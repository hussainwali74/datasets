[
    {
        "Question": "ڈی ایس اے",
        "Answer": "مخفف ڈی ایس اے کئی مختلف چیزوں کا حوالہ دے سکتا ہے: امریکہ کے ڈیموکریٹک سوشلسٹ (ڈی ایس اے): یہ ریاستہائے متحدہ میں سب سے بڑی سوشلسٹ تنظیم ہے ، جس میں تمام 50 ریاستوں میں 92،000 سے زیادہ ممبران اور ابواب ہیں۔یہ ایک سیاسی اور کارکن تنظیم ہے جو قانون سازی سے لے کر براہ راست ایکشن 123 تک مختلف حربوں کے ذریعہ کام کرنے والوں کو بااختیار بنانے کے لئے اصلاحات کا مقابلہ کرتی ہے۔ ڈائریکٹ سیلنگ ایسوسی ایشن (ڈی ایس اے): یہ ان کمپنیوں کے لئے نیشنل ٹریڈ ایسوسی ایشن ہے جو صارفین کو براہ راست مارکیٹ اور خدمات کی مارکیٹنگ کرتی ہے۔ایک آزاد سیلز فورس کے ذریعے۔ڈی ایس اے براہ راست فروخت ہونے والی کمپنیوں اور ان کی آزاد سیلز فورس کو زیادہ کامیاب ہونے میں مدد فراہم کرتے ہوئے براہ راست فروخت کی صنعت کو فروغ دینے ، حفاظت اور پولیس کے لئے کام کرتا ہے۔یہ براہ راست فروخت ہونے والے پیشہ ور افراد کے لئے تعلیمی مواقع فراہم کرتا ہے اور ان کے ساتھ کام کرتا ہے تاکہ ضابطے کی تعمیل کو یقینی بنایا جاسکے۔ ریاستی آرکیٹیکٹ (ڈی ایس اے) کی تقسیم: یہ کیلیفورنیا کے محکمہ جنرل سروسز کا ایک ڈویژن ہے جو ساختی حفاظت سے متعلق تعمیراتی کوڈ کے ضوابط میں تبدیلیوں کی تجویز پیش کرتا ہے جس میں ساختی حفاظت سے متعلق عمارت کے ضابطوں میں تبدیلی کی تجویز پیش کی گئی ہے۔کیلیفورنیا کے پبلک کے -12 اسکول ، کمیونٹی کالجز ، ضروری خدمات کی عمارتیں ، اور مختلف دیگر سرکاری اور لیز پر دی گئی سہولیات۔یہ کوڈ کی ضروریات 5. ڈیٹا سسٹمز تجزیہ کاروں ، انکارپوریشن (ڈی ایس اے) کی تعمیل کو یقینی بنانے کے لئے تعمیراتی منصوبوں کی منصوبہ بندی کا جائزہ اور نگرانی بھی فراہم کرتا ہے: یہ ایک ایسی کمپنی ہے جو دفاعی اور وفاقی حکومت کے صارفین کو کاروبار سے چلنے والی انفارمیشن ٹکنالوجی اور مشاورتی حل فراہم کرتی ہے۔یہ محفوظ ، جدید ٹکنالوجی اور انفارمیشن مینجمنٹ حل میں مہارت رکھتا ہے جو اپنے صارفین کو عوام کی خدمت کرنے اور قوم کی حفاظت کرنے کے قابل بناتا ہے۔"
    },
    {
        "Question": "ڈیٹا ڈھانچہ کیا ہے؟",
        "Answer": "ڈیٹا کا ڈھانچہ کمپیوٹر پر ڈیٹا کو منظم کرنے ، انتظام کرنے اور اسٹور کرنے کا ایک طریقہ ہے تاکہ اس تک رسائی ، کارروائی اور موثر انداز میں اپ ڈیٹ ہوسکے۔یہ اعداد و شمار کی اقدار کا ایک مجموعہ ، ان کے مابین تعلقات ، اور افعال یا کام جو ڈیٹا پر لاگو ہوسکتے ہیں۔ڈیٹا ڈھانچے بڑے ڈیٹا بیس اور انٹرنیٹ انڈیکسنگ خدمات جیسے استعمال کے ل effectively موثر طریقے سے ڈیٹا کی بڑی مقدار کو منظم کرنے کا ایک ذریعہ فراہم کرتے ہیں۔مختلف قسم کے ڈیٹا ڈھانچے ہیں ، جن میں لکیری ڈیٹا ڈھانچے اور غیر لکیری ڈیٹا ڈھانچے شامل ہیں۔اعداد و شمار کے ڈھانچے کی کچھ عام مثالوں میں صفیں ، فہرستیں ، درخت اور گراف شامل ہیں۔کسی پروجیکٹ کے لئے صحیح اعداد و شمار کے ڈھانچے کا انتخاب ڈیٹا 123456.1Wikedia2programiz3geeksforgeeks4mygreatlearning5towardsdatacience6simplilearn تک موثر رسائی کو یقینی بنانے کے لئے ضروری ہے۔"
    },
    {
        "Question": "ایک صف اور منسلک فہرست میں کیا فرق ہے؟",
        "Answer": "صفوں اور لنکڈ فہرستیں دونوں لکیری ڈیٹا ڈھانچے ہیں جو اسی طرح کے ڈیٹا کو ذخیرہ کرنے کے لئے استعمال ہوتی ہیں۔تاہم ، وہ متعدد طریقوں سے مختلف ہیں ، جن میں شامل ہیں: مماثل میموری کے مقامات پر ارای اسٹورس ڈیٹا عناصر ، سرنی اشاریہ کا استعمال کرتے ہوئے تیز تر رسائی کی اجازت دیتے ہیں۔ اس سے پہلے اعلان کرنے کی ضرورت ایک مقررہ سائز ، اور خطرے کی وجہ سے رن ٹائم پر ایک صف کا سائز تبدیل نہیں کیا جاسکتا ہے۔اوور رائٹنگ۔ہر ڈیٹا نوڈ اگلے نوڈ کی طرف اشارہ کرتا ہے جہاں اعداد و شمار کو غیر متنازعہ مقامات پر محفوظ کیا جاتا ہے ، اس طرح رن ٹائم کے وقت متحرک سائز کی مختص کرنے کی اجازت دی جاتی ہے۔خلاصہ یہ ہے کہ ، عناصر تک رسائی کے ل arri صفیں تیز ہیں اور ان کا ایک مقررہ سائز ہے ، جبکہ منسلک فہرستیں سائز میں زیادہ لچکدار اور اندراج اور حذف کرنے کی کارروائیوں کے لئے تیز ہیں۔دونوں کے مابین انتخاب کا انحصار ہینڈ 1234.1scaler2geeksforgeeks3towardatascience4studytonight پر مسئلے کی مخصوص ضروریات پر ہے"
    },
    {
        "Question": "ایک اسٹیک قطار سے کیسے مختلف ہے؟",
        "Answer": "اسٹیکس اور قطاریں دونوں لکیری ڈیٹا ڈھانچے ہیں جو ڈیٹا کو اسٹور اور منظم کرنے کے لئے استعمال ہوتے ہیں۔تاہم ، وہ متعدد طریقوں سے مختلف ہیں ، جن میں شامل ہیں: اسٹیک فولوز نے پہلے آؤٹ (LIFO) کے اصول میں آخری (LIFO) اصول ، جس کا مطلب ہے کہ اسٹیک میں شامل آخری عنصر پہلے کو ہٹایا جاتا ہے۔ عناصر کو داخل کرنے اور حذف کرنے کے لئے ایک واحد پوائنٹر (اوپر) کی حیثیت رکھتا ہے۔اسٹیک کا ایک سر۔ قطار کے مقابلے میں ایک آسان عمل درآمد۔ تکرار پر مبنی مسائل کو حل کرنے کے لئے استعمال کیا جاتا ہے۔ پہلے (FIFO) کے اصول میں پہلے کا پہلا عنصر پہلے عنصر کو ہٹایا جاتا ہے۔قطار کے دونوں سروں سے عناصر کو داخل کرنے اور حذف کرنے کے لئے دو پوائنٹرز (سامنے اور پیچھے)۔ اسٹیک کے مقابلے میں زیادہ پیچیدہ عمل درآمد۔، اور قطاریں استعمال کی جاتی ہیں جب پروسیسنگ کا حکم آمد کے وقت پر مبنی ہوتا ہے۔دونوں کے مابین انتخاب کا انحصار ہینڈ 123456.1favtutor2cmu3geeksforgeeks4scaler5everythingComputerscience6javatPoint پر مسئلے کی مخصوص ضروریات پر ہے"
    },
    {
        "Question": "ہیش ٹیبل کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ایک ہیش ٹیبل ، جسے ہیش میپ کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو اقدار کی کلیدوں کا نقشہ بناتا ہے۔یہ ہیشنگ نامی ایک تکنیک کا ایک حصہ ہے ، جس میں سے دوسرا ہیش فنکشن ہے۔ایک ہیش فنکشن ایک الگورتھم ہے جو ایک انڈیکس تیار کرتا ہے جہاں ایک قدر مل سکتی ہے یا ہیش ٹیبل میں محفوظ کی جاسکتی ہے۔ہیش فنکشن کلید کو ان پٹ کے طور پر لیتا ہے اور ہیش ٹیبل میں ایک انڈیکس لوٹاتا ہے جہاں متعلقہ قیمت مل سکتی ہے۔ہیش ٹیبل کلیدی قیمت کے جوڑے کو ذخیرہ کرنے کے لئے منسلک فہرستوں کی ایک صف کا استعمال کرتا ہے۔جب ہیش ٹیبل میں کلیدی قدر کی جوڑی داخل کی جاتی ہے تو ، ہیش فنکشن انڈیکس کا تعین کرنے کے لئے استعمال کیا جاتا ہے جہاں جوڑی کو محفوظ کیا جانا چاہئے۔اگر اس انڈیکس میں پہلے سے ہی کلیدی قدر کی جوڑی محفوظ ہے تو ، تصادم ہوتا ہے۔تصادم کو سنبھالنے کے ل the ، ہیش ٹیبل میں زنجیروں کے نام سے ایک تکنیک کا استعمال کیا گیا ہے ، جہاں انڈیکس میں ایک لنکڈ فہرست تیار کی گئی ہے تاکہ اس انڈیکس میں ہیش ہیش کو ذخیرہ کیا جاسکے۔جب ہیش ٹیبل میں کسی قدر کی تلاش کرتے ہو تو ، ہیش فنکشن انڈیکس کا تعین کرنے کے لئے استعمال ہوتا ہے جہاں قیمت کو ذخیرہ کیا جانا چاہئے۔اگر اس انڈیکس میں کلیدی قدر کی جوڑی محفوظ ہے تو ، قیمت کو تلاش کرنے کے لئے منسلک فہرست کی تلاش کی جاتی ہے۔ہیش ٹیبلز کو ڈیٹا (یا ریکارڈ) کو جلدی سے ذخیرہ کرنے اور بازیافت کرنے کے لئے استعمال کیا جاتا ہے اور عام طور پر ڈیٹا بیس ، مرتب کرنے والوں ، اور نیٹ ورک میں استعمال ہوتے ہیں۔"
    },
    {
        "Question": "درختوں کا ڈیٹا ڈھانچہ کیا ہے اور اس کی مختلف اقسام کیا ہیں؟",
        "Answer": "ایک درخت ایک غیر لکیری درجہ بندی کے اعداد و شمار کا ڈھانچہ ہے جس میں کناروں سے منسلک نوڈس پر مشتمل ہوتا ہے۔اس کا استعمال درجہ بندی کے اعداد و شمار کو ذخیرہ کرنے کے لئے کیا جاتا ہے ، جیسے فائل سسٹم یا خاندانی درخت۔درختوں کو ان کے پاس بچوں کے نوڈس کی تعداد کی بنیاد پر درجہ بندی کیا جاتا ہے ، اور درختوں کی کچھ عام اقسام یہ ہیں: بائنری ٹری: ایک درخت جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچوں کے نوڈس ہوتے ہیں ، بائیں اور دائیں۔ بائنری تلاش کا درخت: ایک بائنری ٹری: بائنری تلاش کا درختجس میں بائیں بچے کا نوڈ والدین نوڈ سے کم ہوتا ہے ، اور دائیں بچے کا نوڈ والدین نوڈ سے زیادہ ہوتا ہے۔زیادہ تر ایک میں۔ بی ٹری: ایک درخت کے اعداد و شمار کا ڈھانچہ جو ڈسک تک رسائی کے ل optim بہتر بنایا جاتا ہے اور عام طور پر ڈیٹا بیس اور فائل سسٹم میں استعمال ہوتا ہے۔ ٹریوں کو ڈیٹا کے مابین درجہ بندی کے تعلقات کی نمائندگی کرنے اور موثر تلاشی ، اندراج اور حذف کرنے کی کارروائیوں کی فراہمی کے لئے استعمال کیا جاتا ہے۔وہ کمپیوٹر سائنس اور پروگرامنگ میں بڑے پیمانے پر استعمال ہوتے ہیں ، بشمول ڈیٹا بیس ، کمپائلرز ، اور نیٹ ورک روٹرز 123456.1 شیکشا 2 یو پی جی آر اے ڈی 3 پی آر او ایم آر آئی ایم 4 وکیپیڈیا 5 جانکاری ہیٹ 6 جی ای ای ایکس فورسفجیکس"
    },
    {
        "Question": "آپ ترتیب شدہ صف میں بائنری سرچ الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "ایک ترتیب شدہ صف پر بائنری سرچ الگورتھم کو نافذ کرنے کے ل you ، آپ ان مراحل پر عمل کرسکتے ہیں: تلاش کی جگہ کی نچلی اور اوپری حدود کو بالترتیب سرنی کے پہلے اور آخری اشارے پر سیٹ کریں۔نچلے اور اوپری حدود کی اوسط۔ مڈل انڈیکس میں قیمت کو ہدف کی قیمت کے ساتھ ملاحظہ کریں۔ اگر مڈل انڈیکس کی قیمت ہدف کی قیمت کے برابر ہے تو ، انڈیکس کو واپس کریں۔ اگر مڈل انڈیکس میں قیمت ہدف سے زیادہ ہے۔قدر ، اوپری پابند کو درمیانی انڈیکس مائنس ایک کے لئے اپ ڈیٹ کریں۔ اگر مڈل انڈیکس کی قیمت ہدف کی قیمت سے کم ہے تو ، نچلے حد کو درمیانی انڈیکس کے علاوہ ایک کے لئے اپ ڈیٹ کریں۔پایا یا تلاش کی جگہ ختم ہوگئی ہے۔ بائنری تلاش ایک ترتیب شدہ صف کی تلاش کے ل an ایک موثر الگورتھم ہے ، جس میں او (لاگ این) کی وقت کی پیچیدگی ہوتی ہے ، جہاں N صف کا سائز ہوتا ہے۔یہ کمپیوٹر سائنس اور پروگرامنگ میں وسیع پیمانے پر استعمال ہوتا ہے ، بشمول ڈیٹا بیس ، کمپائلرز ، اور نیٹ ورک روٹرز 123456.1educative2wikeipedia3khanacademy4edureka5isever6programiz"
    },
    {
        "Question": "ٹری ڈیٹا ڈھانچہ کیا ہے اور یہ کیسے مفید ہے؟",
        "Answer": "ایک ٹری (جس کا اعلان \"کوشش کریں\") درخت پر مبنی ڈیٹا ڈھانچہ ہے جو بعض اوقات کسی سابقہ درخت یا ڈیجیٹل درخت کے نام سے بھی جانا جاتا ہے۔یہ ایک درخت ہے جو ڈیٹا کو آرڈر اور موثر انداز میں محفوظ کرتا ہے۔ٹرائی کے ہر نوڈ میں زیادہ سے زیادہ 26 حوالہ جات (پوائنٹرز) ہوسکتے ہیں ، اور ہر نوڈ ایک کردار اور بولین قدر پر مشتمل ہوتا ہے جو اس پر عمل درآمد کے لئے استعمال ہوتا ہے کہ آیا یہ کردار کلام کے اختتام کی نمائندگی کرتا ہے یا نہیں۔کوششیں عام طور پر تاروں کو ذخیرہ کرنے کے لئے استعمال کی جاتی ہیں اور وہ الگورتھم کے مماثل ہوتے ہیں ، کیونکہ وہ ہر تار کے سابقہ پر مبنی ہوتے ہیں۔انفرادی تاروں کے بجائے تاروں کے گروہوں سے نمٹنے کے وقت عام طور پر کوششیں کی جاتی ہیں ، جس سے وہ وسیع پیمانے پر مسائل حل کرنے کے قابل بناتے ہیں۔ٹری ڈیٹا ڈھانچے کو استعمال کرنے کے کچھ فوائد میں او (ایل) وقت میں تیز رفتار اندراج اور تاروں کی تلاش شامل ہے ، جہاں ایل ایک لفظ کی لمبائی کی نمائندگی کرتا ہے۔یہ بائنری سرچ ٹری اور ہیشنگ سے تیز تر ہے کیونکہ اس کے نفاذ کے طریقوں کی وجہ سے۔کوششیں کسی بھی زبان کے ڈور کو ذخیرہ کرسکتی ہیں ، کیونکہ وہ انکوڈنگ کے بجائے ڈور کے کرداروں پر مبنی ہیں۔کوششیں مؤثر طریقے سے پریفکس سرچ (یا آٹو مکمل) کرنے اور تمام الفاظ کو حروف تہجی کی ترتیب میں پرنٹ کرنے کے لئے بھی کارآمد ہیں ، جو ہیشنگ سے آسانی سے ممکن نہیں ہیں۔تاہم ، ایک ٹری ایک بہت ہی مہارت والا ڈیٹا ڈھانچہ ہے جس میں درختوں اور فہرستوں سے کہیں زیادہ میموری کی ضرورت ہوتی ہے ، اور یہ تمام قسم کے ڈیٹا 123456.1 اسٹوڈٹونائٹ 2 جی ای ای ای ہسفور جی ای ای ای ایس 3 ٹی او پی ٹی ایل 4 ہیکیررتھ 5 وکیپیڈیجینوس کے لئے موزوں نہیں ہے۔"
    },
    {
        "Question": "جب آپ ہیپ ڈیٹا ڈھانچہ استعمال کریں گے؟",
        "Answer": "مختلف ایپلی کیشنز میں ہیپ ڈیٹا کا ڈھانچہ مفید ہے ، بشمول: ترجیحی قطاریں: ہیپ ڈیٹا ڈھانچہ عام طور پر ترجیحی قطار کو نافذ کرنے کے لئے استعمال ہوتا ہے ، جہاں اعلی ترجیح والے عناصر کو پہلے نکالا جاتا ہے۔یہ بہت ساری ایپلی کیشنز میں مفید ہے جیسے شیڈولنگ ٹاسک ، رکاوٹوں سے نمٹنے اور پروسیسنگ کے واقعات۔ہیپ ڈیٹا ڈھانچہ اعلی ترجیحی کام تک موثر رسائی کی اجازت دیتا ہے ، جس سے ملازمت کے شیڈولنگ ایپلی کیشنز 123 کے لئے ایک مفید ڈیٹا ڈھانچہ بنتا ہے۔اس میں O (n لاگ این) کی وقت کی پیچیدگی ہے ، جس سے یہ بڑے ڈیٹاسیٹس 24 کے لئے موثر ہے۔یہ الگورتھم ایک گراف 3 میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتے ہیں۔ آرڈر کے اعدادوشمار: ہیپ ڈیٹا ڈھانچہ کو ایک سرنی 3 میں کے ٹی ایچ ٹی کے سب سے بڑے/سب سے چھوٹے عنصر کو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔سیکیورٹی کے ساتھ اور سرایت شدہ نظاموں جیسے لینکس کرنل 3۔مری سمری میں بھی ، ہیپ ڈیٹا ڈھانچہ ایسی ایپلی کیشنز میں مفید ہے جس میں اعلی ترجیحی عنصر تک موثر رسائی کی ضرورت ہوتی ہے ، الگورتھم ، گراف الگوریتھم ، آرڈر کے اعدادوشمار ، اور ایمبیڈڈ سسٹمز 1243.1 جی ای ای ایکسفورجیکس 2 جی ای ای ایکس 3 پی پی ای پی ایس 3"
    },
    {
        "Question": "متحرک پروگرامنگ کے تصور کی وضاحت کریں۔",
        "Answer": "متحرک پروگرامنگ ایک ایسی تکنیک ہے جو کمپیوٹر پروگرامنگ میں استعمال کی جاتی ہے تاکہ پیچیدہ مسائل کو چھوٹے چھوٹے مسائل میں توڑ کر اور ایک بار ہر ذیلی پروبل کو حل کیا جاسکے ، میموری میں ذیلی مسائل کے حل کو ذخیرہ کیا جاسکے ، اور بار بار گنتی سے بچنے کے ل them ان کو دوبارہ استعمال کیا جاسکے۔یہ تکنیک زیادہ سے زیادہ ساخت کے اصول پر مبنی ہے ، جس کا مطلب ہے کہ کسی مسئلے کا زیادہ سے زیادہ حل اس کے ذیلی مسائل کے زیادہ سے زیادہ حل سے بنایا جاسکتا ہے۔متحرک پروگرامنگ ان مسائل کو حل کرنے میں کارآمد ہے جس میں ذیلی خطوط اور زیادہ سے زیادہ ساختہ پراپرٹی کو اوور لیپنگ ہے۔یہ بنیادی طور پر سادہ تکرار کے مقابلے میں ایک اصلاح ہے اور وقت کی پیچیدگیوں کو کفایت شعاری سے کثیر الجہتی تک کم کرتا ہے۔متحرک پروگرامنگ کا اطلاق کسی بھی مسئلے پر کیا جاسکتا ہے جس کے لئے حتمی حل تک پہنچنے کے لئے کچھ اقدار کے دوبارہ حساب کتاب کی ضرورت ہوتی ہے۔متحرک پروگرامنگ کا استعمال کرتے ہوئے ان مسائل کی کچھ مثالوں کو جن میں حل کیا جاسکتا ہے ان میں گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنا ، الگورتھم کو چھانٹنا ، اور ایک صف میں کے ٹی ایچ ٹی ایچ ٹی ایچ ٹی ٹی ایچ کے سب سے بڑے/سب سے چھوٹے عنصر کی تلاش شامل ہے۔متحرک پروگرامنگ کا اطلاق دو طریقوں سے کیا جاسکتا ہے: اوپر سے نیچے اور نیچے۔ٹاپ ڈاون کو میموائزیشن کے نام سے بھی جانا جاتا ہے ، جہاں ذیلی مسائل کے نتائج مستقبل کے حوالہ کے لئے میموری میں محفوظ ہوتے ہیں۔نیچے اپ کو ٹیبلولیشن کے نام سے بھی جانا جاتا ہے ، جہاں ذیلی مسائل کے نتائج ایک ٹیبل میں محفوظ ہوتے ہیں اور بڑے ذیلی مسائل کو حل کرنے کے لئے استعمال ہوتے ہیں۔متحرک پروگرامنگ ایک طاقتور تکنیک ہے جو پیچیدہ مسائل کو موثر انداز میں حل کرنے میں مدد فراہم کرسکتی ہے۔"
    },
    {
        "Question": "چوڑائی کی پہلی اور گہرائی کی پہلی تلاش کے مابین اختلافات کی وضاحت کریں۔",
        "Answer": "چوڑائی کی پہلی تلاش (بی ایف ایس) اور گہرائی سے پہلے تلاش (ڈی ایف ایس) دو الگورتھم ہیں جو درخت یا گراف ڈیٹا کے ڈھانچے کو عبور کرنے/تلاش کرنے کے لئے استعمال ہوتی ہیں۔بی ایف ایس اور ڈی ایف ایس کے مابین اہم اختلافات یہ ہیں: چوڑائی کی پہلی تلاش (بی ایف ایس) روٹ نوڈ (یا کسی گراف کے کچھ صوابدیدی نوڈ) سے شروع ہوتی ہے اور اگلے درجے کے پڑوسیوں میں جانے سے پہلے سب سے پہلے پڑوسی نوڈس کی کھوج کرتی ہے۔سورس ورٹیکس سے ان کے فاصلے کا حکم ، جہاں ماخذ کے راستے کی کم سے کم لمبائی نوڈ تک ہوتی ہے۔ نوڈس کو ذخیرہ کرنے کے لئے ایک قطار کے اعداد و شمار کا ڈھانچہ بناتا ہے جس کے بعد اگلے تلاش کرنے کی ضرورت ہوتی ہے۔شروع اور گول نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے غیر وزن والے گراف میں دو نوڈس۔بیک ٹریکنگ سے پہلے برانچ۔ ایک اسٹیک ڈیٹا ڈھانچہ بناتا ہے جس کو اگلے تلاش کرنے کی ضرورت ہے۔.س اکثر حقیقی دنیا میں کھیلوں اور کھیل جیسے حالات کی نقالی میں استعمال ہوتا ہے۔ خلاصہ میں ، بی ایف ایس اور ڈی ایف دو مختلف الگورتھم ہیں جو درخت یا گراف ڈیٹا ڈھانچے کو عبور کرنے/تلاش کرنے کے لئے استعمال ہوتے ہیں۔بی ایف ایس کا استعمال غیر وزن والے گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے کیا جاتا ہے ، جبکہ ڈی ایف ایس کو دو نوڈس کے درمیان لمبا ترین راستہ تلاش کرنے کے لئے استعمال کیا جاتا ہے۔دونوں کے مابین انتخاب کا انحصار ہینڈ 123456.1 اسٹیک اوور فلو 2 کوڈکیڈیمی 3 ٹکیڈ لائٹ 4 بیڈنگ 5 ٹیوٹوریلس پوائنٹ 6 جی ای ای ایکسفورجیکس پر مسئلے کی مخصوص ضروریات پر ہے"
    },
    {
        "Question": "یادداشت کیا ہے اور متحرک پروگرامنگ میں اس کا استعمال کس طرح ہوتا ہے؟",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ ایک کثیر الجہتی وقت کے حل کے لئے ایک کفایت شعاری وقت حل کے لئے اوورلیپنگ ذیلی خطوط کے حل کو بہتر بنایا جاسکے۔اس میں مہنگے فنکشن کالز کے نتائج کو ذخیرہ کرنا اور کیشڈ کے نتائج کو واپس کرنا شامل ہے جب وہی آدانوں کو دوبارہ ہوتا ہے۔متحرک پروگرامنگ کے ساتھ کسی مسئلے کو حل کرنے کے لئے میمورائزیشن ٹاپ ڈاون نقطہ نظر ہے۔اسے میموائزیشن کہا جاتا ہے کیونکہ ہم ہر مسئلے کو حل کرنے سے لوٹنے والی اقدار کے لئے ایک میمو ، یا \"خود کو نوٹ\" بنائیں گے۔پھر ، جب ہمیں ایک بار پھر ایک ہی پریشانی کا سامنا کرنا پڑتا ہے تو ، ہم صرف میمو کی جانچ کرتے ہیں ، اور ، دوسرے (یا تیسرے یا چوتھے) بار مسئلے کو حل کرنے کے بجائے ، ہم اپنے میمو سے حل بازیافت کرتے ہیں۔میمورائزیشن عام طور پر نفاذ کے لئے زیادہ بدیہی ہوتی ہے ، خاص طور پر جب ہم ذیلی مسائل کا حل نہیں جانتے ہیں ، جبکہ ٹیبلولیشن کے لئے ہمیں ذیلی مسائل کا حل جاننے کی ضرورت ہوتی ہے۔میمورائزیشن متحرک پروگرامنگ میں ایک عام حکمت عملی ہے ، ایک کمپیوٹر پروگرامنگ تکنیک جس میں ایک بڑے مسئلے کو اوور لیپنگ سب پروبلوں میں توڑنا شامل ہے۔بہتر رن ٹائم کے ل computer کمپیوٹر میموری کے استعمال کو تجارت کرکے ، میموزائزیشن کچھ دوسری صورت میں پیچیدہ تکرار کرنے والے افعال کو ممکن بناتی ہے۔یادداشت کو مختلف ایپلی کیشنز میں استعمال کیا جاتا ہے ، بشمول گراف میں دو نوڈس کے مابین مختصر ترین راستہ تلاش کرنا ، الگورتھم کو چھانٹنا ، اور KTH کا سب سے بڑا/سب سے چھوٹا عنصر تلاش کرنا ایک Array123456.1algodaily2radford3jarednielsen4stackoverflow5inventwithonethonthonthonthonthonthonthonthonthonthonthonthonthonthonthonthonthonthonthonthonthontwithon6hackreearthonthhackerehachethont"
    },
    {
        "Question": "کیا آپ وضاحت کرسکتے ہیں کہ سرخ رنگ کا درخت کیسے کام کرتا ہے؟",
        "Answer": "ایک سرخ رنگ کا درخت ایک خود متوازن بائنری سرچ درخت ہے جو ڈیٹا کو ترتیب دینے کے انداز میں ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔یہ بائنری سرچ ٹری کی ایک قسم ہے جس میں ایک اضافی معلومات ہوتی ہے ، جسے رنگ کہتے ہیں ، ہر نوڈ سے وابستہ ہے۔ہر نوڈ کا رنگ یا تو سرخ یا سیاہ ہوتا ہے۔سرخ رنگ کا درخت مندرجہ ذیل خصوصیات کو پورا کرتا ہے: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ نوڈ سیاہ ہے۔ ہر پتی نوڈ (کال) سیاہ ہے۔ اگر نوڈ سرخ ہے تو پھر اس کے دونوں بچے سیاہ ہیں۔نوڈ کو اس کی اولاد پتی نوڈس میں ایک ہی تعداد میں سیاہ نوڈس ہوتے ہیں۔ سرخ رنگ کا درخت ایک متوازن درخت ہے ، جس کا مطلب ہے کہ درخت کی اونچائی ہمیشہ O (لاگ این) ہوتی ہے ، جہاں N درخت میں نوڈس کی تعداد ہوتی ہےسرخ رنگ کا درخت آرڈر 4 کے بی ٹری سے ملتا جلتا ہے ، جہاں ہر نوڈ میں 1 اور 3 اقدار اور (اس کے مطابق) 2 اور 4 چائلڈ پوائنٹرز کے درمیان شامل ہوسکتے ہیں۔سرخ سیاہ درخت کو ترتیب شدہ انداز میں ڈیٹا کو ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے اور عام طور پر کمپیوٹر سائنس میں تقابلی اعداد و شمار کے ٹکڑوں کو منظم کرنے کے لئے استعمال کیا جاتا ہے ، جیسے ٹیکسٹ ٹکڑے یا نمبر۔ریڈ بلیک ٹری مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، بشمول ڈیٹا بیس ، کمپائلرز ، اور نیٹ ورک روٹرز 123456.1 پاور وولفرم | الفا 2 وکیپیڈیا 3 پروگگرامائز 4 اے یو سی ایل لینڈ 5ومیچ 6 جےواٹ پوائنٹ"
    },
    {
        "Question": "ترجیحی قطار کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ترجیحی قطار ایک خاص قسم کی قطار ہے جس میں ہر عنصر ترجیحی قیمت سے وابستہ ہوتا ہے ، اور عناصر کو ان کی ترجیح کی بنیاد پر پیش کیا جاتا ہے۔یعنی ، اعلی ترجیحی عناصر کو پہلے پیش کیا جاتا ہے۔تاہم ، اگر ایک ہی ترجیح والے عناصر واقع ہوتے ہیں تو ، ان کو قطار میں اپنے آرڈر کے مطابق پیش کیا جاتا ہے۔ترجیح تفویض کرنے کے لئے خود عنصر کی قدر پر غور کیا جاتا ہے۔مثال کے طور پر ، اعلی قیمت والے عنصر کو اعلی ترجیحی عنصر سمجھا جاتا ہے۔تاہم ، دوسرے معاملات میں ، ہم اعلی ترجیحی عنصر کی حیثیت سے سب سے کم قیمت کے ساتھ عنصر کو فرض کرسکتے ہیں۔ہم اپنی ضروریات کے مطابق ترجیحات بھی طے کرسکتے ہیں۔ایک قطار میں ، پہلے ان فرسٹ آؤٹ اصول کو نافذ کیا جاتا ہے ، جبکہ ترجیحی قطار میں ، اقدار کو ترجیح کی بنیاد پر ہٹا دیا جاتا ہے۔سب سے زیادہ ترجیح والا عنصر پہلے ہٹا دیا جاتا ہے۔ترجیحی قطاروں میں دوسرے الگورتھم میں بہت سی درخواستیں ہیں جیسے ڈجکسٹرا اور شیڈولنگ الگورتھم۔ترجیحی قطاریں ان نظاموں کے لئے بہت اہم ہیں جو متعدد پروگراموں اور ان کی پھانسی کو گھماتے ہیں (پروگراموں کو ان کی ترجیح کی بنیاد پر چلانے کے لئے منتخب کیا جاتا ہے)۔وہ انٹرنیٹ کی طرح نیٹ ورکنگ سسٹم کے لئے بھی بہت اہم ہیں ، کیونکہ وہ اس بات کو یقینی بنانے کے لئے اہم اعداد و شمار کو ترجیح دینے میں مدد کرسکتے ہیں کہ یہ تیزی سے گزرتا ہے۔ترجیحی قطاروں کو سرنی ، منسلک فہرست ، ڈھیر ، یا بائنری سرچ ٹری کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ہر طریقہ کے اپنے فوائد اور نقصانات ہیں ، اور بہترین انتخاب آپ کی درخواست کی مخصوص ضروریات پر منحصر ہوگا۔"
    },
    {
        "Question": "آپ بلبلا ترتیب والے الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "بلبلا ترتیب والے الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: N عناصر کی غیر ترتیب شدہ صف سے شروع کریں۔ سرنی کے پہلے اور دوسرے عناصر کو رکھیں۔اگر پہلا عنصر دوسرے عنصر سے بڑا ہے تو ، ان کو تبدیل کریں۔ عناصر کے اگلے جوڑے ، یعنی دوسرے اور تیسرے عناصر کی طرف جائیں۔ان کا موازنہ کریں اور اگر ضروری ہو تو تبادلہ کریں۔ عناصر کی آخری جوڑی تک اس عمل پر عمل کریں ، یعنی (N-1) Th اور Nth عناصر کا موازنہ کیا جاتا ہے اور اگر ضروری ہو تو اس کو تبدیل کیا جاتا ہے۔ 2-4 N-1 مرتبہ ریپیٹ اقدامات ، جہاں N ہےسرنی میں عناصر کی تعداد۔ ہر تکرار کے بعد ، سب سے بڑا عنصر سرنی کے اختتام پر منتقل ہوجائے گا۔ جب مزید تبادلہ کی ضرورت نہیں ہے تو سرنی ترتیب دی جاتی ہے۔ بوبل ترتیب ایک سادہ چھانٹنے والا الگورتھم ہے جو سمجھنے اور اس پر عمل درآمد آسان ہے۔تاہم ، یہ بڑے ڈیٹاسیٹس کے لئے موثر نہیں ہے ، کیونکہ اس کی اوسط اور بدترین وقت کی پیچیدگی کافی زیادہ ہے۔بلبلے کی طرح o (n^2) کی وقت کی پیچیدگی ہوتی ہے ، جہاں N صف میں عناصر کی تعداد ہوتی ہے۔بلبلا کی طرح تعلیمی مقاصد اور چھوٹے ڈیٹاسیٹس کو چھانٹنے کے ل useful مفید ہے۔جب ان پٹ کو تقریبا start ترتیب دیا جاتا ہے تو یہ بھی مفید ہے ، کیونکہ اس میں صف کو ترتیب دینے کے لئے صرف چند تکرار کی ضرورت ہوتی ہے۔بلبلا ترتیب کو مختلف پروگرامنگ زبانوں جیسے سی ، سی ++ ، جاوا ، ازگر ، اور جاواوسکرپٹ 123456.1 اسٹوڈٹونائٹ 2 جےواٹپوائنٹ 3 جی ای ای ایکسفور جی ای ای ایکس 4 فرییکوڈکیمپ 5 فیرکوڈکیمپ کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔"
    },
    {
        "Question": "اکیلا اور دوگنا منسلک فہرست میں کیا فرق ہے؟",
        "Answer": "اکیلے اور دوگنا لنکڈ فہرستیں دو قسم کے منسلک فہرستوں ہیں جو ڈیٹا کو لکیری انداز میں اسٹور کرنے کے لئے استعمال ہوتی ہیں۔دونوں کے مابین اہم اختلافات یہ ہیں: واحد منسلک فہرست میں اکیلے لنکڈ لسٹچ نوڈ میں دو فیلڈز شامل ہیں: فہرست میں اگلے نوڈ کا ڈیٹا اور ایک پوائنٹر۔دم۔ آسانی سے منسلک فہرستوں کو دوگنا منسلک فہرستوں کے مقابلے میں کم میموری کی ضرورت ہوتی ہے ، کیونکہ وہ صرف ایک نوڈ میں ایک پوائنٹر اسٹور کرتے ہیں۔ دوگنا لنکڈ فہرست میں ڈولی سے منسلک لسٹچ نوڈ میں تین فیلڈز شامل ہیں: ڈیٹا ، فہرست میں اگلے نوڈ کا ایک پوائنٹر ، اور ایک پوائنٹرفہرست میں پچھلے نوڈ پر۔ دل سے منسلک فہرستوں کو دونوں سمتوں میں ، سر سے دم اور دم سے سر تک جانے والی دونوں سمتوں میں عبور کیا جاسکتا ہے۔. خلاصہ میں ، اکیلے لنکڈ فہرستیں اور دوگنا منسلک فہرستیں دو قسم کی منسلک فہرستیں ہیں جو ڈیٹا کو لکیری انداز میں اسٹور کرنے کے لئے استعمال ہوتی ہیں۔اکیلے لنکڈ فہرستیں ایک نوڈ میں ایک پوائنٹر اسٹور کرتی ہیں اور اسے صرف ایک ہی سمت میں سفر کیا جاسکتا ہے ، جبکہ دوگنا منسلک فہرستیں ہر نوڈ میں دو پوائنٹرز اسٹور کرتی ہیں اور دونوں سمتوں میں سفر کی جاسکتی ہیں۔"
    },
    {
        "Question": "ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی کیا ہے؟",
        "Answer": "ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی اوسطا O (1) ہے ، جس کا مطلب ہے کہ ہیش ٹیبل میں کسی عنصر کی تلاش میں مستقل وقت لگتا ہے۔اس کی وجہ یہ ہے کہ عنصر کے اشاریہ کا حساب لگانے کے لئے استعمال ہونے والا ہیش فنکشن عناصر کو یکساں طور پر ٹیبل پر تقسیم کرنے کے لئے ڈیزائن کیا گیا ہے ، اور اس ٹیبل کو تصادم کو موثر انداز میں سنبھالنے کے لئے ڈیزائن کیا گیا ہے۔تاہم ، بدترین صورت میں ، ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی O (n) ہوسکتی ہے ، جس کا مطلب ہے کہ ہیش ٹیبل میں کسی عنصر کی تلاش میں لکیری وقت درکار ہوتا ہے۔یہ اس وقت ہوتا ہے جب ہیش ٹیبل میں موجود تمام عناصر کے پاس ایک ہی انڈیکس کے نقشے کی چابیاں ہوتی ہیں۔عام طور پر ، ہیش ٹیبلز تلاش کرنے ، داخل کرنے اور حذف کرنے کے ل very بہت موثر ہیں ، اور وہ عام طور پر کمپیوٹر سائنس میں ایسوسی ایٹو اریوں ، سیٹوں اور کیچوں کو نافذ کرنے کے لئے استعمال ہوتے ہیں۔ہیش ٹیبل آپریشنز کی وقت کی پیچیدگی کا انحصار ہیش ٹیبل کے مخصوص نفاذ اور تصادم کی ریزولوشن کی قسم پر ہوتا ہے جس کا استعمال 123456.1opengenus2baeldung3libretexts4stackexchange5stackage6stackoverflow"
    },
    {
        "Question": "سرکلر بفر کیا ہے اور اس کے کیا فوائد ہیں؟",
        "Answer": "ایک سرکلر بفر ، جسے سرکلر قطار یا رنگ بفر بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ڈیٹا کو ذخیرہ کرنے کے لئے ایک مقررہ سائز کا بفر استعمال کرتا ہے۔بفر کے ساتھ ایسا سلوک کیا جاتا ہے جیسے یہ اختتام سے آخر میں منسلک ہو ، اور جب بفر بھرا ہوا ہو تو ، نیا ڈیٹا بفر میں قدیم ترین ڈیٹا کو اوور رائٹ کرتا ہے۔سرکلر بفرز عام طور پر مختلف ایپلی کیشنز میں استعمال ہوتے ہیں ، بشمول مواصلات پروٹوکول جیسے سیریل اور متوازی بندرگاہوں ، ڈیجیٹل سگنل پروسیسنگ ، نیٹ ورک روٹرز ، اور پیکٹ سوئچنگ کے ل device ڈیوائس ڈرائیور بھی شامل ہیں۔سرکلر بفر کو استعمال کرنے کے فوائد میں شامل ہیں: میموری کا موثر استعمال: سرکلر بفر مستقل سائز کے بفر کا استعمال کرتے ہیں گویا یہ اختتام سے آخر تک لنک کرتا ہے ، جو میموری اور میموری کے بہتر استعمال کے موثر استعمال کی اجازت دیتا ہے۔عناصر کو شامل کرنے اور اسے ہٹانے کے لئے مستقل وقت کی پیچیدگی رکھیں ، جو اوور فلو کی غلطیوں سے پرہیز کرتا ہے اور اعداد و شمار تک تیز تر رسائی کی اجازت دیتا ہے۔ ریئل ٹائم سسٹم کے لئے قابل عمل: سرکلر بفر ریئل ٹائم سسٹم میں کارآمد ہیں کیونکہ وہ موثر اسٹوریج اور ڈیٹا کی منتقلی کی اجازت دیتے ہیں۔سرکلر بفر ڈیجیٹل سگنل پروسیسرز کا ایک اہم عنصر ہیں اور بہت سے ڈی ایس پی پروگرامنگ ایپلی کیشنز میں استعمال ہوتے ہیں۔سرکلر بفر ڈیٹا کو ذخیرہ کرنے کا ایک بہت ہی موثر طریقہ ہے ، اور یہ ترتیب شدہ انداز میں اقدار/اشیاء کی سلائیڈنگ/حرکت پذیر فہرست کو موثر انداز میں برقرار رکھنے کے لئے ایک مفید طریقہ کار ہے۔سرکلر بفرز کو نافذ کرنا آسان ہے اور یہ ایک اچھا انتخاب ہے جب آپ کو ایک مقررہ مقدار میں اعداد و شمار کو ذخیرہ کرنے کی ضرورت ہوتی ہے اور متحرک طور پر مختص کرنے اور میموری کو جمع کرنے کے اوور ہیڈ سے بچنا چاہتے ہیں۔"
    },
    {
        "Question": "متوازن سرچ درخت میں سست لوڈنگ کے تصور کی وضاحت کریں۔",
        "Answer": "سست لوڈنگ ایک ایسی تکنیک ہے جو متوازن تلاش کے درختوں میں استعمال ہوتی ہے جب تک کہ اس کی ضرورت نہ ہو ڈیٹا کی لوڈنگ کو موخر کیا جاسکے۔متوازن سرچ درخت میں ، نوڈس کو میموری میں لادا جاتا ہے کیونکہ ان تک تلاش کے آپریشن کے دوران ان تک رسائی حاصل ہوتی ہے۔تاہم ، ایک سست لوڈنگ نقطہ نظر میں ، نوڈس کو میموری میں لوڈ نہیں کیا جاتا ہے جب تک کہ ان کی ضرورت نہ ہو۔یہ نقطہ نظر ان حالات میں کارآمد ثابت ہوسکتا ہے جہاں تلاش کا درخت بہت بڑا ہے اور میموری کے وسائل محدود ہیں۔جب تک اس کی ضرورت نہ ہو اس وقت تک اعداد و شمار کی بوجھ کو موخر کرنے سے ، میموری کے استعمال کو کم کیا جاسکتا ہے ، اور سرچ آپریشن کو زیادہ موثر بنایا جاسکتا ہے۔تلاش کے مرحلے کے دوران ، سرچ آپریشن معمول کے مطابق انجام دیا جاتا ہے ، لیکن نوڈس کو میموری میں بھری نہیں ہوتی ہے۔اس کے بجائے ، نوڈ کا حوالہ ذخیرہ کیا جاتا ہے ، اور جب تک نوڈ کی ضرورت نہیں ہوتی اس وقت تک بوجھ کا مرحلہ موخر ہوجاتا ہے۔بوجھ کے مرحلے کے دوران ، نوڈ کو میموری میں لادا جاتا ہے ، اور سرچ آپریشن جاری رہتا ہے۔ لیزی لوڈنگ کو مختلف قسم کے متوازن تلاش کے درختوں میں لاگو کیا جاسکتا ہے ، بشمول بائنری تلاش کے درخت اور اے وی ایل کے درخت۔سست لوڈنگ ان حالات میں کارآمد ثابت ہوسکتی ہے جہاں تلاش کا درخت بہت بڑا ہے ، اور میموری کے وسائل محدود ہیں۔جب تک اس کی ضرورت نہ ہو ڈیٹا کی لوڈنگ کو موخر کرکے ، میموری کے استعمال کو کم کیا جاسکتا ہے ، اور سرچ آپریشن کو زیادہ موثر بنایا جاسکتا ہے۔سست لوڈنگ کا استعمال تنازعہ کو کم کرکے اور اسکیل ایبلٹی 1234.1 ویلڈ-انٹر 2 اے آر ایکس آئی وی 3 بی سی 4 این ایل وی کو بہتر بناتے ہوئے ہم آہنگی تلاش کے درختوں کی کارکردگی کو بہتر بنانے کے لئے بھی استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "ریڈکس ترتیب والا الگورتھم کیا ہے؟",
        "Answer": "ریڈکس ترتیب ایک لکیری چھانٹ رہی الگورتھم ہے جو عناصر کو ہندسے کے ذریعہ ہندسے پر کارروائی کرکے ترتیب دیتی ہے۔یہ ایک غیر متنازعہ چھانٹنے والا الگورتھم ہے جو عناصر کو ان کے ریڈکس کے مطابق بالٹیوں میں تخلیق اور تقسیم کرکے موازنہ سے گریز کرتا ہے۔ایک سے زیادہ اہم ہندسوں والے عناصر کے لئے ، ہر ہندسے کے لئے اس بالٹینگ کا عمل دہرایا جاتا ہے ، جبکہ اس سے پہلے کے مرحلے کی ترتیب کو محفوظ رکھتے ہوئے ، جب تک کہ تمام ہندسوں پر غور نہ کیا جائے۔ریڈکس ترتیب فکسڈ سائز کی چابیاں کے ساتھ عدد یا تاروں کے لئے ایک موثر چھانٹنے والا الگورتھم ہے۔عناصر کا براہ راست موازنہ کرنے کے بجائے ، ریڈکس ترتیب ہر ہندسے کی قیمت کی بنیاد پر عناصر کو بالٹیوں میں تقسیم کرتا ہے۔کم سے کم اہم سے لے کر سب سے اہم تک ، ان کے اہم ہندسوں کے ذریعہ عناصر کو بار بار چھانٹ کر ، ریڈکس ترتیب نے حتمی ترتیب شدہ آرڈر کو حاصل کیا۔ریڈکس ترتیب کو مختلف پروگرامنگ زبانوں جیسے ازگر ، جاوا ، سی ++ ، اور سی کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے ، ریڈکس ترتیب کی وقت کی پیچیدگی O (D * (n+b)) ہے ، جہاں D ہندسوں کی تعداد ہے ، n نمبر ہے۔عناصر کی ، اور بی استعمال ہونے والے نمبر کے نظام کی بنیاد ہے۔ریڈکس ترتیب مختلف ایپلی کیشنز میں مفید ہے ، بشمول ڈیجیٹل سگنل پروسیسنگ ، نیٹ ورک روٹرز ، اور پیکٹ سوئچنگ 123456.1 جاواٹپوائنٹ 2wikeipedia3Programiz4simplilearn5Interviewikestart6geeksforgeeks"
    },
    {
        "Question": "بائنری تلاش کے درخت سے اے وی ایل کا درخت کیسے مختلف ہے؟",
        "Answer": "اے وی ایل کے درخت اور بائنری سرچ ٹری (بی ایس ٹی ایس) دونوں بائنری درخت ہیں ، لیکن وہ مندرجہ ذیل طریقوں سے مختلف ہیں: بائنری سرچ ٹرییا بائنری سرچ درخت ایک بائنری درخت ہے جس میں صرف دو شاخیں ہیں جس میں بائیں سبٹری کا ہر نوڈ کم یا برابر ہے اور اس کے برابر ہے اوردائیں سب ٹری میں ہر نوڈ زیادہ ہے۔ بائنری سرچ ٹری ایک درخت کے اعداد و شمار کا ڈھانچہ ہے جو بائنری درخت کی حالت کی پیروی کرتا ہے۔ بائنری سرچ ٹری بائنری تلاش کی خصوصیات کو بھی پیروی کرتا ہے۔ بائنری تلاش کے درخت میں تلاش کرنے کی وقت کی پیچیدگیO (لاگ این) ہے ، جہاں N درخت میں نوڈس کی تعداد ہے۔ بائنری سرچ ٹری کی بدترین وقت کی پیچیدگی O (n) ہے ، جو اس وقت ہوتا ہے جب درخت degenerate ہوتا ہے۔متوازن بائنری سرچ ٹری جہاں بائیں اور دائیں سبٹریز کی اونچائیوں کے درمیان فرق ایک سے زیادہ نہیں ہوسکتا ہے۔ اے ایل کے درخت متوازن درخت ہیں جو تیز رفتار تلاشوں کے ل suitable مناسب شکل کو برقرار رکھتے ہیں۔ درخت خود توازن رکھتے ہیں ، جس کا مطلب ہے کہ وہ خود بخود اپنی شکل کو ایڈجسٹ کرتے ہیں۔توازن کو برقرار رکھنے کے لئے۔ اے وی ایل کے درخت میں تلاش کرنے کی وقت کی پیچیدگی بھی O (لاگ این) ہے۔ اے وی ایل کے درخت کی بدترین وقت کی پیچیدگی بھی O (لاگ این) ہے ، جو بدترین معاملات کے وقت کی پیچیدگی سے بہتر ہے۔بائنری سرچ ٹری میں۔ خلاصہ میں ، اے وی ایل کے درخت اور بائنری تلاش کے درخت دونوں بائنری درخت ہیں ، لیکن اے وی ایل کے درخت بائنری سرچ کے درخت خود کو متوازن کرتے ہیں جو خود بخود ان کی شکل کو ایڈجسٹ کرکے توازن کو برقرار رکھتے ہیں۔بائنری تلاش کے درخت خود توازن نہیں رکھتے ہیں اور ایک منسلک فہرست میں انحطاط کرسکتے ہیں ، جو ان کی تلاش کی کارکردگی کو متاثر کرتا ہے۔اے وی ایل کے درخت تلاش کے ل bin بائنری سرچ درختوں سے زیادہ موثر ہیں ، لیکن ان کو توازن کے عوامل 123456.1 جی ای ای ہسفور جی ای ای ایس 2 جےواٹپوائنٹ 3 ڈبلیو پی آئی 4 بائبلنگ 6youtube کو ذخیرہ کرنے کے لئے زیادہ میموری کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "بلوم فلٹر کیا ہے اور اس کا استعمال کیسے ہوتا ہے؟",
        "Answer": "ایک بلوم فلٹر ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو یہ جانچنے کے لئے استعمال ہوتا ہے کہ آیا عنصر کسی سیٹ کا ممبر ہے یا نہیں۔یہ ایک خلائی موثر ڈیٹا ڈھانچہ ہے جو ہیشنگ پر مبنی ہے۔عناصر خود کسی سیٹ میں شامل نہیں کیے جاتے ہیں۔اس کے بجائے ، عناصر کا ایک ہیش سیٹ میں شامل کیا جاتا ہے۔ایک بلوم فلٹر ایم بٹس کی تھوڑی سی صف ہے ، ان سبھی کو ابتدائی طور پر صفر پر سیٹ کیا جاتا ہے۔ہیش فنکشن بالٹی کی کلید کا نقشہ بنانے کے لئے استعمال ہوتا ہے۔تاہم ، یہ اس بالٹی میں اس کلید کو ذخیرہ نہیں کرے گا ، یہ اسے بھرا ہوا نشان کے مطابق نشان زد کرے گا۔لہذا ، بہت ساری چابیاں ایک ہی بھری ہوئی بالٹی کا نقشہ بناسکتی ہیں ، جس سے غلط مثبت پیدا ہوتے ہیں۔جھوٹے مثبت میچز ممکن ہیں ، لیکن جھوٹے منفی نہیں ہیں - دوسرے لفظوں میں ، ایک سوال یا تو \"ممکنہ طور پر سیٹ میں\" یا \"یقینی طور پر سیٹ میں نہیں\" واپس آتا ہے۔عناصر کو سیٹ میں شامل کیا جاسکتا ہے ، لیکن اسے ہٹایا نہیں جاسکتا (حالانکہ اس کو گنتی بلوم فلٹر کی مختلف حالتوں سے حل کیا جاسکتا ہے)۔ بلوم فلٹر مختلف ایپلی کیشنز میں مفید ہیں ، بشمول ڈیجیٹل سگنل پروسیسنگ ، نیٹ ورک روٹرز ، اور پیکٹ سوئچنگ۔بلوم فلٹرز کو مؤثر طریقے سے یہ طے کرنے کے لئے استعمال کیا جاتا ہے کہ ویب کیچوں میں کون سے ویب آبجیکٹ ذخیرہ کرنا ہے۔ڈی ڈی او ایس حملوں کو متحرک کرنے کے خطرے کو کم سے کم کرنے کے لئے بٹ کوائن میں بلوم فلٹرز بھی استعمال کیے جاتے ہیں۔بلوم فلٹرز کو فلٹرنگ کی پہلی پرت کے طور پر استعمال کیا جاسکتا ہے ، جہاں انہیں مستقل جگہ کی ضرورت ہوتی ہے۔وہ مددگار ثابت ہوسکتے ہیں جہاں ہم جاننا چاہتے ہیں کہ کیا کوئی چیز یقینی طور پر موجود نہیں ہے یا ممکنہ طور پر کہیں موجود ہے۔بلوم فلٹرز ایک خلائی موثر امکانی اعداد و شمار کا ڈھانچہ ہے جو یہ بتا سکتا ہے کہ کوئی عنصر کسی سیٹ میں ہوسکتا ہے یا یقینی طور پر نمبر 123456.1brilliant2wikedia3opengenus4llimllib5enjoyalgorithms6geeksforgeeks نہیں ہے۔"
    },
    {
        "Question": "امورائزڈ تجزیہ کے تصور کی وضاحت کریں۔",
        "Answer": "امورائزڈ تجزیہ ایک ایسا طریقہ ہے جو کمپیوٹر سائنس میں استعمال ہوتا ہے تاکہ متعدد کارروائیوں میں الگورتھم کی اوسط کارکردگی کا تجزیہ کیا جاسکے۔یہ ایک ایسی تکنیک ہے جو انفرادی کارروائیوں کی بدترین صورتحال کی پیچیدگی کے بجائے آپریشن کے سلسلے میں الگورتھم کی اوسط وقت کی پیچیدگی کا اندازہ لگانے کے لئے استعمال ہوتی ہے۔امورائزڈ تجزیہ کے پیچھے خیال یہ ہے کہ مہنگے کاموں کی لاگت کو کم مہنگے کاموں کی ترتیب پر تقسیم کیا جائے۔بنیادی خیال یہ ہے کہ ان مہنگی کارروائیوں کی قیمت کو متعدد کارروائیوں پر پھیلائیں ، تاکہ ہر آپریشن کی اوسط قیمت مستقل یا اس سے کم ہو۔ امورٹائزڈ تجزیہ مفید ہے جب الگورتھم کا بدترین معاملہ بہت مایوسی کا شکار ہے ، اور اوسط-کیس تجزیہ بہت پر امید ہے۔امورائزڈ تجزیہ ہمیں الگورتھم کی مجموعی کارکردگی کے بارے میں زیادہ درست پیش گوئیاں کرنے کی اجازت دیتا ہے ، خاص طور پر ایسے معاملات میں جہاں کچھ آپریشن دوسروں سے زیادہ وقت لگ سکتے ہیں۔امورٹائزڈ تجزیہ کی تین اہم اقسام ہیں: مجموعی تجزیہ ، اکاؤنٹنگ کا طریقہ ، اور ممکنہ طریقہ۔ اجتماعی تجزیہ میں کارروائیوں کی ترتیب کی کل لاگت کا تجزیہ کرنا اور آپریشنوں کی تعداد سے تقسیم کرنا شامل ہے۔اکاؤنٹنگ کے طریقہ کار میں ہر آپریشن کو لاگت تفویض کرنا اور آئندہ کی کارروائیوں کی ادائیگی کے لئے لاگت کا استعمال شامل ہے۔ممکنہ طریقہ میں اعداد و شمار کے ڈھانچے کو ممکنہ فنکشن تفویض کرنا اور ہر آپریشن کی لاگت کی پیمائش کے ل it اس کا استعمال شامل ہے۔ امورٹائزڈ تجزیہ مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، جس میں متحرک صفوں ، ہیش ٹیبلز ، اور بائنری تلاش کے درخت شامل ہیں۔اس سے ہمیں آپریشنز کے سلسلے میں الگورتھم کی اوسط وقت کی پیچیدگی کا اندازہ لگانے کی اجازت ملتی ہے ، جو الگورتھمز 123456.1CMU2Brilliant3wikepedia4tutorialsptipone5geeks6cornell کے ڈیزائن اور تجزیہ کرنے میں کارآمد ثابت ہوسکتی ہے۔"
    },
    {
        "Question": "جامد اور متحرک صف میں کیا فرق ہے؟",
        "Answer": "جامد ارایا جامد سرنی ایک مقررہ سائز کے ساتھ ایک صف ہے جو مرتب وقت پر مختص کی جاتی ہے۔ رن ٹائم کے دوران جامد صف کا سائز تبدیل نہیں کیا جاسکتا۔ اسٹیٹک اراے اسٹیک میموری میں محفوظ ہیں۔مرتب وقت پر اور رن ٹائم کے دوران کسی بھی اضافی میموری کی مختص کرنے کی ضرورت نہیں ہوتی ہے۔ ڈائنیمک ارایا متحرک سرنی ایک ایسی صف ہے جس میں ایک متغیر سائز ہوتا ہے جو رن ٹائم پر مختص ہوتا ہے۔ رن ٹائم کے دوران متحرک صف کا سائز تبدیل کیا جاسکتا ہے۔میموری۔ ڈائنیمک صف مستحکم صفوں سے آہستہ ہیں کیونکہ انہیں رن ٹائم کے دوران اضافی میموری کی مختص کرنے کی ضرورت ہوتی ہے۔ خلاصہ میں ، جامد اور متحرک صفوں کے درمیان بنیادی فرق یہ ہے کہ جامد صفوں کا ایک مقررہ سائز ہوتا ہے جو مرتب وقت پر مختص ہوتا ہے ، جبکہ متحرک صفوں میں متغیر ہوتا ہے۔سائز جو رن ٹائم پر مختص کیا جاتا ہے۔جامد صفیں متحرک صفوں سے تیز ہیں کیونکہ انہیں رن ٹائم کے دوران میموری کے اضافی مختص کرنے کی ضرورت نہیں ہوتی ہے۔تاہم ، متحرک صفیں جامد صفوں کے مقابلے میں زیادہ لچکدار ہیں کیونکہ ان کے سائز کو رن ٹائم 123456.1youtube2youtube3rebus4Medium5dotnettutorials6stackoverflow کے دوران تبدیل کیا جاسکتا ہے۔"
    },
    {
        "Question": "آپ انضمام کی ترتیب الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "انضمام کی ترتیب والے الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل پیرا ہوسکتے ہیں: غیر ترتیب شدہ صف کو این ذیلی اریوں میں تقسیم کریں ، ہر ایک ایک عنصر پر مشتمل ہے۔ دوبارہ نئے ترتیب دیئے جانے والے ذیلی اریوں کو دوبارہ ضم کریں جب تک کہ صرف ایک ذیلی سرے باقی نہ رہے۔یہ ترتیب دی گئی صف ہے۔ انضمام کی ترتیب الگورتھم ایک تقسیم اور فتح کرنے والا الگورتھم ہے جو ان پٹ سرنی کو چھوٹے ذیلی اریوں میں تقسیم کرکے کام کرتا ہے ، ہر ذیلی سرے کو بار بار ترتیب دیتے ہیں ، اور پھر ترتیب دیئے گئے ذیلی اریوں کو مل کر تشکیل دیتے ہیں تاکہ تشکیل پائے۔آخری ترتیب دی گئی سرنی۔انضمام کی ترتیب الگورتھم بڑے ڈیٹاسیٹس کے لئے موثر ہے اور اس میں O (n لاگ این) کی وقت کی پیچیدگی ہوتی ہے ، جہاں N صف میں عناصر کی تعداد ہوتی ہے۔انضمام کی ترتیب ایک مستحکم چھانٹنے والا الگورتھم ہے ، جس کا مطلب ہے کہ یہ ترتیب شدہ صف میں مساوی عناصر کے متعلقہ ترتیب کو محفوظ رکھتا ہے۔انضمام کی ترتیب کو مختلف پروگرامنگ زبانوں جیسے ازگر ، جاوا ، سی ++ ، اور C123456 جیسی مختلف پروگرامنگ زبانوں کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ یہاں ازگر میں انضمام کی ترتیب کی ایک مثال ہے: ڈیف انضمام_سورٹ (اے آر آر): اگر لین (آر اے آر)> 1: درمیانی = لین (اے آر آر (اے آر آر)) // 2 بائیں_ہلف = آر آر [: وسط] دائیں_ہلف = آر آر [وسط:] انضمام_سورٹ (بائیں_ہالف) انضمام_سورٹ (دائیں_ہالف) i = j = k = 0 جبکہ میں <لین (بائیں_ہالف) اور جے <لین (دائیں_ہلف): اگر بائیں_ہلف)۔[k] = بائیں_ہالف [i] i += 1 k += 1 جبکہ j <لین (دائیں_ہلف): arr [k] = دائیں_ہلف [j] j += 1 k += 1 میں ، انضمام_سورٹ فنکشن غیر ترتیب دیتا ہےسرنی ان پٹ کے طور پر اور انضمام کی ترتیب الگورتھم کا استعمال کرتے ہوئے اسے ترتیب دیتا ہے۔فنکشن ان پٹ صف کو بار بار چھوٹے ذیلی اریوں میں تقسیم کرتا ہے ، ہر ذیلی سرے کو ترتیب دیتا ہے ، اور پھر ترتیب شدہ ذیلی اریوں کو ایک ساتھ ملا دیتا ہے تاکہ حتمی ترتیب دیئے گئے سرے کی تشکیل کی جاسکے۔"
    },
    {
        "Question": "اسکیپ لسٹ ڈیٹا کا ڈھانچہ کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "اسکیپ لسٹ ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو ایک ترتیب شدہ فہرست میں موثر تلاش ، اندراج اور عناصر کو حذف کرنے کی اجازت دیتا ہے۔یہ ایک قسم کی منسلک فہرست ہے جو نوڈس کی متعدد پرتوں کا استعمال کرکے تیزی سے تلاش کرنے کی اجازت دیتی ہے۔ہر پرت ایک ترتیب شدہ منسلک فہرست ہے جس میں اس کے نیچے کی پرت میں عناصر کا ایک ذیلی سیٹ ہوتا ہے۔نچلی پرت ایک باقاعدہ منسلک فہرست ہے ، جبکہ اس کے اوپر کی پرتوں میں \"اسکیپنگ\" لنکس ہوتے ہیں جو نیچے کی پرت میں بہت دور ہونے والے عناصر پر تیز نیویگیشن کی اجازت دیتے ہیں۔اس کے پیچھے خیال یہ ہے کہ مطلوبہ عنصر کو فوری طور پر عبور کرنے کی اجازت دی جائے ، جس سے اس تک پہنچنے کے لئے درکار اقدامات کی اوسط تعداد کم ہوجائے۔اسکیپ لسٹس کو \"سکے پلٹ جانے\" کے نام سے ایک تکنیک کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اس تکنیک میں ، ہر اندراج کے لئے ایک بے ترتیب تعداد تیار کی جاتی ہے تاکہ نیا عنصر پر قبضہ کرنے والی تہوں کی تعداد کا تعین کیا جاسکے۔اس کا مطلب یہ ہے کہ ، اوسطا ، ہر عنصر لاگ (این) پرتوں میں ہوگا ، جہاں اسکیپ لسٹ میں عناصر کی تعداد ہے۔اسکیپ لسٹس مختلف ایپلی کیشنز میں کارآمد ہیں ، بشمول ڈیٹا بیس انڈیکسنگ ، ویب کیچنگ ، اور نیٹ ورک روٹنگ 123456.1 تھیک ریزی پروگرمر 2 سکلر 3 JAVATPOINT4GEATSFORGEEKS5CMU6Wikepedia"
    },
    {
        "Question": "ایک لاحقہ درخت کیا ہے اور یہ کیسے مفید ہے؟",
        "Answer": "ایک لاحقہ درخت ایک اعداد و شمار کا ڈھانچہ ہے جو بنیادی پری پروسیسنگ کے مقابلے میں گہرے انداز میں تار کے اندرونی ڈھانچے کو بے نقاب کرتا ہے۔یہ ٹری کا ایک کمپریسڈ ورژن ہے جس میں سٹرنگ کے تمام لاحقہ شامل ہیں۔لاحقہ درخت متن پر ہر طرح کے اعدادوشمار کی گنتی کے ل useful مفید ہیں ، جیسے طویل ترین بار بار آنے والے سبسٹرنگ کو تلاش کرنا ، سب سے طویل عام سبسٹرنگ تلاش کرنا ، اور تار میں سب سے طویل پیلنڈرووم تلاش کرنا۔لاحقہ درختوں کا استعمال بہت سے تار کے مسائل کو حل کرنے کے لئے کیا جاسکتا ہے جو ٹیکسٹ ایڈیٹنگ ، فری ٹیکسٹ سرچ ، کمپیوٹیشنل بیالوجی ، اور دیگر اطلاق کے علاقوں میں پائے جاتے ہیں۔لاحقہ درخت اکثر بائیو انفارمیٹکس ایپلی کیشنز میں استعمال ہوتے ہیں ، ڈی این اے یا پروٹین کی ترتیب میں نمونوں کی تلاش کرتے ہیں (جسے حروف کی لمبی تار کے طور پر دیکھا جاسکتا ہے)۔مماثلتوں کے ساتھ موثر انداز میں تلاش کرنے کی صلاحیت کو ان کی سب سے بڑی طاقت سمجھا جاسکتا ہے۔ڈیٹا کمپریشن میں بھی لاحقہ درخت استعمال ہوتے ہیں۔ان کا استعمال بار بار اعداد و شمار تلاش کرنے کے لئے کیا جاسکتا ہے ، اور اسے بروز - وہیلر ٹرانسفارم کے چھانٹنے کے مرحلے کے لئے استعمال کیا جاسکتا ہے۔ لاحقہ درخت کی تعمیر کے لئے بروٹ فورس الگورتھم یہ ہے کہ وہ تار کے تمام لاحقہ پر غور کریں اور انہیں ایک کے ذریعہ ایک تری میں داخل کریں۔اس میں O (n²) وقت لگے گا کیونکہ وہاں N لاحقہ موجود ہیں ، اور ہر لاحقہ ٹری میں داخل ہونے میں O (n) وقت لگے گا۔لاحقہ درختوں کی تعمیر کا یہ طریقہ بڑے تاروں کے لئے غیر موثر ہے ، اور ہمیں لاحقہ درخت کی تعمیر کے لئے ایک بہتر طریقہ تلاش کرنے کی ضرورت ہے۔ خلاصہ یہ ہے کہ ، ایک لاحقہ درخت ایک ڈیٹا ڈھانچہ ہے جو متن میں ترمیم میں ہونے والے بہت سے تار کے مسائل کو حل کرنے کے لئے مفید ہے۔، فری ٹیکسٹ سرچ ، کمپیوٹیشنل بیالوجی ، اور دیگر اطلاق والے علاقوں۔لاحقہ درخت اکثر بائیو انفارمیٹکس ایپلی کیشنز میں استعمال ہوتے ہیں ، ڈی این اے یا پروٹین کی ترتیب میں نمونوں کی تلاش کرتے ہیں۔مماثلتوں کے ساتھ موثر انداز میں تلاش کرنے کی صلاحیت کو ان کی سب سے بڑی طاقت سمجھا جاسکتا ہے۔لاحقہ درختوں کو ڈیٹا کمپریشن میں بھی استعمال کیا جاتا ہے اور اسے بار بار ڈیٹا تلاش کرنے اور بروز کے چھانٹنے کے لئے استعمال کیا جاسکتا ہے - وہیلر ٹرانسفارم 123456.1UCF2UCDAVIS3POWERED WOLFRAM کے ذریعہ"
    },
    {
        "Question": "بائنری تلاش کے درخت میں عنصر ڈالنے کی وقت کی پیچیدگی کیا ہے؟",
        "Answer": "بائنری تلاش کے درخت میں عنصر ڈالنے کی وقت کی پیچیدگی درخت کی اونچائی پر منحصر ہے۔بدترین صورت میں ، جب درخت مکمل طور پر غیر متوازن ہوتا ہے تو ، درخت کی اونچائی O (n) ہوتی ہے ، اور داخل کرنے کی وقت کی پیچیدگی O (n) ہوتی ہے۔عام طور پر ، بائنری تلاش کے درخت میں داخل کرنے کی وقت کی پیچیدگی O (H) ہے ، جہاں H درخت کی اونچائی ہے۔اوسط صورت میں ، جب درخت متوازن ہوتا ہے تو ، درخت کی اونچائی O (لاگ این) ہوتی ہے ، اور اندراج کی وقت کی پیچیدگی O (لاگ این) ہوتی ہے۔ایک داخل کرنے والے آپریشن کے لئے اوسطا کیس ٹائم کی پیچیدگی O (لاگ این) ہے ، اور N داخل کرنے کے کاموں کے لئے ، اوسط کیس ٹائم کی پیچیدگی O (n لاگ این) ہے۔کلیدی بات یہ ہے کہ آپریشن کو درخت کی اونچائی کے متناسب وقت کی ضرورت ہوتی ہے۔خلاصہ یہ کہ ، بائنری تلاش کے درخت میں کسی عنصر کو داخل کرنے کی وقت کی پیچیدگی O (H) ہے ، جہاں H درخت کی اونچائی ہے۔بدترین صورت میں ، وقت کی پیچیدگی O (n) ہے ، اور اوسط صورت میں ، وقت کی پیچیدگی O (لاگ این) ہے (لاگ این)"
    },
    {
        "Question": "کیا آپ وضاحت کرسکتے ہیں کہ ایک فبونیکی ہیپ کیسے کام کرتا ہے؟",
        "Answer": "ایک فبونیکی ہیپ ایک ڈیٹا ڈھانچہ ہے جو ترجیحی قطاروں کو نافذ کرنے کے لئے استعمال ہوتا ہے۔یہ ایک قسم کا ڈھیر ڈیٹا ڈھانچہ ہے جس میں درختوں کا ایک مجموعہ ہوتا ہے ، جہاں ہر درخت ڈھیر آرڈرڈ ملٹی ٹری ہوتا ہے۔فبونیکی ڈھیر میں درختوں کو اس طرح منظم کیا جاتا ہے کہ چھوٹی چھوٹی کلید کے ساتھ جڑ کا نوڈ ہمیشہ درختوں کی فہرست کے سامنے رہتا ہے۔فبونیکی کے ڈھیروں کا نام فبونیکی نمبروں کے نام پر رکھا گیا ہے ، جو ان کے رننگ ٹائم تجزیہ میں استعمال ہوتے ہیں۔ فبونیکی ڈھیر کی اہم خصوصیات یہ ہیں: یہ کم سے کم ڈھیر آرڈر والے درختوں کا ایک سیٹ ہے۔(یعنی والدین ہمیشہ بچوں سے چھوٹا ہوتا ہے۔) کم سے کم عنصر نوڈ پر ایک پوائنٹر برقرار رکھا جاتا ہے۔ یہ نشان زدہ نوڈس کے ایک سیٹ پر مشتمل ہوتا ہے۔(کلیدی آپریشن کو کم کریں) نوڈس کی ڈگری (بچوں کی تعداد) محدود ہیں۔ڈھیر میں ہر نوڈ میں زیادہ تر O (لاگ این) کی ڈگری ہوتی ہے ، اور ڈگری K کے نوڈ میں جڑے ہوئے سب ٹری کا سائز کم از کم ایف کے+2 ہوتا ہے ، جہاں ایف کے کے ٹی ایچ فبونیکی نمبر ہے۔اس ڈھانچے کو ایک قاعدہ بنا کر برقرار رکھا جاتا ہے کہ زیادہ سے زیادہ ایک بچے کو ہر غیر جڑ کے نوڈ سے کاٹا جاسکتا ہے۔جب ایک دوسرے بچے کو ہٹا دیا جاتا ہے تو ، نوڈ کو خود ہی اپنے والدین سے ہٹانے کی ضرورت ہوتی ہے اور وہ ایک نئے درخت کی جڑ بن جاتی ہے۔ فبونیکی ڈھیر میں بنیادی کارروائیوں کی وقت کی پیچیدگی یہ ہیں: اندراج: O (1) کم سے کم تلاش کریں: O (O (O (1)1) کم سے کم حذف کریں: O (لاگ این) کلید میں کمی: O (1) امورائزڈ ٹائم فبونیکی ہیپس مختلف ایپلی کیشنز میں کارآمد ہیں ، بشمول گراف الگورتھم جیسے ڈجکسٹرا کے الگورتھم اور پرائم کے الگورتھم۔وہ ڈیٹا کمپریشن میں بھی استعمال ہوتے ہیں اور بروز کے چھانٹنے والے مرحلے - وہیلر ٹرانسفارم کے لئے بھی استعمال ہوسکتے ہیں۔"
    },
    {
        "Question": "خود توازن بائنری تلاش کا درخت کیا ہے اور آپ اسے کب استعمال کریں گے؟",
        "Answer": "ایک خود توازن بائنری سرچ درخت ایک بائنری سرچ ٹری ہے جو خود بخود اپنی اونچائی کو ہر وقت کم سے کم رکھنے کی کوشش کرتا ہے۔یہ بائنری سرچ ٹری کی ایک قسم ہے جو اونچائی کو کم کرنے کے لئے کلیدی اوقات (اندراج اور حذف کرنے) پر درخت پر تبدیلیاں انجام دے کر اپنے توازن کو برقرار رکھتی ہے۔بائنری تلاش کے درختوں کو خود توازن دینے کے پیچھے بنیادی خیال یہ ہے کہ درخت کی اونچائی ہمیشہ لاگ (این) کی ترتیب میں رہتی ہے ، جہاں درخت میں نوڈس کی تعداد ہوتی ہے۔خود توازن بائنری تلاش کے درخت لچکدار ڈیٹا ڈھانچے ہیں جو اضافی ڈیٹا کو ریکارڈ کرنے یا موثر انداز میں نئی کارروائیوں کو انجام دینے کے لئے بڑھانا آسان ہیں۔وہ مختلف ایپلی کیشنز میں کارآمد ہیں ، بشمول ڈیٹا بیس انڈیکسنگ ، ویب کیچنگ ، اور نیٹ ورک روٹنگ۔خود توازن بائنری تلاش کے درخت باقاعدہ بائنری تلاش کے درختوں سے مختلف ہیں جس میں وہ خود بخود خود کو متوازن رکھتے ہیں ، جبکہ بائنری تلاش کے باقاعدہ درخت غیر متوازن اور ایک منسلک فہرست میں انحطاط پذیر ہوسکتے ہیں ، جو ان کی تلاش کی کارکردگی کو متاثر کرتا ہے۔جب ہمیں عناصر کی ترتیب شدہ فہرست میں آپریشن کرنے کی ضرورت ہوتی ہے تو خود توازن بائنری تلاش کے درخت استعمال ہوتے ہیں ، اور ہم اس بات کو یقینی بنانا چاہتے ہیں کہ آپریشنز موثر انداز میں انجام دیئے جائیں ، یہاں تک کہ جب فہرست بڑی تعداد میں ہے۔"
    },
    {
        "Question": "آپ کوئکسورٹ الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "کوئکسورٹ الگورتھم کو نافذ کرنے کے ل you ، آپ ان مراحل پر عمل کرسکتے ہیں: سرنی سے ایک محور عنصر کا انتخاب کریں۔ حصہ محور عنصر کے ارد گرد صف کو ، اس طرح کہ محور سے کم تمام عناصر محور کے بائیں طرف ہیں ، اور اس سے زیادہ تمام عناصر اس سے زیادہ ہیں۔محور محور کے دائیں طرف ہیں۔ مذکورہ بالا اقدامات کو بائیں اور دائیں ذیلی عادیوں پر لگائیں جب تک کہ پوری صف کو ترتیب نہ دیا جائے۔ کوئکورٹ الگورتھم کی کلید تقسیم کرنے والا مرحلہ ہے ، جو ایک محور عنصر کو منتخب کرکے کیا جاتا ہے۔اور سرنی کو اس طرح دوبارہ ترتیب دینا کہ محور سے کم تمام عناصر محور کے بائیں جانب ہیں ، اور محور سے زیادہ تمام عناصر محور کے دائیں جانب ہیں۔محور عنصر کو منتخب کرنے کے مختلف طریقے ہیں ، جیسے صف کا پہلا ، آخری ، یا درمیانی عنصر منتخب کرنا۔محور عنصر کا انتخاب الگورتھم کی کارکردگی کو متاثر کرسکتا ہے ، خاص طور پر بدترین صورتحال میں۔بہترین صورتحال میں ، جب محور عنصر سرنی کا درمیانی حصہ ہوتا ہے تو ، کوئکورٹ کی وقت کی پیچیدگی O (n لاگ این) ہوتی ہے۔بدترین صورتحال میں ، جب محور عنصر صف کا سب سے چھوٹا یا سب سے بڑا عنصر ہوتا ہے تو ، کوئکسورٹ کی وقت کی پیچیدگی O (n^2) ہوتی ہے۔اوسط صورت میں ، کوئکسورٹ کی وقت کی پیچیدگی O (n لاگ این) ہے۔ یہاں ازگر میں کوئکسورٹ کا ایک مثال عمل ہے: ڈیف کوئکسورٹ (اے آر آر): اگر لین (آر آر) <= 1: ریٹرن آر او آر ایل: پیوٹ = اے آر آر[0] بائیں = [x کے لئے x کے لئے x [1:] اگر x <pivot] دائیں = [x کے لئے x کے لئے x [1:] اگر x> = Pivot] کوئیکسٹورٹ (بائیں) + [محور] + کوئیکسورٹ (کوئکسورٹ (دائیں) اس نفاذ میں ، کوئکسورٹ فنکشن ان پٹ کے طور پر ایک غیر ترتیب شدہ صف لیتا ہے اور کوئکسورٹ الگورتھم کا استعمال کرتے ہوئے اسے ترتیب دیتا ہے۔فنکشن ایک محور عنصر کے آس پاس ان پٹ سرنی کو متنازعہ طور پر تقسیم کرتا ہے ، اور پھر اسی الگورتھم کا استعمال کرتے ہوئے بائیں اور دائیں ذیلی خطوں کو ترتیب دیتا ہے۔"
    },
    {
        "Question": "گراف ڈیٹا ڈھانچہ کیا ہے اور اس کی مختلف اقسام کیا ہیں؟",
        "Answer": "گراف ڈیٹا ڈھانچہ نوڈس کا ایک مجموعہ ہے جس میں ڈیٹا ہوتا ہے اور وہ کناروں کے ذریعہ دوسرے نوڈس سے جڑے ہوتے ہیں۔گراف کا استعمال اشیاء کے مابین تعلقات کی نمائندگی کرنے کے لئے کیا جاتا ہے ، جیسے سوشل نیٹ ورکس ، کمپیوٹر نیٹ ورکس ، اور ٹرانسپورٹیشن نیٹ ورکس۔گراف کو عام طور پر دو طریقوں سے نمائندگی کی جاتی ہے: ملحقہ میٹرکس اور ملحقہ فہرست۔ملحقہ میٹرکس V X V عمودی کی 2D صف ہے ، جہاں ہر قطار اور کالم ایک عمودی کی نمائندگی کرتے ہیں۔اگر کسی بھی عنصر A [i] [j] کی قدر 1 ہے تو ، اس کی نمائندگی کرتی ہے کہ وہاں ایک کنارے ہے جو ورٹیکس I اور ورٹیکس جے کو جوڑتا ہے۔ملحقہ فہرست لنکڈ فہرستوں کے مجموعہ کے طور پر گراف کی نمائندگی کرتی ہے ، جہاں ہر ایک خطوط میں ملحقہ عمودی کی فہرست ہوتی ہے۔ مختلف قسم کے گراف ہیں ، بشمول: ہدایت نامہ: ایک گراف جس میں ایک ایج (یو ، وی) ضروری نہیں ہے۔اس کا مطلب یہ ہے کہ ایک کنارے (v ، u) بھی ہے۔اس طرح کے گراف میں موجود کناروں کی نمائندگی تیر کے ذریعہ کی جاتی ہے تاکہ کنارے کی سمت ظاہر کی جاسکے۔غیر وزن والا گراف: ایک گراف جس میں ہر کنارے کا وزن یا لاگت ایک ہی ہوتا ہے۔ گراف مختلف ایپلی کیشنز میں کارآمد ہوتے ہیں ، بشمول ڈیٹا بیس انڈیکسنگ ، ویب کیچنگ ، اور نیٹ ورک روٹنگ۔گراف کو ڈیٹا کمپریشن میں بھی استعمال کیا جاتا ہے اور بروز کے چھانٹنے والے مرحلے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "ایک منٹ کے ڈھیر اور میکس ہیپ کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "ایک منٹ کا ڈھیر اور ایک زیادہ سے زیادہ ڈھیر دونوں درختوں پر مبنی ڈیٹا ڈھانچے ہیں جو بالترتیب کم سے کم اور زیادہ سے زیادہ عناصر کی موثر بازیافت کو قابل بناتے ہیں۔عناصر کے انتظامات اور ان کو تفویض کردہ ترجیحات میں دونوں جھوٹ کے درمیان کلیدی فرقپاپ انجام دیا جاتا ہے۔ایک منٹ کے ڈھیر میں ، والدین یا روٹ نوڈ عام طور پر بچوں کے نوڈس سے کم قیمت میں ہوتے ہیں۔کم سے کم عنصر کو مستقل وقت کے اندر ہی حاصل کیا جاتا ہے کیونکہ یہ انڈیکس 1 پر ہوتا ہے۔ ایک منٹ کو حذف کرنا ایک منٹ کے ڈھیر میں ہوتا ہے لاجارتھمک وقت یعنی او (لاگ (این))۔ زیادہ سے زیادہ ہیپ: سب سے بڑا عنصر درخت کی جڑ میں واقع ہےمیکس ہیپ ، اس طرح کہ جب ہیپ پاپ انجام دیا جاتا ہے تو سب سے بڑا عنصر منتخب کرنا آسان ہوتا ہے۔زیادہ سے زیادہ ڈھیر میں ، والدین یا روٹ نوڈ عام طور پر بچوں کے نوڈس سے زیادہ قیمت میں ہوتے ہیں۔زیادہ سے زیادہ عنصر کو مستقل وقت کے اندر حاصل کیا جاتا ہے کیونکہ یہ انڈیکس 1 پر ہوتا ہے۔ ایک عنصر کو زیادہ سے زیادہ ڈھیر میں حذف کرنے سے لوگرتھمک وقت ہوتا ہے یعنی او (لاگ (این))مثال کے طور پر ، ہیپ ترتیب بہترین چھانٹنے والے الگورتھم میں سے ایک ہے جو O (n*لاگ این) وقت میں صف کو ترتیب دینے کے لئے بائنری ہیپ کا استعمال کرتا ہے۔ایک ترجیحی قطار کو ڈھیر کا استعمال کرکے نافذ کیا جاسکتا ہے کیونکہ یہ O (لاگ این) وقت میں داخل () ، حذف () اور ایکسٹریکٹ میکس () آپریشن کی حمایت کرتا ہے۔عناصر اور ان کو تفویض کردہ ترجیحات کی۔ایک منٹ کا ڈھیر سب سے چھوٹے عنصر کو ترجیح دیتا ہے ، جبکہ ایک زیادہ سے زیادہ ڈھیر سب سے بڑے عنصر کو ترجیح دیتا ہے۔دونوں من ہیپ اور میکس ہیپ کی اپنی انوکھی ایپلی کیشنز ہیں اور مختلف الگورتھمز 123456.1 پریپ بائٹس 2section3geeksforgeeks4cmu5byjus6tutorialsPoint میں استعمال ہوتے ہیں"
    },
    {
        "Question": "آپ گراف پر ڈی ایف ایس (گہرائی کی پہلی تلاش) الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "کسی گراف پر ڈی ایف ایس (گہرائی کی پہلی تلاش) الگورتھم کو نافذ کرنے کے ل we ، ہم ان اقدامات پر عمل پیرا ہوسکتے ہیں: ایک اسٹیک بنائیں اور اسٹیک پر شروع ہونے والے سر کو دبائیں۔اسٹیک اور اس کا دورہ کریں۔ ملاحظہ کی گئی ورٹیکس کے ہر غیر منحصر پڑوسی کے ل it ، اسے ملاحظہ کی طرح نشان زد کریں اور اسے اسٹیک پر دھکیلیں۔ ڈی ایف ایس الگورتھم بیک ٹریکنگ سے پہلے ہر شاخ کے ساتھ گراف کو زیادہ سے زیادہ گہرائی سے تلاش کرکے کام کرتا ہے۔درختوں کے اعداد و شمار کے ڈھانچے یا گراف کے تمام عمودی کو تلاش کرنے کے لئے یہ ایک بار بار الگورتھم ہے۔ڈی ایف ایس الگورتھم گراف کے ابتدائی نوڈ سے شروع ہوتا ہے اور اس وقت تک گہرا ہوجاتا ہے جب تک کہ ہمیں گول نوڈ یا نوڈ نہ مل جائے جس میں کوئی اولاد نہیں ہے۔ڈی ایف ایس کو گراف کی ٹوپولوجیکل چھانٹنے ، دو عمودیوں کے مابین راستوں کی تلاش ، اور گراف میں چکروں کا پتہ لگانے کے لئے استعمال کیا جاسکتا ہے۔ جاوا میں ڈی ایف کو نافذ کرنے کے متعدد طریقے ہیں۔ہم گراف کی نمائندگی کے لئے ملحقہ فہرست استعمال کرسکتے ہیں اور الگورتھم کے نفاذ کے لئے تکرار کے ساتھ ساتھ ایک تکراری نقطہ نظر دونوں کا احاطہ کرسکتے ہیں۔جاوا میں ڈی ایف ایس الگورتھم کے لئے تکرار کرنے والا عمل مندرجہ ذیل ہے: باطل ڈی ایف ایس (انٹورٹیکس) {ملاحظہ کیا [ورٹیکس] = سچ ؛system.out.print (vertex + \"\") ؛کے لئے (INT پڑوسی: ایڈجسٹس [ورٹیکس]) {اگر (! ملاحظہ کیا [پڑوسی]) {DFS (پڑوسی) ؛}} this اس نفاذ میں ، ڈی ایف ایس فنکشن ان پٹ کے طور پر ایک ابتدائی ورٹیکس لیتا ہے اور گراف پر گہرائی سے پہلے تلاش کرتا ہے۔فنکشن ابتدائی ورٹیکس کو دورہ کے طور پر نشان زد کرتا ہے ، اسے پرنٹ کرتا ہے ، اور پھر بار بار اپنے آپ کو ورٹیکس ڈاٹ کام کے تمام غیر منحصر پڑوسیوں پر کال کرتا ہے ، تاکہ کسی گراف پر ڈی ایف ایس الگورتھم کو نافذ کیا جاسکے ، ہمیں اسٹیک بنانے اور شروعاتی حد کو آگے بڑھانے کی ضرورت ہے۔اسٹیکاس کے بعد ہم ابتدائی ورٹیکس کو دورے کے مطابق نشان زد کرتے ہیں اور جب اسٹیک خالی نہیں ہوتا ہے ، ہم اسٹیک سے ایک چوٹی کو پاپ کرتے ہیں اور اس پر جاتے ہیں۔دورہ شدہ ورٹیکس کے ہر غیر منحصر پڑوسی کے ل we ، ہم اسے ملاحظہ کے ساتھ نشان زد کرتے ہیں اور اسے اسٹیک پر دھکیل دیتے ہیں۔درختوں کے ڈیٹا ڈھانچے یا گراف کے تمام عمودی تلاش کے ل D ڈی ایف ایس ایک تکرار الگورتھم ہے۔اس کا استعمال گراف کی ٹاپولوجیکل چھانٹنے ، دو عمودیوں کے مابین راستوں کو تلاش کرنے ، اور گراف 123456.1 پرو گرامائز 2 ایف اے وی ٹیوٹر 3 JavatPoint4Simplelearn5Techidelight6geeksforgeks میں چکروں کا پتہ لگانے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "یادداشت کیا ہے اور متحرک پروگرامنگ میں اس کا استعمال کس طرح ہوتا ہے؟",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال کی جاتی ہے تاکہ کسی فنکشن کو بہتر بنانے کے لئے استعمال کیا جاسکے جس نے دہرایا اور مہنگے گنتی کو دہرایا ہو۔اس میں فنکشن کالز کے نتائج کیچنگ اور کیشڈ نتیجہ کو واپس کرنا شامل ہے اگر فنکشن کو اسی آدانوں کے ساتھ دوبارہ بلایا جائے۔یادداشت ایک ٹاپ ڈاون نقطہ نظر ہے جہاں ہم ایک میمو ، یا \"خود کو نوٹ\" بناتے ہیں ، کیونکہ ہر مسئلے کو حل کرنے سے لوٹنے والی اقدار۔پھر ، جب ہمیں ایک بار پھر ایک ہی پریشانی کا سامنا کرنا پڑتا ہے تو ، ہم صرف میمو کی جانچ کرتے ہیں ، اور ، دوسرے (یا تیسرے یا چوتھے) بار مسئلے کو حل کرنے کے بجائے ، ہم اپنے میمو سے حل بازیافت کرتے ہیں۔میمورائزیشن کو عام طور پر تکرار کا استعمال کرتے ہوئے نافذ کیا جاتا ہے اور ان مسائل کے ل well مناسب مناسب ہے جس میں نسبتا small چھوٹا سیٹ ہوتا ہے۔متحرک پروگرامنگ مسائل کو چھوٹے چھوٹے مضامین میں توڑ کر اور ہر ذیلی مسئلے کو صرف ایک بار حل کرکے حل کرنے کی ایک تکنیک ہے۔میمورائزیشن متحرک پروگرامنگ کے دو نقطہ نظر میں سے ایک ہے ، دوسرا ٹیبلولیشن۔میمورائزیشن اور ٹیبلولیشن کے درمیان بنیادی فرق یہ ہے کہ یادداشت ایک ٹاپ ڈاون نقطہ نظر ہے ، جبکہ ٹیبلولیشن ایک نچلا اپ اپروچ ہے۔یادداشت میں ، ہم اصل مسئلے سے شروع کرتے ہیں اور اسے بار بار چھوٹے چھوٹے مضامین میں توڑ دیتے ہیں ، جبکہ ٹیبلولیشن میں ، ہم سب سے چھوٹی ذیلی مشکلات سے شروع کرتے ہیں اور اصل مسئلے کو تیار کرتے ہیں۔میموائزیشن اور ٹیبلولیشن دونوں متحرک پروگرامنگ الگورتھم کی عمل درآمد کو بہتر بنانے کے لئے استعمال ہوتے ہیں اور ہاتھ میں مسئلے پر منحصر ہوتے ہوئے ایک دوسرے کے ساتھ تبادلہ خیال کیا جاسکتا ہے۔ خلاصہ یہ ہے کہ میمورائزیشن ایک ایسی تکنیک ہے جو کسی فنکشن کی نفاست کو بہتر بنانے کے لئے متحرک پروگرامنگ میں استعمال کی جاتی ہے جس میں دہرایا جاتا ہے اور مہنگا کمپیوٹیشن ہے۔اس میں فنکشن کالز کے نتائج کیچنگ اور کیشڈ نتیجہ کو واپس کرنا شامل ہے اگر فنکشن کو اسی آدانوں کے ساتھ دوبارہ بلایا جائے۔یادداشت کا استعمال ان مسائل کو حل کرنے کے لئے کیا جاتا ہے جن میں ذیلی مسائل کو اوور لیپنگ ہوتی ہے اور عام طور پر تکرار کا استعمال کرتے ہوئے اس پر عمل درآمد ہوتا ہے۔متحرک پروگرامنگ کے لئے دو طریقوں میں سے ایک یادداشت ہے ، دوسرا ٹیبلولیشن ، اور دونوں متحرک پروگرامنگ الگورتھمز پر عمل درآمد کو بہتر بنانے کے لئے استعمال ہوتے ہیں۔"
    },
    {
        "Question": "ڈیجکسٹرا کا الگورتھم کیا ہے اور اس کا استعمال کیسے ہوتا ہے؟",
        "Answer": "ڈیجکسٹرا کا الگورتھم ایک گراف ٹراورسل الگورتھم ہے جو وزن والے گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتا ہے۔الگورتھم وزٹ شدہ نوڈس کا ایک سیٹ اور غیر منحصر نوڈس کا ایک سیٹ برقرار رکھتے ہوئے کام کرتا ہے۔یہ ماخذ نوڈ سے شروع ہوتا ہے اور پڑوسی نوڈس کا دورہ کرتا ہے ، اور ماخذ نوڈ سے ان کے فاصلوں کو اپ ڈیٹ کرتا ہے۔اس کے بعد یہ نوڈ کو سب سے چھوٹے فاصلے کے ساتھ منتخب کرتا ہے اور اسے دیکھنے والے سیٹ میں شامل کرتا ہے۔اس عمل کو اس وقت تک دہرایا جاتا ہے جب تک کہ منزل کا نوڈ پہنچ نہ جائے یا تمام نوڈس کا دورہ کیا جائے۔ ڈیجکسٹرا کا الگورتھم ایک لالچی الگورتھم ہے جو ہر قدم پر ماخذ نوڈ سے سب سے کم فاصلے کے ساتھ نوڈ کا انتخاب کرکے کام کرتا ہے۔غیر منفی کنارے کے وزن والے گراف میں مختصر ترین راستہ تلاش کرنے کی ضمانت ہے۔سب سے چھوٹی فاصلے کے ساتھ نوڈ کو موثر انداز میں منتخب کرنے کے لئے ڈجکسٹرا کے الگورتھم کو ترجیحی قطار کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ ڈیجکسٹرا کا الگورتھم مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، جس میں جی پی ایس نیویگیشن سسٹم ، نیٹ ورک روٹنگ پروٹوکول ، اور ایئر لائن روٹ کی منصوبہ بندی شامل ہیں۔یہ کمپیوٹر نیٹ ورکس میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے بھی استعمال ہوتا ہے۔ خلاصہ میں ، ڈیجکسٹرا کا الگورتھم ایک گراف ٹراورسل الگورتھم ہے جو وزن والے گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتا ہے۔یہ وزٹ شدہ نوڈس کا ایک سیٹ اور غیر منحصر نوڈس کا ایک سیٹ برقرار رکھنے اور ہر قدم پر ماخذ نوڈ سے سب سے کم فاصلے کے ساتھ نوڈ کا انتخاب کرکے کام کرتا ہے۔ڈیجکسٹرا کا الگورتھم مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، جس میں جی پی ایس نیویگیشن سسٹم ، نیٹ ورک روٹنگ پروٹوکول ، اور ایئر لائن روٹ منصوبہ بندی 123456.1Simplearn2farruh3wikipedia4brilliant5Scientirectecamp"
    },
    {
        "Question": "کیا آپ AVL درخت اور سرخ رنگ کے درخت کے درمیان فرق کی وضاحت کرسکتے ہیں؟",
        "Answer": "اے وی ایل کے درخت اور سرخ رنگ کے درخت دونوں خود توازن بائنری تلاش کے درخت ہیں جو جب ضروری ہو تو درخت پر گردش کرتے ہوئے اپنے توازن کو برقرار رکھتے ہیں۔توازن کے معیار میں دونوں جھوٹ کے درمیان بنیادی فرق اور درختوں کو متوازن کرنے کے لئے درکار گردشوں کی تعداد۔زیادہ سے زیادہ ایک کے ذریعہ۔ توازن درخت پر گردشیں انجام دے کر کیا جاتا ہے جب نوڈ کے بائیں اور دائیں سبٹری کے درمیان اونچائی کا فرق ایک سے زیادہ ہوتا ہے۔ اے وی ایل درخت سرخ سیاہ درختوں سے زیادہ سختی سے متوازن ہوتے ہیں ، جس کا مطلب ہے کہ وہ تیز رفتار فراہم کرتے ہیں۔تلاشیں لیکن آہستہ آہستہ اندراج اور حذف کرنے کی کارروائیوں کو۔ درختوں کو سرخ رنگ کے درختوں سے زیادہ درختوں میں توازن کے ل more زیادہ گردش کی ضرورت ہوتی ہے۔ سرخ رنگ کے درخت: سرخ سیاہ درخت تقریبا اونچائی سے متوازن بائنری تلاش کے درخت ہیں ، جس کا مطلب ہے کہ بائیں کی اونچائی اورکسی بھی نوڈ کے دائیں ذیلی ذخیرے زیادہ سے زیادہ دو سے مختلف ہوسکتے ہیں۔ ری بیلنسنگ گردش انجام دینے اور درخت میں نوڈس کو دوبارہ بنانے سے کی جاتی ہے جب ضروری ہو۔توازن۔ سیاہ درختوں کے درختوں کے مقابلے میں درخت کو متوازن کرنے کے لئے کم گردش کی ضرورت ہوتی ہے۔ دونوں کے درخت اور سرخ رنگ کے درختوں کا استعمال بائنری تلاش کے درختوں کی کارکردگی کو بہتر بنانے کے لئے کیا جاتا ہے تاکہ وہ اپنے توازن کو برقرار رکھیں۔دونوں کے مابین انتخاب کا انحصار مخصوص درخواست اور تلاش کی تعداد اور اضافے اور حذفوں کی تعداد کے مابین توازن پر ہے۔عام طور پر ، اے وی ایل کے درختوں کو ان ایپلی کیشنز کے لئے ترجیح دی جاتی ہے جن کے لئے تیز تر تلاش کی ضرورت ہوتی ہے ، جبکہ سرخ رنگ کے درختوں کو ان ایپلی کیشنز کے لئے ترجیح دی جاتی ہے جن میں تیزی سے داخل ہونے اور حذف کرنے کی کارروائیوں کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "ریڈکس درخت کیسے کام کرتا ہے؟",
        "Answer": "ایک ریڈکس ٹری ، جسے ریڈکس ٹری یا کمپیکٹ پریفکس ٹری کے نام سے بھی جانا جاتا ہے ، ایک اعداد و شمار کا ڈھانچہ ہے جو خلائی سے بہتر ٹری (سابقہ درخت) کی نمائندگی کرتا ہے جس میں ہر نوڈ جو اکلوتا بچہ ہوتا ہے اس کے والدین کے ساتھ مل جاتا ہے۔نتیجہ یہ ہے کہ ہر داخلی نوڈ کے بچوں کی تعداد زیادہ تر ریڈکس ٹری کے ریڈکس آر پر ہوتی ہے ، جہاں آر ایک مثبت عدد اور 2 کا پاور ایکس ہے ، جس میں x ≥ 1. ریڈکس کے درخت اس کے ساتھ ایسوسی ایٹو صفوں کی تعمیر کے لئے مفید ہیں۔چابیاں جن کا اظہار تار کے طور پر کیا جاسکتا ہے۔انہیں آئی پی روٹنگ کے شعبے میں خصوصی اطلاق ملتا ہے ، جہاں کچھ مستثنیات کے ساتھ اقدار کی بڑی حدود رکھنے کی صلاحیت خاص طور پر IP پتے کی درجہ بندی کی تنظیم کے لئے موزوں ہے۔وہ معلومات کی بازیافت میں ٹیکسٹ دستاویزات کے الٹی اشاریہ کے لئے بھی استعمال ہوتے ہیں۔ریڈکس درخت اندراج ، حذف کرنے ، اور تلاش کے کاموں کی حمایت کرتے ہیں۔ذخیرہ شدہ ڈیٹا کی مقدار کو کم سے کم کرنے کی کوشش کرتے ہوئے اندراج ٹرائی میں ایک نیا تار شامل کرتا ہے۔ذخیرہ شدہ اعداد و شمار کی مقدار کو کم سے کم کرنے کی کوشش کرتے ہوئے حذف کرنے سے ٹرائی سے ایک تار ہٹ جاتا ہے۔تلاش کرنے سے کسی دیئے گئے کلید سے وابستہ قدر مل جاتی ہے۔ریڈکس کے درخت اپنے ڈیٹا کو کناروں کی ترتیب میں سرایت کرتے ہیں جس سے نوڈ کی طرف جاتا ہے۔اس کا مطلب یہ ہے کہ صرف پتے (نیچے دیئے گئے نوڈس) واقعی ایک کوڈڈ قدر کی نمائندگی کرتے ہیں۔کوڈڈ ویلیو وہ راستہ ہے جو اس کی طرف جاتا ہے۔ریڈکس کے درخت نوڈس کو ضم کرکے نوڈ اوور ہیڈ کو بچانے کے لئے \"پاتھ کمپریشن\" نامی کسی چیز کا فائدہ اٹھاتے ہیں۔جب خود متوازن بائنری تلاش کے درختوں کے مقابلے میں ریڈکس کے درخت ایک آسان اور زیادہ جگہ سے موثر ڈھانچے کے طور پر ڈیزائن کیے گئے ہیں۔"
    },
    {
        "Question": "بی ٹری کیا ہے اور یہ بائنری سرچ کے درخت سے کیسے مختلف ہے؟",
        "Answer": "ایک بی ٹری ایک خود توازن رکھنے والے درختوں کے اعداد و شمار کا ڈھانچہ ہے جو ترتیب شدہ ڈیٹا کو برقرار رکھتا ہے اور لوگرتھمک وقت میں تلاش ، ترتیب تک رسائی ، اضافے اور حذف کرنے کی اجازت دیتا ہے۔یہ درخت کی ایک قسم ہے جو ڈسک تک رسائی کے ل optim بہتر ہے اور ڈیٹا بیس اور فائل سسٹم میں استعمال ہوتی ہے۔بی ٹری بائنری سرچ ٹری سے مندرجہ ذیل طریقوں سے مختلف ہے: بی ٹری میں دو سے زیادہ بچے ہوسکتے ہیں ، جبکہ بائنری سرچ کا درخت زیادہ سے زیادہ دو بچوں میں ہوسکتا ہے۔ ایک بی ٹری ایک چھانٹیا ہوا درخت ہے ، جبکہ ایکبائنری سرچ ٹری کو لازمی طور پر ترتیب نہیں دیا جاتا ہے۔ اے بی ٹری ڈسک پر ڈیٹا اسٹوریج کے لئے استعمال ہوتا ہے ، جبکہ بائنری سرچ ٹری رام میں ڈیٹا اسٹوریج کے لئے استعمال ہوتا ہے۔ بی ٹری میں لاگ ایم این کی اونچائی ہوتی ہے ، جہاں ایم آرڈر ہوتا ہےدرخت اور این میں نوڈس کی تعداد ہے ، جبکہ بائنری سرچ ٹری کی اونچائی لاگ 2 این کی ہے ، جہاں ن نوڈس کی تعداد ہے۔ بی ٹریوں کو ایپلی کیشنز میں استعمال کیا جاتا ہے جہاں ڈیٹا کو ڈسک پر محفوظ کیا جاتا ہے اور تیز رفتار رسائی کی ضرورت ہوتی ہے۔وہ ڈیٹا بیس اور فائل سسٹم میں بھی بڑی مقدار میں ڈیٹا کو موثر انداز میں ذخیرہ کرنے کے لئے استعمال ہوتے ہیں۔ خلاصہ میں ، بی ٹری ایک خود توازن درختوں کے اعداد و شمار کا ڈھانچہ ہے جو ترتیب شدہ ڈیٹا کو برقرار رکھتا ہے اور تلاش ، ترتیب تک رسائی ، اضافے اور لوگرتھمک وقت میں حذف کرنے کی اجازت دیتا ہے۔یہ بائنری سرچ ٹری سے مختلف ہے جس میں اس میں دو سے زیادہ بچے ہوسکتے ہیں ، ایک چھانٹیا ہوا درخت ہے ، ڈسک پر ڈیٹا اسٹوریج کے لئے استعمال ہوتا ہے ، اور اس کی اونچائی لاگ ایم این کی ہے۔ بی ٹریوں کو ایپلی کیشنز میں استعمال کیا جاتا ہے جہاں ڈیٹا ہے۔ڈسک اور فاسٹ تک رسائی پر ذخیرہ کرنے کی ضرورت ہے 123456"
    },
    {
        "Question": "درخت پر مبنی ڈیٹا ڈھانچے کا استعمال کرتے ہوئے ہف مین کوڈنگ کے تصور کی وضاحت کریں۔",
        "Answer": "ہف مین کوڈنگ ایک ایسی تکنیک ہے جو اعداد و شمار کو کمپریس کرنے کے لئے استعمال کی جاتی ہے جس کی تعدد کی بنیاد پر ان کی تعدد کی بنیاد پر متغیر لمبائی کے کوڈز تفویض کرتے ہیں۔کوڈز کو اس طرح تفویض کیا گیا ہے کہ کوئی کوڈ کسی دوسرے کوڈ کا سابقہ نہیں ہے ، جو اس بات کو یقینی بناتا ہے کہ کوڈ کو منفرد طور پر ضابطہ کشائی کی جاسکے۔ہف مین کوڈنگ الگورتھم کوڈ کو تیار کرنے کے لئے درخت پر مبنی ڈیٹا ڈھانچہ استعمال کرتا ہے۔درخت بار بار دو نوڈس کو کم ترین تعدد کے ساتھ مل کر تعمیر کیا جاتا ہے جب تک کہ ایک نوڈ نہ رہ جائے ، جو درخت کی جڑ بن جاتا ہے۔درخت کی بائیں اور دائیں شاخیں بالترتیب کوڈ کے 0 اور 1 بٹس کی نمائندگی کرتی ہیں۔کوڈ درخت کو جڑ سے پتی کے نوڈس تک جانے سے پیدا ہوتے ہیں ، ہر شاخ کو 0 یا 1 بٹ تفویض کرتے ہیں اس پر منحصر ہے کہ یہ بائیں یا دائیں شاخ ہے۔ہر کردار کے نتیجے میں کوڈ 0 اور 1 بٹس کی جڑ سے متعلقہ پتی نوڈ کی ترتیب ہے۔ ہف مین کوڈنگ الگورتھم مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، بشمول ڈیٹا کمپریشن ، امیج کمپریشن ، اور ٹیکسٹ انکوڈنگ۔یہ ایک لچکدار کمپریشن تکنیک ہے ، جس کا مطلب ہے کہ کمپریسڈ ڈیٹا سے اصل اعداد و شمار کو مکمل طور پر دوبارہ تشکیل دیا جاسکتا ہے۔ خلاصہ میں ، ہف مین کوڈنگ ایک ایسی تکنیک ہے جو ان کی موجودگی کی تعدد کی بنیاد پر حروف کو متغیر لمبائی کے کوڈز کو تفویض کرکے ڈیٹا کو کمپریس کرنے کے لئے استعمال کی جاتی ہے۔ہف مین کوڈنگ الگورتھم کوڈز تیار کرنے کے لئے درخت پر مبنی ڈیٹا ڈھانچہ کا استعمال کرتا ہے ، جہاں درخت کی بائیں اور دائیں شاخیں بالترتیب 0 اور 1 بٹس کی نمائندگی کرتی ہیں۔کوڈ درخت کو جڑ سے پتی کے نوڈس تک جانے سے پیدا ہوتے ہیں ، ہر شاخ کو 0 یا 1 بٹ تفویض کرتے ہیں اس پر منحصر ہے کہ یہ بائیں یا دائیں شاخ ہے۔ہر کردار کے نتیجے میں کوڈ 0 اور 1 بٹس کی جڑ سے متعلقہ پتی نوڈ کی ترتیب ہے۔ہف مین کوڈنگ الگورتھم مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، بشمول ڈیٹا کمپریشن ، امیج کمپریشن ، اور ٹیکسٹ انکوڈنگ 123456.1purdue2indiana3programiz4vt5tutorialspoint6wmich"
    },
    {
        "Question": "ملحقہ میٹرکس کیا ہے اور یہ گراف کی نمائندگی کرنے کے لئے کس طرح استعمال ہوتا ہے؟",
        "Answer": "ملحقہ میٹرکس ایک مربع میٹرکس ہے جو ایک محدود گراف کی نمائندگی کرنے کے لئے استعمال ہوتا ہے۔یہ ایک دو جہتی صف ہے جو اس بارے میں معلومات کو محفوظ کرتی ہے کہ آیا گراف میں جوڑے ملحقہ ہیں یا نہیں۔میٹرکس کے عناصر اس بات کی نشاندہی کرتے ہیں کہ آیا ورٹیکس I سے لے کر ورٹیکس جے تک ایک کنارے موجود ہیں۔میٹرکس کے اخترن عناصر تمام صفر ہیں کیونکہ ایک عمودی سے اپنے آپ کو (لوپس) کے کنارے آسان گرافوں میں اجازت نہیں ہے۔ملحقہ میٹرکس ایم ایکس ایم میٹرکس ایم کے ن عمات پر مشتمل محدود گراف کی نمائندگی کرنے کا ایک کمپیکٹ طریقہ ہے۔ ملحقہ میٹرکس کو اس بات کا تعین کرنے کے لئے استعمال کیا جاسکتا ہے کہ گراف منسلک ہے یا نہیں۔ملحقہ میٹرکس گرافوں میں ہیرا پھیری کے ل computer کمپیوٹر پروگراموں میں گراف کی نمائندگی کے لئے ڈیٹا ڈھانچے کے طور پر استعمال کیا جاسکتا ہے۔اس ایپلی کیشن کے لئے استعمال میں بھی اہم متبادل ڈیٹا ڈھانچہ ، ملحقہ فہرست ہے۔ خلاصہ یہ ہے کہ ، ایک ملحقہ میٹرکس ایک مربع میٹرکس ہے جو ایک محدود گراف کی نمائندگی کرنے کے لئے استعمال ہوتا ہے۔یہ ایک دو جہتی صف ہے جو اس بارے میں معلومات کو محفوظ کرتی ہے کہ آیا گراف میں جوڑے ملحقہ ہیں یا نہیں۔ملحقہ میٹرکس ایم ایکس ایم میٹرکس ایم کے ن عمات پر مشتمل محدود گراف کی نمائندگی کرنے کا ایک کمپیکٹ طریقہ ہے۔ ملحقہ میٹرکس کو اس بات کا تعین کرنے کے لئے استعمال کیا جاسکتا ہے کہ گراف منسلک ہے یا نہیں۔ملحقہ میٹرکس کو گرافس 123456.1 وکیپیڈیا 2 بی ای جے یو ایس 3 کے ذریعہ کمپیوٹر پروگراموں میں گراف کی نمائندگی کے لئے ڈیٹا ڈھانچے کے طور پر استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "آپ گراف پر بی ایف ایس (چوڑائی کی پہلی تلاش) الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "کسی گراف پر بی ایف ایس (چوڑائی کی پہلی تلاش) الگورتھم کو نافذ کرنے کے ل we ، ہم ان اقدامات پر عمل پیرا ہوسکتے ہیں: ایک قطار بنائیں اور ابتدائی حد کو قطار پر لگائیں۔قطار اور اس کا دورہ کریں۔ ملاحظہ شدہ ورٹیکس کے ہر غیر منحصر پڑوسی کے ل it ، اسے ملاحظہ کریں اور اسے قطار میں لگائیں۔ بی ایف ایس الگورتھم پرت کے لحاظ سے گراف پرت کی کھوج کرکے کام کرتا ہے ، ماخذ نوڈ سے شروع ہوتا ہے اور تمام نوڈس کا دورہ کرتا ہے۔اگلی گہرائی کی سطح پر نوڈس پر جانے سے پہلے موجودہ گہرائی کی سطح۔بی ایف ایس گراف میں نوڈس کا تجزیہ کرنے اور ان کے ذریعے سفر کرنے کا مختصر ترین راستہ تعمیر کرنے کے لئے مفید ہے۔بی ایف ایس تکرار کی سب سے چھوٹی تعداد میں گراف کے ذریعے عبور کرسکتا ہے۔بی ایف ایس الگورتھم کا فن تعمیر آسان اور مضبوط ہے۔بی ایف ایس الگورتھم کا نتیجہ دوسرے الگورتھم کے مقابلے میں اعلی سطح کی درستگی کا حامل ہے۔بی ایف ایس تکرار ہموار ہیں ، اور اس الگورتھم کے لامحدود لوپ کے مسئلے میں پھنس جانے کا کوئی امکان نہیں ہے۔ جاوا میں بی ایف ایس کو نافذ کرنے کے متعدد طریقے ہیں۔ہم گراف کی نمائندگی کے لئے ملحقہ فہرست استعمال کرسکتے ہیں اور الگورتھم کے نفاذ کے لئے تکرار کے ساتھ ساتھ ایک تکراری نقطہ نظر دونوں کا احاطہ کرسکتے ہیں۔جاوا میں بی ایف ایس الگورتھم کے لئے تکراری عمل درآمد مندرجہ ذیل ہے: باطل بی ایف ایس (انٹ ورٹیکس) {قطار <انٹیجر> قطار = نئی لنکڈ لسٹ <> () ؛ملاحظہ کیا [ورٹیکس] = سچ ؛قطار.اڈ (ورٹیکس) ؛جبکہ (! قطار.ایسپٹی ()) {انٹ کرنٹ = قطار۔ پول () ؛system.out.print (موجودہ + \"\") ؛کے لئے (INT پڑوسی: ایڈجسٹس [موجودہ]) {اگر (! ملاحظہ کیا [پڑوسی]) {ملاحظہ کیا [پڑوسی] = سچ ؛قطار.اڈ (پڑوسی) ؛}}} this اس نفاذ میں ، BFS فنکشن ان پٹ کے طور پر ایک ابتدائی عمومی طور پر لیتا ہے اور گراف پر چوڑائی کی پہلی تلاش کرتا ہے۔فنکشن ابتدائی ورٹیکس کو ملاحظہ کی طرح نشان زد کرتا ہے ، اسے قطار میں ڈالتا ہے ، اور پھر تکراری طور پر قطار سے عمودی کو ختم کرتا ہے اور ان سے ملتا ہے۔ملاحظہ کرنے والے ورٹیکس کے ہر غیر منحصر پڑوسی کے ل the ، فنکشن اس کو ملاحظہ کی طرح نشان زد کرتا ہے اور اسے قطار پر جوڑ دیتا ہے۔ خلاصہ ، کسی گراف پر بی ایف ایس الگورتھم کو نافذ کرنے کے لئے ، ہمیں ایک قطار بنانے اور ابتدائی حد کو قطار میں ڈالنے کی ضرورت ہے۔اس کے بعد ہم ابتدائی ورٹیکس کو تشریف لاتے ہوئے نشان زد کرتے ہیں اور جب قطار خالی نہیں ہوتی ہے ، تو ہم قطار سے ایک چوٹی کو ڈی کیوئ کرتے ہیں اور اس پر جاتے ہیں۔دورہ شدہ ورٹیکس کے ہر غیر منحصر پڑوسی کے ل we ، ہم اسے ملاحظہ کی طرح نشان زد کرتے ہیں اور اسے قطار میں لگاتے ہیں۔بی ایف ایس گراف میں نوڈس کا تجزیہ کرنے اور ان کے ذریعے سفر کرنے کا مختصر ترین راستہ تعمیر کرنے کے لئے مفید ہے۔بی ایف ایس تکرار کی سب سے چھوٹی تعداد میں گراف کے ذریعے عبور کرسکتا ہے۔بی ایف ایس الگورتھم کا فن تعمیر آسان اور مضبوط ہے۔بی ایف ایس الگورتھم کا نتیجہ دوسرے الگورتھمز 123456.1 جیورو 992 جی ای ای ایکسفور جی ای ای ایکس 3 ہیکیریٹورفورفورٹور 5 پرو گرامج 6 جےواٹ پوائنٹ کے مقابلے میں اعلی سطح کی درستگی کا حامل ہے۔"
    },
    {
        "Question": "ایک لاحقہ سرنی کیا ہے اور یہ کیسے مفید ہے؟",
        "Answer": "ایک لاحقہ سرنی دیئے گئے تار کے تمام لاحقہ کا ایک ترتیب شدہ صف ہے۔یہ ایک ڈیٹا ڈھانچہ ہے جو مکمل ٹیکسٹ انڈیکس ، ڈیٹا کمپریشن الگورتھم ، اور بائبلومیٹرکس کے فیلڈ میں استعمال ہوتا ہے۔منبر اینڈ مائرز (1990) نے لاحقہ درختوں کے لئے ایک آسان ، خلائی موثر متبادل کے طور پر لاحقہ سرنی متعارف کروائی تھی۔انہیں پیٹ سرنی کے نام سے 1987 میں گیسٹن گونٹ نے آزادانہ طور پر دریافت کیا تھا۔لاحقہ درخت کی گہرائی سے پہلے ٹراورسل کو انجام دے کر لاحقہ درخت سے ایک لاحقہ سرنی تعمیر کی جاسکتی ہے۔لاحقہ سرنی ٹریورسل کے ذریعہ دیئے گئے پتی لیبل سے مساوی ہے۔ایک لاحقہ سرنی ایک لاحقہ درخت سے زیادہ کمپیکٹ ہے اور یہ ثانوی میموری میں اسٹوریج کے لئے قابل عمل ہے۔ایک لاحقہ سرنی کو وسیع پیمانے پر مسائل کو حل کرنے کے لئے استعمال کیا جاسکتا ہے ، جس میں سٹرنگ سرچ ، سب سے طویل عام مشترکہ سبسٹرنگ ، اور پیٹرن مماثلت شامل ہے۔لاحقہ درختوں سے زیادہ لاحقہ سرنیوں کے فوائد میں جگہ کی بہتر تقاضے ، آسان لکیری ٹائم تعمیراتی الگورتھم ، اور بہتر کیشے کے علاقے شامل ہیں۔ خلاصہ میں ، ایک لاحقہ سرنی کسی دیئے گئے تار کے تمام لاحقہ کی ایک ترتیب شدہ صف ہے۔یہ ایک ڈیٹا ڈھانچہ ہے جو مکمل ٹیکسٹ انڈیکس ، ڈیٹا کمپریشن الگورتھم ، اور بائبلومیٹرکس کے فیلڈ میں استعمال ہوتا ہے۔لاحقہ درخت کی گہرائی سے پہلے ٹراورسل کو انجام دے کر لاحقہ درخت سے ایک لاحقہ سرنی تعمیر کی جاسکتی ہے۔لاحقہ سرنی ٹریورسل کے ذریعہ دیئے گئے پتی لیبل سے مساوی ہے۔ایک لاحقہ سرنی ایک لاحقہ درخت سے زیادہ کمپیکٹ ہے اور یہ ثانوی میموری میں اسٹوریج کے لئے قابل عمل ہے۔ایک لاحقہ سرنی کو وسیع پیمانے پر مسائل کو حل کرنے کے لئے استعمال کیا جاسکتا ہے ، جس میں سٹرنگ سرچ ، سب سے طویل عام مشترکہ سبسٹرنگ ، اور پیٹرن مماثلت شامل ہے۔لاحقہ درختوں سے زیادہ لاحقہ سرنیوں کے فوائد میں جگہ کی بہتر ضروریات ، آسان لکیری وقت کی تعمیر الگورتھم ، اور بہتر کیشے لوکلیٹی 123456.1wikeipeia2geeksforgeyks3dartmouth4scaler5cp-algorithms6stackoverflow شامل ہیں۔"
    },
    {
        "Question": "ہیش ٹیبل میں ہیش تصادم کے تصور کی وضاحت کریں۔",
        "Answer": "ہیش کے تصادم ایک ہیش ٹیبل میں پائے جاتے ہیں جب ٹیبل میں ایک ہی انڈیکس یا بالٹی میں دو یا زیادہ چابیاں نقش کردی جاتی ہیں۔یہ ٹیبل کے محدود سائز اور ممکنہ چابیاں کی لامحدود تعداد کی وجہ سے ہوسکتا ہے۔جب تصادم ہوتا ہے تو ، ہیش ٹیبل کو ایک ہی بالٹی میں ایک سے زیادہ چابیاں اسٹور کرکے یا کلید کو ذخیرہ کرنے کے لئے ایک مختلف بالٹی تلاش کرکے تصادم کو حل کرنے کی ضرورت ہوتی ہے۔ہیش کے تصادم کو سنبھالنے کے لئے متعدد تکنیکیں ہیں ، بشمول: علیحدہ زنجیر: اس تکنیک میں ، ہیش ٹیبل میں ہر بالٹی ایک منسلک فہرست ہے ، اور تصادم کو اسی طرح کی بالٹی پر منسلک فہرست میں شامل کرکے حل کیا جاتا ہے۔ اوپن ایڈریسنگ۔اس تکنیک میں ، جب تصادم ہوتا ہے تو ، ہیش ٹیبل اگلی دستیاب بالٹی کو بالٹیوں کے پہلے سے طے شدہ ترتیب میں دیکھتا ہے جب تک کہ خالی بالٹی نہ مل جائے۔ لائنر تحقیقات: اس تکنیک میں ، جب تصادم ہوتا ہے تو ، ہیش ٹیبل اگلے کی تلاش کرتا ہےایک لکیری ترتیب میں دستیاب بالٹی جب تک کہ خالی بالٹی نہیں مل جاتی ہے۔ کوآرڈیٹک تحقیقات: اس تکنیک میں ، جب تصادم ہوتا ہے تو ، ہیش ٹیبل اگلی دستیاب بالٹی کو ایک چوکور ترتیب میں تلاش کرتا ہے جب تک کہ خالی بالٹی پائے جاتے ہیں۔کلید کی تلاش کے لئے درکار وقت میں اضافہ کرکے یا ہیش ٹیبل کے سائز میں اضافہ کرکے ہیش ٹیبل کی کارکردگی۔لہذا ، یہ ضروری ہے کہ کسی اچھ have ے ہیش فنکشن کا انتخاب کیا جائے جو تصادم کی تعداد کو کم سے کم کرے اور تصادم کو سنبھالنے کے لئے تصادم کی ریزولوشن کی مناسب تکنیک کا استعمال کرے۔ایک اچھی طرح سے ڈیزائن کردہ ہیش ٹیبل عام طور پر کچھ تصادم پیش کرتا ہے ، اور تصادم کی قرارداد کی تکنیک کا انتخاب مخصوص درخواست اور متوقع تعداد پر منحصر ہوتا ہے۔"
    },
    {
        "Question": "خود کو منظم کرنے کی فہرست ڈیٹا ڈھانچے کا کام کیسے کام کرتا ہے؟",
        "Answer": "ایک خود تنظیم سازی کی فہرست ایک ڈیٹا ڈھانچہ ہے جو اوسط تک رسائی کے وقت کو بہتر بنانے کے ل some کچھ خود تنظیمی ہورسٹک کی بنیاد پر اپنے عناصر کی بحالی کرتا ہے۔خود تنظیم سازی کی فہرست کا مقصد لکیری تلاش کی کارکردگی کو بہتر بنانا ہے جس میں زیادہ کثرت سے رسائی والی اشیاء کو فہرست کے سر کی طرف منتقل کیا جائے۔خود تنظیم سازی کی فہرست کا آسان ترین نفاذ ایک منسلک فہرست کے طور پر ہے ، لیکن یہ بے ترتیب نوڈس تک ناکارہ رسائی سے دوچار ہے۔اس نا اہلی کو کم کرنے کے ل a ، ایک خود تنظیم سازی کی فہرست رن ٹائم کے وقت مختلف استفسار تقسیم کو اپنانے کے لئے تنظیم نو الگورتھم کا استعمال کرتی ہے۔خود تنظیم سازی کی فہرستوں کے ذریعہ بہت سی حکمت عملی استعمال کی جاتی ہے ، جن میں شامل ہیں: موو ٹو فرنٹ کا طریقہ: اس طریقہ کار میں ، کسی بھی نوڈ کو تلاش کی گئی فہرست کے سامنے منتقل کیا جاتا ہے۔یہ طریقہ رسائی کے نمونوں کو تبدیل کرنے میں تیزی سے ڈھال دیتا ہے۔ حساب کا طریقہ: اس طریقہ کار میں ، ہر نوڈ کی گنتی اس کے ساتھ وابستہ ہوتی ہے ، اور نوڈس کو ان کی گنتی کی بنیاد پر دوبارہ ترتیب دیا جاتا ہے۔یہ طریقہ رسائی کے نمونوں کو تبدیل کرنے کے ل more زیادہ آہستہ آہستہ ڈھالتا ہے۔یہ طریقہ رسائی کے نمونوں کو تبدیل کرنے کے ل quickly جلدی سے موافقت نہیں رکھتا ہے۔ خود تنظیم سازی کی فہرستیں اس فہرست کو دوبارہ ترتیب دینے کا فیصلہ کرنے کے لئے ایک ہورسٹک کا استعمال کرتی ہیں۔یہ ہورسٹکس بفر تالابوں کے انتظام کے قواعد سے ملتے جلتے ہیں۔در حقیقت ، ایک بفر پول خود تنظیم سازی کی فہرست کی ایک شکل ہے۔متوقع تعدد کے ذریعہ بفر پول کا آرڈر دینا ایک اچھی حکمت عملی ہے ، کیونکہ عام طور پر ہمیں بفروں کے مندرجات کو تلاش کرنا ہوگا تاکہ یہ معلوم کیا جاسکے کہ مطلوبہ معلومات پہلے ہی مرکزی میموری میں ہے یا نہیں۔اگرچہ خود تنظیم سازی کی فہرستیں عام طور پر تلاش کے درختوں یا کسی ترتیب شدہ فہرست کے ساتھ ساتھ انجام نہیں دیتی ہیں ، ان دونوں کو O (لاگ این) تلاش کے وقت کی ضرورت ہوتی ہے ، بہت سارے حالات ایسے ہیں جن میں خود تنظیم سازی کی فہرستیں ایک قیمتی ٹول ثابت کرتی ہیں۔ خلاصہ ، ایک۔خود کو منظم کرنے کی فہرست ایک ڈیٹا ڈھانچہ ہے جو اوسط تک رسائی کے وقت کو بہتر بنانے کے ل some کچھ خود تنظیمی ہورسٹک کی بنیاد پر اپنے عناصر کی بحالی کرتا ہے۔خود تنظیم سازی کی فہرست کا مقصد لکیری تلاش کی کارکردگی کو بہتر بنانا ہے جس میں زیادہ کثرت سے رسائی والی اشیاء کو فہرست کے سر کی طرف منتقل کیا جائے۔خود تنظیم سازی کی فہرستیں رن ٹائم کے وقت مختلف سوالات کی تقسیم کے مطابق ڈھالنے کے لئے تنظیم نو الگورتھم کا استعمال کرتی ہیں۔خود تنظیم سازی کی فہرستوں کے ذریعہ متعدد حکمت عملی استعمال کی جاتی ہیں ، جن میں اقدام سے سامنے کا طریقہ ، گنتی کا طریقہ ، اور ٹرانسپوز طریقہ شامل ہے۔اگرچہ خود کو منظم کرنے والی فہرستیں عام طور پر تلاش کے درختوں یا ترتیب شدہ فہرست کے ساتھ ساتھ انجام نہیں دیتی ہیں ، ان دونوں کو O (لاگ این) تلاش کے وقت کی ضرورت ہوتی ہے ، لیکن بہت سارے حالات موجود ہیں جن میں خود کو منظم کرنے والی فہرستیں ایک قیمتی ٹول 123456.1wisdomejobs2wikeipedia3geeksforgeeks5slideslideshare6vte کو ثابت کرتی ہیں۔"
    },
    {
        "Question": "ڈھیر ڈیٹا ڈھانچے میں کم سے کم عنصر کی تلاش میں وقت کی پیچیدگی کیا ہے؟",
        "Answer": "ڈھیر کے اعداد و شمار کے ڈھانچے میں کم سے کم عنصر کو تلاش کرنے کی وقت کی پیچیدگی اس بات پر منحصر ہے کہ آیا ہیپ ایک کم ہیپ ہے یا زیادہ سے زیادہ ہیپ ہے۔ایک منٹ میں ، کم سے کم عنصر ہمیشہ ڈھیر کی جڑ میں ہوتا ہے ، اور اس کی وقت کی پیچیدگی O (1) ہوتی ہے۔زیادہ سے زیادہ چھت میں ، کم سے کم عنصر آسانی سے دستیاب نہیں ہوتا ہے ، اور ہمیں اسے تلاش کرنے کے لئے ڈھیر کو عبور کرنے کی ضرورت ہے۔زیادہ سے زیادہ ہیپ میں کم سے کم عنصر کی تلاش کے ل Br بروٹ فورس نقطہ نظر ہیپ میں موجود تمام نوڈس کی جانچ کرنا ہے ، جس میں O (n) کی وقت کی پیچیدگی ہوتی ہے۔تاہم ، ایک موثر نقطہ نظر زیادہ سے زیادہ ہیپ پراپرٹی کو استعمال کرنا ہے ، جس کے لئے یہ ضروری ہے کہ والدین کا نوڈ اس کے بچے نوڈ (زبانیں) سے زیادہ ہو۔اس پراپرٹی کی وجہ سے ، ہم یہ نتیجہ اخذ کرسکتے ہیں کہ غیر پتی نوڈ کم سے کم عنصر نہیں ہوسکتا ہے کیونکہ اس کے بچے نوڈ کی قیمت کم ہے۔لہذا ہم اپنی تلاش کو ڈھیر کے پتے کے نوڈس تک محدود کرسکتے ہیں ، جس میں این عناصر کے ساتھ ڈھیر کے لئے O (لاگ این) کی وقت کی پیچیدگی ہوتی ہے۔ خلاصہ میں ، ڈھیر ڈیٹا ڈھانچے میں کم سے کم عنصر کی تلاش کرنے کی وقت کی پیچیدگی کا انحصار ہوتا ہے۔اس پر کہ ڈھیر ایک کم ہیپ ہے یا زیادہ سے زیادہ ہیپ ہے۔ایک منٹ میں ، کم سے کم عنصر ہمیشہ ڈھیر کی جڑ میں ہوتا ہے ، اور اس کی وقت کی پیچیدگی O (1) ہوتی ہے۔زیادہ سے زیادہ ڈھیر میں ، کم سے کم عنصر تلاش کرنے کی وقت کی پیچیدگی N عناصر کے ساتھ ڈھیر کے لئے O (لاگ این) ہے ، ایک موثر نقطہ نظر کا استعمال کرتے ہوئے جو زیادہ سے زیادہ پراپرٹی 123456.1GeeksforgeEKS2STACKOVERFLOW3Linkedin4Stackexchangedcective"
    },
    {
        "Question": "ایک سپلی ٹری کیا ہے اور اسے کس طرح استعمال کیا جاتا ہے؟",
        "Answer": "ایک سپلی ٹری ایک خود کو ایڈجسٹ کرنے والا بائنری سرچ درخت ہے جو حال ہی میں حاصل ہونے والے نوڈ کو جڑ میں لانے کے لئے ہر آپریشن کے بعد خود کو تنظیم نو کرتا ہے۔یہ ان کی کلیدی اقدار کی بنیاد پر ڈیٹا عناصر تک موثر رسائی کے لئے ڈیزائن کیا گیا ہے۔اسپلے کے درخت روایتی متوازن بائنری تلاش کے درختوں سے مختلف ہیں جیسے اے وی ایل اور سرخ رنگ کے درخت ، کیونکہ وہ حال ہی میں رسائی نوڈ کو جڑ میں لانے کے لئے ہر آپریشن کے بعد درخت کی تنظیم نو کرتے ہیں۔اس سے درخت کی اونچائی کو کم کرنے میں مدد ملتی ہے اور اس کے نتیجے میں تیزی سے کام ہوتے ہیں۔چھڑکنے والے درختوں کے لئے بنیادی آپریشن ہے جو درخت کو دوبارہ ترتیب دیتا ہے تاکہ عنصر کو درخت کی جڑ پر رکھا جائے۔چھڑکنے والے درخت انتہائی لچکدار ہوتے ہیں اور استعمال کے مختلف معاملات میں ڈھال سکتے ہیں۔وہ مختلف ایپلی کیشنز میں بڑے پیمانے پر استعمال ہوتے ہیں اور کارکردگی اور سادگی کے مابین ایک بہترین تجارت فراہم کرتے ہیں۔ اس کھیل کے درختوں میں بائنری سرچ ٹری کی تمام کارروائی ہوتی ہے ، جیسے اندراج ، حذف کرنا ، اور تلاش کرنا۔لیکن ان میں ایک اور آپریشن بھی ہوتا ہے ، جسے splaying کہا جاتا ہے۔ایک چھڑکنے والے درخت میں ، ہر آپریشن درخت کی جڑ پر انجام دیا جاتا ہے۔اسپلے کے درخت میں موجود تمام کارروائیوں میں ایک عام آپریشن شامل ہوتا ہے جس کو splaying کہتے ہیں۔سپلی ٹری ایک متحرک خود توازن بائنری سرچ ٹری ڈیٹا ڈھانچہ ہے جو عناصر کو تلاش کرنے ، داخل کرنے اور حذف کرنے کا ایک موثر طریقہ فراہم کرتا ہے۔وہ انتہائی ورسٹائل ہیں اور استعمال کے مختلف معاملات میں ڈھال سکتے ہیں۔ دیگر بائنری سرچ درختوں کے اوپر چھڑکنے والے درختوں کے فوائد میں بہتر کارکردگی ، سادگی اور استعداد شامل ہے۔مختلف ایپلی کیشنز میں سپلی کے درخت بڑے پیمانے پر استعمال ہوتے ہیں ، بشمول نیٹ ورک روٹرز ، ڈیٹا کمپریشن ، اور ڈیٹا بیس انڈیکسنگ۔اسپلے کا درخت متوازن بائنری سرچ ٹری کا موثر نفاذ ہے جو آنے والی تلاش کی درخواستوں میں استعمال ہونے والی چابیاں میں محل وقوع کا فائدہ اٹھاتا ہے۔بہت ساری ایپلی کیشنز کے لئے ، بہترین کلیدی علاقہ ہے۔اگر بہت کم عناصر کا بھاری استعمال ہورہا ہے تو ، وہ درخت کی چوٹی کے قریب پائے جائیں گے اور اس طرح جلدی سے پائے جاتے ہیں۔ خلاصہ یہ کہ ایک سپلینگ کا درخت خود کو ایڈجسٹ کرنے والا بائنری سرچ درخت ہے جو ہر آپریشن کے بعد خود کو تنظیم نو کرتا ہے۔حال ہی میں حاصل شدہ نوڈ کو جڑ میں لائیں۔اسپلے کے درخت روایتی متوازن بائنری تلاش کے درختوں سے مختلف ہیں جیسے اے وی ایل اور سرخ رنگ کے درخت ، کیونکہ وہ حال ہی میں رسائی نوڈ کو جڑ میں لانے کے لئے ہر آپریشن کے بعد درخت کی تنظیم نو کرتے ہیں۔چھڑکنے والے درخت انتہائی لچکدار ہوتے ہیں اور استعمال کے مختلف معاملات میں ڈھال سکتے ہیں۔وہ مختلف ایپلی کیشنز میں وسیع پیمانے پر استعمال ہوتے ہیں اور کارکردگی اور سادگی 123456.1educative2geeksforgeeks3indstate4astikanand5scaler6cornell کے مابین ایک بہترین تجارت فراہم کرتے ہیں۔"
    },
    {
        "Question": "اسکیپ گراف ڈیٹا ڈھانچہ کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "اسکیپ گراف ایک تقسیم شدہ ڈیٹا ڈھانچہ ہے جو تقسیم شدہ نظام میں متوازن درخت کی مکمل فعالیت فراہم کرتا ہے۔یہ اسکیپ لسٹوں پر مبنی ہے ، جو ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو عناصر کی ایک ترتیب شدہ فہرست کو اسٹور کرسکتا ہے اور تیز رفتار تلاش ، اندراج اور حذف کرنے کی کارروائیوں کی حمایت کرسکتا ہے۔اسکیپ گراف کو تقسیم شدہ ماحول میں موثر تلاش اور اپ ڈیٹ آپریشن فراہم کرنے کے لئے ڈیزائن کیا گیا ہے ، جہاں نوڈس کسی بھی وقت سسٹم میں ناکام یا اس میں شامل ہوسکتے ہیں۔اسکیپ گراف اسکیپ لسٹوں کی طرح ہیں ، لیکن وہ تقسیم شدہ ماحول میں کام کرنے کے لئے ڈیزائن کیے گئے ہیں۔ان میں نوڈس کا ایک مجموعہ ہوتا ہے جو کناروں کے ذریعہ جڑے ہوئے ہوتے ہیں ، جس میں ہدایت شدہ ایسائکلک گراف تشکیل دیتے ہیں۔اسکیپ گراف میں ہر نوڈ میں کلیدی قدر کے جوڑے کا ایک سیٹ ہوتا ہے ، اور کناروں پر چابیاں کے وقفوں کے ساتھ لیبل لگایا جاتا ہے جس سے وہ جڑ جاتے ہیں۔اسکیپ گراف کی سطح میں منظم کیا گیا ہے ، جہاں ہر سطح میں گراف میں نوڈس کا سب سیٹ ہوتا ہے۔اوپر کی سطح میں گراف میں موجود تمام نوڈس ہوتے ہیں ، اور اس کے بعد کے ہر سطح میں پچھلی سطح میں نوڈس کا ایک حصہ ہوتا ہے۔اسکیپ گراف میں موجود نوڈس کو اس طرح منظم کیا گیا ہے کہ ہر نوڈ میں بہت کم پڑوسی ہوتے ہیں ، اور جب ہم گراف کی سطح کو نیچے جاتے ہیں تو پڑوسیوں کی تعداد بڑھ جاتی ہے۔یہ تنظیم موثر تلاش اور اپ ڈیٹ کے کاموں کی اجازت دیتی ہے ، کیونکہ ہر نوڈ میں بہت کم پڑوسیوں کے ساتھ بات چیت کرنے کی اجازت ہوتی ہے۔ اسکیپ گراف ڈیٹا ڈھانچہ تقسیم شدہ نظاموں میں مفید ہے جہاں نوڈس کسی بھی وقت سسٹم میں ناکام یا اس میں شامل ہوسکتے ہیں۔یہ نوڈ کی ناکامیوں کی موجودگی میں بھی موثر تلاش اور اپ ڈیٹ کے کام فراہم کرتا ہے۔اسکیپ گراف کو مختلف ایپلی کیشنز میں استعمال کیا جاتا ہے ، بشمول تقسیم شدہ ڈیٹا بیس ، ہم مرتبہ سے پیر نیٹ ورکس ، اور تقسیم شدہ فائل سسٹم۔اسکیپ گراف ڈیٹا ڈھانچہ تقسیم شدہ نظاموں کی تعمیر کے لئے ایک طاقتور ٹول ہے جس میں نوڈ کی ناکامیوں کی موجودگی میں موثر تلاش اور اپ ڈیٹ آپریشن کی ضرورت ہوتی ہے۔ خلاصہ یہ کہ اسکیپ گراف ایک تقسیم شدہ ڈیٹا ڈھانچہ ہے جو تقسیم میں متوازن درخت کی مکمل فعالیت فراہم کرتا ہے۔نظامیہ اسکیپ لسٹوں پر مبنی ہے ، جو ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو عناصر کی ایک ترتیب شدہ فہرست کو اسٹور کرسکتا ہے اور تیز رفتار تلاش ، اندراج اور حذف کرنے کی کارروائیوں کی حمایت کرسکتا ہے۔اسکیپ گراف کو تقسیم شدہ ماحول میں موثر تلاش اور اپ ڈیٹ آپریشن فراہم کرنے کے لئے ڈیزائن کیا گیا ہے ، جہاں نوڈس کسی بھی وقت سسٹم میں ناکام یا اس میں شامل ہوسکتے ہیں۔اسکیپ گراف کی سطح میں منظم کیا گیا ہے ، جہاں ہر سطح میں گراف میں نوڈس کا سب سیٹ ہوتا ہے۔اسکیپ گراف ڈیٹا کا ڈھانچہ تقسیم شدہ نظاموں میں مفید ہے جہاں نوڈس کسی بھی وقت سسٹم میں ناکام یا شامل ہوسکتے ہیں ، اور یہ مختلف ایپلی کیشنز میں استعمال ہوتا ہے ، بشمول تقسیم شدہ ڈیٹا بیس ، ہم مرتبہ سے ہم مرتبہ نیٹ ورکس ، اور تقسیم شدہ فائل سسٹم 1234456.1NUS2YALE3UIOWA4Linkedin5ResearchGate6yale"
    },
    {
        "Question": "اسٹیک اور قطار کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "اسٹیکس اور قطاریں اعداد و شمار کو ذخیرہ کرنے اور بازیافت کرنے کے لئے کمپیوٹر سائنس میں استعمال ہونے والے دو بنیادی اعداد و شمار کے ڈھانچے ہیں۔اسٹیک اور قطار کے درمیان بنیادی فرق اعداد و شمار کے ڈھانچے سے عناصر کو ہٹا دیا جاتا ہے۔ اسٹیک: آخری ان فرسٹ آؤٹ (LIFO) اصول کی پیروی کرتا ہے ، اس کا مطلب ہے کہ اسٹیک میں شامل آخری عنصر پہلا ایک ہےہٹا دیا جانا چاہئے۔ عنصروں کو اسٹیک کے اوپری حصے سے شامل اور ہٹا دیا جاتا ہے۔ کامن آپریشنز میں پش (اسٹیک کے اوپری حصے میں عنصر شامل کریں) اور پاپ (اسٹیک سے اوپر کا عنصر کو ہٹا دیں) شامل ہیں۔ اسٹیک اکثر بار بار بار بار چلنے والے الگورتھم کے لئے استعمال ہوتے ہیں۔یا ملاحظہ کی گئی ریاستوں کی تاریخ کو برقرار رکھنے کے لئے۔ حقیقی دنیا کی ایپلی کیشنز کے مثالوں میں پروگرامنگ زبانوں میں کال اسٹیک اور ویب براؤزرز میں بیک بٹن شامل ہے۔قطار میں شامل عنصر کو سب سے پہلے ہٹایا جاتا ہے۔ قطار کے عقبی حصے میں عنصر شامل کیے جاتے ہیں اور قطار کے سامنے سے ہٹا دیئے جاتے ہیں۔ کامن آپریشنز میں انکیو (قطار کے عقبی حصے میں عنصر شامل کریں) اور ڈیکوئو (ہٹائیں) شامل ہیں۔قطار سے سامنے کا عنصر). کیوئس اکثر ان حالات میں استعمال ہوتے ہیں جہاں پروسیسنگ کا حکم ضروری ہوتا ہے ، جیسے کاموں کا شیڈولنگ یا پروسیسنگ کی درخواستوں میں۔ حقیقی دنیا کی ایپلی کیشنز کے مثالوں میں گروسری اسٹور پر چیک آؤٹ لائن اور اے میں پرنٹ کی نوکری شامل ہوتی ہے۔پرنٹر قطار۔ ان خلاصہ ، اسٹیک اور قطار کے درمیان بنیادی فرق جس طرح سے اعداد و شمار کے ڈھانچے سے عناصر کو ہٹا دیا جاتا ہے۔ایک اسٹیک LIFO اصول کی پیروی کرتا ہے ، جبکہ ایک قطار FIFO اصول کی پیروی کرتی ہے۔اسٹیک اکثر بار بار بار بار چلنے والی الگورتھم کے لئے یا ملاحظہ کی گئی ریاستوں کی تاریخ کو برقرار رکھنے کے لئے استعمال کیے جاتے ہیں ، جبکہ قطاریں اکثر ایسے حالات میں استعمال ہوتی ہیں جہاں پروسیسنگ کا حکم ضروری ہوتا ہے ، جیسے کاموں کی شیڈولنگ یا پروسیسنگ کی درخواستوں میں 123456.1favtutor2cmu3geksforgeeks4scaler5everythantcomputerscience"
    },
    {
        "Question": "فینوک درخت کیا ہے اور اس کا استعمال کیسے ہوتا ہے؟",
        "Answer": "ایک فینوک درخت ، جسے بائنری انڈیکسڈ ٹری (BIT) بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ایک صف میں موثر اپ ڈیٹ اور سابقہ رقم کے حساب کتاب کی اجازت دیتا ہے۔یہ حدود کی رقم کو موثر انداز میں حساب کرنے اور کسی صف میں عنصر کی اقدار کو اپ ڈیٹ کرنے کے لئے مفید ہے۔فینوک ٹری ایک ڈیٹا ڈھانچہ ہے جو کسی صف میں ڈیٹا کو ذخیرہ کرتا ہے ، حالانکہ اسے درخت کہا جاتا ہے۔اس کی وجہ یہ ہے کہ صف میں ہر سیل اصل صف میں متعدد عناصر کی رقم کو ذخیرہ کرنے کا ذمہ دار ہے۔انڈیکس I پر سیل (G (i) ، i) سے عناصر کی رقم کو ذخیرہ کرنے کا ذمہ دار ہے ، جہاں G (i) سیل I کی ذمہ داری کی حد میں پہلا انڈیکس ہے۔چونکہ فینوک ٹری کی اونچائی لاگ (این) ہے ، لہذا تازہ کاری اور استفسار کی کارروائیوں میں زیادہ سے زیادہ لاگ (این) وقت لگتا ہے۔اس سے فینوک ٹری کو ایسے حالات کے ل data ڈیٹا کا ایک مفید ڈھانچہ بنتا ہے جہاں اکثر اپ ڈیٹ کے سوالات ہوتے ہیں۔فینوک کے درخت کی سب سے عام اطلاق متعدد عددیوں کی رقم کا حساب لگانا ہے۔ فینوک ٹری استعمال کرنا آسان ہے اور کوڈ ، خاص طور پر کثیر جہتی صفوں کی صورت میں۔اسے بائنری انڈیکسڈ ٹری بھی کہا جاتا ہے ، یا صرف تھوڑا سا مختص کیا جاتا ہے۔فینوک ٹری کو سب سے پہلے 1994 میں پیٹر ایم فینوک کے ذریعہ \"مجموعی تعدد ٹیبلز کے لئے ایک نیا ڈیٹا ڈھانچہ\" کے عنوان سے ایک مقالے میں بیان کیا گیا تھا۔ فینوک ٹری کو عناصر کے ساتھ ایک پر مبنی صف پر غور کرکے آسانی سے سمجھا جاتا ہے۔متعلقہ فینوک درخت کی جڑ پر ایک مضمر نوڈ 0 کے ساتھ نوڈس ہیں۔درخت کی ہر سطح میں نوڈس ہوتے ہیں جن میں اشاریے کے ساتھ اشارے ہوتے ہیں۔بائنری ڈھیر کے نفاذ کے لئے.اس نمائندگی میں ، روٹ نوڈ 0 کو چھوڑ دیا گیا ہے اور سرنی کے اشارے درخت میں نوڈ انڈیکس (1 پر مبنی اشاریہ کا استعمال کرتے ہوئے) کے مطابق براہ راست مطابقت رکھتے ہیں۔ خلاصہ میں ، ایک فینوک ٹری ایک ڈیٹا ڈھانچہ ہے جس پر موثر اپ ڈیٹس اور سابقہ رقم کے حساب کتاب کی اجازت ملتی ہے۔ایک صفیہ حدود کی رقم کو موثر انداز میں حساب کرنے اور کسی صف میں عنصر کی اقدار کو اپ ڈیٹ کرنے کے لئے مفید ہے۔فینوک کا درخت استعمال کرنا آسان ہے اور کوڈ ، خاص طور پر کثیر جہتی صفوں کی صورت میں۔اسے بائنری انڈیکسڈ ٹری بھی کہا جاتا ہے ، یا صرف تھوڑا سا مختص کیا جاتا ہے۔فینوک ٹری کو سب سے پہلے 1994 میں پیٹر ایم فینوک کے ذریعہ \"مجموعی تعدد ٹیبلز کے لئے ایک نیا ڈیٹا ڈھانچہ\" کے عنوان سے ایک مقالے میں بیان کیا گیا تھا۔ فینوک ٹری کو عناصر کے ساتھ ایک پر مبنی صف پر غور کرکے آسانی سے سمجھا جاتا ہے۔متعلقہ فینوک درخت کی جڑ پر ایک مضمر نوڈ 0 کے ساتھ نوڈس ہیں۔چونکہ فینوک ٹری کی اونچائی لاگ (این) ہے ، لہذا تازہ کاری اور استفسار کی کارروائیوں میں زیادہ سے زیادہ لاگ (این) وقت لگتا ہے۔یہ فینوک ٹری کو ان حالات کے ل data ڈیٹا کا ایک مفید ڈھانچہ بناتا ہے جہاں اکثر اپ ڈیٹ کے سوالات ہوتے ہیں۔"
    },
    {
        "Question": "گنتی کی ترتیب الگورتھم کیسے کام کرتی ہے؟",
        "Answer": "گنتی کی طرح ایک لکیری چھانٹنے والا الگورتھم ہے جو چابیاں کے مطابق اشیاء کے ذخیرے کو ترتیب دیتا ہے جو چھوٹے مثبت عدد ہیں۔یہ ان اشیاء کی تعداد کی گنتی کرکے کام کرتا ہے جو الگ الگ اہم اقدار کے مالک ہیں اور آؤٹ پٹ تسلسل میں ہر کلیدی قدر کی پوزیشنوں کا تعین کرنے کے لئے ان گنتیوں پر سابقہ رقم کا اطلاق کرتے ہیں۔گنتی کی طرح ایک غیر ہم آہنگی پر مبنی الگورتھم ہے ، جس کا مطلب ہے کہ ان کو ترتیب دینے کے لئے عناصر کا موازنہ نہیں کیا جاتا ہے۔اس کے بجائے ، یہ فرض کرتا ہے کہ ان پٹ عناصر حد [0 ، K] میں عدد ہیں۔جب K = O (n) ، تو گنتی کی ترتیب O (n) وقت میں چلے گی۔ گنتی ترتیب والے الگورتھم کا کام مندرجہ ذیل ہے: دیئے گئے سرنی سے زیادہ سے زیادہ عنصر (زیادہ سے زیادہ ہونے دیں) تلاش کریں۔تمام عناصر کے ساتھ لمبائی زیادہ سے زیادہ+1 کی 0. یہ صف سرنی میں عناصر کی گنتی کو ذخیرہ کرنے کے لئے استعمال کی جاتی ہے۔ ان پٹ سرنی کو رجوع کریں اور گنتی سرنی میں اسی عنصر کی گنتی میں اضافہ کریں۔آؤٹ پٹ تسلسل میں ہر کلیدی قدر کی پوزیشنوں کا تعین کریں۔ ان پٹ سرنی کو دوبارہ رجوع کریں اور ہر عنصر کو اپنی صحیح پوزیشن میں آؤٹ پٹ سرنی میں رکھیں۔ان پٹ ڈیٹا کی حد کو ترتیب دینے کے لئے اشیاء کی تعداد سے نمایاں طور پر زیادہ نہیں ہے۔یہ اکثر دوسرے چھانٹنے والے الگورتھم جیسے ریڈکس ترتیب میں سبروٹائن کے طور پر استعمال ہوتا ہے۔گنتی کی طرح کی وقت کی پیچیدگی O (n+K) ہے ، جہاں ان پٹ سرنی میں عناصر کی تعداد ہے اور K ان پٹ ڈیٹا کی حد ہے۔گنتی کی طرح کی خلائی پیچیدگی بھی O (n+K) ہے ، جو اسے خلائی موثر الگورتھم بناتی ہے۔ ان کا خلاصہ ، گنتی کی طرح ایک لکیری چھانٹ رہا الگورتھم ہے جو چابیاں کے مطابق اشیاء کے ذخیرے کو ترتیب دیتا ہے جو چھوٹے مثبت عدد ہیں۔یہ ایک غیر تقویت پر مبنی الگورتھم ہے جو فرض کرتا ہے کہ ان پٹ عناصر حد [0 ، K] میں عددی ہیں۔گنتی کی طرح مفید ہے جب ان پٹ ڈیٹا کی حد کو ترتیب دینے والی اشیاء کی تعداد سے نمایاں طور پر زیادہ نہیں ہوتا ہے۔گنتی کی طرح کی وقت کی پیچیدگی O (n+k) ہے ، اور خلائی پیچیدگی بھی O (n+k) ہے"
    },
    {
        "Question": "ایک لنکڈ فہرست کو جگہ پر الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "تلاش کے نتائج کی بنیاد پر ، ایک منسلک فہرست کو تبدیل کرنے کے لئے یہاں ایک فنکشن کا نفاذ ہے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ویل = 0 ، اگلا = کوئی بھی نہیں): سیلف.وال = ویل سیلف۔ نیکسٹ = اگلا ڈیف ریورس_ لنکڈ_ لسٹ (ہیڈ: نوڈ) -> نوڈ: کرنٹ = ہیڈ پچھلا = کوئی بھی نہیں جبکہ موجودہ کوئی نہیں ہے: next_node = موجودہ۔ نیکسٹ موجودہ۔ نیکسٹ = پچھلا موجودہ = موجودہ موجودہ = اگلی_نوڈ ریٹرن پچھلی_لنکڈ_ لسٹ فنکشن ان پٹ کے طور پر لنکڈ فہرست کا سر لیتا ہے اورالٹ لنکڈ لسٹ کے سربراہ کو لوٹاتا ہے۔اس میں تین پوائنٹر استعمال کیے گئے ہیں: موجودہ ، پچھلا اور نیکسٹ_نوڈ۔موجودہ پوائنٹر منسلک فہرست کے سر سے شروع ہوتا ہے ، اور پچھلا پوائنٹر کسی کے طور پر شروع نہیں ہوتا ہے۔فنکشن لنکڈ لسٹ کے ذریعے لوپ ہوتا ہے ، پوائنٹرز کو تبدیل کرتا ہے تاکہ ہر نوڈ پچھلے نوڈ کی طرف اشارہ کرتا ہے۔نیکسٹ_نوڈ پوائنٹر کو اصل لنکڈ فہرست میں اگلے نوڈ کو ٹریک رکھنے کے لئے استعمال کیا جاتا ہے۔ایک بار لنکڈ لسٹ کا اختتام پہنچنے کے بعد ، پچھلا پوائنٹر الٹ لنکڈ لسٹ کے نئے سربراہ کی طرف اشارہ کرتا ہے ، جو فنکشن کے ذریعہ واپس کیا جاتا ہے۔ خلاصہ ان کا خلاصہ ، ریورس_ لنکڈ_ لسٹ فنکشن ان پٹ کے طور پر لنکڈ لسٹ کے سر کو لے جاتا ہے اور سر لوٹاتا ہے۔الٹ لنکڈ لسٹ کی۔لنکڈ فہرست میں ہر نوڈ کے پوائنٹرز کو الٹ کرنے کے لئے یہ تین پوائنٹر استعمال کرتا ہے ، تاکہ ہر نوڈ پچھلے نوڈ کی طرف اشارہ کرے۔فنکشن لنکڈ لسٹ کے ذریعے ختم ہوجاتا ہے جب تک کہ اختتام تک نہ پہنچ جاتا ہے ، اور الٹ لنکڈ لسٹ 1.1.emre کے نئے سربراہ کو لوٹاتا ہے۔"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ معلوم کیا جاسکے کہ بائنری کا درخت بائنری تلاش کا درخت ہے۔",
        "Answer": "یہاں ایک فنکشن کا ازگر کا نفاذ ہے جس کا پتہ لگانے کے لئے کہ اگر کوئی بائنری ٹری بائنری سرچ ٹری ہے ، تلاش کے نتائج پر مبنی ہے: ازگرکلاس نوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، دائیں = کوئی نہیں): خود۔ویل = ویل سیلف۔> بول: اگر نوڈ کوئی نہیں ہے: اگر نوڈ.ول <= من_وال یا نوڈ.ول> = زیادہ سے زیادہ واپس آجائیں تو غلط واپسی IS_BST_HELPER (نوڈ.لفٹ ، من_وال ، نوڈ.ول) اور is_bst_helper (نوڈ.رائٹ ، نوڈ۔، MAX_VAL) واپسی IS_BST_HELPER (جڑ) IS_BST فنکشن بائنری درخت کی جڑ کو ان پٹ کے طور پر لیتا ہے اور اگر بائنری ٹری بائنری سرچ کا درخت ہے ، اور دوسری صورت میں غلط ہے۔یہ ایک مددگار فنکشن IS_BST_HELPER استعمال کرتا ہے جو نوڈ ، کم سے کم قیمت ، اور ان پٹ کے طور پر زیادہ سے زیادہ قیمت لیتا ہے اور اگر نوڈ پر جڑے ہوئے سب ٹری دیئے گئے رینج میں بائنری سرچ کا درخت ہے ، اور دوسری صورت میں غلط ہے۔فنکشن بار بار جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں سبٹریز مناسب حد کے اندر بائنری تلاش کے درخت ہیں۔اگر نوڈ کی قیمت کم سے کم قیمت سے کم یا اس کے برابر ہے یا زیادہ سے زیادہ قیمت سے زیادہ یا اس کے برابر ہے تو ، یہ غلط لوٹتا ہے۔اگر بائنری ٹری میں موجود تمام نوڈس بائنری سرچ ٹری پراپرٹی کو مطمئن کرتے ہیں تو یہ فنکشن سچ ہوتا ہے۔ خلاصہ میں ، IS_BST فنکشن بائنری درخت کی جڑ کو ان پٹ کے طور پر لے جاتا ہے اور اگر بائنری ٹری بائنری سرچ کا درخت ہے ، اور غلط ہے تو وہ سچ ہے۔یہ ایک مددگار فنکشن کا استعمال کرتا ہے جو بار بار جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں سبٹریز مناسب حد کے اندر بائنری سرچ کے درخت ہیں۔اگر بائنری ٹری میں موجود تمام نوڈس بائنری سرچ ٹری پراپرٹی کو پورا کرتے ہیں۔"
    },
    {
        "Question": "دو قطاروں کا استعمال کرتے ہوئے ایک اسٹیک کو نافذ کریں۔",
        "Answer": "یہاں ازگر میں دو قطاریں استعمال کرتے ہوئے اسٹیک کا نفاذ ہے: پائیتھنکلاس اسٹیک: ڈیف __init __ (خود): سیلف. کیو 1 = [] سیلف. کیو 2 = [] ڈیف پش (خود ، x): سیلف. کیو 1.پی اینڈ (ایکس)ڈیف پاپ (خود): اگر خود نہیں.Q1 ، self.q2 = self.q2 ، self.Q1 ریٹرن ریٹرن ڈف ٹاپ (خود): اگر خود نہیں ہے۔پاپ (0)) نتیجہ = self.q1.pop (0) self.q2.append (نتیجہ) سیلف. کیو 1 ، سیلف. کیو 2 = سیل. کیو 2 ، سیلف۔ کیو 1 ریٹرن ریٹرن ڈیف خالی (خود): خود نہیں۔Q1 اسٹیک کلاس میں دو قطاریں Q1 اور Q2 ہیں۔پش طریقہ آسانی سے Q1 میں ایک عنصر کو شامل کرتا ہے۔پاپ کا طریقہ Q1 سے Q2 تک آخری عنصر کے سوا سب کو منتقل کرتا ہے ، Q1 سے آخری عنصر کو ہٹاتا ہے ، اور پھر Q1 اور Q2 کو تبدیل کرتا ہے۔سب سے اوپر کا طریقہ پاپ طریقہ کار سے ملتا جلتا ہے ، لیکن قطار میں بدلنے سے پہلے یہ Q1 سے Q2 میں آخری عنصر کو بھی شامل کرتا ہے۔خالی طریقہ درست لوٹتا ہے اگر Q1 خالی ہے۔ خلاصہ میں ، اسٹیک کلاس دو قطاروں کا استعمال کرتے ہوئے اسٹیک کو نافذ کرتی ہے۔پش طریقہ اسٹیک میں ایک عنصر کو شامل کرتا ہے ، پاپ کا طریقہ اسٹیک سے اوپر عنصر کو ہٹاتا ہے اور واپس کرتا ہے ، اوپر کا طریقہ اسٹیک سے اوپر عنصر کو اسے ہٹائے بغیر لوٹاتا ہے ، اور اگر اسٹیک خالی ہے تو خالی طریقہ درست لوٹاتا ہے۔اس عمل میں اسٹیک آپریشنز 1.1 جیکسفورجیکس کی نقل کے لئے دو قطاریں استعمال ہوتی ہیں"
    },
    {
        "Question": "\"انٹیجرز کی ایک صف کو دیکھتے ہوئے ، زیادہ سے زیادہ سبری کی رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔\"",
        "Answer": "انٹیجرز کی ایک صف کا زیادہ سے زیادہ سبراے مجموعہ تلاش کرنے کے ل we ، ہم کڈانے کے الگورتھم کا استعمال کرسکتے ہیں ، جو ایک متحرک پروگرامنگ الگورتھم ہے جو O (n) وقت میں چلتا ہے۔الگورتھم اب تک دیکھنے میں آنے والی زیادہ سے زیادہ سبری کی رقم کا سراغ لگاتے ہوئے کام کرتا ہے اور سرنی میں ہر پوزیشن پر ختم ہونے والی زیادہ سے زیادہ سبری کا مجموعہ ختم ہوتا ہے۔پوزیشن I پر ختم ہونے والا زیادہ سے زیادہ سبری کا مجموعہ یا تو پوزیشن I پر عنصر ہے یا عنصر کا مجموعہ I میں اور زیادہ سے زیادہ سبری کا مجموعہ I-1 پر ختم ہوتا ہے ، جو بھی زیادہ ہوتا ہے۔اب تک دیکھا جانے والا زیادہ سے زیادہ سبری کا مجموعہ اپ ڈیٹ ہوتا ہے جب بھی کسی پوزیشن پر ختم ہونے والی زیادہ سے زیادہ سبری کا مجموعہ موجودہ زیادہ سے زیادہ سبری کی رقم سے زیادہ ہوتا ہے۔ یہاں کڈانے کے الگورتھم کا ایک ازگر کا نفاذ ہے: پائیتھنڈف میکس_سوبری_سم (نمبر): میکس_سم = فلوٹ ((نمبر)'-Inf') موجودہ_سم = 0 نمبر کے لئے نمبر: موجودہ_سم = زیادہ سے زیادہ (NUM ، موجودہ_سم + نمبر) زیادہ سے زیادہ_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) میکس_سومٹے میکس_سوبری_سم فنکشن ان پٹ کے طور پر ان پٹ کے طور پر انٹیجرز کی صف لیتا ہے اور زیادہ سے زیادہ ذیلی حصے کو واپس کرتا ہے۔یہ بالترتیب دو متغیر میکس_سم اور کرنٹ_سم کو منفی انفینٹی اور صفر سے شروع کرتا ہے۔اس کے بعد یہ سرنی کے ذریعے لوپ ہوجاتا ہے ، جیسا کہ اوپر بیان کیا گیا ہے موجودہ_سم اور میکس_سم کو اپ ڈیٹ کرتے ہیں۔فنکشن میکس_سم کو اختتام پر لوٹاتا ہے۔ خلاصہ ، انٹیجرز کی ایک صف کی زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے ، ہم کڈانے کے الگورتھم کا استعمال کرسکتے ہیں ، جو ایک متحرک پروگرامنگ الگورتھم ہے جو O (n) وقت میں چلتا ہے۔الگورتھم اب تک دیکھنے میں آنے والی زیادہ سے زیادہ سبری کی رقم کا سراغ لگاتے ہوئے کام کرتا ہے اور سرنی میں ہر پوزیشن پر ختم ہونے والی زیادہ سے زیادہ سبری کا مجموعہ ختم ہوتا ہے۔میکس_سوبری_سم فنکشن کڈین کے الگورتھم کو پائیتھون 123.1leetcode2enjoyalgorithms3afteracademy میں نافذ کرتا ہے"
    },
    {
        "Question": "عدد کی ایک صف پر کوئکسورٹ انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "تلاش کے نتائج کی بنیاد پر ، عدد کی ایک صف کو ترتیب دینے کے لئے کوئکسورٹ الگورتھم کا یہاں ایک ازگر کا نفاذ ہے: پیتھونڈف کوئیکسٹورٹ (نمبر): اگر لین (نمبر) <= 1: ریٹرن نمبر پائیوٹ = نمبر [0] بائیں = [نمبر =نمبر میں نمبر [1:] اگر num <pivot] دائیں = [num کے لئے نمبر [1:] اگر num> = Pivot] کوئکسٹورٹ (بائیں) + [محور] + کوئکسٹورٹ (دائیں) کوئکسٹورٹ فنکشن ایک صف لیتا ہےان پٹ کے طور پر انٹیجرز کا اور کوئکسورٹ الگورتھم کا استعمال کرتے ہوئے ترتیب شدہ صف کو واپس کرتا ہے۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا سرنی کی لمبائی 1 سے کم یا اس کے برابر ہے ، ایسی صورت میں یہ صف کو اسی طرح لوٹاتا ہے۔بصورت دیگر ، یہ سرنی کے پہلے عنصر کو محور کے طور پر منتخب کرتا ہے ، اور صف کو دو سبریوں میں تقسیم کرتا ہے: ایک محور سے کم عناصر پر مشتمل ہے ، اور دوسرا محور سے زیادہ یا اس کے برابر عناصر پر مشتمل ہے۔اس کے بعد یہ بار بار کوئکسورٹ الگورتھم کو بائیں اور دائیں سبریوں پر لاگو کرتا ہے ، اور ترتیب شدہ سبریوں کو محور عنصر کے ساتھ جوڑتا ہے تاکہ حتمی ترتیب دیئے گئے سرنی کو تیار کیا جاسکے۔ خلاصہ میں ، کوئکسورٹ فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور ترتیب دیئے گئے سرے کو ان پٹ کا استعمال کرتے ہوئے لوٹاتا ہے۔کوئکسورٹ الگورتھم۔فنکشن ایک محور عنصر کی بنیاد پر دو سبریوں میں صفوں کو تقسیم کرتا ہے ، اور جب تک پوری صف کو ترتیب دیا جاتا ہے اس وقت تک جب تک کہ پوری صفوں کو ترتیب دیا جاتا ہے جب تک کہ پوری صفوں کو ترتیب دیا جاتا ہے۔"
    },
    {
        "Question": "منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کریں۔",
        "Answer": "منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کرنے کے ل we ، ہم ڈھیر کی نمائندگی کرنے کے لئے ایک صف کا استعمال کرسکتے ہیں۔ڈھیر کی جڑ ہمیشہ اعلی ترجیح کے ساتھ عنصر ہوگی ، جو اس معاملے میں کم سے کم عنصر ہے۔ہم ترجیحی قطار پر درج ذیل کارروائیوں کو نافذ کرسکتے ہیں: داخل کریں: ترجیحی قطار میں ایک عنصر شامل کریں۔ گیٹ_مین: ترجیحی قطار میں کم سے کم عنصر کو اسے ہٹائے بغیر واپس کریں۔منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کا ایک ازگر کا نفاذ: پائیٹونکلاس کی ترجیحی کیو: ڈیف __init __ (خود): سیلف۔ ہیپ = [] ڈیف داخل کریں (خود ، قدر): سیلف۔ ہیپینڈ (ویلیو) سیلف۔.HEAP) - 1) Def get_min (خود): اگر خود نہیں ہے۔ ہیپ: کوئی بھی واپس نہیں لوٹ کر خود واپس کریں۔= self.heap.pop () اگر self.heap: self.heap [0] = last_value سیلف۔= 0 اور سیلف۔ ہیپ [والدین]> خودDef _sift_down (خود ، اشاریہ): بائیں = 2 * انڈیکس + 1 دائیں = 2 * انڈیکس + 2 سب سے چھوٹا = انڈیکس اگر بائیں طرف <لین (سیلف۔ ہیپ) اور سیلف۔ ہیپ [بائیں] <سیلف۔ ہیپ [سب سے چھوٹا]: سب سے چھوٹا]= بائیں اگر دائیں <لین (سیلف ہاپ) اور سیلف۔ ہیپ [دائیں] <سیلف پی ایچ ای اے پی [سب سے چھوٹا]: سب سے چھوٹا = دائیں اگر سب سے چھوٹا ہو تو! = انڈیکس: خود۔ ہیپ [انڈیکس] ، سیلف۔ ہیپ [سب سے چھوٹا] = خود.HEAP [سب سے چھوٹا] ، سیلف ۔ہپ [انڈیکس] سیلف۔داخل کرنے کا طریقہ ڈھیر میں ایک عنصر کو شامل کرتا ہے اور پھر ہیپ پراپرٹی کو برقرار رکھنے کے ل if اس کو الگ کرتا ہے۔get_min طریقہ ڈھیر میں کم سے کم عنصر کو ہٹائے بغیر واپس کرتا ہے۔نچوڑ_من کا طریقہ ڈھیر میں کم سے کم عنصر کو ہٹاتا ہے اور لوٹاتا ہے ، اور پھر ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے آخری عنصر کو نیچے کرتا ہے۔_sift_up کا طریقہ ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے ڈھیر کو ڈھیر کرتا ہے ، اور _SIFT_DOWN کا طریقہ ڈھیر پراپرٹی کو برقرار رکھنے کے لئے ڈھیر کے نیچے عنصر کو گھٹا دیتا ہے۔ خلاصہ میں ، ایک ترجیحی قطار کو ایک من ہیپ کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے ، جو بائنری ٹری ہے۔جس میں ہر نوڈ اپنے بچوں سے کم یا اس کے برابر ہے۔ڈھیر کی جڑ ہمیشہ اعلی ترجیح کے ساتھ عنصر ہوگی ، جو اس معاملے میں کم سے کم عنصر ہے۔ترجیحی طبقے کی کلاس Python123456.1 ہیپائیکوڈرز 2 کوڈسڈوپ 3 پریپ بائٹس 4 سی ایم یو 5 برڈ فیلڈ سی ایس ایس 6 جی ای ای ایکس فففجیکس میں ایک منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کی کارروائیوں کو نافذ کرتی ہے۔"
    },
    {
        "Question": "اس بات کا تعین کرنے کے لئے ایک پروگرام لکھیں کہ آیا دو بائنری درخت ایک جیسے ہیں یا نہیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں ، ہمیں یہ چیک کرنے کی ضرورت ہے کہ درختوں کی ایک ہی ساخت اور ہر نوڈ پر ایک ہی اقدار ہیں۔اس چیک کو نافذ کرنے کے بہت سارے طریقے ہیں ، لیکن ایک عام نقطہ نظر یہ ہے کہ ہر نوڈ کے بائیں اور دائیں سبٹریوں کا موازنہ کرنے کے لئے تکرار کا استعمال کیا جائے۔ یہاں ایک فنکشن کا ایک ازگر کا نفاذ ہے اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں: ازگرکلاس نوڈ: ڈیف __init__.روٹ 2 کوئی نہیں ہے: اگر روٹ 1 کوئی نہیں ہے یا روٹ 2 کوئی نہیں ہے تو کوئی نہیں ہے یا کوئی بھی نہیں ہے: اگر روٹ 1.Val! = روٹ 2.Val: غلط ریٹرن آئی ایس_جینیکل (روٹ 1. لیفٹ ، روٹ 2۔ لیفٹ) اور آئی ایس_جینیکل (روٹ 1. رائٹ ، روٹ 2۔ روٹ 2۔ رائٹ 2۔ رائٹ 2۔) is_identical فنکشن دو بائنری درختوں کی جڑوں کو ان پٹ کے طور پر لیتا ہے اور اگر درخت ایک جیسے ہیں ، اور غلط ہیں تو سچائی لوٹتے ہیں۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا دونوں جڑیں کوئی نہیں ہیں ، ایسی صورت میں یہ سچائی لوٹتی ہے۔اگر صرف ایک جڑ کوئی نہیں ہے تو ، یہ غلط لوٹتا ہے۔اگر جڑوں کی اقدار برابر نہیں ہیں تو ، یہ غلط لوٹتی ہے۔بصورت دیگر ، یہ بار بار جانچ پڑتال کرتا ہے کہ آیا ہر نوڈ کے بائیں اور دائیں ذیلی ذیلی ایک جیسے ہیں۔ خلاصہ یہ ہے کہ آیا دو بائنری درخت ایک جیسے ہیں ، ہم ہر نوڈ کے بائیں اور دائیں سب ٹریوں کا موازنہ کرنے کے لئے تکرار کا استعمال کرسکتے ہیں۔is_identical فنکشن دو بائنری درختوں کی جڑوں کو ان پٹ کے طور پر لیتا ہے اور اگر درخت ایک جیسے ہوتے ہیں تو وہ درست ہوجاتے ہیں ، اور دوسری صورت میں غلط ہیں ، اور دوسری صورت میں 123456.1 ٹیککراسکورس 2 ایڈوکیٹیو 3 جی ای ای ای ای ای ای ای ای ای ای ای ای ای ایس 4 ٹکیفورورڈ 5 جےواٹپوائنٹ 6 جےواٹ پوائنٹ پوائنٹ"
    },
    {
        "Question": "شروع سے ہیش ٹیبل کو نافذ کریں۔",
        "Answer": "تصادم کو سنبھالنے کے لئے ایک سرنی اور منسلک فہرستوں کا استعمال کرتے ہوئے ہیش ٹیبل کا ایک ازگر کا نفاذ ہے: ازگرکلاس ہیش ٹیبل: ڈیف __ __init __ (خود ، سائز): خود۔Def _hash (خود ، کلید): واپسی ہیش (کلیدی) ٪ خود۔== کلید: جوڑی [1] = ویلیو ریٹرن سیلف۔ ٹیبل [ہیش_کی]]: اگر جوڑی [0] == کلید: ریٹرن جوڑی [1] واپسی کوئی بھی ڈیف ڈیلیٹ (خود ، کلید): ہیش_کی = سیلف۔جوڑی [0] == کلید: ڈیل سیلف۔ ٹیبل [ہیش_کی] [i] ریٹرن ہیش ٹیبل کلاس میں ایک مثال متغیر ٹیبل ہے جو ہیش ٹیبل کی نمائندگی کرتا ہے ، جو منسلک فہرستوں کی ایک صف ہے۔_ ہیش طریقہ ان پٹ کے طور پر ایک کلید لیتا ہے اور ہیش ویلیو کو واپس کرتا ہے ، جو صف میں انڈیکس کے لئے استعمال ہوتا ہے۔داخل کرنے کا طریقہ ہیش ٹیبل میں کلیدی قدر کی جوڑی داخل کرتا ہے ، مناسب انڈیکس میں منسلک فہرست میں شامل کرکے تصادم کو سنبھالتا ہے۔GET طریقہ ہیش ٹیبل میں کسی کلید سے وابستہ قیمت لوٹاتا ہے ، یا کوئی نہیں اگر کلید نہیں ملتی ہے۔حذف کرنے کا طریقہ ہیش ٹیبل سے کلیدی قدر کی جوڑی کو ہٹا دیتا ہے۔ خلاصہ میں ، ایک ہیش ٹیبل کو تصادم کو سنبھالنے کے لئے سرنی اور منسلک فہرستوں کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ہیش ٹیبل کلاس ہیش ٹیبل آپریشنز کو اس نقطہ نظر کا استعمال کرتے ہوئے پائیتھون 123456.1 ریلپیتھون 2 کاوڈر بوک 3 اسٹیک اوور فلو 4 ڈیجیٹلوسین 5 ہیرویگو 6benhoyt میں نافذ کرتی ہے"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے بہت سارے طریقے ہیں۔ایک نقطہ نظر یہ ہے کہ اب تک کے سب سے بڑے عناصر کو ٹریک رکھنے کے لئے زیادہ سے زیادہ ڈھیر کا استعمال کیا جائے۔ہم صف کے پہلے K عناصر کے ساتھ ایک زیادہ سے زیادہ ڈھیر شروع کرسکتے ہیں ، اور پھر صف کے باقی عناصر کے ذریعے تکرار کرسکتے ہیں۔ہر عنصر کے ل if ، اگر یہ زیادہ سے زیادہ ڈھیر میں کم سے کم عنصر سے زیادہ ہے تو ، ہم کم سے کم عنصر کو نئے عنصر کے ساتھ تبدیل کرسکتے ہیں اور اسی کے مطابق ڈھیر کو ایڈجسٹ کرسکتے ہیں۔آخر میں ، زیادہ سے زیادہ ڈھیر میں زیادہ سے زیادہ عنصر سرنی کا سب سے بڑا عنصر ہوگا۔ یہاں اس نقطہ نظر کا ازگر کا نفاذ ہے: پائیتھونیمپورٹ ہیپکیڈف Kth_larget (نمبر ، کے): ہیپ = نمبر [: K] ہیپ کیو ایپیفائی (ڈھیر) نمبر میں نمبر [K:]: اگر num> ہیپ [0]: ہیپ کیو ہائپری پلیس (ہیپ ، نمبر) ریٹرن ہیپ [0] Kth_largest فنکشن ان پٹ کے طور پر انٹیجر نمبر اور ایک عددی K کی ایک صف لیتا ہے ، اور لوٹتا ہےسرنی میں کے ٹی ایچ کا سب سے بڑا عنصر۔یہ صف کے پہلے K عناصر کے ساتھ ایک زیادہ سے زیادہ ڈھیر کا آغاز کرتا ہے ، اور پھر صف کے باقی عناصر کے ذریعے تکرار کرتا ہے۔ہر عنصر کے ل if ، اگر یہ زیادہ سے زیادہ ڈھیر میں کم سے کم عنصر سے زیادہ ہے تو ، یہ کم سے کم عنصر کو نئے عنصر کے ساتھ تبدیل کرتا ہے اور اسی کے مطابق ڈھیر کو ایڈجسٹ کرتا ہے۔آخر میں ، زیادہ سے زیادہ ڈھیر میں زیادہ سے زیادہ عنصر سرنی میں کے ٹی ایچ ٹی کا سب سے بڑا عنصر ہوگا۔ خلاصہ میں ، بغیر کسی سرے میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے ل we ، ہم دیکھا جانے والے کے سب سے بڑے عناصر کو ٹریک رکھنے کے لئے زیادہ سے زیادہ ڈھیر استعمال کرسکتے ہیں۔اب تک.Kth_larget فنکشن اس نقطہ نظر کو Python123.1 javatPoint2leetCode3geeksforgeeks میں نافذ کرتا ہے"
    },
    {
        "Question": "سرکلر بفر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک سرکلر بفر ، جسے رنگ بفر کے نام سے بھی جانا جاتا ہے ، ایک مقررہ سائز کا ڈیٹا ڈھانچہ ہے جو عام طور پر ریئل ٹائم سافٹ ویئر ایپلی کیشنز میں استعمال کیا جاتا ہے تاکہ پہلے سے طے شدہ قدروں کو ذخیرہ کیا جاسکے۔یہ خاص طور پر ان حالات میں مفید ہے جہاں اعداد و شمار کو مسلسل نمونہ بنایا جارہا ہے اور پہلے سے طے شدہ نمونے کے سائز کا استعمال کرتے ہوئے حساب کتاب کرنے کی ضرورت ہے یا مسلسل تصور کی ضرورت ہے۔اس طرح کے اعداد و شمار کے ڈھانچے کی FIFO (پہلے ان فرسٹ آؤٹ) نوعیت پر قبضہ کرنے کے لئے ایک مقررہ تعداد میں پوزیشنوں کے ساتھ رنگ کی مشابہت کافی مفید ہے۔ایک بار جب بفر بھرا ہوا ہے تو ، پہلا عنصر جو بفر کو لکھا گیا تھا (\"in\") اگلے آنے والے عنصر کے ذریعہ اوور رائٹ (\"آؤٹ\") ہے۔ ایک سرکلر بفر کو سرنی یا لنکڈ کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔فہرستسرکلر بفر کو نافذ کرنے کا سب سے خوبصورت طریقہ ایک صف کا استعمال ہے۔سرنی کو ایک مقررہ سائز کے ساتھ شروع کیا جاسکتا ہے ، اور دو پوائنٹرز کو پڑھنے اور لکھنے کی پوزیشنوں کو ٹریک رکھنے کے لئے استعمال کیا جاسکتا ہے۔پڑھنے والے پوائنٹر اگلے عنصر کو پڑھنے کے لئے نشاندہی کرتے ہیں ، اور لکھنے کا اشارہ اگلے عنصر کی طرف اشارہ کرتا ہے۔جب لکھنے کا اشارہ سرنی کے اختتام پر پہنچ جاتا ہے تو ، یہ صف کے آغاز تک لپیٹ جاتا ہے۔اسی طرح ، جب ریڈ پوائنٹر صف کے اختتام پر پہنچ جاتا ہے ، تو یہ سرنی کے آغاز تک لپیٹ جاتا ہے۔ یہاں ایک سرنی کا استعمال کرتے ہوئے سرکلر بفر کا ایک ازگر کا نفاذ ہے: پائیٹونکلاس سرکلر بفر: ڈیف __ __init __ (خود ، سائز): خود۔ سائز۔= سائز self.buffer = [کوئی نہیں] * سائز خود۔٪ self.size اگر sell.بفر [self.read] self.read = (self.read + 1) ٪ خود۔ سائز کی واپسی والویتھ سرکلر بفر کلاس میں ایک مثال متغیر بفر ہوتا ہے جو سرکلر بفر کی نمائندگی کرتا ہے ، جو سائز کے سائز کی ایک صف ہے۔پڑھنے اور لکھنے کے اشارے بفر میں پڑھنے اور لکھنے کی پوزیشنوں پر نظر رکھتے ہیں۔Writ_value طریقہ موجودہ تحریری پوزیشن پر بفر کو ایک قدر لکھتا ہے ، اور پھر لکھنے کے پوائنٹر میں اضافہ کرتا ہے۔اگر تحریری پوائنٹر ریڈ پوائنٹر تک پہنچ جاتا ہے تو ، بفر میں قدیم ترین قیمت کو اوور رائٹ کرنے سے بچنے کے لئے پڑھنے والے پوائنٹر میں اضافہ ہوتا ہے۔READ_VALUE طریقہ موجودہ پڑھنے کی پوزیشن پر بفر سے ایک قدر پڑھتا ہے ، اور پھر ریڈ پوائنٹر میں اضافہ کرتا ہے۔اگر ریڈ پوائنٹر رائٹ پوائنٹر تک پہنچ جاتا ہے تو ، کوئی بھی اس بات کی نشاندہی کرنے کے لئے واپس نہیں کیا جاتا ہے کہ بفر خالی ہے۔ خلاصہ میں ، ایک سرکلر بفر ایک مقررہ سائز کا ڈیٹا ڈھانچہ ہوتا ہے جو عام طور پر پہلے سے طے شدہ تعداد کو ذخیرہ کرنے کے لئے ریئل ٹائم سافٹ ویئر ایپلی کیشنز میں استعمال ہوتا ہے۔اقدار کیاسے سرنی یا منسلک فہرست کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔سرکلر بفر کلاس پائیتھون 123456.1 میں ایک سرنی کا استعمال کرتے ہوئے ایک سرکلر بفر کا اطلاق کرتی ہے۔"
    },
    {
        "Question": "گراف پر چوڑائی کی پہلی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "بریڈتھ فرسٹ سرچ (بی ایف ایس) ایک گراف ٹراورسل الگورتھم ہے جو گراف کی جڑ سے شروع ہوتا ہے اور اگلی گہرائی کی سطح پر نوڈس پر جانے سے پہلے موجودہ گہرائی کی سطح پر تمام نوڈس کا دورہ کرتا ہے۔بی ایف ایس کا استعمال نوڈ کے لئے گراف ڈیٹا ڈھانچے کو تلاش کرنے کے لئے کیا جاتا ہے جو معیار کے ایک سیٹ کو پورا کرتا ہے۔الگورتھم کو گراف تھیوری میں بہت ساری پریشانیوں کو حل کرنے کے لئے استعمال کیا جاسکتا ہے ، جیسے دو عمودیوں کے مابین مختصر ترین راستہ تلاش کرنا۔ گراف پر بی ایف ایس انجام دینے کے ل we ، ہم نوڈس کو ذخیرہ کرنے کے لئے قطار کے ڈیٹا ڈھانچے کا استعمال کرسکتے ہیں جس کا دورہ کرنے کی ضرورت ہے۔ہم قطار میں جڑ کے نوڈ کو شامل کرکے شروع کرتے ہیں ، اور پھر بار بار قطار سے پہلا نوڈ بار بار نکالیں ، اس کے پڑوسیوں سے ملیں ، اور اگر ان کا دورہ نہیں کیا گیا ہے تو انہیں قطار میں شامل کریں۔ہم ہر دورے کے نوڈ کو نشان زد کرتے ہیں تاکہ اس پر عملدرآمد کرنے سے بچنے کے ل .۔ یہاں قطار کا استعمال کرتے ہوئے گراف کے لئے بی ایف ایس الگورتھم کا ازگر عمل درآمد ہوتا ہے: ازگر کے ذخیرے کی درآمد ڈیکو کلاس گراف: ڈیف __init __ (خود ، عمودی)self.adj_list = {v: [] v کے لئے v کے لئے vertices} def add_edge (خود ، u ، v): self.adj_list [u] .append (v) sell، شروع کریں): ملاحظہ کریں = {v: v کے لئے v کے لئے غلط۔خود میں پڑوسی کے لئے۔ adj_list [نوڈ]: اگر ملاحظہ نہیں کیا جاتا ہے [پڑوسی]: ملاحظہ کیا [پڑوسی] = سچی قطار۔ اپینڈ (پڑوسی) گراف کلاس میں ایک مثال متغیر adj_list ہے جو گراف کی ملحقہ فہرست کی نمائندگی کرتا ہے ، جو ایک لغت ہےیہ ہر ایک کے نقشوں کو اپنے پڑوسیوں کی فہرست میں نقشہ دیتا ہے۔بی ایف ایس کا طریقہ ان پٹ کے طور پر ایک ابتدائی ورٹیکس لیتا ہے اور گراف پر بی ایف ایس انجام دیتا ہے ، جس کی ترتیب میں ملاحظہ کیا گیا نوڈس پرنٹ کرتے ہیں۔اس طریقہ کار میں ملاحظہ کرنے والے نوڈس کا سراغ لگانے کے لئے بولین کا دورہ کیا گیا لغت ، اور قطار کو نافذ کرنے کے لئے ایک ڈیک ڈیٹا ڈھانچہ استعمال کیا گیا ہے۔ خلاصہ یہ ہے کہ ، ایک بی ایف ایس ایک گراف ٹراورسل الگورتھم ہے جو گراف کی جڑ سے شروع ہوتا ہے اور کرنٹ میں تمام نوڈس کا دورہ کرتا ہے۔اگلی گہرائی کی سطح پر نوڈس پر جانے سے پہلے گہرائی کی سطح۔کسی گراف پر بی ایف ایس انجام دینے کے ل we ، ہم نوڈس کو ذخیرہ کرنے کے لئے قطار کے ڈیٹا ڈھانچے کا استعمال کرسکتے ہیں جس کا دورہ کرنے کی ضرورت ہے۔گراف کلاس Python123456.1 geeksforgeeks2 javatpPoint3programiz4wikedia5simplilearn6tutorialstutorialsPoint میں قطار کا استعمال کرتے ہوئے گراف کے لئے BFS الگورتھم کا اطلاق کرتا ہے"
    },
    {
        "Question": "ترتیب شدہ لنکڈ فہرست میں بائنری سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "ترتیب شدہ لنکڈ فہرست میں بائنری تلاش کرنے کے ل we ، ہمیں ہر تکرار پر فہرست کا درمیانی عنصر تلاش کرنے کی ضرورت ہے ، جس میں ہر بار O (n) وقت لگتا ہے۔تاہم ، اگر ہم اسکیپ لسٹ استعمال کریں تو اس سے بچا جاسکتا ہے۔اسکیپ لسٹ ایک ڈیٹا ڈھانچہ ہے جو ترتیب شدہ فہرست کی تیزی سے تلاش کرنے کی اجازت دیتا ہے"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ آیا دیئے گئے تار ایک پیلنڈرووم ہے۔",
        "Answer": "یہاں ایک C ++ پروگرام ہے جس کا تعین کرنے کے لئے کہ آیا دیئے گئے تار ایک palindrome ہے: C ++#شامل <iostream>#شامل <سٹرنگ> بول ispalindrome (std :: string str) {int بائیں = 0 ، دائیں = str.length () - 1 ؛جبکہ (بائیں <دائیں) {اگر (str [بائیں]! = str [دائیں]) {غلط لوٹ ؛} بائیں ++ ؛ٹھیک ہے-؛} سچ واپس ؛} انٹ مین () {std :: سٹرنگ str ؛std :: cout << \"ایک تار درج کریں:\" ؛std :: getline (std :: cin ، str) ؛اگر (ispalindrome (str)) {std :: cout << str << \"ایک palindrome ہے\" << std :: endl ؛} دوسری {std :: cout << str << \"ایک palindrome نہیں ہے\" << std :: endl ؛} واپس 0 ؛} اس پروگرام میں پہلے ایک فنکشن ispalindrome () کی وضاحت کی گئی ہے جو ایک تار کو ان پٹ کے طور پر لیتا ہے اور اگر اسٹرنگ ایک پالندرووم ہے اور غلط ہے تو سچائی واپس کرتا ہے۔فنکشن دونوں سروں سے تار کو عبور کرنے کے لئے ، بائیں اور دائیں دو پوائنٹرز کا استعمال کرتا ہے۔اگر دونوں پوائنٹرز کے کردار برابر نہیں ہیں تو ، فنکشن غلط لوٹتا ہے۔اگر فنکشن بغیر کسی غیر مساوی حروف کی تلاش کیے تار کے وسط تک پہنچ جاتا ہے تو ، یہ سچ واپس آجاتا ہے۔ مین () فنکشن صارف کو تار داخل کرنے کا اشارہ کرتا ہے ، STD :: getline () ، اور ispalindrome () کو کال کرتا ہے اس کا تعین کرنے کے لئے تار پڑھتا ہے۔اگر تار ایک پالندرووم ہے۔اس کے بعد یہ ایک پیغام پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا سٹرنگ ایک پیلینڈرووم ہے یا نہیں۔ مثال کے طور پر ، مندرجہ ذیل کوڈ چیک کرتا ہے کہ آیا تار ایک پالندرووم ہے یا نہیں: C ++ std :: سٹرنگ str = \"Racecar\" ؛ if (ispalindrome (str)) {std :: cout << str << \"ایک palindrome ہے\" << std :: endl ؛} else {std :: cout << str << \"<< std :: endl ؛} 1educative2geeksforgeks4w3schools5javatptpy"
    },
    {
        "Question": "بائنری ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "بائنری ہیپ ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ڈھیر کی پراپرٹی کو مطمئن کرتا ہے ، جس کی وجہ یہ ہے کہ سب سے زیادہ یا سب سے کم ترجیح والا عنصر ہمیشہ درخت کی جڑ میں محفوظ رہتا ہے۔بائنری ہیپ کو ایک سرنی کا استعمال کرتے ہوئے موثر انداز میں نافذ کیا جاسکتا ہے ، جہاں انڈیکس میں والدین ، بائیں بچے اور نوڈ کے دائیں بچے کا حساب کتاب مندرجہ ذیل ہے: والدین = (i - 1) / 2 ، بائیں بچے = 2i + 1 ،اور دائیں بچہ = 2i+212. یہاں ایک C ++ بائنری ہیپ کا نفاذ: C ++#شامل <iosteream>#شامل کریں <ویکٹر> کلاس بائنری ہیپ {عوامی: بائنری ہیپ () {} باطل داخل (انٹ ویلیو) {ہیپ.پش_بیک (قیمت (قیمت)) ؛int index = hap.size () - 1 ؛جبکہ (انڈیکس> 0 && ڈھیر [انڈیکس]> ہیپ [(انڈیکس - 1) / 2]) {ایس ٹی ڈی :: تبادلہ (ہیپ [انڈیکس] ، ہیپ [(انڈیکس - 1) / 2]) ؛انڈیکس = (انڈیکس - 1) / 2 ؛}} انٹ ایکسٹریکٹ میکس () {انٹ زیادہ سے زیادہ = ہیپ [0] ؛ہیپ [0] = ہیپ ڈاٹ بیک () ؛hap.pop_back () ؛INT انڈیکس = 0 ؛جبکہ (سچ) {int بائیں = 2 * انڈیکس + 1 ؛INT حق = 2 * انڈیکس + 2 ؛INT سب سے بڑا = انڈیکس ؛اگر (بائیں <hap.size () && ہیپ [بائیں]> ڈھیر [سب سے بڑا]) {سب سے بڑا = بائیں ؛} if (دائیں <hap.size () && ہیپ [دائیں]> ہیپ [سب سے بڑا]) {سب سے بڑا = دائیں ؛} اگر (سب سے بڑا == انڈیکس) {بریک ؛} ایس ٹی ڈی :: سویپ (ہیپ [انڈیکس] ، ڈھیر [سب سے بڑا]) ؛انڈیکس = سب سے بڑا ؛} زیادہ سے زیادہ واپسی ؛} Bool isempty () {hep.empty () واپسی () ؛} نجی: std :: vector <int> ہیپ ؛} ؛ INT مین () {بائنری ہیپ ہیپ ؛hap.insert (5) ؛hap.insert (3) ؛hap.insert (8) ؛hap.insert (1) ؛hap.insert (6) ؛جبکہ (!} std :: cout << std :: endl ؛واپس 0 ؛} اس پروگرام میں ایک کلاس بائنری ہیپ کی وضاحت کی گئی ہے جس میں تین طریقے ہیں: داخل کریں () ، ایکسٹریکٹ میکس () ، اور آئسیمپٹی ()۔داخل () کا طریقہ بائنری ہیپ میں ایک قدر داخل کرتا ہے اور اگر ضروری ہو تو اس کے والدین کے ساتھ قیمت کو تبدیل کرکے ہیپ پراپرٹی کو برقرار رکھتا ہے۔ایکسٹریکٹ میکس () کا طریقہ بائنری ہیپ سے زیادہ سے زیادہ قیمت کو ہٹاتا ہے اور واپس کرتا ہے اور اگر ضروری ہو تو اپنے سب سے بڑے بچے کے ساتھ جڑ کو تبدیل کرکے ہیپ پراپرٹی کو برقرار رکھتا ہے۔اگر بائنری ہیپ خالی اور غلط ہے تو آئسٹی () کا طریقہ درست لوٹتا ہے۔ اہم () فنکشن بائنری ہیپ آبجیکٹ بناتا ہے ، بائنری ہیپ میں کچھ اقدار داخل کرتا ہے ، اور بائنری ڈھیر سے زیادہ سے زیادہ اقدار نکالتا ہے جب تک کہ یہ خالی نہ ہو۔اس کے بعد یہ نکالی گئی اقدار کو پرنٹ کرتی ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ بائنری ہیپ بناتا ہے ، کچھ اقدار داخل کرتا ہے ، اور زیادہ سے زیادہ اقدار نکالتا ہے: C ++ بائنری ہیپ ہیپ ؛ ہیپ.سرٹ (5) ؛ ہیپ.سرٹ (3) ؛ ڈھیر۔داخل کریں (8) ؛ ہیپ۔ INSERT (1) ؛ ہیپ.سرٹ (6) ؛<< std :: endl ؛ 1 programiz2algorithmtutor"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ دیئے گئے بائنری درخت متوازن ہیں یا نہیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا بائنری درخت متوازن ہے یا نہیں ، ہمیں یہ چیک کرنے کی ضرورت ہے کہ ، درخت میں موجود تمام نوڈس کے لئے ، بائیں اور دائیں سبٹریوں کی اونچائی کے درمیان فرق 112345 سے زیادہ نہیں ہے۔ اگر کسی بھی نوڈ کے لئے فرق 1 سے زیادہ ہے تو، درخت متوازن نہیں ہے۔ یہاں ایک C ++ پروگرام یہ چیک کرنے کے لئے ہے کہ آیا دیئے گئے بائنری ٹری متوازن ہے: C ++#شامل کریں <iostream>#شامل کریں <الگورتھم> سٹرک نوڈ {انٹ ڈیٹا ؛نوڈ* بائیں ؛نوڈ* دائیں ؛} ؛ انٹ اونچائی (نوڈ* نوڈ) {اگر (نوڈ == نولپٹر) {واپس 0 ؛} int بائیں_ہائٹ = اونچائی (نوڈ-> بائیں) ؛int right_height = اونچائی (نوڈ-> دائیں) ؛واپس STD :: میکس (بائیں_ہائٹ ، دائیں_ہائٹ) + 1 ؛} بول isalanced (نوڈ* نوڈ) {اگر (نوڈ == نولپٹر) {سچ واپس ؛} int بائیں_ہائٹ = اونچائی (نوڈ-> بائیں) ؛int right_height = اونچائی (نوڈ-> دائیں) ؛اگر (std :: abs (بائیں_ہائٹ - دائیں_ہائٹ)> 1) {غلط لوٹائیں ؛} واپس isbalanced (نوڈ-> بائیں) && isbalanced (نوڈ-> دائیں) ؛} انٹ مین () {نوڈ* روٹ* روٹ = نیا نوڈ {1 ، نیا نوڈ {2 ، نیا نوڈ {4 ، نولپٹر ، نولپٹر} ، نیا نوڈ{5 ، نولپٹر ، نولپٹر}} ، نیا نوڈ {3 ، نولپٹر ، نولپٹر}} ؛اگر (isbalanced (جڑ)) {std :: cout << \"بائنری ٹری متوازن ہے\" << std :: endl ؛} دوسری {std :: cout << \"بائنری ٹری متوازن نہیں ہے\" << std :: endl ؛} واپسی 0 ؛} یہ پروگرام ایک ڈھانچے کے نوڈ کی وضاحت کرتا ہے جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے۔پروگرام میں دو افعال کی بھی وضاحت کی گئی ہے: اونچائی () اور isbalanced ()۔اونچائی () فنکشن بائنری درخت میں نوڈ کی اونچائی کا حساب کتاب کرتا ہے۔isbalanced () فنکشن چیک کرتا ہے کہ اگر کسی بائنری ٹری کو ہر نوڈ کے بائیں اور دائیں سب ٹریوں کی اونچائی کا حساب لگاکر متوازن کیا جاتا ہے اور یہ جانچ پڑتال کرتے ہیں کہ آیا اونچائیوں کے درمیان فرق 1 سے زیادہ نہیں ہے تو اگر کسی نوڈ کے لئے فرق 1 سے زیادہ ہے تو، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، یہ بار بار جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں سبٹریز متوازن ہیں۔ مین () فنکشن بائنری درخت بناتا ہے ، اگر یہ متوازن () کا استعمال کرتے ہوئے متوازن ہے ، اور اس پیغام کو پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ بائنری درخت متوازن ہے یا نہیں۔ مثال کے طور پر۔، مندرجہ ذیل کوڈ بائنری ٹری تیار کرتا ہے ، اگر یہ متوازن ہے تو چیک کرتا ہے ، اور ایک پیغام پرنٹ کرتا ہے: C ++ نوڈ* روٹ = نیا نوڈ {1 ، نیا نوڈ {2 ، نیا نوڈ {4 ، نولپٹر ، نولپٹر} ، نیا نوڈ {5 ، nullptr ، nullptr}} ، نیا نوڈ {3 ، نولپٹر ، نولپٹر}} if اگر (isbalanced (جڑ)) {std :: cout << \"بائنری ٹری متوازن ہے\"std :: cout << \"بائنری ٹری متوازن نہیں ہے\" << std :: endl ؛} 1TakeUforward2techeidelight3geeksforgeeks4digitalocean5programize"
    },
    {
        "Question": "ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک ٹری ڈیٹا ڈھانچہ ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ڈور کے مجموعوں کو ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔یہ تار کے ایک بہت بڑے سیٹ میں کسی کلید کی موثر بازیافت کے لئے استعمال ہوتا ہے۔لفظ \"ٹری\" لفظ \"بازیافت\" سے آیا ہے جس کا مطلب ہے کہ کچھ تلاش کرنا یا حاصل کرنا ہے۔ یہاں ایک سی ++ ٹری ڈیٹا ڈھانچے کا نفاذ ہے: c ++#شامل <iostream>#شامل <غیر منظم_ میپ> کلاس ٹرینوڈ {عوامی: std :::غیر آرڈرڈ_ میپ <چار ، ٹرائینوڈ*> بچے ؛بول isendofword ؛trienode () {isendofword = غلط ؛}} ؛ کلاس ٹری {عوامی: ٹری () {جڑ = نیا ٹرائینوڈ () ؛} باطل داخل کریں (std :: سٹرنگ ورڈ) {trienode* نوڈ = جڑ ؛کے لئے (چار سی: ورڈ) {اگر (نوڈ-> بچے۔} نوڈ = نوڈ-> بچے [c] ؛} نوڈ-> isendofword = سچ ؛} بول تلاش (std :: سٹرنگ ورڈ) {trienode* نوڈ = جڑ ؛کے لئے (چار سی: ورڈ) {اگر (نوڈ-> بچے.فائنڈ (سی) == نوڈ-> بچے۔} نوڈ = نوڈ-> بچے [c] ؛} واپسی نوڈ-> isendofword ؛} بول اسٹارٹ ویتھ (ایس ٹی ڈی :: سٹرنگ کا سابقہ) {ٹرائینوڈ* نوڈ = جڑ ؛کے لئے (چار سی: سابقہ) {اگر (نوڈ-> بچے۔ فائنڈ (سی) == نوڈ-> بچے۔} نوڈ = نوڈ-> بچے [c] ؛} سچ واپس ؛} نجی: ٹرائینوڈ* جڑ ؛} ؛ انٹ مین () {ٹری ٹری ؛trie.insert (\"ایپل\") ؛std :: cout << trie.search (\"ایپل\") << std :: endl ؛// پرنٹس 1 std :: cout << trie.search (\"app\") << std :: endl ؛// پرنٹس 0 std :: cout << trie.startswith (\"app\") << std :: endl ؛// پرنٹس 1 trie.insert (\"ایپ\") ؛std :: cout << trie.search (\"app\") << std :: endl ؛// پرنٹس 1 ریٹرن 0 ؛} اس پروگرام میں دو کلاسوں کی وضاحت کی گئی ہے: ٹرائنوڈ اور ٹری۔ٹرائینوڈ کلاس ٹری ڈیٹا ڈھانچے میں ایک نوڈ کی نمائندگی کرتی ہے اور اس کے دو فیلڈز ہیں: بچے ، جو ایک غیر منظم نقشہ ہے جو بچوں کے نوڈس ، اور آئسنڈوف ورڈ کے کرداروں کا نقشہ بناتا ہے ، جو ایک بولین پرچم ہے جو اس بات کی نشاندہی کرتا ہے کہ آیا نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے یا نہیں۔ٹری کلاس ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے اور اس کے تین طریقے ہیں: داخل کریں () ، تلاش () ، اور اسٹارٹ ویتھ ()۔داخل () کا طریقہ ٹرائی کو عبور کرکے اور ضرورت کے مطابق نئے نوڈس تشکیل دے کر ٹرائی ڈیٹا ڈھانچے میں ایک لفظ داخل کرتا ہے۔تلاش () طریقہ ٹرائی کو عبور کرکے اور یہ چیک کرکے ٹرائی ڈیٹا ڈھانچے میں کسی لفظ کی تلاش کرتا ہے کہ آیا حتمی نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔اسٹارٹ ویتھ () کا طریقہ چیک کرتا ہے کہ اگر ٹری کو عبور کرتے ہوئے ٹرائی ڈیٹا ڈھانچے میں کوئی سابقہ موجود ہے اور یہ جانچ کر کے کہ اگر سابقہ میں موجود تمام کردار ٹری میں موجود ہیں۔ مین () فنکشن ٹری آبجیکٹ کی تشکیل کرتا ہے ، کچھ الفاظ ٹرائی میں داخل کرتا ہے ،اور تلاش () اور اسٹارٹ ویتھ () طریقوں کا استعمال کرتے ہوئے کچھ تلاشی اور پریفکس چیک انجام دیتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک سہ رخی تخلیق کرتا ہے ، کچھ الفاظ داخل کرتا ہے ، اور کچھ تلاشیں اور سابقہ چیک انجام دیتا ہے: C ++ ٹری ٹری ؛ ٹری۔ Insert (trie.Insert (\"ایپل\") ؛ std :: cout << trie.search (\"ایپل\") << std :: endl ؛// پرنٹس 1std :: cout << trie.search (\"app\") << std :: endl ؛// پرنٹس 0STD :: cout << trie.startswith (\"app\") << std :: endl ؛// پرنٹس 1 ٹری۔ Insert (\"ایپ\") ؛ std :: cout << trie.search (\"app\") << std :: endl ؛// پرنٹس 11 سکلر 2leetCode"
    },
    {
        "Question": "کسی گراف پر گہرائی کی پہلی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی گراف پر گہرائی کی پہلی تلاش کرنے کے ل we ، ہم ایک بار بار چلنے والے الگورتھم کا استعمال کرسکتے ہیں جو ایک دیئے گئے نوڈ سے شروع ہوتا ہے اور بیک ٹریکنگ 123 سے پہلے ہر شاخ کے ساتھ جہاں تک ممکن ہو تلاش کرتا ہے۔الگورتھم نوڈس کا ٹریک رکھنے کے لئے ایک وزٹ شدہ سیٹ کو برقرار رکھتا ہے جن کا پہلے ہی دورہ کیا جا چکا ہے اور نوڈس کا ٹریک رکھنے کے لئے ایک اسٹیک جس کا دورہ کرنے کی ضرورت ہے۔<iosteream>#شامل <ویکٹر>#شامل <غیر منظم_سیٹ>#شامل <اسٹیک> کلاس گراف {عوامی: گراف (انٹ این) {adj.resize (n) ؛} باطل اضافے (int u ، int v) {adj [u] .push_back (v) ؛adj [v] .push_back (u) ؛diid باطل DFS (int start) {std :: غیر آرڈرڈ_سیٹ <int> ملاحظہ ؛std :: stac <int> اسٹیک ؛اسٹیک.پش (شروع) ؛جبکہ (! stack.empty ()) {انٹ نوڈ = اسٹیک۔ ٹاپ () ؛stac.pop () ؛اگر (ملاحظہ کیا گیا۔} ملاحظہ کریں۔ INSERT (نوڈ) ؛std :: cout << نوڈ << \"\" ؛کے لئے (INT پڑوسی: adj [نوڈ]) {stack.push (پڑوسی) ؛}} std :: cout << std :: endl ؛} نجی: std :: vector <std :: vector <int >> adj ؛} ؛ INT مین () {گراف گراف (4) ؛گراف.ڈیج (0 ، 1) ؛گراف.ڈیج (0 ، 2) ؛گراف.ڈیج (1 ، 2) ؛گراف.ڈیج (2 ، 3) ؛گراف ڈاٹ ڈی ایف ایس (0) ؛واپس 0 ؛} اس پروگرام میں ایک کلاس گراف کی وضاحت کی گئی ہے جو ایک غیر ہدایت شدہ گراف کی نمائندگی کرتا ہے اور اس کے دو طریقے ہیں: ایڈج () اور ڈی ایف ایس ()۔ایڈج () کا طریقہ گراف میں دو نوڈس کے درمیان ایک کنارے کا اضافہ کرتا ہے۔ڈی ایف ایس () کا طریقہ ایک دیئے گئے سیٹ اور اسٹیک کو برقرار رکھتے ہوئے دیئے گئے نوڈ سے شروع ہونے والے گراف پر گہرائی کی پہلی تلاش کرتا ہے۔یہ طریقہ اسٹیک پر اسٹارٹ نوڈ کو آگے بڑھانے سے شروع ہوتا ہے اور پھر بار بار اسٹیک سے نوڈ کو پاپ کرتا ہے ، اسے دیکھنے کے طور پر نشان زد کرتا ہے ، اسے پرنٹ کرتا ہے ، اور اپنے غیر منحصر پڑوسیوں کو اسٹیک پر دھکیل دیتا ہے۔ مین () فنکشن ایک گراف آبجیکٹ بناتا ہے ، کچھ شامل کرتا ہے۔گراف کے کنارے ، اور ڈی ایف ایس () کے طریقہ کار کا استعمال کرتے ہوئے نوڈ 0 سے شروع ہونے والی گہرائی کی پہلی تلاش انجام دیتے ہیں۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک گراف بناتا ہے ، کچھ کناروں کو شامل کرتا ہے ، اور نوڈ 0 سے شروع ہونے والی گہرائی کی پہلی تلاش کرتا ہے: سی۔++ گراف گراف (4) ؛ گراف.ڈیج (0 ، 1) ؛ گراف.اڈیج (0 ، 2) ؛ گراف.اڈیج (1 ، 2) ؛ گراف.اڈیج (2 ، 3) ؛ گراف.ڈف ایس (0)؛ 1geeksforgeeks2programiz3javatPoint"
    },
    {
        "Question": "خود توازن بائنری تلاش کے درخت کو نافذ کریں۔",
        "Answer": "ایک خود توازن بائنری سرچ ٹری ایک بائنری سرچ ٹری ہے جو خود بخود اپنی اونچائی کو کم سے کم رکھتا ہے ، اس بات کو یقینی بناتا ہے کہ اس کی کارروائی ہمیشہ O (لاگ این) 123 کی بدترین صورتحال کو برقرار رکھے گی۔خود توازن بائنری سرچ ٹری تغیر پذیر آرڈر کی فہرستوں کے لئے موثر نفاذ فراہم کرتے ہیں ، اور دوسرے تجریدی اعداد و شمار کے ڈھانچے جیسے ایسوسی ایٹیو اریوں ، ترجیحی قطاریں ، اور سیٹ 2 کے لئے استعمال ہوسکتے ہیں۔ خود توازن بائنری تلاش کے درختوں کی متعدد اقسام ہیں ، جن میں AVL درخت بھی شامل ہیں ،سرخ سیاہ درخت ، اور بی ٹریز 12۔خود متوازن بائنری سرچ ٹری کا نفاذ AVL درخت کے اعداد و شمار کے ڈھانچے کی طرح ہے۔ یہاں A AVL درخت کا C ++ عمل درآمد ہے ، جو خود توازن بائنری تلاش کا درخت ہے: C ++#شامل <iostream> کلاس نوڈ {پبلک: INT KEY ؛INT اونچائی ؛نوڈ* بائیں ؛نوڈ* دائیں ؛نوڈ (INT KEY) {this-> key = key ؛اونچائی = 1 ؛بائیں = nullptr ؛دائیں = nullptr ؛}} ؛ کلاس avltree {عوامی: avltree () {جڑ = nullptr ؛} باطل داخل کریں (انٹ کلید) {جڑ = داخل کریں (جڑ ، کلید) ؛} باطل ہٹائیں (انٹ کی کلید) {جڑ = ہٹائیں (جڑ ، کلید) ؛} باطل inorder () {inorder (جڑ) ؛std :: cout << std :: endl ؛} نجی: نوڈ* جڑ ؛INT اونچائی (نوڈ* نوڈ) {اگر (نوڈ == نولپٹر) {واپس 0 ؛} واپسی نوڈ-> اونچائی ؛} انٹ بیلنس فیکٹر (نوڈ* نوڈ) {اگر (نوڈ == نولپٹر) {واپس 0 ؛} اونچائی (نوڈ-> بائیں)-اونچائی (نوڈ-> دائیں) ؛} باطل اپ ڈیٹ ہائٹ (نوڈ* نوڈ) {نوڈ-> اونچائی = std :: زیادہ سے زیادہ (اونچائی (نوڈ-> بائیں) ، اونچائی (نوڈ-> دائیں)) + 1 ؛} نوڈ* روٹیٹلیفٹ (نوڈ* نوڈ) {نوڈ* نیوروٹ = نوڈ-> صحیح ؛نوڈ-> دائیں = newrot-> بائیں ؛newrot-> بائیں = نوڈ ؛اپ ڈیٹ ہائٹ (نوڈ) ؛اپ ڈیٹ ہائٹ (نیو روٹ) ؛واپس نیو روٹ ؛} نوڈ* روٹیرائٹ (نوڈ* نوڈ) {نوڈ* نیو روٹ = نوڈ-> بائیں ؛نوڈ-> بائیں = newrot-> دائیں ؛newrot-> حق = نوڈ ؛اپ ڈیٹ ہائٹ (نوڈ) ؛اپ ڈیٹ ہائٹ (نیو روٹ) ؛واپس نیو روٹ ؛} نوڈ* بیلنس (نوڈ* نوڈ) {اگر (بیلنس فیکٹر (نوڈ)> 1) {اگر (بیلنس فیکٹر (نوڈ-> بائیں) <0) {نوڈ-> بائیں = روٹیٹیلفٹ (نوڈ-> بائیں) ؛} روٹیرائٹ (نوڈ) لوٹائیں ؛} ورنہ اگر (بیلنس فیکٹر (نوڈ) <-1) {اگر (بیلنس فیکٹر (نوڈ-> دائیں)> 0) {نوڈ-> حق = روٹیرائٹ (نوڈ-> دائیں) ؛return روٹیٹ لفٹ (نوڈ) واپس کریں ؛} واپسی نوڈ ؛} نوڈ* داخل کریں (نوڈ* نوڈ ، انٹ کی) {اگر (نوڈ == نولپٹر) {نیا نوڈ (کلید) واپس کریں ؛} if (key <نوڈ-> کلید) {نوڈ-> بائیں = داخل کریں (نوڈ-> بائیں ، کلید) ؛} دوسری صورت میں اگر (key> نوڈ-> کلید) {نوڈ-> دائیں = داخل کریں (نوڈ-> دائیں ، کلید) ؛} دوسری {واپسی نوڈ ؛} اپ ڈیٹ ہائٹ (نوڈ) ؛واپسی بیلنس (نوڈ) ؛} نوڈ* فائنڈ مین (نوڈ* نوڈ) {جبکہ (نوڈ-> بائیں! = نولپٹر) {نوڈ = نوڈ-> بائیں ؛} واپسی نوڈ ؛} نوڈ* ہٹانے والا (نوڈ* نوڈ) {اگر (نوڈ-> بائیں == نولپٹر) {واپسی نوڈ-> دائیں ؛} نوڈ-> بائیں = ہٹانے والا (نوڈ-> بائیں) ؛اپ ڈیٹ ہائٹ (نوڈ) ؛واپسی بیلنس (نوڈ) ؛} نوڈ* ہٹائیں (نوڈ* نوڈ ، انٹ کی) {اگر (نوڈ == نولپٹر) {واپس نولپٹر ؛} if (key <نوڈ-> کلید) {نوڈ-> بائیں = ہٹائیں (نوڈ-> بائیں ، کلید) ؛} دوسری صورت میں اگر (key> نوڈ-> کلید) {نوڈ-> حق = ہٹائیں (نوڈ-> دائیں ، کلید) ؛} دوسری {نوڈ* بائیں = نوڈ-> بائیں ؛نوڈ* دائیں = نوڈ-> صحیح ؛نوڈ کو حذف کریں ؛اگر (دائیں == nullptr) {بائیں واپس ؛} نوڈ* منٹ = فائنڈ مین (دائیں) ؛Min-> دائیں = ہٹانے والا (دائیں) ؛من-> بائیں = بائیں ؛اپ ڈیٹ ہائٹ (منٹ) ؛واپسی بیلنس (منٹ) ؛} اپ ڈیٹ ہائٹ (نوڈ) ؛واپسی بیلنس (نوڈ) ؛} باطل inorder (نوڈ* نوڈ) {اگر (نوڈ == نولپٹر) {واپسی ؛} inorder (نوڈ-> بائیں) ؛std :: cout << نوڈ-> کلید << \"\" ؛inorder (نوڈ-> دائیں) ؛}} ؛ انٹ مین () {avltree درخت ؛tree.insert (5) ؛tree.insert (3) ؛tree.insert (8) ؛tree.insert (1) ؛tree.insert (6) ؛tree.inorder () ؛// پرنٹس 1 3 5 6 8 درخت۔ ریمو (3) ؛tree.inorder () ؛// پرنٹس 1 5 6 8 ریٹرن 0 ؛} اس پروگرام میں دو کلاسوں کی وضاحت کی گئی ہے: نوڈ اور ایولٹری۔نوڈ کلاس"
    },
    {
        "Question": "عدد کی ایک صف پر انضمام کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عددیوں کی ایک صف پر انضمام کرنے کے لئے C ++ میں ایک پروگرام ہے: C ++#شامل <iosteream> نام اسپیس ایس ٹی ڈی کا استعمال کرتے ہوئے ؛ باطل انضمام (INT arr [] ، int l ، int m ، int r) {int n1 = m - l+1؛int n2 = r - m ؛int l [n1] ، r [n2] ؛کے لئے (int i = 0 ؛ i <n1 ؛ i ++) {l [i] = arr [l+i] ؛} کے لئے (int j = 0 ؛ j <n2 ؛ j ++) {r [j] = arr [m + 1 + j] ؛i انٹ i = 0 ، j = 0 ، k = l ؛جبکہ (i <n1 && j <n2) {اگر (l [i] <= r [j]) {arr [k] = l [i] ؛i ++ ؛} else {arr [k] = r [j] ؛J ++ ؛} K ++ ؛} جبکہ (i <n1) {arr [k] = l [i] ؛i ++ ؛K ++ ؛} جبکہ (j <n2) {arr [k] = r [j] ؛J ++ ؛K ++ ؛}} باطل انضمام (int arr [] ، int l ، int r) {if (l <r) {int m = l + (r - l) / 2 ؛انضمام (ARR ، L ، M) ؛انضمام (arr ، m + 1 ، r) ؛ضم (ARR ، L ، M ، R) ؛}} باطل پرنٹ ایری (انٹ آر آر [] ، انٹ سائز) {کے لئے (int i = 0 ؛ i <سائز ؛ i ++) {cout << arr [i] << \"\" ؛} cout << endl ؛} int مین () {int arr [] = {12 ، 11 ، 13 ، 5 ، 6 ، 7} ؛int arr_size = sizeof (arr) / sizeof (arr [0]) ؛cout << \"دی گئی صف \\ n\" ؛پرنٹ ایری (arr ، arr_size) ؛انضمام (arr ، 0 ، arr_size - 1) ؛cout << \"\\ nsorted سرنی \\ n\" ہے ؛پرنٹ ایری (arr ، arr_size) ؛واپس 0 ؛} اس پروگرام میں تین افعال کی وضاحت کی گئی ہے: انضمام () ، انضمام () ، اور پرنٹ ایری ()۔انضمام () فنکشن ایک سرنی آر آر ، دو اشارے ایل اور آر ، اور ایک مڈل انڈیکس ایم لیتا ہے اور دو سبارری آر آر [ایل.. ایم] اور آر آر [ایم+1..r] کو ایک ہی ترتیب شدہ سبری آر اے آر میں ضم کرتا ہے [l..r].انضمام () فنکشن ایک سرنی آر آر ، دو انڈیکس ایل اور آر لیتا ہے ، اور انضمام () فنکشن کا استعمال کرتے ہوئے سبری آر آر [ایل.. آر] کو بار بار ترتیب دیتا ہے۔پرنٹ اری () فنکشن ایک سرنی آر آر اور اس کے سائز کا سائز لیتا ہے اور سرنی کے عناصر کو پرنٹ کرتا ہے۔ مین () فنکشن ایک سرنی آر آر تشکیل دیتا ہے ، اصل صف کو پرنٹ کرتا ہے ، مرجورٹ () فنکشن کا استعمال کرتے ہوئے سرے کو ترتیب دیتا ہے ، اور ترتیب شدہ ترتیب کو پرنٹ کرتا ہے۔سرنی۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک صف تیار کرتا ہے ، اصل صف کو پرنٹ کرتا ہے ، مرجورٹ () فنکشن کا استعمال کرتے ہوئے سرنی کو ترتیب دیتا ہے ، اور ترتیب شدہ صف کو پرنٹ کرتا ہے: C ++ INT ARR [] = {12 ، 11 ، 13 ، 5 ،6 ، 7} int int arr_size = sizeof (arr) / sizeof (arr [0]) ؛ cout << \"دیئے گئے سرنی \\ n\" ؛ پرنٹراے (arr ، arr_size) ؛ مرجورٹ (arr ، 0 ، arr_size - 1) ؛cout << \"\\ nsorted سرنی \\ n\" ہے \\ n \"؛ پرنٹ ایری (arr ، arr_size) ؛ آؤٹ پٹ: دیئے گئے سرنی 12 11 13 5 6 6 7 ترتیب شدہ سرنی 5 6 7 11 12 13 1scaler2prepinsta3sanfoundry4softwaretetinghelp5programize ہے"
    },
    {
        "Question": "اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "اسکیپ لسٹ ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو لنکڈ لسٹ 1234 کے ساتھ عناصر یا ڈیٹا کی ترتیب شدہ فہرست کو ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔یہ ایک ہی مرحلے میں پوری فہرست کے متعدد عناصر کو چھوڑ کر عناصر یا ڈیٹا کی موثر پروسیسنگ کی اجازت دیتا ہے ، اسی وجہ سے اسے اسکیپ لسٹ 2 کے نام سے جانا جاتا ہے۔اسکیپ لسٹ منسلک فہرست کا ایک توسیع شدہ ورژن ہے اور یہ دو پرتوں میں بنایا گیا ہے: سب سے کم پرت اور اوپری پرت 2۔اسکیپ لسٹ کی سب سے کم پرت ایک عام ترتیب شدہ لنکڈ فہرست ہے ، اور اسکیپ لسٹ کی اوپری پرتیں ایک \"ایکسپریس لائن\" کی طرح ہیں جہاں عناصر کو چھوڑ دیا جاتا ہے۔ اس کا ایک مختصر جائزہ ہے کہ اسکیپ لسٹ کیسے کام کرتی ہے: اسکیپ لسٹ ہے۔اضافی فارورڈ پوائنٹرز کے ساتھ ایک منسلک فہرست۔ فارورڈ پوائنٹرز تلاش کے دوران کچھ عناصر کو چھوڑنے کی اجازت دیتے ہیں ، جس سے تلاش کو تیز تر ہوتا ہے۔ فارورڈ پوائنٹر ممکنہ طور پر بنائے جاتے ہیں ، لہذا اسکیپ لسٹ بے ترتیب ڈیٹا ڈھانچہ ہے۔ اسکیپ کی متوقع تلاش کا وقت اسکیپ کا متوقع وقت ہے۔فہرست O (لاگ این) ہے۔ یہاں ایک سی ++ اسکیپ لسٹ ڈیٹا ڈھانچے کا نفاذ ہے: C ++#شامل کریں <iostream>#شامل کریں <cstdlib>#شامل کریں <ctime> نام اسپیس ایس ٹی ڈی کا استعمال کرتے ہوئے const کانسٹ انٹ میکس_ لیول = 6 ؛ کلاس نوڈ {عوامی: عوامی: عوامی:INT KEY ؛نوڈ ** آگے ؛نوڈ (انٹ ، انٹ) ؛~ نوڈ () ؛} ؛ نوڈ :: نوڈ (INT KEY ، INT لیول) {this-> key = key ؛فارورڈ = نیا نوڈ*[سطح+1] ؛میمسیٹ (فارورڈ ، 0 ، سائز (نوڈ*)*(سطح+1)) ؛} نوڈ :: ~ نوڈ () {حذف کریں [] فارورڈ ؛} کلاس اسکیپلسٹ {عوامی: اسکیپلسٹ () ؛~ اسکیپلسٹ () ؛باطل داخلہ (INT) ؛BOOL سرچ ایلیمنٹ (INT) ؛باطل حذف (INT) ؛باطل ڈسپلے لسٹ () نجی: انٹ رینڈم لیول () ؛نوڈ* سر ؛انٹ لیول ؛} ؛ اسکیپلسٹ :: اسکیپلسٹ () {سر = نیا نوڈ (-1 ، میکس_ لیول) ؛سطح = 0 ؛} اسکیپلسٹ :: ~ اسکیپلسٹ () {سر کو حذف کریں ؛} انٹ اسکیپلسٹ :: رینڈم لیول () {انٹ لول = 0 ؛جبکہ (رینڈ () <رینڈ_میکس/2 && lvl <MAX_LEVEL) {LVL ++ ؛l لوٹ ایل وی ایل ؛} باطل اسکیپلسٹ :: داخلہ (انٹ کلید) {نوڈ* موجودہ = سر ؛نوڈ* اپ ڈیٹ [میکس_ لیول+1] ؛میمسیٹ (اپ ڈیٹ ، 0 ، سائز (نوڈ*)*(میکس_ لیول+1)) ؛(int i = سطح ؛ i> = 0 ؛ i--) {جبکہ (موجودہ-> فارورڈ [i]! = nullptr && موجودہ-> فارورڈ [i]-> کلید <کلید) {موجودہ = موجودہ-> فارورڈ[میں]؛} اپ ڈیٹ [i] = موجودہ ؛} موجودہ = موجودہ-> فارورڈ [0] ؛اگر (موجودہ == nullptr || موجودہ-> کلید! = کلید) {int newlevel = randlelevel () ؛اگر (newlevel> سطح) {for (int i = سطح+1 ؛ i <= newlevel ؛ i ++) {اپ ڈیٹ [i] = ہیڈ ؛} سطح = newlevel ؛} نوڈ* newnode = نیا نوڈ (کلید ، نیا لیول) ؛(int i = 0 ؛ i <= newlevel ؛ i ++) {newnode-> فارورڈ [i] = اپ ڈیٹ [i]-> فارورڈ [i] ؛اپ ڈیٹ [i]-> فارورڈ [i] = newnode ؛}}} بول اسکیپلسٹ :: سرچ ایلیمنٹ (انٹ کی کلید) {نوڈ* موجودہ = سر ؛(int i = سطح ؛ i> = 0 ؛ i--) {جبکہ (موجودہ-> فارورڈ [i]! = nullptr && موجودہ-> فارورڈ [i]-> کلید <کلید) {موجودہ = موجودہ-> فارورڈ[میں]؛}} موجودہ = موجودہ-> فارورڈ [0] ؛واپسی (موجودہ! = nullptr && موجودہ-> کلید == کلید) ؛} باطل اسکیپلسٹ :: حذف کرنے والا (INT کلید) {نوڈ* موجودہ = ہیڈ ؛نوڈ* اپ ڈیٹ [میکس_ لیول+1] ؛میمسیٹ (اپ ڈیٹ ، 0 ، سائز (نوڈ*)*(میکس_ لیول+1)) ؛(int i = سطح ؛ i> = 0 ؛ i--) {جبکہ (موجودہ-> فارورڈ [i]! = nullptr && موجودہ-> فارورڈ [i]-> کلید <کلید) {موجودہ = موجودہ-> فارورڈ[میں]؛} اپ ڈیٹ [i] = موجودہ ؛} موجودہ = موجودہ-> فارورڈ [0] ؛اگر (کرنٹ!} اپ ڈیٹ [i]-> فارورڈ [i] = موجودہ-> فارورڈ [i] ؛current موجودہ حذف کریں ؛جبکہ (سطح> 0 && ہیڈ-> فارورڈ [سطح] == نولپٹر) {لیول-- ؛}}} باطل اسکیپلسٹ :: ڈسپلے لسٹ () {cout << \"اسکیپ لسٹ\" << اینڈل ؛کے لئے (int i = 0 ؛ i <= سطح ؛ i ++) {نوڈ* نوڈ = ہیڈ-> فارورڈ [i] ؛cout << \"سطح\" << i << \":\" ؛جبکہ (نوڈ! = نولپٹر) {cout << نوڈ-> کلید << \"\" ؛نوڈ = نوڈ-> فارورڈ [i] ؛} cout << endl ؛}} انٹ مین () {سرینڈ (وقت (نولپٹر)) ؛اسکیپلسٹ لسٹ ؛فہرست۔ insertelement (3) ؛فہرست۔ insertelement (6) ؛فہرست"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں یا نہیں۔",
        "Answer": "یہ چیک کرنے کے بہت سارے طریقے ہیں کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں یا نہیں۔یہاں کچھ عام طریقے ہیں: تار میں ہر کردار کی تعدد کو گننے کے لئے لغت کا استعمال کرتے ہوئے: ہم دو لغات پیدا کرسکتے ہیں ، ہر ایک تار کے لئے ایک ، اور ہر کردار کی تار میں ظاہر ہونے کی تعداد کو گن سکتے ہیں۔اگر لغات برابر ہیں ، تو پھر دو اصل ڈور اناگرام ہیں۔اس طریقہ کار کا ایک ازگر کا نفاذ یہاں ہے: پیتھنڈف آئی ایس_انگم (ایس 1 ، ایس 2): اگر لین (ایس 1)! = لین (ایس 2): غلط ڈکٹ 1 = {} ڈکٹ 2 = {} S1 میں چار کے لئے: ڈکٹ 1 [چار] = ڈکٹ 1۔S2 میں چار کے لئے (چار ، 0) + 1 حاصل کریں: ڈکٹ 2 [چار] = ڈکٹ 2۔بیٹ (چار ، 0) + 1 واپسی ڈکٹ 1 == ڈکٹ 2 پرنٹ (is_anagram (\"angram\" ، \"ناگارام\")) # ٹروپنٹ (is_anagram (is_anagram (is_anagram (is_anagram \")\"ہیلو\" ، \"ورلڈ\"))) # ازگر میں کلیکشن ماڈیول سے کاؤنٹر کلاس کو غلط استعمال کرنا: کاؤنٹر کلاس ان پٹ کے طور پر قابل تقلید لیتا ہے اور اس کے قابل ہر عنصر کی تعدد کو گنتا ہے۔ہم ہر تار کو ان پٹ کے طور پر کسی کاؤنٹر آبجیکٹ کے پاس منتقل کرسکتے ہیں اور دو کاؤنٹر اشیاء کا موازنہ کرسکتے ہیں۔اس طریقہ کار کا ایک ازگر کا نفاذ یہاں ہے: ازگر کے کلیکشن امپورٹ کاؤنٹر ڈیف is_anagram (S1 ، S2): ریٹرن کاؤنٹر (S1) == کاؤنٹر (S2) پرنٹ (is_anagram (\"agnagram\" ، \"nagaram\")) # سچ پرنٹ (IS_Anagram (\"ہیلو\"،\" ورلڈ \")) # تاروں کی غلط فہمی اور ان کا موازنہ کرنا: ہم ہر تار میں کرداروں کو ترتیب دے سکتے ہیں اور ترتیب شدہ تاروں کا موازنہ کرسکتے ہیں۔اگر ترتیب دیئے گئے ڈور برابر ہیں ، تو دو اصل ڈور اناگرام ہیں۔یہاں جاوا اس طریقہ کار پر عمل درآمد ہے: جاوایمپورٹ java.util.Arrays ؛ عوامی کلاس اناگرام {عوامی جامد بولین اسانگگرام (سٹرنگ S1 ، سٹرنگ S2) {اگر (s1.length ()! = s2.length ()) {غلط واپس ؛} چار [] چیرری 1 = s1.tochararray () ؛چار [] چیرری 2 = s2.tochararray () ؛arrays.sort (چاراری 1) ؛arrays.sort (چیراری 2) ؛واپسی arrays.equals (چیرری 1 ، چیرری 2) ؛} عوامی جامد باطل مین (سٹرنگ [] آرگس) {system.out.println (isanagram (\"سنو\" ، \"خاموش\")) ؛// true system.out.println (isanagram (\"ہیلو\" ، \"دنیا\")) ؛// غلط}} آخر میں ، یہ چیک کرنے کے بہت سارے طریقے ہیں کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں یا نہیں۔ہم تار میں ہر کردار کی تعدد کو گننے ، ازگر میں کلیکشن ماڈیول سے کاؤنٹر کلاس کا استعمال کرنے کے لئے ایک لغت کا استعمال کرسکتے ہیں ، یا تاروں کو ترتیب دے سکتے ہیں اور ان کا موازنہ کرسکتے ہیں۔"
    },
    {
        "Question": "شروع سے ایک واحد منسلک فہرست کو نافذ کریں۔",
        "Answer": "شروع سے ایک واحد منسلک فہرست کو نافذ کرنے کے ل we ، ہمیں ایک نوڈ کلاس کی وضاحت کرنے کی ضرورت ہے جس میں دو فیلڈز ہوں: ڈیٹا اور اگلا۔ڈیٹا فیلڈ نوڈ کی قیمت کو محفوظ کرتا ہے ، اور اگلا فیلڈ فہرست میں اگلے نوڈ کا حوالہ دیتا ہے۔ہمیں لنکڈ لسٹ کلاس کی بھی وضاحت کرنے کی ضرورت ہے جس میں فہرست کے ہیڈ نوڈ کا حوالہ موجود ہو۔ہیڈ نوڈ فہرست میں پہلا نوڈ ہے۔ یہاں ایک واحد منسلک فہرست کا ازگر کا نفاذ ہے: پائیتھنکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈی اے ٹی اے = ڈیٹا سیلف۔ نیکسٹ = نان کلاس لنکڈ لسٹ: ڈیف __init __ (خود):self.head = کوئی بھی Def داخل نہیں (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر سیلف ہیڈ کوئی نہیں ہے: سیلف۔ ہیڈ = نیا_نوڈ اور: موجودہ = سیلف۔اگلا کرنٹ۔ نیکسٹ = نیا_نوڈ ڈیف ڈیلیٹ (خود ، ڈیٹا): اگر سیلف ہیڈ کوئی نہیں ہے: اگر سیلف ڈاٹا == ڈیٹا: سیلف۔ ہیڈ = سیل۔ ہیڈ۔ نیکسٹ واپس موجودہ = سیلف۔ ہیڈ موجودہ کے دوران۔اگلا کوئی بھی نہیں ہے: اگر موجودہ۔ نیکسٹ.ڈیٹا == ڈیٹا: موجودہ۔ نیکسٹ = کرنٹ۔ نیکسٹ۔ نیکسٹ ریٹرن کرنٹ = کرنٹ۔ نیکسٹ ڈیف سرچ (خود ، ڈیٹا): موجودہ = سیلف۔موجودہ ڈاٹ ڈیٹا == اعداد و شمار: حقیقی موجودہ = موجودہ۔ نیکسٹ ریٹرن فالس ڈیف ڈسپلے (خود): موجودہ = سیلف ہیڈ جبکہ موجودہ کوئی نہیں ہے: پرنٹ (کرنٹ.ڈیٹا ، اختتام = \"\") موجودہ = کرنٹ۔ نیکسٹ پرنٹ() مثال کے طور پر useagelinked_list = لنکڈ لسٹ () لنکڈ_لسٹ.نسرٹ (1) لنکڈ_لسٹ.نسرٹ (2) لنکڈ_لسٹ.نسرٹ (3) لنکڈ_لسٹ.ڈیس پلے () # آؤٹ پٹ: 1 2 3linked_list.delete (2) لنکڈ_لسٹ.ڈیس پلے () # آؤٹ پٹ: 1 3 پرنٹ (لنکڈ_ لسٹ.سرچ (3)) # آؤٹ پٹ: ٹروپنٹ (لنکڈ_ لسٹ.سرچ (2)) # آؤٹ پٹ: اس پر عمل درآمد کو غلط ، نوڈ کلاس میں دو فیلڈز ہیں: ڈیٹا اور اگلا۔لنکڈ لسٹ کلاس میں ایک فیلڈ ہیڈ ہوتا ہے جو فہرست کے ہیڈ نوڈ کا حوالہ دیتا ہے۔داخل () طریقہ فہرست کے آخر میں ایک نیا نوڈ داخل کرتا ہے۔حذف () کا طریقہ فہرست سے دی گئی قیمت کے ساتھ ایک نوڈ کو حذف کرتا ہے۔تلاش () کا طریقہ فہرست میں دی گئی قیمت کے ساتھ نوڈ کی تلاش کرتا ہے اور اگر یہ پایا جاتا ہے تو ، غلط ہے۔ڈسپلے () کا طریقہ فہرست میں تمام نوڈس کی اقدار کو پرنٹ کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک لنکڈ فہرست تیار کرتا ہے ، کچھ نوڈس داخل کرتا ہے ، فہرست کو دکھاتا ہے ، نوڈ کو حذف کرتا ہے ، فہرست کو دوبارہ دکھاتا ہے ، اور نوڈ کی تلاش کرتا ہے: پائیٹون لنکڈ_ لسٹ= لنکڈ لسٹ () لنکڈ_لسٹ۔ INSERT (1) لنکڈ_لسٹ۔ INSERT (2) لنکڈ_لسٹ.سرٹ (3) لنکڈ_لسٹ.ڈیس پلے () # آؤٹ پٹ: 1 2 3linked_list.delete (2) لنکڈ_لسٹ.ڈیس پلے () # آؤٹ پٹ: 1 3 پرنٹ (لنکڈ_ لسٹ (لنکڈ_ لسٹ. تلاش (3)) # آؤٹ پٹ: ٹروپنٹ (لنکڈ_لسٹ.سارچ (2)) # آؤٹ پٹ: غلط"
    },
    {
        "Question": "عدد کی صف پر بائنری تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عددیوں کی ایک صف پر بائنری تلاش کرنے کے ل we ، ہم مندرجہ ذیل الگورتھم کا استعمال کرسکتے ہیں: دو پوائنٹرز کو ، کم اور اونچے حصے کو سرنی کے پہلے اور آخری اشاریوں پر بالترتیب شروع کریں ، سرے کے درمیانی اشاریہ کو درمیانی = (کم کم+ اعلی) // 2. اگر سرنی کا درمیانی عنصر ہدف عنصر کے برابر ہے تو ، مڈل انڈیکس واپس کریں۔ اگر صف کا درمیانی عنصر ہدف عنصر سے زیادہ ہے تو ، اونچی ترتیب دے کر صف کے بائیں نصف کو تلاش کریں۔= وسط - 1. اگر سرنی کا درمیانی عنصر ہدف عنصر سے کم ہے تو ، کم = وسط + ترتیب دے کر صف کے دائیں نصف تلاش کریں۔تھک جانے والے۔ یہاں بائنری سرچ الگورتھم کے کچھ ازگر کے نفاذات ہیں: تھوڑی دیر لوپ کا استعمال کرتے ہوئے: پائیتھنڈف بائنری_سرچ (اے آر آر ، ہدف): کم = 0 ہائی = لین (اے آر آر) - 1 جبکہ کم <= اعلی: درمیانی = (کم + اعلی)// 2 اگر err [وسط] == ہدف: مڈ الیف آر آر [وسط] <ہدف: کم = وسط + 1 اور: اعلی = وسط - 1 واپسی -1 اے آر آر = [1 ، 2 ، 3 ، 4 ، 5 ، 6، 7 ، 8 ، 9] ٹارگٹ = 5result = بائنری_سرچ (اے آر آر ، ہدف) اگر نتیجہ!} صف میں موجود نہیں ہے۔: مڈ ایلف آر آر آر [مڈ] <ٹارگٹ: بائنری_سرچ (اے آر آر ، ٹارگٹ ، مڈ + 1 ، اونچا) لوٹائیں اور: بائنری_سرچ (اے آر آر ، ہدف ، کم ، وسط - 1) آر اے آر = [1 ، 2 ، 3 ، 4 ،5 ، 6 ، 7 ، 8 ، 9] ٹارگٹ = 5 ریزولٹ = بائنری_سرچ (اے آر آر ، ٹارگٹ ، 0 ، لین (اے آر آر) - 1) اگر نتیجہ! = -1: پرنٹ (ایف \"عنصر {ہدف and انڈیکس میں موجود ہے} \") اور: پرنٹ (ایف\" عنصر {ہدف} سرنی میں موجود نہیں ہے \") دونوں پر عمل درآمد میں ، بائنری_سرچ () فنکشن ایک سرنی آر آر ، ایک ہدف عنصر کا ہدف ، اور دو اشارے کم اور اونچائی لیتا ہے جو تلاش کی وضاحت کرتا ہے۔حدفنکشن سرنی میں ہدف عنصر کا انڈیکس لوٹاتا ہے اگر یہ پایا جاتا ہے ، یا اگر یہ نہیں مل جاتا ہے تو -1۔پہلا عمل درآمد بائنری تلاش کو انجام دینے کے ل a تھوڑی دیر کا استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد تکرار کا استعمال کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک سرنی تخلیق کرتا ہے ، کسی ہدف کے عنصر کے لئے صف پر بائنری تلاش کرتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے: ازگر =1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] ہدف = 5Result = بائنری_سرچ (ARR ، ہدف) اگر نتیجہ!\") اور: پرنٹ (ایف\" عنصر {ہدف} صف میں موجود نہیں ہے \")"
    },
    {
        "Question": "منسلک فہرست کا استعمال کرتے ہوئے اسٹیک کو نافذ کریں۔",
        "Answer": "لنکڈ لسٹ کا استعمال کرتے ہوئے اسٹیک کو نافذ کرنے کے ل we ، ہم ایک نوڈ کلاس کی وضاحت کرسکتے ہیں جس میں دو فیلڈز شامل ہیں: ڈیٹا اور اگلا۔ڈیٹا فیلڈ نوڈ کی قیمت کو محفوظ کرتا ہے ، اور اگلا فیلڈ فہرست میں اگلے نوڈ کا حوالہ دیتا ہے۔ہمیں ایک اسٹیک کلاس کی بھی وضاحت کرنے کی ضرورت ہے جس میں اسٹیک کے اوپری نوڈ کا حوالہ موجود ہو۔فہرست میں سب سے اوپر کا نوڈ حال ہی میں شامل کیا گیا نوڈ ہے۔ ایک لنکڈ فہرست کا استعمال کرتے ہوئے اسٹیک کا ایک ازگر کا نفاذ ہے: ازگر کلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ اسٹیک: ڈیف __init__(خود): سیلف۔ ٹاپ = کوئی بھی ڈیف پش (خود ، ڈیٹا): نیا_نوڈ = نوڈ (ڈیٹا) نیا_نوڈ. نیکسٹ = سیلف ٹاپ سیلف۔ ٹاپ = نیا_نوڈ ڈیف پاپ (خود): اگر سیلف نہیں ہے۔ڈیٹا = sell.top.data self.top = self.top.next ریٹرن ڈیٹا ڈیف PEEK (self): اگر self.top کوئی نہیں ہے: کوئی بھی واپس نہیں ہے۔کوئی بھی نہیں # مثال کے طور پر usagestack = اسٹیک () اسٹیک.پش (1) اسٹیک.پش (2) اسٹیک.پش (3) پرنٹ (اسٹیک.پیک ()) # آؤٹ پٹ: 3 پرنٹ (اسٹیک.پپ ()) # آؤٹ پٹ: 3 پرنٹ (3 پرنٹ (stac.pop ()) # آؤٹ پٹ: 2 پرنٹ (stack.is_empty ()) # آؤٹ پٹ: غلط پرنٹ (اسٹیک.پپ ()) # آؤٹ پٹ: 1 پرنٹ (اسٹیک.س_پٹی ()) # آؤٹ پٹ: ٹری پرنٹ (اسٹیک.پپ ())# آؤٹ پٹ: اس پر عمل درآمد نہیں ، نوڈ کلاس کے دو فیلڈز ہیں: ڈیٹا اور اگلا۔اسٹیک کلاس میں ایک فیلڈ ٹاپ ہوتا ہے جو اسٹیک کے اوپری نوڈ کا حوالہ دیتا ہے۔پش () کا طریقہ اسٹیک کے اوپری حصے میں ایک نیا نوڈ شامل کرتا ہے۔پاپ () کا طریقہ اسٹیک کے اوپری نوڈ کو ہٹاتا ہے اور لوٹاتا ہے۔جھانکنے والا () طریقہ اسٹیک کے اوپری نوڈ کی قیمت کو اسے ہٹائے بغیر لوٹاتا ہے۔اگر اسٹیک خالی ہے ، غلط ہے تو ، IS_EMPTY () کا طریقہ درست لوٹتا ہے۔خالی ہے ، اور اسٹیک سے ایک اور نوڈ کو پاپ کرتا ہے: پائیتھون اسٹیک = اسٹیک () اسٹیک.پش (1) اسٹیک.پش (2) اسٹیک.پش (3) پرنٹ (اسٹیک.پیک ()) # آؤٹ پٹ: 3 پرنٹ (اسٹیک.پوپ()) # آؤٹ پٹ: 3 پرنٹ (اسٹیک.پپ ()) # آؤٹ پٹ: 2 پرنٹ (اسٹیک.س_پٹی ()) # آؤٹ پٹ: غلط پرنٹ (اسٹیک.پپ ()) # آؤٹ پٹ: 1 پرنٹ (اسٹیک.IS_EMPTY ()) # آؤٹ پٹ:سچ پرنٹ (اسٹیک.پپ ()) # آؤٹ پٹ: نونین نتیجہ ، ہم نوڈ کلاس کی وضاحت کرکے لنکڈ فہرست کا استعمال کرتے ہوئے ایک اسٹیک کو نافذ کرسکتے ہیں جو لنکڈ فہرست میں نوڈ کی نمائندگی کرتا ہے ، اور اسٹیک کلاس جو اسٹیک کو نافذ کرنے کے لئے اس نوڈ کلاس کا استعمال کرتا ہے۔اسٹیک کلاس کا سب سے اوپر کی صفت اسٹیک کے اوپری حصے کی طرف اشارہ کرتی ہے (یعنی ، لنکڈ فہرست میں پہلا نوڈ)۔کسی شے کو اسٹیک پر دھکیلنے کے ل we ، ہم دیئے گئے آئٹم کے ساتھ ایک نیا نوڈ تیار کرتے ہیں اور اس کا اگلا پوائنٹر اسٹیک کے موجودہ اوپر پر سیٹ کرتے ہیں۔اس کے بعد ہم نے اسٹیک کے اوپری حصے کو نئے نوڈ پر سیٹ کیا ، اور اسے مؤثر طریقے سے اسٹیک کا نیا اوپر بنا دیا۔اسٹیک سے کسی شے کو پاپ کرنے کے ل we ، ہم لنکڈ لسٹ سے پہلے نوڈ کو اسٹیک کے اوپری حصے کو فہرست میں اگلے نوڈ پر ترتیب دے کر ہٹاتے ہیں (یعنی ، نوڈ نے موجودہ ٹاپ نوڈ کے اگلے فیلڈ کی طرف اشارہ کیا)۔1geeksforgeeks2agostini3prepbytes4ksu5pdx"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ دیئے گئے بائنری ٹری متوازن بائنری تلاش کا درخت ہے یا نہیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ اگر دیئے گئے بائنری کا درخت متوازن بائنری سرچ درخت ہے تو ، ہمیں یہ چیک کرنے کی ضرورت ہے کہ ، درخت کے ہر نوڈ کے لئے ، اس کے بائیں سب ٹری کی اونچائی اور اس کے دائیں سب ٹری کی اونچائی کے درمیان فرق 1 سے زیادہ نہیں ہے۔یہ حالت درخت کے ہر نوڈ کے لئے درست ہے ، پھر درخت متوازن بائنری تلاش کا درخت ہے۔ یہاں ایک فنکشن کا ایک ازگر کا نفاذ ہے جو چیک کرتا ہے کہ اگر بائنری کا درخت متوازن بائنری سرچ درخت ہے: ازگرکلاس نوڈ: ڈیف __ (خود ، ویل ، ویل ، ویل ، ویل ، ویل ، ویل ، ویل): سیلف۔ وول = ویل سیلف۔رائٹ_ہائٹ)> 1: غلط واپسی آئی ایس_ بیلنسڈ (روٹ.لفٹ) اور آئی ایس_بلنسڈ (روٹ. رائٹ) ڈیف اونچائی (نوڈ): اگر نوڈ کوئی نہیں ہے: واپس 0 لوٹ واپس 1 + زیادہ سے زیادہ (اونچائی (نوڈ.لفٹ) ، اونچائی (نوڈ۔دائیں))# مثال یوزیگروٹ = نوڈ (4) جڑ۔ لیفٹ = نوڈ (2) روٹ۔ رائٹ = نوڈ (6) جڑ۔.left = نوڈ (5) روٹ. رائٹ. رائٹ = نوڈ (7) پرنٹ (is_balanced (جڑ)) # آؤٹ پٹ: اس عمل کو سچ میں ، نوڈ کلاس بائنری درخت میں ایک نوڈ کی نمائندگی کرتا ہے۔آئی ایس_بلنسڈ () فنکشن بائنری درخت کی جڑ نوڈ کو ان پٹ کے طور پر لیتا ہے اور اگر درخت متوازن بائنری سرچ درخت ہے تو ، غلط ہے۔اونچائی () فنکشن بائنری ٹری میں دیئے گئے نوڈ کی اونچائی کا حساب لگاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ بائنری ٹری تیار کرتا ہے ، چیک کرتا ہے اگر یہ متوازن بائنری سرچ ٹری ہے ، اور نتیجہ پرنٹ کرتا ہے: پائیٹونروٹ = نوڈ (4) جڑ.left = نوڈ (2) روٹ۔ رائٹ = نوڈ (6) جڑ.ایلفٹ.لفٹ = نوڈ (1) روٹ. لیفٹ. رائٹ = نوڈ (3) روٹ۔ رائٹ.یلفٹ = نوڈ (5) جڑ۔= نوڈ (7) پرنٹ (is_balanced (جڑ)) # آؤٹ پٹ: سچائی نتیجہ ، ہم یہ طے کرسکتے ہیں کہ اگر دیئے گئے بائنری کا درخت ایک متوازن بائنری سرچ ٹری ہے ، یہ جانچ کر کے ، اگر درخت میں ہر نوڈ کے لئے ، اس کی اونچائی کے درمیان فرق ہے توبائیں سب ٹری اور اس کے دائیں سب ٹری کی اونچائی 1 سے زیادہ نہیں ہے۔ ہم اس چیک کو ایک بار بار چلنے والے فنکشن کا استعمال کرتے ہوئے نافذ کرسکتے ہیں جو درخت میں ہر نوڈ کی اونچائی کا حساب لگاتا ہے اور چیک کرتا ہے کہ اگر درخت ہر نوڈ پر متوازن ہے۔"
    },
    {
        "Question": "دو اسٹیکس کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "دو اسٹیکس کا استعمال کرتے ہوئے قطار کے اعداد و شمار کے ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل الگورتھم کا استعمال کرسکتے ہیں: دو اسٹیک ، اسٹیک 1 اور اسٹیک 2 بنائیں۔ عنصر کو بہتر بنانے کے ل an ، اسے اسٹیک 1 پر دبائیں۔ کسی عنصر کو ڈی کیوئو کرنے کے ل. ، اگر اسٹیک 2 خالی نہیں ہے تو ، اوپر عنصر کو پاپ کریں۔اسٹیک 2 سے اور اسے لوٹائیں۔بصورت دیگر ، جبکہ اسٹیک 1 خالی نہیں ہے ، اسٹیک 1 سے ٹاپ عنصر کو پاپ کریں اور اسے اسٹیک 2 پر دبائیں۔پھر اسٹیک 2 سے اوپر عنصر کو پاپ کریں اور اسے واپس کریں۔ یہ چیک کرنے کے لئے کہ قطار خالی ہے یا نہیں ، چیک کریں کہ اسٹیک 1 اور اسٹیک 2 دونوں خالی ہیں۔ یہاں دو اسٹیکوں کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کا ازگر عمل درآمد ہے: ازگر کلاس قطار: ڈیف __init __ (خود):self.stack1 = [] self.stack2 = [] Def enqueue (خود ، ڈیٹا): self.stack1.append (ڈیٹا) Def dequeue (self): اگر لین (self.stack2) == 0: جبکہ لین (خود)اسٹیک 1)! = 0: self.stack2.append (self.stack1.pop ()) اگر لین (self.stack2) == 0: کوئی بھی واپس نہیں کرے گا۔ sellself.stack1) == 0 اور LEN (self.stack2) == 0# مثال کے طور پر استعمال کیوئو = قطار () قطار۔ enqueue (1) قطار۔# آؤٹ پٹ: 1 پرنٹ (قطار۔ ڈیکوئ ()) # آؤٹ پٹ: 2 پرنٹ (قطار.IS_EMPTY ()) # آؤٹ پٹ: غلط پرنٹ (قطار۔ ڈی کیوئ ()) # آؤٹ پٹ: 3 پرنٹ (قطار.IS_EMPTY ()) # آؤٹ پٹ: ٹروپنٹ (قطار پرنٹ (قطار.dequeue ()) # آؤٹ پٹ: اس پر عمل درآمد نہیں ، قطار کلاس میں دو فیلڈز ہیں: اسٹیک 1 اور اسٹیک 2۔enqueue () کا طریقہ قطار کے آخر میں ایک نئے عنصر کو اسٹیک 1 پر دھکیل کر شامل کرتا ہے۔ڈی کیو () کا طریقہ اسٹیک 2 سے پاپ کرکے قطار سے پہلا عنصر کو ہٹاتا ہے اور واپس کرتا ہے۔اگر اسٹیک 2 خالی ہے تو ، یہ سب سے پہلے تمام عناصر کو اسٹیک 1 سے اسٹیک 1 سے پاپ کرکے اور اسٹیک 2 پر دھکیل کر منتقل کرتا ہے۔اگر قطار خالی ہے ، غلط ہے تو ، IS_EMPTY () کا طریقہ درست لوٹتا ہے۔قطار سے ، اور چیک کرتا ہے کہ اگر قطار دوبارہ خالی ہے تو: پائیتھونکیو = قطار () قطار۔ enqueue (1) قطار۔ enqueue (2) قطار۔ enqueue (3) پرنٹ (قطار۔ ڈیکیو ()) # آؤٹ پٹ: 1 پرنٹ (قطار).dequeue ()) # آؤٹ پٹ: 2 پرنٹ (قطار.IS_EMPTY ()) # آؤٹ پٹ: غلط پرنٹ (قطار.ڈیکیو ()) # آؤٹ پٹ: 3 پرنٹ (قطار.IS_EMPTY ()) # آؤٹ پٹ: ٹروپنٹ (قطار.Dequeue ()) #آؤٹ پٹ: کوئی نتیجہ نہیں ، ہم مذکورہ بالا الگورتھم کا استعمال کرکے دو اسٹیکس کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کو نافذ کرسکتے ہیں۔دونوں ڈھیروں کو قطار کے طرز عمل کی نقالی کرنے کے لئے استعمال کیا جاتا ہے ، ایک اسٹیک کے ساتھ عناصر کو ترتیب دینے کے لئے استعمال کیا جاتا ہے جس کی ترتیب میں وہ ان کو تیار کیا جاتا تھا ، اور دوسرا اسٹیک عناصر کو ترتیب میں محفوظ کرنے کے لئے استعمال ہوتا ہے جس کی وجہ سے وہ اس کو ختم کردیں گے۔جب کسی عنصر کو منسلک کیا جاتا ہے تو ، اسے پہلے اسٹیک پر دھکیل دیا جاتا ہے۔جب کسی عنصر کو کم کیا جاتا ہے ، اگر دوسرا اسٹیک خالی نہیں ہے تو ، اوپر عنصر دوسرے اسٹیک سے پاپ ہوجاتا ہے اور واپس ہوجاتا ہے۔بصورت دیگر ، تمام عناصر کو پہلے اسٹیک سے دوسرے اسٹیک میں منتقل کیا جاتا ہے ، اور پھر ٹاپ عنصر کو دوسرے اسٹیک سے پاپ کیا جاتا ہے اور واپس کردیا جاتا ہے۔"
    },
    {
        "Question": "الفاظ کی ترتیب کو تار میں الٹا کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "الفاظ کی ترتیب کو تار میں تبدیل کرنے کے ل we ، ہم مندرجہ ذیل الگورتھم کا استعمال کرسکتے ہیں: تار کو ڈیمیمیٹر (جیسے ، جگہ) کا استعمال کرتے ہوئے الفاظ میں تقسیم کریں۔ الفاظ کی ترتیب کو دیکھیں۔ الفاظ کو ایک ساتھ مل کر ایک ہی حدود کا استعمال کرتے ہوئے۔ایک فنکشن کا ازگر عمل درآمد جو تار میں الفاظ کی ترتیب کو تبدیل کرتا ہے: پائیتھونڈف ریورس_ ورڈز (سٹرنگ): الفاظ = سٹرنگ.سپلٹ () الفاظ۔کوڈفورون پر \"الٹ_سٹرنگ = ریورس_ ورڈز (سٹرنگ) پرنٹ (الٹ_سٹرنگ) # آؤٹ پٹ:\" اس پر عمل درآمد میں \"پروگرامنگ لرننگ لرننگ لیو I\" میں کوڈفورون \"، ریورس_ورڈز () فنکشن ان پٹ کے طور پر ایک تار تار کرتا ہے اور الفاظ کے آرڈر کے ساتھ ایک نیا تار واپس کرتا ہے۔الٹفنکشن اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے ان پٹ سٹرنگ کو الفاظ میں تقسیم کرتا ہے ، ریورس () طریقہ کار کا استعمال کرتے ہوئے الفاظ کی نتیجے میں فہرست کی ترتیب کو تبدیل کرتا ہے ، اور جوائن () کے طریقہ کار کا استعمال کرتے ہوئے ایک ساتھ مل کر الفاظ میں شامل ہوتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کے لئے ، مندرجہ ذیل کوڈایک تار تیار کرتا ہے ، اس کے الفاظ کی ترتیب کو تبدیل کرتا ہے ، اور اس کے نتیجے کو پرنٹ کرتا ہے: ازگراسٹرنگ = \"مجھے کوڈفورون میں پروگرامنگ سیکھنا پسند ہے\" الٹ_سٹرنگ = ریورس_ ورڈز (سٹرنگ) پرنٹ (الٹ_سٹرنگ) # آؤٹ پٹ: \"پروگرامنگ سیکھنے میں کوڈفورون\"ہم تار کو الفاظ میں تقسیم کرکے ، الفاظ کی فہرست کو تبدیل کرکے ، اور الفاظ کی فہرست کو تبدیل کرکے ، اور الفاظ کو ایک ساتھ شامل کرکے الفاظ کے ترتیب کو الٹ سکتے ہیں۔اس کو کسی فنکشن کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے جو ان پٹ کے طور پر تار لیتا ہے اور الٹ الفاظ کے آرڈر کے ساتھ ایک نیا تار واپس کرتا ہے۔"
    },
    {
        "Question": "کم سے کم میکس ہیپ ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "ایک من میکس کا ڈھیر ایک خصوصی بائنری ٹری ڈیٹا ڈھانچہ ہے جو ایک کم ہیپ اور زیادہ سے زیادہ ہیپ دونوں کی خصوصیات کو یکجا کرتا ہے۔یہ اس میں کم سے کم اور زیادہ سے زیادہ عناصر دونوں کو مستقل وقت کی بازیافت اور لوگرتھمک وقت کو ہٹانا فراہم کرتا ہے۔اس سے ڈبل اختتامی ترجیحی قطار کو نافذ کرنے کے لئے من میکس ہیپ کو ایک بہت ہی مفید ڈیٹا ڈھانچہ بناتا ہے۔بائنری من-ہیپس اور زیادہ سے زیادہ ہیپس کی طرح ، کم سے کم میکس ہیپس لوگرتھمک اندراج اور حذف کرنے کی حمایت کرتے ہیں اور لکیری وقت میں تعمیر کیے جاسکتے ہیں۔من میکس کے ڈھیروں کی اکثر سرے میں واضح طور پر نمائندگی کی جاتی ہے۔من میکس ہیپ پراپرٹی یہ ہے کہ درخت میں ایک بھی سطح پر ہر نوڈ اس کی تمام اولاد سے کم ہوتا ہے ، جبکہ درخت میں عجیب سطح پر ہر نوڈ اپنی تمام اولاد سے زیادہ ہوتا ہے۔ ایک کم سے کم میکس ڈھیر کو نافذ کرنے کے لئے۔، ہم ڈیٹا کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرسکتے ہیں۔ہم انڈیکس 1 سے ذخیرہ کرنا شروع کردیتے ہیں ، نہیں۔ پوزیشن I میں کسی بھی نوڈ کے لئے ، اس کا بائیں بچہ [2i] پر ہے اگر دستیاب ہو تو ، اس کا دائیں بچہ [2i+1] پر ہے تو [2i+1] ہے ، اور اس کا والدین نوڈ [i پر ہے۔/2] اگر دستیاب ہو۔بڑے پیمانے پر ہیپ میں تین آپریشنز ہیں: داخل کریں آپریشن (ٹائم پیچیدگی O (لاگ این)) ، حذف کریں آپریشن (ٹائم پیچیدگی O (لاگ این)) ، اور نکالنے والے آپریشن (وقت کی پیچیدگی O (لاگ این)) 2. اے منٹ ہیپ ایک ڈھیر ہےجہاں ہر ایک والدین نوڈ ، بشمول جڑ ، اپنے بچوں کے نوڈس کی قیمت سے کم یا اس کے برابر ہے۔ایک منٹ کے ڈھیر کی سب سے اہم پراپرٹی یہ ہے کہ چھوٹی ، یا کم سے کم قیمت والا نوڈ ہمیشہ جڑ کا نوڈ ہوگا۔ایک زیادہ سے زیادہ ڈھیر مؤثر طریقے سے ایک منٹ کے ڈھیر کی بات چیت ہے۔اس شکل میں ، ہر والدین نوڈ ، بشمول جڑ ، اپنے بچوں کے نوڈس کی قیمت سے زیادہ یا اس کے برابر ہے۔زیادہ سے زیادہ ڈھیر کی اہم جائیداد یہ ہے کہ سب سے بڑی ، یا زیادہ سے زیادہ قیمت والا نوڈ ہمیشہ جڑ نوڈ پر ہوگا۔دونوں قسم کے ڈھیر مختلف ایپلی کیشنز 234 میں کارآمد ہیں۔ اختتام پر ، ایک من میکس ہیپ ایک خاص بائنری ٹری ڈیٹا ڈھانچہ ہے جو ایک من چھپی اور زیادہ سے زیادہ ہیپ دونوں کی خصوصیات کو یکجا کرتا ہے۔یہ اس میں کم سے کم اور زیادہ سے زیادہ عناصر دونوں کو مستقل وقت کی بازیافت اور لوگرتھمک وقت کو ہٹانا فراہم کرتا ہے۔ہم ڈیٹا کو ذخیرہ کرنے اور داخل کرنے ، حذف کرنے ، اور نکالنے کے کام انجام دینے کے لئے ایک سرنی کا استعمال کرتے ہوئے ایک من میکس کے ڈھیر کو نافذ کرسکتے ہیں۔مزید برآں ، ہم مختلف ایپلی کیشنز کے لئے کم سے کم ڈھیر اور زیادہ سے زیادہ ڈھیر استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "دو ڈوروں کے مابین سب سے طویل عام حصول تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو ڈوروں کے مابین سب سے طویل مشترکہ حصول تلاش کرنے کے ل we ، ہم O (Mn) وقت میں مسئلے کو حل کرنے کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں ، جہاں M اور N دونوں تار کی لمبائی ہیں۔ہم دو جہتی سرنی ڈی پی سائز (M+1) x (n+1) تشکیل دے سکتے ہیں تاکہ دونوں ڈوروں کے تمام سابقوں کی لمبائی کی لمبائی کو ذخیرہ کیا جاسکے۔ڈی پی [i] [j] کی قدر پہلی سٹرنگ کے پہلے I حرفوں اور دوسرے تار کے پہلے جے حروف کے سب سے طویل عام مشترکہ حصے کی لمبائی کی نمائندگی کرتی ہے۔ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے سرنی ڈی پی کو پُر کرسکتے ہیں: ڈی پی [i] [j] = 0 اگر i = 0 یا j = 0dp [i] [j] = dp [i-1] [j-1] + 1اگر S1 [I-1] = S2 [J-1] DP [i] [J] = زیادہ سے زیادہ (DP [I-1] [J] ، DP [I] [J-1]) دوسرا پہلا معاملہ بنیاد کی نمائندگی کرتا ہےمعاملہ جہاں ایک ڈور خالی ہے ، اور سب سے طویل عام مشترکہ حصول کی لمبائی 0 ہے۔ دوسرا معاملہ اس معاملے کی نمائندگی کرتا ہے جہاں دونوں ڈوروں کے آخری حروف میچ ہوتے ہیں ، اور ہم اس کردار کو شامل کرکے سب سے طویل عام مشترکہ حصول کو بڑھا سکتے ہیں۔تیسرا معاملہ اس معاملے کی نمائندگی کرتا ہے جہاں دونوں ڈوروں کے آخری کردار مماثل نہیں ہیں ، اور ہمیں آخری کردار کے بغیر دو تار کے سابقہ کے دو طویل عرصے تک عام طور پر انتخاب کرنے کی ضرورت ہے۔ یہاں ایک فنکشن کا ازگر کا نفاذ ہے۔اس سے دو ڈوروں کے مابین سب سے طویل عرصے سے عام ملحق مل جاتا ہے: پائیتھنڈف طویل ترین_کومون_سوبسینس (ایس 1 ، ایس 2): ایم ، این = لین (ایس 1) ، لین (ایس 2) ڈی پی = [[0] * (این+1) رینج میں _ کے لئے (ایم+کے لئے (ایم+1)] میں رینج (1 ، ایم+1) کے لئے: رینج میں جے کے لئے (1 ، n+1): اگر S1 [I-1] == S2 [J-1]: ڈی پی [i] [j]عامi ، j = m ، n جبکہ i> 0 اور j> 0: اگر S1 [i-1] == s2 [J-1]: lcs = s1 [i-1] + lcs i-= 1 j-= 1ELIF DP [I -1] [J]> DP [I] [J -1]: i -= 1 اور: J -= 1 واپسی LCS# مثال کے استعمال 1 = \"ABCDGH\" S2 = \"AEDFHR\" LCS = طویل ترین_کومون_سوبسینس (S1.فنکشن ڈی پی سرنی کو پُر کرنے کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے ، اور پھر سب سے طویل عام مشترکہ حصول کی تعمیر کے لئے بیک ٹریک کا استعمال کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ دو تاروں کو تخلیق کرتا ہے ، ان کے مابین سب سے طویل مشترکہ ملحق پایا جاتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے: ازگر 1 = \"ABCDGH\"s2 = \"aedfhr\" lcs = طویل ترین_کومون_سوبسینس (S1 ، S2) پرنٹ (LCS) # آؤٹ پٹ: \"ADH\" نتیجہ میں ، ہم دو جہتی صفوں کو پُر کرنے کے لئے متحرک پروگرامنگ کا استعمال کرتے ہوئے دو تار کے درمیان سب سے طویل مشترکہ حصول تلاش کرسکتے ہیں جو اس کو اسٹور کرتا ہے۔دونوں تار کے تمام سابقہوں کے سب سے طویل عام مشترکہ حصے کی لمبائی۔اس کے بعد ہم سب سے طویل عام مشترکہ حصول کی تعمیر کے لئے بیک ٹریک کرسکتے ہیں۔اس کو ایک فنکشن کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے جو ان پٹ کے طور پر دو ڈور لیتا ہے اور ایک تار لوٹاتا ہے جو دو تار کے سب سے طویل عرصے سے عام حصول کی نمائندگی کرتا ہے۔"
    },
    {
        "Question": "ڈیجکسٹرا کے مختصر ترین راستے الگورتھم کو نافذ کریں۔",
        "Answer": "ڈجکسٹرا کا الگورتھم ایک مختصر ترین راستہ الگورتھم ہے جو گراف میں نوڈس کے مابین مختصر ترین راستوں کو تلاش کرنے کے لئے ڈیزائن کیا گیا تھا۔اس کا استعمال سنگل آؤٹ سورس نوڈ اور گراف کے دوسرے نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے کیا جاتا ہے۔الگورتھم نوڈس کا ایک سیٹ بنا کر کام کرتا ہے جس کا ماخذ سے کم سے کم فاصلہ ہوتا ہے۔الگورتھم شروع سے فاصلے پر ترتیب دیئے گئے جزوی حل کو ذخیرہ کرنے اور ان سے استفسار کرنے کے لئے ڈیٹا ڈھانچہ استعمال کرتا ہے۔ڈیجکسٹرا کا اصل الگورتھم کم سے کم ترجیحی قطار کا استعمال نہیں کرتا ہے اور وقت پر چلتا ہے (جہاں نوڈس کی تعداد ہے) 12. ڈجکسٹرا کے الگورتھم کو نافذ کرنے کے لئے ، ہم ان نوڈس کو ذخیرہ کرنے کے لئے ترجیحی قطار استعمال کرسکتے ہیں جو ابھی تک نہیں گئے ہیں ، ان کے ذریعہ ترتیب دیئے گئے ہیں ، ان کے مطابق ترتیب دیئے گئے ہیں ، ان کے ذریعہ ترتیب دیئے گئے ہیں۔ماخذ نوڈ سے فاصلہ۔ہم ماخذ نوڈ کے فاصلے کو 0 اور دوسرے تمام نوڈس کے فاصلے کو انفینٹی تک شروع کرکے شروع کرتے ہیں۔اس کے بعد ہم ماخذ نوڈ سے سب سے کم فاصلے کے ساتھ نوڈ کا دورہ کرتے ہیں اور اس کے پڑوسیوں کے فاصلوں کو اپ ڈیٹ کرتے ہیں۔ہم اس عمل کو اس وقت تک دہراتے ہیں جب تک کہ ہم تمام نوڈس کا دورہ نہ کریں یا جب تک کہ منزل کا نوڈ نہ ہوجائے۔ہم پچھلے نوڈ کو پاتھ 34 میں اسٹور کرکے ماخذ نوڈ سے لے کر ہر نوڈ تک مختصر ترین راستے پر بھی نظر رکھ سکتے ہیں۔ جہاں ڈیجکسٹرا کے الگورتھم کا ایک ازگر عمل درآمد ہے: پائیتھونیمپورٹ ہیپکیڈف ڈجکسٹرا (گراف ، ماخذ ، منزل): فاصلوں = {نوڈ: فلوٹ('INF') گراف میں نوڈ کے لئے} فاصلوں [ماخذ] = 0 قطار = [(0 ، ماخذ)] پچھلی_نوڈس = {نوڈ: گراف میں نوڈ کے لئے کوئی بھی نہیں جبکہ قطار میں: موجودہ_ڈیسٹینس ، کرنٹ_نوڈ = ہیپ کیو.اپپپ (قطار) اگر اگرموجودہ_ڈسٹنس> دوری [موجودہ_نوڈ]: اگر موجودہ_نوڈ == منزل: راستہ = [] جاری رکھیں جبکہ پچھلی_نوڈس [موجودہ_نوڈ] کوئی بھی نہیں ہے: پاتھ.ایپینڈ (کرنٹ_نوڈ) موجودہ_نوڈ = پچھلی_نوڈس [موجودہ_نوڈ] راستہ۔ اے پی پیینڈ (ماخذ) پاتھ۔ ریورس () ()پڑوسی کے لئے راستہ ، گراف میں وزن [موجودہ_نوڈ]. آئٹمز (): فاصلہ = موجودہ_ڈسٹینس + وزن اگر فاصلہ <فاصلوں [پڑوسی]: فاصلے [پڑوسی] = فاصلہ پچھلا_نوڈس [پڑوسی] = موجودہ_نوڈ ہیپ کیو۔ ہیپش (قطار ، (فاصلہ ، (فاصلہ ، (فاصلہ ،پڑوسی)) کوئی بھی نہیں# مثال استعمال گراف = {'A': {'B': 2 ، 'C': 3} ، 'B': {'A': 2 ، 'C': 1 ، 'D': 1} ، 'C': {'A': 3 ، 'B': 1 ، 'D': 4} ، 'D': {'B': 1 ، 'C': 4}} ماخذ = 'a'destination= 'd'apath = DijkStra (گراف ، ماخذ ، منزل) پرنٹ (راستہ) # آؤٹ پٹ: [' a '،' b '،' d '] اس نفاذ میں ، ڈجکسٹرا () فنکشن ایک گراف لیتا ہے جس کی نمائندگی ایک لغت کے طور پر کی جاتی ہے۔لغات کی ، ایک ماخذ نوڈ ، اور منزل مقصود نوڈ ان پٹ کے طور پر اور ایک ایسی فہرست لوٹاتا ہے جو ماخذ نوڈ سے منزل نوڈ تک مختصر ترین راستے کی نمائندگی کرتا ہے۔فنکشن تمام نوڈس کے فاصلوں کو انفینٹی سے شروع کرتا ہے سوائے سورس نوڈ کے ، جو 0 سے شروع کیا جاتا ہے۔یہ ماخذ نوڈ سے ہر نوڈ تک مختصر ترین راستے میں پچھلے نوڈ کو بھی ٹریک کرتا ہے۔فنکشن سورس نوڈ سے سب سے کم فاصلے کے ساتھ نوڈ کا دورہ کرتا ہے اور اپنے پڑوسیوں کے فاصلے کو اپ ڈیٹ کرتا ہے۔یہ اس عمل کو دہراتا ہے جب تک کہ اس نے تمام نوڈس کا دورہ نہ کیا ہو یا جب تک کہ منزل کا نوڈ نہ ہوجائے۔آخر میں ، یہ راستے میں پچھلے نوڈ کا استعمال کرتے ہوئے منزل نوڈ سے ماخذ نوڈ تک بیک ٹریک کرکے ماخذ نوڈ سے منزل نوڈ تک مختصر ترین راستہ بناتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک گراف بناتا ہے ، دو نوڈس کے مابین مختصر ترین راستہ تلاش کرتا ہےڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے ، اور اس کا نتیجہ پرنٹ کرتا ہے: پائیتھنگ گراف = {'A': {'B': 2 ، 'C': 3} ، 'B': {'A': 2 ، 'C': 1 ، 'D'.'منزل =' d'apath = DijkStra (گراف ، ماخذ ، منزل) پرنٹ (راستہ) # آؤٹ پٹ: ['a' ، 'b' ، 'd'] اختتام میں ، ہم ذخیرہ کرنے کے لئے ترجیحی قطار کا استعمال کرتے ہوئے ڈجکسٹرا کے الگورتھم کو نافذ کرسکتے ہیں۔نوڈس جن کا ابھی تک نہیں ملا ہے ، ماخذ نوڈ سے ان کے فاصلے سے ترتیب دیا گیا ہے۔ہم تمام نوڈس کے فاصلوں کو انفینٹی سے شروع کرسکتے ہیں سوائے سورس نوڈ کے ، جو شروع کیا جاتا ہے۔ہم اس عمل کو اس وقت تک دہراتے ہیں جب تک کہ ہم تمام نوڈس کا دورہ نہ کریں یا جب تک کہ منزل کا نوڈ نہ ہوجائے۔ہم ماخذ نوڈ سے لے کر ہر نوڈ تک پچھلے حصے کو ذخیرہ کرکے بھی مختصر ترین راستے سے باخبر رہ سکتے ہیں"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کے وسط تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دو ترتیب شدہ صفوں کے وسط کو تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ دونوں صفوں کو ایک ہی ترتیب شدہ صف میں ضم کریں اور پھر انضمام شدہ صف کا وسط تلاش کریں۔ایک اور نقطہ نظر یہ ہے کہ دونوں صفوں کے وسط کو براہ راست تلاش کرنے کے لئے بائنری سرچ کا استعمال کیا جائے۔ پہلے نقطہ نظر میں دونوں ترتیب شدہ صفوں کو ایک ہی ترتیب شدہ صف میں ضم کرنا اور پھر انضمام شدہ صف کا میڈین تلاش کرنا شامل ہے۔یہ سائز M+N کی ایک نئی صف تشکیل دے کر کیا جاسکتا ہے ، جہاں ایم اور این دونوں صفوں کی لمبائی ہیں ، اور پھر دونوں صفوں کو نئی صف میں ضم کرکے۔اس کے بعد ہم درمیانی دو عناصر کی اوسط کو لے کر انضمام شدہ صف کا درمیانی حصہ تلاش کرسکتے ہیں اگر انضمام شدہ صف کی کل لمبائی برابر ہے ، یا درمیانی عنصر کو لے کر اگر کل لمبائی عجیب ہے۔اس نقطہ نظر میں O (M+N) کی وقت کی پیچیدگی اور O (M+N) کی خلائی پیچیدگی 12. دوسرے نقطہ نظر میں براہ راست دونوں صفوں کے وسط کو تلاش کرنے کے لئے بائنری سرچ کا استعمال کرنا شامل ہے۔ہم دونوں صفوں کو ایک مخصوص انڈیکس I اور J پر دو حصوں میں تقسیم کرکے شروع کرسکتے ہیں ، جیسے دونوں صفوں کے بائیں نصف حصے میں موجود تمام عناصر دائیں نصف حصے میں موجود تمام عناصر سے چھوٹے ہیں۔اس کے بعد ہم دونوں حصوں کے درمیانی عناصر کے موازنہ کی بنیاد پر پارٹیشن انڈیکس I اور J کو ایڈجسٹ کرسکتے ہیں۔اگر دونوں صفوں کا میڈین درمیانی دو عناصر کی اوسط ہے تو ، ہم درمیانی حصوں کو زیادہ سے زیادہ بائیں حصوں اور کم سے کم دائیں حصوں کو لے کر تلاش کرسکتے ہیں۔اس نقطہ نظر میں O (لاگ (منٹ (M ، N))) کی ایک وقت کی پیچیدگی ہے اور O (1) 12 کی خلائی پیچیدگی ہے۔nums1)> len (nums2): nums1 ، nums2 = nums2 ، nums1 m ، n = len (nums1) ، len (nums2) imin ، imax ، نصف_لن = 0 ، m ، (m + n + 1) // 2 جبکہ imin<= imax: i = (imin + imax) // 2 j = نصف_لین- i اگر میں <m اور nums2 [j-1]> nums1 [i]: imin = i + 1 alif i> 0 اور nums1 [i-1]> nums2 [j]: imax = i-1 اور: if i == 0: max_left = nums2 [j-1] elif j == 0: max_left = nums1 [i-1] else: max_left = زیادہ سے زیادہ (nums1۔] اور: Min_right = min (nums1 [i] ، nums2 [j]) واپسی (میکس_ لیفٹ + منٹ_ رائٹ) / 2# مثال usagenums1 = [1 ، 3] nums2 = [2] میڈین = find_median_sorted_arrays (nums1 ، nums2) پرنٹ (میڈین) پرنٹ (میڈین) # آؤٹ پٹ: 2.0 اس پر عمل درآمد میں ، find_median_sorted_arrays () فنکشن ان پٹ کے طور پر دو ترتیب شدہ اریوں نمبر 1 اور نمبر 2 لیتا ہے اور ان دونوں صفوں کے میڈین کو واپس کرتا ہے۔فنکشن دو حصوں میں تقسیم کرنے کے لئے بائنری تلاش کا استعمال کرتا ہے اور پھر دونوں حصوں کے درمیانی عناصر کے موازنہ کی بنیاد پر پارٹیشن انڈیکس کو ایڈجسٹ کرتا ہے۔اس کے بعد یہ دونوں صفوں کے میڈین کی گنتی زیادہ سے زیادہ بائیں حصوں اور دائیں حصوں کی کم سے کم کی بنیاد پر کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ دو ترتیب دیئے ہوئے صفوں کو تخلیق کرتا ہے ، find_median_sorted_arrays () فنکشن کا استعمال کرتے ہوئے دو صفوں کا میڈین تلاش کرتا ہے ،اور اس کا نتیجہ پرنٹ کرتا ہے: پائیتھونومومس 1 = [1 ، 3] نمبر 2 = [2] میڈین = تلاش_میڈین_سورٹڈ_آریز (نمبر 1 ، نمبر 2) پرنٹ (میڈین) پرنٹ (میڈین) # آؤٹ پٹ: 2.0in اختتام ، ہم دو طریقوں کا استعمال کرتے ہوئے دو ترتیب شدہ صفوں کا میڈین تلاش کرسکتے ہیں: ضمدونوں صفوں میں ایک ہی ترتیب شدہ صف میں اور پھر انضمام شدہ سرنی کا درمیانی درپیش ، یا براہ راست دونوں صفوں کے وسط کو تلاش کرنے کے لئے بائنری سرچ کا استعمال کرتے ہوئے تلاش کریں۔دوسرے نقطہ نظر میں پہلے نقطہ نظر سے بہتر وقت کی پیچیدگی اور خلائی پیچیدگی ہوتی ہے۔اس کو ایک فنکشن کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے جو دو ترتیب شدہ صفوں کو ان پٹ کے طور پر لیتا ہے اور دو صفوں کے میڈین کو واپس کرتا ہے۔"
    },
    {
        "Question": "خود توازن رکھنے والے AVL درخت کو نافذ کریں۔",
        "Answer": "اے وی ایل کے درخت بائنری سرچ کے درختوں کو خود توازن دیتے ہیں جو درخت کی اونچائی کو خود بخود کم سے کم رکھتے ہیں جب درخت پر اندراج اور حذف کرنے کی کارروائی کی جاتی ہے۔اے وی ایل کے درخت کی اونچائی عام طور پر لاگ ان کی ترتیب میں برقرار رہتی ہے تاکہ تمام کاروائیاں اوسطا 12 پر O (لاگ این) کا وقت لگائیں۔ اے وی ایل کے درخت کو نافذ کرنے کے ل we ، ہمیں ایک نوڈ ڈھانچے کی وضاحت کرنے کی ضرورت ہے جس میں اعداد و شمار موجود ہوں ، بائیں اور دائیں طرف اشارہ کریں۔بچے ، اور نوڈ کی اونچائی۔ہمیں بائنری سرچ درخت کی بنیادی کارروائیوں کی بھی وضاحت کرنے کی ضرورت ہے ، جیسے اندراج ، حذف کرنا ، اور تلاش کرنا۔اس کے علاوہ ، ہمیں توازن کی کارروائیوں کو نافذ کرنے کی ضرورت ہے جو درخت کی اونچائی کے توازن کو برقرار رکھیں۔توازن کی کارروائیوں میں بائیں اور دائیں گردشوں کے ساتھ ساتھ دو ڈبل گردشیں شامل ہیں جو درختوں کو متوازن کرنے کے لئے دو گردشوں کو جوڑتی ہیں۔ ایک AVL درخت کا ازگر کا نفاذ: ازگرکلاس نوڈ: Def __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔بائیں = کوئی بھی نہیں.. رائٹ ، ڈیٹا) نوڈ.ہائٹ = 1 + زیادہ سے زیادہ (سیلف ۔_ہائٹ (نوڈ۔ لیفٹ) ، سیلف۔ڈیٹا: واپس لوٹائیں۔(node.left) سیلف۔خود ، ڈیٹا): سیلف.روٹ = سیلف ۔_ ڈیلیٹ (سیلف.روٹ ، ڈیٹا) ڈیف _ ڈیلیٹ (خود ، نوڈ ، ڈیٹا): اگر نوڈ کوئی نہیں ہے: نوڈ الیف ڈیٹا <نوڈ.ڈیٹا: نوڈ.لفٹ = سیلف_ڈیلیٹ.حق کوئی نہیں ہے: temp = node.left نوڈ = کوئی بھی نہیں لوٹنے والا عارضی temp = self._min_value_nodکوئی نہیں: واپس نوڈ نوڈ۔ ہائٹ = 1 + زیادہ سے زیادہ (سیلف ۔_ہائٹ (نوڈ۔ لیفٹ) ، سیلف۔)> = 0: خود کو لوٹائیں۔<0.) سیلف۔: نوڈ ایلف ڈیٹا <نوڈ ڈاٹ ڈیٹا واپس کریں: خود کو واپس کریں۔: واپسی نوڈ۔ ہائٹ ڈیف _ بیلنس (خود ، نوڈ): اگر نوڈ کوئی نہیں ہے: واپس 0 اور: واپس کریں۔node.left دائیں_گراینڈچائلڈ = بائیں_ڈائلڈ۔زیادہ سے زیادہ (سیلف۔node.height = 1 + زیادہ سے زیادہ (سیلف ۔_ہائٹ (نوڈ. لیفٹ) ، سیلف۔)) رائٹ_چڈ ڈیف _Min_value_node (خود ، نوڈ): موجودہ = نوڈ جبکہ موجودہ۔"
    },
    {
        "Question": "بائنری درخت پر آرڈر میں درختوں کی سیر کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "انڈر آرڈر ٹری ٹریورسل ایک قسم کا بائنری ٹری ٹراورسل ہے جو بائیں سب ٹری ، پھر موجودہ نوڈ ، اور آخر میں دائیں سب ٹری کا دورہ کرتا ہے۔اس ٹریورسل طریقہ کو چڑھتے ہوئے ترتیب میں بائنری درخت کے تمام نوڈس کو دیکھنے کے لئے استعمال کیا جاتا ہے۔بار بار آرڈر ٹراورسل کو تکرار یا تکرار کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ یہاں ازگر میں آرڈر کے درختوں کی ٹریورسل کا ایک مثال عمل: ازگر کلاس نوڈ: ڈیف __init __ (خود ، ویل): سیلف۔ وال = ویل سیلف۔نان ڈیف انڈرڈر_ٹراورسال (جڑ): اگر جڑ کوئی نہیں ہے: اس عمل میں نوڈ کلاس بائنری درخت میں نوڈ کی ساخت کی وضاحت کرتا ہے ، جس میں نوڈ کلاس بائنری درخت میں نوڈ کی ساخت کی وضاحت کرتا ہے۔نوڈ کی قدر ، اور بائیں اور دائیں بچوں کی طرف اشارہ۔inorder_traversal () فنکشن بائنری ٹری کی جڑ نوڈ کو ان پٹ کے طور پر لیتا ہے اور بائنری ٹری کے بار بار بار آرڈر ٹراورسل کو انجام دیتا ہے۔فنکشن سب سے پہلے جانچ پڑتال کرتا ہے کہ آیا روٹ نوڈ کوئی نہیں ہے ، اور اگر نہیں تو ، یہ بار بار اپنے آپ کو بائیں سب ٹری پر کال کرتا ہے ، پھر موجودہ نوڈ کی قیمت کو پرنٹ کرتا ہے ، اور آخر کار خود کو دائیں سب ٹری پر کال کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ تخلیق کرتا ہے۔ایک بائنری درخت ، انڈرڈر_ٹراورسل () فنکشن کا استعمال کرتے ہوئے درخت کے آرڈر میں ٹراورسل انجام دیتا ہے ، اور نوڈس کی اقدار کو چڑھائی ترتیب میں پرنٹ کرتا ہے: پائیٹونروٹ = نوڈ (5) روٹ۔ لیفٹ = نوڈ (3) روٹ۔ رائٹ = نوڈ (روٹ = نوڈ (7) روٹ. لیفٹ۔ لیفٹ = نوڈ (1) روٹ۔ لیفٹ۔ رائٹ = نوڈ (4) روٹ۔ رائٹ.لیفٹ = نوڈ (6) روٹ۔ رائٹ۔ رائٹ = نوڈ (8) inorder_traversal (جڑ) اس کی پیداوار ہوگی۔1345678in نتیجہ ، انڈر آرڈر ٹری ٹریورسل بائنری ٹری ٹریورسل کی ایک قسم ہے جو بائیں سب ٹری ، پھر موجودہ نوڈ ، اور آخر میں دائیں سب ٹری کا دورہ کرتی ہے۔اس ٹریورسل طریقہ کو چڑھتے ہوئے ترتیب میں بائنری درخت کے تمام نوڈس کو دیکھنے کے لئے استعمال کیا جاتا ہے۔ریسرچ یا تکرار کا استعمال کرتے ہوئے آرڈر میں ٹریورسل کو نافذ کیا جاسکتا ہے"
    },
    {
        "Question": "بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک بلوم فلٹر ایک خلائی موثر امکانی اعداد و شمار کا ڈھانچہ ہے جو یہ جانچنے کے لئے استعمال ہوتا ہے کہ آیا عنصر کسی سیٹ کا ممبر ہے یا نہیں۔یہ تیزی سے اور میموری کو موثر طریقے سے بتا سکتا ہے کہ آیا کوئی عنصر کسی سیٹ میں موجود ہے یا نہیں۔تجارت یہ ہے کہ اس کے نتیجے میں غلط مثبتات پیدا ہوسکتے ہیں ، مطلب یہ بتا سکتا ہے کہ جب کوئی عنصر سیٹ میں موجود ہوتا ہے جب وہ نہیں ہوتا ہے۔بلوم فلٹرز ڈیٹا آئٹم کو بالکل بھی محفوظ نہیں کرتے ہیں۔اس کے بجائے ، وہ تھوڑا سا سرنی استعمال کرتے ہیں جو ہیش کے تصادم کی اجازت دیتا ہے۔بلوم فلٹرز میں استعمال ہونے والے ہیش فنکشن کا انتخاب آزاد اور یکساں طور پر تقسیم ہونا چاہئے۔انہیں بھی جتنا ممکن ہو تیز ہونا چاہئے۔تیز ، آسان ، غیر کرپٹوگرافک ہیشوں میں جو کافی آزاد ہیں ان میں گنگناہٹ ، ہیش فنکشنز کی ایف این وی سیریز ، اور جینکنز ہیشیس 12 شامل ہیں۔ بلوم فلٹر کو نافذ کرنے کے لئے ، ہمیں فلٹر کی ساخت ، ہیش کے افعال کو استعمال کرنے کی ضرورت ہے ، اورفلٹر کی بنیادی کاروائیاں۔فلٹر کی ساخت عام طور پر سائز میٹر کی تھوڑی سی صف ہوتی ہے ، جہاں ایم فلٹر میں بٹس کی تعداد ہوتی ہے۔ہیش کے افعال کو ان پٹ ڈیٹا کو فلٹر میں K بٹس کے ایک سیٹ پر نقشہ بنانے کے لئے استعمال کیا جاتا ہے۔فلٹر کی بنیادی کارروائیوں میں اندراج اور ممبرشپ کی جانچ شامل ہے۔فلٹر میں عنصر داخل کرنے کے ل we ، ہم ہیش کے افعال کو عنصر پر لاگو کرتے ہیں اور فلٹر میں اسی طرح کے بٹس مرتب کرتے ہیں۔فلٹر میں کسی عنصر کی رکنیت کی جانچ کے ل we ، ہم ہیش کے افعال کو عنصر پر لاگو کرتے ہیں اور چیک کرتے ہیں کہ آیا فلٹر میں متعلقہ تمام بٹس سیٹ ہیں یا نہیں۔اگر کوئی بٹس سیٹ نہیں ہے تو ، عنصر یقینی طور پر سیٹ میں نہیں ہے۔اگر تمام بٹس مرتب کیے گئے ہیں تو ، عنصر شاید سیٹ 132 میں ہے۔ یہاں ازگر میں ایک بلوم فلٹر کی ایک مثال کے طور پر عمل درآمد: پائیتھونیمپورٹ ایم ایم ایچ 3 فریم بِٹ رے امپورٹ بٹلری کلاس بلوم فلٹر: ڈیف __init __ (خود ، سائز ، ہیش_کونٹ): خود۔ سائز = سائز = سائز۔ہیش_کاؤنٹ = ہیش_کاؤنٹ سیلف۔ بٹ_ری = بٹیرے (سائز) سیلف۔ بٹ_آرے۔ سیٹال (0) ڈیف شامل کریں (خود ، آئٹم): حد میں بیج کے لئے (سیلف۔ ہش_کاؤنٹ): انڈیکس = ایم ایم ایچ 3. ہش (آئٹم ، بیج) ٪ خود۔size self.bit_array [index] = 1 def __ contains __ (خود ، آئٹم): حد میں بیج کے لئے (خود. hash_count): انڈیکس = mmh3.hash (آئٹم ، بیج) ٪ خود.0: غلط ریٹرن ریٹرن سچے اس عمل کو ، بلوم فلٹر کلاس فلٹر کی ساخت کی وضاحت کرتا ہے ، جس میں فلٹر کا سائز ، استعمال ہونے والے ہیش افعال کی تعداد ، اور تھوڑا سا صف جو فلٹر کی نمائندگی کرتا ہے۔کلاس فلٹر کی بنیادی کارروائیوں کی بھی وضاحت کرتی ہے ، جس میں اندراج اور ممبرشپ کی جانچ بھی شامل ہے۔ADD () طریقہ کسی شے کو ان پٹ کے طور پر لیتا ہے ، ہیش کے افعال کو آئٹم پر لاگو کرتا ہے ، اور فلٹر میں اسی طرح کے بٹس طے کرتا ہے۔__ contains __ () کا طریقہ کسی شے کو ان پٹ کے طور پر لیتا ہے ، ہیش کے افعال کو آئٹم پر لاگو کرتا ہے ، اور چیک کرتا ہے کہ اگر فلٹر میں متعلقہ تمام بٹس مرتب کیے گئے ہیں۔اگر بٹس میں سے کوئی بھی سیٹ نہیں ہے تو ، آئٹم یقینی طور پر سیٹ میں نہیں ہے۔اگر تمام بٹس سیٹ کیے گئے ہیں تو ، شے شاید سیٹ میں ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک بلوم فلٹر بناتا ہے ، فلٹر میں کچھ اشیاء شامل کرتا ہے ، اور کچھ اشیاء کی رکنیت کے لئے ٹیسٹ کرتا ہے: پائیٹونبف = بلومفلٹر (100 ، 3) بی ایف.add (\"ایپل\") bf.add (\"کیلے\") bf.add (\"چیری\") پرنٹ (\"ایپل\" BF میں) # آؤٹ پٹ: ٹروپنٹ (\"کیلے\" BF میں) # آؤٹ پٹ: سچ پرنٹ (\"اورنج\"BF میں) # آؤٹ پٹ: فالسیتس آؤٹ پٹ: ٹریوٹریفالسن نتیجہ ، ایک بلوم فلٹر ایک خلائی موثر امکانی اعداد و شمار کا ڈھانچہ ہے جو جانچنے کے لئے استعمال ہوتا ہے کہ آیا عنصر کسی سیٹ کا ممبر ہے یا نہیں۔یہ تیزی سے اور میموری کو موثر طریقے سے بتا سکتا ہے کہ آیا کوئی عنصر کسی سیٹ میں موجود ہے یا نہیں۔بلوم فلٹر کو نافذ کرنے کے ل we ، ہمیں فلٹر کی ساخت ، ہیش کے افعال کو استعمال کرنے اور فلٹر کی بنیادی کارروائیوں کی وضاحت کرنے کی ضرورت ہے۔اس کو ایک کلاس کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے جو فلٹر کی ساخت اور بنیادی کارروائیوں کی وضاحت کرتا ہے۔"
    },
    {
        "Question": "دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی دیئے گئے تار کے تمام اجازت نامے پیدا کرنے کے ل we ، ہم تکرار یا تکرار کا استعمال کرسکتے ہیں۔بنیادی خیال یہ ہے کہ ہر دوسرے کردار کے ساتھ تار کے ہر کردار کو تبدیل کرنا ہے تاکہ ہر ممکنہ اجازت نامے پیدا ہوں۔ازگر میں دیئے گئے تار کے تمام تعی .ن پیدا کرنے کی یہاں دو مثالیں ہیں: تکرار کا استعمال کرتے ہوئے: پیتھنڈف پرمٹیشن (سٹرنگ ، مرحلہ = 0): اگر قدم == لین (سٹرنگ): # ہم نے اختتام کو پہنچا دیا ہے ، اجازت نامے پرنٹ کریں۔پرنٹ (\"\". شامل ہوں (سٹرنگ)) I میں I (مرحلہ ، لین (سٹرنگ)) کے لئے: # سٹرنگ (اسٹور کے طور پر اسٹور کریں) سٹرنگ_کوپی = [C کے لئے C کو کاپی کریں][مرحلہ] ، سٹرنگ_کوپی [i] = string_copy [i] ، string_copy [مرحلہ] # اس تار کے اس حصے پر بازیافت کریں جو ابھی تک نہیں تبدیل ہوا ہے (سٹرنگ_ کوپی ، مرحلہ + 1) # مثال کے استعمال (\"ABC\")عمل درآمد ، پرمٹیشن () فنکشن ان پٹ اور ایک مرحلہ پیرامیٹر کے طور پر ایک تار لیتا ہے جو سٹرنگ کے موجودہ انڈیکس پر نظر رکھتا ہے۔اگر مرحلہ پیرامیٹر تار کی لمبائی کے برابر ہے تو ، ہم نے ایک ترتیب تیار کیا ہے اور اسے پرنٹ کیا ہے۔بصورت دیگر ، ہم اسٹرنگ کے ذریعے لوپ کرتے ہیں اور موجودہ انڈیکس کو مرحلہ کے ساتھ تبدیل کرتے ہیں ، پھر تاروں کے اس حصے پر جو ابھی تک تبدیل نہیں ہوئے ہیں اس پر بار بار تعل .ق () کو کال کریں۔''. join (p) prmutations میں p کے لئے (سٹرنگ)] ریٹرن پرمز# مثال کے استعمال میں استعمال میں (\"ABC\") پرنٹ (پرمز) پرنٹ (\"ABC\") پرنٹ (پرمز) ، all_permutations () فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اجازت نامہ استعمال کرتا ہے () تار کے ہر ممکنہ اجازت نامے پیدا کرنے کے لئے Itertools ماڈیول سے کام کریں۔پرمٹیشن () فنکشن ٹیپلس کے ایک تکرار کو لوٹاتا ہے ، لہذا ہم ٹولس کو ڈوروں میں شامل کرنے کے لئے ایک فہرست کی تفہیم کا استعمال کرتے ہیں۔ مثال کے طور پر ، مندرجہ ذیل کوڈ دونوں پر عمل درآمد کا استعمال کرتے ہوئے سٹرنگ \"اے بی سی\" کے تمام اجازت نامے تیار کرتا ہے: ازگر= all_permutations (\"ABC\") پرنٹ (پرمز) اس کی پیداوار ہوگی: ABCACBBACBCACBACAB ['ABC' ، 'ACB' ، 'BAC' ، 'BCA' ، 'CAB' ، 'CBA'] کے اختتام پر ، A کے تمام ترتیب تیار کرنے کے لئےتار دیئے گئے ، ہم تکرار یا تکرار کا استعمال کرسکتے ہیں۔بنیادی خیال یہ ہے کہ ہر دوسرے کردار کے ساتھ تار کے ہر کردار کو تبدیل کرنا ہے تاکہ ہر ممکنہ اجازت نامے پیدا ہوں۔ہم اس فنکشن کا استعمال کرتے ہوئے اس پر عمل درآمد کرسکتے ہیں جو ان پٹ کے طور پر تار لیتا ہے اور سٹرنگ کے تمام اجازت نامے تیار کرتا ہے۔"
    },
    {
        "Question": "سرخ سیاہ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "بائنری درخت پر پری آرڈر ٹری ٹریور کو انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "پری آرڈر ٹری ٹریورسل ایک قسم کی گہرائی کا پہلا ٹراورسل ہے جو پہلے جڑ کے نوڈ کا دورہ کرتا ہے ، اس کے بعد بائیں سب ٹری اور پھر دائیں سب ٹری کے بعد۔بائنری درخت پر پری آرڈر ٹراورسال انجام دینے کے ل we ، ہم تکرار یا تکرار کا استعمال کرسکتے ہیں۔ازگر میں پری آرڈر ٹراورسل کے دو مثال کے نفاذ: تکرار کا استعمال کرتے ہوئے: پائیتھنکلاس نوڈ: ڈیف __ __init __ (خود ، قدر): خود۔ ویلیو۔کوئی نہیں: پرنٹ (node.value) preoorder_traversal (node.left) preoorder_traversal (نوڈ. رائٹ)# مثال کے طور پر یوزیگروٹ = نوڈ (1) روٹ. لیفٹ = نوڈ (2) روٹ. رائٹ = نوڈ (3) روٹ.فٹ.یلفٹ= نوڈ (4) روٹ. لیفٹ. رائٹ = نوڈ (5) پری آرڈر_ٹراورسل (جڑ) اس عمل میں ، پری آرڈر_ٹراورسل () فنکشن ان پٹ کے طور پر ایک نوڈ لیتا ہے اور نوڈ کی قیمت کو پرنٹ کرتا ہے ، پھر بائیں طرف پری آرڈر_ٹراورال () کو بار بار پیش کرتا ہے۔اور دائیں سبٹریز۔ تکرار کا استعمال کرتے ہوئے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، قدر): خود۔ ویلیو = ویلیو سیلف۔نوڈ) جبکہ اسٹیک: نوڈ = اسٹیک.پوپ () اگر نوڈ کوئی نہیں ہے: نتیجہ۔ اپینڈ (نوڈ.والیو) اسٹیک.ایپینڈ (نوڈ. رائٹ) اسٹیک.ایپینڈ (نوڈ.لفٹ) واپسی کا نتیجہ# مثال یوزجیروٹ = نوڈ (نوڈ (نوڈ (نوڈ (1) روٹ.لفٹ = نوڈ (2) روٹ۔ رائٹ = نوڈ (3) روٹ۔ لیفٹ.لیفٹ = نوڈ (4) روٹ۔ لیفٹ. رائٹ = نوڈ (5) نتیجہ = پری آرڈر_ٹراورسل (جڑ) پرنٹ (نتیجہ) اس میں اس میںعمل درآمد ، پری آرڈر_ٹراورسل () فنکشن ان پٹ کے طور پر نوڈ لیتا ہے اور نوڈس کا دورہ کرنے کے لئے ٹریک کا استعمال کرتا ہے۔ہم اسٹیک پر جڑ کے نوڈ کو آگے بڑھا کر شروع کرتے ہیں۔پھر ، جب اسٹیک خالی نہیں ہے ، ہم اسٹیک سے ایک نوڈ پاپ کرتے ہیں ، اس کی قیمت کو نتائج کی فہرست میں شامل کرتے ہیں ، اور اس کے دائیں اور بائیں بچوں کو اسٹیک پر دھکیل دیتے ہیں۔ مثال کے طور پر ، مندرجہ ذیل کوڈ بائنری پر پری آرڈر ٹراورسل انجام دیتا ہے۔درخت دونوں پر عمل درآمد کا استعمال کرتے ہوئے: پائیتھونروٹ = نوڈ (1) روٹ۔ لیفٹ = نوڈ (2) روٹ۔ رائٹ = نوڈ (3) روٹ۔ لیفٹ۔ لیفٹ = نوڈ (4) جڑ۔) نتیجہ = پری آرڈر_ٹراورسل (جڑ) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 12453 [1 ، 2 ، 4 ، 5 ، 3] اختتام میں ، پری آرڈر ٹری ٹریورسل ایک قسم کی گہرائی کا پہلا سفر ہے جو پہلے جڑ کے نوڈ کا دورہ کرتا ہے ،اس کے بعد بائیں سب ٹری اور پھر دائیں سب ٹری کے بعد۔ہم اس فنکشن کا استعمال کرتے ہوئے اس پر عمل درآمد کرسکتے ہیں جو ان پٹ کے طور پر نوڈ لیتا ہے اور بائنری ٹری پر پری آرڈر ٹراورسل انجام دیتا ہے۔ہم پری آرڈر ٹریورسل کو انجام دینے کے لئے تکرار یا تکرار کا استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "ایک ناگوار سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک ناگوار سیٹ ڈیٹا ڈھانچہ ، جسے یونین فٹ ڈیٹا ڈھانچہ بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو کئی ناگوار (غیر اوورلیپنگ) سبسیٹس میں تقسیم شدہ عناصر کے ایک سیٹ پر نظر رکھتا ہے۔یہ مندرجہ ذیل کارروائیوں کی حمایت کرتا ہے: ناپسندیدہ سیٹ میں نئے سیٹ شامل کرنا۔سیٹ ڈیٹا ڈھانچہ ان مسائل کو حل کرنے میں مفید ہے جس میں ایک سیٹ کو ناپسندیدہ ذیلی سیٹوں میں تقسیم کرنا اور ان سب سیٹوں پر کام انجام دینا شامل ہے۔متنازعہ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کا ایک طریقہ یہ ہے کہ ہر سیٹ کی نمائندگی کسی لنکڈ فہرست کے ذریعہ کی جائے۔سیٹ میں ہر عنصر ایک منسلک فہرست میں ہوتا ہے اور اس میں سیٹ میں اگلے عنصر کا ایک پوائنٹر اور سیٹ کے نمائندے کا دوسرا پوائنٹر ہوتا ہے۔متنازعہ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کا ایک اور طریقہ یہ ہے کہ جڑوں والے درختوں کے ذریعہ سیٹوں کی نمائندگی کی جائے ، جس میں ہر نوڈ میں ایک عنصر ہوتا ہے اور ہر درخت ایک سیٹ کی نمائندگی کرتا ہے۔ہر عنصر صرف اپنے والدین کی طرف اشارہ کرتا ہے ، اور ہر درخت کی جڑ اس سیٹ اور اس کے اپنے والدین کا نمائندہ ہوتی ہے۔ ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچہ مندرجہ ذیل کارروائیوں کی حمایت کرتا ہے: میک سیٹ (یو): سنگل پر مشتمل ایک نیا سیٹ تشکیل دیتا ہے جس میں سنگل پر مشتمل ایک نیا سیٹ تیار کرتا ہےعنصر U.FIND (U): اس سیٹ کے نمائندے کو واپس کرتا ہے جس میں U.union (U ، V) شامل ہوتا ہے: U اور V پر مشتمل سیٹوں کو ایک ہی سیٹ میں ضم کرتا ہے۔ تلاش کی آپریشن اس بات کا تعین کرنے کے لئے استعمال ہوتا ہے کہ ایک خاص عنصر کس سب سیٹ ہےاس میں اور اس کا تعین کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا دو عناصر ایک ہی سب سیٹ میں ہیں۔یونین آپریشن کو ایک ہی سبسیٹ میں دو ذیلی سیٹوں میں شامل کرنے کے لئے استعمال کیا جاتا ہے۔این ڈس ڈیسپینٹ سیٹ بنانے کی وقت کی پیچیدگی O (n) ہے ، اور ان سیٹوں پر ایم فائنڈ اور یونین کی کارروائیوں کو انجام دینے کی وقت کی پیچیدگی O (M لاگ این) ہے جو یونین بائی رینک اور راہ کمپریشن ہورسٹکس ڈاٹ کام کا استعمال کرتے ہوئے ہے۔ایک ناگوار سیٹ ڈیٹا ڈھانچہ ایک ڈیٹا ڈھانچہ ہے جو عناصر کے ایک سیٹ پر نظر رکھتا ہے جو متعدد ناگوار ذیلی ذخیروں میں تقسیم ہوتا ہے۔یہ آپریشنوں کی حمایت کرتا ہے جیسے نئے سیٹ شامل کرنا ، ناگوار سیٹوں کو ضم کرنا ، کسی ناگوار سیٹ کے نمائندے کو تلاش کرنا ، اور جانچ پڑتال کرنا کہ آیا دو سیٹ ناگوار ہیں یا نہیں۔ناگوار سیٹ ڈیٹا ڈھانچہ ان مسائل کو حل کرنے میں کارآمد ہے جس میں ایک سیٹ کو ناپسندیدہ ذیلی سیٹوں میں تقسیم کرنا اور ان سب سیٹوں پر کام انجام دینا شامل ہے۔اس کو لنکڈ لسٹوں یا جڑوں والے درختوں کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے ، اور ان سیٹوں پر آپریشن کرنے کی وقت کی پیچیدگی O (M لاگ این) یونین بائی رینک اور پاتھ کمپریشن کا استعمال کرتے ہوئے ہے۔"
    },
    {
        "Question": "متن کے تار میں پیٹرن کی موجودگی کی تعداد کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی متن کے تار میں پیٹرن کی واقعات کی تعداد کو گننے کے ل we ، ہم مختلف طریقوں جیسے سٹرنگ کے طریقے ، باقاعدہ تاثرات ، اور کمانڈ لائن ٹولز استعمال کرسکتے ہیں۔ازگر اور لینکس میں کچھ مثال کے نفاذ یہ ہیں: سٹرنگ کے طریقوں کا استعمال کرتے ہوئے: پائیتھونڈف گنتی_کورینس (متن ، نمونہ): گنتی = 0 انڈیکس = ٹیکسٹ.فائنڈ (پیٹرن) جبکہ انڈیکس! = -1: گنتی += 1 انڈیکس = ٹیکسٹ.فائنڈ (پیٹرن ، انڈیکس + 1) ریٹرن گنتی# مثال usagetext = \"کوئیک براؤن فاکس سست کتے کے اوپر چھلانگ لگاتا ہے\" پیٹرن = \"o\" گنتی = گنتی = گنتی (متن ، پیٹرن) پرنٹ (گنتی) اس عمل میں ، گنتی_و کارنس () فنکشن لیتا ہےایک ٹیکسٹ سٹرنگ اور پیٹرن اسٹرنگ ان پٹ کے طور پر اور متن میں پیٹرن کی پہلی موجودگی کو تلاش کرنے کے لئے تلاش () کا طریقہ استعمال کرتا ہے۔اس کے بعد یہ نمونہ کے بعد کے تمام واقعات کو تلاش کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے اور ہر واقعے کے لئے گنتی متغیر۔گنتی# مثال usagetext = \"کوئیک براؤن فاکس سست کتے پر چھلانگ لگاتا ہے\" پیٹرن = \"o\" گنتی = گنتی_کورینس (متن ، پیٹرن) پرنٹ (گنتی) اس عمل میں ، گنتی_کورینس () فنکشن ایک متن کی تار اور پیٹرن سٹرنگ لیتا ہےچونکہ متن میں پیٹرن کے تمام واقعات کو تلاش کرنے کے لئے ان پٹ اور ری ماڈیول سے فائنل () کا طریقہ استعمال کرتا ہے۔اس کے بعد یہ میچوں کی نتیجے میں فہرست کی لمبائی لوٹاتا ہے۔ لینکس کمانڈ لائن ٹولز کا استعمال کرتے ہوئے: باش $ گریپ -او \"او\" <<< \"کوئیک براؤن فاکس سست کتے کے اوپر چھلانگ لگا دیتا ہے\" |ڈبلیو سی -ایل 4 اس پر عمل درآمد میں ، ہم گریپ کمانڈ کو متن میں صرف پیٹرن کے میچوں کو آؤٹ پٹ کرنے کے لئے -o آپشن کے ساتھ استعمال کرتے ہیں۔اس کے بعد ہم لائنوں کی تعداد کو گننے کے لئے -L آپشن کے ساتھ WC کمانڈ پر آؤٹ پٹ کو پائپ کرتے ہیں ، جو ہمیں متن میں پیٹرن کی تعداد کی تعداد فراہم کرتا ہے۔تار ، ہم مختلف طریقوں جیسے سٹرنگ کے طریقے ، باقاعدہ اظہار اور کمانڈ لائن ٹولز استعمال کرسکتے ہیں۔ہم اس فنکشن کا استعمال کرتے ہوئے اس پر عمل درآمد کرسکتے ہیں جو ٹیکسٹ سٹرنگ اور پیٹرن سٹرنگ کو ان پٹ کے طور پر لیتا ہے اور متن میں پیٹرن کے واقعات کی تعداد کو لوٹاتا ہے۔ہم سٹرنگ کے طریقوں جیسے تلاش () اور گنتی () اور گنتی (باقاعدگی سے اظہار ، یا کمانڈ لائن ٹولز جیسے GREP کو گنتی انجام دینے کے لئے استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "ریڈکس ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "ریڈکس ترتیب ایک غیر تقویت پر مبنی چھانٹنے والا الگورتھم ہے جو انفرادی ہندسوں کے ذریعہ چابیاں گروپ کرکے انٹیجر کیز کے ساتھ اعداد و شمار کو ترتیب دیتا ہے جو ایک ہی اہم پوزیشن اور قدر (جگہ کی قیمت) کا اشتراک کرتے ہیں۔ریڈکس ترتیب نمبروں کی ایک صف کو ترتیب دینے کے لئے گنتی ترتیب کو سبروٹائن کے طور پر استعمال کرتا ہے۔الگورتھم عناصر کو متعدد پاسوں میں پروسیسنگ کرکے ، ہندسے کے ذریعہ ہندسے کی ترتیب دیتا ہے ، جس سے کم سے کم اہم ہندسوں (ایل ایس ڈی) سے لے کر انتہائی اہم ہندسوں (ایم ایس ڈی) یا اس کے برعکس شروع ہوتا ہے۔ایک ہی جگہ کی قیمت کے ہندسوں کو ترتیب دینے کے لئے ریڈکس ترتیب مختلف چھانٹنے والے الگورتھم کو شامل کرسکتا ہے۔ریڈکس ترتیب O (d*(n+b)) وقت میں چلتا ہے ، جہاں D ہندسوں کی تعداد ہے ، n عناصر کی تعداد ہے ، اور B عناصر کی نمائندگی کرنے کے لئے استعمال ہونے والے نمبر کے نظام کی بنیاد ہے۔ بنیادی خیال کا بنیادی خیالریڈکس ترتیب عناصر کو ان کے ہندسوں کے ذریعہ ترتیب دینا ہے ، کم سے کم اہم ہندسے سے لے کر انتہائی اہم ہندسے تک شروع ہوتا ہے۔ہر پاس میں ، عناصر کو موجودہ ہندسے کی قیمت کی بنیاد پر بالٹیوں میں ترتیب دیا جاتا ہے ، اور پھر ترتیب شدہ فہرست کی تشکیل کے ل the بالٹیوں کو متحرک کیا جاتا ہے۔الگورتھم ہر ہندسے کے ل this اس عمل کو دہراتا ہے جب تک کہ تمام ہندسوں پر غور نہ کیا جائے۔RADIX SORT LSD Radix Sort یا MSD Radix ترتیب کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ایل ایس ڈی ریڈکس ترتیب سے کم سے کم اہم ہندسے سے چھانٹنا شروع ہوتا ہے اور اسی جگہ کی قیمت کے ہندسوں کو ترتیب دینے کے لئے ایک مستحکم چھانٹنے والے الگورتھم کو سبروٹائن کے طور پر استعمال کرتا ہے۔ایم ایس ڈی ریڈکس ترتیب انتہائی اہم ہندسے سے چھانٹنا شروع کرتا ہے اور اسی جگہ کی قیمت کے ہندسوں کو ترتیب دینے کے لئے بالٹی ترتیب کو بار بار انجام دیتا ہے۔ یہاں ازگر میں ایل ایس ڈی ریڈکس ترتیب کا ایک مثال ہے: پائیتھنڈف ریڈکس_سورٹ_ل ایس ڈی (اے آر آر)= 1 جبکہ میکس_ ویلیو // ایکسپ> 0: بالٹیاں = [[] _ کے لئے _ میں حد (10)] نمبر کے لئے نمبر: ہندسہ = (نمبر // ایکسپ) ٪ 10 بالٹی [ہندسہ]بالٹی میں بالٹی میں بالٹی کے لئے نمبر] Exp *= 10 ریٹرن ایرن اس نفاذ کو ، Radix_sort_lsd () فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور صف کو ترتیب دینے کے لئے LSD ریڈکس ترتیب استعمال کرتا ہے۔فنکشن سب سے بڑی تعداد میں ہندسوں کی تعداد کا تعین کرنے کے لئے صف میں زیادہ سے زیادہ قیمت تلاش کرنے سے شروع ہوتا ہے۔اس کے بعد یہ ہر ہندسے پر تکرار کرتا ہے ، کم سے کم اہم ہندسے سے شروع ہوتا ہے ، اور موجودہ ہندسے کی قدر کی بنیاد پر عناصر کو بالٹیوں میں ترتیب دینے کے لئے بالٹی ترتیب کا استعمال کرتا ہے۔آخر میں ، فنکشن ترتیب شدہ فہرست کی تشکیل کے ل the بالٹیوں کو ہم آہنگ کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایل ایس ڈی ریڈکس ترتیب کا استعمال کرتے ہوئے انٹیجرز کی ایک صف کو ترتیب دیتا ہے: ازگر = [170 ، 45 ، 75 ، 90 ، 802 ، 24 ، 2 ، 66]sharted_arr = radix_sort_lsd (arr) پرنٹ (sharted_arr) اس کی پیداوار ہوگی: [2 ، 24 ، 45 ، 66 ، 75 ، 90 ، 170 ، 170 ، 802] اختتام میں ، ریڈکس ترتیب ایک غیر ہم آہنگی پر مبنی چھانٹنے والا الگورتھم ہے جو انٹجر کے ساتھ ڈیٹا کو ترتیب دیتا ہے۔انفرادی ہندسوں کے ذریعہ کلیدوں کو گروپ کرکے چابیاں جو ایک ہی اہم پوزیشن اور قیمت (جگہ کی قیمت) کا اشتراک کرتی ہیں۔یہ عناصر کو متعدد پاسوں میں پروسیسنگ کرکے ، ہندسے کے ذریعہ ہندسے کو ترتیب دیتا ہے ، کم سے کم اہم ہندسے سے لے کر انتہائی اہم ہندسوں تک یا اس کے برعکس شروع ہوتا ہے۔Radix ترتیب LSD Radix Sort یا MSD Radix ترتیب کا استعمال کرتے ہوئے نافذ کی جاسکتی ہے ، اور یہ O (D*(n+b)) وقت میں چلتا ہے ، جہاں D ہندسوں کی تعداد ہے ، n عناصر کی تعداد ہے ، اور B اس کی بنیاد ہے۔عناصر کی نمائندگی کرنے کے لئے استعمال ہونے والے نمبر سسٹم میں سے"
    },
    {
        "Question": "بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے ل we ، ہم مختلف طریقوں جیسے ان آرڈر ٹریورسل ، تکراری ٹریورسل ، اور تکرار کرنے والے ٹراورسل کو استعمال کرسکتے ہیں۔ازگر میں کچھ مثال کے نفاذ یہ ہیں: ان آرڈر ٹریورسل کا استعمال: ازگر کلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، کوئی بھی نہیں): سیلف۔ وال = ویل سیلف۔kth_smallest (جڑ ، کے): اسٹیک = [] نوڈ = جڑ جبکہ نوڈ یا اسٹیک: جبکہ نوڈ: اسٹیک.ایپینڈ (نوڈ) نوڈ = نوڈ۔ لیفٹ نوڈ = اسٹیک.پوپ () k -= 1 اگر k == 0:واپسی نوڈ.ول نوڈ = نوڈ۔.فنکشن ایک اسٹیک کا استعمال کرتا ہے تاکہ نوڈس کا دورہ کرنے کے لئے ٹریک کیا جاسکے اور اسٹیک پر بائیں بازو کے نوڈ کو آگے بڑھا کر شروع ہوتا ہے۔اس کے بعد یہ اسٹیک سے نوڈس کو پاپ کرتا ہے ، K ، اور چیک کرتا ہے کہ اگر K 0 کے برابر ہے۔ اگر K 0 کے برابر ہے تو ، فنکشن موجودہ نوڈ کی قیمت لوٹاتا ہے۔بصورت دیگر ، یہ فنکشن دائیں سب ٹری کو عبور کرنا جاری رکھے ہوئے ہے۔رائٹ ڈیف Kth_smallest (روٹ ، کے): ڈیف انڈرڈر_ٹراورسل (نوڈ): نان لوکل K اگر نوڈ کوئی نہیں ہے: واپس کوئی نہیں بائیں = inorder_traversal (node.left) اگر بائیں نہیں ہے: بائیں طرف نہیں ہے: بائیں K -= 1 اگر K -= 1: واپسیnode.val دائیں = inorder_traversal (node.right) اگر صحیح کوئی نہیں ہے: واپس دائیں واپسی inorder_traversal (روٹ)# مثال کے طور پر یوزیجروٹ = ٹرینوڈ (3) روٹ۔ لیفٹ = ٹرینوڈ (1) روٹ۔ رائٹ = ٹرینوڈ (4) جڑ۔بائیں۔بائنری تلاش کے درخت میں عنصر۔فنکشن ایک نیسٹڈ فنکشن INORDER_TRAVERSAL () کی وضاحت کرتا ہے جو بائنری سرچ درخت پر آرڈر میں ٹریورسل انجام دیتا ہے۔فنکشن نوڈس کی تعداد کا پتہ لگانے کے لئے ایک نان لوکل متغیر K کا استعمال کرتا ہے اور کے ٹی ایچ نوڈ کی قیمت کو واپس کرتا ہے جب K 0 کے برابر ہوتا ہے۔.: 1in نتیجہ ، بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے ل we ، ہم مختلف طریقوں جیسے کہ آرڈر میں ٹراورسل ، تکراری ٹراورسل ، اور تکرار کرنے والی ٹریورسل کو استعمال کرسکتے ہیں۔ہم اس فنکشن کا استعمال کرتے ہوئے اس پر عمل درآمد کرسکتے ہیں جو جڑ کے نوڈ اور ایک انٹیجر K کو ان پٹ کے طور پر لیتا ہے اور بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کی قیمت لوٹاتا ہے۔ہم بائنری سرچ ٹری پر آرڈر ٹراورسل کو انجام دینے کے لئے اسٹیک یا تکرار کا استعمال کرسکتے ہیں اور متغیر K.1TakeUforward2stackoverflow3leetCode4helloacm5baeldung کا استعمال کرتے ہوئے نوڈس کی تعداد کا پتہ لگاسکتے ہیں۔"
    },
    {
        "Question": "ایک طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک طبقہ کا درخت ایک اعداد و شمار کا ڈھانچہ ہوتا ہے جو کسی سرے کے وقفوں یا طبقات کے بارے میں معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔اس سے ہمیں لوگرتھمک ٹائم پیچیدگی میں صف میں حد سے متعلق سوالات اور تازہ کاری کرنے کی اجازت ملتی ہے۔ایک طبقہ کا درخت بنیادی طور پر ایک بائنری درخت ہوتا ہے جس کے نوڈس میں ہم لکیری ڈیٹا ڈھانچے کے حصوں کے بارے میں معلومات رکھتے ہیں جیسے ایک صف۔درخت کی جڑ پوری صف کی نمائندگی کرتی ہے ، اور ہر نوڈ صف کے ایک حصے کی نمائندگی کرتا ہے۔طبقہ کا درخت تقسیم اور فتح کے اصول پر کام کرتا ہے۔ہر سطح پر ، ہم سرنی طبقات کو دو حصوں میں تقسیم کرتے ہیں۔اگر دی گئی صف میں [0 ،.. ، N-1] اس میں عناصر پھر صف کے دو حصے [0 ، ہوں گے۔. ، n/2-1] اور [n/2 ،.. ، N-1].اس کے بعد ہم بار بار اس وقت تک جاری رکھیں گے جب تک کہ حد کی نچلی اور اوپری حد برابر نہ ہوجائیں۔طبقہ کے درخت کی ساخت بائنری درخت کی طرح دکھائی دیتی ہے۔طبقہ کے درخت کو مختلف مسائل جیسے رینج سم ، رینج کم سے کم/زیادہ سے زیادہ استفسار ، اور رینج اپ ڈیٹ کو حل کرنے کے لئے استعمال کیا جاسکتا ہے۔ یہاں رینج سم کے استفسار کے لئے ازگر میں طبقہ کے درخت کی ایک مثال ہے: ازگرکلاس سیگمنٹٹری: ڈیف __ __init __ (خود ، نمبرز): self.nums = nums self.tree = [0] * (4 * لین (نمبر)) سیلف۔ بلڈ (0 ، 0 ، لین (نمبر) - 1) ڈیف بلڈ (خود ، نوڈ ، اسٹارٹ ، اختتام):اگر اسٹارٹ == اختتام: self.tree [node] = self.nums [شروع] اور: وسط = (اسٹارٹ + اینڈ) // 2 سیلف۔ بلڈ (2 * نوڈ + 1 ، اسٹارٹ ، مڈ) سیل۔ بلڈ (2* نوڈ + 2 ، مڈ + 1 ، اختتام) سیلف ٹری [نوڈ] = سیلف ٹری [2 * نوڈ + 1] + سیلف ٹری [2 * نوڈ + 2] ڈیف استفسار (خود ، نوڈ ، اسٹارٹ ، اختتام ،بائیں ، دائیں): اگر بائیں> اختتام یا دائیں <شروع کریں: واپس 0 اگر بائیں <= شروع اور دائیں> = اختتام: واپس کریں۔* نوڈ + 1 ، اسٹارٹ ، وسط ، بائیں ، دائیں) + سیلف۔ کیوری (2 * نوڈ + 2 ، مڈ + 1 ، اختتام ، بائیں ، دائیں) ڈیف اپ ڈیٹ (خود ، نوڈ ، اسٹارٹ ، اینڈ ، انڈیکس ، ویل):اگر اسٹارٹ == اختتام: self.nums [index] = ویل سیلف ٹری [نوڈ] = ویل کوئی اور: درمیانی = (اسٹارٹ + اینڈ) // 2 اگر انڈیکس> = اسٹارٹ اور انڈیکس <= مڈ: سیل۔ اپ ڈیٹ (2* نوڈ + 1 ، اسٹارٹ ، مڈ ، انڈیکس ، ویل) اور: سیلف۔ اپ ڈیٹ (2 * نوڈ + 2 ، مڈ + 1 ، اینڈ ، انڈیکس ، ویل) سیلف ٹری [نوڈ] = سیلف ٹری [2 * نوڈ +1] + سیلف ٹری [2 * نوڈ + 2] اس نفاذ میں ، سیگمنٹ ٹری کلاس ان پٹ کے طور پر انٹیجرز کی ایک صف لیتی ہے اور حد کے خلا کو استفسار کے ل a ایک طبقہ کا درخت بناتی ہے۔طبقہ طبقہ کے درخت کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرتا ہے اور تین طریقوں کی وضاحت کرتا ہے: بلڈ () ، استفسار () ، اور اپ ڈیٹ ()۔بلڈ () کا طریقہ کار کو دو حصوں میں تقسیم کرکے اور طبقات کی رقم کی گنتی کرکے طبقہ کے درخت کو بار بار بناتا ہے۔استفسار () کا طریقہ دیئے گئے حد میں عناصر کا مجموعہ تلاش کرنے کے لئے طبقہ کے درخت سے متنازعہ طور پر استفسار کرتا ہے۔اپ ڈیٹ () طریقہ سرنی میں کسی عنصر کی قدر کو اپ ڈیٹ کرتا ہے اور اس کے مطابق طبقہ کے درخت کو اپ ڈیٹ کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ عدد کی ایک صف کے لئے ایک طبقہ کا درخت بناتا ہے اور حدود کے سوالات کو انجام دیتا ہے: پائیٹونومز = [1 ، 3 ، 5، 7 ، 9 ، 11] درخت = سیگمنٹ ٹری (نمبر) پرنٹ (درخت.کوری (0 ، 0 ، لین (نمبر) - 1 ، 1 ، 3)) # آؤٹ پٹ: 15 ٹری۔ اپ ڈیٹ (0 ، 0 ، لین (نمبر)- 1 ، 2 ، 6) پرنٹ (درخت.کیری (0 ، 0 ، لین (نمبر) - 1 ، 1 ، 3)) # آؤٹ پٹ: 16 اس آؤٹ پٹ: 1516in نتیجہ ، ایک طبقہ کا درخت ایک ڈیٹا ڈھانچہ ہے جو معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتا ہےوقفوں یا کسی صف کے طبقات کے بارے میں۔اس سے ہمیں لوگرتھمک ٹائم پیچیدگی میں صف میں حد سے متعلق سوالات اور تازہ کاری کرنے کی اجازت ملتی ہے۔ہم بائنری ٹری کا استعمال کرتے ہوئے ایک طبقہ کے درخت کو نافذ کرسکتے ہیں جس میں نوڈس ہم لکیری ڈیٹا ڈھانچے کے حصوں کے بارے میں معلومات کو اسٹور کرتے ہیں جیسے ایک صف۔ہم مختلف مسائل جیسے رینج سم ، رینج کم سے کم/زیادہ سے زیادہ استفسار ، اور رینج اپ ڈیٹ کے لئے ایک طبقہ کے درخت کا استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیا گیا گراف ایک درخت ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی گراف ایک درخت ہے ، ہمیں دو خصوصیات کی تصدیق کرنے کی ضرورت ہے: گراف میں کوئی سائیکل نہیں ہے۔ گراف منسلک ہے۔ اگر کوئی گراف دونوں خصوصیات کو پورا کرتا ہے تو یہ ایک درخت ہے۔بصورت دیگر ، یہ ایک درخت نہیں ہے۔ یہاں ازگر میں کچھ مثال کے نفاذ ہیں: ڈی ایف ایس کا استعمال کرتے ہوئے: ازگروں سے جمع ہونے والے مجموعے کو درآمد ڈیفالٹ ڈیک ڈیف آئی ایس_ٹری (این ، کناروں): گراف = ڈیفالٹ ڈکٹ (فہرست) یو کے لئے ، وی ، گراف [u] .append (v) گراف [v] .append (u) ملاحظہ کریں = سیٹ () والدین = {0: -1} def dfs (نوڈ): گراف میں پڑوسی کے لئے ملاحظہ کریں۔والدین [پڑوسی] = نوڈ اگر ڈی ایف ایس (پڑوسی): سچے ایلیف والدین کو واپس کریں [نوڈ]! = پڑوسی: سچ واپس لوٹیں اگر ڈی ایف ایس (0) یا لین (ملاحظہ کیا گیا)! = این: غلط واپسی سچے اس پر عمل درآمد ، آئی ایس ٹی ٹری() فنکشن ان پٹ کے بطور ایک انٹیجر این اور کناروں کی فہرست لیتا ہے اور یہ چیک کرنے کے لئے ڈی ایف ایس کا استعمال کرتا ہے کہ آیا گراف درخت ہے یا نہیں۔یہ فنکشن گراف کی ملحقہ فہرست کی نمائندگی کرتا ہے اور ہر نوڈ کے والدین سے باخبر رہنے کے لئے ملاحظہ کرنے والے نوڈس اور ایک لغت کو ٹریک رکھنے کے لئے ایک سیٹ کا استعمال کرتا ہے۔اس کے بعد فنکشن گراف پر ڈی ایف ایس انجام دیتا ہے اور سائیکلوں کی جانچ پڑتال کرتا ہے اس بات کی تصدیق کرکے کہ ہر ملاحظہ کرنے والے نوڈ کے والدین اس کا پڑوسی نہیں ہے۔اگر کوئی سائیکل مل جاتا ہے تو ، فنکشن غلط لوٹاتا ہے۔بصورت دیگر ، اگر تمام نوڈس کا دورہ کیا جاتا ہے تو فنکشن درست لوٹتا ہے۔گراف [v] .append (u) ملاحظہ کریں = سیٹ () قطار = deque ([0]) والدین = {0: -1} جبکہ قطار: نوڈ = قطار۔ پوپٹ () ملاحظہ کریں۔ ایڈ (نوڈ) گراف میں پڑوسی کے لئے (نوڈ)۔آئی ایس_ٹری () فنکشن ان پٹ کے طور پر ایک انٹیجر این اور کناروں کی فہرست لیتا ہے اور یہ چیک کرنے کے لئے بی ایف ایس کا استعمال کرتا ہے کہ آیا گراف درخت ہے یا نہیں۔یہ فنکشن گراف کی ملحقہ فہرست کی نمائندگی کرتا ہے اور ہر نوڈ کے والدین سے باخبر رہنے کے لئے ملاحظہ شدہ نوڈس ، بی ایف ایس انجام دینے کے لئے ایک قطار ، اور ایک لغت رکھنے کے لئے ایک سیٹ کا استعمال کرتا ہے۔اس کے بعد فنکشن گراف پر بی ایف ایس انجام دیتا ہے اور سائیکلوں کی جانچ پڑتال کرتا ہے اس بات کی تصدیق کرکے کہ ہر ملاحظہ کرنے والے نوڈ کے والدین اس کا پڑوسی نہیں ہے۔اگر کوئی سائیکل مل جاتا ہے تو ، فنکشن غلط لوٹاتا ہے۔بصورت دیگر ، اگر تمام نوڈس کا دورہ کیا جاتا ہے تو ، فنکشن درست لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ چیک کرتا ہے اگر دیا ہوا گراف دونوں پر عمل درآمد کا استعمال کرتے ہوئے ایک درخت ہے: ازگر = 5 ای ڈی ایس = [(0 ، 1) ، (0 ، 2) ، (0 ، (0 ،3) ، (3 ، 4)] پرنٹ (is_tree (n ، کناروں)) # آؤٹ پٹ: truen = 5egges = [(0 ، 1) ، (1 ، 2) ، (2 ، 3) ، (3 ، 4) ، (3 ، 4) ،.ہم گراف کو عبور کرنے اور سائیکل اور رابطے کی جانچ پڑتال کے لئے ڈی ایف ایس یا بی ایف ایس کا استعمال کرتے ہوئے اس پر عمل درآمد کرسکتے ہیں۔اگر گراف دونوں خصوصیات کو مطمئن کرتا ہے ، تو یہ ایک درخت ہے۔بصورت دیگر ، یہ ایک درخت نہیں ہے ۔1 کوڈنگنینجاس 2 ایف ای پی پی 3 بییلڈنگ 4sanfoundry5tuturialSPoint"
    },
    {
        "Question": "فبونیکی ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک فبونیکی ہیپ ایک ڈھیر ڈیٹا ڈھانچہ ہے جو بائنومیئل ہیپ کی طرح ہے ، صرف کچھ ترمیم اور ایک ڈھیلے ڈھانچے کے ساتھ۔فبونیکی ہیپ کو الگورتھم کے ذریعہ زیادہ تر استعمال ہونے والی کارروائیوں کو بہتر بنا کر O (M لاگ N) سے O (M + N LOG N) سے O (M LOG N) سے O (M LOG N) سے O (M LOG N) سے O (M LOG N) سے O (M + N LOG N) تک کو بہتر بنانے کے لئے ڈیزائن کیا گیا تھا۔اس کا نام اس حقیقت سے اخذ کیا گیا ہے کہ فبونیکی تسلسل اس کے آپریشنز 123 کے پیچیدگی کے تجزیے میں استعمال ہوتا ہے۔ ایک فبونیکی ہیپ ہیپ کے آرڈر والے درختوں کا ایک مجموعہ ہے۔انہیں بائنومیئل ٹری ہونے کی ضرورت نہیں ہے ، تاہم ، یہ وہ جگہ ہے جہاں کچھ بائنومیئل ڈھیر کی خصوصیات میں نرمی آتی ہے۔ ہر درخت کا ایک آرڈر ہوتا ہے جیسے بائنومیئل ڈھیر جو بچوں کی تعداد پر مبنی ہوتا ہے۔کسی فبونیکی ڈھیر کے اندر نوڈس کو ان کے درخت سے ان کی تنظیم نو کے بغیر ہٹایا جاسکتا ہے ، لہذا آرڈر ضروری طور پر درخت کی زیادہ سے زیادہ اونچائی یا اس میں موجود نوڈس کی تعداد کی نشاندہی نہیں کرتا ہے۔فبونیکی ہیپ میں نوڈس کے مابین پوائنٹرز دوگنا منسلک فہرست 1 سے ملتے جلتے ہیں۔ فبونیکی ہیپ کو فبونیکی ہیپ کہا جاتا ہے کیونکہ درختوں کو اس طرح سے تعمیر کیا جاتا ہے کہ آرڈر این کے درخت میں کم از کم ایف این+2 نوڈس ہوتے ہیں۔یہ ، جہاں fn + 2 (n + 2) th fibonacci نمبر ہے۔فیبونیکی ہیپ کی اہم خصوصیات یہ ہیں کہ یہ کم سے کم ڈھیر آرڈر والے درختوں کا ایک مجموعہ ہے ، ایک پوائنٹر کو کم سے کم عنصر نوڈ پر برقرار رکھا جاتا ہے ، اور اس میں نشان زدہ نوڈس 42. اے فیبوناکی 1 گرو 2 جی ای ای ای ایس ایف ایف ای ای کے پیڈیا 4 پروگگرامز کا ایک سیٹ ہوتا ہے۔"
    },
    {
        "Question": "بائنری ٹری پر پوسٹ آرڈر کے درختوں کو ٹریورسل انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "پوسٹ آرڈر ٹراورسل درختوں کی ایک قسم ہے جو بائیں سب ٹری ، پھر دائیں سب ٹری ، اور آخر میں سب ٹری کا جڑ نوڈ ملتی ہے۔بائنری درخت پر پوسٹ آرڈر ٹریورسل انجام دینے کے ل we ، ہم تکرار یا تکرار کا استعمال کرسکتے ہیں۔یہاں ازگر میں تکرار کا استعمال کرتے ہوئے پوسٹ آرڈر ٹراورسل کا ایک مثال عمل ہے: پائیٹونکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، کوئی بھی نہیں)رائٹ ڈیف پوسٹ آرڈر_ٹراورسل (روٹ): اگر جڑ کوئی نہیں ہے: واپسی [] بائیں = پوسٹ آرڈر_ٹراورسل (روٹ. لیفٹ) دائیں = پوسٹ آرڈر_ٹراورسل (روٹ. رائٹ) بائیں طرف + دائیں + [جڑ.ال] اس عمل میں ، پوسٹ آرڈر_ٹراورال () فنکشن لیتا ہےایک جڑ نوڈ بطور ان پٹ اور بائنری ٹری پر پوسٹ آرڈر ٹراورسال انجام دینے کے لئے تکرار کا استعمال کرتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا روٹ نوڈ کوئی نہیں ہے اور اگر خالی فہرست ہے تو وہ خالی فہرست لوٹاتا ہے۔بصورت دیگر ، فنکشن بار بار بائیں اور دائیں سبٹریز کو عبور کرتا ہے اور نتائج کو روٹ نوڈ ویلیو کے ساتھ جوڑتا ہے تاکہ حتمی پوسٹ آرڈر ٹراورسل تشکیل پائے۔پائیتھونروٹ = ٹرینوڈ (1) روٹ۔ لیفٹ = ٹرینوڈ (2) روٹ۔ رائٹ۔ رائٹ (3) روٹ۔ لیفٹ۔ لیفٹ = ٹرینوڈ (4) روٹ.لفٹ۔نتیجہ) اس کی پیداوار ہوگی: [4 ، 5 ، 2 ، 3 ، 1] آخر میں ، پوسٹ آرڈر ٹریورسل درختوں کی ایک قسم ہے جو بائیں سب ٹری ، پھر دائیں سب ٹری ، اور آخر کار سبٹری کی جڑ نوڈ کا دورہ کرتی ہے۔ہم تکرار یا تکرار کا استعمال کرتے ہوئے پوسٹ آرڈر ٹراورسل کو نافذ کرسکتے ہیں۔بائنری درخت پر پوسٹ آرڈر ٹریورسل انجام دینے کا ایک آسان اور بدیہی طریقہ ہے۔"
    },
    {
        "Question": "ہدایت شدہ ایسائکلک گراف کے لئے ایک ٹوپولوجیکل ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "ٹوپولوجیکل ترتیب ایک الگورتھم ہے جو کسی لکیری ترتیب میں ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کے عمودی کو ترتیب دینے کے لئے استعمال ہوتا ہے جیسے ہر ہدایت والے کنارے (یو ، وی) کے لئے ، ورٹیکس یو آرڈر میں ورٹیکس وی سے پہلے آتا ہے۔ٹوپولوجیکل قسم صرف ڈی اے جی پر لاگو ہوتا ہے کیونکہ گراف میں ایک سائیکل درست آرڈر تلاش کرنا ناممکن بنا دیتا ہے۔ٹوپولوجیکل طرح کی انجام دینے کے ل several کئی الگورتھم موجود ہیں ، جن میں ڈی ایف ایس پر مبنی اور بی ایف ایس پر مبنی الگورتھم شامل ہیں۔ ٹوپولوجیکل ترتیب کے لئے ایک مشترکہ الگورتھم کاہن کا الگورتھم ہے ، جو اس ترتیب کا تعین کرنے کے لئے ہر خطوط کی ان ڈگری کا استعمال کرتا ہے جس میں عمودی عمل پر کارروائی کی جانی چاہئے۔الگورتھم مندرجہ ذیل کام کرتا ہے: گراف میں ہر ایک چوٹی کی ان ڈگری کی گنتی کریں۔ ایک قطار کو ان تمام عمودیوں کے ساتھ بنائیں جن میں 0. کی ڈگری ہوتی ہے ، قطار خالی نہیں ہے ، قطار سے ایک چوٹی کو ہٹا دیں اور اس میں شامل کریںترتیب شدہ فہرست۔ ہٹائے گئے ورٹیکس کے ہر پڑوسی کے لئے ، اس کی ڈگری میں کمی۔اگر ان ڈگری 0 بن جاتی ہے تو ، اسے قطار میں شامل کریں۔ اگر ترتیب شدہ فہرست میں گراف میں موجود تمام عمودی حصے شامل ہیں تو ، فہرست کو ٹاپولوجیکل آرڈر کے طور پر واپس کریں۔بصورت دیگر ، گراف میں ایک سائیکل ہے اور کوئی درست ٹوپولوجیکل آرڈر موجود نہیں ہے۔ یہاں ازگر میں کاہن کے الگورتھم کا ایک مثال ہے: ازگر کے ذخیرے کی درآمد سے پہلے سے طے شدہ ڈیڈکٹ ، ڈی کیو ڈیف ٹاپولوجیکل_سورٹ (این ، ایجز): گراف = ڈیفالٹ ڈکٹ (فہرست) in_degree = [0] *N کے لئے آپ ، V کے کناروں میں: گراف [u] .append (v) in_degree [v] += 1 قطار = ڈیک ([i کے لئے I کے لئے (n) اگر in_degree [i] == 0]) نتیجہ = [] جبکہ قطار: نوڈ = قطار ۔پوفٹ () نتیجہ۔نتیجہ)! = N: کوئی بھی واپسی کے نتیجے میں کوئی نہیں لوٹنے کے نتیجے میں ، ٹوپولوجیکل_سورٹ () فنکشن ان پٹ کے طور پر ایک عدد این اور کناروں کی فہرست لیتا ہے اور گراف پر ٹاپولوجیکل ترتیب دینے کے لئے کاہن کے الگورتھم کا استعمال کرتا ہے۔فنکشن گراف کی ملحقہ فہرست کی نمائندگی کرتا ہے اور ہر ایک خط کی ڈگری کی گنتی کرتا ہے۔اس کے بعد فنکشن ان تمام عمودیوں کے ساتھ ایک قطار کا آغاز کرتا ہے جس میں 0 کی ڈگری ہوتی ہے اور قطار سے عمودی کو ہٹاتا ہے ، جس سے انہیں ترتیب شدہ فہرست میں شامل کیا جاتا ہے اور اپنے پڑوسیوں کی ڈگری کو کم کیا جاتا ہے۔اگر ترتیب شدہ فہرست میں گراف میں موجود تمام عمودی حصے شامل ہیں تو ، فنکشن فہرست کو ٹاپولوجیکل آرڈر کے طور پر واپس کرتا ہے۔بصورت دیگر ، فنکشن اس بات کی نشاندہی کرنے کے لئے کوئی نہیں لوٹتا ہے کہ گراف میں ایک سائیکل ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ مندرجہ بالا عمل درآمد کا استعمال کرتے ہوئے ڈی اے جی پر ٹوپولوجیکل ترتیب دیتا ہے: پائیٹون = 6 ای ڈی ایس = [(0 ، 1) ، (0 ، 2) ، ((0 ، 1) ، (1 ، 3) ، (2 ، 3) ، (2 ، 4) ، (3 ، 5) ، (4 ، 5)] نتیجہ = ٹوپولوجیکل_سورٹ (این ، ایجز) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: [0 ، 1 ،2 ، 4 ، 3 ، 5] آخر میں ، ٹوپولوجیکل سورڈ ایک الگورتھم ہے جو ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کے عمودی کو لکیری ترتیب میں ترتیب دینے کے لئے استعمال ہوتا ہے جیسے ہر ہدایت والے کنارے (یو ، وی) کے لئے ، ورٹیکس یو ورٹیکس سے پہلے آتا ہے۔آرڈر میں v.ہم کاہن کے الگورتھم سمیت مختلف الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل ترتیب کو نافذ کرسکتے ہیں ، جو اس ترتیب کا تعین کرنے کے لئے ہر ایک ورٹیکس کی ڈگری کا استعمال کرتا ہے جس میں عمودی عمل پر کارروائی کی جانی چاہئے۔"
    },
    {
        "Question": "عدد کی ایک صف میں سب سے طویل عرصہ تک بڑھتی ہوئی کامیابی کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عددیوں کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے ل we ، ہم O (n^2) وقت کی پیچیدگی میں مسئلے کو حل کرنے کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں۔خیال یہ ہے کہ ان پٹ سرنی نمبروں کی طرح لمبائی کا ایک سرنی ڈی پی بنانا ہے ، جہاں ڈی پی [i] لمبے لمبے لمبے لمبے لمبے لمبائی کی نمائندگی کرتا ہے جو نمبر [i] پر ختم ہوتا ہے۔ہم ڈی پی کو تمام 1 کی شروعات کرسکتے ہیں ، کیونکہ کسی بھی عنصر پر ختم ہونے والا سب سے طویل عرصہ تک بڑھتا ہوا حصہ کم از کم 1 (عنصر خود) ہوتا ہے۔پھر ، ہر عنصر نمبر [i] کے ل we ، ہم پچھلے تمام عناصر نمبر [j] پر تکرار کرسکتے ہیں جیسے j <i اور nums [j] <nums [i] ، اور ڈی پی [i] کو ڈی پی کی زیادہ سے زیادہ بننے کے لئے اپ ڈیٹ کریں [I] اور DP [J] + 1. آخر میں ، ہم DP میں زیادہ سے زیادہ قیمت کو سب سے طویل عرصے تک بڑھتے ہوئے متناسب کی لمبائی کے طور پر واپس کرسکتے ہیں۔ یہاں ازگر میں اس الگورتھم کا ایک مثال ہے: پائیٹھنڈف طویل ترین_انکریزنگ_ سبسینس (نمبر): n = len ((nums): n = len (nums)nums) dp = [1] * n رینج (1 ، n) کے لئے: J کے لئے رینج میں (i): اگر nums [j] <nums [i]: dp [i] = زیادہ سے زیادہ (dp [i] ،ڈی پی [جے] + 1) اس نفاذ میں میکس (ڈی پی) کی واپسی ، سب سے طویل_incressing_subsecence () فنکشن ان پٹ کے طور پر انٹیجر نمبروں کی ایک صف لیتا ہے اور طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی تلاش کرنے کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے۔فنکشن نے تمام 1 کی لمبائی کے ایک سرنی ڈی پی کی ابتدا کی ہے ، جہاں N نمبر کی لمبائی ہے۔اس کے بعد یہ فنکشن انڈیکس (i ، j) کے تمام جوڑے پر تکرار کرتا ہے جیسے i> j اور nums [j] <nums [i] ، اور ڈی پی [i] کو زیادہ سے زیادہ ڈی پی [i] اور ڈی پی [j] بننے کے لئے اپ ڈیٹ کرتا ہے۔+ 1. آخر میں ، فنکشن ڈی پی میں زیادہ سے زیادہ قیمت لوٹاتا ہے کیونکہ طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کو مذکورہ بالا عمل کو استعمال کرتے ہوئے عدد کی ایک صف میں سب سے طویل عرصہ تک بڑھتا ہوا پایا جاتا ہے: پائیٹونومس = [10 ، 9 ،2 ، 5 ، 3 ، 7 ، 101 ، 18] نتیجہ = سب سے طویل_increasing_subsence (Nums) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 4 اس مثال کے طور پر ، ان پٹ صف میں سب سے طویل عرصہ تک بڑھتی ہوئی تعداد [2 ، 5 ، 7 ، 101] ہے ، جو ہے ، جولمبائی 4. اس کے نتیجے میں ، ہم O (n^2) وقت کی پیچیدگی میں عدد کی ایک صف میں طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی تلاش کرنے کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں۔الگورتھم میں ہر عنصر پر ختم ہونے والے طویل ترین بڑھتے ہوئے تقویم کی لمبائی کو ذخیرہ کرنے کے لئے ایک سرنی ڈی پی بنانا شامل ہے ، اور اشاریوں کے تمام جوڑے (i ، j) پر گھریلو لوپ کا استعمال کرتے ہوئے ڈی پی کو اپ ڈیٹ کرنا ہے جس میں i> j اور nums [j] <نمبر [i]۔سب سے طویل عرصے تک بڑھتے ہوئے حصول کی لمبائی پھر DP.1Algodaily2cp-algorithms3stackoverflow4afteracademy5opengenus میں زیادہ سے زیادہ قیمت ہے"
    },
    {
        "Question": "لاحقہ سرنی ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک لاحقہ سرنی ایک ڈیٹا ڈھانچہ ہے جو کسی بڑے متن میں نمونوں کی موثر انداز میں تلاش کرنے کے لئے استعمال ہوتا ہے۔یہ کسی دیئے گئے تار کے تمام ممکنہ لاحقہ کی ایک صف ہے ، جس میں لغت کے مطابق ترتیب دیا گیا ہے۔لاحقہ سرنی کا لاحقہ درخت سے گہرا تعلق ہے ، جو دیئے گئے متن کے تمام لاحقہ کی ایک کمپریسڈ سہ رخی ہے۔لاحقہ سرنی کو مختلف آپریشنز جیسے تعمیر ، تلاش ، سب سے طویل عام پریفکس ، گنتی الگ الگ سبسٹرنگز ، وغیرہ انجام دینے کے لئے استعمال کیا جاسکتا ہے۔لاحقہ سرنی ، بشمول بولی الگورتھم اور او (این لاگ این) الگورتھم۔بولی الگورتھم تمام لاحقہ پر غور کرتا ہے ، ان کو O (n لاگ این) ترتیب دینے والے الگورتھم کا استعمال کرتے ہوئے ترتیب دیتا ہے ، اور اصل اشاریہ جات کو برقرار رکھتا ہے۔بولی الگورتھم کی وقت کی پیچیدگی O (n^2 لاگ این) ہے ، جہاں این ان پٹ اسٹرنگ میں حروف کی تعداد ہے۔او (این لاگ این) لاحقہ سرنی تعمیر کے لئے الگورتھم اپنے پہلے K کرداروں کے ذریعہ لاحقہ کو چھانٹنے کے خیال پر مبنی ہے ، جہاں کے 2 کی طاقت ہے۔1 ، 2 ، ... ، لاگ این ، ریڈکس ترتیب یا گنتی ترتیب کا استعمال کرتے ہوئے۔ یہاں ازگر میں لاحقہ سرنی کی تعمیر کے لئے O (n لاگ این) الگورتھم کا ایک مثال ہے: پیتھنڈف لاحقہ_ارری (s): n = len (s) sa = [i for i in range (n)] درجہ = [ord (s [i]) کے لئے i in range (n)] k = 1 جبکہ k <n: sa = syted (sa ، key = lambda i:.[i - 1]] اور درجہ بندی [sa [i] + k] == درجہ [sa [i - 1] + k] ورنہ I کے لئے I (n)] k *= 2 اس عمل کو نفاذ کریں ، لاحقہ_ریری() فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور لاحقہ سرنی کی تعمیر کے لئے O (n لاگ این) الگورتھم کا استعمال کرتا ہے۔فنکشن ایس کے اشارے اور رینک سرنی رینک کو ایس میں کرداروں کی ASCII اقدار کے لئے لاحقہ سرنی SA کا آغاز کرتا ہے۔اس کے بعد فنکشن نے اپنے پہلے 2^I حرفوں کے ذریعہ لاحقہ لاحقہ کو I = 0 ، 1 ، 2 ، ... ، لاگ این کے ذریعہ ترتیب دیا ہے ، جس میں ایک کلیدی فنکشن کے ساتھ ترتیب شدہ () فنکشن کا استعمال کیا جاتا ہے جو لاحقہ کی صفوں کا موازنہ کرتا ہے۔فنکشن ترتیب شدہ لاحقہ سرنی اور پچھلے رینک سرنی کی بنیاد پر رینک سرنی کو اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن لاحقہ سرنی کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ مذکورہ بالا عمل کو استعمال کرتے ہوئے دیئے گئے تار کے لئے ایک لاحقہ صف تیار کرتا ہے: ازگر = \"کیلے\" سا = لاحقہ_ارری (ایس) پرنٹ (SA) اس کی پیداوار ہوگی: [5 ،3 ، 1 ، 0 ، 4 ، 2] اس مثال میں ، ان پٹ سٹرنگ \"کیلے\" کے لاحق لاحقہ سرنی IS531042.IS اختتام پر ، ایک لاحقہ ایک اعداد و شمار کا ڈھانچہ ہے جو کسی بڑے متن کے اندر نمونوں کی موثر انداز میں تلاش کرنے کے لئے استعمال ہوتا ہے۔ہم مختلف الگورتھم کا استعمال کرتے ہوئے ایک لاحقہ سرنی بنا سکتے ہیں ، بشمول بولی الگورتھم اور او (این لاگ این) الگورتھم۔O (n log n) الگورتھم اپنے پہلے K کرداروں کے ذریعہ لاحقہ کو چھانٹنے کے خیال پر مبنی ہے ، جہاں K 2 کی طاقت ہے۔ ہم چھانٹنے والے الگورتھم جیسے ریڈکس ترتیب یا گنتی کا استعمال کرتے ہوئے O (n لاگ این) الگورتھم کو نافذ کرسکتے ہیں۔ترتیب دیں"
    },
    {
        "Question": "بائنری درخت کا قطر تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "بائنری درخت کا قطر تلاش کرنے کے ل we ، ہمیں درخت میں کسی بھی دو نوڈس کے درمیان لمبا ترین راستہ تلاش کرنے کی ضرورت ہے۔راستہ درخت کے جڑ نوڈ سے گزر سکتا ہے یا نہیں۔بائنری درخت کے قطر کو تلاش کرنے کے ل several کئی الگورتھم ہیں ، بشمول متحرک پروگرامنگ کا استعمال کرتے ہوئے بولی نقطہ نظر اور بہتر نقطہ نظر سمیت۔ بولی نقطہ نظر میں بائنری درخت کے ہر نوڈ کو گھماؤ نقطہ کے طور پر غور کرنا شامل ہے۔ہم مڑے ہوئے نقطہ کو قطر کے راستے پر نوڈ کے طور پر بیان کرسکتے ہیں جس کی زیادہ سے زیادہ اونچائی ہے۔ہر نوڈ کے ل we ، ہم اس کے بائیں اور دائیں سبٹریز کی اونچائی کا حساب لگاسکتے ہیں اور نوڈ کا قطر حاصل کرنے کے لئے ان کو ایک ساتھ شامل کرسکتے ہیں۔اس کے بعد ہم پورے بائنری درخت کو عبور کرسکتے ہیں اور تمام نوڈس میں زیادہ سے زیادہ قطر تلاش کرسکتے ہیں۔بولی نقطہ نظر کی وقت کی پیچیدگی O (n^2) ہے ، جہاں n بائنری درخت میں نوڈس کی تعداد ہے۔ متحرک پروگرامنگ کا استعمال کرتے ہوئے بہتر نقطہ نظر میں بائنری درخت میں ہر نوڈ کی اونچائی کا حساب لگانا اور اسے صف میں اسٹور کرنا شامل ہے۔اس کے بعد ہم بائنری درخت میں ہر نوڈ کے قطر کا حساب لگانے کے لئے اونچائی کی صف کا استعمال کرسکتے ہیں۔نوڈ کا قطر اس کے بائیں اور دائیں سب ٹریوں کے علاوہ ایک کی اونچائیوں کا مجموعہ ہے۔اس کے بعد ہم پورے بائنری درخت کو عبور کرسکتے ہیں اور تمام نوڈس میں زیادہ سے زیادہ قطر تلاش کرسکتے ہیں۔بہتر نقطہ نظر کی وقت کی پیچیدگی O (n) ہے ، جہاں بائنری ٹری میں نوڈس کی تعداد ہے۔ یہاں ازگر میں متحرک پروگرامنگ کا استعمال کرتے ہوئے بہتر نقطہ نظر کی ایک مثال ہے: ازگرکلاس ٹرینوڈ: ڈیف __INIT __ (خود ، ویل =0 ، بائیں = کوئی نہیں ، کوئی بھی نہیں): self.val = val self.left = بائیں سیلف۔ رائٹ = رائٹ ڈیف قطر_ف_بائنری_ٹری (جڑ): اونچائی = {} Def get_height (نوڈ): اگر نوڈ کوئی نہیں ہے: واپس 0 اگر نوڈ واپساونچائی میں: ریٹرن اونچائی [نوڈ] بائیں_ہائٹ = get_height (node.left) رائٹ_ہائٹ = get_height (نوڈ. رائٹ) اونچائی [نوڈ] = زیادہ سے زیادہ (بائیں_ہائٹ ، رائٹ_ہائٹ) + 1 ریٹرن اونچائی [نوڈ] ڈیف گیٹ_ڈیئمٹر (نوڈ): اگر نوڈ ہے۔کیا کوئی نہیں: واپس 0 بائیں_ڈیئمٹر = get_diameter (نوڈ.لفٹ) رائٹ_ڈیمیٹر = get_diameter (نوڈ. رائٹ) نوڈ_ڈیمیٹر = get_height (نوڈ. لیفٹ) + get_heighروٹ) اس نفاذ میں ، قطر_وف_بائنری_ٹری () فنکشن ان پٹ کے طور پر ایک جڑ نوڈ لیتا ہے اور بائنری درخت کا قطر تلاش کرنے کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے۔فنکشن سب سے پہلے بائنری درخت میں ہر نوڈ کی اونچائی کو ذخیرہ کرنے کے لئے ایک لغت کی اونچائی کا آغاز کرتا ہے۔اس کے بعد فنکشن ہر نوڈ کی اونچائی اور قطر کا حساب لگانے کے لئے بالترتیب دو مددگار افعال get_height () اور get_diameter () کی وضاحت کرتا ہے۔get_height () فنکشن اس کے بائیں اور دائیں سب ٹریوں کی اونچائی کا حساب کتاب کرکے اور اونچائی کی لغت میں نتیجہ کو ذخیرہ کرکے نوڈ کی اونچائی کا حساب کتاب کرتا ہے۔get_diameter () فنکشن اس کے بائیں اور دائیں سب ٹریوں کے قطر اور اونچائی کی لغت کا استعمال کرتے ہوئے خود نوڈ کے قطر کا حساب لگا کر نوڈ کے قطر کا حساب کتاب کرتا ہے۔آخر میں ، فنکشن روٹ نوڈ کے قطر کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک بائنری درخت بناتا ہے اور مذکورہ بالا عمل کو استعمال کرتے ہوئے اس کا قطر تلاش کرتا ہے: پائیٹونروٹ = ٹرینوڈ (1) جڑ۔(3) روٹ. لیفٹ۔ لیفٹ = ٹرینوڈ (4) روٹ۔ لیفٹ. رائٹ = ٹرینوڈ (5) نتیجہ = قطر_وف_بائنری_ٹری (جڑ) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 3 میں بائنری درخت کا قطر 3 ہے ،جو نوڈ 4 سے نوڈ 5 تک راستے کی لمبائی ہے ، ہم مختلف الگورتھم کا استعمال کرتے ہوئے بائنری درخت کا قطر تلاش کرسکتے ہیں ، بشمول متحرک پروگرامنگ کا استعمال کرتے ہوئے بولی نقطہ نظر اور بہتر نقطہ نظر سمیت۔بہتر نقطہ نظر میں بائنری درخت میں ہر نوڈ کی اونچائی کا حساب لگانا اور ہر نوڈ کے قطر کا حساب لگانے کے لئے استعمال کرنا شامل ہے۔اس کے بعد ہم پورے بائنری درخت کو عبور کرسکتے ہیں اور تمام نوڈس میں زیادہ سے زیادہ قطر تلاش کرسکتے ہیں۔"
    },
    {
        "Question": "بی+ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ایک بی+ درخت متوازن درختوں کے اعداد و شمار کا ڈھانچہ ہے جو بی ٹری کی توسیع ہے۔یہ عام طور پر ڈیٹا بیس سسٹم اور فائل سسٹم میں استعمال ہوتا ہے تاکہ بڑی مقدار میں ڈیٹا کو موثر انداز میں اسٹور اور بازیافت کیا جاسکے۔A B+ درخت جڑ نوڈ ، اندرونی نوڈس اور پتی کے نوڈس پر مشتمل ہوتا ہے۔جڑ کا نوڈ یا تو پتی یا دو یا زیادہ بچوں کے ساتھ نوڈ ہوسکتا ہے۔بی+ درخت میں ہر نوڈ میں صرف چابیاں ہوتی ہیں (کلیدی قدر کے جوڑے نہیں) ، اور جس میں منسلک پتے کے ساتھ نیچے ایک اضافی سطح شامل کی جاتی ہے۔بی+ درخت کی چابیاں چڑھتے ہوئے ترتیب میں ترتیب دی جاتی ہیں ، اور اندرونی نوڈ میں ہر کلید ایک ذیلی ٹری سے مساوی ہوتی ہے جس میں کلید سے زیادہ یا اس کے برابر تمام چابیاں ہوتی ہیں اور اگلی کلید سے کم ہوتی ہیں۔بی+ ٹری کے پتی نوڈس میں اصل اعداد و شمار موجود ہیں ، اور ریکارڈ کو سرچ فیلڈ پر آرڈرڈ رسائی فراہم کرنے کے لئے ایک دوسرے کے ساتھ جڑے ہوئے ہیں۔بی+ ٹری ایک کثیر سطحی ڈیٹا ڈھانچہ ہے ، جس میں اوپر کی جڑ نوڈ اور اس کے نیچے اندرونی نوڈس کی ایک یا زیادہ سطح ہے۔نیچے کی سطح پر پتی کے نوڈس میں اصل اعداد و شمار ہوتے ہیں۔بی+ ٹری بہتر داخل کرنے ، حذف کرنے ، اور بی ٹری پر تلاش کرنے کی حمایت کرتا ہے ، اور اندرونی نوڈس کے ساتھ ساتھ پتی کے نوڈس میں ڈیٹا پوائنٹرز اور کلیدی اقدار دونوں کی اجازت دیتا ہے ، جس سے تلاش ، داخل کریں اور آپریشنوں کو زیادہ موثر بنائیں۔بی+ ٹری مرکزی میموری میں بڑی مقدار میں ڈیٹا کو ذخیرہ کرنے کے لئے ایک مفید ڈیٹا ڈھانچہ ہے ، جہاں مرکزی میموری کا سائز اتنا بڑا نہیں ہے۔"
    },
    {
        "Question": "ڈیٹا ڈھانچہ کیا ہے؟",
        "Answer": "ڈیٹا کا ڈھانچہ ڈیٹا کو منظم کرنے ، پروسیسنگ ، بازیافت اور ڈیٹا کو اسٹور کرنے کے لئے ایک خصوصی شکل ہے۔یہ کمپیوٹر پر ڈیٹا کا اہتمام کرنے کا ایک طریقہ ہے تاکہ اس تک رسائی اور موثر انداز میں اپ ڈیٹ ہوسکے۔اعداد و شمار کے ڈھانچے کی متعدد بنیادی اور اعلی درجے کی اقسام ہیں ، یہ سب ایک خاص مقصد کے مطابق ڈیٹا کا بندوبست کرنے کے لئے ڈیزائن کیا گیا ہے۔ڈیٹا ڈھانچے صارفین کے لئے مناسب طریقوں سے ان کی ضرورت کے اعداد و شمار تک رسائی اور کام کرنا آسان بناتے ہیں۔سب سے اہم بات یہ ہے کہ ڈیٹا کے ڈھانچے معلومات کی تنظیم کو تیار کرتے ہیں تاکہ مشینیں اور انسان اسے بہتر طور پر سمجھ سکیں۔کمپیوٹر سائنس اور کمپیوٹر پروگرامنگ میں ، ڈیٹا کا ڈھانچہ منتخب یا مختلف الگورتھم کے ساتھ استعمال کرنے کے مقصد کے لئے ڈیٹا اسٹور کرنے کے لئے ڈیزائن کیا جاسکتا ہے۔کچھ معاملات میں ، الگورتھم کی بنیادی کاروائیاں ڈیٹا ڈھانچے کے ڈیزائن کے ساتھ مضبوطی سے مل جاتی ہیں۔ہر اعداد و شمار کے ڈھانچے میں ڈیٹا کی اقدار ، ڈیٹا کے مابین تعلقات کے بارے میں معلومات ہوتی ہیں ، اور - کچھ معاملات میں - ایسے افعال جو اعداد و شمار پر لاگو ہوسکتے ہیں۔عام بیس ڈیٹا کی اقسام ، جیسے انٹیجرز یا فلوٹنگ پوائنٹ اقدار ، جو زیادہ تر کمپیوٹر پروگرامنگ زبانوں میں دستیاب ہیں زیادہ پیچیدہ ڈیٹا ڈھانچے بنانے کے لئے استعمال کی جاسکتی ہیں۔ڈیٹا ڈھانچے کو تقریبا every ہر پروگرام یا سافٹ ویئر سسٹم میں استعمال کیا جاتا ہے جو تیار کیا گیا ہے۔لکیری ڈیٹا ڈھانچے اور غیر لکیری ڈیٹا ڈھانچے ڈیٹا ڈھانچے کی دو اہم اقسام ہیں۔لکیری ڈیٹا ڈھانچے وہ ہیں جن میں عناصر کو ایک کے بعد ایک ترتیب میں ترتیب دیا جاتا ہے ، جبکہ غیر لکیری ڈیٹا ڈھانچے وہ ہیں جن میں عناصر کو دوسرے کے بعد ترتیب میں ترتیب نہیں دیا جاتا ہے۔"
    },
    {
        "Question": "ایک صف اور منسلک فہرست میں کیا فرق ہے؟",
        "Answer": "صفوں اور منسلک فہرستیں ڈیٹا کو اسٹور اور منظم کرنے کے لئے استعمال ہونے والے دو بنیادی اعداد و شمار کے ڈھانچے ہیں۔دونوں کے مابین کچھ اختلافات یہ ہیں: میموری کی مختص: آریوں کو میموری کے متضاد مقامات پر اسٹور عناصر اسٹور کرتے ہیں ، جبکہ لنکڈ فہرستیں غیر متضاد میموری کے مقامات پر اسٹور عناصر کو اسٹور کرتی ہیں۔اس کا مطلب یہ ہے کہ صفوں کو مختص کرنے کے لئے ایک مقررہ مقدار میں میموری کی ضرورت ہوتی ہے ، یہاں تک کہ اگر یہ سب استعمال نہیں کیا جارہا ہے ، جبکہ منسلک فہرستیں اعداد و شمار کی مقدار کے تناسب سے اپنے سائز کو مرحلہ وار بڑھا سکتی ہیں۔سرنی کو براہ راست اس کے انڈیکس سے حاصل کیا جاسکتا ہے ، جو لنکڈ فہرست کے مقابلے میں ایک صف میں عناصر تک رسائی کو تیز تر بناتا ہے۔تاہم ، کسی منسلک فہرست کی صورت میں ، کسی بھی عنصر تک پہنچنے کے لئے پچھلے تمام عناصر کو عبور کرنا چاہئے۔ داخل اور حذف کرنا: کسی صف میں عناصر کا اندراج اور حذف کرنا وقت طلب ہوسکتا ہے ، خاص طور پر اگر صف بڑی ہے ، کیونکہ تمام تماماندراج یا حذف کرنے کے بعد عناصر کو منتقل کرنا ضروری ہے۔اس کے برعکس ، لنکڈ لسٹ میں عناصر کا اندراج اور حذف کرنا تیز ہے کیونکہ صرف پوائنٹرز کو اپ ڈیٹ کرنے کی ضرورت ہے۔ میموری کا استعمال: صفوں کو میموری کی ایک مقررہ مقدار میں مختص کرنے کی ضرورت ہوتی ہے ، چاہے یہ سب استعمال نہ ہو ، جبکہ لنکڈ فہرستیںاعداد و شمار کی مقدار کے تناسب سے مرحلہ وار ان کے سائز میں اضافہ کرسکتا ہے۔اس کا مطلب یہ ہے کہ لنکڈ فہرستیں کچھ معاملات میں صفوں کے مقابلے میں زیادہ میموری سے موثر ہوسکتی ہیں۔ نفاذ: صفوں کو نافذ کرنا اور استعمال کرنا آسان ہے ، جبکہ لنکڈ فہرستوں کو نافذ کرنے اور استعمال کرنے کے لئے مزید کام کی ضرورت ہوتی ہے۔منسلک فہرستیں سیگمنٹٹیشن فالٹ یا میموری لیک کی غلطیوں کا زیادہ خطرہ ہیں۔ خلاصہ میں ، صفوں اور لنکڈ فہرستیں اعداد و شمار کو ذخیرہ کرنے اور منظم کرنے کے لئے مفید ڈیٹا ڈھانچے ہیں ، لیکن ان کے مختلف فوائد اور نقصانات ہیں۔عناصر تک رسائی حاصل کرنے کے لئے صفیں تیز ہیں ، جبکہ منسلک فہرستیں عناصر کے اندراج اور حذف کرنے کے لئے تیز ہیں۔صفوں کو مختص کرنے کے لئے ایک مقررہ مقدار میں میموری کی ضرورت ہوتی ہے ، جبکہ لنکڈ فہرستیں اعداد و شمار کی مقدار کے تناسب سے مرحلہ وار اپنے سائز میں اضافہ کرسکتی ہیں۔صفوں اور منسلک فہرستوں کے مابین انتخاب کا انحصار مخصوص استعمال کے معاملے اور رسائی کے وقت ، اندراج اور حذف وقت کے درمیان تجارتی تعلقات پر ہوتا ہے۔"
    },
    {
        "Question": "اسٹیک کیا ہے؟اس کی ایک مثال دیں کہ اسے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک اسٹیک ایک لکیری ڈیٹا ڈھانچہ ہے جو LIFO (آخری میں آخری میں) اصول کی پیروی کرتا ہے۔یہ ایک آسان ڈیٹا ڈھانچہ ہے جو عناصر کو کسی خاص ترتیب میں شامل کرنے اور اسے ہٹانے کی اجازت دیتا ہے۔اسٹیک کا ایک سر ہے ، جبکہ قطار کے دو سرے (سامنے اور پیچھے) ہیں۔اس میں اسٹیک کے سب سے اوپر والے عنصر کی طرف اشارہ کرنے والے صرف ایک پوائنٹر ٹاپ ہوتا ہے۔جب بھی کسی عنصر کو اسٹیک میں شامل کیا جاتا ہے تو ، اسے اسٹیک کے اوپری حصے میں شامل کیا جاتا ہے ، اور عنصر کو صرف اسٹیک سے حذف کیا جاسکتا ہے۔اسٹیکس کو بہت ساری ایپلی کیشنز میں استعمال کیا جاتا ہے ، جیسے ٹیکسٹ ایڈیٹرز میں انضمام/ریڈو آپریشنز ، بیک ٹریکنگ الگورتھم ، اور اظہار کی تشخیص۔ اس کی ایک مثال ہے کہ کسی لفظ کو الٹا کرنے کے لئے اسٹیک کو کس طرح استعمال کیا جاسکتا ہے۔ہم ایک دیئے گئے لفظ کو اسٹیک - خط کے ذریعہ خط - اور پھر اسٹیک سے پاپ لیٹرز پر دھکیل سکتے ہیں۔اس کے نتیجے میں لفظ الٹ ہوجائے گا۔مثال کے طور پر ، ہم کہتے ہیں کہ ہم لفظ \"ہیلو\" کو پلٹنا چاہتے ہیں۔ہم لفظ کے ہر خط کو اسٹیک پر دھکیل سکتے ہیں ، اور پھر الٹ لفظ کو حاصل کرنے کے لئے ان کو الٹ ترتیب میں بند کر سکتے ہیں: ازگر کے لفظ کے ل letter پیر کے لئے: اسٹیک.ایپینڈ (خط) الٹ_ ورڈ = \"\"جبکہ اسٹیک: الٹ_ ورڈ += اسٹیک ۔پپ () پرنٹ (الٹ_ ورڈ) اس کی پیداوار ہوگی: اولیہ اس مثال کے طور پر ، ہم پہلے اسٹیک پر \"ہیلو\" کے لفظ کے ہر خط کو آگے بڑھاتے ہیں ، اور پھر ان کو الٹا کرنے کے لئے الٹ ترتیب میں پاپ کریںلفظ \"اولیہ\". اختتام پر ، ایک اسٹیک ایک سادہ ڈیٹا ڈھانچہ ہے جو عناصر کو کسی خاص ترتیب میں شامل کرنے اور اسے ہٹانے کی اجازت دیتا ہے۔یہ LIFO (آخری میں آخری میں) اصول کی پیروی کرتا ہے اور بہت سی ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے ٹیکسٹ ایڈیٹرز میں کالعدم/ریڈو آپریشنز ، بیک ٹریکنگ الگورتھم ، اور اظہار کی تشخیص۔ہم اسٹیک پر لفظ کے ہر حرف کو اسٹیک پر دھکیل کر اور پھر ان کو ریورس آرڈر میں پاپ کرتے ہوئے ایک لفظ کو پلٹانے کے لئے ایک اسٹیک کا استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "قطار کیا ہے؟اس کی ایک مثال دیں کہ اسے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک قطار ایک لکیری ڈیٹا ڈھانچہ ہے جو FIFO (پہلے میں پہلے) اصول کی پیروی کرتا ہے۔یہ اشیاء کا ایک کنٹینر ہے جو FIFO اصول کے مطابق داخل اور ہٹا دیا جاتا ہے۔ایک قطار کے دو سرے ہوتے ہیں ، سامنے اور عقبی ، اور نئے عناصر کو عقبی سرے میں شامل کیا جاتا ہے اور سامنے کے سرے سے ہٹا دیا جاتا ہے۔قطاریں بہت سے ایپلی کیشنز میں استعمال ہوتی ہیں ، جیسے ملازمت کا شیڈولنگ ، نیٹ ورک پیکٹ روٹنگ ، اور چوڑائی کی پہلی تلاش الگورتھم۔ یہاں پرنٹر قطار کو نافذ کرنے کے لئے قطار کو کس طرح استعمال کیا جاسکتا ہے اس کی ایک مثال ہے۔فرض کریں کہ ہمارے پاس ایک پرنٹر ہے جو ایک وقت میں ایک دستاویز پرنٹ کرسکتا ہے ، اور متعدد صارفین اپنے دستاویزات پرنٹ کرنا چاہتے ہیں۔ہم پرنٹنگ کی درخواستوں کو سنبھالنے کے لئے قطار استعمال کرسکتے ہیں۔ہر بار جب کوئی صارف کسی دستاویز کو پرنٹ کرنا چاہتا ہے تو ، ہم دستاویز کو قطار کے عقبی سرے میں شامل کرسکتے ہیں۔اس کے بعد پرنٹر دستاویز کو قطار کے اگلے سرے سے ہٹا سکتا ہے اور اسے پرنٹ کرسکتا ہے۔اس سے یہ یقینی بنتا ہے کہ دستاویزات کو اس ترتیب میں پرنٹ کیا گیا ہے جس کی ان کی درخواست کی گئی تھی ، اس کے بعد ان کی درخواست کی گئی تھی۔ڈیف پرنٹ_ڈوکیومنٹ (خود): اگر خود نہیں۔ کیوئو: پرنٹ (\"پرنٹ کرنے کے لئے کوئی دستاویزات نہیں\") دوسری: دستاویز = سیلف۔ کیوئو.پپ (0) پرنٹ (\"پرنٹنگ دستاویز:\" ، دستاویز) پرنٹر_کیو = پرنٹرکیو () پرنٹر_کیو۔add_docament (\"دستاویز 1\") printer_queue.add_docament (\"دستاویز 2\") پرنٹر_کیو.ایڈ_ڈوکیومنٹ (\"دستاویز 3\") پرنٹر_کیو. پرنٹ_ڈوکیومنٹ () پرنٹر_کیو ای ڈی پرنٹ: پرنٹ: پرنٹ: پرنٹ_کیو ایو۔دستاویز: دستاویز 1 پرنٹنگ دستاویز: دستاویز 2 پرنٹنگ دستاویز: دستاویزات 3NO دستاویزات کو پرنٹ کرنے کے لئے اس مثال کے طور پر ، ہم پہلے ایک پرنٹروکیو کلاس بناتے ہیں جس میں دستاویزات کو ذخیرہ کرنے کے لئے داخلی فہرست ہوتی ہے۔اس کے بعد ہم ADD_DOCAMENT () کے طریقہ کار کا استعمال کرتے ہوئے قطار میں تین دستاویزات شامل کرتے ہیں ، اور ان کو پرنٹ_Docament () طریقہ کار کا استعمال کرتے ہوئے پرنٹ کرتے ہیں۔پرنٹ_Docament () کا طریقہ پی او پی (0) کے طریقہ کار کا استعمال کرتے ہوئے قطار کے اگلے سرے سے دستاویز کو ہٹا دیتا ہے اور اسے پرنٹ کرتا ہے۔اگر قطار میں کوئی دستاویزات نہیں ہیں تو ، یہ ایک پیغام پرنٹ کرتا ہے جس میں \"پرنٹ کرنے کے لئے کوئی دستاویزات نہیں\" کہا جاتا ہے۔ اختتام پر ، ایک قطار ایک لکیری ڈیٹا ڈھانچہ ہے جو FIFO اصول کی پیروی کرتا ہے۔یہ بہت سے ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے ملازمت کا نظام الاوقات ، نیٹ ورک پیکٹ روٹنگ ، اور چوڑائی پہلی تلاش الگورتھم۔ہم قطار کے عقبی سرے پر دستاویزات شامل کرکے اور قطار کے اگلے سرے سے ان کی درخواست کی جانے والی قطار کے اگلے سرے سے ہٹانے کے لئے ایک قطار کا استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "بائنری درخت کیا ہے؟",
        "Answer": "بائنری ٹری ایک درخت کے اعداد و شمار کا ڈھانچہ ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچے ہوسکتے ہیں۔بائنری درخت کا ہر نوڈ تین آئٹمز پر مشتمل ہوتا ہے: ایک ڈیٹا آئٹم ، بائیں بچے کا پتہ ، اور دائیں بچے کا پتہ۔ایک بائنری درخت ایک بار بار اعداد و شمار کا ڈھانچہ ہوتا ہے ، جس کا مطلب ہے کہ درخت میں ہر نوڈ کو سب ٹری کی جڑ سمجھا جاسکتا ہے۔بائنری کے درخت بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے الگورتھم کی تلاش اور چھانٹنا ، اظہار کی تشخیص ، اور فائل سسٹم۔ بائنری درختوں کی متعدد اقسام ہیں ، جن میں شامل ہیں: مکمل بائنری ٹری: ایک مکمل بائنری درخت ایک خاص قسم کا بائنری درخت ہے جس میں ہر ایک میںوالدین نوڈ/اندرونی نوڈ میں یا تو دو یا کوئی بچے نہیں ہوتے ہیں۔: ایک مکمل بائنری درخت بالکل ایک مکمل بائنری درخت کی طرح ہے ، لیکن دو بڑے اختلافات کے ساتھ - ہر سطح کو مکمل طور پر پُر ہونا چاہئے ، اور پتی کے تمام عناصر کو بائیں طرف جھکنا ہوگا۔ بائنری درختوں کو نوڈ ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے جس میں ایک کلید ہوتی ہے۔، ایک بائیں چائلڈ پوائنٹر ، اور دائیں چائلڈ پوائنٹر۔کلید نوڈ میں ذخیرہ شدہ قدر ہے ، اور بائیں اور دائیں چائلڈ پوائنٹرز بالترتیب نوڈ کے بائیں اور دائیں سبٹریز کی طرف اشارہ کرتے ہیں۔ یہاں ازگر میں بائنری درختوں کے نفاذ کی ایک مثال ہے: ازگرکلاس نوڈ: ڈیف __init __ (خود ، ، خود ،کلیدی): self.key = key self.left = کوئی بھی نہیں۔ خود نہیںروٹ. لیفٹ = نوڈ (2) روٹ۔ رائٹ = نوڈ (3) روٹ. لیفٹ.لیفٹ = نوڈ (4) روٹ۔ لیفٹ۔ رائٹ = نوڈ (5) انڈرڈر_ٹراورسل (جڑ) اس کی پیداوار ہوگی: 42513 میں ، ہم پہلے ، ہم سب سے پہلے ، ہم پہلے ہوں گے۔ایک نوڈ کلاس کی وضاحت کریں جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں ایک کلید ، بائیں بچے کا پوائنٹر ، اور دائیں چائلڈ پوائنٹر ہوتا ہے۔اس کے بعد ہم ایک انڈرور_ٹراورسل () فنکشن کی وضاحت کرتے ہیں جو بائنری درخت کا ایک ان آرڈر ٹراورسل انجام دیتا ہے ، جس کا مطلب ہے کہ یہ بائیں سب ٹری ، پھر جڑ اور پھر دائیں سب ٹری کا دورہ کرتا ہے۔آخر میں ، ہم پانچ نوڈس کے ساتھ ایک بائنری درخت بناتے ہیں اور درخت کا ایک انڈرور ٹراورسل کرتے ہیں۔ اختتام پر ، ایک بائنری ٹری ایک درخت کا ڈیٹا ڈھانچہ ہے جس میں ہر نوڈ زیادہ سے زیادہ دو بچوں میں ہوسکتا ہے۔بائنری کے درخت بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے الگورتھم کی تلاش اور چھانٹنا ، اظہار کی تشخیص ، اور فائل سسٹم۔بائنری درختوں کی متعدد اقسام ہیں ، جن میں مکمل بائنری درخت ، کامل بائنری درخت ، اور بائنری کے مکمل درخت شامل ہیں۔بائنری درختوں کو نوڈ ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے جس میں کلید ، بائیں چائلڈ پوائنٹر ، اور دائیں بچے کا پوائنٹر ہوتا ہے۔"
    },
    {
        "Question": "بائنری تلاش کا درخت کیا ہے؟",
        "Answer": "بائنری سرچ ٹری بائنری درخت کے اعداد و شمار کا ڈھانچہ ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچے ہوتے ہیں ، اور نوڈ کے بائیں بچے میں چابیاں ہوتی ہیں جو نوڈ کی کلید سے کم ہوتی ہیں ، جبکہ نوڈ کے دائیں بچے میں ایسی چابیاں ہوتی ہیں جو اس سے زیادہ ہوتی ہیں۔نوڈ کی کلیدبائنری سرچ ٹری ایک نوڈ پر مبنی ، غیر لکیری قسم کا ڈیٹا ڈھانچہ ہے جو اعداد و شمار کو بازیافت ، چھانٹنے اور تلاش کرنے کے لئے استعمال ہوتا ہے۔اسے ایک آرڈرڈ بائنری ٹری کے نام سے بھی جانا جاتا ہے کیونکہ اس کے نوڈس کو ایک خاص ترتیب میں ترتیب دیا گیا ہے۔بائنری سرچ ٹری الگورتھم کی تلاش اور چھانٹنے کے ل data ڈیٹا کا ایک مفید ڈھانچہ ہے ، اور یہ بہت سے ایپلی کیشنز ، جیسے ڈیٹا بیس ، فائل سسٹم ، اور مرتب کرنے والے میں استعمال ہوتا ہے۔ بائنری سرچ ٹری کی کچھ خصوصیات ہیں: نوڈ کے بائیں سب ٹری پر مشتمل ہے۔صرف چابیاں والی نوڈس جو نوڈ کی کلید سے کم ہیں۔ نوڈ کے دائیں سب ٹری میں صرف نوڈس ہوتے ہیں جن کی چابیاں ہوتی ہیں جو نوڈ کی کلید سے زیادہ ہوتی ہیں۔ دونوں نوڈ کے بائیں اور دائیں سبٹریوں کو بائنری تلاش کے درخت بھی ہونا چاہئے۔ وہاں ہونا ضروری ہے۔درخت میں کوئی ڈپلیکیٹ نوڈس نہیں۔ یہاں ازگر میں بائنری سرچ ٹری کے نفاذ کی ایک مثال ہے: ازگرکلاس نوڈ: ڈیف __init __ (خود ، کلید): self.key = key self.left = کوئی بھی نہیں۔کلیدی): اگر جڑ کوئی نہیں ہے: واپس نوڈ (کلید) اگر کلید <روٹ.کی: روٹ.لفٹ = داخل کریں (جڑ۔ لیفٹ ، کلید) ایلف کلید> روٹ.کی: روٹ۔ رائٹ = داخل کریں (جڑ۔ رائٹ ، کلید) روٹ ڈیف inorder_traversal (روٹ): اگر جڑ: inorder_traversal (روٹ. لیفٹ) پرنٹ (روٹ.کی) inorder_traversal (روٹ. رائٹ) جڑ = نانیروٹ = داخل کریں (جڑ ، 50) جڑ = داخل کریں (جڑ ، 30) جڑ = داخل کریں.پہلے نوڈ کلاس کی وضاحت کریں جو بائنری سرچ درخت میں نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں ایک کلید ، بائیں بچے کا پوائنٹر ، اور دائیں چائلڈ پوائنٹر ہوتا ہے۔اس کے بعد ہم ایک داخل () فنکشن کی وضاحت کرتے ہیں جو بائنری سرچ ٹری میں ایک نئی کلید داخل کرتا ہے۔فنکشن نئی کلید کے لئے مناسب پوزیشن تلاش کرنے کے لئے درخت کو بار بار عبور کرتا ہے۔آخر میں ، ہم سات نوڈس کے ساتھ ایک بائنری سرچ ٹری تیار کرتے ہیں اور درخت کا ایک ان آرڈر ٹراورسال کرتے ہیں۔ اختتام پر ، بائنری سرچ ٹری بائنری درختوں کا ڈیٹا ڈھانچہ ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچے ہوتے ہیں ، اور نوڈ کا بائیں بچہایسی چابیاں ہیں جو نوڈ کی کلید سے کم ہیں ، جبکہ نوڈ کے دائیں بچے میں چابیاں شامل ہیں جو نوڈ کی کلید سے زیادہ ہیں۔یہ الگورتھم کی تلاش اور چھانٹنے کے لئے ایک مفید ڈیٹا ڈھانچہ ہے ، اور یہ بہت سے ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے ڈیٹا بیس ، فائل سسٹم ، اور مرتب کرنے والے۔"
    },
    {
        "Question": "ہیش ٹیبل کیا ہے؟",
        "Answer": "ایک ہیش ٹیبل ایک ڈیٹا ڈھانچہ ہے جو کلیدی قدر کے جوڑے ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔یہ انڈیکس کی گنتی کے لئے ہیش فنکشن کا استعمال کرتا ہے جس میں کسی عنصر کو داخل یا تلاش کیا جائے گا۔ایک اچھے ہیش فنکشن کا استعمال کرکے ، ہیشنگ اچھی طرح سے کام کر سکتی ہے۔معقول مفروضوں کے تحت ، ہیش ٹیبل میں کسی عنصر کی تلاش کے لئے درکار اوسط وقت O (1) ہے۔ایک ہیش ٹیبل ایک تجریدی ڈیٹا کی قسم ہے جو اقدار کے لئے چابیاں کا نقشہ بناتی ہے۔یہ بہت سارے قسم کے کمپیوٹر سافٹ ویئر میں بڑے پیمانے پر استعمال ہوتا ہے ، خاص طور پر ایسوسی ایٹو اریوں ، ڈیٹا بیس انڈیکسنگ ، کیچز ، اور سیٹس کے لئے۔ اے ہیش ٹیبل دو بڑے اجزاء پر مشتمل ہے: ایک سرنی اور ایک ہیش فنکشن۔سرنی کو کلیدی قدر کے جوڑے ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے ، اور ہیش فنکشن سرنی کے اشاریہ کی گنتی کے لئے استعمال ہوتا ہے جہاں کلیدی قیمت کی جوڑی محفوظ ہوگی۔ہیش فنکشن کلید کو ان پٹ کے طور پر لیتا ہے اور صف میں ایک انڈیکس لوٹاتا ہے۔ہیش فنکشن کو اس طرح ڈیزائن کیا جانا چاہئے کہ وہ سرنی کے پار یکساں طور پر چابیاں تقسیم کرے۔ ہیش ٹیبلز بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جن میں ڈیٹا بیس ، سرچ انجن اور کیچنگ سسٹم شامل ہیں۔وہ موثر اسٹوریج اور ڈیٹا کی بازیافت کی اجازت دیتے ہیں ، جس سے وہ بہت سے کمپیوٹر پروگراموں کے لئے ایک اہم ذریعہ بن جاتے ہیں۔ہیش ٹیبلز اقدار کے مکمل ہیش کوڈز کو بھی اسٹور کرسکتے ہیں ، جو اسکیننگ کو ایک بالٹی کو تیز رفتار بناتے ہیں۔چابیاں پر مساوات کے مکمل ٹیسٹ کرنے کی ضرورت نہیں ہے اگر ان کے ہیش کوڈ مماثل نہیں ہیں۔ اختتام پر ، ایک ہیش ٹیبل ایک ڈیٹا ڈھانچہ ہے جو کلیدی قیمت کے جوڑے کو ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔یہ انڈیکس کی گنتی کے لئے ہیش فنکشن کا استعمال کرتا ہے جس میں کسی عنصر کو داخل یا تلاش کیا جائے گا۔ہیش ٹیبل بڑے پیمانے پر کمپیوٹر سافٹ ویئر میں بڑے پیمانے پر استعمال ہوتے ہیں ، خاص طور پر ایسوسی ایٹو اریوں ، ڈیٹا بیس انڈیکسنگ ، کیچز اور سیٹ کے لئے۔وہ موثر اسٹوریج اور ڈیٹا کی بازیافت کی اجازت دیتے ہیں ، جس سے وہ بہت سے کمپیوٹر پروگراموں کے لئے ایک اہم ٹول بناتے ہیں۔"
    },
    {
        "Question": "ایک گراف کیا ہے؟",
        "Answer": "ایک گراف ایک غیر لکیری ڈیٹا ڈھانچہ ہے جس میں عمودی کا ایک سیٹ ہوتا ہے (جسے نوڈس بھی کہا جاتا ہے) اور کناروں پر مشتمل ہوتا ہے جو ان عمودی کو جوڑتے ہیں۔اشیاء کے مابین رابطوں کے نیٹ ورک کی نمائندگی کرنے کے لئے ایک گراف کا استعمال کیا جاتا ہے۔عمودی اشیاء کی نمائندگی کرتے ہیں ، اور کنارے ان کے مابین رابطوں کی نمائندگی کرتے ہیں۔گراف کا استعمال بہت سے حقیقی دنیا کے مسائل کو حل کرنے کے لئے کیا جاتا ہے ، جیسے دو نکات کے مابین مختصر ترین راستہ تلاش کرنا ، سوشل نیٹ ورکس کی ماڈلنگ کرنا ، اور کمپیوٹر نیٹ ورکس کی نمائندگی کرنا۔ گراف سے متعلق کچھ کلیدی تصورات ہیں: ورٹیکس: ایک ورٹیکس گراف میں ایک نوڈ ہے۔یہ نیٹ ورک میں کسی شے یا کسی نقطہ کی نمائندگی کرتا ہے۔ ایج: ایک کنارے دو عمودی کے درمیان تعلق ہے۔یہ نیٹ ورک میں دو اشیاء یا پوائنٹس کے مابین تعلقات یا رابطے کی نمائندگی کرتا ہے۔ ہدایت شدہ گراف: ایک ہدایت والا گراف ایک گراف ہے جس میں کناروں کی سمت ہوتی ہے۔اس کا مطلب یہ ہے کہ کناروں میں ایک ابتدائی ورٹیکس اور ایک اختتامی ورٹیکس ہوتا ہے۔اس کا مطلب یہ ہے کہ کنارے بغیر کسی خاص سمت کے دو عمودی کو جوڑتے ہیں۔ وزن والا گراف: وزن والا گراف ایک گراف ہے جس میں کناروں کا وزن یا ان سے وابستہ لاگت ہوتی ہے۔اس کا مطلب یہ ہے کہ کناروں کی ایک قیمت ہے جو اس ایج کو عبور کرنے کی قیمت کی نمائندگی کرتی ہے۔ گراف کو مختلف طریقوں سے پیش کیا جاسکتا ہے ، جیسے ملحقہ میٹرکس ، ملحقہ فہرست ، اور ایج لسٹ۔نمائندگی کا انتخاب مخصوص استعمال کے معاملے اور جگہ اور وقت کی پیچیدگی کے مابین تجارتی تعلقات پر منحصر ہوتا ہے۔ اختتام پر ، ایک گراف ایک غیر لکیری ڈیٹا ڈھانچہ ہے جس میں عمودی اور کناروں کا ایک مجموعہ ہوتا ہے جو ان عمودیوں کو جوڑتا ہے۔گراف کو اشیاء کے مابین رابطوں کے نیٹ ورک کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے اور بہت سے حقیقی دنیا کے مسائل حل کرنے کے لئے استعمال ہوتے ہیں۔گراف کی نمائندگی مختلف طریقوں سے کی جاسکتی ہے ، جیسے ملحق میٹرکس ، ملحقہ فہرست ، اور ایج کی فہرست۔"
    },
    {
        "Question": "چوڑائی کی پہلی تلاش اور گہرائی کی پہلی تلاش میں کیا فرق ہے؟",
        "Answer": "چوڑائی کی پہلی تلاش (بی ایف ایس) اور گہرائی سے پہلے تلاش (ڈی ایف ایس) دو الگورتھم ہیں جو کسی گراف یا درخت کو عبور کرنے کے لئے استعمال ہوتے ہیں۔بی ایف ایس اور ڈی ایف ایس کے مابین کچھ اختلافات یہ ہیں: چوڑائی کی پہلی تلاش: بی ایف ایس پرتوں میں موجود تمام عمودیوں کا دورہ کرتا ہے ، ماخذ ورٹیکس سے باہر کی طرف بڑھتا ہے۔شروع ہونے والے عمودی سے کسی دیئے گئے ورٹیکس تک مختصر ترین راستہ تلاش کریں۔ بی ایف ایس کی ضمانت دی جاتی ہے کہ وہ بغیر وزن والے گراف میں مختصر ترین راستہ تلاش کریں۔ایک حل کے لئے درخت۔ ڈیپتھ فرسٹ تلاش: دوسری شاخوں کو تلاش کرنے کے لئے بیک ٹریکنگ سے پہلے ڈی ایف ایس زیادہ سے زیادہ گہرا ہوتا ہے۔ ڈی ایف ایس اگلے دورے کے لئے عمودی کو ٹریک رکھنے کے لئے اسٹیک یا تکرار کا استعمال کرتا ہے۔ ڈی ایف عام طور پر استعمال ہوتا ہے جب آپ کو تلاش کرنے کی ضرورت ہوتی ہےپورے ٹری ڈاٹ ڈی ایف ایس کو بی ایف ایس کے مقابلے میں تکرار کا استعمال کرتے ہوئے نافذ کرنا آسان ہے اور اس میں کم ریاست کی ضرورت ہوتی ہے۔ ڈی ایف اکثر حقیقی دنیا میں کھیلوں اور کھیل جیسے حالات میں استعمال ہوتا ہے۔ خلاصہ میں ، بی ایف ایس اور ڈی ایف دو الگورتھم ہیں جو گراف کو عبور کرنے کے لئے استعمال ہوتے ہیں اورایک درخت.بی ایف ایس سورس ورٹیکس سے باہر کی طرف بڑھتے ہوئے پرتوں میں تمام عمودی کا دورہ کرتا ہے ، جبکہ ڈی ایف ایس دوسری شاخوں کی تلاش کے ل back بیک ٹریکنگ سے پہلے زیادہ سے زیادہ گہرائی میں جاتا ہے۔بی ایف ایس اگلے دورے کے لئے عمودی کو ٹریک رکھنے کے لئے قطار کے ڈیٹا ڈھانچے کا استعمال کرتا ہے ، جبکہ ڈی ایف ایس اسٹیک یا تکرار کا استعمال کرتا ہے۔بی ایف ایس کا استعمال شروعاتی ورٹیکس سے کسی دیئے گئے ورٹیکس تک مختصر ترین راستہ تلاش کرنے کے لئے کیا جاتا ہے ، جبکہ ڈی ایف ایس عام طور پر استعمال ہوتا ہے جب آپ کو پورے درخت کو تلاش کرنے کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "ڈھیر کیا ہے؟",
        "Answer": "ایک ڈھیر درخت پر مبنی ایک خصوصی ڈیٹا ڈھانچہ ہے جو ڈیٹا کو موثر انداز میں ذخیرہ کرنے اور بازیافت کرنے کے لئے استعمال ہوتا ہے۔یہ ایک مکمل بائنری درخت ہے جہاں ہر نوڈ کی ایک کلید ہوتی ہے جو (زیادہ سے زیادہ ڈھیر میں) سے زیادہ یا اس کے برابر ہوتی ہے یا اس سے کم یا اس کے برابر (ایک منٹ کے ڈھیر میں) اپنے بچوں کی چابیاں۔ہیپ پراپرٹی اس بات کو یقینی بناتی ہے کہ ڈھیر کا جڑ نوڈ ہمیشہ ہی زیادہ سے زیادہ (زیادہ سے زیادہ ہیپ میں) یا کم سے کم (ایک منٹ کے ڈھیر میں) ڈھیر میں ہوتا ہے۔ ایچ ای اے پی ایس بہت سے ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے الگورتھم ، ترجیحی قطاریں ، اورگراف الگورتھم۔وہ عناصر کو موثر داخل کرنے اور حذف کرنے کی اجازت دیتے ہیں ، اور وہ ڈھیر میں زیادہ سے زیادہ یا کم سے کم عنصر کو جلدی سے تلاش کرنے کا ایک طریقہ فراہم کرتے ہیں۔ دو قسم کے ڈھیر ہیں: زیادہ سے زیادہ ہیپ اور من ہیپ۔زیادہ سے زیادہ ڈھیر میں ، روٹ نوڈ کی زیادہ سے زیادہ کلیدی قیمت ہوتی ہے ، اور بچوں کے تمام نوڈس والدین نوڈ سے کم یا اس کے برابر کلیدی اقدار رکھتے ہیں۔ایک منٹ کے ڈھیر میں ، روٹ نوڈ کی کم سے کم کلیدی قیمت ہوتی ہے ، اور بچوں کے تمام نوڈس والدین نوڈ سے زیادہ یا اس کے برابر کلیدی اقدار رکھتے ہیں۔ وہ سرے یا درخت کے اعداد و شمار کے ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔سرنی پر مبنی نفاذ میں ، ڈھیر ایک صف میں محفوظ کیا جاتا ہے ، اور والدین کے بچوں کے تعلقات کا تعین صف کے عناصر کے اشارے سے ہوتا ہے۔درختوں پر مبنی نفاذ میں ، ڈھیر کو بائنری ٹری کے طور پر محفوظ کیا جاتا ہے ، اور والدین کے بچے کے تعلقات نوڈس کے درمیان پوائنٹرز کے ذریعہ طے کیے جاتے ہیں۔ آخر میں ، ایک ڈھیر درخت پر مبنی ایک خصوصی ڈیٹا ڈھانچہ ہے جو اسٹور کے لئے استعمال ہوتا ہے اورڈیٹا کو موثر انداز میں بازیافت کریں۔یہ ایک مکمل بائنری درخت ہے جہاں ہر نوڈ کی ایک کلید ہوتی ہے جو (زیادہ سے زیادہ ڈھیر میں) سے زیادہ یا اس کے برابر ہوتی ہے یا اس سے کم یا اس کے برابر (ایک منٹ کے ڈھیر میں) اپنے بچوں کی چابیاں۔ڈھیر بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے الگورتھم ، ترجیحی قطار اور گراف الگورتھم کو چھانٹنا۔ان کو سرنی یا درخت کے اعداد و شمار کے ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔"
    },
    {
        "Question": "زیادہ سے زیادہ ڈھیر اور ایک منٹ کے ڈھیر کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "ڈھیر درخت پر مبنی ڈیٹا ڈھانچہ ہے جو مستقل وقت میں درخت میں کم سے کم اور زیادہ سے زیادہ عنصر تک رسائی کی اجازت دیتا ہے۔ڈھیروں کی دو اقسام ہیں: کم سے کم اور زیادہ سے زیادہ ہیپ۔ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر کے درمیان بنیادی فرق وہ ترتیب ہے جس میں عناصر کا اہتمام کیا جاتا ہے۔ایک منٹ کے ڈھیر میں ، جڑ نوڈ میں کم سے کم کلیدی عنصر ہوتا ہے ، جبکہ زیادہ سے زیادہ ڈھیر میں ، جڑ نوڈ میں زیادہ سے زیادہ کلیدی عنصر ہوتا ہے۔یہاں ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر کے درمیان کچھ کلیدی اختلافات ہیں: من ڈھیر: بچوں کے نوڈس کے مقابلے میں جڑ یا والدین کا نوڈ عام طور پر قدر میں کم ہوتا ہے۔ کم سے کم کلیدی عنصر جڑ نوڈ پر موجود ہے۔ سب سے چھوٹا عنصر تک رسائی حاصل ہے۔مستقل وقت کے اندر چونکہ یہ انڈیکس پر ہے 1. اے منٹ ہیپ کو ڈھیر میں کم سے کم عنصر تک رسائی حاصل کرنے کے لئے استعمال کیا جاتا ہے۔ میکس ہیپ: بچوں کے نوڈس کے مقابلے میں جڑ یا والدین کا نوڈ عام طور پر قدر میں زیادہ ہوتا ہے۔ زیادہ سے زیادہ کلیدی عنصر موجود ہےروٹ نوڈ پر۔ سب سے بڑے عنصر کو مستقل وقت کے اندر حاصل کیا جاتا ہے کیونکہ یہ انڈیکس 1. پر ہے۔ ایک زیادہ سے زیادہ ہیپ ڈھیر میں زیادہ سے زیادہ عنصر تک رسائی حاصل کرنے کے لئے استعمال ہوتا ہے۔ دو منٹ ہیپ اور میکس ہیپ کے اپنے فوائد اور نقصانات ہیں۔جب آپ کو ڈھیر میں سب سے چھوٹا عنصر تلاش کرنے کی ضرورت ہوتی ہے تو ایک منٹ کا ڈھیر مفید ہوتا ہے ، جب کہ جب آپ کو ڈھیر میں سب سے بڑا عنصر تلاش کرنے کی ضرورت ہوتی ہے تو زیادہ سے زیادہ ڈھیر مفید ہوتا ہے۔جس کا انتخاب استعمال کرنے کے لئے ہے اس کا انحصار مخصوص استعمال کے معاملے اور ایپلی کیشن کی ضروریات پر ہوتا ہے۔ اختتام پر ، ڈھیر درخت پر مبنی ڈیٹا ڈھانچہ ہے جو مستقل وقت میں درخت میں کم سے کم اور زیادہ سے زیادہ عنصر تک رسائی کی اجازت دیتا ہے۔ڈھیروں کی دو اقسام ہیں: کم سے کم اور زیادہ سے زیادہ ہیپ۔ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر کے درمیان بنیادی فرق وہ ترتیب ہے جس میں عناصر کا اہتمام کیا جاتا ہے۔ڈھیر میں کم سے کم عنصر تک رسائی کے لئے ایک منٹ کا ڈھیر استعمال کیا جاتا ہے ، جبکہ ڈھیر میں زیادہ سے زیادہ عنصر تک رسائی کے لئے ایک زیادہ سے زیادہ ڈھیر استعمال کیا جاتا ہے۔جس کا انتخاب استعمال کرنا ہے اس کا انحصار مخصوص استعمال کے معاملے اور درخواست کی ضروریات پر ہوتا ہے۔"
    },
    {
        "Question": "ترجیحی قطار کیا ہے؟",
        "Answer": "ترجیحی قطار قطار کی ایک قسم ہے جو ان کی ترجیحی اقدار کی بنیاد پر عناصر کا اہتمام کرتی ہے۔اعلی ترجیحی اقدار والے عناصر کو عام طور پر کم ترجیحی اقدار والے عناصر سے پہلے بازیافت کیا جاتا ہے۔ترجیحی قطار میں ، ہر عنصر ترجیحی قیمت سے وابستہ ہوتا ہے ، اور عناصر کو ان کی ترجیح کی بنیاد پر پیش کیا جاتا ہے۔ترجیحی قطار مندرجہ ذیل خصوصیات کے ساتھ قطار کے اعداد و شمار کے ڈھانچے کی توسیع ہے: ہر شے کی اس سے وابستہ ترجیح ہوتی ہے۔ اعلی ترجیح کے حامل عنصر کو کم ترجیح کے حامل عنصر سے پہلے ہی اس کی ترجیح دی جاتی ہے۔ اگر دو عناصر ایک ہی ترجیح رکھتے ہیں تو ، ان کی خدمت کی جاتی ہے۔قطار میں ان کے آرڈر کے مطابق۔ ترجیحی قطار کو نافذ کرنے کے متعدد طریقے ہیں ، بشمول ایک صف ، منسلک فہرست ، ڈھیر ، یا بائنری سرچ ٹری کا استعمال۔ہر طریقہ کار کے اپنے فوائد اور نقصانات ہوتے ہیں ، اور بہترین انتخاب آپ کی درخواست کی مخصوص ضروریات پر منحصر ہوگا۔ پریوریٹی قطاریں اکثر ریئل ٹائم سسٹم میں استعمال ہوتی ہیں ، جہاں جس ترتیب میں عناصر پر کارروائی کی جاتی ہے اس کے اہم نتائج برآمد ہوسکتے ہیں۔ان کی افادیت کو بہتر بنانے کے لئے الگورتھم میں بھی استعمال کیا جاتا ہے ، جیسے گراف میں مختصر ترین راستہ تلاش کرنے کے لئے ڈیجکسٹرا کے الگورتھم اور پاتھ فائنڈنگ کے لئے* تلاش الگورتھم۔اقدار۔اعلی ترجیحی اقدار والے عناصر کو عام طور پر کم ترجیحی اقدار والے عناصر سے پہلے بازیافت کیا جاتا ہے۔ترجیحی قطاریں بہت سے ایپلی کیشنز میں استعمال کی جاتی ہیں ، جیسے ان کی افادیت کو بہتر بنانے کے لئے ریئل ٹائم سسٹم اور الگورتھم۔ترجیحی قطار کو نافذ کرنے کے بہت سارے طریقے ہیں ، اور بہترین انتخاب آپ کی درخواست کی مخصوص ضروریات پر منحصر ہوگا۔"
    },
    {
        "Question": "ایک ٹری کیا ہے؟",
        "Answer": "ایک ٹرائی ، جسے ایک سابقہ درخت یا ڈیجیٹل درخت بھی کہا جاتا ہے ، درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ڈیٹا کے ایک سیٹ میں تاروں کو موثر انداز میں اسٹور کرنے اور تلاش کرنے کے لئے استعمال ہوتا ہے۔نام \"ٹری\" لفظ \"بازیافت\" سے آیا ہے ، جو اس کے تاروں کو موثر انداز میں بازیافت کرنے کے بنیادی اطلاق کی عکاسی کرتا ہے۔ایک ٹری شاخوں کے ذریعہ منسلک نوڈس پر مشتمل ہے ، ہر ایک تار میں ایک ہی کردار کی نمائندگی کرتا ہے۔روٹ نوڈ عام طور پر خالی ہوتا ہے یا اس کی ایک خاص قیمت ہوتی ہے ، جبکہ پتی کے نوڈس تار کے اختتام کی نشاندہی کرتے ہیں۔جب ہم جڑ کے نوڈ سے پتے کے نوڈ تک جاتے ہیں تو ، ہم ہر نوڈ کے ذریعہ پیش کردہ کرداروں کو ہم آہنگ کرکے تار تیار کرتے ہیں۔ یہاں ایک ٹری کی کچھ اہم خصوصیات ہیں: ایک ٹرائی میں ہر نوڈ ایک تار میں ایک کردار کی نمائندگی کرتا ہے۔ جڑ نوڈ نمائندگی کرتا ہے۔ایک خالی تار۔ پتی کے نوڈس تار کے اختتام کی نمائندگی کرتے ہیں۔ روٹ نوڈ سے پتی نوڈ تک کا راستہ ایک تار کی نمائندگی کرتا ہے۔ سیرتیں اکثر تلاش اور آٹو تکمیل جیسے کاموں میں استعمال ہوتی ہیں ، جہاں تار کے ایک بڑے ڈیٹاسیٹ کی ضرورت ہوتی ہے۔موثر انداز میں ذخیرہ ، جانچ پڑتال ، یا تلاش کی جا .۔ دیگر اعداد و شمار کے ڈھانچے ، جیسے ہیش ٹیبلز اور بائنری تلاش کے درختوں کے مقابلے میں کئی فوائد ہیں۔وہ موثر سابقہ تلاشیوں کی اجازت دیتے ہیں ، جس کا مطلب ہے کہ آپ ٹری میں موجود تمام ڈوروں کو جلدی سے تلاش کرسکتے ہیں جو کسی دیئے گئے سابقہ سے شروع ہوتے ہیں۔کوششیں ہیش ٹیبلز کے مقابلے میں کم میموری کا استعمال بھی کرتی ہیں ، اور وہ کچھ کاموں کے لئے بائنری تلاش کے درختوں سے تیز تر ہوسکتی ہیں۔ اختتام پر ، ایک ٹری ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ڈیٹا کے ایک سیٹ میں تاروں کو موثر انداز میں اسٹور کرنے اور تلاش کرنے کے لئے استعمال ہوتا ہے۔اس میں شاخوں کے ذریعہ منسلک نوڈس شامل ہیں ، ہر ایک تار میں ایک ہی کردار کی نمائندگی کرتا ہے۔کوششوں کو اکثر تلاش اور آٹو تکمیل جیسے کاموں میں استعمال کیا جاتا ہے ، جہاں تاروں کے ایک بڑے ڈیٹاسیٹ کو موثر انداز میں ذخیرہ کرنے ، جانچ پڑتال کرنے یا تلاش کرنے کی ضرورت ہوتی ہے۔کوششوں کے دیگر اعداد و شمار کے ڈھانچے پر کئی فوائد ہیں ، جیسے ہیش ٹیبلز اور بائنری تلاش کے درخت۔"
    },
    {
        "Question": "سرخ سیاہ درخت کیا ہے؟",
        "Answer": "ایک سرخ رنگ کا درخت ایک خود متوازن بائنری سرچ درخت ہے جس کی ایجاد 1972 میں روڈولف بایر نے کی تھی جس نے اسے \"توازن بائنری بی ٹری\" کہا تھا۔یہ بائنری سرچ ٹری کی ایک شکل ہے اور اس کی کارروائیوں کے لئے اسی طرح کی پیچیدگی کی ضمانت دیتا ہے اور تلاش ، اندراج اور حذف کرنے کے طور پر استعمال کرنے کے لئے موثر ہے۔یہ سب O (لاگ ان) وقت میں کیا جاسکتا ہے ، جہاں درخت میں نوڈس کی تعداد ہے۔ایک سرخ رنگ کا درخت ایک بائنری تلاش کا درخت ہے جس میں ہر نوڈ کا رنگ ہوتا ہے جو سرخ یا سیاہ ہوتا ہے۔جڑ نوڈ ہمیشہ سیاہ ہوتا ہے ، اور ہر پتی نوڈ سیاہ ہوتا ہے۔ہر سرخ نوڈ میں اس کے دونوں بچوں کو رنگین رنگ کا رنگ ہوتا ہے ، اور اس میں کوئی دو ملحقہ سرخ نوڈس نہیں ہیں۔جڑ سے پتی نوڈ تک ہر راستے میں ایک ہی تعداد میں سیاہ نوڈس ہوتے ہیں۔سرخ رنگ کے درخت کا مقصد متوازن رہنا ہے ، جو اس بات کو یقینی بناتا ہے کہ اس کی مشترکہ کاروائیاں ، جیسے تلاش اور حذف کریں ، کبھی بھی O (n*لاگ (N)) سے بھی بدتر نہیں ہوتا ہے۔بائنری سرچ درخت کو سرخ سیاہ درخت میں تبدیل کرنے کے لئے درکار تبدیلیاں سختی سے اضافی ہیں۔اس کا مطلب یہ ہے کہ ، ایک سرخ رنگ کا درخت ایک معیاری بائنری سرچ درخت ہے جو اضافی حملہ آوروں کو برقرار رکھتا ہے۔سرخ سیاہ درخت بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹمز۔"
    },
    {
        "Question": "بی ٹری کیا ہے؟",
        "Answer": "بی ٹری ایک خود توازن رکھنے والا درختوں کا ڈیٹا ڈھانچہ ہے جو بڑی مقدار میں ڈیٹا کو موثر انداز میں ذخیرہ کرنے اور بازیافت کرنے کے لئے استعمال ہوتا ہے۔یہ بائنری سرچ ٹری کی عام کاری ہے جس میں ہر نوڈ کے دو سے زیادہ بچے ہوسکتے ہیں۔بی ٹری کو ڈیٹا کو بازیافت یا ترمیم کرنے کے لئے درکار ڈسک تک رسائی کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیا گیا ہے ، جس سے یہ ڈیٹا بیس اور فائل سسٹم میں استعمال کے ل well مناسب ہے۔بی ٹری کی کچھ اہم خصوصیات یہ ہیں: ایک بی ٹری ایک خود توازن رکھنے والے درختوں کے اعداد و شمار کا ڈھانچہ ہے جو ترتیب شدہ ڈیٹا کو برقرار رکھتا ہے اور تلاش ، ترتیب تک رسائی ، اضافے اور حذف ہونے کی اجازت دیتا ہے۔بائنری سرچ ٹری ، دو سے زیادہ بچوں کے ساتھ نوڈس کی اجازت دیتا ہے۔ ایک بی ٹری اسٹوریج سسٹم کے ل well مناسب ہے جو ڈیٹا کے نسبتا large بڑے بلاکس ، جیسے ڈیٹا بیس اور فائل سسٹم کو پڑھتا اور لکھتا ہے۔ آرڈر ایم کا بی ٹری ایم ہے۔ایک درخت جس میں ہر نوڈ میں زیادہ تر ایم بچوں اور کم از کم ایم/2 بچے ہوتے ہیں۔ ایک بی ٹری متوازن ہے ، جس کا مطلب ہے کہ درخت کی اونچائی چھوٹی رکھی جاتی ہے ، اس بات کو یقینی بناتے ہوئے کہ ڈسک تک رسائی کی تعداد بازیافت یا اس میں ترمیم کرنے کے لئے درکار ہےڈیٹا کو کم سے کم کیا جاتا ہے۔ بی ٹیرز بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، فائل سسٹم ، اور سرچ انجن۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار ڈسک تک رسائی کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیز رسائی کی ضرورت ہوتی ہے۔ اختتام پر ، بی ٹری خود توازن درخت کا ڈیٹا ہے۔ڈھانچہ جو بڑی مقدار میں ڈیٹا کو موثر انداز میں ذخیرہ کرنے اور بازیافت کرنے کے لئے استعمال ہوتا ہے۔یہ بائنری سرچ ٹری کی عام کاری ہے جس میں ہر نوڈ کے دو سے زیادہ بچے ہوسکتے ہیں۔بی ٹریوں کو بہت سے ایپلی کیشنز میں استعمال کیا جاتا ہے ، جیسے ڈیٹا بیس ، فائل سسٹم ، اور سرچ انجن۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار ڈسک تک رسائی کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں ڈیٹا کی بڑی مقدار میں تیزی سے رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "طبقہ کا درخت کیا ہے؟",
        "Answer": "ایک طبقہ کا درخت درخت پر مبنی ڈیٹا ڈھانچہ ہے جو کسی صف میں متعدد رینج کے سوالات کا موثر انداز میں جواب دینے کے لئے استعمال ہوتا ہے۔اس سے ہمیں کسی عنصر یا علامتی وقت میں کسی عنصر کی جگہ لے کر صف میں ترمیم کرنے کی اجازت ملتی ہے۔ایک طبقہ کا درخت ایک بائنری درخت ہوتا ہے جس میں ہر نوڈ ایک حد کے بارے میں معلومات محفوظ کرتا ہے ، جو مسئلے پر منحصر ہوتا ہے۔عام طور پر ، ایک طبقہ کا درخت ایک بہت ہی لچکدار ڈیٹا ڈھانچہ ہے ، اور اس کے ساتھ بہت ساری پریشانیوں کو حل کیا جاسکتا ہے۔یہاں ایک طبقہ کے درخت کی کچھ اہم خصوصیات ہیں: ایک طبقہ کا درخت بائنری درخت کے اعداد و شمار کا ڈھانچہ ہوتا ہے جیسے ہر نوڈ ایک حد کے بارے میں معلومات محفوظ کرتا ہے۔ ایک طبقہ کے درخت کو ایک سرنی پر متعدد رینج کے سوالات کو موثر انداز میں جواب دینے کے لئے استعمال کیا جاتا ہے۔ ایک طبقہ کا درخت ہمیں اجازت دیتا ہے۔کسی عنصر یا عناصر کی پوری رینج کی جگہ لے کر اس میں ترمیم کریں۔مختلف قسم کی معلومات کو ذخیرہ کرنے کے لئے جیسے حد سے زیادہ سے زیادہ ، رینج سم ، رینج XOR ، وغیرہ۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار ڈسک تک رسائی کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیز رفتار رسائی کی ضرورت ہوتی ہے۔طبقہ کے درختوں کو رینج کے استفسار کے مسائل کو حل کرنے کے لئے استعمال کیا جاسکتا ہے جیسے کسی حد میں کم سے کم ، زیادہ سے زیادہ ، یا عناصر کی رقم تلاش کرنا۔ان کا استعمال رینج اپ ڈیٹ کے مسائل کو حل کرنے کے لئے بھی کیا جاسکتا ہے جیسے تمام عناصر کو ایک نئی قدر میں اپ ڈیٹ کرنا۔"
    },
    {
        "Question": "فینوک درخت کیا ہے؟",
        "Answer": "ایک فینوک درخت ، جسے بائنری انڈیکسڈ ٹری (BIT) بھی کہا جاتا ہے ، ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ایک صف میں متعدد رینج کے سوالات کو موثر انداز میں جواب دینے کے لئے استعمال ہوتا ہے۔اس سے ہمیں کسی عنصر یا علامتی وقت میں کسی عنصر کی جگہ لے کر صف میں ترمیم کرنے کی اجازت ملتی ہے۔ایک فینوک درخت کو عام طور پر ایک صف کے طور پر نافذ کیا جاتا ہے اور عددی چابیاں کے ٹکڑوں کا استعمال کرتے ہوئے اس کی ترتیب دی جاتی ہے۔یہ انٹیجر کیز رینج [1 ... n] میں گرتی ہیں ، 0. اسکیپنگ 0.متعلقہ فینوک درخت کی جڑ پر ایک مضمر نوڈ 0 کے ساتھ نوڈس ہیں۔درخت کی ہر سطح میں نوڈس ہوتے ہیں جن میں اشاریوں کے ساتھ 2 کی الگ الگ طاقتوں کی رقم ہوتی ہے (0 خالی رقم 0 کی نمائندگی کرنے کے ساتھ)۔دیئے گئے نوڈ کے والدین کو اس کے انڈیکس میں آخری سیٹ بٹ (ایل ایس بی) صاف کرکے پایا جاسکتا ہے ، جو اس کی رقم میں 2 کی سب سے چھوٹی طاقت کے مطابق ہے۔فینوک ٹری زیادہ تر استعمال ہوتا ہے جب ہمیں ایک صف دی گئی ہے اور ہمیں متعدد بار یا////اور ہمیں کئی بار عناصر کی رقم تلاش کرنے کی ضرورت ہے ، اور ہمیں اس کی بھی ضرورت ہے کہ ہمیں متعدد بار عناصر کا مجموعہ تلاش کرنے کی ضرورت ہے۔کسی بھی خاص انڈیکس کی قیمت کو اپ ڈیٹ کرنے کے لئے متعدد اپ ڈیٹ آپریشن انجام دیں۔فینوک ٹری استعمال اور کوڈ آسان ہے ، خاص طور پر کثیر جہتی صفوں کی صورت میں۔طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کے مقابلے میں ، فینوک ٹری کم جگہ استعمال کرتا ہے اور اس پر عمل درآمد آسان ہے۔فینوک ٹری کا ایک نقصان یہ ہے کہ اسے صرف ایک آپریشن کے ساتھ استعمال کیا جاسکتا ہے جو الٹا ہے۔مثال کے طور پر ، اس کے علاوہ ایک الٹ ایبل آپریشن ہے: اگر A + B = C پھر C - A = B (جہاں - اضافے کے الٹا کے طور پر کام کرتا ہے)"
    },
    {
        "Question": "AVL درخت کیا ہے؟",
        "Answer": "ایک AVL درخت ایک خود متوازن بائنری تلاش کا درخت ہے جس میں کسی بھی نوڈ کے دو بچوں کے ذیلی حصے کی اونچائی زیادہ سے زیادہ ایک سے مختلف ہوتی ہے۔اگر کسی بھی وقت وہ ایک سے زیادہ مختلف ہوتے ہیں تو ، اس پراپرٹی کو بحال کرنے کے لئے توازن پیدا کیا جاتا ہے۔اے وی ایل کے درختوں کا نام ان کے موجدوں ایڈیلسن ویلسکی اور لینڈس کے نام پر رکھا گیا ہے۔یہاں ایک AVL درخت کی کچھ اہم خصوصیات ہیں: ایک AVL درخت ایک بائنری تلاش کا درخت ہے جس میں کسی بھی نوڈ کے دو بچوں کے ذیلی ذخیرے کی اونچائی زیادہ سے زیادہ ایک سے مختلف ہوتی ہے۔ اے وی ایل درخت خود توازن رکھتے ہیں ، جس کا مطلب ہے کہ وہ خود بخود ان کو ایڈجسٹ کرتے ہیں۔ہر نوڈ کے توازن عنصر کو برقرار رکھنے کے لئے ڈھانچہ۔ لیک اپ ، اندراج ، اور حذف کرنے والے سب اوسط اور بدترین دونوں ہی صورتوں میں O (لاگ این) وقت لیتے ہیں ، جہاں N آپریشن سے پہلے درخت میں نوڈس کی تعداد ہوتی ہے۔ درخت ہیں۔اکثر سرخ رنگ کے درختوں کے ساتھ موازنہ کیا جاتا ہے کیونکہ دونوں ایک ہی کاموں کی حمایت کرتے ہیں اور بنیادی کارروائیوں کے لئے وقت نکالتے ہیں۔ اے وی ایل درخت بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے اور آپریٹنگ سسٹم۔وہ اعداد و شمار کو بازیافت یا ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیز رسائی کی ضرورت ہوتی ہے۔ اختتام پر ، ایک اے وی ایل کا درخت خود سے متوازن بائنری سرچ ٹری ہے۔جس میں کسی بھی نوڈ کے دو بچوں کے ذیلی ذیلی حصے کی اونچائی زیادہ سے زیادہ ایک سے مختلف ہوتی ہے۔اے وی ایل کے درخت بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیزی سے رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "لاحقہ درخت کیا ہے؟",
        "Answer": "ایک لاحقہ درخت ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو تار میں ذیلی ذخیروں کو اسٹور کرنے اور تلاش کرنے کے لئے استعمال ہوتا ہے۔یہ ایک کمپریسڈ ٹری ہے جس میں دیئے گئے متن کے تمام لاحقہ پر مشتمل ہے۔لاحقہ درخت ایک کمپریسڈ درخت ہے جس میں دیئے گئے ٹیکسٹ سٹرنگ ٹی لمبائی ن کرداروں کے تمام لاحقہ پر مشتمل ہے۔ٹیکسٹ سٹرنگ ٹی میں ہر لاحقہ کی پوزیشنوں کو لاحقہ درخت کے پتے پر انٹیجر انڈیکس کے طور پر ریکارڈ کیا جاتا ہے ، جبکہ پتیوں کے پاتھ لیبل (جڑ سے شروع ہونے والے کنارے کے لیبلوں کا مقابلہ) پتے کے لاحقہ کو بیان کرتے ہیں۔لاحقہ درخت سٹرنگ سے وابستہ بہت سارے مسائل کو حل کرنے میں مدد کرتے ہیں جیسے پیٹرن مماثل ، تلاش کی تلاش ، اور طویل ترین بار بار ہونے والی سب سے طویل تر سسٹرنگ تلاش کرنا۔لاحقہ درخت بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔وہ اعداد و شمار کو بازیافت یا ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیزی سے رسائی کی ضرورت ہوتی ہے۔ ایک فینوک ٹری ، جسے بائنری انڈیکسڈ ٹری (بٹ) بھی کہا جاتا ہے ، جسے بھی کہا جاتا ہے ،ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ایک صف میں متعدد رینج کے سوالات کا موثر انداز میں جواب دینے کے لئے استعمال ہوتا ہے۔اس سے ہمیں کسی عنصر یا علامتی وقت میں کسی عنصر کی جگہ لے کر صف میں ترمیم کرنے کی اجازت ملتی ہے۔فینوک ٹری زیادہ تر استعمال ہوتا ہے جب ہمیں ایک صف دی گئی ہے اور ہمیں متعدد بار یا////اور ہمیں کئی بار عناصر کی رقم تلاش کرنے کی ضرورت ہے ، اور ہمیں اس کی بھی ضرورت ہے کہ ہمیں متعدد بار عناصر کا مجموعہ تلاش کرنے کی ضرورت ہے۔کسی بھی خاص انڈیکس کی قیمت کو اپ ڈیٹ کرنے کے لئے متعدد اپ ڈیٹ آپریشن انجام دیں۔فینوک ٹری استعمال اور کوڈ آسان ہے ، خاص طور پر کثیر جہتی صفوں کی صورت میں۔طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کے مقابلے میں ، فینوک ٹری کم جگہ استعمال کرتا ہے اور اس پر عمل درآمد آسان ہے۔فینوک ٹری کا ایک نقصان یہ ہے کہ اسے صرف ایک آپریشن کے ساتھ استعمال کیا جاسکتا ہے جو الٹا ہے۔مثال کے طور پر ، اس کے علاوہ ایک الٹ ایبل آپریشن ہے: اگر A + B = C پھر C - A = B (جہاں - اضافے کے الٹا کے طور پر کام کرتا ہے). اختتام پر ، ایک لاحقہ درخت ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ذخیرہ کرنے اور تلاش کرنے کے لئے استعمال ہوتا ہےتار میں سبسٹرنگز۔یہ ایک کمپریسڈ ٹری ہے جس میں دیئے گئے متن کے تمام لاحقہ پر مشتمل ہے۔لاحقہ درخت سٹرنگ سے وابستہ بہت سارے مسائل کو حل کرنے میں مدد کرتے ہیں جیسے پیٹرن مماثل ، تلاش کی تلاش ، اور طویل ترین بار بار ہونے والی سب سے طویل تر سسٹرنگ تلاش کرنا۔فینوک ٹری ایک درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ایک صف میں متعدد رینج کے سوالات کو موثر انداز میں جواب دینے کے لئے استعمال ہوتا ہے۔اس سے ہمیں کسی عنصر یا علامتی وقت میں کسی عنصر کی جگہ لے کر صف میں ترمیم کرنے کی اجازت ملتی ہے۔فینوک ٹری زیادہ تر استعمال ہوتا ہے جب ہمیں ایک صف دی گئی ہے اور ہمیں متعدد بار یا/////متعدد عناصر کی رقم تلاش کرنے کے لئے متعدد گیٹسم کے سوالات کا جواب دینے کی ضرورت ہے۔"
    },
    {
        "Question": "ایک لاحقہ سرنی کیا ہے؟",
        "Answer": "ایک لاحقہ سرنی دیئے گئے تار کے تمام لاحقہ کا ایک ترتیب شدہ صف ہے۔یہ ایک ڈیٹا ڈھانچہ ہے جو تار میں ذیلی ذخیروں کو اسٹور کرنے اور تلاش کرنے کے لئے استعمال ہوتا ہے۔تعریف ایک لاحقہ درخت کی طرح ہے ، جو دیئے گئے متن کے تمام لاحقہ کی ایک کمپریسڈ سہ رخی ہے۔کسی بھی لاحقہ درخت پر مبنی الگورتھم کو الگورتھم کے ساتھ تبدیل کیا جاسکتا ہے جو اضافی معلومات کے ساتھ بڑھا ہوا لاحقہ سرنی استعمال کرتا ہے اور اسی مسئلے کو اسی وقت کی پیچیدگی میں حل کرتا ہے۔لاحقہ درخت کے ڈی ایف ایس ٹراورسل کرکے لاحقہ درخت سے لاحقہ سرنی تعمیر کی جاسکتی ہے۔در حقیقت ، ایک لاحقہ سرنی اور لاحقہ درخت دونوں لکیری وقت میں ایک دوسرے سے تعمیر کیا جاسکتا ہے۔لاحقہ سرنی بہت سارے سٹرنگ سے متعلق مسائل کو حل کرنے میں مدد کرتا ہے جیسے پیٹرن مماثل ، تلاش کی تلاش ، اور سب سے طویل بار بار ہونے والی سبسٹرنگ تلاش کرنا۔بہت ساری ایپلی کیشنز ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم میں لاحقہ سرنیوں کا استعمال کیا جاتا ہے۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیزی سے رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "ایک ناگوار سیٹ ڈیٹا ڈھانچہ کیا ہے؟",
        "Answer": "ایک ناگوار سیٹ ڈیٹا ڈھانچہ ، جسے یونین فٹ ڈیٹا ڈھانچہ یا انضمام کی تلاش کے سیٹ کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ڈس ڈیسینٹ (غیر اوورلیپنگ) سیٹوں کا مجموعہ محفوظ کرتا ہے۔یہ نئے سیٹوں کو شامل کرنے ، سیٹوں کو ضم کرنے (ان کی یونین کے ذریعہ ان کی جگہ لینے) ، اور کسی سیٹ کا نمائندہ ممبر تلاش کرنے کے لئے کاروائیاں فراہم کرتا ہے۔کسی گراف کے کم سے کم پھیلے ہوئے درخت کو تلاش کرنے کے لئے کرسکل کے الگورتھم میں متنازعہ اعداد و شمار کے ڈھانچے کلیدی کردار ادا کرتے ہیں۔کم سے کم پھیلا ہوا درختوں کی اہمیت کا مطلب یہ ہے کہ اعداد و شمار کے ڈھانچے کو الگ الگ الگورتھم کی وسیع اقسام کا سامنا کرنا پڑتا ہے۔اس کے علاوہ ، ناگوار سیٹ ڈیٹا ڈھانچے میں علامتی گنتی کے ساتھ ساتھ مرتب کرنے والوں میں بھی ، خاص طور پر رجسٹر مختص کرنے کے مسائل کے ل applications ایپلی کیشنز بھی موجود ہیں۔ایک ناگوار سیٹ ایک ڈیٹا ڈھانچہ ہے جو عناصر کی کائنات سے باخبر رہتا ہے۔آئٹمز کو متعدد ناگوار (غیر اوورلیپنگ) سیٹوں میں تقسیم کیا جاتا ہے۔ناگوار سیٹ ڈیٹا ڈھانچہ مندرجہ ذیل کارروائیوں کی حمایت کرتا ہے: ناپسندیدہ سیٹ میں نئے سیٹ شامل کرنا۔سیٹ ڈیٹا ڈھانچے بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں ڈیٹا کی بڑی مقدار میں تیز رفتار رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "اسکیپ لسٹ کیا ہے؟",
        "Answer": "اسکیپ لسٹ ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو لنکڈ فہرستوں کے درجہ بندی کی مدد سے آئٹمز کی ترتیب شدہ فہرست کو ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے جو آئٹمز کے بڑھتے ہوئے ویرل ویرل کے بعد کے حصول کو جوڑتا ہے۔یہ ایک موثر انداز میں آئٹم کی تلاش کے عمل کی اجازت دیتا ہے۔اسکیپ لسٹ منسلک فہرست کا ایک توسیع شدہ ورژن ہے۔یہ صارف کو بہت جلد عنصر کو تلاش ، ہٹانے اور داخل کرنے کی اجازت دیتا ہے۔اس میں ایک بیس لسٹ پر مشتمل ہے جس میں عناصر کا ایک مجموعہ شامل ہے جو بعد کے عناصر کے لنک درجہ بندی کو برقرار رکھتا ہے۔اسکیپ لسٹ پرتوں میں بنی ہوئی ہے ، جس میں نیچے کی پرت ایک عام آرڈرڈ منسلک فہرست ہے۔ہر اعلی پرت نیچے دی گئی فہرستوں کے لئے \"ایکسپریس لین\" کے طور پر کام کرتی ہے ، جہاں پرت میں ایک عنصر میں پرت I+1 میں کچھ مقررہ امکان کے ساتھ ظاہر ہوتا ہے۔اوسطا ، ہر عنصر لاگ این کی فہرستوں میں ظاہر ہوتا ہے ، اور سب سے لمبا عنصر (عام طور پر اسکیپ لسٹ کے سامنے کا ایک خاص عنصر) تمام فہرستوں میں ظاہر ہوتا ہے۔اسکیپ لسٹوں کو عملی جامہ پہنانے میں نسبتا easy آسان ہے ، خاص طور پر جب متوازن درختوں جیسے AVL درختوں یا سرخ سیاہ درختوں کے مقابلے میں۔وہ بے ترتیب نمبر جنریٹر سے مشورہ کرکے متوازن ہیں ، جو اس بات کا تعین کرتا ہے کہ نوڈ کی سطح کو نوڈ کی سطح کے نام سے پائے جانے والے نوڈ کے پاس کتنے پوائنٹر کہتے ہیں۔اسکیپ لسٹیں بہت سے ایپلی کیشنز میں استعمال کی جاتی ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیز رفتار رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "خود توازن بائنری تلاش کا درخت کیا ہے؟",
        "Answer": "خود توازن بائنری سرچ کا درخت ایک بائنری سرچ ٹری ہے جو خود بخود اپنی اونچائی کو صوابدیدی شے کے اضافے اور حذف کرنے کے عالم میں رکھتا ہے۔یہ ایک نوڈ پر مبنی بائنری سرچ ٹری ہے جس میں درخت کی اونچائی میں بڑھتی ہوئی درخت کی اونچائی کے خلاف احتیاطی اقدامات شامل ہیں ، تاکہ یہ تجریدی اعداد و شمار کے ڈھانچے \"خود توازن\" کو وصف حاصل کریں۔بائنری سرچ ٹری پر زیادہ تر آپریشن درخت کی اونچائی کے لئے براہ راست متناسب وقت لگاتے ہیں ، لہذا اونچائی کو چھوٹا رکھنا ضروری ہے۔اونچائی H کے ساتھ ایک بائنری درخت زیادہ سے زیادہ 2^(H+1) -1 نوڈس پر مشتمل ہوسکتا ہے۔خود توازن بائنری تلاش کے درخت اتپریورتی ترتیب شدہ فہرستوں کے لئے موثر نفاذ فراہم کرتے ہیں ، اور دوسرے تجریدی اعداد و شمار کے ڈھانچے جیسے ایسوسی ایٹیو اریوں ، ترجیحی قطاریں اور سیٹوں کے لئے استعمال ہوسکتے ہیں۔خود توازن بائنری تلاش کے درختوں کی متعدد اقسام ہیں ، جیسے اے وی ایل کے درخت ، سرخ سیاہ درخت ، چھڑکنے والے درخت اور ٹریپس۔یہ درخت ہمیشہ اپنی اونچائی کو کم سے کم رکھتے ہیں ، اس بات کو یقینی بناتے ہوئے کہ ان کے کام ہمیشہ O (لاگ این) کی بدترین قیمت کو برقرار رکھیں گے۔خود توازن بائنری تلاش کے درخت بہت سے ایپلی کیشنز ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم میں استعمال ہوتے ہیں۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیزی سے رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "دوگنا منسلک فہرست کیا ہے؟",
        "Answer": "ایک دوگنا لنکڈ فہرست ایک قسم کی منسلک فہرست ہے جس میں ہر نوڈ میں تین اجزاء ہوتے ہیں: ڈیٹا ، پچھلے نوڈ کا ایک پوائنٹر ، اور اگلے نوڈ کا ایک پوائنٹر۔یہ ایک لکیری ڈیٹا ڈھانچہ ہے جو اجتماعی طور پر اعداد و شمار کی ترتیب کی نمائندگی کرتا ہے جس میں ہر نوڈ کے تین حصے ہوتے ہیں۔پہلے نوڈ کا پچھلا پوائنٹر اور آخری نوڈ کے اگلے پوائنٹر میں ہمیشہ ہر سمت میں اختتام کی نشاندہی ہوتی ہے۔ایک دوگنا منسلک فہرست آگے اور پسماندہ دونوں سمتوں میں نیویگیشن کی اجازت دیتی ہے ، جس سے یہ ایک واحد منسلک فہرست سے زیادہ لچکدار بن جاتا ہے۔یہ بہت سے ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔دوگنا منسلک فہرست کے فوائد میں مستقل وقت داخل کرنے اور عناصر کو حذف کرنے کے ساتھ ساتھ دونوں سمتوں میں فہرست کو عبور کرنے کی صلاحیت بھی شامل ہے۔نقصانات میں پچھلے پوائنٹر کے لئے درکار اضافی جگہ اور ایک واحد منسلک فہرست کے مقابلے میں عمل درآمد کی پیچیدگی شامل ہے۔مجموعی طور پر ، ایک دوگنا لنکڈ فہرست ان حالات کے لئے ایک مفید ڈیٹا ڈھانچہ ہے جہاں بار بار اندراج اور عناصر کو حذف کرنے کی ضرورت ہوتی ہے ، اور جہاں دونوں سمتوں میں ٹراورسل ضروری ہے۔"
    },
    {
        "Question": "ایک سرکلر منسلک فہرست کیا ہے؟",
        "Answer": "ایک سرکلر منسلک فہرست ایک قسم کی منسلک فہرست ہے جس میں تمام نوڈس دائرے کی تشکیل کے لئے جڑے ہوئے ہیں۔روایتی منسلک فہرست کے برعکس ، فہرست کے آخر میں کوئی کالعدم نہیں ہے۔اس کے بجائے ، آخری نوڈ پہلے نوڈ کی طرف اشارہ کرتا ہے ، جس سے ایک سرکلر ڈھانچہ پیدا ہوتا ہے۔سرکلر سے منسلک فہرستوں کو عام طور پر ایک واحد منسلک فہرست کے ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاتا ہے ، جہاں فہرست میں ہر نوڈ اگلے نوڈ سے ایک پوائنٹر کے ذریعہ منسلک ہوتا ہے۔اس فہرست میں آخری نوڈ پھر پہلے نوڈ سے منسلک ہوتا ہے ، جس سے رنگ نما ڈھانچہ تشکیل ہوتا ہے۔سرکلر منسلک فہرستوں کی دو اقسام ہیں: اکیلے لنکڈ اور دوگنا لنکڈ۔ایک واحد منسلک سرکلر لنکڈ فہرست میں ، ہر نوڈ میں ایک پوائنٹر ہوتا ہے جو فہرست میں اگلے نوڈ کی طرف اشارہ کرتا ہے۔دوگنا منسلک سرکلر لنکڈ فہرست میں ، ہر نوڈ میں ایک پوائنٹر ہوتا ہے جو فہرست میں اگلے اور پچھلے دونوں نوڈس کی طرف اشارہ کرتا ہے۔ سرکلر لنکڈ فہرستیں ایسی صورتحال میں کارآمد ہیں جہاں اعداد و شمار کو مستقل لوپ میں کارروائی کرنے کی ضرورت ہے ، جیسے حقیقت میں۔وقت کی درخواستیں یا نقالی۔وہ ملٹی پلیئر گیمز میں بھی استعمال ہوتے ہیں ، جہاں تمام کھلاڑیوں کو سرکلر لنکڈ لسٹ فارم میں ترتیب دیا جاتا ہے۔سرکلر سے منسلک فہرست کے فوائد میں فہرست کے اختتام پر نظر رکھنے کے بغیر پوری فہرست کو عبور کرنے کی صلاحیت ، اور فہرست میں کسی بھی نوڈ سے کسی بھی نوڈ پر جانے کی صلاحیت شامل ہے۔نقصانات میں ایک واحد منسلک فہرست کے مقابلے میں عمل درآمد کی پیچیدگی ، اور لامحدود لوپ میں جانے کا امکان شامل ہے جبکہ فہرست کو عبور کرتے ہوئے اگر لوپ کو صحیح طریقے سے نہیں توڑا گیا ہے۔"
    },
    {
        "Question": "ایک واحد منسلک فہرست کیا ہے؟",
        "Answer": "ایک واحد منسلک فہرست ایک لکیری ڈیٹا ڈھانچہ ہے جس میں عناصر متضاد میموری کے مقامات پر محفوظ نہیں ہوتے ہیں اور ہر عنصر صرف ایک پوائنٹر کا استعمال کرتے ہوئے اس کے اگلے عنصر سے منسلک ہوتا ہے۔یہ ایک قسم کی منسلک فہرست ہے جو غیر مستقیم ہے ، اس کا مطلب ہے کہ اسے سر سے آخری نوڈ (دم) تک صرف ایک ہی سمت میں منتقل کیا جاسکتا ہے۔منسلک فہرست میں ہر عنصر کو نوڈ کہا جاتا ہے۔ایک ہی نوڈ میں ڈیٹا اور اگلے نوڈ کا پوائنٹر ہوتا ہے جو فہرست کی ساخت کو برقرار رکھنے میں مدد کرتا ہے۔پہلے نوڈ کو سر کہا جاتا ہے۔یہ فہرست کے پہلے نوڈ کی طرف اشارہ کرتا ہے اور فہرست میں ہر دوسرے عنصر تک رسائی میں ہماری مدد کرتا ہے۔آخری نوڈ ، جسے کبھی کبھی دم بھی کہا جاتا ہے ، نول کی طرف اشارہ کرتا ہے جو فہرست کے اختتام پر اس بات کا تعین کرنے میں ہماری مدد کرتا ہے۔اکیلے منسلک فہرستیں اعداد و شمار کو صرف ایک طرح سے عبور کرنے کی اجازت دیتی ہیں۔اکیلے لنکڈ فہرستیں بہت سے ایپلی کیشنز میں استعمال کی جاتی ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔وہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیے گئے ہیں ، جس سے وہ ان ایپلی کیشنز میں استعمال کے ل well مناسب ہیں جن میں بڑی مقدار میں ڈیٹا تک تیز رفتار رسائی کی ضرورت ہوتی ہے۔کچھ عام کاروائیاں جو اکیلے منسلک فہرستوں پر انجام دی جاسکتی ہیں ان میں اندراج ، حذف کرنا ، اور ایک مخصوص نوڈ کی تلاش کرنا شامل ہے۔"
    },
    {
        "Question": "تھوڑا سا صف کیا ہے؟",
        "Answer": "تھوڑا سا سرنی ، جسے بٹ میپ ، بٹ سیٹ ، بٹ سٹرنگ ، یا بٹ ویکٹر بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ایک صف کی شکل میں بولین اقدار یا بٹس کو کمپیکٹ طور پر اسٹور کرتا ہے۔بٹس صرف 0 یا 1 ہوسکتے ہیں۔بٹ سرنی میں ہر ایک آزاد ہے ، اور چونکہ ہر ایک میں 2 اقدار ہوسکتے ہیں ، یہ 2^n اقدار کی نمائندگی کرسکتا ہے جہاں N صف میں بٹس کی تعداد ہے۔تھوڑا سا سرنی سیٹ {0 ، 1} میں اقدار کے ل some کچھ ڈومین (تقریبا ہمیشہ عددیوں کی ایک رینج) کی نقشہ سازی ہے۔اقدار کو تاریک/روشنی ، غیر حاضر/موجود ، مقفل/غیر مقفل ، درست/غلط ، اور اسی طرح کی ترجمانی کی جاسکتی ہے۔ان کی کمپیکٹینس کی وجہ سے ، بٹ سرنیوں میں ان علاقوں میں متعدد درخواستیں ہیں جہاں جگہ یا کارکردگی ایک پریمیم میں ہے۔عام طور پر ، وہ ایک سادہ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے استعمال ہوتے ہیں۔بٹ سرے تیزی سے آپریشن کرنے کے لئے ہارڈ ویئر میں بٹ لیول کی ہم آہنگی کا استحصال کرنے میں موثر ہیں۔وہ بہت سے ایپلی کیشنز میں استعمال ہوتے ہیں ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔جاوا میں ، تھوڑا سا سرنی کی نمائندگی بٹسیٹ کلاس کے ذریعہ کی جاتی ہے ، اور C ++ میں ، تھوڑا سا سرنی بٹیرے کلاس کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔"
    },
    {
        "Question": "بائنری انڈیکسڈ درخت کیا ہے؟",
        "Answer": "ایک بائنری اشاریہ دار درخت ، جسے فینوک ٹری کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو اعداد کی ایک صف پر سابقہ رقم کے سوالات کو موثر انداز میں جواب دینے کے لئے استعمال ہوتا ہے۔یہ ہمیں O (لاگ این) ٹائم پیچیدگی میں ایک صف کے سابقہ مجموعہ کا حساب لگانے کی اجازت دیتا ہے۔بائنری انڈیکسڈ درخت کی نمائندگی ایک صف کے طور پر کی جاتی ہے ، جہاں ہر نوڈ ان پٹ سرنی کے کچھ عناصر کا مجموعہ رکھتا ہے۔بائنری انڈیکسڈ درخت کا سائز ان پٹ سرنی کے سائز کے برابر ہے۔بائنری اشاریہ دار درخت درخت میں موجود تمام اقدار کو 0 کے طور پر شروع کرکے تعمیر کیا گیا ہے ، اور پھر تمام اشاریہ جات کے لئے اپ ڈیٹ () فنکشن کو کال کریں۔اپ ڈیٹ () آپریشن بائنری انڈیکسڈ ٹری کو آر آر [انڈیکس] += ویل انجام دے کر اپ ڈیٹ کرتا ہے ، جہاں اے آر آر ان پٹ سرنی ہے۔بائنری اشاریہ دار درخت کو حد سے متعلق سوالات انجام دینے کے لئے استعمال کیا جاسکتا ہے ، جیسے انڈیکس کی ایک حد میں عناصر کی رقم تلاش کرنا۔بائنری انڈیکسڈ درخت بہت سے ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔یہ ڈیٹا کو بازیافت یا ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیا گیا ہے ، جس سے یہ ایپلی کیشنز میں استعمال کے ل well مناسب ہے جس میں بڑی مقدار میں ڈیٹا تک تیز رسائی کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "ایک ویرل ٹیبل کیا ہے؟",
        "Answer": "ایک ویرل ٹیبل ایک اعداد و شمار کا ڈھانچہ ہے جو نسبتا fast تیز اور موثر انداز میں جامد رینج کے سوالات کا جواب دینے کے لئے استعمال کیا جاتا ہے ، جیسے رینج کم سے کم استفسار (RMQ)۔یہ دوسرے ڈیٹا ڈھانچے کے مقابلے میں اس کے تیز استفسار اور مختصر نفاذ کے لئے پہچانا جاتا ہے۔ایک ویرل ٹیبل کا بنیادی خیال یہ ہے کہ دو لمبائی کی طاقت کے ساتھ رینج سوالات کے لئے تمام جوابات کو پہلے سے تعی .ن کرنا ہے۔جب ہم کسی ویرل ٹیبل پر رینج کے استفسار کا جواب دیتے ہیں تو ، ہم پہلے اسے پاور آف ٹو دو ذیلی حدود میں تقسیم کرسکتے ہیں۔اس کے بعد ، ہم پہلے سے موجود جوابات کو تلاش کرتے ہیں اور انہیں اپنے آخری جواب میں جوڑ دیتے ہیں۔ویرل ٹیبل بہت سے ایپلی کیشنز میں استعمال ہوتا ہے ، جیسے ڈیٹا بیس ، مرتب کرنے والے ، اور آپریٹنگ سسٹم۔یہ ڈیٹا کو بازیافت کرنے یا اس میں ترمیم کرنے کے لئے درکار موازنہ کی تعداد کو کم سے کم کرنے کے لئے ڈیزائن کیا گیا ہے ، جس سے یہ ایپلی کیشنز میں استعمال کے ل well مناسب ہے جس میں بڑی مقدار میں ڈیٹا تک تیز رفتار رسائی کی ضرورت ہوتی ہے۔کچھ عام کاروائیاں جو کسی ویرل ٹیبل پر انجام دی جاسکتی ہیں ان میں تعمیر ، پیشگی ، اور حد سے متعلق سوالات شامل ہیں۔ویرل ٹیبل کو کم سے کم سوالات (RMQ) میں استعمال کیا جاتا ہے ، جہاں یہ O (1) وقت میں جواب کی گنتی کرسکتا ہے۔تاہم ، یہ ناقابل تسخیر صفوں پر رینج کے سوالات کے ل better بہتر ہے ، جہاں سرنی کے اعداد و شمار کو دو سوالات کے درمیان تبدیل نہیں کیا جاسکتا۔"
    }
]