[
    {
        "Question": "ازگر",
        "Answer": "ازگر ایک اعلی سطحی ، عمومی مقصد کے پروگرامنگ زبان ہے جو متعدد پروگرامنگ نمونوں کی حمایت کرتی ہے ، جس میں ساختی ، آبجیکٹ پر مبنی اور فنکشنل پروگرامنگ 1 شامل ہیں۔اسے اکثر اس کی جامع معیاری لائبریری 1 کی وجہ سے \"بیٹریاں شامل\" زبان کے طور پر بیان کیا جاتا ہے۔ازگر کا مطلب ایک آسانی سے پڑھنے کے قابل زبان ہے ، جس میں ضعف بے ترتیبی فارمیٹنگ ہوتی ہے جو اکثر انگریزی کلیدی الفاظ استعمال کرتی ہے جہاں دوسری زبانیں اوقاف 1 کا استعمال کرتی ہیں۔بہت سی دوسری زبانوں کے برعکس ، یہ بیانات کی اجازت دینے کے بعد بلاکس کو ختم کرنے کے لئے گھوبگھرالی خطوط کا استعمال نہیں کرتا ہے ، اور شاذ و نادر ہی استعمال ہوتا ہے۔ازگر کی بڑی معیاری لائبریری بہت سے کاموں کے لئے موزوں ٹولز مہیا کرتی ہے اور اسے عام طور پر اس کی سب سے بڑی طاقت 1 کے طور پر پیش کیا جاتا ہے۔اس کا استعمال سرور پر ویب ایپلی کیشنز بنانے کے لئے ، سافٹ ویئر کے ساتھ ساتھ ورک فلوز بنانے کے لئے ، اور ڈیٹا بیس سسٹم 2 سے رابطہ قائم کرنے کے لئے استعمال کیا جاسکتا ہے۔ازگر فائلوں کو بھی پڑھ سکتا اور اس میں ترمیم کرسکتا ہے۔ ازگر سیکھنے کے لئے بہت سارے وسائل دستیاب ہیں ، بشمول سرکاری ویب سائٹ ، جو سبق اور ہدایت نامہ 3 کے ساتھ ، ازگر کی معیاری لائبریری کے لئے دستاویزات پیش کرتی ہے۔W3Schools ایک ازگر ٹیوٹوریل پیش کرتا ہے جس میں فائل ہینڈلنگ ، ڈیٹا بیس ہینڈلنگ ، مشقیں ، مثالوں اور کوئزز 4 جیسے موضوعات کا احاطہ کیا گیا ہے۔کوڈ کیڈیمی ابتدائی اور اعلی درجے کے صارفین کے لئے ازگر کورسز اور سبق پیش کرتا ہے۔"
    },
    {
        "Question": "فہرست میں تمام نمبروں کا مجموعہ تلاش کرنے کے لئے ایک ازگر پروگرام لکھیں۔",
        "Answer": "یہاں ایک ازگر پروگرام ہے جس میں تمام تعداد کا مجموعہ ایک فہرست میں ملاحظہ کیا جاتا ہے () فنکشن کا استعمال کرتے ہوئے: پائیتھونمی_ لسٹ = [1 ، 2 ، 3 ، 4 ، 5] SUM_OF_LIST = SUM (my_list) پرنٹ (\"فہرست کا مجموعہ:\" ، \"SUM_OF_LIST) یہ پروگرام سب سے پہلے کچھ نمبروں کے ساتھ MY_LIST نامی ایک فہرست شروع کرتا ہے۔اس کے بعد ، یہ فہرست میں موجود تمام نمبروں کے مجموعہ کا حساب لگانے کے لئے بلٹ ان سوم () فنکشن کا استعمال کرتا ہے اور اسے SUM_OF_LIST نامی متغیر میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست کا مجموعہ پرنٹ کرتا ہے۔یہاں ایک مثال یہ ہے: پائیتھونمی_ لسٹ = [1 ، 2 ، 3 ، 4 ، 5] SUM_OF_LIST = 0 کے لئے my_list میں نمبر: SUM_OF_LIST += نمبر پرنٹ (\"فہرست کا مجموعہ ہے:\" ، SUM_OF_LIST) یہ پروگرام پہلے کچھ نمبروں کے ساتھ ایک فہرست شروع کرتا ہے جس میں کچھ تعداد شامل ہوتی ہے۔اس کے بعد ، یہ Sum_of_list نامی متغیر کی ابتدا کرتا ہے۔ اگلا ، یہ فہرست میں ہر نمبر کے ذریعے لوپ کے لئے A کا استعمال کرتا ہے اور اسے Sum_of_list متغیر میں شامل کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست کا مجموعہ پرنٹ کرتا ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے اسٹرنگ ایک پیلنڈرووم ہے۔",
        "Answer": "یہاں ایک ازگر فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک پیلیندرووم ہے: پائیتھونڈف آئی ایس_پالنڈرووم (سٹرنگ): # تار کو چھوٹے سے کیس میں تبدیل کریں اور غیر الفینومیرک حروف کو ہٹا دیں۔) .lower () # چیک کریں کہ آیا تار اس کے الٹ ریٹرن سٹرنگ == سٹرنگ کے برابر ہے [::-1] یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور پہلے تمام غیر الفانومرک حروف کو ہٹاتا ہے اور اس میں شمولیت کا استعمال کرتے ہوئے سٹرنگ کو چھوٹے میں تبدیل کرتا ہے۔() اور کم () طریقے۔پھر ، یہ جانچ پڑتال کرتا ہے کہ آیا اسٹرنگ سلائسنگ کا استعمال کرتے ہوئے اس کے الٹ کے برابر ہے۔اگر تار اس کے الٹ کے برابر ہے تو ، فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ تار ایک پیلنڈرووم ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھنسٹرنگ = \"ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما\" اگر is_palindrome (سٹرنگ): پرنٹ (\"تار ایک palindrome ہے۔\") اور: پرنٹ کریں۔(\"سٹرنگ ایک پیلیندرووم نہیں ہے۔\") یہ پروگرام سب سے پہلے کچھ متن کے ساتھ اسٹرنگ نامی تار شروع کرتا ہے۔اس کے بعد ، یہ ان پٹ کے بطور اسٹرنگ کے ساتھ IS_Palindrome () فنکشن کو کال کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا تار ایک پیلنڈرووم ہے یا پرنٹ () فنکشن استعمال نہیں کررہا ہے۔اس معاملے میں ، آؤٹ پٹ \"سٹرنگ ایک پیلنڈرووم ہے۔\""
    },
    {
        "Question": "ایک مقررہ نمبر تک تمام پرائم نمبر تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ایرٹوسٹینز الگورتھم کی چھلنی کا استعمال کرتے ہوئے کسی مخصوص نمبر تک تمام بنیادی تعداد تیار کرنے کے لئے ایک ازگر پروگرام ہے: پائیتھنڈف جنریٹ_پرائمز (این): # ایک بولین سرنی \"پرائم [0..n]\" بنائیں اور # تمام اندراجات کو اس کو سچ سمجھا جاتا ہے۔پرائم = [رینج میں I کے لئے سچ (n+1)] p = 2 جبکہ p ** 2 <= n: # اگر پرائم [p] تبدیل نہیں کیا گیا ہے ، تو یہ ایک اہم ہے اگر پرائم [p]: # اپ ڈیٹ کریںرینج (پی ** 2 ، این+1 ، پی) کے لئے پی کے ضرب: پرائم [i] = غلط پی+= 1 # رینج میں پی کے لئے تمام پرائم نمبر پرنٹ کریں (2 ، n+1): اگر پرائم [اگر پرائم [P]: پرنٹ (P) یہ پروگرام ان پٹ کے طور پر ایک عدد N لیتا ہے اور ایرٹوسٹینس الگورتھم کی چھلنی کا استعمال کرتے ہوئے N تک تمام بنیادی نمبر تیار کرتا ہے۔الگورتھم سائز N+1 کا بولین سرنی پرائم بنانے اور تمام اندراجات کو سچ میں شروع کرکے کام کرتا ہے۔اس کے بعد ، یہ N کے مربع روٹ تک تمام نمبروں پر تکرار کرتا ہے اور ہر نمبر کے تمام ضربوں کو غلط میں اپ ڈیٹ کرتا ہے۔آخر میں ، یہ ان تمام نمبروں کو پرنٹ کرتا ہے جو اب بھی پرائم سرنی میں درست ہیں۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر = 50 جینریٹ_پرائمز (این) یہ پروگرام جنریٹ_پرائمز () فنکشن اور پرنٹس کا استعمال کرتے ہوئے 50 تک تمام پرائم نمبر تیار کرتا ہے۔انہیں کنسول میں۔آؤٹ پٹ یہ ہوگا: 235711131719232931374143471 JAVATPOINT2SANFONDRY3STACKOVERFLOW4PROGROGRAMIZ5GEEKSFORGEEKS"
    },
    {
        "Question": "ایک فنکشن بنائیں جو ان پٹ کے طور پر تار لیتا ہے اور تار میں ہر کردار کی فریکوئنسی لوٹاتا ہے۔",
        "Answer": "یہاں ایک ازگر فنکشن ہے جو ان پٹ کے طور پر ایک تار لیتا ہے اور تار میں ہر کردار کی فریکوئنسی کو لوٹاتا ہے: پیتھونڈف چار_فریڈیکونسی (سٹرنگ): # ہر کردار کی فریکوئنسی کو ذخیرہ کرنے کے لئے ایک خالی لغت بنائیں = {} # لوپ ہر کردار میں ہر کردار کے ذریعےتار میں چار کے لئے تار: # اگر کردار پہلے سے ہی لغت میں ہے تو ، اس کی گنتی میں اضافہ کریں اگر فریک میں چار: فریق [چار] += 1 # دوسری صورت میں ، 1 اور کی گنتی کے ساتھ کردار کو لغت میں شامل کریں: فریک [چار [چار] = 1 # لوٹائیں کردار کی فریکوئنسی کی لغت کو لوٹائیں فریکتس فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور ہر کردار کی تعدد کو ذخیرہ کرنے کے لئے فریک نامی ایک خالی لغت شروع کرتا ہے۔اس کے بعد ، یہ ہر کردار کو تار میں کھڑا کرتا ہے اور چیک کرتا ہے کہ کیا کردار پہلے سے ہی لغت میں ہے۔اگر یہ ہے تو ، اس کردار کی گنتی میں اضافہ ہوتا ہے۔اگر یہ نہیں ہے تو ، اس نے کردار کو لغت میں 1 کی گنتی کے ساتھ شامل کیا ہے۔ آخر میں ، یہ کردار کی تعدد کی لغت کو لوٹاتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پیتھنسٹرنگ = \"ہیلو ، ورلڈ!\" فریک = چار_فریکونسی (سٹرنگ (سٹرنگ) پرنٹ (فریق) یہ پروگرام پہلے کچھ متن کے ساتھ سٹرنگ نامی تار شروع کرتا ہے۔اس کے بعد ، یہ چار_فریکوینسی () کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر میں فریک کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے کردار کی تعدد کی لغت کو پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار ہوگی: {'H': 1 ، 'E': 1 ، 'L': 3 ، 'O': 2 ، '،': 1 ، '': 1 ، 'W': 1، 'r': 1 ، 'd': 1 ، '!': 1} یہ لغت ان پٹ میں ہر کردار کی تعدد کو ظاہر کرتی ہے۔"
    },
    {
        "Question": "ترتیب شدہ فہرست میں کسی عنصر کی پوزیشن تلاش کرنے کے لئے بائنری سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "ایک ترتیب شدہ فہرست میں کسی عنصر کی پوزیشن تلاش کرنے کے لئے بائنری سرچ الگورتھم کا ازگر کا نفاذ یہاں ہے: پیتھنڈف بائنری_سارچ (آر ، ایکس): # ابتدائی اقدار کو پہلے اور آخری اشاریوں کے لئے پہلے = 0 آخری = لین (آر آر) -1 # لوپ جب تک کہ پہلا انڈیکس آخری انڈیکس سے کم یا اس کے برابر نہیں ہوتا ہے جبکہ پہلا <= آخری: # درمیانی انڈیکس مڈ = (پہلا + آخری) کا حساب لگائیں // 2 # اگر درمیانی عنصر ہدف ہے تو ، اس کا انڈیکس واپس کریں اگرآر آر [مڈ] == ایکس: وسط # لوٹیں # اگر ہدف درمیانی عنصر سے کم ہے تو ، بائیں آدھے ایلف آر آر [مڈ]> x: آخری = وسط - 1 # تلاش کریں اگر ہدف درمیانی عنصر سے زیادہ ہے تو ، تلاش کریںدائیں آدھے اور: پہلا = وسط + 1 # اگر ہدف نہیں ملا ہے تو ، واپسی -1 ریٹرن -1 -1 اس فنکشن میں ایک ترتیب شدہ فہرست AR اور ایک ہدف عنصر X کو ان پٹ کے طور پر لیتا ہے اور اس فہرست میں ہدف عنصر کا انڈیکس واپس کرتا ہے۔بائنری تلاش الگورتھم۔الگورتھم بار بار تلاش کے وقفے کو آدھے حصے میں تقسیم کرکے کام کرتا ہے جب تک کہ ہدف عنصر نہ مل جائے یا تلاش کا وقفہ خالی نہ ہو۔ہر تکرار میں ، یہ تلاش کے وقفے کے درمیانی عنصر کو ہدف عنصر سے موازنہ کرتا ہے اور اس کے مطابق تلاش کے وقفے کو اپ ڈیٹ کرتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر = [1 ، 3 ، 5 ، 7 ، 9] x = 5result= بائنری_سارچ (آر ، ایکس) اگر نتیجہ! = -1: پرنٹ (ایف \"عنصر {x} انڈیکس میں موجود ہے {نتیجہ}\") اور: پرنٹ (\"عنصر صف میں موجود نہیں ہے\") یہ پروگرام پہلے ترتیب سے شروع کرتا ہےفہرست کو اے آر آر اور ایک ہدف عنصر x کہا جاتا ہے۔اس کے بعد ، یہ بائنری_سرچ () کو ARR اور X کے ساتھ فنکشن کہتے ہیں اور ان پٹ کے طور پر اس کے نتیجے میں ایک متغیر کے نتیجے میں ہوتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا ہدف عنصر فہرست میں موجود ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے اس کا انڈیکس۔اس معاملے میں ، آؤٹ پٹ \"عنصر 5 انڈیکس 2 پر موجود ہے\""
    },
    {
        "Question": "لنکڈ فہرست کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کو پلٹنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو ایک منسلک فہرست کی نمائندگی کرتی ہے اور اس کو الٹ کرنے کے لئے ایک طریقہ: ازگر کلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹا = ڈیٹا سیلف۔ نیکسٹ = نون کلاس لنکڈ لسٹ: ڈیف __init __ (خود): کوئی بھی نہیں۔داخل کریں (خود ، ڈیٹا): نیا_نوڈ = نوڈ (ڈیٹا) اگر سیلف۔ ہیڈ: موجودہ = سیلف۔: موجودہ = سیلف ہیڈ کے دوران موجودہ: پرنٹ (کرنٹ.ڈیٹا ، اینڈ = \"\") موجودہ = کرنٹ۔ نیکسٹ پرنٹ () ڈیف ریورس (خود): پچھلا = کوئی بھی نہیں موجودہ = خود نہیں۔موجودہ۔ نیکسٹ = پچھلا سابقہ = موجودہ موجودہ = اگلا_نوڈ سیلف۔ ہیڈ = پچھلا کلاس نوڈ کلاس اور لنکڈ لسٹ کلاس کے ساتھ ایک منسلک فہرست کی نمائندگی کرتی ہے۔نوڈ کلاس میں ڈیٹا وصف اور اگلی وصف ہے جو فہرست میں اگلے نوڈ کی طرف اشارہ کرتا ہے۔لنکڈ لسٹ کلاس میں ایک سر وصف ہے جو فہرست میں پہلے نوڈ کی طرف اشارہ کرتا ہے۔اس میں فہرست کے اختتام پر ایک نیا نوڈ داخل کرنے ، فہرست کو پرنٹ کرنے اور فہرست کو الٹ کرنے کے طریقے بھی موجود ہیں۔ ریورس () طریقہ سے منسلک فہرست کو الٹ کرنے کے لئے تکراری نقطہ نظر کا استعمال کیا گیا ہے۔یہ بالترتیب دو پوائنٹرز ، پچھلے اور موجودہ ، کسی کو اور فہرست کے سربراہ کو بالترتیب شروع کرتا ہے۔اس کے بعد ، یہ فہرست کے ذریعے تکرار کرتا ہے اور پچھلے نوڈ کی طرف اشارہ کرنے کے لئے ہر نوڈ کی اگلی وصف کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ آخری نوڈ کی طرف اشارہ کرنے کے لئے فہرست کے ہیڈ وصف کو اپ ڈیٹ کرتا ہے ، جو اب الٹ لسٹ کا پہلا نوڈ ہے۔ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونمی_ لسٹ = لنکڈ لسٹ () my_list.insert (1) my_list.INSERT (2) my_list.insert (3) my_list.insert (4) my_list.insert (5) پرنٹ (\"اصل فہرست:\") my_list.print_list () my_list.reverse () پرنٹ (\"الٹ لسٹ:\") my_list.print_list () یہ پروگرام پہلے کچھ نوڈس کے ساتھ My_list نامی ایک منسلک فہرست کی ابتدا کرتا ہے۔اس کے بعد ، یہ پرنٹ_ لسٹ () کے طریقہ کار کا استعمال کرتے ہوئے اصل فہرست پرنٹ کرتا ہے۔اگلا ، یہ الٹ () طریقہ کار کا استعمال کرتے ہوئے فہرست کو تبدیل کرتا ہے اور پرنٹ_ لسٹ () طریقہ کار کا استعمال کرتے ہوئے الٹ فہرست کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: اصل فہرست: 1 2 3 4 5 الٹ الٹ فہرست: 5 4 3 2 1 1 ایڈوکیٹو 2 الفاکوڈنگس کِل ایس 3 کوڈنگنگنجاس 4 ایس این فاؤنڈری 5 جی ای ای ایکسفورجیکس"
    },
    {
        "Question": "ایک ایسا فنکشن بنائیں جس میں تار کی فہرست میں سب سے طویل عام پریفکس سٹرنگ مل جائے۔",
        "Answer": "تار کی فہرست میں سب سے طویل عام پریفکس سٹرنگ تلاش کرنے کے ل we ، ہم مندرجہ ذیل ازگر فنکشن کا استعمال کرسکتے ہیں: پائیتھنڈف طویل ترین_کومون_پریفکس (ایس ٹی آر ایس): اگر ایس ٹی آر نہیں ہے تو: واپس کریں \"\" \"اسٹرنگز کی فہرست کو ترتیب دیں۔پہلی اور آخری ڈور کے درمیان کے درمیان = \"\" کے لئے I کے لئے (لین (strs [0])): اگر strs [0] [i] == strs [-1] [i]: سابقہ += strs [0][i] اور: بریک ریٹرن پریفکسٹ یہ فنکشن ان پٹ کے طور پر اسٹرنگز ایس ٹی آر کی فہرست لیتا ہے اور ان میں سب سے طویل عام پریفکس اسٹرنگ کو لوٹاتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست خالی ہے اور اگر خالی تار واپس کرتا ہے تو۔اس کے بعد ، یہ حرف تہجی ترتیب میں تاروں کی فہرست کو ترتیب دیتا ہے۔آخر میں ، یہ فہرست میں پہلے سٹرنگ کے کرداروں کے ذریعے تکرار کرتا ہے اور فہرست میں آخری سٹرنگ میں متعلقہ کرداروں سے ان کا موازنہ کرتا ہے۔اگر حروف ایک جیسے ہیں تو ، یہ ان کو سابقہ تار میں شامل کرتا ہے۔اگر وہ مختلف ہیں تو ، یہ لوپ سے ٹوٹ جاتا ہے اور پریفکس سٹرنگ کو واپس کرتا ہے۔ فنکشن کو استعمال کرنے کے طریقہ کی ایک مثال ہے: پائیتھنسٹرنس = [\"پھول\" ، \"فلو\" ، \"فلائٹ\"] پریفکس = طویل ترین_کومون_پریفکس (ایس ٹی آر ایس) پرنٹ (پرنٹ (\"سب سے طویل مشترکہ سابقہ:\" ، سابقہ) یہ پروگرام پہلے ایس ٹی آر ایس نامی تار کی فہرست شروع کرتا ہے۔اس کے بعد ، یہ ایس ٹی آر کے ساتھ طویل ترین_کومون_پریفکس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے نام پر اسٹور کرتا ہے جسے سابقہ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے سب سے طویل عام پریفکس اسٹرنگ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ \"سب سے طویل عام سابقہ: FL\" ہوگا۔"
    },
    {
        "Question": "ایک ایسے سجاوٹ کو نافذ کریں جو کسی فنکشن کے عمل کے وقت کی پیمائش کرے۔",
        "Answer": "ایک ازگر ڈیکوریٹر بنانے کے لئے جو کسی فنکشن کے عمل کے وقت کی پیمائش کرتا ہے ، ہم ٹائم ماڈیول استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیٹونیمپورٹ ٹائم ڈیف پیمائش_ ٹائم (فنک): ڈی ای ایف ریپر (*آرگس ، ** KWARGS): اسٹارٹ_ ٹائم = ٹائم.پیرف_کونٹر () نتیجہ = فنک (** آرگس ، ** KWARGS) اختتام_ وقت = وقت = وقت () پرنٹ () پرنٹ () پرنٹ () پرنٹ () پرنٹ کریں۔f \"فنکشن {func .__ name__} take {end_time - start_time: .8f} سیکنڈ پر عملدرآمد کرنے کے لئے۔\") واپسی کا نتیجہ ریٹرن ریپریس ڈیکوریٹر ان پٹ کے طور پر ایک فنکشن فنک لیتا ہے اور ایک ریپر فنکشن واپس کرتا ہے جو فنک کے عملدرآمد کے وقت کی پیمائش کرتا ہے۔ریپر فنکشن وقت کا استعمال کرتا ہے۔اس کے بعد یہ دو بار کے درمیان فرق کا حساب لگاتا ہے اور فنک کے عملدرآمد کے وقت پرنٹ کرتا ہے۔آخر میں ، یہ فنک کو کال کرنے کا نتیجہ لوٹاتا ہے۔ ہر ایک کی مثال ہے کہ سجاوٹ کو کس طرح استعمال کیا جائے: ازگر@پیمائش_ٹیمیڈف my_func (n): کل = رقم ((x کے لئے x کے لئے (0 ، n ** 2))) واپس کلیمی_فونک(10000) یہ پروگرام سب سے پہلے My_func نامی ایک فنکشن کی وضاحت کرتا ہے جو ان پٹ کے طور پر ایک عدد N لیتا ہے اور 0 سے N ** 2 تک تمام نمبروں کی رقم کا حساب لگاتا ہے۔اس کے بعد ، یہ @ نحو کا استعمال کرتے ہوئے پیمائش_ ٹائم ڈیکوریٹر کے ساتھ my_func فنکشن کو سجاتا ہے۔آخر میں ، اس نے 10000 کے ان پٹ کے ساتھ سجایا ہوا my_func فنکشن کہا ہے۔ آؤٹ پٹ کچھ اس طرح ہوگا: فنکشن my_func پر عمل درآمد میں 0.00007100 سیکنڈ لگے۔"
    },
    {
        "Question": "کسی خاص کلید کی بنیاد پر لغت کی فہرست ترتیب دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ایک مخصوص کلید کی بنیاد پر لغت کی فہرست کو ترتیب دینے کے ل we ، ہم ازگر میں ترتیب شدہ () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھونڈف ترتیب_لسٹ_ف_ ڈکٹ (فہرست_ او ایف_ ڈکٹ ، کلید): چھانٹے ہوئے_ لسٹ = ترتیب شدہ (فہرست_ او ایف_ ڈکٹ ، کلیدی = لیمبڈا ایکس: ایکس [کلیدی]) ریٹرن سیٹڈ_ لسٹس فنکشن لسٹ_ف_ ڈکٹ کی فہرست لیتا ہے۔مخصوص کلید کی بنیاد پر لغات کی۔ترتیب شدہ () فنکشن لغت کی فہرست اور ایک کلیدی پیرامیٹر لیتا ہے ، جو لغت کی کلید کی وضاحت کرتا ہے جس کے ذریعہ فہرست کو ترتیب دیا جانا چاہئے۔اس معاملے میں ، ہم فہرست میں ہر لغت سے مخصوص کلید کی قدر نکالنے کے لئے لیمبڈا فنکشن کا استعمال کرتے ہیں۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonmy_list = [{'نام': 'جان' ، 'عمر':25} ، {'نام': 'جین' ، 'عمر': 30} ، {'نام': 'باب' ، 'عمر': 20}] ترتیب شدہ_لسٹ = ترتیب_ لسٹ_ف_ ڈکٹ (my_list ، 'عمر') پرنٹ (چھانٹڈ_ لسٹ)پروگرام سب سے پہلے لغات کی ایک فہرست شروع کرتا ہے جسے My_list کہا جاتا ہے۔اس کے بعد ، یہ SORT_LIST_OF_DICTS () کو MY_LIST اور 'عمر' کے ساتھ ان پٹ کے طور پر فنکشن کہتے ہیں اور اس کے نتیجے میں ایک متغیر کو ترتیب دیتے ہیں جس کو چھانٹیا_ لسٹ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے لغات کی ترتیب شدہ فہرست پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [{'نام': 'باب' ، 'عمر': 20} ، {'نام': 'جان' ، 'عمر': 25} ، {'نام': 'جین'."
    },
    {
        "Question": "کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ایک تکرار والی تقریب کو نافذ کریں۔",
        "Answer": "ازگر میں تکرار کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ، ہم ایک ایسے فنکشن کی وضاحت کرسکتے ہیں جو اپنے آپ کو ایک چھوٹی ان پٹ کے ساتھ کال کرتا ہے جب تک کہ وہ بیس کیس تک نہ پہنچے ، جو 1 کی حقیقت ہے ، جو 1 ہے۔ یہاں ایک مثال ہے: پائیٹنڈففیکٹوریئل (این): اگر n == 1: واپسی 1 اور: واپسی n * فیکٹوریئل (N-1) یہ فنکشن ان پٹ کے طور پر ایک عدد N لیتا ہے اور تکرار کا استعمال کرتے ہوئے n کی حقیقت کو واپس کرتا ہے۔پہلا اگر بیان چیک کرتا ہے کہ آیا ان پٹ نمبر N 1 ہے۔اگر n 1 نہیں ہے تو ، فنکشن N کی مصنوعات اور N-1 کی حقیقت کو لوٹاتا ہے۔یہ وہ جگہ ہے جہاں تکرار فنکشن کال واقع ہوتی ہے ، جہاں فنکشن خود کو ان پٹ N-1 کے ساتھ کال کرتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن = 5result = فیکٹوریل (این) پرنٹ (f \"{n} کی حقیقت ہے{نتیجہ} \") یہ پروگرام سب سے پہلے N نامی ایک انٹیجر کو 5 کی قیمت کے ساتھ شروع کرتا ہے۔ پھر ، یہ N کے ساتھ فیکٹوریئل () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N کی حقیقت پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 5 کی حقیقت پسندی 120 ہے اس آؤٹ پٹ میں ان پٹ نمبر N کی حقیقت پسندی ظاہر ہوتی ہے جس کا استعمال فیکٹوریل () فنکشن کا استعمال کرتے ہوئے کیا جاتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک ازگر پروگرام لکھیں کہ آیا اسٹرنگ میں صرف ہندسے ہوتے ہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کسی تار میں ازگر میں صرف ہندسے ہوتے ہیں ، ہم isdigit () طریقہ یا باقاعدہ اظہار استعمال کرسکتے ہیں۔isdigit () کے طریقہ کار کا استعمال کرتے ہوئے ایک مثال کے نفاذ: پائیتھنڈف پر مشتمل ہے_ونلی_ڈیجٹس (سٹرنگ): ریٹرن سٹرنگ۔ آئیسڈیجٹ () یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر تار صرف ہندسوں اور غلط پر مشتمل ہوتا ہے تو وہ سچ ہوتا ہے۔isdigit () کا طریقہ درست لوٹتا ہے اگر تار کے تمام حرف ہندسے ہیں اور کم از کم ایک کردار ہے ، اور دوسری صورت میں غلط ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹنسٹرنگ 1 = \"12345\" سٹرنگ 2 = \"12345a\" پرنٹ (پر مشتمل ہے_ونلی_ڈیجٹس.اس کے بعد ، یہ پرنٹس_ونلی_ڈیجٹس () کو سٹرنگ 1 اور سٹرنگ 2 کے ساتھ فنکشن کہتے ہیں اور ان پٹ کے طور پر پرنٹ () فنکشن کا استعمال کرتے ہوئے نتائج کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹریفلستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ پہلی سٹرنگ میں صرف ہندسے ہوتے ہیں اور دوسری تار میں کم از کم ایک غیر ہندسے کا کردار ہوتا ہے۔یہاں ایک مثال کے نفاذ ہے: پائیتھونیمپورٹ ریڈف پر مشتمل ہے_ونلی_ڈیجٹس (سٹرنگ): ریٹرن بی او ایل (re.match ('^[0-9]+$' ، سٹرنگ)) یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر اسٹرنگ میں صرف ہندسے ہوتے ہیں اور اگر سٹرنگ میں سچ ہوتا ہے۔جھوٹا دوسری صورت میں۔باقاعدگی سے اظہار '^[0] [1] [2] [3] [4] [5] [6] [7] [7] [8] [9]+$' میچوں میں صرف ایک یا زیادہ ہندسے ہوتے ہیں۔تار کے اختتام تک۔اگر باقاعدگی سے اظہار تار سے مماثل ہوتا ہے تو ، اور کوئی بھی نہیں۔ہم نتائج کو بولین ویلیو میں تبدیل کرنے کے لئے BOOL () فنکشن کا استعمال کرتے ہیں۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھنسٹرنگ 1 = \"12345\" سٹرنگ 2 = \"12345a\" پرنٹ (پر مشتمل ہے_ونلی_ڈیجٹس (سٹرنگ 1))) # فالسیتیس پروگرام سب سے پہلے دو تار شروع کرتا ہے جسے سٹرنگ 1 اور سٹرنگ 2 کہتے ہیں۔اس کے بعد ، یہ پرنٹس_ونلی_ڈیجٹس () کو سٹرنگ 1 اور سٹرنگ 2 کے ساتھ فنکشن کہتے ہیں اور ان پٹ کے طور پر پرنٹ () فنکشن کا استعمال کرتے ہوئے نتائج کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹریفلستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ پہلی سٹرنگ میں صرف ہندسے ہوتے ہیں اور دوسرے سٹرنگ میں کم از کم ایک غیر ہندسے کا کردار ہوتا ہے۔"
    },
    {
        "Question": "فہرست میں دوسرا سب سے بڑا عنصر تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں ایک فہرست میں دوسرا سب سے بڑا عنصر تلاش کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: چھنٹائی کا استعمال: ہم فہرست کو نزول ترتیب میں ترتیب دے سکتے ہیں اور دوسرا عنصر واپس کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف سیکنڈ_لارسٹ (ایل ایس ٹی): چھانٹے ہوئے_لسٹ = ترتیب شدہ (LST ، relust = relut) ریٹرن shard_lst [1] یہ فنکشن ان پٹ کے طور پر ایک فہرست LST لیتا ہے اور فہرست میں دوسرا سب سے بڑا عنصر واپس کرتا ہے۔یہ سب سے پہلے الٹ = سچے پیرامیٹر کے ساتھ ترتیب شدہ () فنکشن کا استعمال کرتے ہوئے نزولی ترتیب میں فہرست کو ترتیب دیتا ہے۔پھر ، یہ ترتیب شدہ فہرست کا دوسرا عنصر لوٹاتا ہے۔ زیادہ سے زیادہ () فنکشن کا استعمال کرتے ہوئے: ہم فہرست میں زیادہ سے زیادہ عنصر تلاش کرنے اور اسے ہٹانے کے لئے زیادہ سے زیادہ () فنکشن استعمال کرسکتے ہیں ، پھر دوسرا سب سے بڑا عنصر حاصل کرنے کے لئے زیادہ سے زیادہ عنصر کو دوبارہ تلاش کریں۔یہاں ایک مثال عمل ہے: پائیتھنڈف سیکنڈ_لارسٹ (ایل ایس ٹی): میکس_یلیم = میکس (ایل ایس ٹی) ایل ایس ٹی۔ ریمو (میکس_یلیم) سیکنڈ_میکس = میکس (ایل ایس ٹی) ریٹرن سیکنڈ_میکس فنکشن ان پٹ کے طور پر ایک فہرست ایل ایس ٹی لیتا ہے اور فہرست میں دوسرا سب سے بڑا عنصر واپس کرتا ہے۔یہ پہلے میکس () فنکشن کا استعمال کرتے ہوئے فہرست میں زیادہ سے زیادہ عنصر تلاش کرتا ہے اور اسے میکس_یلیم نامی متغیر میں اسٹور کرتا ہے۔پھر ، یہ ہٹانے () کے طریقہ کار کا استعمال کرتے ہوئے فہرست سے زیادہ سے زیادہ عنصر کو ہٹا دیتا ہے۔آخر میں ، یہ دوسرا سب سے بڑا عنصر حاصل کرنے کے لئے ایک بار پھر زیادہ سے زیادہ عنصر تلاش کرتا ہے اور اسے لوٹاتا ہے۔ ایک لوپ کا استعمال کرتے ہوئے: ہم فہرست میں زیادہ سے زیادہ اور دوسرے زیادہ سے زیادہ عناصر تلاش کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف سیکنڈ_لارسٹ (ایل ایس ٹی): میکس_یلیم = ایل ایس ٹی [0] سیکنڈ_میکس = ایل ایس ٹی میں الیم کے لئے کوئی نہیں [1:]: اگر الیم> میکس_یلیم: سیکنڈ_میکس = میکس_یلیم میکس_یلیم = ایلیم ایلف سیکنڈ_میکس کوئی بھی نہیں ہے یا ایلیم> سیکنڈ_میکس: سیکنڈ_میکس= الیم ریٹرن سیکنڈ_ماکس اس فنکشن ان پٹ کے طور پر ایک فہرست LST لیتا ہے اور فہرست میں دوسرا سب سے بڑا عنصر لوٹاتا ہے۔یہ پہلے فہرست میں پہلے عنصر اور دوسرا زیادہ سے زیادہ عنصر کسی کو بھی زیادہ سے زیادہ عنصر کی ابتدا کرتا ہے۔اس کے بعد ، یہ فہرست میں موجود باقی عناصر کے ذریعے کھڑا ہوتا ہے اور اسی کے مطابق زیادہ سے زیادہ اور دوسرے زیادہ سے زیادہ عناصر کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ دوسرا زیادہ سے زیادہ عنصر لوٹتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھونلسٹ = [3 ، 1 ، 4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5] سیکنڈ_میکس = سیکنڈ_لارسٹ (ایل ایس ٹی)پرنٹ (\"دوسرا سب سے بڑا عنصر:\" ، سیکنڈ_میکس) یہ پروگرام سب سے پہلے ایل ایس ٹی نامی فہرست کو کچھ نمبروں کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ دوسرے_لارسٹ () فنکشن کو ان پٹ کے طور پر کہتے ہیں اور اس کے نتیجے کو ایک متغیر میں سیکنڈ_میکس کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے دوسرا سب سے بڑا عنصر پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: دوسرا سب سے بڑا عنصر: 6 اس آؤٹ پٹ ان پٹ کی فہرست میں دوسرا سب سے بڑا عنصر دکھاتا ہے۔"
    },
    {
        "Question": "انفرادی الفاظ کو تبدیل کیے بغیر کسی دیئے گئے جملے کو الٹا کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں انفرادی الفاظ کو تبدیل کیے بغیر کسی دیئے گئے جملے کو پلٹانے کے ل we ، ہم جملے کو الفاظ میں تقسیم کرسکتے ہیں ، الفاظ کی ترتیب کو الٹ سکتے ہیں ، اور پھر ان کے ساتھ مل کر ان کے ساتھ شامل ہوسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف ریورس_سینٹینس (جملہ): الفاظ = جملہ۔ اسپلٹ () الفاظ۔الفاظیہ سب سے پہلے اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے جملے کو الفاظ میں تقسیم کرتا ہے ، جو وائٹ اسپیس حروف میں اسٹرنگ کو بطور ڈیفالٹ تقسیم کرتا ہے۔اس کے بعد ، یہ الٹ () طریقہ کار کا استعمال کرتے ہوئے الفاظ کے ترتیب کو تبدیل کرتا ہے۔آخر میں ، یہ ایک خلائی کردار کے ساتھ جوائن () کے طریقہ کار کا استعمال کرتے ہوئے ایک ساتھ مل کر الفاظ میں شامل ہوتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھنسینٹینس = \"یہ ایک ٹیسٹ جملہ ہے\" الٹ_سینٹینس = ریورس_سینٹینس (جملہ) پرنٹ (\"پرنٹ (\"الٹ جملہ: \"، الٹ_سینٹینس) یہ پروگرام پہلے کسی متن کے ساتھ جملے کے نام سے ایک تار شروع کرتا ہے۔اس کے بعد ، یہ ان پٹ کے طور پر ریورس_سینٹینس () فنکشن کو جملے کے ساتھ کال کرتا ہے اور اس کے نتیجے کو متغیر میں تبدیل کرتا ہے جسے الٹ_سینٹینس کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے الٹ جملے کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: الٹ جملہ: جملہ ٹیسٹ A ہے یہ آؤٹ پٹ ان پٹ جملہ میں انفرادی الفاظ کو تبدیل کیے بغیر الٹ جملے کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "\"اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کے پش ، پاپ اور جھانکنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو اسٹیک اور اس کے پش ، پاپ ، اور جھانکنے کے طریقوں کی نمائندگی کرتی ہے: پائیٹونکلاس اسٹیک: ڈیف __init __ (خود): سیلف۔ آئٹمز = [] ڈیف پش (خود ، آئٹم)(خود): اگر خود نہیں۔ IS_EMPTY (): واپس کریں۔(self.items) == 0 یہ کلاس اسٹیک کلاس والے اسٹیک کی نمائندگی کرتی ہے۔__init __ () طریقہ اسٹیک عناصر کو ذخیرہ کرنے کے لئے آئٹم نامی خالی فہرست کی ابتدا کرتا ہے۔پش () کا طریقہ کسی شے کو ان پٹ کے طور پر لے جاتا ہے اور اس کو ضمیمہ () کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے اوپری حصے میں شامل کرتا ہے۔اگر اسٹیک خالی نہیں ہے تو پاپ () کا طریقہ پاپ () کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے اوپری عنصر کو ہٹاتا ہے اور واپس کرتا ہے۔اگر اسٹیک خالی نہیں ہے تو انڈیکس -1 کا استعمال کرتے ہوئے جھانکنے والا () طریقہ اسٹیک کے اوپری عنصر کو لوٹاتا ہے۔اگر اسٹیک خالی اور غلط ہے تو IS_EMPTY () کا طریقہ درست لوٹتا ہے۔ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonmy_stack = اسٹیک () my_stack.push (1) my_stack.push (2) my_stack.push (3) پرنٹ(\"ٹاپ عنصر:\" ، my_stack.peek ()) پرنٹ (\"پاپڈ عنصر:\" ، my_stack.pop ()) پرنٹ (\"پاپڈ عنصر:\" ، my_stack.pop ()) پرنٹ (\"کیا اسٹیک خالی ہے؟\"، my_stack.is_empty ()) یہ پروگرام پہلے کچھ عناصر کے ساتھ My_stack نامی ایک اسٹیک کی ابتدا کرتا ہے۔اس کے بعد ، یہ پش () ، جھانکنے () ، پاپ () ، اور آئی ایس پیٹی () مائی_ اسٹیک آبجیکٹ کے طریقوں کو کہتے ہیں اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتائج کو پرنٹ کرتے ہیں۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹاپ عنصر: 3 پیپ عنصر: 3 پیپ عنصر: 2 کیا اسٹیک خالی ہے؟فالسیتیس آؤٹ پٹ اسٹیک کا اوپری عنصر ، پاپڈ عناصر ، اور چاہے اسٹیک خالی ہے یا نہیں۔"
    },
    {
        "Question": "آرڈر کو محفوظ رکھتے ہوئے کسی فہرست سے نقل کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں آرڈر کو محفوظ رکھتے ہوئے کسی فہرست سے نقلیں ہٹانے کے ل we ، ہم فہرست (DICK.FROMKEYS (فہرست)) کا طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائتھونڈف ہٹائیں_ڈوپلیکیٹس (ایل ایس ٹی): ریٹرن لسٹ (ڈکٹ.فومکیز (ایل ایس ٹی)) یہ فنکشن ان پٹ کے طور پر ایک فہرست لی ایس ٹی لیتا ہے اور آرڈر کو محفوظ رکھتے ہوئے ہٹا دیئے گئے ڈپلیکٹس کے ساتھ ایک نئی فہرست لوٹاتا ہے۔یہ سب سے پہلے فہرست کو لغت میں تبدیل کرتا ہے۔اس کے بعد ، یہ فہرست () کنسٹرکٹر کا استعمال کرتے ہوئے لغت کو دوبارہ فہرست میں تبدیل کرتا ہے۔چونکہ لغات کی چابیاں کی ترتیب کو محفوظ رکھتے ہیں ، فہرست آرڈرنگ محفوظ ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنلسٹ = [3 ، 1 ، 4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5]منفرد_لسٹ = ہٹائیں_ڈوپلیکیٹس (ایل ایس ٹی) پرنٹ (\"نقلوں کے ساتھ فہرست کو ہٹا دیا گیا ہے:\" ، منفرد_لسٹ) یہ پروگرام سب سے پہلے ایل ایس ٹی نامی فہرست کو کچھ نمبروں کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ ہٹانے_ڈوپلیکیٹس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں متغیر کو منفرد_لسٹ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے ہٹا دی گئی نقل کے ساتھ فہرست پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ڈپلیکٹس کے ساتھ فہرست ہٹا دی گئی: [3 ، 1 ، 4 ، 5 ، 9 ، 2 ، 6] اس آؤٹ پٹ کو ان پٹ کی فہرست میں عناصر کے ترتیب کو محفوظ کرتے ہوئے نقل کے ساتھ فہرست دکھائی گئی۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے ل we ، ہم لوپ یا تکرار کا استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال: ہم کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے ایک لوپ کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف فبونیکی (این): ایف آئی بی = [0 ، 1] جبکہ لین (فب) <این: ایف آئی بی ۔پینڈ (ایف آئی بی [-1] + ایف آئی بی [-2]) ریٹرن فبھیس فنکشن ایک انٹیجر این کے طور پر لیتا ہے۔ان پٹ اور فبونیکی تسلسل کی ایک فہرست کو ن تک لوٹاتا ہے۔اس نے پہلے ایف آئی بی کے نام سے ایک فہرست شروع کی ہے جس میں پہلے دو فبونیکی نمبر ہیں۔اس کے بعد ، اس فہرست میں آخری دو نمبر شامل کرکے اگلے فبونیکی نمبروں کا حساب لگانے کے لئے تھوڑی دیر کا استعمال کرتا ہے۔آخر میں ، یہ فبونیکی نمبروں کی فہرست لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن = 10fib_seq = fibonacci (n) پرنٹ (\"Fibonacci تسلسل\" تک \"، n ،\": \"، Fib_seq) یہ پروگرام پہلی بار شروع کرتا ہے۔انٹیجر نے N کو 10 کی قیمت کے ساتھ فون کیا۔ پھر ، یہ N کے ساتھ Fibonacci () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر میں اسٹور کرتا ہے جسے Fib_seq کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے ن تک فبونیکی تسلسل پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 10: [0 ، 1 ، 1 ، 1 ، 2 ، 3 ، 5 ، 8 ، 13 ، 21 ، 34] تک فبونیکی تسلسل] اس آؤٹ پٹ میں فبونیکی تسلسل کو ان پٹ نمبر N تک دکھایا گیا ہے جس کا استعمال کرتے ہوئے ان پٹ نمبر N تک حساب کیا گیا ہے۔Fibonacci () فنکشن۔ تکرار کا استعمال: ہم کسی دیئے گئے نمبر تک Fibonacci ترتیب کا حساب لگانے کے لئے تکرار کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف فائبونیکی (این): اگر n <= 1: واپسی n اور: واپس فیبونیکی (N-1) + fibonacci (N-2) یہ فنکشن ان پٹ کے طور پر ایک عدد N لے جاتا ہے اور NTH نمبر کو واپس کرتا ہےتکرار کا استعمال کرتے ہوئے Fibonacci ترتیب.یہ پہلے جانچ پڑتال کرتا ہے کہ آیا ان پٹ نمبر N 0 یا 1 ہے۔ اگر n 0 یا 1 ہے تو ، فنکشن واپس آجاتا ہے۔اگر n 1 سے زیادہ ہے تو ، فنکشن Fibonacci تسلسل میں N-1th اور N-2th نمبروں کا مجموعہ واپس کرتا ہے۔یہ وہ جگہ ہے جہاں تکرار کرنے والی فنکشن کال واقع ہوتی ہے ، جہاں فنکشن خود کو ان پٹ N-1 اور N-2 کے ساتھ کال کرتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonn = 10fib_seq = [fibonacci (i) I in Range (n))] پرنٹ (\"Fibonacci تسلسل تک\" ، N ، \":\" ، fib_seq) یہ پروگرام سب سے پہلے 10 کی قیمت کے ساتھ N نامی ایک عدد کا آغاز کرتا ہے۔ پھر ، یہ Fibonacci () کو ہر عدد کے ساتھ 0 سے N- تک فون کرتا ہے۔1 فہرست کی تفہیم کا استعمال کرتے ہوئے ان پٹ کے طور پر اور اس کے نتیجے میں ایک متغیر کو FIB_SEQ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے ن تک فبونیکی تسلسل پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 10: [0 ، 1 ، 1 ، 1 ، 2 ، 3 ، 5 ، 8 ، 13 ، 21 ، 34] تک فبونیکی تسلسل] اس آؤٹ پٹ میں فبونیکی تسلسل کو ان پٹ نمبر N تک دکھایا گیا ہے جس کا استعمال کرتے ہوئے ان پٹ نمبر N تک حساب کیا گیا ہے۔fibonacci () recursion کے ساتھ کام کرتا ہے"
    },
    {
        "Question": "بائنری درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کی اونچائی کا حساب لگانے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "ازگر میں بائنری درخت کی نمائندگی کرنے اور اس کی اونچائی کا حساب لگانے کے ل we ، ہم درخت میں ہر نوڈ کی نمائندگی کرنے کے لئے ٹرینوڈ کلاس کی وضاحت کرسکتے ہیں اور پورے درخت کی نمائندگی کرنے کے لئے درخت کی کلاس۔یہاں ایک مثال کے نفاذ ہے: پائیٹونکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل): سیلف.وال = ویل خود۔): اگر نوڈ کوئی نہیں ہے: واپس 0 اور: بائیں_ہائٹ = سیلف۔ ہائٹ (نوڈ۔ لیفٹ) رائٹ_ہائٹ = سیلف۔ ہائٹ (نوڈ۔ رائٹ) میکس ریٹرن میکس (بائیں_ہائٹ ، رائٹ_ہائٹ) + 1 اس پر عمل درآمد ایک ٹرینوڈ کلاس کی وضاحت کرتا ہے ، اے۔بائیں بچہ ، اور ایک دائیں بچہ۔یہ جڑ کے نوڈ کے ساتھ ایک درخت کی کلاس کی بھی وضاحت کرتا ہے۔اونچائی () کا طریقہ ان پٹ کے طور پر ایک نوڈ لیتا ہے اور اس نوڈ پر جڑے ہوئے سب ٹری کی اونچائی کو لوٹاتا ہے۔یہ پہلے چیک کرتا ہے کہ نوڈ کوئی نہیں ہے۔اگر یہ ہے تو ، طریقہ 0 لوٹتا ہے۔ بصورت دیگر ، یہ بار بار بائیں اور دائیں سبٹریز کی اونچائی کا حساب لگاتا ہے اور زیادہ سے زیادہ اونچائی کے علاوہ لوٹاتا ہے۔درخت.روٹ = ٹرینوڈ (1) درخت.روٹ.لفٹ = ٹرینوڈ (2) درخت.روٹ۔ رائٹ۔ رائٹ = ٹرینوڈ (3) درخت۔5)# درخت کی اونچائی = درخت کی اونچائی کا حساب لگائیں۔اس کے بعد ، یہ جڑ کے نوڈ کے ساتھ درخت آبجیکٹ کی اونچائی () طریقہ کو ان پٹ کے طور پر کہتے ہیں اور اس کے نتیجے کو ایک متغیر میں اونچائی کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے درخت کی اونچائی پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار ہوگی: درخت کی اونچائی: 3 اس آؤٹ پٹ کو بائنری درخت کی اونچائی دکھاتی ہے جس کا استعمال درخت آبجیکٹ کی اونچائی () طریقہ کا استعمال کرتے ہوئے ہوتا ہے۔"
    },
    {
        "Question": "نمبروں کی فہرست کے وسط کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں نمبروں کی فہرست کے درمیانی حصے کو تلاش کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: اعدادوشمار کے ماڈیول کا استعمال: ہم اعداد و شمار کی فہرست کے اوسط کو تلاش کرنے کے لئے اعداد و شمار کے ماڈیول سے اعداد و شمار.میدیان () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھونیمپورٹ شماریات ڈیف فائنڈ_میڈین (ایل ایس ٹی): ریٹرن شماریات۔ میڈیم (ایل ایس ٹی) یہ فنکشن ان پٹ کے طور پر ایک فہرست لی ایس ٹی لیتا ہے اور اعدادوشمار کا استعمال کرتے ہوئے فہرست کے میڈین کو لوٹاتا ہے۔ استعمال کیا جائے۔فنکشن: pythonlst = [3 ، 1 ، 4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5] میڈین = Find_median (LST) پرنٹ (\"فہرست کا میڈین:\" ، میڈین) یہ پروگرام پہلے شروع ہوتا ہےکچھ تعداد کے ساتھ ایل ایس ٹی نامی ایک فہرست۔اس کے بعد ، یہ LST کے ساتھ find_median () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو میڈین نامی متغیر میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست کے میڈین کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: فہرست کا میڈین: 5 اس آؤٹ پٹ کو فائنڈ_میڈین () فنکشن کا استعمال کرتے ہوئے ان پٹ لسٹ کا میڈین دکھاتا ہے۔ نیپی ماڈیول کا استعمال کرتے ہوئے: ہم numpy.median () فنکشن کو numpy ماڈیول سے استعمال کرسکتے ہیں۔نمبروں کی فہرست کا اوسط تلاش کرنے کے لئے۔یہاں ایک مثال کے نفاذ ہے: پائیتھونیمپورٹ نیمپی بطور NPDEF Find_median (LST): واپسی NP.Median (LST) یہ فنکشن ایک فہرست LST لے جاتا ہے اور Numpy.Median () فنکشن کا استعمال کرتے ہوئے فہرست کے میڈین کو واپس کرتا ہے۔فنکشن کو استعمال کرنے کے لئے: pythonlst = [3 ، 1 ، 4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5 ، 5] میڈین = Find_median (LST) پرنٹ (\"فہرست کا میڈین:\" ، میڈین) اس پروگرام کوپہلے کچھ نمبروں کے ساتھ ایل ایس ٹی نامی ایک فہرست کی ابتدا کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ find_median () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو میڈین نامی متغیر میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست کے میڈین کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: فہرست کا میڈین: 5.0 اس آؤٹ پٹ کو تلاش کریں۔نمبروں کییہاں ایک مثال کے نفاذ ہے: پائتھنڈف فاؤنڈ_میڈین (ایل ایس ٹی): این = لین (ایل ایس ٹی) ایس = ترتیب (ایل ایس ٹی) اگر این ٪ 2 == 0: واپسی (ایس [این // 2-1] + ایس [این // 2])/2 اور: واپسی s [n // 2] یہ فنکشن ان پٹ کے طور پر ایک فہرست لیتا ہے اور فہرست کے میڈین کو واپس کرتا ہے۔یہ پہلے فہرست کی لمبائی کا حساب لگاتا ہے اور ترتیب شدہ () فنکشن کا استعمال کرتے ہوئے فہرست کو ترتیب دیتا ہے۔پھر ، یہ جانچ پڑتال کرتا ہے کہ آیا فہرست کی لمبائی برابر ہے یا عجیب ہے۔اگر یہ بھی ہے تو ، یہ درمیانی دو نمبروں کی اوسط لوٹاتا ہے۔اگر یہ عجیب ہے تو ، یہ درمیانی نمبر لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونلسٹ = [3 ، 1 ، 4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5 ، 5] میڈین = فائنڈ_میڈین (LST) پرنٹ (\"فہرست کا میڈین:\" ، میڈین) یہ پروگرام سب سے پہلے ایل ایس ٹی نامی فہرست کو کچھ نمبروں کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ find_median () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو میڈین نامی متغیر میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست کے میڈین کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: فہرست کا میڈین: 5 اس آؤٹ پٹ کو ان پٹ لسٹ کا میڈین دکھاتا ہے جس کا استعمال Find_median () فنکشن کا استعمال کرتے ہوئے کیا جاتا ہے۔"
    },
    {
        "Question": "کسی دیئے گئے ٹیکسٹ فائل میں ہر لفظ کے واقعات کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں دیئے گئے ٹیکسٹ فائل میں ہر لفظ کے واقعات کو گننے کے ل we ، ہم فائل کو پڑھ سکتے ہیں ، ہر لکیر کو الفاظ میں تقسیم کرسکتے ہیں ، اور ہر لفظ کے واقعات کو گننے کے لئے لغت کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف گنتی_ ورڈز (فائل نام): ورڈ_کاؤنٹ = {} اوپن (فائل کا نام ، 'آر') کے ساتھ ایف کے طور پر: f: الفاظ میں الفاظ = لائن.سپلٹ () الفاظ میں الفاظ کے لئے: اگر ورڈ_کاؤنٹ میں لفظ: ورڈ_کاؤنٹ[ورڈ] += 1 اور: ورڈ_کاؤنٹ [ورڈ] = 1 ریٹرن ورڈ_کونٹ یہ فنکشن ان پٹ کے طور پر فائل کا نام لیتا ہے اور فائل میں ہر لفظ کی موجودگی کی گنتی کے ساتھ ایک لغت واپس کرتا ہے۔یہ پہلے ایک خالی لغت کو شروع کرتا ہے جسے ورڈ_کاؤنٹ کہتے ہیں۔اس کے بعد ، یہ کھلی () فنکشن کا استعمال کرتے ہوئے فائل کھولتا ہے اور فائل میں ہر لائن کو پڑھتا ہے۔یہ ہر ایک لفظ کے ذریعے اسپلٹ () کے طریقہ کار اور لوپ کا استعمال کرتے ہوئے ہر لکیر کو الفاظ میں تقسیم کرتا ہے۔اگر یہ لفظ پہلے ہی ورڈ_کاؤنٹ لغت میں ہے تو ، اس سے گنتی میں اضافہ ہوتا ہے۔بصورت دیگر ، اس لفظ کو لغت میں 1 کی گنتی کے ساتھ شامل کرتا ہے۔ہر لفظ کا: \") لفظ کے لئے ، ورڈ_کاؤنٹ میں گنتی کریں۔اس کے بعد ، یہ فائل نام کے ساتھ گنتی_ ورڈز () کو ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو ورڈ_کاؤنٹ نامی متغیر میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فائل میں ہر لفظ کے واقعات کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ہر لفظ کی موجودگی: یہ: 1IS: 2AN: 1Example: 1File: 2to: 1Count: 1TE: 1OCCURTENSS: 1OF: 1of: 1 ورڈ: 1 ورڈ: 1 یہ آؤٹ پٹ ان پٹ فائل میں ہر لفظ کی موجودگی کو ظاہر کرتا ہےگنتی_ ورڈز () فنکشن کا استعمال کرتے ہوئے حساب کیا گیا ہے"
    },
    {
        "Question": "ایک فنکشن بنائیں جو چیک کرتا ہے کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں۔",
        "Answer": "یہ چیک کرنے کے بہت سارے طریقے ہیں کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں جو ازگر میں ہیں۔یہاں کچھ مثالیں ہیں: ایک لغت کا استعمال: ہم تار میں ہر کردار کی تعدد کو گننے کے لئے ایک لغت کا استعمال کرسکتے ہیں۔ہم دو لغتیں تشکیل دے سکتے ہیں ، ہر ایک تار کے لئے ایک ، اور ہر کردار کی تعداد کی گنتی کر سکتے ہیں۔اگر لغات برابر ہیں ، تو پھر دو اصل ڈور اناگرام ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف آئی ایس_انگم (ایس ٹی آر 1 ، ایس ٹی آر 2): اگر لین (ایس ٹی آر 1)! = لین (ایس ٹی آر 2): غلط ڈکٹ 1 = {} ڈکٹ 2 = {} str1 میں چار کے لئے: اگر ڈکٹ 1 میں چار: ڈکٹ 1 [چار] += 1 اور: DICT1 [CHAR] = 1 STR2 میں CHAR کے لئے: اگر DICT2 میں چار: DICT2 [CHAR] += 1 اور: DICT2 [CHAR] = 1 ریٹرن ڈکٹ 1 == ڈکٹ 2 اس فنکشن میں دو اسٹرنگز STR1 اور STR2 کو ان پٹ کے طور پر لیتا ہے اوراگر وہ ایک دوسرے کے اناگرام ہیں اور دوسری صورت میں جھوٹے ہیں تو سچائی لوٹتے ہیں۔یہ پہلے چیک کرتا ہے کہ آیا دونوں ڈوروں کی لمبائی برابر ہے۔اس کے بعد ، یہ دو لغات اور ڈکٹ 2 کو تخلیق کرتا ہے تاکہ دونوں تاروں میں ہر کردار کی فریکوئنسی کو گنیں۔یہ دو تاروں میں ہر ایک کردار کے ذریعے کھڑا ہوتا ہے اور اسی لغت میں گنتی میں اضافہ کرتا ہے۔آخر میں ، اگر یہ دونوں لغات برابر اور غلط ہیں تو یہ سچ ثابت ہوتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھ اسٹرن 1 = \"اینگگرام\" str2 = \"نگرام\" پرنٹ (is_anagram (str1 ، str2)) # Truestr1 = \"ہیلو\"str2 = \"ورلڈ\" پرنٹ (is_anagram (str1 ، str2)) # فالسیتیس پروگرام سب سے پہلے str1 اور str2 نامی دو تار کو کچھ متن کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ STR1 اور STR2 کے ساتھ IS_ANAGRAM () کو ان پٹ کے طور پر فون کرتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹریفلستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا یہ دو ان پٹ ڈور ایک دوسرے کے اناگرام ہیں یا نہیں۔اگر ترتیب دیئے گئے ڈور برابر ہیں ، تو دو اصل ڈور اناگرام ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھونڈف آئی ایس_انگرم (ایس ٹی آر 1 ، ایس ٹی آر 2): اگر لین (ایس ٹی آر 1)! = لین (ایس ٹی آر 2): غلط ترتیب والے_سٹر 1 = ترتیب شدہ (ایس ٹی آر 1) ترتیب شدہ (str1) ترتیب شدہ (str2) ریٹرن sharted_str1 == sharted_str2th icstr2 بطور ان پٹ اور واپس آجاتا ہے اگر وہ ایک دوسرے کے اناگرام ہیں اور دوسری صورت میں غلط ہیں۔یہ پہلے چیک کرتا ہے کہ آیا دونوں ڈوروں کی لمبائی برابر ہے۔اس کے بعد ، یہ ترتیب شدہ () فنکشن کا استعمال کرتے ہوئے دونوں ڈوروں کو ترتیب دیتا ہے اور درست لوٹتا ہے اگر ترتیب شدہ ڈور مساوی اور غلط ہیں تو دوسری صورت میں۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھ اسٹرن 1 = \"اینگگرام\" str2 = \"ناگرم\" پرنٹ (is_anagram (str1 (str1)، str2)) # truestr1 = \"ہیلو\" str2 = \"ورلڈ\" پرنٹ (is_Anagram (str1 ، str2)) # فالسیتیس پروگرام سب سے پہلے str1 اور str2 نامی دو تار کو کچھ متن کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ STR1 اور STR2 کے ساتھ IS_ANAGRAM () کو ان پٹ کے طور پر فون کرتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹریفلستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا دونوں ان پٹ ڈور ایک دوسرے کے اناگرام ہیں یا نہیں۔"
    },
    {
        "Question": "کسی مثبت عدد میں ہندسوں کی رقم کا حساب لگانے کے لئے ایک تکرار فنکشن کو نافذ کریں۔",
        "Answer": "ایک مثبت عدد میں ہندسوں کی رقم کا حساب لگانے کے لئے ازگر میں ایک بار بار بار چلنے والے فنکشن کا نفاذ: پائیتھنڈف SUM_OF_DIGITS (N): اگر N <10: واپسی N ELSE: واپسی N ٪ 10 + SUM_OF_DIGITS (N // 10) اس فنکشنان پٹ کے طور پر ایک مثبت انٹیجر این لیتا ہے اور تکرار کا استعمال کرتے ہوئے اپنے ہندسوں کا مجموعہ واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا ان پٹ نمبر N 10 سے کم ہے۔ اگر N 10 سے کم ہے تو ، فنکشن واپس آجاتا ہے۔بصورت دیگر ، یہ N کے آخری ہندسے کا مجموعہ اور N.HERE کے بقیہ ہندسوں کے ساتھ فنکشن کو بار بار کال کرنے کا نتیجہ لوٹاتا ہے۔\"، این ،\": \"، خلاصہ میں ہندسے) یہ پروگرام سب سے پہلے 12345 کی قیمت کے ساتھ N نامی ایک عدد کا آغاز کرتا ہے۔ پھر ، یہ N کے ساتھ Sum_of_digits () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں متغیر کو Sum کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N میں ہندسوں کا مجموعہ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 12345: 15 میں ہندسوں کا مجموعہ ان پٹ نمبر N میں ہندسوں کا مجموعہ ظاہر کرتا ہے جس کا استعمال کرتے ہوئے SUM_OF_DIGITS () فنکشن کا استعمال کیا جاتا ہے۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سب سے بڑی مستقل رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں دیئے گئے عدد کی فہرست میں سب سے بڑی مستقل رقم تلاش کرنے کے ل we ، ہم کڈانے کے الگورتھم کو استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھونڈف میکس_سوبری_سم (ایل ایس ٹی): میکس_سم = ایل ایس ٹی [0] موجودہ_سم = ایل ایس ٹی [0] رینج (1 ، لین (ایل ایس ٹی)) کے لئے]) میکس_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) واپسی میکس_سومتھ فنکشن ان پٹ کی حیثیت سے ایک فہرست لیتا ہے اور کڈانے کے الگورتھم کا استعمال کرتے ہوئے فہرست میں سب سے بڑی مستقل رقم واپس کرتا ہے۔یہ پہلے فہرست کے پہلے عنصر میں دو متغیر میکس_سم اور کرنٹ_سم کی ابتدا کرتا ہے۔اس کے بعد ، یہ باقی فہرست میں شامل ہے اور موجودہ انڈیکس میں ختم ہونے والے سبری کے زیادہ سے زیادہ جوڑے کا حساب لگاتا ہے جس کا استعمال فارمولا موجودہ_سم = میکس (LST [i] ، کرنٹ_سم + ایل ایس ٹی [i]) کا استعمال کرتے ہوئے ہوتا ہے۔یہ اب تک کی زیادہ سے زیادہ رقم کے ساتھ میکس_سم متغیر کو بھی اپ ڈیٹ کرتا ہے۔آخر میں ، یہ میکس_سم متغیر کو لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھونلسٹ = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] میکس_سم = میکس_سوبری_سم (LST) پرنٹ(\"فہرست میں سب سے بڑی مستقل رقم:\" ، میکس_سم) یہ پروگرام سب سے پہلے ایل ایس ٹی نامی فہرست کو کچھ انٹیجرز کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ MAX_SUBARRAY_SUM () کو ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو متغیر میں میکس_سم کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست میں سب سے بڑی مستقل رقم پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: فہرست میں سب سے بڑی مستقل رقم: 6 اس آؤٹ پٹ میکس_سوبری_سم () فنکشن کا استعمال کرتے ہوئے ان پٹ لسٹ میں سب سے بڑی مستقل رقم دکھاتا ہے۔"
    },
    {
        "Question": "ایک قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور اس کے تزئین و آرائش اور dequeue طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس کا ایک مثال عمل ہے جو اس کے enqueue اور dequeue طریقوں کے ساتھ قطار کی نمائندگی کرتا ہے: پائیٹونکلاس قطار: Def __init __ (خود): self.items = [] Def enqueue (خود ، آئٹم)dequeue (خود): اگر خود نہیں== 0 یہ عمل درآمد __init __ () کے ساتھ ایک قطار کلاس کی وضاحت کرتا ہے جس میں آئٹمز نامی خالی فہرست شروع کرنے کے لئے طریقہ ، قطار کے اختتام پر کسی شے کو شامل کرنے کے لئے ایک enqueue () طریقہ ، ایک dequeue () طریقہ کو ختم کرنے اور واپس کرنے کے لئے ایک dequeue () طریقہقطار کے سامنے ، اور ایک is_empty () طریقہ یہ چیک کرنے کے لئے کہ قطار خالی ہے یا نہیں۔ ڈیکوئ () کا طریقہ چیک کرتا ہے کہ اگر کسی شے کو ختم کرنے سے پہلے قطار خالی ہے تو۔اگر قطار خالی ہے تو ، یہ ایک مناسب غلطی کے پیغام کے ساتھ ایک انڈیکس ایرر اٹھاتا ہے۔ قطار کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھون کیوئو = قطار () قطار۔ انکیو (1) قطار۔ انکیو (2) قطار۔ enqueue (3)پرنٹ (قطار.Dequeue ()) # 1 پرنٹ (قطار.Dequeue ()) # 2 پرنٹ (قطار.IS_EMPTY ()) # غلط پرنٹ (قطار.Dequeue ()) # 3 پرنٹ (قطار.IS_EMPTY ()) # TRUETHIS پروگرام پہلے ایک تخلیق کرتا ہےقطار کلاس کی مثال کے نام سے کہا جاتا ہے۔اس کے بعد ، یہ enqueue () طریقہ کار کا استعمال کرتے ہوئے قطار میں تین آئٹموں کو تیار کرتا ہے اور ڈی کیوئ () کے طریقہ کار کا استعمال کرتے ہوئے ان کو ڈی کیو کرتا ہے۔آخر میں ، یہ چیک کرتا ہے کہ آیا IS_EMPTY () طریقہ کار کا استعمال کرتے ہوئے قطار خالی ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 12false3Truethis آؤٹ پٹ قطار کلاس کا استعمال کرتے ہوئے قطار آبجیکٹ پر انجام دی جانے والی enqueue اور dequeue آپریشنز کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "کسی فنکشن کو نافذ کریں جو چیک کرتا ہے کہ اگر کوئی دی گئی تعداد ایک اہم نمبر ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے نمبر ازگر میں ایک اہم نمبر ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال: ہم یہ چیک کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں کہ آیا رینج (2 ، N-1) میں تمام نمبروں پر لوپنگ کرکے کوئی نمبر اہم ہے یا نہیں۔اگر ہمیں کوئی ایسا عنصر مل جاتا ہے جو باقی کے بغیر N کو یکساں طور پر تقسیم کرتا ہے تو ، ہم فوری طور پر یہ نتیجہ اخذ کرسکتے ہیں کہ تعداد اہم نہیں ہے۔اگر ہم نمبروں کی پوری رینج کو 2 سے لے کر N - 1 تک کسی نمبر کی تلاش کیے بغیر N کو یکساں طور پر تقسیم کرتے ہیں ، تو یہ تعداد اہم ہے۔یہاں ایک مثال عمل ہے: پائیتھنڈف آئی ایس_پائم (این): اگر ن <2: رینج (2 ، این) میں I کے لئے جھوٹی لوٹ لوٹیں (2 ، این): اگر n ٪ i == 0: واپس جھوٹی ریٹرن ٹروٹیس فنکشن ان پٹ کے طور پر ایک عددی n لیتا ہے اور سچ واپس آتا ہےاگر یہ ایک اہم نمبر ہے اور دوسری صورت میں غلط ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا ان پٹ نمبر N 2 سے کم ہے اگر N 2 سے کم ہے تو ، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، یہ رینج (2 ، این) کی تمام تعداد میں گھومتا ہے اور چیک کرتا ہے کہ اگر ان میں سے کوئی بھی باقی کے بغیر این کو یکساں طور پر تقسیم کرتا ہے۔اگر اسے کوئی ایسا عنصر مل جاتا ہے جو N کو یکساں طور پر تقسیم کرتا ہے تو ، یہ غلط لوٹاتا ہے۔بصورت دیگر ، یہ سچائی لوٹتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن = 17 پرنٹ (is_prime (n)) # Truen = 20 پرنٹ (is_prime (n)) # فالستھیس پروگرام سب سے پہلے N کی قیمت کے ساتھ N نامی ایک عدد کی ابتدا کرتا ہے اور20. پھر ، یہ IS_PRIME () کو N کے ساتھ ان پٹ کے طور پر فون کرتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹری فالستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا ان پٹ نمبر ایک پرائم نمبر ہے یا آئی ایس_ پرائم () فنکشن کا استعمال کرتے ہوئے اس کا حساب نہیں کیا گیا ہے۔ سمپی ماڈیول کا استعمال کرتے ہوئے: ہم سمپی.سپریم () فنکشن کو سمپی ماڈیول سے لے کر استعمال کرسکتے ہیں۔چیک کریں کہ آیا کوئی نمبر پرائم ہے یا نہیں۔یہاں ایک مثال عمل ہے: ازگر سمپی امپورٹ ISPrimedef is_prime (n): واپسی isprime (n) یہ فنکشن ان پٹ کے طور پر ایک عدد N کی ضرورت ہے اور اگر یہ ایک اہم نمبر ہے اور غلط ہے تو دوسری صورت میں سمپی.سپریم () فنکشن کا استعمال کرتے ہوئے۔فنکشن کو کس طرح استعمال کریں اس کی مثال: پائیٹون = 17 پرنٹ (is_prime (n)) # TRUEN = 20 پرنٹ (is_prime (n)) # فالسیتیس پروگرام سب سے پہلے N نامی ایک عدد کی ابتداء 17 اور 20 کی قیمت کے ساتھ کرتا ہے۔ پھر ، یہ IS_PRIME کو فون کرتا ہے۔() N کے ساتھ ان پٹ کے طور پر کام کریں اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کریں۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹریفلستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا ان پٹ نمبر ایک پرائم نمبر ہے یا سمپی ماڈیول سے آئی ایس_ پرائم () فنکشن کا استعمال کرتے ہوئے اس کا حساب نہیں لگایا گیا ہے۔ازگر میں بنیادی نمبر"
    },
    {
        "Question": "اعشاریہ نمبر کو اس کی بائنری نمائندگی میں تبدیل کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "اعشاریہ کی تعداد کو ازگر میں اس کی بائنری نمائندگی میں تبدیل کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: فارمیٹ () فنکشن کا استعمال کرتے ہوئے: ہم اعشاریہ نمبر کو اس کی ثنائی نمائندگی میں تبدیل کرنے کے لئے 'B' فارمیٹ کے مخصوص شکل () کے ساتھ فارمیٹ () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف اعشاریہ_ٹو_بائنری (این): ریٹرن فارمیٹ (این ، 'بی') یہ فنکشن ان پٹ کے طور پر ایک عدد این لیتا ہے اور 'بی' فارمیٹ کے ساتھ فارمیٹ () فنکشن کا استعمال کرتے ہوئے اپنی بائنری نمائندگی واپس کرتا ہے۔فنکشن کو کس طرح استعمال کرنے کا طریقہ: pythonn = 10binary = decimal_to_binary (n) پرنٹ (\"بائنری نمائندگی\" ، این ، \":\" ، بائنری) اس پروگرام میں پہلے ایک عدد کا آغاز 10 کی قیمت کے ساتھ ہوتا ہے۔ پھر ، یہ کال کرتا ہےاعشاریہ_ٹو_بائنری () این کے ساتھ ان پٹ کے طور پر کام کرتا ہے اور اس کے نتیجے کو ایک متغیر میں بائنری کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N کی بائنری نمائندگی پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 10: 1010 کی بائنری نمائندگی اس آؤٹ پٹ کو ان پٹ نمبر N کی بائنری نمائندگی ظاہر کرتی ہے جس کا استعمال اعشاریہ_ٹو_بائنری () فنکشن کا استعمال کرتے ہوئے کیا جاتا ہے۔اس کی بائنری نمائندگی کے لئے ایک اعشاریہ۔یہاں ایک مثال کے نفاذ ہے: پائیتھونڈف اعشاریہ اعشاریہ_ٹو_بائنری (این): ریٹرن بن (این) [2:] یہ فنکشن ان پٹ کے طور پر ایک عدد این لیتا ہے اور بن () فنکشن کا استعمال کرتے ہوئے اپنی بائنری نمائندگی لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے۔pythonn = 10barinary = decimal_to_binary (n) پرنٹ (\"بائنری نمائندگی\" ، n ، \":\" ، بائنری) یہ پروگرام پہلے 10 کی قیمت کے ساتھ n نامی ایک عدد کا آغاز کرتا ہے۔ پھر ، اس کو N کے ساتھ اعشاریہ_ٹو_بائنری () فنکشن کہتے ہیں۔جیسا کہ ان پٹ اور اسٹور کرتا ہے اس کا نتیجہ بائنری نامی متغیر میں ہوتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N کی بائنری نمائندگی پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 10: 1010 کی بائنری نمائندگی اس آؤٹ پٹ کو ظاہر کرتا ہے کہ ان پٹ نمبر N کی بائنری نمائندگی ظاہر ہوتی ہے جس کا استعمال اعشاریہ_ٹو_بائنری () فنکشن کا استعمال کرتے ہوئے کیا جاتا ہے۔ازگر میں"
    },
    {
        "Question": "ایک فنکشن بنائیں جو ایک فہرست کو ایک دیئے گئے تعداد کے ذریعہ دائیں طرف گھومتا ہے۔",
        "Answer": "ازگر میں دیئے گئے ایک دیئے گئے مراحل کے ذریعہ دائیں طرف فہرست کو گھمانے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: سلائسنگ کا استعمال: ہم کسی دیئے گئے تعداد کے ذریعہ کسی فہرست کو دائیں طرف گھمانے کے لئے سلائسنگ کا استعمال کرسکتے ہیں۔ہم فہرست کو انڈیکس لین (LST) - K میں دو حصوں میں تقسیم کرسکتے ہیں ، جہاں K فہرست کو گھمانے کے لئے اقدامات کی تعداد ہے۔اس کے بعد ، ہم گھومے ہوئے فہرست کو حاصل کرنے کے لئے دوسرے حصے کے ساتھ دوسرے حصے کو جوڑ سکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف روٹیٹ_ رائٹ (ایل ایس ٹی ، کے): این = لین (ایل ایس ٹی) K = K ٪ N ریٹرن LST [N-K:] + LST [: N-K] اس فنکشن میں فہرست LST اور ایک عددی K کو ان پٹ اور ریٹرن کے طور پر لیتا ہے۔فہرست سلائسنگ کا استعمال کرتے ہوئے K مراحل کے ذریعہ دائیں طرف گھوم گئی۔یہ سب سے پہلے ن کے ساتھ کے ماڈیولس کو لے کر لسٹ ن کی لمبائی اور K کی موثر تعداد کا حساب لگاتا ہے۔اس کے بعد ، یہ سلائسنگ کا استعمال کرتے ہوئے انڈیکس این-کے میں دو حصوں میں اس فہرست کو تقسیم کرتا ہے اور گھومے ہوئے فہرست کو حاصل کرنے کے لئے دوسرے حصے کے ساتھ دوسرے حصے کو جوڑتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونلسٹ = [1 ، 2 ، 3 ، 4.2 کی قیمت 2 کے بعد ، یہ LST اور K کے ساتھ ROTATE_RIGHT () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں ایک متغیر میں گھومنے والا_لسٹ ہوتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے اصل اور گھماؤ فہرستوں کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: اصل فہرست: [1 ، 2 ، 3 ، 4 ، 5] گھومے ہوئے فہرست: [4 ، 5 ، 1 ، 2 ، 3] یہ آؤٹ پٹ روٹیٹ_ رائٹ (جس کا استعمال کرتے ہوئے حساب کی گئی اصل اور گھماؤ فہرستوں کو دکھاتا ہے (() فنکشن۔ ایک لوپ کا استعمال: ہم ایک لوپ کا استعمال کسی مخصوص تعداد میں دائیں طرف گھومنے کے لئے کرسکتے ہیں۔ہم فہرست کے اوقات میں لوپ کرسکتے ہیں اور ہر تکرار میں فہرست کے آخری عنصر کو فہرست کے سامنے منتقل کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف روٹیٹ_ رائٹ (ایل ایس ٹی ، کے): این = لین (ایل ایس ٹی) K = K ٪ N کے لئے I IN RAND (K): LST.INSERT (0 ، LST.POP ()) ریٹرن LSTTHIS فنکشن ایک فہرست لیتا ہےLST اور ایک انٹیجر K ان پٹ کے طور پر اور لوپ کا استعمال کرتے ہوئے K کے قدموں کے ذریعہ دائیں طرف گھومتے ہیں۔یہ سب سے پہلے ن کے ساتھ کے ماڈیولس کو لے کر لسٹ ن کی لمبائی اور K کی موثر تعداد کا حساب لگاتا ہے۔اس کے بعد ، یہ فہرست کے اوقات میں شامل ہے اور فہرست کے آخری عنصر کو داخل () اور پاپ () طریقوں کا استعمال کرتے ہوئے ہر تکرار میں فہرست کے سامنے کی طرف لے جاتا ہے۔ اس فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonlst = [1 ، 2 ، 3 ، 4 ، 5] k = 2rotated_lst = rotate_right (lst ، k) پرنٹ (\"اصل فہرست:\" ، LST) پرنٹ (\"گھومے ہوئے فہرست:\" ، گھومے ہوئے_لسٹ) یہ پروگرام پہلے ایل ایس ٹی کے نام سے ایک فہرست شروع کرتا ہے۔انٹیجرز اور ایک انٹیجر جس کو 2 کی قیمت کے ساتھ K کہا جاتا ہے ، اس کے بعد ، یہ LST اور K کے ساتھ گھومنے والی_ رائٹ () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں ایک متغیر میں گھومنے والا_لسٹ ہوتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے اصل اور گھماؤ فہرستوں کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: اصل فہرست: [1 ، 2 ، 3 ، 4 ، 5] گھومے ہوئے فہرست: [4 ، 5 ، 1 ، 2 ، 3] یہ آؤٹ پٹ روٹیٹ_ رائٹ (جس کا استعمال کرتے ہوئے حساب کی گئی اصل اور گھماؤ فہرستوں کو دکھاتا ہے (() فنکشن.بوت کے نفاذ درست ہیں اور اس کی فہرست کو دائیں طرف گھومنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ایک تکرار والی تقریب کو نافذ کریں۔",
        "Answer": "یہاں دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ازگر میں ایک تکرار کرنے والے فنکشن کا ایک مثال عمل ہے: پیتھنڈف فیکٹوریئل (این): اگر n == 0: واپسی 1 اور: ریٹرن این * فیکٹوریئل (این -1) اس فنکشن میں ایک مثبت عدد لیتا ہےn بطور ان پٹ اور تکرار کا استعمال کرتے ہوئے اس کی حقیقت کو واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا ان پٹ نمبر N 0 کے برابر ہے۔ اگر n 0 کے برابر ہے تو ، فنکشن واپس آجاتا ہے۔ 1 بصورت دیگر ، یہ N کی مصنوعات اور N-1 کے ساتھ فنکشن کو بار بار کال کرنے کا نتیجہ لوٹاتا ہے۔ اس کی ایک مثال ہے۔فنکشن کو کس طرح استعمال کریں: pythonn = 5 فیکٹ = فیکٹوریئل (n) پرنٹ (\"حقیقت پسند\" ، n ، \":\" ، حقیقت) یہ پروگرام پہلے N نامی ایک عدد کا آغاز 5 کی قیمت کے ساتھ کرتا ہے۔ پھر ، یہ حقیقت پسندانہ کہتے ہیں (یہ حقیقت پسند ہے () N کے ساتھ ان پٹ کے طور پر کام کریں اور اس کے نتیجے میں ایک متغیر کو حقیقت میں کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N کی حقیقت پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 5: 120 کی حقیقت پسندی سے یہ معلوم ہوتا ہے کہ فیکٹوریل () فنکشن کا استعمال کرتے ہوئے ان پٹ نمبر N کا حساب کتاب کیا جاتا ہے۔ نوٹ کریں کہ بار بار فنکشن کالز کی وجہ سے ن کی بڑی اقدار کے لئے تکرار کرنے والا فنکشن سست ہوسکتا ہے۔اس طرح کے معاملات میں ، بہتر ہے کہ حقیقت پسندی کا حساب لگانے کے لئے تکراری نقطہ نظر یا یادداشت کا استعمال کریں۔"
    },
    {
        "Question": "گراف کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور گہرائی کی پہلی تلاش کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک گراف کی نمائندگی کرنے والے ایک ازگر طبقے کی ایک مثال ہے اور گہرائی سے پہلے تلاش کرنے کا طریقہ: پائیٹونکلاس گراف: ڈیف __init __ (خود): سیلف گراف = {} ڈیف ایڈ_ج (خود ، یو ، وی): اگر آپ نہیں ہیںسیلف گراف میں: سیلف گراف [u] = [] self.graph [u] .append (v) Def dfs (خود ، شروع ، دورہ = کوئی بھی نہیں): اگر ملاحظہ کیا گیا تو کوئی نہیں: ملاحظہ کریں = سیٹ () ملاحظہ کریں۔(اسٹارٹ) پرنٹ (اسٹارٹ) اگلے کے لئے۔ گراف [اسٹارٹ] - ملاحظہ کریں: سیلف ڈاٹ ایف ایس (اگلا ، ملاحظہ کیا گیا)# مثال کے طور پر استعمال کریں۔g.add_edge (1 ، 2) g.add_edge (2 ، 0) g.add_edge (2 ، 3) g.add_edge (3 ، 3) پرنٹ (\"گہرائی کا پہلا ٹراورسل (ورٹیکس 2 سے شروع ہوتا ہے):\") جی ڈی ایف ایس(2) اس عمل سے گراف نامی خالی لغت ، گراف میں ایک کنارے شامل کرنے کے لئے ایک ADD_EDGE () طریقہ ، اور DFS () کے طریقہ کار کو شروع کرنے کے لئے ایک گراف کلاس کی وضاحت کی گئی ہے جس میں گراف کو ایک کنارے شامل کرنے کا طریقہ ، اور ڈی ایف ایس () کا طریقہکسی دیئے گئے ورٹیکس سے۔ ڈی ایف ایس () کا طریقہ ایک ابتدائی ورٹیکس اسٹارٹ لیتا ہے اور ان پٹ کے طور پر دورہ کرنے والے چوڑائیوں کا ایک مجموعہ اور اسٹارٹ ورٹیکس سے شروع ہونے والے گراف پر گہرائی کی پہلی تلاش انجام دیتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا وزٹ شدہ سیٹ کوئی نہیں ہے۔اگر یہ ہے تو ، یہ اسے خالی سیٹ پر شروع کرتا ہے۔اس کے بعد ، اس سے دورے والے سیٹ میں اسٹارٹ ورٹیکس شامل ہوتا ہے اور اسے پرنٹ کرتا ہے۔آخر میں ، یہ اسٹارٹ ورٹیکس کے پڑوسی ممالک کے ذریعہ کھڑا ہے جن کا ابھی تک نہیں گیا ہے اور ہر پڑوسی پر ڈی ایف ایس () کے طریقہ کار کو بار بار کال کرتا ہے۔ گراف کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونگ = گراف () g.add_edge (0.ورٹیکس 2 سے شروع ہو رہا ہے): \") جی ڈی ایف ایس (2) یہ پروگرام پہلے جی نامی گراف کلاس کی مثال بناتا ہے۔اس کے بعد ، یہ ADD_EDGE () طریقہ کار کا استعمال کرتے ہوئے گراف میں کچھ کناروں کا اضافہ کرتا ہے۔آخر میں ، یہ ڈی ایف ایس () کے طریقہ کار کا استعمال کرتے ہوئے ورٹیکس 2 سے شروع ہونے والی گہرائی کی پہلی تلاش انجام دیتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: گہرائی کا پہلا ٹراورسال (ورٹیکس 2 سے شروع ہو رہا ہے): 2013 اس آؤٹ پٹ میں گراف میں ورٹیکس 2 سے شروع ہونے والی گہرائی کی پہلی تلاش کے دوران دیکھنے والے عمودی کو دکھایا گیا ہے۔"
    },
    {
        "Question": "دو فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "دو فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے یہاں ایک مثال ازگر پروگرام ہے: پائیتھونڈف Find_common_elements (List1 ، List2): سیٹ 1 = سیٹ (لسٹ 1) سیٹ 2 = سیٹ (لسٹ 2) عام_ایلمنٹ = سیٹ 1. انٹریوریکشن (سیٹ 2) ریٹرن لسٹ (کامن_لیمنٹس) یہ فنکشن لیتا ہے۔دو فہرستیں لسٹ 1 اور لسٹ 2 کو ان پٹ کے طور پر اور ان کے مشترکہ عناصر کی فہرست لوٹاتے ہیں۔یہ پہلے سیٹ () فنکشن کا استعمال کرتے ہوئے دونوں فہرستوں کو سیٹ میں تبدیل کرتا ہے۔اس کے بعد ، یہ دونوں سیٹوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرتا ہے۔آخر میں ، یہ فہرست () فنکشن کا استعمال کرتے ہوئے کسی فہرست میں واپس آنے والی فہرست میں واپس آجاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھون لسٹ 1 = [1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [3 ، 4 ، 5 ،6 ، 7] کامن_لیمنٹس = find_common_elements (List1 ، List2) پرنٹ (\"عام عناصر کے درمیان\" ، لسٹ 1 ، \"اور\" ، \"، لسٹ 2 ،\": \"، عام_ایلمنٹ) یہ پروگرام پہلے کچھ انٹیجرز کے ساتھ لسٹ 1 اور لسٹ 2 نامی دو فہرستوں کی ابتدا کرتا ہے۔اس کے بعد ، یہ Find_common_elements () کو لسٹ 1 اور لسٹ 2 کے ساتھ فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں متغیر کو عام_ایلمنٹ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے لسٹ 1 اور لسٹ 2 کے مابین مشترکہ عناصر کو پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار یہ ہوگی: [1 ، 2 ، 3 ، 4 ، 5] اور [3 ، 4 ، 5 ، 6 ، 7 ، 7] کے درمیان مشترکہ عناصر: [3 ، 4 ، 5] اس آؤٹ پٹ کے مابین مشترکہ عناصر کو ظاہر کیا گیا ہے۔Find_common_elements () فنکشن کا استعمال کرتے ہوئے ان پٹ کی فہرستیں۔"
    },
    {
        "Question": "کسی فنکشن کو نافذ کریں جو چیک کرتا ہے کہ آیا تار ایک درست ای میل ایڈریس ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا سٹرنگ ازگر میں ایک درست ای میل ایڈریس ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: باقاعدہ اظہار کا استعمال کرتے ہوئے: ہم کسی ای میل ایڈریس کی شکل کو درست کرنے کے لئے باقاعدہ اظہار استعمال کرسکتے ہیں۔ہم سٹرنگ کے خلاف باقاعدہ اظہار کے نمونہ سے ملنے کے لئے ازگر میں RE ماڈیول کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھونیمپورٹ ریڈف آئی ایس_والیڈ_ ای میل (ای میل): پیٹرن = آر '^[A-ZA-Z0-9 ._ ٪+-]+@[a-za-Z0-9 .-]+\\. [a--ZA-Z] {2 ،} $ 'ریٹرن BOOL (Re.Match (پیٹرن ، ای میل)) یہ فنکشن ان پٹ کے طور پر ایک تار ای میل لیتا ہے اور اگر یہ ایک درست ای میل ایڈریس ہے اور غلط ہے تو باقاعدگی سے اظہار کا استعمال کرتے ہوئے غلط ہے۔یہ پہلے ایک باقاعدہ اظہار پیٹرن کی وضاحت کرتا ہے جو ایک درست ای میل ایڈریس کی شکل سے مماثل ہے۔اس کے بعد ، یہ ان پٹ سٹرنگ کے خلاف پیٹرن سے ملنے کے لئے ری.مچ () فنکشن کا استعمال کرتا ہے اور اگر کوئی میچ اور غلط ہے تو سچائی واپس آجاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonemail = 'مثال@example.com'درست = is_valid_email (ای میل) پرنٹ (\"IS\" ، ای میل ، \"ایک درست ای میل ایڈریس؟\" ، درست) یہ پروگرام سب سے پہلے 'مثال@example.com' کی قدر کے ساتھ ای میل کے نام سے ایک تار شروع کرتا ہے۔اس کے بعد ، یہ ای میل کے ساتھ is_valid_email () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر میں درست کہتے ہیں۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا ای میل پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک درست ای میل ایڈریس ہے۔اس معاملے میں ، آؤٹ پٹ ہوگا: کیا مثال ہے@example.com ایک درست ای میل ایڈریس؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا ان پٹ سٹرنگ ایک درست ای میل ایڈریس ہے یا باقاعدگی سے اظہار کے ساتھ IS_Valid_email () فنکشن کا استعمال کرتے ہوئے حساب نہیں کیا جاتا ہے۔ تیسری پارٹی کی لائبریریوں کا استعمال کرتے ہوئے: ہم ای میل کے پتے کی توثیق کرنے کے لئے تھرڈ پارٹی لائبریریوں جیسے ای میل ویلیڈیٹر جیسے ای میل ویلیڈیٹر کا استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیٹون سے ای میل_والیڈیٹر امپورٹ کوئلیئڈیٹ_ ای میل ، ای میل نوٹ ویلیڈر آرورڈف آئی ایس_والیڈ_ ای میل (ای میل): کوشش کریں: درست = کوئلیئڈ_ ای میل (ای میل) ای میل = درست۔ ای میل ریٹرن ای میل نوٹس وولائڈر رائٹ کے علاوہ: ریٹرن فالسٹیس فنکشن ان پٹ کے طور پر سٹرنگ ای میل لیتا ہے اور واپسی کو درست کرتا ہے۔درست ای میل ایڈریس اور غلط بشرطیکہ ای میل-ویلیڈیٹر لائبریری کا استعمال کرتے ہوئے۔یہ پہلے ای میل ایڈریس کی توثیق کرنے کے لئے کوئیلیٹیٹ_ ای میل () فنکشن کا استعمال کرتا ہے اور اگر یہ درست ہے تو صحیح لوٹاتا ہے۔اگر ای میل ایڈریس درست نہیں ہے تو ، یہ ایک ای میل نوٹ وولائڈرر رعایت اٹھاتا ہے ، جو بلاک کے سوا پکڑا جاتا ہے اور غلط کو لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: pythonemail ='Example@example.com'valid = is_valid_email (ای میل)پرنٹ (\"IS\" ، ای میل ، \"ایک درست ای میل ایڈریس؟\" ، درست) یہ پروگرام سب سے پہلے 'مثال@example.com' کی قیمت کے ساتھ ای میل نامی تار شروع کرتا ہے۔اس کے بعد ، یہ ای میل کے ساتھ is_valid_email () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر میں درست کہتے ہیں۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا ای میل پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک درست ای میل ایڈریس ہے۔اس معاملے میں ، آؤٹ پٹ ہوگا: کیا مثال ہے@example.com ایک درست ای میل ایڈریس؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا ان پٹ سٹرنگ ایک درست ای میل ایڈریس ہے یا ای میل ویلیڈیٹر لائبریری کے ساتھ IS_Valid_email () فنکشن کا استعمال کرتے ہوئے حساب نہیں کیا جاتا ہے۔"
    },
    {
        "Question": "انٹیجرز کی دی گئی فہرست میں گمشدہ نمبر تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "لاپتہ نمبر کو ازگر میں عددیوں کی ایک فہرست میں تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: سیٹ () فنکشن کا استعمال: ہم انٹیجرز کی فہرست میں گمشدہ نمبر تلاش کرنے کے لئے سیٹ () فنکشن کا استعمال کرسکتے ہیں۔ہم پہلے فہرست کو کسی سیٹ میں تبدیل کرسکتے ہیں اور پھر ایک اور سیٹ تشکیل دے سکتے ہیں جس میں کم سے کم سے کم سے کم قیمت میں فہرست میں زیادہ سے زیادہ قیمت شامل ہو۔آخر میں ، ہم گمشدہ نمبر حاصل کرنے کے لئے دونوں سیٹوں کے درمیان فرق تلاش کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف Find_missing_number (LST): n = len (lst) + 1 متوقع_سم = n * (n + 1) // 2 اصل_سم = رقم (LST) واپسی متوقع_سم - اصل_سومتھس فنکشن ان پٹ اور ریٹرن کے طور پر ایک فہرست لیتا ہے۔فہرست میں گمشدہ نمبر۔اس میں پہلے انٹیجرز کی متوقع رقم کا حساب 1 سے N تک ہوتا ہے ، جہاں N فہرست کے علاوہ ایک کی لمبائی ہوتی ہے ، جس میں فارمولا N * (n + 1) // 2 کا استعمال کیا جاتا ہے۔ پھر ، اس میں انٹیجرز کے اصل مجموعہ کا حساب لگایا جاتا ہے۔رقم () فنکشن کا استعمال کرتے ہوئے فہرست۔آخر میں ، یہ متوقع رقم اور اصل رقم کے درمیان فرق لوٹاتا ہے ، جو گمشدہ نمبر ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونلسٹ = [1 ، 2 ، 3 ، 4 ، 6 ، 7 ، 8 ، 9 ،10] گمشدہ_نبر = Find_missing_number (LST) پرنٹ (\"گمشدہ نمبر\" ، LST ، \":\" ، لاپتہ_ نمبر) یہ پروگرام پہلے ایل ایس ٹی نامی فہرست کو کچھ انٹیجرز کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ Find_missing_number () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر میں لاپتہ_نبر کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست میں گمشدہ نمبر پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [1 ، 2 ، 3 ، 4 ، 6 ، 7 ، 8 ، 9 ، 10] میں گمشدہ تعداد: 5 یہ آؤٹ پٹ Find_missing_number () فنکشن کا استعمال کرتے ہوئے ان پٹ لسٹ میں گمشدہ نمبر دکھاتا ہے۔نیپی لائبریری کا استعمال کرتے ہوئے: ہم انڈی لائبریری کا استعمال انٹیجرز کی فہرست میں گمشدہ نمبر تلاش کرنے کے لئے کرسکتے ہیں۔ہم پہلے 1 سے N تک کے تمام عدد پر مشتمل ایک صف تشکیل دے سکتے ہیں ، جہاں npmy.arange () فنکشن کا استعمال کرتے ہوئے ، فہرست کے علاوہ ایک کی لمبائی ہے۔اس کے بعد ، ہم گمشدہ نمبر حاصل کرنے کے لئے متوقع سرنی اور اصل فہرست کے مابین فرق تلاش کرنے کے لئے numpy.setdiff1d () فنکشن کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھونیم پورٹ نیمپی بطور این پی ڈی ای ایف فائنڈ_میسنگ_نمبر (ایل ایس ٹی): این = لین (ایل ایس ٹی) + 1 متوقع_نومز = این پی.ارج (1 ، این) لاپتہ_نومز = این پی ایس ای ٹی ڈی آئی ایف ایف 1 ڈی (متوقع_نومز ، ایل ایس ٹی) لاپتہ_نومز [0]ایک فہرست ان پٹ کے طور پر LST ہے اور NUMPY لائبریری کا استعمال کرتے ہوئے فہرست میں گمشدہ نمبر لوٹاتی ہے۔یہ پہلے 1 سے N تک کے تمام عددیوں پر مشتمل متوقع صف کا حساب لگاتا ہے ، جہاں npy.arange () فنکشن کا استعمال کرتے ہوئے ، فہرست کے علاوہ ایک کی لمبائی ہے۔اس کے بعد ، یہ گمشدہ نمبر حاصل کرنے کے لئے متوقع سرنی اور اصل فہرست کے مابین فرق تلاش کرنے کے لئے numpy.setdiff1d () فنکشن کا استعمال کرتا ہے۔ یہاں فنکشن کو استعمال کرنے کی ایک مثال ہے: ازگرلسٹ = [1 ، 2 ، 3 ، 4 ،6 ، 7 ، 8 ، 9 ، 10] لاپتہ_نبر = Find_missing_number (LST) پرنٹ (\"گمشدہ نمبر\" ، LST ، \":\" ، لاپتہ_نبر) یہ پروگرام سب سے پہلے LST نامی فہرست کو کچھ عدد کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ Find_missing_number () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر میں لاپتہ_نبر کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست میں گمشدہ نمبر پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [1 ، 2 ، 3 ، 4 ، 6 ، 7 ، 8 ، 9 ، 9 ، 10] میں گمشدہ تعداد: 5 یہ آؤٹ پٹ ان پٹ لسٹ میں گمشدہ نمبر کو ظاہر کرتا ہے جس کا حساب کتاب_مشنگ_نبر () فنکشن کا استعمال کرتے ہوئے کیا جاتا ہے۔numpy لائبریری۔ دونوں عمل درآمد درست ہیں اور ازگر میں دیئے گئے عدد کی فہرست میں گمشدہ نمبر تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا کوئی دیئے گئے تار ایک درست پیلنڈرووم ہے ، غیر الفینومرک کرداروں کو نظرانداز کرتے ہوئے۔\"",
        "Answer": "یہ چیک کرنے کا ایک طریقہ کہ آیا دیئے گئے تار ایک درست پیلنڈرووم ہے ، غیر الفانومیرک کرداروں کو نظرانداز کرتے ہوئے ، پہلے تمام غیر الفانومرک کرداروں کو تار سے ہٹانا ہے اور پھر چیک کریں کہ آیا نتیجے میں تار ایک پیلنڈرووم ہے یا نہیں۔یہاں ازگر میں ایک مثال عمل ہے: پائیتھنڈف is_valid_palindrome (s): # غیر الفانومیرک حروف کو ہٹا دیں اور لوئر کیس ایس = '' میں تبدیل کریں۔نتیجے میں سٹرنگ ایک پیلنڈرووم ریٹرن ہے s == s [::-1] یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر یہ ایک درست پیلنڈرووم ہے تو ، غیر الفینومرک کرداروں کو نظرانداز کرتے ہوئے ، اور دوسری صورت میں جھوٹے کو درست کرتا ہے۔یہ پہلے فہرست کی تفہیم اور isalnum () کے طریقہ کار کا استعمال کرتے ہوئے سٹرنگ سے تمام غیر الفانومیرک حروف کو ہٹا دیتا ہے ، اور پھر اس کے نتیجے میں ہونے والے تار کو لوئر کیس میں تبدیل کرتا ہے۔آخر میں ، یہ جانچ پڑتال کرتا ہے کہ اگر نتیجہ خیز تار سلائسنگ آپریٹر [::-1] کا استعمال کرتے ہوئے اس کے الٹ سے موازنہ کرکے ایک پیلنڈرووم ہے ۔یہ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر = \"ایک آدمی ، ایک منصوبہ ، نہر:پاناما \"درست = is_valid_palindrome (s) پرنٹ (\" IS \"، s ،\" ایک درست palindrome؟ \"، درست) یہ پروگرام سب سے پہلے\" ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما \"کی قدر کے ساتھ ایس نامی تار شروع کرتا ہے۔اس کے بعد ، یہ IS_Valid_palindrome () کو ایس کے ساتھ ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو ایک متغیر میں اسٹور کرتا ہے جسے درست کہتے ہیں۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا S پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک درست پیلنڈرووم ہے۔اس معاملے میں ، پیداوار ہوگی: کیا ایک آدمی ، منصوبہ ہے ، ایک نہر: پاناما ایک درست پیلنڈرووم ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا ان پٹ سٹرنگ ایک درست پیلنڈرووم ہے ، غیر الفینومرک کرداروں کو نظرانداز کرتے ہوئے ، is_valid_palindrome () فنکشن کا استعمال کرتے ہوئے حساب کیا جاتا ہے۔ نوٹ کریں کہ یہ چیک کرنے کے اور بھی طریقے موجود ہیں کہ آیا تار ایک درست پیلنڈرووم ہے ، جیسے غیر الفینومرک کرداروں کو نظرانداز کرتے ہیں ، جیسے کہ غیر الفینومرک کرداروں کو نظرانداز کرتے ہیں ، جیسےباقاعدگی سے اظہارات کا استعمال کرنا یا دو پوائنٹرز کے ساتھ تار کے ذریعے تکرار کرنا۔"
    },
    {
        "Question": "ایک قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور اس کے سائز اور is_empty طریقوں کو نافذ کریں۔",
        "Answer": "ایک قطار کی نمائندگی کرنے اور اس کے سائز اور isempty طریقوں کو نافذ کرنے والی ایک ازگر کلاس بنانے کے ل we ، ہم مندرجہ ذیل نفاذ کو استعمال کرسکتے ہیں: پائیٹونکلاس قطار: Def __init __ (خود): self.items = [] Def enqueue (خود ، آئٹم): سیلف۔ آئٹمز۔ضمیمہ (آئٹم) ڈیف ڈی کیوئ (خود): خود کو واپس کریں۔آئٹمز نامی خالی فہرست کو شروع کرنے کے لئے __init __ () کے ساتھ ایک قطار کلاس ، قطار کے اختتام پر کسی شے کو شامل کرنے کے لئے ایک enqueue () طریقہ ، قطار میں پہلی شے کو ہٹانے اور واپس کرنے کے لئے ایک dequeue () طریقہ ،سائز () قطار میں موجود اشیاء کی تعداد کو واپس کرنے کا طریقہ ، اور یہ چیک کرنے کے لئے کہ قطار خالی ہے یا نہیں۔is_empty () طریقہ چیک کرتا ہے کہ اگر آئٹمز کی فہرست کی لمبائی 0 کے برابر ہے اور اگر یہ ہے تو ، اور غلط ہے۔خالی؟ \"، Q.IS_EMPTY ()) Q.enqueue (1) Q.enqueue (2) Q.enqueue (3) پرنٹ (\" قطار کا سائز: \"، Q.SIZE ()) پرنٹ (\" قطار ہے قطار ہےخالی؟ \"، Q.is_empty ()) Q.dequeue () پرنٹ (\" قطار کا سائز: \"، Q.Size ()) یہ پروگرام پہلے Q نامی قطار کلاس کی ایک مثال بناتا ہے۔پھر ، یہ چیک کرتا ہے کہ آیا IS_EMPTY () کے طریقہ کار کا استعمال کرتے ہوئے قطار خالی ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کرتی ہے۔اگلا ، اس میں enqueue () طریقہ کار کا استعمال کرتے ہوئے قطار میں کچھ اشیاء شامل کردی گئیں۔اس کے بعد ، یہ سائز () کے طریقہ کار کا استعمال کرتے ہوئے قطار کا سائز حاصل کرتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کرتا ہے۔آخر میں ، یہ ڈیکیو () کے طریقہ کار کا استعمال کرتے ہوئے قطار سے کسی آئٹم کو ہٹا دیتا ہے اور سائز () کے طریقہ کار کا استعمال کرتے ہوئے دوبارہ قطار کا سائز حاصل کرتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ کو پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار ہوگی: کیا قطار خالی ہے؟قطار کا trusize: 3 کیا قطار خالی ہے؟قطار کا غلط استعمال کریں: 2 اس آؤٹ پٹ قطار کے سائز کو ظاہر کرتا ہے اور چاہے وہ خالی ہے یا قطار کلاس کا استعمال کرتے ہوئے اس کا حساب نہیں لگایا گیا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دو ڈور ایک دوسرے کی گردش ہیں یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دو ڈور ایک دوسرے کی گردش ہیں یا نہیں ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ہم آہنگی کا استعمال کرتے ہوئے: ہم پہلے تار کو خود سے جوڑ سکتے ہیں اور پھر چیک کرسکتے ہیں کہ آیا دوسرا تار کنکیٹیٹڈ اسٹرنگ کا ایک سٹرنگ ہے۔یہاں ایک مثال کے نفاذ ہے: پائتھونڈف ARE_ROTATIONS (S1 ، S2): اگر لین (S1)! = لین (S2): جھوٹی ٹیمپ = S1 + S1 لوٹائیں اگر S2 ٹیمپ میں: واپس سچی دوسری چیز: واپسی فالتھیس فنکشن میں دو تاریں S1 اور S2 لیتے ہیںچونکہ ان پٹ اور واپس آجاتا ہے اگر وہ ایک دوسرے کی گردش اور غلط ہیں تو۔یہ پہلے چیک کرتا ہے کہ آیا دونوں ڈوروں کی لمبائی برابر ہے۔اگر وہ برابر نہیں ہیں تو ، یہ غلط لوٹتا ہے۔اس کے بعد ، یہ عارضی تار بنانے کے ل first خود سے پہلی تار کو متحرک کرتا ہے جس کو عارضی طور پر کہتے ہیں۔آخر میں ، یہ جانچ پڑتال کرتا ہے کہ آیا دوسرا سٹرنگ ان آپریٹر کا استعمال کرتے ہوئے ٹمپ سٹرنگ کا ایک ذخیرہ ہے اور اگر یہ ہے تو ، اور غلط ہے۔درست = are_rotations (S1 ، S2) پرنٹ (\"ہیں\" ، S1 ، \"اور\" ، S2 ، \"ایک دوسرے کی گردش؟\" ، درست) یہ پروگرام پہلے کچھ اقدار کے ساتھ S1 اور S2 نامی دو تار شروع کرتا ہے۔اس کے بعد ، یہ S1 اور S2 کے ساتھ AR_Rotations () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے ساتھ اسٹور کرتا ہے جسے درست کہتے ہیں۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا S1 اور S2 پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک دوسرے کی گردش ہیں۔اس معاملے میں ، پیداوار ہوگی: کیا ایک دوسرے کے ABCD اور CDAB گردش ہیں؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا دو ان پٹ ڈور ایک دوسرے کی گردش ہیں جو AL_ROTATIONS () فنکشن کا استعمال کرتے ہوئے ہیں۔دوسرا حصہ اور پہلے تار کا پہلا حصہ۔یہاں ایک مثال عمل ہے: پائیتھنڈف ARE_ROTATIONS (S1 ، S2): اگر لین (S1)! = لین (S2): رینج (لین (S1)) میں I کے لئے غلط لوٹائیں: اگر S1 [I:] + S1 [: i]== S2: حقیقی واپسی فالسیتیس فنکشن دو ڈور S1 اور S2 کو ان پٹ کے طور پر لیتا ہے اور اگر وہ ایک دوسرے کی گردش اور غلط ہیں تو وہ سچ ثابت ہوتا ہے۔یہ پہلے چیک کرتا ہے کہ آیا دونوں ڈوروں کی لمبائی برابر ہے۔اگر وہ برابر نہیں ہیں تو ، یہ غلط لوٹتا ہے۔اس کے بعد ، یہ لوپ اور چیک کے لئے پہلے سٹرنگ کے اشاریوں کے ذریعے کھڑا ہوتا ہے اگر دوسرے حصے اور پہلے تار کا پہلا حصہ دوسرے تار کے برابر ہے۔اگر یہ ہے تو ، یہ سچ واپس آجاتا ہے۔اگر لوپ میچ ڈھونڈے بغیر مکمل ہوجاتا ہے تو ، یہ غلط کام کرتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: ازگر 1 = \"ABCD\" S2 = \"CDAB\" درست = ARE_ROTATIONS (S1 ، S2) پرنٹ (\"ہیں\" ، S1 ، \"اور \"، ایس 2 ،\" ایک دوسرے کی گردش؟ \"، درست) یہ پروگرام سب سے پہلے کچھ اقدار کے ساتھ S1 اور S2 نامی دو تار شروع کرتا ہے۔اس کے بعد ، یہ S1 اور S2 کے ساتھ AR_Rotations () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے ساتھ اسٹور کرتا ہے جسے درست کہتے ہیں۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا S1 اور S2 پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک دوسرے کی گردش ہیں۔اس معاملے میں ، پیداوار ہوگی: کیا ایک دوسرے کے ABCD اور CDAB گردش ہیں؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ آیا دو ان پٹ ڈور ایک دوسرے کی گردشیں ہیں جو AL_ROTATIONs () فنکشن کا استعمال کرتے ہوئے حساب کی جاتی ہیں۔ دونوں عمل درآمد درست ہیں اور یہ چیک کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا ازگر میں دو تار ایک دوسرے کی گردش ہیں یا نہیں۔"
    },
    {
        "Question": "تکرار کا استعمال کرتے ہوئے کسی نمبر کی طاقت کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یہاں تکرار کا استعمال کرتے ہوئے کسی نمبر کی طاقت کا حساب لگانے کے لئے ازگر فنکشن کا ایک مثال عمل ہے: پیتھونڈف پاور (بیس ، ایکسپینٹر): اگر ایکسپینٹ == 0: واپسی 1 الیف ایکسپینٹ == 1: واپسی کی بنیاد: ریٹرن بیس * پاور (بیس * پاور (بیس * پاور (بیس)، اخراج کنندہ - 1) یہ فنکشن دو دلائل کی بنیاد اور اخراج کنندہ لیتا ہے اور تکرار کا استعمال کرتے ہوئے اخراج کنندہ کی طاقت میں اٹھائے ہوئے بیس کی قیمت کو لوٹاتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا اخراج کنندہ 0 ہے اور اگر 1 ہے تو 1 واپس آجاتا ہے۔پھر ، یہ چیک کرتا ہے کہ آیا اخراج کنندہ 1 ہے اور اگر یہ ہے تو اڈے کو واپس کرتا ہے۔آخر میں ، اگر اخراج کنندہ 1 سے زیادہ ہے تو ، یہ اڈے اور ایکسپینٹ مائنس کے ساتھ بار بار چلنے والے فنکشن کو کال کرنے کے نتیجے میں بیس کو بڑھاتا ہے۔پاور (بیس ، ایکسپینٹر) پرنٹ (بیس ، \"طاقت میں اٹھایا ہوا ،\" ، \"،\" ہے \"، نتیجہ) یہ پروگرام پہلے دو متغیرات کا آغاز کرتا ہے جس کو بیس اور ایکسپینٹ کو کچھ اقدار کے ساتھ کہا جاتا ہے۔اس کے بعد ، یہ ان پٹ کے طور پر بیس اور اخراج کنندہ کے ساتھ پاور () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 5 کی طاقت میں اٹھایا ہوا 32 یہ آؤٹ پٹ پاور () فنکشن کا استعمال کرتے ہوئے حساب کتاب کے حساب سے اڈے کو بڑھانے کا نتیجہ ظاہر کرتا ہے۔ازگر میں تکرار ، بشمول نیپی لائبریری کا استعمال یا بائنری نقطہ نظر استعمال کرنا۔"
    },
    {
        "Question": "تار سے تمام نقول نکالنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں تار سے تمام نقلیں ہٹانے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: ایک آرڈرڈ لغت کا استعمال کرتے ہوئے: ہم حروف کے ترتیب کو محفوظ رکھتے ہوئے ڈپلیکیٹ کو تار سے نکالنے کے لئے آرڈرڈ لغت کا استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: ازگر کے کلیکشنز امپورٹ آرڈرڈکٹ ڈیف کو ہٹائیں_ڈپلیکیٹس (زبانیں): واپس ''. join (آرڈرڈکٹ.فومکیز (ایس)) یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تمام نقلوں کے ساتھ ایک نئی تار واپس کرتا ہے جبکہ اس کے آرڈر کو محفوظ کرتے ہوئے ہٹا دیا جاتا ہے۔کرداریہ سب سے پہلے آرڈرڈ ڈکٹ.فومکیز () طریقہ کا استعمال کرتے ہوئے سٹرنگ سے ایک آرڈرڈ لغت تیار کرتا ہے ، جو کرداروں کے ترتیب کو محفوظ رکھتے ہوئے نقل کو دور کرتا ہے۔اس کے بعد ، یہ آرڈرڈ ڈکشنری کو جوائن () کے طریقہ کار کا استعمال کرتے ہوئے ایک تار میں واپس بدل دیتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: ازگر = \"ہیلو ورلڈ\" نتیجہ = ہٹائیں_ڈوپلیکیٹس (زبانیں) پرنٹ (\"ڈپلیکیٹ کے ساتھ تار:\" ، \"،نتیجہ) یہ پروگرام سب سے پہلے \"ہیلو ورلڈ\" کی قدر کے ساتھ ایس نامی ایک تار کا آغاز کرتا ہے۔اس کے بعد ، یہ ST کے ساتھ ہٹانے_ڈوپلیکیٹس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے ہٹا دی گئی ڈپلیکیٹ کے ساتھ نتیجے میں تار پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ڈپلیکیٹس کے ساتھ تار کو ہٹا دیا گیا: ہیلیو WRDTHIS آؤٹ پٹ ہینڈ_ڈوپلیکیٹس () فنکشن کا استعمال کرتے ہوئے گنتی کے حساب سے ڈپلیکیٹ کے نتیجے میں ہونے والی تار کو ظاہر کرتا ہے۔ ایک سیٹ کا استعمال کرتے ہوئے: ہم تار سے ڈپلیکیٹ کو ہٹانے کے لئے ایک سیٹ کا استعمال کرسکتے ہیں ، لیکن یہطریقہ کرداروں کے ترتیب کو محفوظ نہیں رکھتا ہے۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف ہٹائیں_ڈوپلیکیٹس (زبانیں): واپسی ''یہ سب سے پہلے سیٹ () کے طریقہ کار کا استعمال کرتے ہوئے سٹرنگ سے ایک سیٹ تیار کرتا ہے ، جو نقل کو دور کرتا ہے لیکن کرداروں کے ترتیب کو محفوظ نہیں رکھتا ہے۔اس کے بعد ، یہ جوائن () کے طریقہ کار کا استعمال کرتے ہوئے سیٹ کو واپس اسٹرنگ میں تبدیل کرتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: ازگر = \"ہیلو ورلڈ\" نتیجہ = ہٹائیں_ڈوپلیکیٹس (s) پرنٹ (\"نقول کے ساتھ تار:\" ، نتیجہ) یہ پروگرام سب سے پہلے \"ہیلو ورلڈ\" کی قدر کے ساتھ ایس نامی ایک تار کا آغاز کرتا ہے۔اس کے بعد ، یہ ST کے ساتھ ہٹانے_ڈوپلیکیٹس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے ہٹا دی گئی ڈپلیکیٹ کے ساتھ نتیجے میں تار پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ڈپلیکیٹس کے ساتھ تار کو ہٹا دیا گیا: ڈیہلورو یہ آؤٹ پٹ ایک سیٹ کے ساتھ ہٹانے_ڈوپلیکیٹس () فنکشن کا استعمال کرتے ہوئے ہٹا دی جانے والی ڈپلیکیٹ کے نتیجے میں ہونے والی تار کو ظاہر کرتا ہے۔ دونوں عمل درآمد درست ہیں اور تار سے تمام ڈپلیکٹس کو ہٹانے کے لئے استعمال کیا جاسکتا ہے۔ازگر میں"
    },
    {
        "Question": "بائنری سرچ ٹری کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور نوڈ داخل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "بائنری سرچ ٹری کی نمائندگی کرنے اور نوڈ داخل کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرنے والی ایک ازگر کلاس بنانے کے لئے ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: ازگرکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف۔ لیفٹ = کوئی بھی نہیں۔= ڈیٹاکلاس بائنری سرچ ٹری: ڈیف __init __ (خود): سیلف.روٹ = کوئی بھی ڈیف داخل نہیں (خود ، ڈیٹا): اگر سیلف.روٹ کوئی بھی نہیں ہے: سیلف.روٹ = نوڈ (ڈیٹا) اور: سیلف ۔_ انرٹ (ڈیٹا ، سیلف.روٹ)ڈیف _ انرٹ (خود ، ڈیٹا ، کرنٹ_نوڈ): اگر ڈیٹا <موجودہ_نوڈ.ڈیٹا: اگر موجودہ_نوڈ.لفٹ کوئی بھی نہیں ہے: موجودہ_نوڈ.لفٹ = نوڈ (ڈیٹا) دوسری: سیلف ۔_ انرٹ (ڈیٹا ، کرنٹ_نوڈ.یلفٹ) ایلف ڈیٹا> موجودہ_نوڈ.ڈیٹا: اگر موجودہ_نوڈ. رائٹ کوئی بھی نہیں ہے: موجودہ_نوڈ۔ رائٹ = نوڈ (ڈیٹا) اور: سیلف ۔_ انرٹ (ڈیٹا ، کرنٹ_نوڈ. رائٹ) اور: پرنٹ (\"درخت میں پہلے سے ہی موجود ہے۔\") یہ عمل درآمد ایک کے ساتھ نوڈ کلاس کی وضاحت کرتا ہے۔کنسٹرکٹر جو بائیں اور دائیں بچے کے نوڈس اور نوڈ کے ڈیٹا کو شروع کرتا ہے۔یہ ایک بائنری سرچ ٹری کلاس کی بھی وضاحت کرتا ہے جو ایک کنسٹرکٹر کے ساتھ ہے جو درخت کے جڑ نوڈ کو کسی کو بھی شروع کرتا ہے۔بائنری سرچ ٹری کلاس میں ایک داخل () طریقہ بھی ہوتا ہے جو ان پٹ کی حیثیت سے ایک قدر لیتا ہے اور اسے درخت میں داخل کرتا ہے۔ داخل کریں () طریقہ پہلے چیک کرتا ہے کہ اگر جڑ کا نوڈ کوئی نہیں ہے۔اگر یہ ہے تو ، یہ ان پٹ ویلیو کے ساتھ ایک نیا نوڈ تیار کرتا ہے اور اسے روٹ نوڈ کے طور پر سیٹ کرتا ہے۔اگر روٹ نوڈ کوئی نہیں ہے تو ، وہ ان پٹ ویلیو اور جڑ نوڈ کے ساتھ _INSERT () کے طریقہ کار کو ان پٹ کے بطور کال کرتا ہے۔نوڈ کی قدر کی بنیاد پر نیا نوڈ داخل کرنے کے لئے صحیح پوزیشن تلاش کرنے کے لئے _ انرٹ () کا طریقہ درخت کو بار بار عبور کرتا ہے۔اگر قیمت پہلے ہی درخت میں موجود ہے تو ، یہ ایک پیغام پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ قیمت پہلے سے موجود ہے۔ یہاں بائنری سرچ ٹری کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونبسٹ = بائنری سرچ ٹری () BST.Insert (5) BST.Insert (3) BST۔داخل کریں (7) bst.insert (2) bst.insert (4) bst.insert (6) bst.insert (8) یہ پروگرام سب سے پہلے بائنری سرچ ٹری کلاس کی مثال بناتا ہے جسے بی ایس ٹی کہتے ہیں۔اس کے بعد ، یہ داخل () کے طریقہ کار کا استعمال کرتے ہوئے درخت میں کچھ اقدار داخل کرتا ہے۔اس معاملے میں ، پیداوار یہ ہوگی: درخت میں پہلے سے ہی قیمت موجود ہے۔ اس آؤٹ پٹ سے پتہ چلتا ہے کہ ویلیو 5 پہلے ہی درخت میں موجود ہے اور اسے دوبارہ داخل نہیں کیا گیا تھا۔ نوٹ کریں کہ یہ نفاذ بائنری سرچ ٹری بنانے اور داخل کرنے کا صرف ایک طریقہ ہے۔اس میں ایک نوڈ۔بائنری سرچ ٹری کو نافذ کرنے کے لئے اور بھی طریقے ہیں ، جیسے نوڈس کو تلاش کرنے اور حذف کرنے کے ل an تکراری نقطہ نظر کو استعمال کرنا یا اضافی طریقوں کو نافذ کرنا۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں کرداروں کو دہرائے بغیر سب سے طویل عروج تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں دیئے گئے اسٹرنگ میں کرداروں کو دہرائے بغیر سب سے طویل عروج تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: سلائیڈنگ ونڈو اپروچ کا استعمال: ہم کسی دیئے گئے تار میں کرداروں کو دہرائے بغیر سب سے طویل تر اسٹرنگ تلاش کرنے کے لئے سلائیڈنگ ونڈو نقطہ نظر کا استعمال کرسکتے ہیں۔ہم دو پوائنٹرز ، اسٹارٹ اور اینڈ کا استعمال کرتے ہیں ، موجودہ اسٹرنگ کے آغاز اور اختتام کی نمائندگی کرنے کے لئے ، اور موجودہ سبسٹرنگ میں کرداروں کو ٹریک رکھنے کے لئے ایک سیٹ۔ہم آخری پوائنٹر کو دائیں طرف منتقل کرسکتے ہیں جب تک کہ ہمیں ایک دہرانے والا کردار نہ ملے ، اور پھر اسٹارٹ پوائنٹر کو دائیں طرف منتقل کریں جب تک کہ ہم دہرانے والے کردار کو سیٹ سے نہ ہٹائیں۔ہم اس عمل کو اس وقت تک دہرا سکتے ہیں جب تک کہ ہم تار کے اختتام تک نہ پہنچ جائیں۔یہاں ایک مثال عمل ہے: پائیٹھنڈف طویل ترین_سبسٹرنگ (s): شروع = 0 اختتام = 0 میکس_ لمبائی = 0 چارس = سیٹ () جبکہ اختتام <لین (s): اگر s [end] چارس میں نہیں ہے: چارس ایڈ (s [end]) اختتام += 1 زیادہ سے زیادہ_ لمبائی = زیادہ سے زیادہ (زیادہ سے زیادہ کی لمبائی ، اختتام - شروع) اور: چار.ایموو (ایس [اسٹارٹ]) اسٹارٹ += 1 ریٹرن میکس_ لمبائی اس فنکشن کو ان پٹ کے طور پر سٹرنگ لیتا ہے اور حرفوں کو دہراتے ہوئے طویل عرصے تک سب سے طویل ذخیرے کی لمبائی واپس کرتا ہے۔سلائیڈنگ ونڈو اپروچ کا استعمال کرتے ہوئے تار میں۔یہ پہلے اسٹارٹ اور اینڈ پوائنٹرز کو 0 ، میکس_ لمبائی متغیر 0 ، اور چاروں کو خالی سیٹ پر سیٹ کرنے کی ابتدا کرتا ہے۔اس کے بعد ، یہ تھوڑی دیر کا استعمال کرتے ہوئے سٹرنگ کے ذریعے گھومتا ہے اور چیک کرتا ہے کہ اگر آخری پوائنٹر میں موجودہ کردار چارس سیٹ میں ہے۔اگر یہ نہیں ہے تو ، یہ کردار کو سیٹ میں شامل کرتا ہے ، اختتامی پوائنٹر کو دائیں طرف لے جاتا ہے ، اور اگر ضروری ہو تو میکس_ لمبائی متغیر کو اپ ڈیٹ کرتا ہے۔اگر یہ ہے تو ، یہ اسٹارٹ پوائنٹر کے کردار کو سیٹ سے ہٹاتا ہے ، اسٹارٹ پوائنٹر کو دائیں طرف منتقل کرتا ہے ، اور اس عمل کو دہراتا ہے جب تک کہ موجودہ کردار سیٹ میں نہ ہو۔آخر میں ، یہ میکس_ لمبائی متغیر کو لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: ازگر = \"ابکیب سی بی بی\" نتیجہ = طویل ترین_سبسٹرنگ (زبانیں) پرنٹ (\"حرفوں کو دہرانے کے بغیر سب سے طویل عرصہ کی سبسٹرنگ:\" ، نتیجہ) یہ پروگرام سب سے پہلے ایک سٹرنگ کو شروع کرتا ہے جسے ایس کہتے ہیں۔\"ABCABCBB\" کی قدر کے ساتھ۔اس کے بعد ، یہ ان پٹ کے طور پر سب سے طویل_substring () فنکشن کو فون کرتا ہے اور اس کے نتیجے میں ایک متغیر کے نتیجے میں نتائج کو اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے کرداروں کو دہرائے بغیر طویل ترین سبسٹرنگ کی لمبائی پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: بغیر کسی اعضاء کے طویل ترین سبسٹرنگ: 3 اس آؤٹ پٹ طویل عرصے تک سب سے طویل سلسٹرنگ کی لمبائی کو ظاہر کرتا ہے جس میں بغیر کسی طویل ترین_سبسٹرنگ () فنکشن کا استعمال کرتے ہوئے حساب کتاب کو دہراتا ہے۔ ہیش ٹیبل کا استعمال کرتے ہوئے: ہم ٹریک رکھنے کے لئے ہیش ٹیبل کا استعمال کرسکتے ہیں۔تار میں ہر کردار کا آخری واقعہ اور موجودہ اسٹرنگ کا آغاز۔ہم سٹرنگ کے ذریعے لوپ کرسکتے ہیں اور ہیش ٹیبل اور موجودہ اسٹرنگ کے آغاز کو ضرورت کے مطابق اپ ڈیٹ کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف طویل ترین_سبسٹرنگ (ایس): اسٹارٹ = 0 میکس_ لمبائی = 0 آخری_سین = {} رینج (لین (ایس)) کے اختتام کے لئے: اگر ایس [اختتام] آخری_سین اور لسٹ_سین [ایس [اینڈ]]> = اسٹارٹ: start = last_seen [s [end]] + 1 last_seen [s [end]] = اختتام میکس_ لمبائی = زیادہ سے زیادہ (میکس_ لمبائی ، اختتام - شروع کریں + 1) واپسی میکس_ لمبائی اس فنکشن کو ان پٹ کے طور پر سٹرنگ لیتا ہے اور سب سے طویل عرصہ کی لمبائی واپس کرتا ہےہیش ٹیبل کا استعمال کرتے ہوئے تار میں حروف کو دہرائے بغیر۔یہ پہلے اسٹارٹ متغیر کو 0 ، میکس_ لمبائی متغیر 0 ، اور آخری_سین ہیش ٹیبل کو خالی لغت میں شروع کرتا ہے۔اس کے بعد ، یہ لوپ کے لئے A کا استعمال کرتے ہوئے سٹرنگ کے ذریعے گھومتا ہے اور اگر آخری انڈیکس میں موجودہ کردار آخری_سین ہیش ٹیبل میں ہے اور اگر اس کا آخری واقعہ موجودہ اسٹرنگ کے آغاز کے بعد ہے۔اگر یہ ہے تو ، یہ کریکٹر پلس 1 کے آخری واقعے کے لئے موجودہ اسٹرنگ کے آغاز کو اپ ڈیٹ کرتا ہے۔ پھر ، یہ آخری کردار اور اس کے انڈیکس کے ساتھ آخری_سین ہیش ٹیبل کو اپ ڈیٹ کرتا ہے ، اور اگر ضروری ہو تو زیادہ سے زیادہ لمبائی متغیر کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ میکس_ لمبائی متغیر کو لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: ازگر = \"ابکیب سی بی بی\" نتیجہ = طویل ترین_سبسٹرنگ (زبانیں) پرنٹ (\"حرفوں کو دہرانے کے بغیر سب سے طویل عرصہ کی سبسٹرنگ:\" ، نتیجہ) یہ پروگرام سب سے پہلے ایک سٹرنگ کو شروع کرتا ہے جسے ایس کہتے ہیں۔\"ABCABCBB\" کی قدر کے ساتھ۔اس کے بعد ، یہ ان پٹ کے طور پر سب سے طویل_substring () فنکشن کو فون کرتا ہے اور اس کے نتیجے میں ایک متغیر کے نتیجے میں نتائج کو اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے کرداروں کو دہرائے بغیر طویل ترین سبسٹرنگ کی لمبائی پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: حرفوں کو دہرانے کے بغیر سب سے طویل سبسٹرنگ: 3 اس آؤٹ پٹ کو ہیش ٹیبل کے ساتھ طویل ترین_سوبسٹرنگ () فنکشن کا استعمال کرتے ہوئے حساب کتاب کے بغیر دہرائے بغیر طویل عرصے تک سبسٹرنگ کی لمبائی دکھاتی ہے۔ دونوں عمل درآمد درست ہیں اور تلاش کرنے کے لئے استعمال کیا جاسکتا ہےازگر میں دیئے گئے اسٹرنگ میں حروف کو دہرائے بغیر سب سے طویل عروج"
    },
    {
        "Question": "کسی دیئے گئے جملے میں الفاظ کی ترتیب کو پلٹانے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں دیئے گئے جملے میں الفاظ کی ترتیب کو الٹا کرنے کے ل we ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: پائیتھونڈف ریورس_سینٹینس (جملہ): الفاظ = جملہ۔ اسپلٹ () الٹ_ ورڈز = الفاظ [::-1] الٹ_سینٹینس = \"\". join (الٹ_ ورڈز) ریٹرن الٹ_سینٹیتھیس عمل درآمد ایک فنکشن کی وضاحت کرتا ہے جسے ریورس_سینٹینس () کہا جاتا ہے جو ان پٹ کے طور پر ایک تار کا جملہ لیتا ہے اور جملے میں الفاظ کی ترتیب کے ساتھ ایک نیا تار واپس کرتا ہے۔یہ سب سے پہلے اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی فہرست میں جملے کو تقسیم کرتا ہے ، جو وائٹ اسپیس حروف میں تار کو الگ کرتا ہے۔اس کے بعد ، یہ [::-1] سلائس آپریٹر کا استعمال کرتے ہوئے فہرست میں الفاظ کے ترتیب کو تبدیل کرتا ہے۔آخر میں ، یہ الفاظ کی الٹ فہرست میں شامل ہوتا ہے جس میں خلائی کردار کے ساتھ جوائن () کے طریقہ کار کو جداکار کے طور پر استعمال کرتے ہوئے سٹرنگ میں شامل ہوتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنسینٹینس = \"یہ ایک ٹیسٹ جملہ ہے\" الٹ_سینٹینس = ریورس_سینٹینس ((ریورس_سینٹینسجملہ) پرنٹ (\"الٹ جملہ:\" ، الٹ_سینٹینس) یہ پروگرام سب سے پہلے \"یہ ایک ٹیسٹ جملہ ہے\" کی قیمت کے ساتھ جملے کے نام سے ایک تار شروع کرتا ہے۔اس کے بعد ، یہ ان پٹ کے طور پر ریورس_سینٹینس () فنکشن کو جملے کے ساتھ کال کرتا ہے اور اس کے نتیجے کو متغیر میں تبدیل کرتا ہے جسے الٹ_سینٹینس کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے الٹ الفاظ کے آرڈر کے ساتھ نتیجے میں تار کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: الٹ جملہ: جملے کی جانچ A یہ ہے یہ آؤٹ پٹ ریورس_سینٹینس () فنکشن کا استعمال کرتے ہوئے حساب شدہ الفاظ کی ترتیب کے ساتھ نتیجے میں ہونے والے تار کو ظاہر کرتا ہے۔ نوٹ کریں کہ یہ عمل درآمد یہ فرض کرتا ہے کہ جملے میں الفاظ الگ ہوجاتے ہیں۔وائٹ اسپیس حروف۔اگر اس جملے میں اوقاف یا دیگر غیر الفانومرک کردار شامل ہیں تو ، وہ الفاظ میں شامل ہوں گے اور اس کے نتیجے کو متاثر کرسکتے ہیں۔اس معاملے کو سنبھالنے کے ل we ، ہم جملے کو الفاظ میں تقسیم کرنے کے لئے باقاعدہ اظہار استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "ایک فنکشن لکھیں جو متحرک پروگرامنگ کا استعمال کرتے ہوئے NTH Fibonacci نمبر لوٹائے۔",
        "Answer": "ازگر میں متحرک پروگرامنگ کا استعمال کرتے ہوئے نویں فبونیکی نمبر تلاش کرنے کے ل we ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: پائیتھونڈف فبوناکی (این): فب_آرے = [0 ، 1] I میں I کے لئے (2 ، n + 1): fib_array.append (fib_array [i - 1] + fib_array [i - 2]) واپسی fib_array [n] یہ عمل درآمد فبونیکی () نامی ایک تقریب کی وضاحت کرتا ہے جو ان پٹ کے طور پر ایک عدد N لیتا ہے اور متحرک پروگرامنگ کا استعمال کرتے ہوئے Nth fibonacci نمبر واپس کرتا ہے۔اس نے پہلے Fib_array نامی ایک فہرست کو پہلے دو fibonacci نمبر ، 0 اور 1 کے ساتھ شروع کیا ہے ، پھر ، یہ لوپ کے لئے باقی فبونیکی نمبروں کو تکرار کے رشتے کا استعمال کرتے ہوئے فہرست میں شامل کرنے کے لئے استعمال کرتا ہے [i] = fib_array [i-1] +fib_array [I-2]۔آخر میں ، یہ فہرست کے نویں عنصر کو لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھن = 10 ریزولٹ = فبونیکی (این) پرنٹ (\"دی\" ، این ، \"ویں فبونیکی نمبر:\" ، نتیجہ) یہ پروگرام پہلے اس پروگرام10 کی قیمت کے ساتھ N نامی ایک انٹیجر کی ابتداء کرتا ہے۔ پھر ، یہ N کے ساتھ Fibonacci () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور نتیجہ کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے NTH Fibonacci نمبر پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 10 ویں فبونیکی نمبر یہ ہے: 55 اس آؤٹ پٹ کو متحرک پروگرامنگ کے ساتھ فبوناکی () فنکشن کا استعمال کرتے ہوئے حساب کردہ نویں فبونیکی نمبر دکھاتا ہے۔ نوٹ کریں کہ اس عمل درآمد میں O (N) کی وقت کی پیچیدگی اور ایک معاون ہے۔O (n) کی خلائی پیچیدگی ، جو O (2^n) کی وقت کی پیچیدگی اور O (n) کی معاون جگہ کی پیچیدگی کے ساتھ تکرار نقطہ نظر سے بہتر ہے۔متحرک پروگرامنگ کا استعمال کرتے ہوئے NTH Fibonacci نمبر تلاش کرنے کے ل other دوسرے نقطہ نظر بھی موجود ہیں ، جیسے میمورائزیشن یا نچلے حصے کا استعمال۔"
    },
    {
        "Question": "میٹرکس ضرب انجام دینے کے لئے ایک پروگرام نافذ کریں۔",
        "Answer": "ازگر میں میٹرکس ضرب انجام دینے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: نیسٹڈ لوپ کا استعمال: ہم میٹرکس کے ہر صف اور کالم کے ذریعے تکرار کرنے کے لئے نیسڈ لوپ کا استعمال کرسکتے ہیں اور اسی عناصر کی مصنوعات کا حساب لگاسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف میٹرکس_مولٹپلیکیشن (x ، y): نتیجہ = [] I میں I (لین (x)) کے لئے: قطار = [] رینج میں جے کے لئے (لین (Y [0])): رقم = 0 کے لئےرینج میں Kگھریلو لوپس کا استعمال کرکے ان پٹ اور لوٹاتا ہے۔یہ پہلے ایک خالی فہرست کا آغاز کرتا ہے جسے نتائج کہتے ہیں۔اس کے بعد ، یہ میٹرکس کی ہر صف اور کالم کے ذریعے تکرار کرنے کے لئے تین گھریلو لوپ کا استعمال کرتا ہے اور متعلقہ عناصر کی مصنوعات کا حساب لگاتا ہے۔اس کے نتیجے میں ROW نامی ایک نئی فہرست میں ذخیرہ ہوتا ہے ، جو نتائج کی فہرست میں شامل کیا جاتا ہے۔آخر میں ، یہ نتیجہ کی فہرست لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیٹونکس = [[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]] y = [[[9]، 8 ، 7] ، [6 ، 5 ، 4] ، [3 ، 2 ، 1]] نتیجہ = میٹرکس_مولٹپلیکیشن (x ، y) پرنٹ (\"میٹرکس کی مصنوعات x اور y:\" ، نتیجہ) یہ پروگرام پہلے دو میٹرک کی ابتدا کرتا ہےکچھ اقدار کے ساتھ x اور y کہا جاتا ہے۔اس کے بعد ، یہ X اور Y کے ساتھ میٹرکس_مولٹپلیکیشن () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے میٹرک کی مصنوعات کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: میٹرکس X اور Y کی مصنوعات: [[30 ، 24 ، 18] ، [84 ، 69 ، 54] ، [138 ، 114 ، 90]] اس آؤٹ پٹ نے حساب شدہ میٹرک کی مصنوعات کو ظاہر کیا ہے۔نیسٹڈ لوپ کے ساتھ میٹرکس_مولٹپلیکشن () فنکشن کا استعمالیہاں ایک مثال کے نفاذ ہے: پیتھونیمپورٹ نیمپی بطور این پی ڈی ای ایف میٹرکس_مولٹپلیکشن (ایکس ، وائی): x = np.array (x) y = np.array (y) نتیجہ = np.dot (x ، y) واپسی کا نتیجہ۔ ٹولسٹ () اس فنکشنان پٹ کے طور پر دو میٹرکس X اور y لیتا ہے اور نمی کا استعمال کرتے ہوئے ان کی مصنوعات کو لوٹاتا ہے۔یہ سب سے پہلے میٹرکس کو NP.Array () طریقہ کار کا استعمال کرتے ہوئے numpy صفوں میں تبدیل کرتا ہے۔اس کے بعد ، یہ میٹرکس کی مصنوعات کا حساب لگانے کے لئے NP.DOT () کا طریقہ استعمال کرتا ہے۔آخر میں ، یہ ٹولسٹ () کے طریقہ کار کا استعمال کرتے ہوئے اس کی فہرست میں واپس آجاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیٹونکس = [[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8، 9]] Y = [[9 ، 8 ، 7] ، [6 ، 5 ، 4] ، [3 ، 2 ، 1]] نتیجہ = میٹرکس_مولٹیکشن (ایکس ، وائی) پرنٹ (\"میٹرکس X اور Y کی مصنوعات:\"، نتیجہ) یہ پروگرام پہلے کچھ اقدار کے ساتھ X اور Y نامی دو میٹرک کی ابتدا کرتا ہے۔اس کے بعد ، یہ X اور Y کے ساتھ میٹرکس_مولٹپلیکیشن () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے میٹرک کی مصنوعات کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: میٹرکس X اور Y کی مصنوعات: [[30 ، 24 ، 18] ، [84 ، 69 ، 54] ، [138 ، 114 ، 90]] اس آؤٹ پٹ نے حساب شدہ میٹرک کی مصنوعات کو ظاہر کیا ہے۔نمی کے ساتھ میٹرکس_مولٹپلیکیشن () فنکشن کا استعمال کرنا۔نمی کا نفاذ عام طور پر بڑے میٹرکس کے لئے تیز اور زیادہ موثر ہوتا ہے۔"
    },
    {
        "Question": "ایک اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور یہ چیک کرنے کے لئے کسی طریقہ کو نافذ کریں کہ آیا یہ خالی ہے یا نہیں۔",
        "Answer": "یہاں ایک پائیون کلاس کا ایک مثال عمل ہے جو اسٹیک کی نمائندگی کرتا ہے اور یہ چیک کرنے کے لئے کسی طریقہ پر عمل درآمد کرتا ہے کہ آیا یہ خالی ہے: پیتھونکلاس اسٹیک: ڈیف __init __ (خود): خود۔ آئٹمز = [] Def is_empty (self): واپسی لین (سیلف۔ آئٹم)== 0 اس پر عمل درآمد ایک کنسٹرکٹر کے ساتھ اسٹیک کلاس کی وضاحت کرتا ہے جو آئٹمز نامی خالی فہرست کو شروع کرتا ہے۔اسٹیک کلاس میں ایک is_empty () طریقہ بھی ہوتا ہے جو اسٹیک خالی ہے (یعنی آئٹمز کی فہرست کی لمبائی 0 ہے) اور غلط ہے۔پرنٹ (\"کیا اسٹیک خالی ہے؟\" ، اسٹیک۔ آئیس_پٹی ()) یہ پروگرام پہلے اسٹیک کلاس کی ایک مثال تیار کرتا ہے جسے اسٹیک کہتے ہیں۔اس کے بعد ، یہ اسٹیک آبجیکٹ پر IS_EMPTY () کے طریقہ کار کو کال کرتا ہے اور پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار ہوگی: کیا اسٹیک خالی ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_empty () کا طریقہ صحیح طور پر شناخت کرتا ہے کہ اسٹیک خالی ہے۔ نوٹ کریں کہ یہ عمل درآمد اسٹیک بنانے اور چیک کرنے کا صرف ایک طریقہ ہے کہ آیا یہ خالی ہے یا نہیں۔اسٹیک کو نافذ کرنے کے اور بھی طریقے ہیں ، جیسے لنکڈ فہرست کا استعمال کرنا یا عناصر کو آگے بڑھانے اور پاپ کرنے کے ل additional اضافی طریقوں کو نافذ کرنا۔"
    },
    {
        "Question": "دو نمبروں میں سے کم سے کم عام ایک سے زیادہ (LCM) تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں دو نمبروں میں سے کم سے کم عام ایک سے زیادہ (LCM) تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: فرکشن ماڈیول سے جی سی ڈی فنکشن کا استعمال: ہم فارمولا LCM (A ، B) = (A * B) // GCD کا استعمال کرتے ہوئے دو نمبروں کا LCM تلاش کرنے کے لئے فریکشن ماڈیول سے GCD فنکشن استعمال کرسکتے ہیں۔(a ، b)یہاں ایک مثال کے نفاذ ہے: ازگر کے فرکشن کو درآمد GCDDEF LCM (A ، B): واپسی (A * B) // GCD (A ، B) یہ فنکشن ان پٹ کے طور پر دو عدد A اور B لیتا ہے اور جی سی ڈی فنکشن کا استعمال کرتے ہوئے ان کے LCM کو واپس کرتا ہے۔فرکشن ماڈیول۔اس میں LCM کا حساب لگانے کے لئے فارمولا LCM (a ، b) = (a * b) // gcd (a ، b) کا استعمال کیا جاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پیتھونا = 12b = 14result = lcm (a ، b) پرنٹ (\"LCM آف\" ، A ، \"اور\" ، B ، \"ہے:\" ، نتیجہ) یہ پروگرام پہلے کچھ اقدار کے ساتھ A اور B نامی دو عدد کا آغاز کرتا ہے۔اس کے بعد ، یہ LCM () کو A اور B کے ساتھ ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے دو نمبروں کے LCM پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 12 اور 14 کا LCM IS: 84 اس آؤٹ پٹ میں LCM () فنکشن کا استعمال کرتے ہوئے LCM () فنکشن کا استعمال کرتے ہوئے LCM کو دکھاتا ہے۔جبکہ دو نمبروں کے LCM کو بڑی تعداد کے تمام ضربوں کے ذریعے تکرار کرکے تلاش کرنے کے لئے لوپ جب تک کہ ہمیں ایک سے زیادہ نہ مل جائے جو چھوٹی تعداد میں بھی ایک سے زیادہ ہے۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف LCM (A ، B): اگر A> B: زیادہ = A اور: زیادہ سے زیادہ = B جبکہ سچ ہے: اگر زیادہ سے زیادہ A == 0 اور زیادہ ٪ B == 0: lcm = زیادہ سے زیادہ بریک زیادہ + += 1 واپسی LCMTHIS فنکشن ان پٹ کے طور پر دو عدد A اور B لیتا ہے اور تھوڑی دیر لوپ کا استعمال کرتے ہوئے اپنے LCM واپس کرتا ہے۔یہ پہلے چیک کرتا ہے کہ کون سی تعداد زیادہ ہے اور اس نمبر پر زیادہ سے زیادہ متغیر کی ابتدا کرتی ہے۔اس کے بعد ، اس سے زیادہ کے تمام ضربوں کے ذریعے تکرار کرنے کے لئے تھوڑی دیر کا استعمال ہوتا ہے جب تک کہ اس کو ایک سے زیادہ نہ مل جائے جو چھوٹی تعداد میں بھی ایک سے زیادہ ہے۔یہ نتیجہ کو LCM نامی متغیر میں محفوظ کرتا ہے اور اسے واپس کرتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھونا = 12 بی = 14 ریزولٹ = ایل سی ایم (اے ، بی) پرنٹ (\"ایل سی ایم آف\" ، اے ، \"اور\" ، بی ،\"آئی ایس:\" ، نتیجہ) اس پروگرام میں پہلے کچھ اقدار کے ساتھ A اور B نامی دو عدد کا آغاز ہوتا ہے۔اس کے بعد ، یہ LCM () کو A اور B کے ساتھ ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے دو نمبروں کے LCM پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 12 اور 14 کا LCM IS: 84 یہ آؤٹ پٹ LCM () فنکشن کا استعمال کرتے ہوئے حساب کردہ دو نمبروں کے LCM کو ظاہر کرتا ہے۔ازگر میں دو نمبرپہلا نفاذ زیادہ موثر ہے اور فرکشن ماڈیول سے جی سی ڈی فنکشن کا استعمال کرتا ہے ، جبکہ دوسرا عمل آسان ہے اور تھوڑی دیر کا استعمال کرتا ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ ازگر میں ایک درست IPv4 ایڈریس ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: آئی پی ایڈریس ماڈیول کا استعمال کرتے ہوئے: ہم آئی پی وی 4 ایڈریس کی توثیق کرنے کے لئے ازگر کے معیاری لائبریری سے آئی پی ایڈریس ماڈیول استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیٹونیمپورٹ IPADDRESSDEF IS_Valid_IPV4_Address (ایڈریس): کوشش کریں: IPADDRESS.IPV4Address (ایڈریس) IPaddress کے سوا سچ واپس کریں۔ AddressvalueError: واپسی فالسیتھس فنکشن ان پٹ کے طور پر ایک سٹرنگ ایڈریس لیتا ہے اور اگر یہ ایک درست IPV4 پتہ اور غلط ہے تو یہ سچ ہے۔ایڈریس کو درست کرنے کے لئے اس میں آئی پی ای ڈی ڈریس ماڈیول سے آئی پی وی 4 ایڈریس () کا طریقہ استعمال کیا جاتا ہے۔اگر پتہ درست ہے تو ، طریقہ ایک IPv4Address آبجیکٹ کو لوٹاتا ہے ، اور فنکشن درست لوٹتا ہے۔اگر پتہ درست نہیں ہے تو ، طریقہ کار ایڈریس ویلیوئیرر استثناء اٹھاتا ہے ، اور فنکشن غلط کو واپس کرتا ہے۔ فنکشن کو استعمال کرنے کی ایک مثال ہے: پائیتھون ایڈریس = \"192.168.0.1\" نتیجہ = is_valid_ipv4_address (ایڈریس) پرنٹ (\"ہے\" ، ایڈریس، \"ایک درست IPv4 ایڈریس؟\" ، نتیجہ) یہ پروگرام پہلے \"192.168.0.1\" کی قیمت کے ساتھ ایڈریس نامی ایک تار شروع کرتا ہے۔اس کے بعد ، یہ IS_Valid_ipv4_address () کو ایڈریس کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا ایڈریس پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک درست IPv4 پتہ ہے۔اس معاملے میں ، پیداوار ہوگی: کیا 192.168.0.1 ایک درست IPv4 پتہ ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_valid_ipv4_address () فنکشن صحیح طریقے سے اس کی نشاندہی کرتا ہے کہ ایڈریس ایک درست IPv4 پتہ ہے۔ باقاعدہ اظہار کا استعمال کرتے ہوئے: ہم IPv4 ایڈریس کو جانچ کر کے باقاعدہ اظہار کا استعمال کرسکتے ہیں اگر یہ شامل کرنے کی حد 0 میں چار اعشاریہ کے اعداد و شمار سے مماثل ہے یا نہیں۔–255 ، نقطوں سے الگ.یہاں ایک مثال کے نفاذ ہے: پائیتھونیمپورٹ ریڈف is_valid_ipv4_address (ایڈریس): پیٹرن = r \"^((25 [0-5] | 2 [0-4] [0-4] [0-9] | [01]؟ [0-9] [0-9] [0-9] [0-9]9]؟) \\.) {3} (25 [0-5] | 2 [0-4] [0-9] | [01]؟ [0-9] [0-9]؟.ایڈریس کو درست کرنے کے لئے یہ باقاعدہ اظہار کا نمونہ استعمال کرتا ہے۔پیٹرن جامع رینج 0-255 میں چار اعشاریہ عدد سے میل کھاتا ہے ، جو ڈاٹ کے ذریعہ الگ ہوتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھونا ایڈریس = \"192.168.0.1\" نتیجہ = is_valid_ipv4_address (ایڈریس) پرنٹ (\"ہے\" ، ایڈریس ، \"ایک درست IPv4 پتہ؟ \"، نتیجہ) یہ پروگرام پہلے\" 192.168.0.1 \"کی قیمت کے ساتھ ایڈریس نامی ایک تار شروع کرتا ہے۔اس کے بعد ، یہ IS_Valid_ipv4_address () کو ایڈریس کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا ایڈریس پرنٹ () فنکشن کا استعمال کرتے ہوئے ایک درست IPv4 پتہ ہے۔اس معاملے میں ، پیداوار ہوگی: کیا 192.168.0.1 ایک درست IPv4 پتہ ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ IS_Valid_ipv4_address () فنکشن صحیح طریقے سے اس بات کی نشاندہی کرتا ہے کہ ایڈریس ایک درست IPv4 ایڈریس ہے۔ دونوں عمل درآمد درست ہیں اور یہ چیک کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا دیئے گئے سٹرنگ ازگر میں ایک درست IPv4 پتہ ہے یا نہیں۔پہلا نفاذ ازگر اسٹینڈرڈ لائبریری سے آئی پی ایڈریس ماڈیول کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ باقاعدگی سے اظہار استعمال کرتا ہے۔"
    },
    {
        "Question": "دیئے گئے نمبر کا سب سے بڑا بنیادی عنصر تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "کسی مخصوص نمبر کا سب سے بڑا بنیادی عنصر تلاش کرنے کے لئے ایک ازگر پروگرام کا ایک مثال عمل ہے: پائیٹونیمپورٹ ریاضی کے سب سے بڑے_پائم_فیکٹر (n): میکس_ پرائم_فیکٹر = 0 جبکہ n ٪ 2 == 0: زیادہ سے زیادہ 2 == 0: میکس_پریم_فیر = 2 این = این / 2 (I in رینج میں I کے لئے (MAX_PRIME_FARM_FARM_FARM_FARM_FAFICTOR = 2 N = N / 23 ، int (math.sqrt (n)) + 1 ، 2): جبکہ n ٪ i == 0: max_prime_factor = i n = n / i اگر n> 2: میکس_ پرائم_فیکٹر = n ریٹرن انٹ (میکس_ پرائم_فیکٹر) یہ عمل ایک فنکشن کی وضاحت کرتا ہےسب سے بڑا_پائم_فیکٹر () کہا جاتا ہے جو ان پٹ کے طور پر ایک عدد N لیتا ہے اور N کا سب سے بڑا بنیادی عنصر لوٹاتا ہے۔یہ سب سے پہلے میکس_ پرائم_فیکٹر نامی متغیر کی ابتدا کرتا ہے۔ پھر ، یہ N کو 2 کے ذریعہ تقسیم کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے جب تک کہ یہ 2 کے ذریعہ اب تقسیم نہیں ہوتا ہے ، اور میکس_ پرائم_فیکٹر کو 2 میں اپ ڈیٹ کرتا ہے۔اگلا ، یہ لوپ کے لئے A کا استعمال 3 سے لے کر N کے مربع جڑ تک تمام عجیب تعداد میں تکرار کرنے کے لئے کرتا ہے ، اور ہر عجیب نمبر کے ذریعہ N کو تقسیم کرتا ہے جب تک کہ اس نمبر کے ذریعہ اب یہ تقسیم نہ ہو۔اگر یہ N کا عنصر ہے تو یہ MAX_PRIME_FACTOR کو موجودہ نمبر پر اپ ڈیٹ کرتا ہے۔آخر میں ، یہ میکس_پرائم_فیکٹر کو ایک عدد کے طور پر لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن = 60 ریزولٹ = سب سے بڑا_پائم_فیکٹر (این) پرنٹ (\"\" ، این ، \"کا سب سے بڑا بنیادی عنصر\" ہے: \"، نتیجہ) یہ پروگرام پہلی بار شروع ہوتا ہےایک انٹیجر جس کو N 60 کی قیمت کے ساتھ فون کیا جاتا ہے۔ پھر ، یہ N کے ساتھ سب سے بڑا_پائم_ فیکٹر () فنکشن ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N کا سب سے بڑا بنیادی عنصر پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 60 کا سب سے بڑا بنیادی عنصر یہ ہے: 5 اس آؤٹ پٹ سے پتہ چلتا ہے کہ سب سے بڑا_پائم_فیکٹر () فنکشن صحیح طور پر اس کی نشاندہی کرتا ہے کہ 60 کا سب سے بڑا بنیادی عنصر 5 ہے۔ نوٹ کریں کہ اس عمل کو لوپ اور لوپ کے لئے ایک وقت استعمال ہوتا ہے۔N کے عوامل کے ذریعے تکرار کرنے اور چیک کرنے کے لئے کہ آیا وہ وزیر اعظم ہیں۔کسی تعداد کے سب سے بڑے بنیادی عنصر کو تلاش کرنے کے ل other اور بھی نقطہ نظر موجود ہیں ، جیسے recursion یا eratustshenes کی چھلنی استعمال کرنا۔"
    },
    {
        "Question": "سرکلر سے منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور شروع میں نوڈ داخل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس کی ایک مثال ہے جو سرکلر سے منسلک فہرست کی نمائندگی کرتی ہے اور شروع میں نوڈ داخل کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرتی ہے: پائیتھنکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا نیکسٹ = نون کلاس سرکلر لنکڈ لسٹ: ڈیف __ __init__(خود): خود نہیں۔موجودہ۔ نیکسٹ! = سیلف ہیڈ: کرنٹ = کرنٹ۔ نیکسٹ کرنٹ۔ نیکسٹ = نیا_نوڈ نیا_نوڈ.نیکسٹ = سیلف ہیڈ سیل۔ ہیڈ = نیا_نوڈتیس عمل درآمد ایک کنسٹرکٹر کے ساتھ ایک نوڈ کلاس کی وضاحت کرتا ہے جو ڈیٹا پراپرٹی اور اگلی پراپرٹی کا آغاز کرتا ہے جو پوائنٹس کی شروعات کرتا ہے۔فہرست میں اگلے نوڈ پر۔اس عمل میں ایک سرکلر لنکڈ لسٹ کلاس کی بھی وضاحت کی گئی ہے جس میں ایک کنسٹرکٹر کے ساتھ ہیڈ پراپرٹی شروع نہیں کی جاتی ہے۔سرکلر لنکڈ لسٹ کلاس میں ایک داخل_اٹ_بیگیننگ () طریقہ بھی ہوتا ہے جو ڈیٹا پیرامیٹر لیتا ہے اور سرکلر سے منسلک فہرست کے آغاز میں دیئے گئے ڈیٹا کے ساتھ ایک نیا نوڈ داخل کرتا ہے۔اگر فہرست خالی ہے تو ، نیا نوڈ سر بن جاتا ہے ، اور اس کی اگلی پراپرٹی خود ہی اشارہ کرتی ہے۔اگر فہرست خالی نہیں ہے تو ، آخری نوڈ تلاش کرنے کے ل the اس طریقہ کار کی فہرست کے ذریعے تکرار کرتا ہے اور اس کی اگلی پراپرٹی کو نئے نوڈ کی طرف اشارہ کرنے کے لئے اپ ڈیٹ کرتا ہے۔نئی نوڈ کی اگلی پراپرٹی سر کی طرف اشارہ کرتی ہے ، اور سر کو نئے نوڈ کی طرف اشارہ کرنے کے لئے اپ ڈیٹ کیا جاتا ہے۔ سرکلر لنکڈ لسٹ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونکلسٹ = سرکلر لنکڈ لسٹ () clist.insert_at_beginning (1) clist.insert_at_beginning (2)clist.insert_at_beginning (3) یہ پروگرام سب سے پہلے سرکلر لنکسیڈ لسٹ کلاس کی ایک مثال تخلیق کرتا ہے جسے کلسٹ کہتے ہیں۔اس کے بعد ، یہ سرکلر لنکڈ لسٹ کے آغاز میں تین نوڈس داخل کرنے کے لئے مختلف اقدار کے ساتھ کلیسٹ پر INSERT_AT_BEGINNNING () کا طریقہ قرار دیتا ہے۔ نوٹ کریں کہ اس عمل سے یہ فرض کیا گیا ہے کہ سرکلر سے منسلک فہرست اکیلے منسلک ہے۔اگر سرکلر لنکڈ فہرست دوگنا منسلک ہے تو ، ہمیں نوڈس کی پراپرٹی پراپرٹی کو بھی اپ ڈیٹ کرنے کی ضرورت ہے۔"
    },
    {
        "Question": "دو فہرستوں کا چوراہا تلاش کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں دو فہرستوں کا چوراہا تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: سیٹ چوراہے کا استعمال: ہم دو فہرستوں کا چوراہا تلاش کرنے کے لئے بلٹ ان سیٹ چوراہے کا طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف چوراہا (لسٹ 1 ، لسٹ 2): سیٹ 1 = سیٹ (لسٹ 1) سیٹ 2 = سیٹ (لسٹ 2) ریٹرن لسٹ (سیٹ 1.ٹریسیکشن (سیٹ 2)) یہ فنکشن دو فہرستوں کی فہرست 1 اور لسٹ 2 کو ان پٹ کے طور پر لوٹاتا ہے اور اپنے چوراہے کو واپس کرتا ہے اور ان کے چوراہے کو واپس کرتا ہے اور ان کے چوراہے کو واپس کرتا ہے۔چوراہے کا طریقہ۔یہ پہلے سیٹ () کے طریقہ کار کا استعمال کرتے ہوئے فہرستوں کو سیٹ میں تبدیل کرتا ہے۔اس کے بعد ، یہ دونوں سیٹوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرتا ہے۔آخر میں ، یہ فہرست () کے طریقہ کار کا استعمال کرتے ہوئے کسی فہرست میں واپس بدلتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیٹون لسٹ 1 = [1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [4 ، 5 ، 6 ، 7، 8] نتیجہ = چوراہا (لسٹ 1 ، لسٹ 2) پرنٹ (\"چوراہا\" ، لسٹ 1 ، \"اور\" ، لسٹ 2 ، \"ہے:\" ، نتیجہ) یہ پروگرام پہلے کچھ اقدار کے ساتھ لسٹ 1 اور لسٹ 2 نامی دو فہرستوں کی ابتدا کرتا ہے۔اس کے بعد ، یہ چوراہا () کو لسٹ 1 اور لسٹ 2 کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے دونوں فہرستوں کے چوراہے پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [1 ، 2 ، 3 ، 4 ، 5] اور [4 ، 5 ، 6 ، 7 ، 8] کا چوراہا یہ ہے: [4 ، 5] اس آؤٹ پٹ سے پتہ چلتا ہے کہ چوراہا () فنکشن () فنکشندونوں فہرستوں کے مابین مشترکہ عناصر کی صحیح طور پر نشاندہی کرتا ہے۔ فہرست کی تفہیم کا استعمال: ہم ایک فہرست کے عناصر کے ذریعے تکرار کرکے دو فہرستوں کا چوراہا تلاش کرنے کے لئے ایک فہرست کی تفہیم کا استعمال کرسکتے ہیں اور جانچ پڑتال کرتے ہیں کہ آیا وہ دوسری فہرست میں موجود ہیں یا نہیں۔یہاں ایک مثال کے نفاذ ہے: پائیٹنڈف چوراہا (فہرست 1 ، فہرست 2): واپسی [فہرست 1 میں عنصر کے لئے عنصر اگر عنصر 2 میں عنصر] یہ فنکشن دو فہرستوں کی فہرست 1 اور لسٹ 2 کو ان پٹ کے طور پر لیتا ہے اور فہرست کی تفہیم کا استعمال کرتے ہوئے ان کے چوراہے کو واپس کرتا ہے۔اگر وہ لسٹ 2 میں موجود ہیں تو یہ لسٹ 1 اور چیک کے عناصر کے ذریعے تکرار کرتا ہے۔اگر کوئی عنصر دونوں فہرستوں میں موجود ہے تو ، اس کو آؤٹ پٹ لسٹ میں شامل کیا گیا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیٹون لسٹ 1 = [1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [4 ، 5 ، 6 ، 7، 8] نتیجہ = چوراہا (لسٹ 1 ، لسٹ 2) پرنٹ (\"چوراہا\" ، لسٹ 1 ، \"اور\" ، لسٹ 2 ، \"ہے:\" ، نتیجہ) یہ پروگرام پہلے کچھ اقدار کے ساتھ لسٹ 1 اور لسٹ 2 نامی دو فہرستوں کی ابتدا کرتا ہے۔اس کے بعد ، یہ چوراہا () کو لسٹ 1 اور لسٹ 2 کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے دونوں فہرستوں کے چوراہے پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [1 ، 2 ، 3 ، 4 ، 5] اور [4 ، 5 ، 6 ، 7 ، 8] کا چوراہا یہ ہے: [4 ، 5] اس آؤٹ پٹ سے پتہ چلتا ہے کہ چوراہا () فنکشن () فنکشندونوں فہرستوں کے مابین مشترکہ عناصر کی صحیح طور پر نشاندہی کرتا ہے۔ دونوں عمل درآمد درست ہیں اور ازگر میں دو فہرستوں کے چوراہے کو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔پہلا نفاذ زیادہ موثر ہے اور سیٹ چوراہے کا طریقہ استعمال کرتا ہے ، جبکہ دوسرا نفاذ ایک فہرست کی تفہیم کا استعمال کرتا ہے۔"
    },
    {
        "Question": "دیئے گئے لمبائی کا بے ترتیب پاس ورڈ تیار کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں دیئے گئے لمبائی کا بے ترتیب پاس ورڈ تیار کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: سٹرنگ ماڈیول کا استعمال: ہم حروف کے پہلے سے طے شدہ سیٹ سے حروف کو منتخب کرکے بے ترتیب پاس ورڈ تیار کرنے کے لئے سٹرنگ ماڈیول کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیٹونیمپورٹ رینڈم امپورٹ سٹرنگ ڈیف جنریٹ_ پاس ورڈ (لمبائی): خط = سٹرنگ.اسکی_لیٹرز ہندسے = سٹرنگ.ڈیجٹس کی علامتیں = سٹرنگ۔لمبائی)) ریٹرن پاس ورڈ یہ فنکشن ان پٹ کے طور پر ایک عدد لمبائی لیتا ہے اور مخصوص لمبائی کا بے ترتیب پاس ورڈ لوٹاتا ہے۔اس میں پہلے تین متغیرات کا آغاز ہوتا ہے جسے خطوط ، ہندسوں اور علامتوں کو خطوط ، ہندسوں ، اور سٹرنگ ماڈیول میں بیان کردہ علامتوں کے سیٹ کہتے ہیں۔اس کے بعد ، اس میں ایک فہرست کی تفہیم اور بے ترتیب۔ چوائس () کا طریقہ استعمال کیا گیا ہے تاکہ خطوط ، ہندسوں اور علامتوں کے مشترکہ سیٹ سے بے ترتیب حروف کو منتخب کیا جاسکے۔آخر میں ، یہ منتخب کردہ حروف کو ایک تار میں شامل کرتا ہے اور اسے لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونلنتھ = 10 پاس ورڈ = جنریٹ_ پاس ورڈ (لمبائی) پرنٹ (\"لمبائی کا بے ترتیب پاس ورڈ\" ، لمبائی ، \"ہے:\" ، پاس ورڈ)یہ پروگرام پہلے 10 کی قیمت کے ساتھ لمبائی کے نام سے ایک انٹیجر کی ابتدا کرتا ہے۔ پھر ، یہ لمبائی کے ساتھ جنریٹ_ پاس ورڈ () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں متغیر کو پاس ورڈ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بے ترتیب پاس ورڈ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: لمبائی 10 کا بے ترتیب پاس ورڈ یہ ہے: 8J! 2G#7x $ zthis آؤٹ پٹ سے پتہ چلتا ہے کہ جنریٹ_ پاس ورڈ () فنکشن صحیح طور پر مخصوص لمبائی کا بے ترتیب پاس ورڈ تیار کرتا ہے۔ سیکریٹ ماڈیول کا استعمال: ہم استعمال کرسکتے ہیں۔خفیہ ماڈیول ایک خفیہ نگاری سے محفوظ بے ترتیب پاس ورڈ تیار کرنے کے لئے۔یہاں ایک مثال عمل ہے: پائیتھونیمپورٹ سیکریٹسم پورٹ سٹرنگ ڈیف جنریٹ_ پاس ورڈ (لمبائی): حرف تہجی = سٹرنگ.اسکی_لیٹرز + سٹرنگ.ڈیجٹس + سٹرنگ۔ان پٹ کے طور پر ایک انٹیجر لمبائی لیتا ہے اور مخصوص لمبائی کا ایک خفیہ نگاری سے محفوظ بے ترتیب پاس ورڈ واپس کرتا ہے۔یہ سب سے پہلے حرف ، ہندسوں ، اور سٹرنگ ماڈیول میں بیان کردہ علامتوں کے سیٹ کے ساتھ حرف تہجی نامی متغیر کی ابتدا کرتا ہے۔اس کے بعد ، اس میں ایک فہرست کی تفہیم اور راز استعمال کیا جاتا ہے۔ حرفی سیٹ سے بے ترتیب حرفوں کو کریپٹوگرافک طور پر محفوظ کرنے کے لئے انتخاب () کا طریقہ۔آخر میں ، یہ منتخب کردہ حروف کو ایک تار میں شامل کرتا ہے اور اسے لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونلنتھ = 10 پاس ورڈ = جنریٹ_ پاس ورڈ (لمبائی) پرنٹ (\"لمبائی کا بے ترتیب پاس ورڈ\" ، لمبائی ، \"ہے:\" ، پاس ورڈ)یہ پروگرام پہلے 10 کی قیمت کے ساتھ لمبائی کے نام سے ایک انٹیجر کی ابتدا کرتا ہے۔ پھر ، یہ لمبائی کے ساتھ جنریٹ_ پاس ورڈ () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے میں متغیر کو پاس ورڈ کہتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بے ترتیب پاس ورڈ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: لمبائی 10 کا بے ترتیب پاس ورڈ یہ ہے: 8J! 2G#7x $ ZTHIS آؤٹ پٹ سے پتہ چلتا ہے کہ جنریٹ_ پاس ورڈ () فنکشن صحیح طور پر ایک مخصوص لمبائی کا ایک خفیہ نگاری سے محفوظ بے ترتیب پاس ورڈ تیار کرتا ہے۔ازگر میں دی گئی لمبائی کا بے ترتیب پاس ورڈ تیار کرنے کے لئے استعمال کیا جاتا ہے۔پہلا نفاذ سٹرنگ اور بے ترتیب ماڈیولز کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ سٹرنگ اور راز ماڈیول استعمال کرتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا ایک دیئے گئے نمبر ایک کامل مربع ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے نمبر ازگر میں ایک بہترین مربع ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ریاضی کے ماڈیول کا استعمال: ہم ریاضی کے ماڈیول سے ISQRT () فنکشن استعمال کرسکتے ہیں تاکہ یہ معلوم کیا جاسکے کہ کوئی نمبر ایک کامل مربع ہے یا نہیں۔یہاں ایک مثال عمل ہے: پائیٹونیمپورٹ میتھ ڈیف IS_PERFECT_SQUARE (نمبر): روٹ = ریاضی۔ ISQRT (نمبر) ریٹرن روٹ * روٹ * روٹ == نمبر یہ فنکشن ان پٹ کے طور پر ایک عدد نمبر لیتا ہے اور اگر یہ ایک بہترین مربع اور غلط ہے تو یہ سچ ہے۔یہ نمبر کے عددی مربع جڑ کا حساب لگانے کے لئے ریاضی کے ماڈیول سے ISQRT () فنکشن کا استعمال کرتا ہے۔پھر ، یہ چیک کرتا ہے کہ آیا انٹیجر اسکوائر روٹ کا مربع اصل نمبر کے برابر ہے۔اگر یہ ہے تو ، نمبر ایک کامل مربع ہے ، اور فنکشن سچ واپس آجاتا ہے۔بصورت دیگر ، فنکشن غلط کو لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن نمبر = 25 ریزولٹ = is_perfect_square (نمبر) پرنٹ (\"IS\" ، نمبر ، \"ایک کامل مربع؟\" ، نتیجہ) یہ پروگرام پہلے ایک انٹیجر نامی نمبر شروع کرتا ہے جس میں نمبر کہا جاتا ہے۔25 کی قیمت کے ساتھ۔ پھر ، یہ IS_PERFECT_SQUARE () فنکشن کو نمبر کے ساتھ فون کرتا ہے اور ان پٹ کے طور پر اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا پرنٹ () فنکشن کا استعمال کرتے ہوئے نمبر ایک بہترین مربع ہے یا نہیں۔اس معاملے میں ، پیداوار ہوگی: کیا 25 ایک کامل مربع ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_perfect_square () فنکشن صحیح طریقے سے اس بات کی نشاندہی کرتا ہے کہ 25 ایک کامل مربع ہے۔ انٹیجر ڈویژن کا استعمال: ہم یہ چیک کرنے کے لئے انٹیجر ڈویژن کا استعمال کرسکتے ہیں کہ آیا نمبر کے 1 سے مربع روٹ تک تمام عدد کے ذریعے تکرار کرکے کوئی نمبر ایک بہترین مربع ہے یا نہیں۔اور یہ چیک کرنا کہ آیا ان کا مربع اصل نمبر کے برابر ہے۔یہاں ایک مثال عمل ہے: پائیتھنڈف IS_PERFECT_SQUARE (نمبر): رینج میں Iسچ ہے اگر یہ ایک کامل مربع اور غلط ہے۔یہ لوپ کے لئے A کا استعمال 1 سے لے کر نمبر کے مربع جڑ تک تمام عدد کے ذریعے تکرار کرنے کے لئے کرتا ہے۔پھر ، یہ چیک کرتا ہے کہ آیا موجودہ عددی کا مربع اصل نمبر کے برابر ہے۔اگر یہ ہے تو ، نمبر ایک کامل مربع ہے ، اور فنکشن سچ واپس آجاتا ہے۔اگر لوپ کامل مربع کی تلاش کیے بغیر مکمل ہوجاتا ہے تو ، فنکشن غلط کو لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن نمبر = 25 ریزولٹ = is_perfect_square (نمبر) پرنٹ (\"IS\" ، نمبر ، \"ایک کامل مربع؟\" ، نتیجہ)یہ پروگرام سب سے پہلے 25 کی قیمت کے ساتھ نمبر نامی ایک انٹیجر کی ابتدا کرتا ہے۔ پھر ، یہ IS_PERFECT_SQUARE () فنکشن کو نمبر کے ساتھ فون کرتا ہے اور ان پٹ کے طور پر اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا پرنٹ () فنکشن کا استعمال کرتے ہوئے نمبر ایک بہترین مربع ہے یا نہیں۔اس معاملے میں ، پیداوار ہوگی: کیا 25 ایک کامل مربع ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_perfect_square () فنکشن صحیح طور پر اس بات کی نشاندہی کرتا ہے کہ 25 ایک کامل مربع ہے۔ دونوں عمل درآمد درست ہیں اور یہ چیک کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا کوئی دی گئی تعداد ازگر میں ایک بہترین مربع ہے یا نہیں۔پہلا نفاذ ریاضی کے ماڈیول سے ISQRT () فنکشن کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ انٹیجر ڈویژن۔"
    },
    {
        "Question": "بلبلا ترتیب والے الگورتھم کا استعمال کرتے ہوئے عددیوں کی فہرست کو ترتیب دینے کے لئے ایک پروگرام کو نافذ کریں۔",
        "Answer": "بلبلا ترتیب والے الگورتھم کا استعمال کرتے ہوئے عددیوں کی فہرست کو ترتیب دینے کے لئے ایک ازگر پروگرام کی ایک مثال کے نفاذ: پائیتھنڈف بلبلا_سورٹ (نمبر): این = لین (نمبر) کے لئے I (n) کی حد (n) کے لئے (n - i - 1 - 1): اگر نمبر [j]> نمبر [j + 1]: نمبر [j] ، نمبر [j + 1] = نمبر [j + 1] ، نمبر [j] واپسی نمبر یہ عمل درآمد بلبل_سورٹ () نامی ایک تقریب کی وضاحت کرتا ہے۔ان پٹ کے طور پر عددی نمبروں کی ایک فہرست اور بلبلا ترتیب والے الگورتھم کا استعمال کرتے ہوئے ترتیب شدہ فہرست کو لوٹاتا ہے۔یہ پہلے فہرست کی لمبائی میں N نامی متغیر کی ابتدا کرتا ہے۔اس کے بعد ، اس فہرست میں ملحقہ عناصر کے تمام جوڑے کے ذریعے تکرار کے ل lo لوپ کے لئے دو گھوںسلا استعمال کرتا ہے۔ہر جوڑی کے ل it ، یہ چیک کرتا ہے کہ آیا پہلا عنصر دوسرے عنصر سے زیادہ ہے یا نہیں۔اگر یہ ہے تو ، یہ عناصر کو تبدیل کرتا ہے۔تمام تکرار کو مکمل کرنے کے بعد ، فنکشن ترتیب شدہ فہرست کو لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھوننمبرز = [5 ، 3 ، 8 ، 6 ، 7 ، 2] نتیجہ = بلبلا_سورٹ (نمبر) پرنٹ (\"ترتیب شدہ فہرست ہے:\"، نتیجہ) یہ پروگرام سب سے پہلے کچھ اقدار کے ساتھ نمبر نامی فہرست کی ابتدا کرتا ہے۔اس کے بعد ، یہ بلبلا_سورٹ () کو ان پٹ کے طور پر نمبر کے ساتھ فنکشن کہتے ہیں اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتے ہیں۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے ترتیب شدہ فہرست پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ترتیب شدہ فہرست یہ ہے کہ: [2 ، 3 ، 5 ، 6 ، 7 ، 8] اس آؤٹ پٹ سے پتہ چلتا ہے کہ بلبل_سورٹ () فنکشن بلبل ترتیب والے الگورتھم کا استعمال کرتے ہوئے انٹیجرز کی فہرست کو صحیح طریقے سے ترتیب دیتا ہے۔بلبلا ترتیب والے الگورتھم میں O (n^2) کی وقت کی پیچیدگی ہوتی ہے ، جو اسے بڑی فہرستوں کے لئے غیر موثر بنا دیتا ہے۔بہتر وقت کی پیچیدگی کے ساتھ دیگر چھانٹنے والے الگورتھم ہیں ، جیسے کوئکسورٹ اور انضمام ، جو بڑی فہرستوں کے لئے استعمال ہوسکتے ہیں۔"
    },
    {
        "Question": "ہدایت نامہ گراف کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور چوڑائی کی پہلی تلاش کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "ایک ہدایت شدہ گراف کی نمائندگی کرنے والے ایک ازگر کلاس بنانے اور چوڑائی کی پہلی تلاش کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرنے کے ل we ، ہم نیٹ ورک ایکس ماڈیول سے گراف کلاس اور بی ایف ایس () کا طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: Pythonimport نیٹ ورک ایکس بطور Nxclass ہدایت نامہ: Def __init __ (خود): سیلف گراف = nx.digraph () def add_edge (خود ، u ، v): سیلف.گراف.ڈی گراف.ڈیج (یو ، وی) ڈیف بی ایف ایس (خود، شروع کریں): ملاحظہ کریں = [] قطار = [شروع] جبکہ قطار: نوڈ = قطار.پوپ (0) اگر نوڈ میں نہیں ملاحظہ کیا گیا: ملاحظہ کیا گیا۔: قطار۔ اپینڈ (پڑوسی) واپسی کا دورہ اس پر عمل درآمد ڈائریکٹ گراف نامی ایک کلاس کی وضاحت کرتا ہے جو ہدایت والے گراف کی نمائندگی کرتا ہے۔اس میں ایک کنسٹرکٹر ہے جو نیٹ ورک ایکس ماڈیول سے ڈیگراف () کے طریقہ کار کا استعمال کرتے ہوئے خالی ہدایت نامہ گراف کی ابتدا کرتا ہے۔اس میں ADD_EDGE () نامی ایک طریقہ بھی ہے جو دو نوڈس U اور V کو ان پٹ کے طور پر لیتا ہے اور نیٹ ورک ایکس ماڈیول سے ADD_EDGE () طریقہ کا استعمال کرتے ہوئے گراف میں U سے V تک ہدایت شدہ کنارے کا اضافہ کرتا ہے۔آخر میں ، اس میں BFS () نامی ایک طریقہ ہے جو ان پٹ کے طور پر شروعاتی نوڈ اسٹارٹ لیتا ہے اور شروع سے شروع ہونے والے گراف پر چوڑائی کی پہلی تلاش کرتا ہے۔اس میں ایک فہرست کا استعمال کیا گیا ہے جس کا نام دورہ نوڈس کا ٹریک رکھنے کے لئے کیا گیا ہے اور چوڑائی کی پہلی تلاش کے الگورتھم کو نافذ کرنے کے لئے قطار نامی ایک فہرست۔یہ وزٹ شدہ نوڈس کی فہرست لوٹاتا ہے۔ یہاں کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگرگراف = ڈائریکٹ گراف () گراف.اڈی_ج (1 ، 2) گراف.اڈی_ج (1 ، 3) گراف.اڈی_ج (2 ، 4) گراف.ج_ج_ج_ج۔.اس کے بعد ، یہ ADD_EDGE () طریقہ کار کا استعمال کرتے ہوئے گراف میں کچھ کناروں کا اضافہ کرتا ہے۔آخر میں ، یہ 1 کے ابتدائی نوڈ کے ساتھ BFS () کے طریقہ کار کو کال کرتا ہے اور نتیجہ کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے نتیجہ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: بی ایف ایس ٹریورسل نوڈ 1 سے شروع ہو رہا ہے: [1 ، 2 ، 3 ، 4 ، 5] اس آؤٹ پٹ سے پتہ چلتا ہے کہ بی ایف ایس () کا طریقہ نوڈ سے شروع ہونے والے ہدایت نامہ گراف پر صحیح طور پر چوڑائی کی پہلی تلاش کرتا ہے۔1 اور ملاحظہ کی گئی نوڈس کی فہرست واپس کرتا ہے۔ نوٹ کریں کہ اس پر عمل درآمد نیٹ ورک ایکس ماڈیول کا استعمال کرتا ہے ، جو ازگر میں بلٹ ان ماڈیول نہیں ہے اور اسے الگ سے انسٹال کرنے کی ضرورت ہے۔اس کو انسٹال کرنے کے ل you ، آپ مندرجہ ذیل کمانڈ استعمال کرسکتے ہیں: PIP نیٹ ورک ایکسیلینٹی کے ساتھ انسٹال کریں ، آپ قطار کے ڈیٹا ڈھانچے کا استعمال کرتے ہوئے BFS () کے طریقہ کار کو نافذ کرسکتے ہیں اور ملاحظہ کرنے والے نوڈس کا سراغ لگانے کے لئے ایک لغت ، جیسا کہ تلاش کے کچھ نتائج میں بیان کیا گیا ہے۔تاہم ، نیٹ ورک ایکس ماڈیول ازگر میں گراف کے ساتھ کام کرنے کا ایک زیادہ آسان اور موثر طریقہ فراہم کرتا ہے۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں سروں کی تعداد گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں دیئے گئے تار میں حرفوں کی تعداد کو گننے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال اور اگر بیان: ہم تار میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں اور اگر یہ کردار ایک حرف ہے تو یہ چیک کرنے کے لئے اگر بیان ہے۔یہاں ایک مثال کے نفاذ ہے: پائتھونڈف کاؤنٹی_وولس (سٹرنگ): سرز = \"aeiouaeiou\" گنتی = 0 اسٹرنگ میں چار کے لئے: اگر سروں میں چار: گنتی += 1 ریٹرن کاؤنٹی ان پٹ کے طور پر ایک تار تار لیتا ہے اور اس میں حرفوں کی تعداد کو واپس کرتا ہے اورتاریہ انگریزی میں سروں کے سیٹ کے ساتھ سروں کے نام سے ایک متغیر کی ابتدا کرتا ہے۔اس کے بعد ، یہ تار میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔ہر کردار کے ل it ، یہ چیک کرتا ہے کہ آیا یہ IF بیان اور آپریٹر میں استعمال کرکے حرف ہے۔اگر کردار ایک حرف ہے تو ، اس سے گنتی متغیر میں اضافہ ہوتا ہے۔آخر میں ، یہ سروں کی گنتی کو لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنسٹرنگ = \"ہیلو ، ورلڈ!\" نتیجہ = گنتی_اوولس (سٹرنگ) پرنٹ (\"سروں کی تعداد\" ، سٹرنگ ، \"ہے:\" ، نتیجہ) یہ پروگرام سب سے پہلے کچھ اقدار کے ساتھ سٹرنگ نامی تار شروع کرتا ہے۔اس کے بعد ، یہ ان پٹ کے طور پر سٹرنگ کے ساتھ COUNT_VOWELS () کو فون کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے سٹرنگ میں سروں کی تعداد پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار ہوگی: ہیلو ، دنیا میں سروں کی تعداد!آئی ایس: 3 اس آؤٹ پٹ سے پتہ چلتا ہے کہ COUNT_VOWELS () فنکشن دیئے گئے تار میں سروں کی تعداد کو صحیح طور پر شمار کرتا ہے۔) اسٹرنگ میں سروں کے سیٹ اور حروف کے سیٹ کے مابین مشترکہ عناصر کو تلاش کرنے کا طریقہ۔یہاں ایک مثال عمل ہے: پائیتھنڈف گنتی_اوولس (سٹرنگ): سرز = سیٹ (\"aeiouaeiou\") گنتی = لین (سرز۔ انٹرفیسیکشن (سیٹ (سٹرنگ)) ریٹرن کاؤنٹ اس فنکشن کو ان پٹ کے طور پر سٹرنگ سٹرنگ لیتا ہے اور اس میں سروں کی تعداد کو واپس کرتا ہے۔تاریہ انگریزی میں سروں کے سیٹ کے ساتھ سروں کے نام سے ایک متغیر کی ابتدا کرتا ہے۔اس کے بعد ، یہ سروں کے سیٹ اور تار میں حروف کے سیٹ کے درمیان مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرتا ہے۔آخر میں ، یہ سروں کی گنتی کو لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنسٹرنگ = \"ہیلو ، ورلڈ!\" نتیجہ = گنتی_اوولس (سٹرنگ) پرنٹ (\"سروں کی تعداد\" ، سٹرنگ ، \"ہے:\" ، نتیجہ) یہ پروگرام سب سے پہلے کچھ اقدار کے ساتھ سٹرنگ نامی تار شروع کرتا ہے۔اس کے بعد ، یہ ان پٹ کے طور پر سٹرنگ کے ساتھ COUNT_VOWELS () کو فون کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے سٹرنگ میں سروں کی تعداد پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار ہوگی: ہیلو ، دنیا میں سروں کی تعداد!آئی ایس: 3 اس آؤٹ پٹ سے پتہ چلتا ہے کہ COUNT_VOWELS () فنکشن دیئے گئے تار میں سروں کی تعداد کو صحیح طور پر شمار کرتا ہے۔ دونوں عمل درآمد درست ہیں اور ازگر میں دیئے گئے تار میں حرفوں کی تعداد گننے کے لئے استعمال ہوسکتے ہیں۔پہلا نفاذ ایک لوپ اور اگر بیان استعمال کرتا ہے ، جبکہ دوسرا نفاذ سیٹ استعمال کرتا ہے۔"
    },
    {
        "Question": "دیئے گئے عدد کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں دیئے گئے عدد کو الٹا کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: سٹرنگ ہیرا پھیری کا استعمال: ہم انٹیجر کو تار میں تبدیل کرسکتے ہیں ، تار کو الٹا کرسکتے ہیں ، اور پھر اسے واپس کسی عدد میں تبدیل کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف ریورس_ٹیجر (نمبر): سٹرنگ = ایس ٹی آر (اے بی ایس (نمبر)) الٹ_سٹرنگ = سٹرنگ [:: -1] الٹ_نمبر = انٹ (الٹ_سٹرنگ) واپسی الٹ_نمبر اگر نمبر> = 0 اور -ریورسڈ_نبرٹھیس فنکشن ایک عددی نمبر لیتا ہے۔جیسا کہ ان پٹ اور الٹ انٹیجر کو لوٹاتا ہے۔یہ سب سے پہلے انٹیجر کی مطلق قیمت کو ایس ٹی آر () کے طریقہ کار کا استعمال کرتے ہوئے اسٹرنگ میں تبدیل کرتا ہے۔اس کے بعد ، یہ تار کو پلٹانے کے لئے سٹرنگ سلائسنگ کا استعمال کرتا ہے۔آخر میں ، یہ الٹ سٹرنگ کو انٹ () کے طریقہ کار کا استعمال کرتے ہوئے کسی عدد میں تبدیل کرتا ہے اور اصل علامت کے ساتھ نتیجہ لوٹاتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھن نمبر = 12345result = revers_integer (نمبر) پرنٹ (\"ریورس آف\"، نمبر ، \"IS:\" ، نتیجہ) یہ پروگرام پہلے 12345 کی قیمت کے ساتھ نمبر نامی ایک انٹیجر کی ابتدا کرتا ہے۔ پھر ، یہ ان پٹ کے طور پر نمبر کے ساتھ ریورس_ٹیجر () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے الٹ انٹیجر کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 12345 کا ریورس یہ ہے: 54321 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ریورس_ٹیجر () فنکشن صحیح طور پر دیئے گئے انٹیجر کو تبدیل کرتا ہے۔انٹیجر کا آخری ہندسہ اور اسے الٹ انٹیجر میں شامل کرنا۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف ریورس_ٹیجر (نمبر): الٹ_نمبر = 0 سائن = 1 اگر نمبر> = 0 اور -1 نمبر = ABS (نمبر) جبکہ نمبر> 0: ہندسہ = نمبر ٪ 10 الٹ_نمبر = الٹ_نمبر * 10 + ہندسے نمبر //= 10 ریٹرن سائن * الٹ_نمبر یہ فنکشن ان پٹ کے طور پر ایک عدد نمبر لیتا ہے اور الٹ انٹیجر کو لوٹاتا ہے۔یہ سب سے پہلے ایک متغیر کو الٹ_ نمبر 0 پر شروع کرتا ہے اور ایک متغیر جس کو سائن کہتے ہیں 1 پر اگر نمبر مثبت ہے اور -1 اگر نمبر منفی ہے تو -1۔اس کے بعد ، یہ ABS () کے طریقہ کار کا استعمال کرتے ہوئے نمبر کی مطلق قیمت لیتا ہے۔ماڈیولو کا استعمال کرتے ہوئے نمبر کے آخری ہندسے کو نکالنے اور انٹیجر ڈویژن کا استعمال کرتے ہوئے اسے الٹ نمبر میں شامل کرنے کے لئے تھوڑی دیر کا استعمال ہوتا ہے۔آخر میں ، یہ اصل علامت کے ساتھ الٹ نمبر کو لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھن نمبر = 12345Result = revers_Integer (نمبر) پرنٹ (\"ریورس\" ، نمبر ، \"ہے:\" ، نتیجہ) یہ پروگرام پہلے شروع ہوتا ہےایک انٹیجر جس کو 12345 کی قیمت کے ساتھ نمبر کہا جاتا ہے۔ پھر ، یہ ان پٹ کے طور پر نمبر کے ساتھ ریورس_ٹیجر () فنکشن کو کال کرتا ہے اور نتیجہ کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے الٹ انٹیجر کو پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 12345 کا ریورس یہ ہے: 54321 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ریورس_ٹیجر () فنکشن نے دیئے گئے انٹیجر کو صحیح طور پر تبدیل کردیا ہے۔پہلا نفاذ سٹرنگ ہیرا پھیری کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ انٹیجر ڈویژن اور ماڈیولو ۔1 میڈیم 2 ڈی اے ٹی اے جی 3 جےواٹپوائنٹ 4 پرو گرامگرام 5 ڈبلیو 3 آر سورس کا استعمال کرتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام بنائیں کہ آیا کوئی دیئے گئے نمبر آرمسٹرونگ نمبر ہے۔",
        "Answer": "ایک آرمسٹرونگ نمبر ایک ایسی تعداد ہے جو ہندسوں کی تعداد کی طاقت کے لئے اٹھائے جانے والے اپنے ہندسوں کی رقم کے برابر ہے۔مثال کے طور پر ، 153 ایک آرمسٹرونگ نمبر ہے کیونکہ 1^3 + 5^3 + 3^3 = 153. یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد ازگر میں آرمسٹرونگ نمبر ہے یا نہیں ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال اور اگر بیان: ہم نمبر کے ہر ہندسے کو نکالنے ، اسے ہندسوں کی تعداد کی طاقت میں بڑھانے اور رقم میں شامل کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں۔اس کے بعد ، ہم یہ جانچنے کے لئے اصل نمبر کے ساتھ رقم کا موازنہ کرسکتے ہیں کہ آیا یہ آرمسٹرونگ نمبر ہے یا نہیں۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف آئی ایس_آرم اسٹرانگ_نمبر (نمبر): نمبر_سٹری میں ہندسے کے لئے نمبر_اسٹر = ایس ٹی آر (نمبر) نمبر_ڈیجٹس = لین (نمبر_سٹر) رقم = 0ان پٹ کے طور پر نمبر اور لوٹتا ہے اگر یہ آرمسٹرونگ نمبر ہے اور دوسری صورت میں غلط ہے۔یہ پہلے نمبر کو تار میں تبدیل کرتا ہے اور لین () طریقہ کار کا استعمال کرتے ہوئے ہندسوں کی تعداد کا حساب لگاتا ہے۔اس کے بعد ، یہ نمبر کے ہر ہندسے کو نکالنے ، اسے ایک عدد میں تبدیل کرنے ، اسے ہندسوں کی تعداد کی طاقت میں بڑھانے اور رقم میں شامل کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔آخر میں ، یہ اصل نمبر کے ساتھ رقم کا موازنہ کرتا ہے کہ آیا یہ آرمسٹرونگ نمبر ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھن نمبر = 153result = is_armstrong_number (نمبر) پرنٹ (نمبر ، \"آرمسٹرونگ نمبر ہے؟\" ، نتیجہ ہے؟ \"، نتیجہ ہے؟\" ، نتیجہ ہے؟ \") یہ پروگرام سب سے پہلے 153 کی قیمت کے ساتھ نمبر نامی ایک انٹیجر کی ابتدا کرتا ہے۔ پھر ، یہ is_armstrong_number () فنکشن کو نمبر کے ساتھ فون کرتا ہے اور ان پٹ کے طور پر اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا پرنٹ () فنکشن کا استعمال کرتے ہوئے نمبر آرمسٹرونگ نمبر ہے۔اس معاملے میں ، پیداوار ہوگی: 153 ایک آرمسٹرونگ نمبر ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ IS_Armstrong_number () فنکشن صحیح طریقے سے اس بات کی نشاندہی کرتا ہے کہ 153 ایک آرمسٹرونگ نمبر ہے۔ استعمال کرتے ہوئے فہرست کی تفہیم: ہم نمبر کے ہر ہندسے کو نکالنے کے لئے ایک فہرست کی تفہیم کا استعمال کرسکتے ہیں ، اسے ہندسوں کی تعداد کی طاقت میں بڑھا سکتے ہیں ، اور اسے شامل کرسکتے ہیں۔ایک رقماس کے بعد ، ہم یہ جانچنے کے لئے اصل نمبر کے ساتھ رقم کا موازنہ کرسکتے ہیں کہ آیا یہ آرمسٹرونگ نمبر ہے یا نہیں۔یہاں ایک مثال عمل ہے: پائیٹھنڈف IS_Armstrong_number (نمبر): num_str = str (نمبر) num_digits = len (num_str) جمع = رقم ([انٹ (ہندسہ) ** num_str میں ہندسے کے لئے num_digits) واپسی کا خلاان پٹ کے طور پر نمبر اور لوٹتا ہے اگر یہ آرمسٹرونگ نمبر ہے اور دوسری صورت میں غلط ہے۔یہ پہلے نمبر کو تار میں تبدیل کرتا ہے اور لین () طریقہ کار کا استعمال کرتے ہوئے ہندسوں کی تعداد کا حساب لگاتا ہے۔اس کے بعد ، یہ نمبر کے ہر ہندسے کو نکالنے ، اسے کسی عدد میں تبدیل کرنے ، اسے ہندسوں کی تعداد کی طاقت میں بڑھانے اور اسے رقم میں شامل کرنے کے لئے ایک فہرست کی تفہیم کا استعمال کرتا ہے۔آخر میں ، یہ اصل نمبر کے ساتھ رقم کا موازنہ کرتا ہے کہ آیا یہ آرمسٹرونگ نمبر ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھن نمبر = 153result = is_armstrong_number (نمبر) پرنٹ (نمبر ، \"آرمسٹرونگ نمبر ہے؟\" ، نتیجہ ہے؟ \"، نتیجہ ہے؟\" ، نتیجہ ہے؟ \") یہ پروگرام سب سے پہلے 153 کی قیمت کے ساتھ نمبر نامی ایک انٹیجر کی ابتدا کرتا ہے۔ پھر ، یہ is_armstrong_number () فنکشن کو نمبر کے ساتھ فون کرتا ہے اور ان پٹ کے طور پر اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا پرنٹ () فنکشن کا استعمال کرتے ہوئے نمبر آرمسٹرونگ نمبر ہے۔اس معاملے میں ، پیداوار ہوگی: 153 ایک آرمسٹرونگ نمبر ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ IS_Armstrong_number () فنکشن صحیح طور پر اس بات کی نشاندہی کرتا ہے کہ 153 ایک آرمسٹرونگ نمبر ہے۔ دونوں عمل درآمد درست ہیں اور یہ چیک کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا کوئی دی گئی تعداد ازگر میں آرمسٹرونگ نمبر ہے یا نہیں۔پہلا نفاذ ایک لوپ اور اگر بیان استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد ایک فہرست کی تفہیم کا استعمال کرتا ہے۔"
    },
    {
        "Question": "ترجیحی قطار کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کے انکیو اور ڈی کیو طریقوں کو نافذ کریں۔",
        "Answer": "ترجیحی قطار ایک اعداد و شمار کا ڈھانچہ ہے جہاں ہر عنصر کی ایک خاص ترجیح ہوتی ہے اور اعلی ترجیح کے حامل عنصر کو سب سے پہلے ختم کیا جاتا ہے۔ازگر میں ، ترجیحی قطار کو نافذ کرنے کے بہت سارے طریقے ہیں ، بشمول قطار ماڈیول ، ہیپ کیو ماڈیول ، یا بائنری ہیپ کا استعمال کرتے ہوئے کسٹم پر عمل درآمد۔یہاں ، ہم ایک فہرست اور ہیپ کیو ماڈیول کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کریں گے ، اور اس کے انکیو () اور ڈی کیو () طریقوں کو نافذ کریں گے۔، ترجیح): ہیپ کیو۔ ہیپش (سیلف ایلیمنٹس ، (ترجیحی ، آئٹم)) ڈیف ڈی کیوئو (خود): ریٹرن ہیپ کیو۔ ہیپپپ (سیلف ایلیمنٹس) [1] یہ عمل درآمد ترجیحی قطار کی نمائندگی کرنے والی ترجیحی قطار کی نمائندگی کرنے والے ایک طبقے کی وضاحت کرتا ہے۔اس میں ایک کنسٹرکٹر ہے جو عناصر کے نام سے ایک خالی فہرست کی ابتدا کرتا ہے۔اس میں انکیو () نامی ایک طریقہ بھی ہے جو کسی شے اور ان پٹ کی حیثیت سے ترجیح لیتا ہے اور ہیپ کیو ماڈیول سے ہیپش () کے طریقہ کار کا استعمال کرتے ہوئے قطار میں شامل کرتا ہے۔ہیپش () طریقہ یہ یقینی بناتا ہے کہ عناصر کو ان کی ترجیح کی بنیاد پر ترتیب دیا جائے۔آخر میں ، اس کے پاس ڈی کیوئ () نامی ایک طریقہ ہے جو ہیپ کیو ماڈیول سے ہیپپپ () طریقہ کا استعمال کرتے ہوئے اعلی ترجیح کے ساتھ آئٹم کو ہٹاتا ہے اور لوٹاتا ہے۔ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونق = ترجیحی کیوئ () Q.enqueue (Q.enqueue (Q.enqueue ()'ٹاسک 1' ، 3) Q.enqueue ('task2' ، 1) Q.enqueue ('task3' ، 2) پرنٹ (Q.dequeue ()) # ٹاسک 2 پرنٹ (Q.dequeue ()) # ٹاسک 3 پرنٹ (Q.dequeue (Q.dequeue ()) # ٹاسک 1 یہ پروگرام سب سے پہلے ایک ترجیحی چیز کو شروع کرتا ہے جسے Q کہتے ہیں۔اس کے بعد ، یہ مختلف ترجیحات کے ساتھ enqueue () کے طریقہ کار کا استعمال کرتے ہوئے قطار میں تین کاموں کا اضافہ کرتا ہے۔آخر میں ، یہ ڈیکیو () کے طریقہ کار کا استعمال کرتے ہوئے اعلی ترجیح کے ساتھ کاموں کو ہٹاتا ہے اور پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ٹاسک 2 ٹاسک 3 ٹاسک 1 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ترجیحی کیو کلاس ایک ترجیحی قطار اور اس کے enqueue () اور dequeue () طریقوں کو صحیح طور پر نافذ کرتی ہے۔ نوٹ کریں کہ اس عمل کو ہیپ کیو کے ماڈیول کا استعمال کیا جاتا ہے ، جو پائیٹون میں ایک بلٹ ان ماڈیول ہے۔اور الگ سے انسٹال کرنے کی ضرورت نہیں ہے۔ازگر میں ترجیحی قطار کو عملی جامہ پہنانے کے اور بھی طریقے ہیں ، جیسے بائنری ہیپ کا استعمال کرتے ہوئے قطار ماڈیول یا کسٹم نفاذ کا استعمال کریں۔"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کے چوراہے کو تلاش کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں دو ترتیب شدہ صفوں کا چوراہا تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال: ہم دونوں صفوں میں ہر عنصر پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں اور ان کا موازنہ کرسکتے ہیں۔اگر عناصر برابر ہیں تو ، ہم انہیں ایک نئی فہرست میں شامل کرتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پیتھنڈف چوراہا (ARR1 ، ARR2): i ، j = 0 ، 0 نتیجہ = [] جبکہ میں <لین (arr1) اور j <لین (arr2): اگر arr1 [i] == arr2 [j]: نتیجہ۔ اپینڈ (arr1 [i]) i += 1 j += 1 Elif arr1 [i] <arr2 [j]: i += 1 اور: j += 1 واپسی کے نتیجے میں اس فنکشن میں دو ترتیب شدہ صفیں آرن اور آر 2 کے طور پر لی جاتی ہیں۔ان پٹ اور ان کے چوراہے کو ایک نئی فہرست کے طور پر لوٹاتا ہے۔یہ دو پوائنٹرز I اور J کو دونوں صفوں کے آغاز اور ایک خالی فہرست کے آغاز کے لئے شروع کرتا ہے جس کو نتیجہ کہا جاتا ہے۔اس کے بعد ، یہ پوائنٹرز کی موجودہ پوزیشنوں پر عناصر کا موازنہ کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔اگر عناصر برابر ہیں تو ، یہ ان کو نتائج کی فہرست میں شامل کرتا ہے اور دونوں پوائنٹرز میں اضافہ کرتا ہے۔اگر ARR1 میں عنصر چھوٹا ہے تو ، اس میں اضافہ ہوا ہے۔اگر ARR2 میں عنصر چھوٹا ہے تو ، اس میں اضافہ ہوتا ہے۔آخر میں ، یہ نتیجہ کی فہرست لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونر 1 = [1 ، 3 ، 4 ، 5 ، 7] ARR2 = [2 ، 3 ، 5 ، 6] نتیجہ = چوراہا (ARR1 ، ARR2)پرنٹ (\"چوراہا\" ، arr1 ، \"اور\" ، arr2 ، \"ہے:\" ، نتیجہ) اس پروگرام میں پہلے دو ترتیب شدہ صفوں کا آغاز کیا گیا ہے جسے ARR1 اور ARR2 کہا جاتا ہے۔اس کے بعد ، یہ ARR1 اور ARR2 کے ساتھ چوراہا () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے صفوں کے چوراہے پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [1 ، 3 ، 4 ، 5 ، 7] اور [2 ، 3 ، 5 ، 6] کا چوراہا یہ ہے: [3 ، 5] اس آؤٹ پٹ سے پتہ چلتا ہے کہ چوراہا () فنکشن صحیح طور پر پائے گا۔دو ترتیب شدہ صفوں کا چوراہا۔ سیٹ () کے طریقہ کار کا استعمال کرتے ہوئے: ہم دونوں صفوں کو سیٹوں میں تبدیل کرسکتے ہیں اور ان کے مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پیتھنڈف چوراہا (ARR1 ، ARR2): سیٹ 1 = سیٹ (ARR1) سیٹ 2 = سیٹ (ARR2) ریٹرن لسٹ (سیٹ 1.ٹریسیکشن (سیٹ 2)) یہ فنکشن ان پٹ کے طور پر دو ترتیب شدہ اریوں اور آر 2 کو لوٹاتا ہے اور ان کے چوراہے کو لوٹاتا ہے۔ایک نئی فہرست کے طور پر.یہ پہلے سیٹ () کے طریقہ کار کا استعمال کرتے ہوئے دونوں صفوں کو سیٹ میں تبدیل کرتا ہے۔اس کے بعد ، یہ اپنے مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرتا ہے۔آخر میں ، یہ نتیجہ کو دوبارہ فہرست میں تبدیل کرتا ہے اور اسے واپس کرتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونر 1 = [1 ، 3 ، 4 ، 5 ، 7] ARR2 = [2 ، 3 ، 5 ، 6] نتیجہ =چوراہا (ARR1 ، ARR2) پرنٹ (\"چوراہا\" ، ARR1 ، \"اور\" ، ARR2 ، \"ہے:\" ، نتیجہ) اس پروگرام میں پہلے دو ترتیب شدہ صفوں کو شروع کیا گیا ہے جسے ARR1 اور ARR2 کہتے ہیں۔اس کے بعد ، یہ ARR1 اور ARR2 کے ساتھ چوراہا () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے صفوں کے چوراہے پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [1 ، 3 ، 4 ، 5 ، 7] اور [2 ، 3 ، 5 ، 6] کا چوراہا یہ ہے: [3 ، 5] اس آؤٹ پٹ سے پتہ چلتا ہے کہ چوراہا () فنکشن صحیح طور پر پائے گا۔دو ترتیب شدہ صفوں کا چوراہا۔ دونوں عمل درآمد درست ہیں اور ازگر میں دو ترتیب شدہ صفوں کے چوراہے کو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔پہلا نفاذ ایک لوپ کا استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد سیٹ () کا طریقہ استعمال کرتا ہے۔"
    },
    {
        "Question": "بائنری نمبر کو اس کے اعشاریہ نمائندگی میں تبدیل کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "بائنری نمبر کو ازگر میں اس کے اعشاریہ نمائندگی میں تبدیل کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: انٹ () فنکشن کا استعمال کرتے ہوئے: ہم بائنری تار کو اس کے اعشاریہ نمائندگی میں تبدیل کرنے کے لئے بلٹ ان انٹ () فنکشن کا استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف بائنری_ٹو_ڈیسیمل (بائنری): اعشاریہ = انٹ (بائنری ، 2) واپسی اعشاریہ ایک بائنری سٹرنگ بائنری کو ان پٹ کے طور پر لیتا ہے اور اس کے اعشاریہ نمائندگی کو ایک عدد کے طور پر واپس کرتا ہے۔بائنری تار کو اپنی اعشاریہ نمائندگی میں تبدیل کرنے کے لئے 2 کی بنیاد کے ساتھ INT () فنکشن کا استعمال کرتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگربری = '1010'Result = بائنری_ٹیٹ_ڈیسیمل (بائنری) پرنٹ (\"اعشاریہ نمائندگی\"، بائنری ، \"ہے:\" ، نتیجہ) یہ پروگرام سب سے پہلے بائنری نامی بائنری تار کو '1010' کی قیمت کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ بائنری_ٹو_ڈیسیمل () کو بائنری کے ساتھ ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بائنری سٹرنگ کی اعشاریہ نمائندگی پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 1010 کی اعشاریہ نمائندگی یہ ہے: 10 اس آؤٹ پٹ سے پتہ چلتا ہے کہ بائنری_ٹو_ڈیسیمل () فنکشن بائنری تار کو صحیح طور پر اپنی اعشاریہ نمائندگی میں تبدیل کرتا ہے۔بائنری نمبر اور اس کی پوزیشن کی بنیاد پر اس کی اعشاریہ قدر کا حساب لگائیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف بائنری_ٹو_ڈیسیمل (بائنری): اعشاریہ = 0 پاور = لین (بائنری) - 1 بائنری میں ہندسے کے لئے: اعشاریہ += انٹ (ہندسہ) * 2 ** پاور پاور - = 1 واپسی اعشاریہ بائنری تار لیتا ہےبائنری ان پٹ کے طور پر اور اس کی اعشاریہ نمائندگی کو بطور عددی نمائندگی لوٹاتا ہے۔یہ ایک متغیر کا آغاز کرتا ہے جسے اعشاریہ 0 پر اعشاریہ کہتے ہیں اور بائنری نمبر میں 2 کی اعلی طاقت کے نام سے ایک متغیر کہا جاتا ہے۔اس کے بعد ، یہ بائنری نمبر میں ہر ہندسے پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔ہر ہندسے کے ل it ، یہ فارمولا ہندسے * 2 ** پاور کا استعمال کرتے ہوئے اپنی پوزیشن کی بنیاد پر اپنی اعشاریہ قدر کا حساب لگاتا ہے اور اسے اعشاریہ متغیر میں شامل کرتا ہے۔آخر میں ، یہ بجلی کے متغیر کو کم کرتا ہے اور اعشاریہ متغیر کو واپس کرتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر = '1010'Result = بائنری_ٹو_ڈیسیمل (بائنری) پرنٹ (\"اعشاریہ نمائندگی\" ، بائنری ، \"ہے:\" ، نتیجہ ہے۔) یہ پروگرام سب سے پہلے بائنری نامی بائنری تار کو '1010' کی قیمت کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ بائنری_ٹو_ڈیسیمل () کو بائنری کے ساتھ ان پٹ کے طور پر فون کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بائنری سٹرنگ کی اعشاریہ نمائندگی پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 1010 کی اعشاریہ نمائندگی یہ ہے: 10 اس آؤٹ پٹ سے پتہ چلتا ہے کہ بائنری_ٹو_ڈیسیمل () فنکشن بائنری تار کو صحیح طور پر اپنی اعشاریہ نمائندگی میں تبدیل کرتا ہے۔ازگر میں نمائندگی۔پہلا عمل درآمد INT () فنکشن کا استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد ایک لوپ."
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار ایک درست پیلنڈرووم ہے ، کیس کی حساسیت پر غور کریں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک درست پیلنڈرووم ہے ، کیس کی حساسیت پر غور کرتے ہوئے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال اور اگر بیان: ہم تار میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں اور اس کا موازنہ تار کے آخر سے اسی کردار سے کرسکتے ہیں۔اگر تمام حروف مماثل ہیں تو ، تار ایک درست پیلنڈرووم ہے۔یہاں ایک مثال کے نفاذ ہے: پائیٹھنڈف is_valid_palindrome (سٹرنگ): سٹرنگ = سٹرنگ.لور () بائیں ، دائیں = 0 ، لین (تار) - 1 جبکہ بائیں <دائیں: اگر تار نہیں ہے [بائیں] .سالمم (): بائیں += 1الیف نہیں سٹرنگ [دائیں] .isalnum (): دائیں -= 1 الیف سٹرنگ [بائیں]! = سٹرنگ [دائیں]: غلط واپس لوٹیں: بائیں += 1 دائیں -= 1 ریٹرن ٹروتیس فنکشن ان پٹ کے طور پر تار تار کرتا ہے اور واپسی کرتا ہےسچ ہے اگر یہ ایک درست پیلنڈرووم اور غلط ہے۔یہ پہلے کم () طریقہ کار کا استعمال کرتے ہوئے تار کو چھوٹے میں تبدیل کرتا ہے۔اس کے بعد ، یہ بالترتیب دو پوائنٹرز کو بائیں اور دائیں کے آغاز اور اختتام تک بالترتیب شروع کرتا ہے۔یہ پوائنٹرز کی موجودہ پوزیشنوں پر کرداروں کا موازنہ کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔اگر یا تو کردار حرفی نہیں ہے تو ، اس سے متعلقہ پوائنٹر میں اضافہ یا کمی واقع ہوتی ہے۔اگر دونوں حرف حرفیومیرک ہیں اور مماثل نہیں ہیں تو ، یہ غلط لوٹتا ہے۔اگر دونوں حرف حرفی اور میچ ہیں تو ، اس میں اضافہ اور دائیں کمی۔آخر میں ، یہ سچ واپس آجاتا ہے اگر لوپ جھوٹی کو واپس کیے بغیر مکمل ہوجاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنسٹرنگ = \"ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما\" نتیجہ = is_valid_palindrome (سٹرنگ) پرنٹ (سٹرنگ ، \"ایک ہےدرست پیلنڈرووم؟ \"، نتیجہ) یہ پروگرام سب سے پہلے\" ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما \"کی قیمت کے ساتھ تار کا آغاز کرتا ہے۔اس کے بعد ، یہ is_valid_palindrome () فنکشن کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا پرنٹ () فنکشن کا استعمال کرتے ہوئے سٹرنگ ایک درست پیلنڈرووم ہے۔اس معاملے میں ، پیداوار ہوگی: ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما ایک درست پیلنڈرووم ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_valid_palindrome () فنکشن صحیح طور پر اس بات کی نشاندہی کرتا ہے کہ دیئے گئے تار ایک درست palindrome ہے۔ سٹرنگ سلائسنگ کا استعمال کرتے ہوئے: ہم تار کو الٹا کرنے کے لئے سٹرنگ سلائسنگ کا استعمال کرسکتے ہیں اور اسے اصل تار کے ساتھ موازنہ کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائیٹھنڈف is_valid_palindrome (سٹرنگ): string = string.lower () سٹرنگ = '' .جوئن (فلٹر (str.isalnum ، string)) ریٹرن سٹرنگ == اسٹرنگ [::-1] یہ فنکشن ایک تار لیتا ہےان پٹ کے طور پر تار اور لوٹتا ہے اگر یہ ایک درست پیلنڈرووم ہے اور غلط ہے تو۔یہ پہلے کم () طریقہ کار کا استعمال کرتے ہوئے تار کو چھوٹے میں تبدیل کرتا ہے۔اس کے بعد ، یہ فلٹر () کے طریقہ کار اور isalnum () فنکشن کا استعمال کرتے ہوئے تمام غیر الفانومرک کرداروں کو ہٹا دیتا ہے۔آخر میں ، اس کے نتیجے میں اسٹرنگ کا موازنہ سٹرنگ سلائسنگ کا استعمال کرتے ہوئے اس کے الٹ سے ہوتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پیتھنسٹرنگ = \"ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما\" نتیجہ = is_valid_palindrome (سٹرنگ) پرنٹ (سٹرنگ ، \"ہےایک درست پیلنڈرووم؟ \"، نتیجہ) یہ پروگرام سب سے پہلے\" ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما \"کی قیمت کے ساتھ تار کا آغاز کرتا ہے۔اس کے بعد ، یہ is_valid_palindrome () فنکشن کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا پرنٹ () فنکشن کا استعمال کرتے ہوئے سٹرنگ ایک درست پیلنڈرووم ہے۔اس معاملے میں ، پیداوار ہوگی: ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما ایک درست پیلنڈرووم ہے؟ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_valid_palindrome () فنکشن صحیح طریقے سے اس بات کی نشاندہی کرتا ہے کہ دیئے گئے تار ایک درست palindrome ہے۔ دونوں عمل درآمد درست ہیں اور یہ چیک کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا دیئے گئے تار میں ایک درست palindrome ہے۔پہلا نفاذ ایک لوپ اور اگر بیان استعمال کرتا ہے ، جبکہ دوسرا نفاذ سٹرنگ سلائسنگ کا استعمال کرتا ہے۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کی حقیقت میں ہندسوں کے جوڑے کا حساب لگانے کے لئے ایک پروگرام کو نافذ کریں۔",
        "Answer": "کسی دیئے گئے نمبر کے حقیقت میں ہندسوں کے جوڑے کا حساب لگانے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: فیکٹوریئل ہندسوں کو ذخیرہ کرنے کے لئے ایک ویکٹر بنائیں اور اس کو 1. ون کے ساتھ 1 سے 1 سے N میں ویکٹر تک شروع کریں۔ہم اس مقصد کے لئے اسکول کی ریاضی کا استعمال کرتے ہیں۔ لہذا ویکٹر میں موجود تمام عناصر کو واپس کریں اور اس کا خلاصہ واپس کریں۔ ازگر میں ایک مثال کے طور پر عمل درآمد: پائیتھنڈف فیکٹوریل_ڈیجٹ_سم (این): # ویکٹر کو 1 ہندسوں کے ساتھ شروع کریں = [1] # 1 سے 1 سے ضرب نمبرN رینج (2 ، n + 1) کے لئے ویکٹر کو: J J کے لئے رینج (لین (ہندسے)): پروڈکٹ = ہندسے [j] * i + لے کر ہندسے [j] = پروڈکٹ ٪ 10 کیری =پروڈکٹ // 10 جبکہ کیری> 0: ہندسے۔ اپینڈ (کیری ٪ 10) لے کر // = 10 # رقم ویکٹر میں موجود تمام عناصر ویکٹر میں موجود ہیں۔n کے حقیقت میں ہندسے۔یہ پہلے ایک ویکٹر کی ابتدا کرتا ہے جس کا نام ہندسوں کے نام سے 1 کی قیمت ہے۔اس کے بعد ، یہ ویکٹر میں 1 سے N تک تعداد میں ضرب لگانے کے ل a ایک لوپ کا استعمال کرتا ہے۔ہر ایک نمبر کے ل it ، یہ اسے ویکٹر میں ہر ہندسے کے ساتھ بڑھاتا ہے اور پچھلے ضرب سے کیری کو شامل کرتا ہے۔اس کے بعد یہ ویکٹر میں ہندسے کو اپ ڈیٹ کرتا ہے اور باقی قیمت پر اٹھاتا ہے۔آخر میں ، اس میں ویکٹر میں کسی بھی باقی کیری ہندسے شامل کیے جاتے ہیں۔لوپ کے بعد ، یہ ویکٹر میں موجود تمام عناصر کا خلاصہ کرتا ہے اور اس کا نتیجہ لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: ازگر = 5result = فیکٹوریل_ڈیجٹ_سم (این) پرنٹ (\"\" حقیقت پسندی میں ہندسوں کا مجموعہ \"، این ،\" ہے۔: \"، نتیجہ) یہ پروگرام سب سے پہلے N نامی ایک انٹیجر کو 5 کی قیمت کے ساتھ شروع کرتا ہے۔ پھر ، اس کو این کے ساتھ فیکٹوریل_ڈیجٹ_سم () فنکشن کہتے ہیں کیونکہ ان پٹ کے طور پر اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کیا جاتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے N کے حقیقت میں ہندسوں کا مجموعہ پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 5 کے حقیقت میں ہندسوں کا مجموعہ یہ ہے: 3 اس آؤٹ پٹ سے پتہ چلتا ہے کہ فیکٹوریل_ڈیجٹ_سم () فنکشن صحیح طور پر ہندسوں کی رقم کا حساب کتاب کرتا ہے۔اس میں ضرب کو انجام دینے کے لئے فیکٹوریئل اور اسکول ریاضی کے ہندسوں کو ذخیرہ کرنے کے لئے ایک ویکٹر کا استعمال کیا گیا ہے۔اس نقطہ نظر کی وقت کی پیچیدگی O (n^2) ہے کیونکہ اس میں متعدد لوپ کا استعمال ہوتا ہے ، اور معاون جگہ کی پیچیدگی O (n) ہے کیونکہ یہ ویکٹر کے لئے جگہ استعمال کررہی ہے۔"
    },
    {
        "Question": "ایک سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور اس کے enqueue اور dequeue طریقوں کو نافذ کریں۔",
        "Answer": "ازگر میں سرکلر قطار کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: مندرجہ ذیل صفات کے ساتھ سرکلر کیو نامی ایک کلاس بنائیں: قطار: قطار میں عناصر کو ذخیرہ کرنے کے لئے ایک فہرست: ایک عدد جو کوئٹیل میں پہلے عنصر کی اشاریہ کی نمائندگی کرنے والا ایک عدد:کوئو میکسائز میں اگلی دستیاب پوزیشن کے اشاریہ کی نمائندگی کرنے والا ایک عدد: قطار میں عنصر کو شامل کرنے کے لئے قطار کے زیادہ سے زیادہ سائز کی نمائندگی کرنے والا ایک عدد جس میں قطار میں کسی عنصر کو شامل کرنے کے لئے انکیو کے طریقہ کار کی نمائندگی کرتا ہے: چیک کریں کہ قطار کے سائز کا موازنہ کرکے قطار کے سائز کا موازنہ کریں -1 اگر قطار بھری ہوئی ہے تو ، میسج کے لئے کسی غلطی کو واپس کریں ، قطار میں دم کی پوزیشن میں عنصر کو شامل کریں اور قطار سے کسی عنصر کو ہٹانے کے لئے 1 کو ڈی کیوئ کے طریقہ کار کے ذریعہ انکریمنٹ ٹیل کی پوزیشن میں شامل کریں: چیک کریں کہ قطار کے سائز کا موازنہ کرکے قطار خالی ہے یا نہیںقطار میں قطار خالی ہے ، اگر ایک غلطی میسج کے لئے ایک غلطی کو واپس کریں ، قطار میں سر کی پوزیشن پر عنصر کو ہٹا دیں اور قطار کے موجودہ سائز کو واپس کرنے کے لئے سائز کے طریقہ کار کو 1 میں شامل کریںقطار کے سرکلر نوعیت کو سنبھالنے کے لئے زیادہ سے زیادہ IS_EMPTY طریقہ کی جانچ پڑتال کرنے کے لئے کہ قطار خالی ہے یا نہیں: چیک کریں کہ آیا قطار مکمل ہے اس کی جانچ پڑتال کرنے کے لئے آئی ایس_فل طریقہ کے برابر ہے یا نہیں: چیک کریں کہ آیا قطار کا سائز میکسسائز ہییر کے برابر ہے یا نہیںازگر میں مثال کے طور پر عمل درآمد: پائیتھنکلاس سرکلر کیوئو: ڈیف __ __init __ (خود ، زیادہ سے زیادہ).size () == self.maxsize - 1: واپس \"قطار مکمل!\"self.queue [self.tail] = ڈیٹا self.tail = (self.tail + 1) ٪ خود۔ میکسسائز واپس حقیقی Def dequeue (خود): اگر self.size () == 0: واپس \"قطار خالی!\"ڈیٹا = سیلف.کوئو [سیلف ہیڈ] سیلف۔ ہیڈ = (سیلف۔ ہیڈ + 1) ٪ خود۔ میکسائز ریٹرن ڈیٹا ڈیف سائز (خود): ریٹرن (سیلف۔ ٹیل - خود - ہیڈ) ٪ خود۔خود): خود کو واپس کریں۔اس کے بعد قطار میں موجود عناصر کی حیثیت کو شامل کرنے ، ہٹانے اور جانچنے کے ل is اس کے بعد عناصر کی حیثیت کو شامل کرنے ، ہٹانے اور جانچنے کے ل is انکیو ، ڈیکوئ ، سائز ، اور آئی ایس_فل طریقوں کو نافذ کرتا ہے۔ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونک کیو = سرکلر کیوئ (5) سی کیو۔ انکیو (1) cq.enqueue (2) cq.enqueue (3) cq.enqueue (4) cq.enqueue (5) پرنٹ (cq.enqueue (6)) # آؤٹ پٹ: قطار مکمل! پرنٹ (cq.dequeue ()) #آؤٹ پٹ: 1 پرنٹ (cq.dequeue ()) # آؤٹ پٹ: 2 پرنٹ (cq.size ()) # آؤٹ پٹ: 3 پرنٹ (cq.is_empty ()) # آؤٹ پٹ: غلط پرنٹ (cq.is_full ()) # آؤٹ پٹ: فالتھیس پروگرام پہلے تخلیق کرتا ہےزیادہ سے زیادہ سائز 5 کے ساتھ سرکلر کیو کلاس کی ایک مثال 5 کے ساتھ زیادہ سے زیادہ سائز کے ساتھ ، یہ enqueue طریقہ کا استعمال کرتے ہوئے قطار میں 5 عناصر کا اضافہ کرتا ہے اور 6 ویں عنصر کو شامل کرنے کی کوشش کرتا ہے ، جو غلطی کا پیغام لوٹاتا ہے۔اس کے بعد یہ ڈیکو کے طریقہ کار کا استعمال کرتے ہوئے قطار سے پہلے دو عناصر کو ہٹا دیتا ہے اور سائز کے طریقہ کار کا استعمال کرتے ہوئے قطار کے موجودہ سائز کو پرنٹ کرتا ہے۔آخر میں ، یہ جانچ پڑتال کرتا ہے کہ اگر بالا بالترتیب ISEMPTY اور IS_FULL طریقوں کا استعمال کرتے ہوئے قطار خالی اور بھری ہوئی ہے۔ اس آؤٹ پٹ سے پتہ چلتا ہے کہ سرکلر کیوئو کلاس صحیح طور پر ازگر میں سرکلر قطار کے لئے انکیو اور ڈی کیو طریقوں کو صحیح طور پر نافذ کرتی ہے۔"
    },
    {
        "Question": "دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال: ہم فہرست میں موجود ہر عنصر پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں اور اب تک نظر آنے والے زیادہ سے زیادہ اور کم سے کم عناصر سے اس کا موازنہ کرسکتے ہیں۔زیادہ سے زیادہ فرق زیادہ سے زیادہ اور کم سے کم عناصر کے درمیان فرق ہے۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف میکس_ ڈفینس (ایل ایس ٹی): اگر لین (ایل ایس ٹی) <2: کوئی بھی نہیں لوٹ کوئی نہیں۔: میکس_یلیم = الیم ریٹرن میکس_یلیم - MIN_ELEMTHIS فنکشن ان پٹ کے طور پر ایک فہرست LST لیتا ہے اور فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق لوٹاتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست کی لمبائی 2 سے کم ہے اور اگر یہ ہے تو کوئی بھی نہیں لوٹاتا ہے۔اس کے بعد ، یہ فہرست میں پہلے عنصر میں دو متغیر MIN_ELEM اور MAX_ELEM کی ابتدا کرتا ہے۔یہ فہرست میں ہر عنصر پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور اگر ضروری ہو تو MIN_ELEM اور MAX_ELEM کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ MAX_ELEM اور MIN_ELEM کے درمیان فرق لوٹاتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: Pythonlst = [2 ، 3 ، 8 ، 0 ، 7] نتیجہ = زیادہ سے زیادہ_ڈیفینس (LST) پرنٹ (\"زیادہ سے زیادہ فرق\" ، LST ،\"آئی ایس:\" ، نتیجہ) یہ پروگرام سب سے پہلے ایل ایس ٹی نامی فہرست کو 23807 کی قیمت کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ MAX_DIFFENCE () کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست میں زیادہ سے زیادہ فرق پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [2 ، 3 ، 8 ، 0 ، 7] میں زیادہ سے زیادہ فرق یہ ہے: 8 اس آؤٹ پٹ سے پتہ چلتا ہے کہ میکس_ ڈفینفینس () فنکشن دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق کی صحیح شناخت کرتا ہے۔ زیادہ سے زیادہ استعمال کرتے ہوئے۔() اور کم سے کم () افعال: ہم فہرست میں زیادہ سے زیادہ اور کم سے کم عناصر تلاش کرنے اور ان کے فرق کا حساب لگانے کے لئے بلٹ ان میکس () اور کم سے کم () افعال استعمال کرسکتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائتھونڈف میکس_ ڈفینفرنس (ایل ایس ٹی): اگر لین (ایل ایس ٹی) <2: کوئی بھی نہیں واپسی میکس (ایل ایس ٹی) - منٹ (ایل ایس ٹی) یہ فنکشن ان پٹ کے طور پر ایک فہرست لی ایس ٹی لیتا ہے اور فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق لوٹاتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست کی لمبائی 2 سے کم ہے اور اگر یہ ہے تو کوئی بھی نہیں لوٹاتا ہے۔اس کے بعد ، یہ فہرست میں زیادہ سے زیادہ اور کم سے کم عناصر تلاش کرنے کے لئے زیادہ سے زیادہ () اور کم سے کم () افعال کا استعمال کرتا ہے اور ان کے فرق کا حساب لگاتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonlst = [2 ، 3 ، 8 ، 0 ، 7] نتیجہ = زیادہ سے زیادہ_ڈیفینس (ایل ایس ٹی) پرنٹ (\"زیادہ سے زیادہ فرق\" ، ایل ایس ٹی ، \"ہے:\" ، نتیجہ) یہ پروگرام پہلے ایل ایس ٹی نامی فہرست کو 23807 کی قیمت کے ساتھ شروع کرتا ہے۔اس کے بعد ، یہ LST کے ساتھ MAX_DIFFENCE () کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرست میں زیادہ سے زیادہ فرق پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: [2 ، 3 ، 8 ، 0 ، 7] میں زیادہ سے زیادہ فرق یہ ہے: 8 اس آؤٹ پٹ سے پتہ چلتا ہے کہ میکس_ ڈفیفینس () فنکشن دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق کی صحیح شناخت کرتا ہے۔ دونوں عمل درآمد ہیں۔درست اور ازگر میں دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔پہلا نفاذ ایک لوپ کا استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد زیادہ سے زیادہ () اور منٹ () فنکشن استعمال کرتا ہے۔"
    },
    {
        "Question": "تار میں پہلا غیر بار بار کردار تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں ایک تار میں پہلا غیر بار بار کردار تلاش کرنے کے لئے بہت سارے نقطہ نظر ہیں۔یہاں کچھ مثالیں ہیں: ایک لغت کا استعمال کرتے ہوئے: ہم تار میں ہر کردار کے واقعات کو گننے کے لئے ایک لغت کا استعمال کرسکتے ہیں اور پھر تار کے اوپر دوبارہ تکرار کرسکتے ہیں تاکہ 1 کی گنتی کے ساتھ پہلا کردار تلاش کیا جاسکے۔(سٹرنگ): سٹرنگ میں چار کے لئے گنتی = {}: اگر گنتی میں چار: گنتی [چار] += 1 اور: گنتی [چار] = 1 تار میں چار کے لئے: اگر گنتی [چار] == 1: واپسی چار ریٹرننانتھیس فنکشن ان پٹ کے طور پر ایک تار تار لیتا ہے اور تار میں پہلا غیر بار بار کردار لوٹاتا ہے۔یہ سب سے پہلے تار میں ہر کردار کے واقعات کو گننے کے لئے گنتی نامی ایک لغت کا آغاز کرتا ہے۔یہ تار کے اوپر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور لغت میں ہر کردار کی گنتی کو اپ ڈیٹ کرتا ہے۔اس کے بعد ، یہ ایک اور لوپ کا استعمال کرتے ہوئے ایک بار پھر تار کے اوپر تکرار کرنے کے لئے استعمال کرتا ہے اور پہلے کردار کو 1 کی گنتی کے ساتھ لوٹاتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنسٹرنگ = \"اے اے بی بی سی ڈی ای ایف\" نتیجہ = فرسٹ_نون_ریپیٹڈ_چارٹر (سٹرنگ) پرنٹ (\"پہلا نان-\"، سٹرنگ ،\" میں بار بار کردار ہے: \"، نتیجہ) یہ پروگرام سب سے پہلے\" AABBCDEEFF \"کی قدر کے ساتھ تار کا آغاز کرتا ہے۔اس کے بعد ، یہ پہلا_نون_ریپیٹڈ_چارٹر () فنکشن کو اسٹرنگ کے ساتھ فون کرتا ہے جیسے ان پٹ کے طور پر اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے سٹرنگ میں پہلا غیر بار بار کردار پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: AABBCDEEFF میں پہلا غیر ریپیٹڈ کردار یہ ہے: CTHIS آؤٹ پٹ سے پتہ چلتا ہے کہ فرسٹ_نون_ریپیٹڈ_چارٹر () فنکشن دیئے گئے سٹرنگ میں پہلے غیر ریپیٹڈ کردار کی صحیح طور پر شناخت کرتا ہے۔ انڈیکس () کا استعمال کرتے ہوئے: ہم استعمال کرسکتے ہیں۔انڈیکس () کا طریقہ کار میں ہر کردار کی پہلی موجودگی کو تلاش کرنے کا طریقہ اور جانچ پڑتال کریں کہ آیا یہ بھی آخری واقعہ ہے۔یہاں ایک مثال کے نفاذ ہے: پائیتھنڈف فرسٹ_نون_ریپیٹڈ_چارٹر (سٹرنگ): سٹرنگ میں چار کے لئے: اگر سٹرنگ ڈاٹ انڈیکس (چار) == سٹرنگ۔ رینڈیکس (چار): ریٹرن چار ریٹرن نانتھیس فنکشن ان پٹ کے طور پر سٹرنگ سٹرنگ لیتا ہے اور پہلی نان ریپیٹڈ لوٹاتا ہےتار میں کردار.یہ تار میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور چیک کرتا ہے کہ اگر اس کا پہلا واقعہ بھی انڈیکس () اور رینڈیکس () طریقوں کا استعمال کرتے ہوئے اس کا آخری واقعہ ہے۔اگر یہ ہے تو ، یہ کردار کو لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھسٹرنگ = \"AABBCDEEFF\" نتیجہ = FIRME_NON_REPEATED_CHARACTER (سٹرنگ) پرنٹ (\"پہلا غیر بار بار کردار\" ، سٹرنگ ، \"ہے:\" ، نتیجہ)یہ پروگرام سب سے پہلے \"AABBCDEEFF\" کی قدر کے ساتھ سٹرنگ نامی ایک تار کا آغاز کرتا ہے۔اس کے بعد ، یہ پہلا_نون_ریپیٹڈ_چارٹر () فنکشن کو اسٹرنگ کے ساتھ فون کرتا ہے جیسے ان پٹ کے طور پر اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے سٹرنگ میں پہلا غیر بار بار کردار پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: AABBCDEEFF میں پہلا غیر بار بار کردار یہ ہے: CTHIS آؤٹ پٹ سے پتہ چلتا ہے کہ فرسٹ_نون_ریپیٹڈ_چارٹر () فنکشن دیئے گئے تار میں پہلے غیر بار بار ہونے والے کردار کی صحیح شناخت کرتا ہے۔ عمل درآمد درست ہیں اور تلاش کرنے کے لئے استعمال کیا جاسکتا ہے اورازگر میں تار میں پہلا غیر بار بار کردار۔پہلا نفاذ ایک لغت کا استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد انڈیکس () کا طریقہ استعمال کرتا ہے۔"
    },
    {
        "Question": "متعدد فہرستوں میں مشترکہ عناصر کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں متعدد فہرستوں میں عام عناصر کو تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: سیٹوں کا استعمال: ہم ہر فہرست کو کسی سیٹ میں تبدیل کرسکتے ہیں اور مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف کامن_لیمنٹس (*فہرستیں): اگر فہرست نہیں ہے تو: کوئی بھی واپسی سیٹ نہیں کریں۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا کوئی فہرستیں موجود ہیں اور کوئی نہیں ہے اگر کوئی نہیں ہے۔اس کے بعد ، یہ نقشہ () فنکشن اور سیٹ () کنسٹرکٹر کا استعمال کرتے ہوئے ہر فہرست کو ایک سیٹ میں تبدیل کرتا ہے۔آخر میں ، یہ سیٹوں کے درمیان مشترکہ عناصر کو تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرتا ہے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھون لسٹ 1 = [1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [4 ، 5 ، 6 ،7 ، 8] لسٹ 3 = [5 ، 6 ، 7 ، 8 ، 9] نتیجہ = عام_ایلمنٹ (لسٹ 1 ، لسٹ 2 ، لسٹ 3) پرنٹ (\"عام عناصر کے درمیان\" ، لسٹ 1 ، لسٹ 2 ، لسٹ 3 ، \"ہیں:\" ، نتیجہ) یہ پروگرامپہلے لسٹ 1 ، لسٹ 2 ، اور لسٹ 3 نامی تین فہرستوں کا آغاز کرتا ہے۔اس کے بعد ، یہ فہرست 1 ، لسٹ 2 ، اور لسٹ 3 کے ساتھ کامن_لیمنٹس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے نتیجے میں اسٹور کرتا ہے جس کو نتیجہ کہا جاتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرستوں میں عام عناصر کو پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار یہ ہوگی: [1 ، 2 ، 3 ، 4 ، 5] [4 ، 5 ، 6 ، 7 ، 8] [5 ، 6 ، 7 ، 8 ، 9] کے درمیان مشترکہ عناصر ہیں: {5}اس آؤٹ پٹ سے پتہ چلتا ہے کہ مشترکہ_ایلیمنٹس () فنکشن دی گئی فہرستوں میں عام عناصر کی صحیح شناخت کرتا ہے۔ لوپ کا استعمال کرتے ہوئے: ہم پہلی فہرست میں ہر عنصر پر تکرار کرنے کے لئے لوپس کا استعمال کرسکتے ہیں اور چیک کرسکتے ہیں کہ آیا یہ دوسری تمام فہرستوں میں موجود ہے یا نہیں۔یہاں ایک مثال عمل ہے: پائیتھنڈف کامن_لیمنٹس (*فہرستیں): اگر فہرست نہیں ہے تو: فہرستوں میں الیوم کے لئے کوئی نہیں عام = [] واپس کریں [0]: اگر سب (فہرستوں میں ایل ایس ٹی کے لئے ایل ایس ٹی میں الیم): کامن۔ اپینڈ (ایلم) ریٹرن سیٹ(عام) یہ فنکشن ان پٹ کے طور پر کسی بھی طرح کی فہرستوں کو لے جاتا ہے اور ان میں عام عناصر کا ایک مجموعہ واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا کوئی فہرستیں موجود ہیں اور کوئی نہیں ہے اگر کوئی نہیں ہے۔پھر ، یہ ایک خالی فہرست شروع کرتا ہے جسے کامن کہتے ہیں۔یہ پہلی فہرست میں ہر عنصر پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور چیک کرتا ہے کہ اگر یہ تمام () فنکشن اور جنریٹر اظہار کا استعمال کرتے ہوئے دوسری تمام فہرستوں میں موجود ہے۔اگر یہ ہے تو ، یہ عنصر کو عام فہرست میں شامل کرتا ہے۔آخر میں ، یہ عام فہرست کا ایک سیٹ لوٹاتا ہے۔ یہاں فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھون لسٹ 1 = [1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [4 ، 5 ، 6 ، 7 ، 8] لسٹ 3 = [5 ، 6 ، 7 ، 8 ، 9] نتیجہ = عام_ایلمنٹ (لسٹ 1 ، لسٹ 2 ، لسٹ 3) پرنٹ (\"عام عناصر کے درمیان\" ، لسٹ 1 ، لسٹ 2 ، لسٹ 3 ، \"ہیں:\" ، نتیجہ) یہ پروگرام پہلے لسٹ 1 نامی تین فہرستوں کی ابتدا کرتا ہے ،لسٹ 2 ، اور لسٹ 3۔اس کے بعد ، یہ فہرست 1 ، لسٹ 2 ، اور لسٹ 3 کے ساتھ کامن_لیمنٹس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے نتیجے میں اسٹور کرتا ہے جس کو نتیجہ کہا جاتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے فہرستوں میں عام عناصر کو پرنٹ کرتا ہے۔اس معاملے میں ، پیداوار یہ ہوگی: [1 ، 2 ، 3 ، 4 ، 5] [4 ، 5 ، 6 ، 7 ، 8] [5 ، 6 ، 7 ، 8 ، 9] کے درمیان مشترکہ عناصر ہیں: {5}اس آؤٹ پٹ سے پتہ چلتا ہے کہ مشترکہ_ایلمنٹ () فنکشن دی گئی فہرستوں میں عام عناصر کی صحیح شناخت کرتا ہے۔ دونوں عمل درآمد درست ہیں اور ازگر میں متعدد فہرستوں میں مشترکہ عناصر کو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔پہلا عمل درآمد سیٹوں کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ لوپ کا استعمال کرتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے نمبر دو کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد ازگر میں دو کی طاقت ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: بٹ وائز آپریشنز کا استعمال: ہم بٹ وائز اور آپریٹر کو یہ چیک کرنے کے لئے استعمال کرسکتے ہیں کہ آیا کوئی نمبر دو کی طاقت ہے یا نہیں۔دو کی طاقت میں صرف ایک تھوڑا سا سیٹ ہوتا ہے ، لہذا جب ہم اس سے 1 کو گھٹا دیتے ہیں تو ، سیٹ بٹ کے دائیں طرف کے تمام ٹکڑے 1. ہوجاتے ہیں۔اگر نمبر دو کی طاقت ہے۔یہاں ایک مثال کے نفاذ ہے: پائیٹھنڈف is_power_of_two (n): اگر n <= 0: واپس غلط واپسی n & (n - 1) == 0 یہ فنکشن ان پٹ کے طور پر ایک نمبر N لے جاتا ہے اور اگر نمبر دو اور غلط ہے تو صحیح لوٹتا ہے۔ورنہ۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا نمبر 0 سے کم یا اس کے برابر ہے اور اگر یہ ہے تو غلط لوٹاتا ہے۔اس کے بعد ، یہ یہ چیک کرنے کے لئے بٹ وائز اور آپریٹر کا استعمال کرتا ہے کہ آیا یہ نمبر دو کی طاقت ہے۔ یہاں فنکشن کو استعمال کرنے کی ایک مثال ہے: pythonn = 16result = is_power_of_two (n) پرنٹ (n ، \"دو کی طاقت ہے:\" ، \"،نتیجہ) یہ پروگرام سب سے پہلے N نامی ایک انٹیجر کو 16 کی قیمت کے ساتھ شروع کرتا ہے۔ پھر ، یہ IS_POWER_OF_TWO () کو N کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا نمبر پرنٹ () فنکشن کا استعمال کرتے ہوئے دو کی طاقت ہے یا نہیں۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 16 دو کی طاقت ہے: ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ IS_POWER_OF_TWO () فنکشن صحیح طور پر اس کی نشاندہی کرتا ہے کہ 16 دو کی طاقت ہے۔ استعمال کرنے والے لوگرتھم: ہم یہ چیک کرنے کے لئے لوگرتھمز کا استعمال کرسکتے ہیں کہ آیا کوئی نمبر ایک طاقت ہے یا نہیں۔دو میں سےدو کی طاقت میں صرف ایک بٹ سیٹ 1 پر ہے ، لہذا اس کی بنیاد 2 سے لاجارتھم ایک عدد ہے۔یہاں ایک مثال عمل ہے: پائیتھونیم پورٹ میتھ ڈیف is_power_of_two (n): اگر n <= 0: غلط واپسی math.log2 (n) .is_integer () یہ فنکشن ان پٹ کے طور پر ایک نمبر N لے جاتا ہے اور اگر یہ نمبر دو کی طاقت ہے تو وہ سچ ہے۔اور دوسری صورت میں جھوٹا۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا نمبر 0 سے کم یا اس کے برابر ہے اور اگر یہ ہے تو غلط لوٹاتا ہے۔اس کے بعد ، یہ ریاضی کے ماڈیول سے لاگ 2 () فنکشن کا استعمال یہ چیک کرنے کے لئے کرتا ہے کہ آیا نمبر 2 کے نمبر 2 کا لوگرتھم ایک عدد ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھن = 16 ریزولٹ = is_power_of_two (n) پرنٹ (این ، این ،\"دو کی طاقت ہے:\" ، نتیجہ) اس پروگرام میں سب سے پہلے N نامی ایک انٹیجر کو 16 کی قیمت کے ساتھ شروع کیا جاتا ہے۔ پھر ، یہ IS_POWER_OF_TWO () N کے ساتھ فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا نمبر پرنٹ () فنکشن کا استعمال کرتے ہوئے دو کی طاقت ہے یا نہیں۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 16 دو کی طاقت ہے: ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ IS_POWER_OF_TWO () فنکشن صحیح طریقے سے اس بات کی نشاندہی کرتا ہے کہ 16 دو کی طاقت ہے۔ دونوں عمل درآمد درست ہیں اور یہ چیک کرنے کے لئے استعمال کیا جاسکتا ہے کہ آیا کوئی دی گئی تعداد ہے یا نہیںازگر میں دو کی طاقت۔پہلا نفاذ بٹ وائز آپریشنز کا استعمال کرتا ہے ، جبکہ دوسرا عمل درآمد لاگ ان کے استعمال کرتا ہے۔"
    },
    {
        "Question": "کسی پروگرام کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار کسی پیلنڈرووم کا اناگرام ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ ازگر میں کسی پیلنڈرووم کا اناگرام ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: لغت کا استعمال کرتے ہوئے: ہم تار میں ہر کردار کے واقعات کو گننے کے لئے ایک لغت کا استعمال کرسکتے ہیں اور پھر چیک کریں کہ کیا زیادہ سے زیادہ ایک کردار ہے جس میں عجیب گنتی ہے۔اگر وہاں موجود ہے تو ، پھر تار ایک پیلینڈرووم کا اناگرام ہے۔یہاں ایک مثال عمل ہے: پائتھونڈف is_anagram_of_palindrome (سٹرنگ): گنتی = {string تار میں چار کے لئے: اگر گنتی میں چار: گنتی [چار] += 1 اور: گنتی کے لئے گنتی [چار] = 1 اوڈ_کاؤنٹ = 0 گنتی میں گنتی کے لئے (گنتی کے لئے (چار]): اگر گنتی ٪ 2 == 1: اوڈ_کاؤنٹ += 1 اگر اوڈ_کاؤنٹ> 1: غلط واپسی ٹروتیس فنکشن ان پٹ کے طور پر ایک تار تار لیتا ہے اور اگر تار کسی پیلنڈرووم کا اناگرام ہے اور غلط ہے تو اس کو سچ ثابت کرتا ہے۔یہ سب سے پہلے تار میں ہر کردار کے واقعات کو گننے کے لئے گنتی نامی ایک لغت کا آغاز کرتا ہے۔یہ تار کے اوپر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور لغت میں ہر کردار کی گنتی کو اپ ڈیٹ کرتا ہے۔اس کے بعد ، یہ ایک اور لوپ کا استعمال گنتی اور چیکوں پر تکرار کرنے کے لئے کرتا ہے اگر عجیب و غریب گنتی کے ساتھ زیادہ سے زیادہ ایک کردار موجود ہو۔اگر وہاں موجود ہے تو ، یہ سچ واپس آجاتا ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھنسٹرنگ = \"ریسکار\" نتیجہ = is_anagram_of_palindrome (سٹرنگ) پرنٹ (سٹرنگ ، \"ایک Palindrome کا ایک اناگرام ہے:\" ، نتیجہ) یہ پروگرام پہلے فون کی شروعات کرتا ہے۔\"ریسکار\" کی قدر کے ساتھ تار۔اس کے بعد ، یہ is_anagram_of_palindrome () فنکشن کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے نتیجے میں اسٹور کرتا ہے جسے نتیجہ کہا جاتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا اسٹرنگ پرنٹ () فنکشن کا استعمال کرتے ہوئے کسی پیلنڈرووم کا اناگرام ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ریسکار ایک پیلینڈرووم کا ایک اناگرام ہے: ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_anagram_of_palindrome () فنکشن صحیح طور پر اس بات کی نشاندہی کرتا ہے کہ \"ریسکار\" ایک palindrome کا ایک اناگرام ہے۔ ہم گنتی کے لئے ایک فہرست کا استعمال کرسکتے ہیں۔تار میں ہر کردار کے واقعات اور پھر چیک کریں کہ آیا زیادہ سے زیادہ ایک کردار ہے جس میں عجیب گنتی ہے۔اگر وہاں موجود ہے تو ، پھر تار ایک پیلینڈرووم کا اناگرام ہے۔یہاں ایک مثال عمل ہے: پائیتھنڈف is_anagram_of_palindrome (سٹرنگ): گنتی = [0] * 128 تار میں چار کے لئے: گنتی [آرڈ (چار)] += 1 اوڈ_کاؤنٹ = 0 گنتی میں گنتی کے لئے: اگر گنتی ٪ 2 == 1: عجیب_کاؤنٹ+= 1 اگر عجیب_کاؤنٹ> 1: غلط واپسی ٹروتیس فنکشن ان پٹ کے طور پر اسٹرنگ سٹرنگ لیتا ہے اور اگر اسٹرنگ کسی پیلنڈرووم کا اناگرام ہے اور غلط ہے تو وہ سچ ہے۔یہ سب سے پہلے تار میں ہر کردار کے واقعات کو گننے کے لئے گنتی کے نام سے ایک فہرست کی ابتدا کرتا ہے۔یہ تار کے اوپر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور فہرست میں ہر کردار کی گنتی کو اپ ڈیٹ کرتا ہے۔اس کے بعد ، یہ ایک اور لوپ کا استعمال گنتی اور چیکوں پر تکرار کرنے کے لئے کرتا ہے اگر عجیب و غریب گنتی کے ساتھ زیادہ سے زیادہ ایک کردار موجود ہو۔اگر وہاں موجود ہے تو ، یہ سچ واپس آجاتا ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھنسٹرنگ = \"ریسکار\" نتیجہ = is_anagram_of_palindrome (سٹرنگ) پرنٹ (سٹرنگ ، \"ایک Palindrome کا ایک اناگرام ہے:\" ، نتیجہ) یہ پروگرام پہلے فون کی شروعات کرتا ہے۔\"ریسکار\" کی قدر کے ساتھ تار۔اس کے بعد ، یہ is_anagram_of_palindrome () فنکشن کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو ایک متغیر کے نتیجے میں اسٹور کرتا ہے جسے نتیجہ کہا جاتا ہے۔آخر میں ، یہ پرنٹ کرتا ہے کہ آیا اسٹرنگ پرنٹ () فنکشن کا استعمال کرتے ہوئے کسی پیلنڈرووم کا اناگرام ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ریسکار ایک پیلیندرووم کا ایک اناگرام ہے: ٹریٹیس آؤٹ پٹ سے پتہ چلتا ہے کہ is_anagram_of_palindrome () فنکشن صحیح طور پر اس بات کی نشاندہی کرتا ہے کہ \"ریسکار\" ایک palindrome کا ایک اناگرام ہے۔ دونوں پر عمل درآمد درست ہیں اور اگر جانچنے کے لئے استعمال کیا جاسکتا ہے تو اگر اس کی جانچ پڑتال کے لئے استعمال کیا جاسکتا ہے۔دیئے گئے تار ازگر میں ایک پیلنڈرووم کا اناگرام ہے۔پہلا نفاذ ایک لغت کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ ایک فہرست استعمال کرتا ہے۔"
    },
    {
        "Question": "دوگنا منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور قیمت کے لحاظ سے نوڈ کو حذف کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس کا ایک مثال عمل ہے جو دوگنا منسلک فہرست کی نمائندگی کرتا ہے اور نوڈ کو حذف کرنے کے لئے ایک طریقہ پر عمل درآمد کرتا ہے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیل۔ڈبل لنکڈ لسٹ: ڈیف __init __ (خود): سیلف ہیڈ = کوئی بھی نہیں ڈیف ڈیلیٹ_نوڈ (خود ، قدر): اگر سیلف ہیڈ کوئی نہیں ہے: موجودہ = سیلف۔.prev کوئی بھی نہیں ہے: موجودہ. prev.next = موجودہ۔ نیکسٹ اور: خود۔ ہیڈ = کرنٹ۔ نیکسٹ اگر موجودہ نہیں ہے۔ نیکسٹ کوئی نہیں ہے: موجودہ۔ نیکسٹ۔ پرپریو = کرنٹ.پیپریو ریٹرن کرنٹ = کرنٹ۔کلاس: نوڈ اور ڈبل لنک لسٹ۔نوڈ کلاس دوگنا منسلک فہرست میں ایک نوڈ کی نمائندگی کرتی ہے اور اس میں تین صفات ہیں: ڈیٹا ، پروپ اور اگلا۔ڈبل لنکڈ لسٹ کلاس دوگنا منسلک فہرست کی نمائندگی کرتی ہے اور اس کی ایک وصف ہے: ہیڈ ، جو فہرست میں پہلا نوڈ ہے۔ ڈیلیٹ_نوڈ () کا طریقہ ان پٹ کی حیثیت سے ایک قدر لیتا ہے اور اس قدر کے ساتھ فہرست میں پہلا نوڈ کو حذف کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست خالی ہے اور اگر یہ ہے تو لوٹ آئے گی۔اس کے بعد ، یہ فہرست میں ہر نوڈ پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور چیک کرتا ہے کہ آیا اس کا ڈیٹا ان پٹ ویلیو کے برابر ہے۔اگر یہ ہے تو ، یہ فہرست سے موجودہ نوڈ کو ہٹانے کے لئے ملحقہ نوڈس کے سابقہ اور اگلے پوائنٹرز کو اپ ڈیٹ کرتا ہے۔ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر# ایک دوگنا لنکڈ فہرست بنائیں.# اصل لسٹ پرنٹ (\"اصل فہرست:\") پرنٹ کریں موجودہ = dll.headle موجودہ کوئی بھی نہیں ہے: پرنٹ (کرنٹ.ڈیٹا) موجودہ = کرنٹ۔ نیکسٹ# ویلیوڈل.ڈیلیٹ_نوڈ (2) کے ذریعہ ایک نوڈ کو حذف کریں۔\"تازہ کاری کی فہرست:\") موجودہ = dll.headle موجودہ کوئی نہیں ہے: پرنٹ (کرنٹ.ڈیٹا) موجودہ = کرنٹ۔ اس کے بعد یہ پروگرام پہلے تین نوڈس کے ساتھ دوگنا منسلک فہرست بناتا ہے۔اس کے بعد ، یہ ہر نوڈ پر تکرار کرنے اور اس کے ڈیٹا کو پرنٹ کرنے کے ل a ایک لوپ کا استعمال کرتے ہوئے اصل فہرست پرنٹ کرتا ہے۔اگلا ، یہ نوڈ کو حذف کریں۔آخر میں ، یہ ہر نوڈ پر تکرار کرنے اور اس کے ڈیٹا کو پرنٹ کرنے کے ل a ایک لوپ کا استعمال کرتے ہوئے تازہ ترین فہرست پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: اصل فہرست: 123 اپ ڈیٹ شدہ فہرست: 13 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ڈیلیٹ_نوڈ () کا طریقہ صحیح طور پر نوڈ کو 2 کی قیمت کے ساتھ لسٹ میں 2 کی قیمت کے ساتھ حذف کرتا ہے۔"
    },
    {
        "Question": "لغت (لغت) آرڈر میں تاروں کی فہرست ترتیب دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں لغت (لغت) آرڈر میں تاروں کی فہرست ترتیب دینے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے: ہم لغت کی ترتیب میں تاروں کی فہرست کو ترتیب دینے کے لئے ترتیب () طریقہ استعمال کرسکتے ہیں۔پہلے سے طے شدہ طور پر ، ترتیب () طریقہ کار میں چڑھتے ترتیب میں فہرست کو ترتیب دیتا ہے۔یہاں ایک مثال کے نفاذ ہے: پائتھنڈف ترتیب_سٹرنگس (ڈور): ڈور۔ سارٹ () ریٹرن اسٹرنگس فنکشن ان پٹ کے طور پر تار کے تاروں کی فہرست لیتا ہے اور لغت کی ترتیب میں ترتیب شدہ فہرست کو لوٹاتا ہے۔اس فہرست کو جگہ میں ترتیب دینے کے لئے ترتیب () کا طریقہ استعمال کرتا ہے۔ اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیتھنسٹرنگز = [\"کیلے\" ، \"ایپل\" ، \"چیری\" ، \"اورنج\"] نتیجہ = ترتیب_سٹرنگ (ڈور) پرنٹ۔اس کے بعد ، یہ ترتیب_سٹرنگس () کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے تار کی ترتیب شدہ فہرست پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ترتیب دیئے گئے تاروں: ['ایپل' ، 'کیلے' ، 'چیری' ، 'اورنج'] اس آؤٹ پٹ سے پتہ چلتا ہے کہ ترتیب_سٹرنگس () فنکشن لغت کے ترتیب میں تاروں کی فہرست کو صحیح طریقے سے ترتیب دیتا ہے۔ترتیب شدہ () فنکشن: ہم لغت کے ترتیب میں تاروں کی فہرست کو ترتیب دینے کے لئے ترتیب شدہ () فنکشن کا استعمال کرسکتے ہیں۔ترتیب شدہ () فنکشن ایک نئی ترتیب شدہ فہرست لوٹاتا ہے اور اصل فہرست میں کوئی تبدیلی نہیں کرتا ہے۔یہاں ایک مثال کے نفاذ ہے: پائیٹنڈف ترتیب_سٹرنگز (ڈور): ریٹرن ترتیب شدہ (ڈور) یہ فنکشن ان پٹ کے طور پر تاروں کے تاروں کی فہرست لیتا ہے اور لغت کی ترتیب میں ترتیب شدہ فہرست کو لوٹاتا ہے۔اس فہرست کو ترتیب دینے کے لئے ترتیب شدہ () فنکشن کا استعمال کرتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھسٹرنگز = [\"کیلے\" ، \"ایپل\" ، \"چیری\" ، \"اورنج\"] نتیجہ = ترتیب_سٹرنگ (ڈور) پرنٹ (\"پرنٹ (\"ترتیب شدہ ڈور: \"، نتیجہ) یہ پروگرام پہلے [\" کیلے \"،\" ایپل \"،\" چیری \"،\" اورنج \"] کی قیمت والی تاروں کے نام سے ایک فہرست شروع کرتا ہے۔اس کے بعد ، یہ ترتیب_سٹرنگس () کو اسٹرنگ کے ساتھ ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے تار کی ترتیب شدہ فہرست پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: ترتیب شدہ ڈور: ['ایپل' ، 'کیلے' ، 'چیری' ، 'اورنج'] اس آؤٹ پٹ سے پتہ چلتا ہے کہ ترتیب_سٹرنگس () فنکشن لغت کی ترتیب میں تاروں کی فہرست کو صحیح طریقے سے ترتیب دیتا ہے۔درست ہیں اور ازگر میں لغت کی ترتیب میں تاروں کی فہرست ترتیب دینے کے لئے استعمال ہوسکتے ہیں۔پہلا نفاذ ترتیب () کا طریقہ استعمال کرتا ہے ، جبکہ دوسرا نفاذ ترتیب شدہ () فنکشن۔"
    },
    {
        "Question": "اعشاریہ کی تعداد کو بائنری فریکشن میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "اعشاریہ نمبر کو ازگر میں بائنری حص into ہ میں تبدیل کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: کسٹم فنکشن کا استعمال کرتے ہوئے: ہم اعشاریہ نمبر کو بائنری فریکشن میں تبدیل کرنے کے لئے کسٹم فنکشن کا استعمال کرسکتے ہیں۔فنکشن اعشاریہ کی تعداد کو 2 سے بڑھاتا ہے اور چیک کرتا ہے کہ اگر نتیجہ 1 سے زیادہ یا اس کے برابر ہے۔اگر یہ نہیں ہے تو ، یہ بائنری حص raction ہ میں 0 کا اضافہ کرتا ہے۔یہ اس عمل کو دہراتا ہے جب تک کہ اعشاریہ نمبر 0 نہ ہوجائے یا بائنری فریکشن میں مطلوبہ صحت سے متعلق ہو۔یہاں ایک مثال عمل ہے: پائیتھنڈف اعشاریہ_ٹو_بائنری_فراکشن (اعشاریہ ، صحت سے متعلق = 10): بائنری = \"\" جبکہ اعشاریہ> 0 اور لین (بائنری) <صحت سے متعلق: اعشاریہ *= 2 اگر اعشاریہ> = 1: بائنری += \"1\" اعشاریہ -=1 اور: بائنری += \"0\" ریٹرن بائنری اس فنکشن کو ان پٹ کے طور پر اعشاریہ اعشاریہ اور اختیاری صحت سے متعلق صحت سے متعلق لیتا ہے اور ایک بائنری حص raction ہ کو تار کے طور پر لوٹاتا ہے۔یہ اعشاریہ کی تعداد کو 2 سے ضرب کرنے اور بائنری فریکشن میں 1 یا 0 شامل کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اس پر منحصر ہے کہ آیا نتیجہ 1 سے زیادہ یا اس کے برابر ہے یا اس کے برابر ہے جب تک کہ اعشاریہ کی تعداد 0 نہ ہوجائے یا بائنری جزء مطلوب ہو۔صحت سے متعلق۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھنڈیسیمل = 0.625Result = اعشاریہ_ٹو_بائنری_فراکشن (اعشاریہ) پرنٹ (\"بائنری حصہ\" ، اعشاریہ ، \"،\" ، نتیجہ) یہ پروگرام پہلے کسی قدر کے ساتھ اعشاریہ کی شروعات کرتا ہے۔0.625اس کے بعد ، یہ اعشاریہ_ٹو_بائنری_فراکشن () فنکشن کو اعشاریہ کے ساتھ فون کرتا ہے اور ان پٹ کے طور پر اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بائنری فریکشن پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 0.625 کا بائنری حصہ یہ ہے: 101 اس آؤٹ پٹ سے پتہ چلتا ہے کہ اعشاریہ_ٹو_بائنری_فراکشن () فنکشن اعشاریہ کو صحیح طور پر بائنری فریکشن میں تبدیل کرتا ہے۔ اعشاریہ ماڈیول کا استعمال کرتے ہوئے: ہم اعشاریہ ماڈیول کو اعشاریہ نمبر میں تبدیل کرنے کے لئے استعمال کرسکتے ہیں۔ایک بائنری حص raction ہ میںاعشاریہ ماڈیول ایک اعشاریہ کلاس مہیا کرتا ہے جو صوابدیدی صحت سے متعلق اعشاریہ کی نمائندگی کرسکتا ہے۔ہم اعشاریہ کلاس کے AS_Integer_ratio () کا طریقہ استعمال کرسکتے ہیں تاکہ فریکشن کے اعداد اور فرق کو حاصل کیا جاسکے اور پھر انہیں بن () فنکشن کا استعمال کرتے ہوئے بائنری میں تبدیل کیا جاسکے۔یہاں ایک مثال عمل ہے: ازگر سے اعشاریہ اعشاریہ اعشاریہ اعشاریہ اعشاریہ اعشاریہ اعشاریہ اعشاریہ = اعشاریہ = اعشاریہ (اعشاریہ)/\" + بائنری_ڈینومینیٹر یہ فنکشن ان پٹ کے طور پر ایک اعشاریہ اعشاریہ اعشاریہ لیتا ہے اور بائنری حص raction ہ کو تار کے طور پر لوٹاتا ہے۔یہ اعشاریہ طبقے کا استعمال کرتے ہیں تاکہ حص raction ہ اور بن () فنکشن کو بائنری میں تبدیل کیا جاسکے۔ یہاں فنکشن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھنڈیسیمل = 0.625result = decimal_to_binary_fraction (اعشاریہ) پرنٹ (\"بائنری فریکشن)\"، اعشاریہ ،\" ہے: \"، نتیجہ) اس پروگرام میں پہلے اعشاریہ نمبر کا آغاز ہوتا ہے جسے اعشاریہ کہا جاتا ہے جس کی قیمت 0.625 ہے۔اس کے بعد ، یہ اعشاریہ_ٹو_بائنری_فراکشن () فنکشن کو اعشاریہ کے ساتھ فون کرتا ہے اور ان پٹ کے طور پر اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بائنری فریکشن پرنٹ کرتا ہے۔اس صورت میں ، آؤٹ پٹ یہ ہوگا: 0.625 کا بائنری حصہ ہے: 101/1000 اس آؤٹ پٹ سے پتہ چلتا ہے کہ اعشاریہ_ٹو_بائنری_فراکشن () فنکشن اعشاریہ کو صحیح طور پر بائنری فریکشن میں تبدیل کرتا ہے۔ازگر میں ایک بائنری حصہ۔پہلا نفاذ ایک کسٹم فنکشن کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ اعشاریہ ماڈیول کا استعمال کرتا ہے۔"
    },
    {
        "Question": "ایک مقررہ نمبر تک بنیادی تعداد کا مجموعہ تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں دیئے گئے نمبر تک بنیادی تعداد کی رقم تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لوپ کا استعمال: ہم ہر نمبر پر دیئے گئے نمبر تک تکرار کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں اور چیک کرسکتے ہیں کہ آیا یہ ایک اہم نمبر ہے۔اگر یہ ہے تو ، ہم اسے چلتی ہوئی رقم میں شامل کرتے ہیں۔یہاں ایک مثال کے نفاذ ہے: پائتھنڈف SUM_OF_PRIMES (n): اگر n <2: واپس 0 پرائمز = [سچ] * (n + 1) پرائمز [0] = پرائمز [1] = رینج میں I کے لئے غلط** 0.5) + 1): اگر پرائمز [i]: رینج میں J کے لئے (i * i ، n + 1 ، i): پرائمز [j] = غلط واپسی کا مجموعہ (i کے لئے I کے لئے (2 ، n + 1) اگر پرائمز [i]) یہ فنکشن ان پٹ کے طور پر ایک عدد N لیتا ہے اور N تک تمام بنیادی نمبروں کا مجموعہ واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا N 2 سے کم ہے اور 0 لوٹتا ہے اگر یہ ہے۔اس کے بعد ، یہ ہر انڈیکس کے لئے N تک ہر انڈیکس کے لئے حقیقی اقدار کے ساتھ پرائمز نامی ایک فہرست کی ابتدا کرتا ہے۔یہ N کے مربع روٹ تک ہر نمبر پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور اپنے تمام ضربوں کو بطور جامع کے طور پر نشان زد کرتا ہے جس سے پرائمز لسٹ میں ان کے متعلقہ اشاریہ کو غلط پر رکھ دیا جاتا ہے۔آخر میں ، یہ ہر ایک نمبر پر N تک تکرار کرنے کے لئے ایک اور لوپ کا استعمال کرتا ہے اور اسے چلانے والی رقم میں شامل کرتا ہے اگر یہ ایک اہم نمبر ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: pythonn = 50result = sum_of_primes (n) پرنٹ (\"سم\"، n ،\" تک بنیادی تعداد میں سے: \"، نتیجہ) یہ پروگرام پہلے 50 کی قیمت کے ساتھ N نامی ایک عدد کا آغاز کرتا ہے۔ پھر ، یہ N کے ساتھ Sum_of_primes () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اور اس کے نتیجے کو متغیر میں اسٹور کرتا ہے۔نتیجہ کہا جاتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بنیادی نمبروں کی رقم پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 50 تک کی بنیادی تعداد کا مجموعہ یہ ہے: 328 اس آؤٹ پٹ سے پتہ چلتا ہے کہ SUM_OF_PRIMES () فنکشن 50 تک پرائم نمبروں کی رقم کی صحیح شناخت کرتا ہے۔ سمپی ماڈیول کا استعمال کرتے ہوئے: ہم سمپی ماڈیول کا استعمال کرسکتے ہیں۔دیئے گئے نمبر تک بنیادی نمبر تلاش کریں اور پھر ان کا خلاصہ کریں۔سمپی ماڈیول ایک پرائمریج () فنکشن مہیا کرتا ہے جو کسی رینج میں بنیادی نمبروں پر ایک تکرار واپس کرتا ہے۔یہاں ایک مثال عمل ہے: ازگر سمپی امپورٹ پرائمرینگ ڈیف SUM_OF_PRIMES (N): واپسی کا مجموعہ (پرائمریج (2 ، N + 1)) یہ فنکشن ان پٹ کے طور پر ایک عدد N لیتا ہے اور N تک تمام پرائم نمبروں کا مجموعہ واپس کرتا ہے۔یہ رینج [2 ، n + 1] میں بنیادی نمبروں پر ایک تکرار حاصل کرنے کے لئے سمپی ماڈیول سے پرائمریج () فنکشن کا استعمال کرتا ہے اور پھر ان کا خلاصہ کرتا ہے۔ فنکشن کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر = 50result = sum_of_prymes (n) پرنٹ (\"پرائم نمبروں کا مجموعہ\" ، این ، \"ہے:\" ، نتیجہ) یہ پروگرام سب سے پہلے 50 کی قیمت کے ساتھ N نامی ایک عدد کی ابتدا کرتا ہے۔ پھر ، یہ N کے ساتھ Sum_of_primes () فنکشن کو ان پٹ کے طور پر کال کرتا ہے اورنتیجہ کو ایک متغیر کے نتیجے میں اسٹور کرتا ہے جسے نتیجہ کہا جاتا ہے۔آخر میں ، یہ پرنٹ () فنکشن کا استعمال کرتے ہوئے بنیادی نمبروں کی رقم پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 50 تک بنیادی تعداد کا مجموعہ یہ ہے: 328 اس آؤٹ پٹ سے پتہ چلتا ہے کہ SUM_OF_PRIMES () فنکشن 50 تک بنیادی تعداد کی رقم کی صحیح شناخت کرتا ہے۔ازگر میں ایک دیئے گئے نمبر تک بنیادی تعداد میں۔پہلا نفاذ ایک لوپ کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ سمپی ماڈیول کا استعمال کرتا ہے۔"
    },
    {
        "Question": "ہیش ٹیبل کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور کلیدی قدر کے جوڑے ڈالنے اور بازیافت کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "ایک ہیش ٹیبل کی نمائندگی کرنے اور کلیدی قیمت کے جوڑے ڈالنے اور بازیافت کرنے کے طریقوں کو نافذ کرنے والے ایک ازگر کلاس بنانے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: علیحدہ زنجیروں کا استعمال: ہم ہیش ٹیبل میں تصادم کو سنبھالنے کے لئے علیحدہ زنجیر کا استعمال کرسکتے ہیں۔علیحدہ زنجیر ایک ایسی تکنیک ہے جہاں ہیش ٹیبل میں ہر بالٹی ایک منسلک فہرست ہے جو کلیدی قیمت کے تمام جوڑے کو محفوظ کرتی ہے جو ہیش ایک ہی انڈیکس میں ہے۔یہاں ایک مثال عمل ہے: ازگر __init __ (خود ، صلاحیت = 100)I کے لئے ، C میں enumerate (key): ہیش_سم + = (i + لین (کلید)) ** آرڈ (سی) ہیش_سم ٪ = سیلف۔ کیپسٹی ریٹرن ہیش_سم ڈیف داخل (خود ، کلیدی ، قدر): انڈیکس = سیلف ۔_ہش(کلیدی) نوڈ = سیلف بوکیٹس [انڈیکس] جبکہ نوڈ کوئی نہیں ہے: اگر نوڈ.کی == کلید: نوڈ۔ ویلیو = ویلیو ریٹرن نوڈ۔بالٹی [انڈیکس] سیلف۔ بکٹس [انڈیکس] = نیا_نوڈ سیلف۔ سائز += 1 ڈیف بازیافت (خود ، کلید): انڈیکس = سیلف۔.key == key: واپسی نوڈ۔ ویلیو نوڈ = نوڈ۔ نیکسٹ ریٹرن نونیکلاس نوڈ: Def __init __ (خود ، کلیدی ، قدر): self.key = key self.value = value sellاور نوڈ۔ہیش ٹیبل کلاس ہیش ٹیبل کی نمائندگی کرتا ہے اور اس میں تین صفات ہیں: صلاحیت ، سائز اور بالٹیاں۔اس کے دو طریقے بھی ہیں: _ ہش () اور داخل کریں ()۔_hash () طریقہ ان پٹ کے طور پر ایک کلید لیتا ہے اور ہیش ٹیبل میں انڈیکس کو واپس کرتا ہے جہاں کلیدی قدر کی جوڑی کو محفوظ کیا جانا چاہئے۔یہ ہیش ویلیو کی گنتی کے لئے ہیش فنکشن کا استعمال کرتا ہے۔داخل () کا طریقہ ان پٹ کے طور پر کلیدی قدر کی جوڑی لیتا ہے اور اسے ہیش ٹیبل میں داخل کرتا ہے۔یہ انڈیکس کی گنتی کے لئے _hash () کا طریقہ استعمال کرتا ہے اور پھر تصادم کو سنبھالنے کے لئے علیحدہ زنجیروں کا استعمال کرتا ہے۔ نوڈ کلاس لنکڈ فہرست میں ایک نوڈ کی نمائندگی کرتی ہے اور اس میں تین صفات ہیں: کلیدی ، قدر ، اور اگلا۔ اس کی ایک مثال ہے کہ کس طرح استعمال کیا جائےکلاس: ازگر# ایک ہیش ٹیبلہٹ = ہیش ٹیبل بنائیں ()# داخل کریں کلید ویلیو جوڑی شیٹ۔ INSERT (\"ایپل\" ، 1) ht.insert (\"کیلے\" ، 2) HT.Insert (\"چیری\" ، 3)# اقدار کو بازیافت کریںکلیدی پرنٹ (HT.Retrieve (\"ایپل\")) پرنٹ (HT.Retrieve (\"کیلے\")) پرنٹ (HT.Retrieve (\"چیری\")) یہ پروگرام پہلے HT کے نام سے ایک ہیش ٹیبل تشکیل دیتا ہے۔اس کے بعد ، یہ داخل () کے طریقہ کار کا استعمال کرتے ہوئے ہیش ٹیبل میں تین کلیدی قدر کے جوڑے داخل کرتا ہے۔آخر میں ، یہ بازیافت () کے طریقہ کار کا استعمال کرتے ہوئے کلید کے ذریعہ اقدار کو بازیافت کرتا ہے اور ان کو پرنٹ () فنکشن کا استعمال کرتے ہوئے پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 123 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ہیش ٹیبل کلاس کلیدی قدر کے جوڑے کو صحیح طور پر داخل کرتی ہے اور اسے بازیافت کرتی ہے۔ایک لغت ایک ہیش ٹیبل ہے جو کلیدی قدر کے جوڑے کو محفوظ کرتی ہے۔یہاں ایک مثال عمل ہے: ازگر __Init __ (خود).get (کلیدی ، کوئی بھی نہیں) اس نفاذ میں ایک ہیش ٹیبل کلاس کی وضاحت کی گئی ہے جس میں ایک وصف ہے: ٹیبل ، جو ایک لغت ہے جو کلیدی قدر کے جوڑے کو محفوظ کرتی ہے۔اس کے دو طریقے بھی ہیں: داخل کریں () اور بازیافت ()۔داخل () کا طریقہ ان پٹ کے بطور کلیدی قدر کی جوڑی لیتا ہے اور اسے لغت میں داخل کرتا ہے۔بازیافت () کا طریقہ ان پٹ کے طور پر ایک کلید لیتا ہے اور لغت سے متعلقہ قیمت کو واپس کرتا ہے۔ کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر# ایک ہیش ٹیبلٹ = ہیش ٹیبل بنائیں ()# داخل کریں کلیدی قدر جوڑی شیٹ۔ داخل کریں۔\"، 1) ht.insert (\" کیلے \"، 2) ht.insert (\" چیری \"، 3)# کلید پرنٹ (ht.reterieve (\" ایپل \")) پرنٹ (ht.reteive (\" کیلے \")) کے ذریعہ اقدار کو بازیافت کریں۔پرنٹ (ht.retreive (\"چیری\")) یہ پروگرام سب سے پہلے ایک ہیش ٹیبل تشکیل دیتا ہے جسے ایچ ٹی کہتے ہیں۔اس کے بعد ، یہ داخل () کے طریقہ کار کا استعمال کرتے ہوئے ہیش ٹیبل میں تین کلیدی قدر کے جوڑے داخل کرتا ہے۔آخر میں ، یہ بازیافت () کے طریقہ کار کا استعمال کرتے ہوئے کلید کے ذریعہ اقدار کو بازیافت کرتا ہے اور ان کو پرنٹ () فنکشن کا استعمال کرتے ہوئے پرنٹ کرتا ہے۔اس معاملے میں ، آؤٹ پٹ یہ ہوگا: 123 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ہیش ٹیبل کلاس ازگر کی بلٹ ان لغت کا استعمال کرتے ہوئے کلیدی قدر کے جوڑے کو صحیح طریقے سے داخل کرتی ہے اور بازیافت کرتی ہے۔کلیدی قدر کے جوڑے ڈالنے اور بازیافت کرنے کے طریقے۔پہلا نفاذ علیحدہ زنجیروں کا استعمال کرتا ہے ، جبکہ دوسرا نفاذ ازگر کی بلٹ ان ڈکشنری کا استعمال کرتا ہے۔"
    },
    {
        "Question": "کسی بھی بلٹ ان طریقوں کو استعمال کیے بغیر دیئے گئے تار کو پلٹنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یہاں جاوا میں ایک فنکشن ہے جو کسی بھی بلٹ ان طریقوں کا استعمال کیے بغیر دیئے گئے تار کو پلٹانے کے لئے ہے: جاواپبلک جامد سٹرنگ ریورس اسٹرنگ (سٹرنگ ایس ٹی آر) {چار [] چارری = str.tochararray () ؛INT بائیں = 0 ؛INT حق = چاراری۔ لمبائی - 1 ؛جبکہ (بائیں <دائیں) {چار ٹیمپ = چارری [بائیں] ؛چیرری [بائیں] = چارری [دائیں] ؛چیرری [دائیں] = عارضی ؛بائیں ++ ؛ٹھیک ہے-؛} نئی سٹرنگ (چیرری) واپس کریں ؛} یہ فنکشن ایک تار ان پٹ لیتا ہے اور اسے کسی کردار کی صف میں تبدیل کرتا ہے۔اس کے بعد بالترتیب سرنی کے آغاز اور اختتام پر کرداروں کو تبدیل کرنے کے لئے ، بائیں اور دائیں ، دو پوائنٹرز کا استعمال کرتا ہے۔اشارے ایک دوسرے کی طرف بڑھتے ہیں یہاں تک کہ وہ صف کے وسط میں ملتے ہیں۔آخر میں ، فنکشن الٹ کریکٹر اری 1 سے ایک نیا سٹرنگ بنا کر الٹ سٹرنگ کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا کوڈ ایک دیئے گئے تار کو الٹ کرنے کے لئے الٹ اسٹریننگ () فنکشن کا استعمال کرتا ہے: جاواسٹرنگ str = \"ہیلو ورلڈ\" ؛ سٹرنگ الٹ اسٹرنگ = ریورسیسرنگ(str) ؛ system.out.println (الٹ سیسٹر) ؛ یہ آؤٹ پٹ: dlrow olleh1geeksforgeeks"
    },
    {
        "Question": "دو ترتیب شدہ فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دو ترتیب شدہ فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھنڈف کامن_لیمنٹس (لسٹ 1 ، لسٹ 2): i = 0 j = 0 نتیجہ = [] جبکہ میں <لین (لسٹ 1) اور جے <لین (لسٹ 2): اگر لسٹ 1 [i] == لسٹ 2 [j]: نتیجہ.ایپینڈ (فہرست 1 [i]) i += 1 J += 1 ELIF List1 [i] <فہرست 2 [j]: i += 1 اور: j += 1 واپسی کے نتیجے میں یہ فنکشنان پٹ کے طور پر دو ترتیب شدہ فہرستیں لیتے ہیں اور فہرستوں کے ذریعے تکرار کرنے کے لئے دو پوائنٹرز ، I اور J استعمال کرتے ہیں۔اگر پوائنٹرز کی موجودہ پوزیشنوں پر موجود عناصر برابر ہیں تو ، فنکشن عنصر کو نتیجہ کی فہرست میں شامل کرتا ہے اور دونوں پوائنٹرز میں اضافہ کرتا ہے۔اگر لسٹ 1 میں عنصر لسٹ 2 میں عنصر سے کم ہے تو ، فنکشن میں اضافہ i.بصورت دیگر ، اس میں اضافہ ہوتا ہے۔فنکشن عام عناصر پر مشتمل نتائج کی فہرست لوٹاتا ہے۔= [1 ، 2 ، 4 ، 5 ، 9 ، 10] نتیجہ = عام_ایلمنٹ (لسٹ 1 ، لسٹ 2) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: [1 ، 4 ، 9] 1 جیکسفورجیکس"
    },
    {
        "Question": "ایک ازگر کلاس بنائیں جس میں بائنری من-ہیپ کی نمائندگی کی جائے اور کم سے کم عنصر کو داخل کرنے اور نکالنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو بائنری من-ہیپ کی نمائندگی کرتی ہے اور کم سے کم عنصر داخل کرنے اور نکالنے کے ل its اس کے طریقوں کی نمائندگی کرتی ہے: پائیتھنکلاس منہیپ: ڈیف __init __ (خود): سیلف.ایپ = [] ڈیف داخل (خود ، قدر): سیلف ہائپ.ایپینڈ ((خود ، قدر)ویلیو) سیلف۔پاپ () سیلف۔self.swap (parent_index ، index) سیلف۔.HEAP [بائیں_ڈائلڈ_ انڈیکس] <سیلف.ایپ [MIN_INDEX]: MIN_INDEX = بائیں_چند_ index اگر رائٹ_چلیڈ_ انڈیکس <len (self.heap) اور sell._swap (index ، Min_index) سیلف۔اس کلاس میں ایک مثال کے متغیر کا ڈھیر ہے جو ڈھیر کے عناصر کو بطور فہرست محفوظ کرتا ہے۔داخل () کا طریقہ ایک قدر لیتا ہے اور اسے فہرست کے آخر میں شامل کرتا ہے ، پھر اسے ڈھیر میں اپنی صحیح پوزیشن تک لے جاتا ہے جب تک کہ ڈھیر کی جائیداد مطمئن نہ ہوجائے۔نچوڑ_مین () کا طریقہ فہرست کے آخری عنصر کے ساتھ تبدیل کرکے ، ڈھیر کے کم سے کم عنصر کو ہٹاتا ہے اور واپس کرتا ہے ، اور پھر بار بار اس کے ساتھ بدل کر ڈھیر میں نئے جڑ کے عنصر کو اس کی صحیح پوزیشن پر لے جاتا ہے۔جب تک ہیپ پراپرٹی مطمئن نہیں ہوتی اس کا سب سے چھوٹا بچہ۔_ببل_پ () اور _ببل_ ڈاون () طریقے مددگار طریقے ہیں جو تبادلہ اور بلبلنگ آپریشن انجام دیتے ہیں۔_SWAP () کا طریقہ ایک اور مددگار طریقہ ہے جو فہرست 1 میں دو عناصر کو تبدیل کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ ایک مینی ہاپ آبجیکٹ بناتا ہے ، کچھ اقدار داخل کرتا ہے ، اور کم سے کم عنصر نکالتا ہے: پائیٹونھیپ = مینی ہاپ () ہیپ.نسرٹ (5)ہیپ۔ INSERT (3) ہیپ۔ INSERT (7) ہیپ۔ INSERT (1) MIN_VALUE = ہیپ.ایکسٹرک_مین () پرنٹ (MIN_Value) اس کی پیداوار ہوگی: 11askPython"
    },
    {
        "Question": "تار میں پہلا غیر بار بار ہونے والے کردار کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "تار میں پہلا غیر ریپیٹنگ کردار تلاش کرنے کے لئے یہاں ایک ازگر فنکشن ہے: پائیٹھونڈف فرسٹ_نون_ریپیٹنگ_چار (سٹرنگ): چار_کاؤنٹ = {string تار میں چار کے لئے: اگر چار_ کاؤنٹ میں چار_کاؤنٹ: چار_کاؤنٹ [چار] += 1 اور: چار_کاؤنٹ [چار] =1 اسٹرنگ میں چار کے لئے: اگر چار_کاؤنٹ [چار] == 1: ریٹرن چار ریٹرن نیتھیس فنکشن ایک تار ان پٹ لیتا ہے اور پہلے ہر کردار کی گنتی کو تار میں ذخیرہ کرنے کے لئے ایک لغت چار_کاؤنٹ بناتا ہے۔اس کے بعد یہ تار کے ذریعے دوبارہ تکرار کرتا ہے اور پہلے کردار کو واپس کرتا ہے جس کی چار_کاؤنٹ ڈکشنری میں 1 کی گنتی ہوتی ہے۔اگر اس طرح کا کوئی کردار نہیں ملا ہے تو ، فنکشن کوئی بھی نہیں لوٹتا ہے۔(نتیجہ) اس کی پیداوار ہوگی: 'H'1geeksforgeeks"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیئے گئے تار ایک درست URL ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک درست URL ہے ، ہم اس نمونہ کے خلاف تار کو میچ کرنے کے لئے باقاعدہ اظہار استعمال کرسکتے ہیں جو درست URL کی ساخت کی وضاحت کرتا ہے۔ازگر میں ایسا کرنے کے بہت سارے طریقے ہیں ، لیکن ایک عام نقطہ نظر یہ ہے کہ باقاعدگی سے اظہار کے نمونہ کو مرتب کرنے کے لئے RE ماڈیول کا استعمال کریں اور پھر میچ () کے طریقہ کار کو یہ چیک کرنے کے لئے استعمال کریں کہ آیا اسٹرنگ پیٹرن سے مماثل ہے۔ یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو استعمال کرتا ہے۔باقاعدگی سے اظہار خیال کرنے کے لئے کہ آیا دیئے گئے تار ایک درست یو آر ایل ہے: پائیتھونیم پورٹ ریڈف آئی ایس_والیڈ_ورل (یو آر ایل): پیٹرن = ری ڈاٹ پییل (آر '^(؟: http | https): // [\\ w.-]+(؟: \\: \\ \\: \\۔یو آر ایل)) یہ فنکشن ایک تار ان پٹ یو آر ایل لیتا ہے اور باقاعدگی سے اظہار کے نمونہ کو مرتب کرنے کے لئے ری ڈاٹ پییل () کا طریقہ استعمال کرتا ہے جو ایک درست یو آر ایل کی ساخت سے مماثل ہے۔اس نمونے میں یو آر ایل کے مختلف اجزاء سے ملنے کے لئے کیریکٹر کلاسز ، گروپس اور کوانٹفائیرز کا ایک مجموعہ استعمال کیا گیا ہے ، جس میں اسکیم ، ڈومین ، راستہ اور استفسار کی تار شامل ہے۔اس کے بعد فنکشن یہ چیک کرنے کے لئے میچ () کا طریقہ استعمال کرتا ہے کہ آیا ان پٹ سٹرنگ پیٹرن سے مماثل ہے ، اور بولین کی قیمت کو واپس کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ سٹرنگ ایک درست یو آر ایل ہے یا نہیں۔اگر دیئے گئے تار ایک درست url ہے: pythonurl = \"https://www.google.com/search؟q=python\"result = is_valid_url (url) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: ٹرو نٹ جس میں باقاعدگی سے اظہار کا نمونہ استعمال ہوتا ہےیہ مثال کامل نہیں ہے اور ہوسکتا ہے کہ تمام ممکنہ درست یو آر ایل سے مماثل نہ ہو۔یو آر ایل کی ساخت میں بہت سی مختلف حالتیں ہیں ، اور کچھ یو آر ایل میں ایسے حروف یا اجزاء شامل ہوسکتے ہیں جو اس طرز کے احاطہ میں نہیں ہیں۔تاہم ، یہ نمونہ زیادہ تر عام URLs سے مماثل ہونا چاہئے اور ضرورت کے مطابق دوسرے معاملات کو سنبھالنے کے لئے آسانی سے ڈھال لیا جاسکتا ہے یا اس میں توسیع کی جاسکتی ہے۔"
    },
    {
        "Question": "متعدد سیٹوں کا چوراہا تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں متعدد سیٹوں کا چوراہا تلاش کرنے کے بہت سارے طریقے ہیں۔ایک طریقہ یہ ہے کہ سیٹ کلاس کے چوراہے () کا طریقہ استعمال کریں۔ایک اور طریقہ یہ ہے کہ اینڈ آپریٹر کو استعمال کیا جائے۔یہاں ایک مثال کا پروگرام ہے جو دونوں طریقوں کو ظاہر کرتا ہے: پائیٹھنڈف انٹرسیکٹ_سیٹس (سیٹ_ لسٹ): # چوراہا () طریقہ کار کا نتیجہ () طریقہ کار کا نتیجہ = سیٹ_ لسٹ [0]s set_list [1:] میں s: # نتیجہ & = s results کے نتیجے میں یہ فنکشن سیٹ سیٹ_ لسٹ کی ایک فہرست لیتا ہے اور پہلے فہرست میں موجود تمام سیٹوں کا چوراہا تلاش کرنے کے لئے چوراہا () کا طریقہ استعمال کرتا ہے۔* آپریٹر کو چوراہے () کے طریقہ کار کے دلائل کے طور پر سیٹوں کی فہرست کھولنے کے لئے استعمال کیا جاتا ہے۔متبادل کے طور پر ، فنکشن فہرست میں موجود سیٹوں کے ذریعے تکرار کرکے چوراہے کو تلاش کرنے اور پچھلے نتائج کے ساتھ چوراہے کو لے کر چوراہے کو تلاش کرنے کے لئے اور آپریٹر کا استعمال کرسکتا ہے۔فنکشن کے نتیجے میں سیٹ لوٹتا ہے جس میں فہرست میں موجود تمام سیٹوں کے مشترکہ عناصر شامل ہوتے ہیں۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ ایک سے زیادہ سیٹوں کا چوراہا تلاش کرنے کے لئے چوراہا_سیٹس () فنکشن کا استعمال کرتا ہے: پائیتھنسیٹ 1 = {1 ، 2 ، 3 ، 4، 5} سیٹ 2 = {2 ، 3 ، 5 ، 7 ، 11} سیٹ 3 = {3 ، 5 ، 8 ، 13} نتیجہ = انٹرسٹ_سیٹس ([سیٹ 1 ، سیٹ 2 ، سیٹ 3]) پرنٹ (نتیجہ) اس سے پیداوار ہوگی: {5 ،3} نوٹ کریں کہ چوراہا_سیٹس () فنکشن فرض کرتا ہے کہ ان پٹ لسٹ سیٹ_ لسٹ میں کم از کم ایک سیٹ ہوتا ہے۔اگر فہرست خالی ہے تو ، فنکشن ایک غلطی میں اضافہ کرے گا۔نیز ، فنکشن یہ فرض کرتا ہے کہ فہرست میں موجود سیٹ خالی نہیں ہیں۔اگر فہرست میں کوئی سیٹ خالی ہے تو ، فنکشن ایک خالی سیٹ کو چوراہے کے طور پر واپس کردے گا۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر ایک پیلنڈرووم ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے نمبر ایک پیلینڈرووم ہے ، ہم نمبر کو اسٹرنگ میں تبدیل کرسکتے ہیں اور چیک کرسکتے ہیں کہ آیا تار اس کے الٹ کے برابر ہے یا نہیں۔ازگر میں ایسا کرنے کے بہت سارے طریقے ہیں ، جن میں لوپس ، تکرار ، اور ون لائنر حل شامل ہیں۔یہاں کچھ مثالیں ہیں: ازگر# لوپڈف is_palindrome (num): num_str = str (num) کا استعمال کرتے ہوئے I (لین (num_str) // 2) کے لئے num_str = str (num): اگر num_str [i]! = num_str [-i - 1]:غلط واپسی سچ# recursionDef is_palindrome (num) کا استعمال کرتے ہوئے: num_str = str (num) اگر لین (num_str) <= 1: اگر num_str [0]! = num_str [-1]: غلط واپسی IS_Palindrome (num_str [1.str () فنکشن.پہلا فنکشن تار کے ذریعے اعادہ کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور تار کے مخالف سروں پر حروف کا موازنہ کرتا ہے۔اگر کرداروں کا کوئی جوڑا مماثل نہیں ہے تو ، فنکشن غلط لوٹتا ہے۔اگر تمام جوڑے ملتے ہیں تو ، فنکشن سچ واپس آجاتا ہے۔دوسرا فنکشن اس بات کی جانچ پڑتال کے لئے تکرار کا استعمال کرتا ہے کہ آیا اسٹرنگ میچ کے پہلے اور آخری حروف ، اور پھر ان کے مابین سٹرنگ کو بار بار چیک کرتے ہیں۔اگر سٹرنگ کی لمبائی 0 یا 1 ہے تو ، فنکشن درست لوٹتا ہے۔تیسرا فنکشن ایک لائنر حل استعمال کرتا ہے جو سلائسنگ کا استعمال کرتے ہوئے سٹرنگ کو تبدیل کرتا ہے اور پھر اس کا موازنہ اصل تار سے کرتا ہے۔اگر دونوں ڈور برابر ہیں تو ، فنکشن درست لوٹتا ہے۔بصورت دیگر ، یہ غلط لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ میں یہ چیک کرنے کے لئے is_palindrome () فنکشن کا استعمال کیا گیا ہے کہ آیا کوئی دی گئی تعداد ایک پیلنڈرووم ہے: پائیٹوننم = 12321reslult = is_palindrome (num) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truenote کہ is_palindreom) فنکشن فرض کرتا ہے کہ ان پٹ نمبر نمبر ایک مثبت عدد ہے۔اگر ان پٹ منفی ہے یا کوئی عدد نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ نمبر اتنا بڑا نہیں ہے کہ اس کی نمائندگی کی جاسکے۔اگر ان پٹ نمبر بہت بڑا ہے تو ، فنکشن ایک غلطی کو بڑھا سکتا ہے۔"
    },
    {
        "Question": "سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور یہ چیک کرنے کے لئے کسی طریقہ کو نافذ کریں کہ آیا یہ بھرا ہوا ہے یا نہیں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو سرکلر قطار اور اس کے طریقہ کار کی نمائندگی کرتی ہے جس کی جانچ پڑتال کے ل it اس کے طریقہ کار کی نمائندگی کرتی ہے یا نہیں: پائیٹونکلاس سرکلر کیوئ: ڈیف __ __init __ (خود ، صلاحیت): خود۔ آئٹمز = [کوئی نہیں] * صلاحیت خود۔ میکس_کیو = صلاحیت خود۔ فرنٹ = 0 خود۔بیک = self.max_queue - 1 self.cont = 0 Def enqueue (خود ، آئٹم): اگر نہیں خود۔ is_full (): self.back = (self.back + 1) ٪ self.max_quee self.items [self.back] = آئٹم خودگنتی -= 1 ریٹرن آئٹم ڈیف is_full (خود): واپسی سیل۔ کاؤنٹ == سیلف۔ میکس_کیو ڈیف is_empty (خود)فہرستسامنے اور پیچھے کے متغیرات بالترتیب قطار کے پہلے اور آخری عناصر کے اشاریوں پر نظر رکھنے کے لئے استعمال ہوتے ہیں۔گنتی متغیر قطار میں موجود عناصر کی تعداد پر نظر رکھتا ہے۔enqueue () کا طریقہ کسی شے کو لے جاتا ہے اور قطار کے پچھلے حصے میں شامل کرتا ہے اگر قطار بھری نہ ہو۔اگر قطار خالی نہیں ہے تو ڈیکوئ () کا طریقہ قطار کے اگلے عنصر کو ہٹاتا ہے اور لوٹاتا ہے۔آئی ایس_فل () کا طریقہ چیک کرتا ہے کہ اگر میکس_کیو صلاحیت سے گنتی متغیر کا موازنہ کرکے قطار بھری ہوئی ہو۔IS_EMPTY () کا طریقہ چیک کرتا ہے اگر گنتی کے متغیر کا موازنہ کرکے 0. مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ ایک سرکلر کیو آبجیکٹ تیار کرتا ہے ، قطار میں کچھ اشیاء شامل کرتا ہے ، اور چیک کرتا ہے کہ قطار بھری ہوئی ہے: پائیٹونکیو = سرکلر کیوئو (5) قطار۔ enqueue (1) قطار۔ enqueue (2) قطار۔ enqueue (3) قطار۔ enqueue (4) قطار۔ enqueue (5) نتیجہ = قطار۔ is_full () پرنٹ (نتیجہ) اس کی پیداوار ہوگیسرکلر کیو کلاس فرض کرتا ہے کہ ان پٹ کی گنجائش ایک مثبت عدد ہے۔اگر ان پٹ منفی ہے یا کوئی عدد نہیں ہے تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ ان پٹ کی گنجائش اس سائز کی فہرست بنانے کے لئے اتنی بڑی نہیں ہے۔اگر ان پٹ کی گنجائش بہت بڑی ہے تو ، کلاس ایک غلطی میں اضافہ کر سکتی ہے۔"
    },
    {
        "Question": "سب سے بڑا پرائم پیلنڈرووم کسی دیئے گئے نمبر سے کم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "سب سے بڑا پرائم پیلنڈرووم کسی دیئے گئے نمبر سے کم تلاش کرنے کے ل we ، ہم پرائم نمبر اور پیلنڈرووم چیک کا مجموعہ استعمال کرسکتے ہیں۔ایسا کرنے کا ایک طریقہ یہ ہے کہ دیئے گئے نمبر سے شروع کریں اور نیچے کی طرف تکرار کریں جب تک کہ ہمیں کوئی ایسی تعداد نہ مل جائے جو پرائم اور ایک پالنڈوم دونوں ہو۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سب سے بڑی_PRIME_PALINDROME (NUM): DEF IS_PRIME (N): اگر N <2: in کے لئے غلط واپس لوٹیں (2 ، INT (n ** 0.5) + 1): اگر n ٪)i == 0: غلط واپسی سچ def is_palindrome (n): ریٹرن st (n) == str (n) [:: -1] in in range (num -1 ، 1 ، -1): اگر is_prime (is_prime (i) اور is_palindrome (i): واپسی میں واپس نونتیس فنکشن ایک نمبر ان پٹ نمبر لیتا ہوں اور پہلے دو مددگار افعال IS_PRIME () اور is_palindrome () کی وضاحت کرتا ہے کہ آیا کوئی نمبر بالترتیب پرائم اور ایک پیلنڈرووم ہے۔IS_PRIME () فنکشن چیک کرتا ہے کہ اگر کوئی نمبر 2 سے نمبر کے مربع جڑ تک پہنچنے کے ذریعہ ایک نمبر پرائم ہوتا ہے اور جانچ پڑتال کرتا ہے کہ آیا کوئی تقسیم کار نمبر کو یکساں طور پر تقسیم کرتا ہے۔is_palindrome () فنکشن چیک کرتا ہے کہ اگر کوئی نمبر ایک تار میں اس کو تار میں تبدیل کرکے اور اس کے الٹ سے موازنہ کرکے ایک پیلیندرووم ہے۔اس کے بعد مرکزی فنکشن ان پٹ نمبر سے نیچے کی طرف تکرار کرتا ہے اور ہر نمبر کی جانچ پڑتال کرتا ہے اگر یہ دونوں پرائم اور ایک پیلینڈرووم ہے۔اگر ایسی تعداد مل جاتی ہے تو ، فنکشن اسے لوٹاتا ہے۔اگر اس طرح کی کوئی تعداد نہیں ملتی ہے تو ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ کسی دیئے گئے نمبر سے کم سب سے بڑا پرائم پیلنڈرووم تلاش کرنے کے لئے سب سے بڑا_پائم_پالنڈرووم () فنکشن استعمال کرتا ہے: پائیٹونوم = 1000 ریزولٹ = سب سے بڑی_پائرم_پال انڈرووم (نمبر) یہ اس کا استعمال کرتا ہے۔آؤٹ پٹ: 929 نوٹ کریں کہ سب سے بڑا_پائم_پالینڈوم () فنکشن فرض کرتا ہے کہ ان پٹ نمبر نمبر ایک مثبت عدد ہے۔اگر ان پٹ منفی ہے یا کوئی عدد نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ نمبر سے کم سب سے بڑا پرائم پیلنڈرووم موجود ہے۔اگر اس طرح کی کوئی تعداد موجود نہیں ہے تو ، فنکشن NONT123.1github2stackoverflow3leetcode واپس نہیں آئے گا"
    },
    {
        "Question": "کسی فہرست سے کسی مخصوص عنصر کے تمام واقعات کو دور کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں کسی فہرست سے کسی مخصوص عنصر کے تمام واقعات کو دور کرنے کے ل we ، ہم فہرست کلاس کے ہٹانے () کا طریقہ استعمال کرسکتے ہیں۔ہٹانے () کا طریقہ ایک دلیل کے طور پر ایک عنصر لیتا ہے اور اس عنصر کی پہلی موجودگی کو فہرست سے ہٹاتا ہے۔اگر عنصر فہرست میں نہیں پایا جاتا ہے تو ، طریقہ کار ویلی ایرر کی رعایت کو بڑھاتا ہے۔عنصر کے تمام واقعات کو دور کرنے کے ل we ، ہم بار بار ہٹانے () کے طریقہ کار کو کال کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں جب تک کہ عنصر کو فہرست میں مزید نہیں مل پائے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف ہٹ_ال (ایل ایس ٹی ، ایلیم): جبکہ ایل ایس ٹی میں الیم: ایل ایس ٹی۔ ریمو (الیم) یہ فنکشن ایک فہرست ان پٹ ایل ایس ٹی اور ایک عنصر ان پٹ ایلم لیتا ہے ، اور بار بار ہٹانے کا طریقہ () طریقہ () کو کال کرتا ہے۔فہرست میں جب تک کہ عنصر اب فہرست میں نہیں پائے گا۔نوٹ کریں کہ یہ فنکشن ان پٹ لسٹ کو جگہ میں تبدیل کرتا ہے اور کوئی نئی فہرست واپس نہیں کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ کسی فہرست سے کسی مخصوص عنصر کے تمام واقعات کو دور کرنے کے لئے ہٹ_ال () فنکشن کا استعمال کرتا ہے: پائیتھونلسٹ = [1 ، 2 ،3 ، 2 ، 4 ، 2 ، 5] ہٹائیں_ال (LST ، 2) پرنٹ (LST) اس کی پیداوار ہوگی: [1 ، 3 ، 4 ، 5] نوٹ کریں کہ ہٹائیں_ال () فنکشن فرض کرتا ہے کہ ان پٹ لسٹ LST ایک درست فہرست ہے۔چیز.اگر ان پٹ فہرست نہیں ہے یا کوئی نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ عنصر الیم فہرست کا ایک درست عنصر ہے۔اگر عنصر فہرست میں نہیں پایا جاتا ہے تو ، فنکشن غلطی نہیں کرے گا لیکن صرف لوپ 12.1 پروگگرامیز 2 جی ای ای ایکسفورجیکس سے باہر نکل جائے گا۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کے ہندسوں کی رقم کا حساب لگانے کے لئے ایک پروگرام لکھیں جب تک کہ یہ ایک ہندسے کا نمبر نہ بن جائے۔",
        "Answer": "یہاں دیئے گئے نمبر کے ہندسوں کے مجموعہ کا حساب لگانے کے لئے یہاں ایک ازگر فنکشن ہے جب تک کہ یہ واحد ہندسہ نمبر نہ ہوجائے: پائیتھنڈف SUM_DIGITS (NUM): جبکہ نمبر> = 10: نمبر = رقم (انٹری (ہندسہ) کے لئے ہندسے کے لئے (نمبر))) واپسی نمبر اس فنکشن میں ایک نمبر ان پٹ نمبر لیتا ہے اور بار بار اس نمبر کے ہندسوں کا خلاصہ ہوتا ہے جب تک کہ نتیجہ ایک ہندسے کی تعداد نہ ہو۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا ان پٹ نمبر 10 سے زیادہ یا اس کے برابر ہے۔ اگر یہ ہے تو ، فنکشن نمبر کو اسٹرنگ میں تبدیل کرتا ہے ، جس میں ایس ٹی آر () فنکشن کا استعمال کرتے ہیں ، جنریٹر کے اظہار کا استعمال کرتے ہوئے سٹرنگ کے ذریعے تکرار کرتا ہے ، اور ہر ہندسے کو واپس تبدیل کرتا ہےانٹ () فنکشن کا استعمال کرتے ہوئے ایک عدد۔اس کے بعد رقم () فنکشن ہندسوں کو شامل کرنے کے لئے استعمال کیا جاتا ہے ، اور اس کے نتیجے میں رقم نمبر متغیر کو واپس تفویض کردی جاتی ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ نمبر 10 سے کم نہ ہو ، جس مقام پر فنکشن نمبر لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ کسی دیئے گئے نمبر کے ہندسوں کی رقم کا حساب لگانے کے لئے SUM_DIGITS () فنکشن کا استعمال کرتا ہے جب تک کہ یہ واحد ہندسے کی تعداد نہ ہوجائے۔: پائیتھوننم = 12345result = sum_digits (num) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 6 نوٹ کریں کہ Sum_digits () فنکشن یہ فرض کرتا ہے کہ ان پٹ نمبر نمبر ایک مثبت عدد ہے۔اگر ان پٹ منفی ہے یا کوئی عدد نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ نمبر کے ہندسوں کا مجموعہ بالآخر ایک ہندسہ نمبر بن جائے گا۔اگر رقم کسی ایک ہندسے کی تعداد میں تبدیل نہیں ہوتی ہے تو ، فنکشن ایک لامحدود لوپ 123.1 جی ای ای ہسفورجیکس 2 جےواٹپوائنٹ 3 کوڈسانسر داخل کرے گا۔"
    },
    {
        "Question": "ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور الفاظ کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو ایک ٹری (سابقہ درخت) کی نمائندگی کرتی ہے اور الفاظ داخل کرنے اور تلاش کرنے کے ل its اس کے طریقوں: پائیتھنکلاس ٹرائینوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈین = {} سیلف۔ آئی ایس_ ورڈ = فالسکلاس ٹری: ڈیف __init __ (خود).root = trienode () Def داخل کریں (خود ، لفظ): لفظ میں چار کے لئے نوڈ = سیلف۔node.is_word = سچے ڈیف سرچ (خود ، لفظ): لفظ میں چار کے لئے نوڈ = سیلف۔جڑ جو ٹرائیوڈ آبجیکٹ کے طور پر ٹری کے جڑ نوڈ کو محفوظ کرتی ہے۔ٹرائینوڈ کلاس میں ایک مثال کے متغیر بچے ہوتے ہیں جو موجودہ نوڈ کے چائلڈ نوڈس کو بطور لغت رکھتے ہیں ، اور ایک مثال کے طور پر متغیر IS_Word ہے جو اس بات کی نشاندہی کرتا ہے کہ آیا موجودہ نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے یا نہیں۔ٹری کلاس کے دو طریقے ہیں: داخل کریں () اور تلاش ()۔داخل () کا طریقہ ایک لفظ ان پٹ لیتا ہے اور اسے لفظ کے کرداروں کے ذریعے تکرار کرکے اور ضرورت کے مطابق نئے نوڈس بنا کر سہ رخی میں داخل کرتا ہے۔تلاش () کا طریقہ لفظ کے کرداروں کے ذریعے تکرار کرکے اور یہ جانچ پڑتال کرکے ٹرائی میں ایک لفظ ان پٹ لیتا ہے اور اس کی تلاش کرتا ہے کہ آیا ہر کردار موجودہ نوڈ کا بچہ ہے یا نہیں۔اگر کلام کا اختتام پہنچ گیا ہے اور موجودہ نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے تو ، طریقہ درست لوٹتا ہے۔بصورت دیگر ، یہ غلط لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ ایک سہ رخی آبجیکٹ تیار کرتا ہے ، کچھ الفاظ داخل کرتا ہے ، اور ان کی تلاش کرتا ہے: پائیتھونٹری = ٹری () ٹری۔ انرٹ (\"ایپل\") ٹرائی ڈاٹ انرٹ (\"کیلے\") ٹری۔داخل کریں (\"چیری\") نتیجہ 1 = trie.search (\"ایپل\") نتیجہ 2 = trie.search (\"سنتری\") پرنٹ (نتیجہ 1) پرنٹ (نتیجہ 1) پرنٹ (نتیجہ 2) اس کی پیداوار ہوگی: ٹری فالنسٹ یہ فرض کرتا ہے کہ ان پٹ الفاظ درست ہیںچھوٹے حرفوں پر مشتمل تار۔اگر ان پٹ اسٹرنگ نہیں ہے یا اس میں بڑے حرف یا دوسرے حروف شامل ہیں تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ ان پٹ الفاظ میں معروف یا پیچھے والی جگہیں نہیں ہیں۔اگر ان پٹ کے الفاظ خالی جگہوں پر مشتمل ہیں تو ، کلاس TRIE123456.1stackoverflow2askpython3Medium4geeksforgeeks5tutorialsptiplepliainglish میں غیر ضروری نوڈس تشکیل دے سکتا ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے اسٹرنگ کسی اور تار کا اناگرام ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ کسی اور تار کا اناگرام ہے ، ہم دونوں ڈوروں کے ترتیب شدہ ورژن کا موازنہ کرسکتے ہیں۔اگر ترتیب دیئے گئے ورژن برابر ہیں ، تو دونوں ڈور ایک دوسرے کے اناگرام ہیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف آئی ایس_انگگرام (ایس ٹی آر 1 ، ایس ٹی آر 2): ریٹرن سیٹڈ (ایس ٹی آر 1) == ترتیب دیا گیا (ایس ٹی آر 2) یہ فنکشن دو تار ان پٹ ایس ٹی آر 1 اور ایس ٹی آر 2 لیتا ہے اور ترتیب شدہ () فنکشن کا استعمال کرتے ہوئے ان کے ترتیب شدہ ورژن کا موازنہ کرتا ہے۔اگر ترتیب دیئے گئے ورژن برابر ہیں تو ، فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ دونوں ڈور ایک دوسرے کے اناگرام ہیں۔بصورت دیگر ، یہ غلط لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ اس بات کی جانچ پڑتال کے لئے آئی ایس_انگگرام () فنکشن کا استعمال کرتا ہے کہ آیا دیئے گئے تار کسی اور تار کا اناگرام ہے: پائیتھ اسٹرن 1 = \"سنو\" str2 = \"خاموش\" نتیجہ = is_anagram (str1 ، str2)پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truenote کہ IS_ANAGRAM () فنکشن یہ فرض کرتا ہے کہ ان پٹ اسٹرنگ STR1 اور STR2 چھوٹے حرفوں پر مشتمل درست تار ہیں۔اگر ان پٹ سٹرنگ نہیں ہے یا اس میں بڑے حرف یا دوسرے حروف شامل ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ ڈور کی لمبائی ایک ہی ہے۔اگر ان پٹ ڈور کی لمبائی مختلف ہوتی ہے تو ، فنکشن غلط واپس آجائے گا یہاں تک کہ اگر وہ ایک دوسرے کے اناگرام ہوں۔"
    },
    {
        "Question": "ایک مقررہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں جس میں کم سے کم تعداد میں تبدیلی کی ضرورت ہے۔",
        "Answer": "تبدیلی کی ایک مقدار کو بنانے کے لئے درکار سککوں کی کم سے کم تعداد تلاش کرنے کے ل we ، ہم سکے کی تبدیلی کے مسئلے کو حل کرنے کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں۔سکے میں تبدیلی کا مسئلہ ایک کلاسک اصلاح کا مسئلہ ہے جو پوچھتا ہے: سکے کے فرقوں کا ایک سیٹ اور تبدیلی کی ایک ہدف کی مقدار کو دیکھتے ہوئے ، تبدیلی کو بنانے کے لئے کم سے کم کم سے کم سککوں کی ضرورت کتنی ہے؟یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پیتھونڈف من_ کوائنز (سکے ، ہدف): ڈی پی = [فلوٹ ('انف')]]): سکے میں سکے کے ل :: اگر سکے <= i: dp [i] = منٹ (dp [i] ، dp [i - coin] + 1) DP واپس کریں [ہدف] اگر dp [ہدف]! = فلوٹ ('inf (' inf') دوسری -1 اس فنکشن میں سکے کے فرقوں کی ایک فہرست اور تبدیلی کے ہدف کی ایک ہدف رقم ہے ، اور تبدیلی کو بنانے کے لئے درکار سککوں کی کم سے کم تعداد کی گنتی کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے۔فنکشن سب سے پہلے انفینٹی ویلیوز کے ساتھ لمبائی کے ہدف + 1 کی فہرست ڈی پی کی ابتدا کرتا ہے ، سوائے پہلی قیمت کے جو 0 پر سیٹ کیا گیا ہے۔اس کے بعد فنکشن 1 سے ہدف تک ہر ایک تبدیلی کے ذریعے تکرار کرتا ہے ، اور ہر ایک رقم کے ل each ، ہر سکے کے فرق کے ذریعے تکرار کرتا ہے اور فارمولا ڈی پی [i] = منٹ (ڈی پی [i] کا استعمال کرتے ہوئے تبدیلی کو بنانے کے لئے کم سے کم تعداد کی گنتی کرتا ہے۔، ڈی پی [i - سکے] + 1)۔فنکشن ڈی پی [ہدف] کی قیمت لوٹاتا ہے اگر یہ انفینٹی نہیں ہے ، تو اس بات کی نشاندہی کرتی ہے کہ دیئے گئے سکے کے فرقوں کا استعمال کرتے ہوئے تبدیلی کی ہدف کی مقدار بھی کی جاسکتی ہے۔بصورت دیگر ، یہ -1 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ دیئے گئے سکے کے فرقوں کا استعمال کرتے ہوئے تبدیلی کی ہدف کی مقدار نہیں کی جاسکتی ہے۔تبدیل کریں: پائیٹونکوائنز = [1 ، 5 ، 10 ، 25] ہدف = 30 ریزولٹ = من_ کوائنز (سکے ، ہدف) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 2 نوٹ کہ MIN_COINS () فنکشن یہ فرض کرتا ہے کہ ان پٹ سکے کی فہرست مثبت کی ایک درست فہرست ہےانٹیجرز ، اور یہ کہ ہدف ان پٹ ایک مثبت عدد ہے۔اگر ان پٹ درست نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ دیئے گئے سکے فرقوں کا استعمال کرتے ہوئے تبدیلی کی ہدف کی مقدار بنائی جاسکتی ہے۔اگر تبدیلی کی ہدف کی مقدار نہیں کی جاسکتی ہے تو ، فنکشن -1 واپس آجائے گا یہاں تک کہ اگر دوسرے سکے کے استعمال سے کوئی حل موجود ہو۔"
    },
    {
        "Question": "فہرست میں دوسرا چھوٹا عنصر تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ازگر میں ایک فہرست میں دوسرا چھوٹا عنصر تلاش کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: فہرست کو ترتیب دیں اور دوسرا عنصر کا دوسرا طریقہ واپس ایک فہرست میں سب سے چھوٹا عنصر تلاش کریں یہ ہے کہ فہرست کو چڑھائی ترتیب میں ترتیب دیں اور دوسرا عنصر واپس کریں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سیکنڈ_سمالسٹ (ایل ایس ٹی): lst.sort () لوٹ لوٹ ایل ایس ٹی [1] اگر لین (LST)> 1 اور نیتھیس فنکشن فہرست میں ان پٹ لسٹ لیتا ہے ، ترتیب () کا استعمال کرتے ہوئے فہرست کو ترتیب دیتا ہے ()فہرست کا طریقہ ، اور اشاریہ سازی کا استعمال کرتے ہوئے ترتیب شدہ فہرست کا دوسرا عنصر واپس کرتا ہے۔اگر فہرست کی لمبائی 2 سے کم ہے تو ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔ میتھوڈ 2: فہرست میں دوسرا سب سے چھوٹا عنصر تلاش کرنے کے لئے دو متغیرات کا استعمال کرتے ہوئے کم سے کم اور دوسرے کم سے کم عناصر تلاش کریں۔دو متغیرات کا استعمال کرتے ہوئے کم سے کم اور دوسرے کم سے کم عناصر۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پیتھونڈف سیکنڈ_سمالسٹ (ایل ایس ٹی): اگر لین (لسٹ) <2: ایل ایس ٹی میں نمبر کے لئے کوئی بھی نہیں منٹ 1 = منٹ 2 = فلوٹ ('انف'): اگر نمبر <منٹ 1: منٹ 2 = منٹ 1 من 1= NUM ELIF NUM <MIN2: MIN2 = NUM ریٹرن MIN2 اس فنکشن میں ایک فہرست ان پٹ LST لیتا ہے ، پہلے چیک کرتا ہے کہ اگر فہرست کی لمبائی 2 سے کم ہے ، اور دو متغیر MIN1 اور MIN2 کو انفینٹی میں شروع کرتی ہے۔اس کے بعد فنکشن فہرست کے ذریعے تکرار کرتا ہے اور ضرورت کے مطابق MIN1 اور MIN2 کو اپ ڈیٹ کرتا ہے۔اگر کوئی نمبر MIN1 سے کم ہے تو ، MIN2 کو MIN1 میں اپ ڈیٹ کیا جاتا ہے اور MIN1 کو نمبر میں اپ ڈیٹ کیا جاتا ہے۔اگر کوئی نمبر MIN1 اور MIN2 کے درمیان ہے تو ، MIN2 کو نمبر پر اپ ڈیٹ کیا جاتا ہے۔فنکشن MIN2 کو دوسرے سب سے چھوٹے عنصر کے طور پر لوٹاتا ہے۔ میتھوڈ 3: کم سے کم تلاش کریں اور اسے ہٹا دیں ، پھر فہرست میں دوسرا سب سے چھوٹا عنصر تلاش کرنے کے لئے نیا کم سے کم تیسرا راستہ تلاش کریں ، کم سے کم عنصر تلاش کرنا ، اسے فہرست سے ہٹانا ، اورپھر نیا کم سے کم عنصر تلاش کریں۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سیکنڈ_سمالسٹ (ایل ایس ٹی): اگر لین (لسٹ) <2: کوئی بھی نہیں منٹ 1 = منٹ (LST) lst.remove (MIN1) MIN2 = MIN2 = MIN2 (LST) MIN2TIS فنکشن ایک فہرست لیتا ہےان پٹ ایل ایس ٹی ، پہلے چیک کرتا ہے کہ آیا فہرست کی لمبائی 2 سے کم ہے ، اور کم سے کم () فنکشن کا استعمال کرتے ہوئے فہرست کا کم سے کم عنصر تلاش کرتا ہے۔اس کے بعد فنکشن فہرست کے ہٹ () کے طریقہ کار کا استعمال کرتے ہوئے فہرست سے کم سے کم عنصر کو ہٹا دیتا ہے ، اور کم سے کم عنصر کو کم سے کم () فنکشن کا استعمال کرتے ہوئے تلاش کرتا ہے۔فنکشن نئے کم سے کم عنصر کو دوسرے سب سے چھوٹے عنصر کے طور پر لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ ایک فہرست میں دوسرا سب سے چھوٹا عنصر تلاش کرنے کے لئے سیکنڈ_سمالسٹ () فنکشن کا استعمال کرتا ہے: پائیتھنلسٹ = [5 ، 3 ، 1 ، 4 ، 2] نتیجہ= سیکنڈ_سمالسٹ (ایل ایس ٹی) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: دوسرا یہ کہ سیکنڈ_سمالسٹ () فنکشن فرض کرتا ہے کہ ان پٹ لسٹ ایل ایس ٹی ایک درست فہرست آبجیکٹ ہے۔اگر ان پٹ فہرست نہیں ہے یا کوئی نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ میں کم از کم دو عناصر ہوتے ہیں۔اگر ان پٹ لسٹ میں دو سے کم عناصر ہوں تو ، فنکشن NONT12345.1GITHUB2PREPINSTA3STACKOVERFLOW4W3RESOURCE5GEEKSFORGEEKS واپس آئے گا"
    },
    {
        "Question": "میٹرکس کے اضافے کے ل a ایک فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں میٹرکس کے اضافے کو انجام دینے کے ل we ، ہم میٹرکس کی نمائندگی کرنے اور میٹرک کے ہر عنصر کے ذریعے تکرار کرنے کے لئے گھریلو فہرستوں کا استعمال کرسکتے ہیں تاکہ ان کو ایک ساتھ شامل کیا جاسکے۔یہاں ایک مثال ازگر فنکشن ہے جو میٹرکس کے اضافے کو نافذ کرتا ہے: پائیتھنڈف میٹرکس_اڈیشن (میٹرکس 1 ، میٹرکس 2): اگر لین (میٹرکس 1)! = لین (میٹرکس 2) یا لین (میٹرکس 1 [0])! = لین (میٹرکس 2 [0]): کوئی بھی نتیجہ نہیں نکلا ہے= [] I میں I (LEN (میٹرکس 1)) کے لئے: قطار = [] رینج میں J کے لئے (LEN (میٹرکس 1 [0])): قطار.ایپینڈ (میٹرکس 1 [i] [J] + میٹرکس 2 [i] [J]) نتیجہ۔ اپینڈ (قطار) ریٹرن کے نتیجے میں یہ فنکشن دو میٹرکس ان پٹ میٹرکس 1 اور میٹرکس 2 کو بطور نیسٹڈ لسٹ لیتا ہے ، اور پہلے چیک کرتا ہے کہ اگر میٹرک کے طول و عرض ایک جیسے ہیں۔اگر طول و عرض ایک جیسے نہیں ہیں تو ، فنکشن کسی کو نہیں لوٹاتا ہے۔بصورت دیگر ، فنکشن میٹرکس کے اضافے کے نتیجے کو ذخیرہ کرنے کے لئے خالی فہرست کے نتائج کی ابتدا کرتا ہے ، اور نیسڈ لوپ کا استعمال کرتے ہوئے میٹرکس کے ہر عنصر کے ذریعے تکرار کرتا ہے۔ہر عنصر کے ل the ، فنکشن دونوں میٹرکس کے متعلقہ عناصر کو ایک ساتھ جوڑتا ہے اور نتیجہ کو نئی قطار کی فہرست میں شامل کرتا ہے۔اس کے بعد قطار کی فہرست کو نتائج کی فہرست میں شامل کیا گیا ہے۔فنکشن نتائج کی فہرست کو دو میٹرکس کے مجموعہ کے طور پر لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ دو میٹرک شامل کرنے کے لئے میٹرکس_اڈیشن () فنکشن کا استعمال کرتا ہے: پائیتھونمیٹرکس 1 = [[1 ، 2 ، 3] ، [4 ، 5 ، 6]، [7 ، 8 ، 9]] میٹرکس 2 = [[9 ، 8 ، 7] ، [6 ، 5 ، 4] ، [3 ، 2 ، 1]] نتیجہ = میٹرکس_ ایڈیشن (میٹرکس 1 ، میٹرکس 2) پرنٹ (نتیجہ)آؤٹ پٹ: [[10 ، 10 ، 10] ، [10 ، 10 ، 10] ، [10 ، 10 ، 10]] نوٹ کریں کہ میٹرکس_اڈیڈیشن () فنکشن یہ فرض کرتا ہے کہ ان پٹ میٹرکس میٹرکس 1 اور میٹرکس 2 اسی جہتوں کی درست گھریلو فہرستیں ہیں۔اگر ان پٹ گھریلو فہرست نہیں ہے یا میٹرکس کے طول و عرض ایک جیسے نہیں ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ میٹرکس میں کم از کم ایک قطار اور ایک کالم ہوتا ہے۔اگر ان پٹ میٹرکس میں صفر قطار یا صفر کالم ہوتے ہیں تو ، فنکشن خالی فہرست 123.1 پروگراگرامنگسمپلائڈ 2youtube3geeksforgeks واپس کرے گا۔"
    },
    {
        "Question": "ایک ہیش سیٹ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور عناصر کو داخل کرنے اور اسے دور کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس ہے جو عناصر کو داخل کرنے اور اسے ہٹانے کے لئے ہیش سیٹ اور اس کے طریقوں کی نمائندگی کرتی ہے: ازگر کلاس ہیشسیٹ: ڈیف __init __ (خود): سیلف۔ ہیشسیٹ = سیٹ () ڈیف داخل (خود ، عنصر): سیل. ہشسیٹ.ایڈ (عنصر) ڈیف(خود ، عنصر) کو ہٹا دیں: سیلف۔ ہیشسیٹ۔ ڈسکارڈ (عنصر) اس کلاس میں ایک مثال متغیر ہیش سیٹ ہے جو ہیش سیٹ کے عناصر کو سیٹ آبجیکٹ کے طور پر محفوظ کرتا ہے۔ہیشسیٹ کلاس کے دو طریقے ہیں: داخل کریں () اور ہٹائیں ()۔داخل () کا طریقہ ایک عنصر لیتا ہے اور اسے سیٹ کے ایڈ () طریقہ کا استعمال کرتے ہوئے ہیش سیٹ میں شامل کرتا ہے۔ہٹانے () کا طریقہ ایک عنصر لیتا ہے اور اسے سیٹ کے ڈسارڈ () طریقہ کا استعمال کرتے ہوئے ہیش سیٹ سے ہٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ ایک ہیشسیٹ آبجیکٹ بناتا ہے ، کچھ عناصر داخل کرتا ہے ، اور ایک عنصر کو ہٹاتا ہے: ازگر ہیشسیٹ = ہیشسیٹ () ہیشسیٹ۔ INSERT (1) ہیشسیٹ۔ INSERT (2) ہیشسیٹ۔ INSERT (3) ہیشسیٹ.میمو (2) پرنٹ (ہیشسیٹ۔ ہیشسیٹ) اس کی پیداوار ہوگی: {1 ، 3} نوٹ کریں کہ ہیشسیٹ کلاس یہ فرض کرتی ہے کہ ان پٹ عناصرہاشبل ہیں۔اگر کوئی عنصر ہاشبل نہیں ہے تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ ان پٹ عناصر متغیر نہیں ہیں۔اگر ہیش سیٹ میں ایک تغیر پزیر آبجیکٹ کو شامل کیا جاتا ہے اور پھر اس میں ترمیم کی جاتی ہے تو ، ہیش سیٹ متضاد 1234.1stackoverflow2askpython3geeksforgeeks4tutorialspoint بن سکتا ہے"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عددیوں کی ایک دی گئی فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی تلاش کرنے کے ل we ، ہم طویل عرصے تک بڑھتے ہوئے سبری مسئلے کو حل کرنے کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں۔سب سے طویل عرصہ تک بڑھتا ہوا سبری کا مسئلہ پوچھتا ہے: عددیوں کی ایک صف کو دیکھتے ہوئے ، سب سے طویل عرصے سے متضاد سبری کی لمبائی کتنی ہے کہ سبری میں ہر عنصر ایک ہی سبری میں اپنے سابقہ عنصر سے سختی سے زیادہ ہوتا ہے؟یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھونڈف طویل ترین_ان کریزنگ_سوبری (ایل ایس ٹی): اگر نہیں تو اگر نہیں تو: رینج میں 0 میکس_لن = 1 کرور_لن = 1 رینج (1 ، لین (LNST)): اگر lst [i]> lst [ist [i)-1]: curr_len += 1 اور: میکس_لن = میکس (میکس_لن ، کرور_لن) کرور_لن = 1 میکس (میکس_لن ، کریری_لن) یہ فنکشن ایک فہرست ان پٹ ایل ایس ٹی لیتا ہے ، اگر فہرست خالی ہے تو پہلے چیک کریں ، اور دو متغیرات میکس_لین کو شروع کرتے ہیں اورcurr_len to 1. فنکشن پھر لوپ کا استعمال کرتے ہوئے فہرست کے ذریعے تکرار کرتا ہے اور چیک کرتا ہے کہ آیا ہر عنصر اس کے پچھلے عنصر سے زیادہ ہے۔اگر یہ ہے تو ، کریری_لن کو 1 کی طرف سے بڑھایا جاتا ہے۔ اگر یہ نہیں ہے تو ، میکس_لن کو زیادہ سے زیادہ میکس_لن اور کرور_لن کی تازہ کاری کی جاتی ہے ، اور کرور_لن کو دوبارہ ترتیب دیا جاتا ہے۔ فنکشن میکس_لن اور کرور_لین کی زیادہ سے زیادہ بڑھتی ہوئی سبیرے کی لمبائی کے طور پر لوٹاتا ہے۔. مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ میں عدد کی ایک دی گئی فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی تلاش کرنے کے لئے طویل ترین_Increasing_subarray () فنکشن کا استعمال کیا گیا ہے: ازگر لسٹ = [5 ، 6 ، 3 ، 5 ، 7 ، 8 ، 9 ، 1 ، 1 ، 2] نتیجہ = سب سے طویل_increasing_subarray (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 5 نوٹ کریں کہ طویل ترین_ان کریزنگ_سبرے () فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ کوئی فہرست نہیں ہے یا اس میں غیر انٹیجر عناصر شامل ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ کی لمبائی کم از کم 1 ہے۔ اگر ان پٹ لسٹ خالی ہے تو ، فنکشن 012.1geksforgeeks2geeksforgeeks واپس آئے گا۔"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا کوئی دیئے گئے تار ایک درست پیلنڈرووم ہے ، صرف حفانومیرک کرداروں پر غور کریں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ ایک درست پیلنڈرووم ہے ، صرف حرفیومیرک حروف پر غور کرتے ہوئے ، ہم تمام غیر الفانومرک کرداروں کو تار سے ہٹانے کے لئے باقاعدہ اظہار کا استعمال کرسکتے ہیں اور پھر نتیجے میں ہونے والے تار کو اس کے الٹ سے موازنہ کرسکتے ہیں۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھونیمپورٹ ریڈف آئی ایس_والیڈ_پالندرووم (ایس): ایس = ری.سوب (آر '[^اے-زیڈ-زیڈ 0-9]' ، '' ، ایس)۔ایس [::-1] یہ فنکشن ایک تار ان پٹ لیتا ہے ، اس میں آر ای ایسب () کا استعمال آر ای ماڈیول سے استعمال کرتا ہے تاکہ تمام غیر الفانومرک کرداروں کو تار سے ہٹادیا جاسکے ، اور اس کے نتیجے میں تار کو چھوٹے میں تبدیل کیا جاتا ہے۔اس کے بعد فنکشن سلائسنگ کا استعمال کرتے ہوئے اس کے الٹ سے نتیجہ اخذ کرنے والے تار کا موازنہ کرتا ہے اور اگر وہ برابر ہیں تو یہ سچائی واپس کرتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اصل تار ایک درست پیلنڈرووم ہے۔بصورت دیگر ، فنکشن غلط لوٹتا ہے۔نتیجہ = is_valid_palindrome (s) پرنٹ (نتیجہ) یہ آؤٹ پٹ ہوگا: truenote کہ is_valid_palindrome () فنکشن فرض کرتا ہے کہ ان پٹ سٹرنگ s ایک درست تار ہے۔اگر ان پٹ اسٹرنگ نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ سٹرنگ میں کم از کم ایک حرفی حرف ہوتا ہے۔اگر ان پٹ سٹرنگ میں کوئی حرفی حروف نہیں ہوتا ہے تو ، فنکشن درست واپس آجائے گا یہاں تک کہ اگر سٹرنگ ایک درست palindrome123.1favtutor2leetcode3 لرن کوڈنگ فاسٹ نہیں ہے۔"
    },
    {
        "Question": "دیئے گئے تار کے ہر ممکن اجازت نامے تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں دیئے گئے تار کے ہر ممکنہ اجازت نامے پیدا کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: Itertools.permutations () کسی دیئے گئے تار کے ہر ممکنہ اجازت نامے پیدا کرنے کا ایک طریقہ یہ ہے کہ ITertools ماڈیول سے اجازت نامہ () فنکشن استعمال کریں۔یہاں ایک مثال ازگر کا فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھونیمپورٹ Itertoolsdef all_permutations (s): ریٹرن لسٹ (Itertools.permutations (s)) یہ فنکشن ایک تار ان پٹ S لیتا ہے ، Itertools ماڈیول سے پرمٹیشن () فنکشن کو استعمال کرتا ہے تاکہ ہر ممکنہ اجازت نامہ تیار کیا جاسکے۔تار کی ، اور اجازت ناموں کو بطور فہرست واپس کرتا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف آل_پرمیٹیشنز (ایس): اگر لین (ایس) == 0: لوٹ کر [] اگر لین (ایس) == 1: ریٹرن [ایس] نتیجہ = [] کے لئے رینج میں (]لین (s)): c = s [i] باقی = s [: i] + s [i + 1:] all_permutations (بقیہ) میں اجازت کے لئے: نتیجہ۔ اپینڈ (C + اجازت) واپسی کا نتیجہ یہ سٹرنگ ان پٹ لیتا ہےایس ، پہلے چیک کرتا ہے کہ آیا تار کی لمبائی 0 یا 1 ہے ، اور اگر یہ ہے تو اس کی فہرست کے طور پر اسٹرنگ کو لوٹاتا ہے۔بصورت دیگر ، فنکشن اجازت نامے کو ذخیرہ کرنے کے لئے خالی فہرست کے نتائج کی ابتدا کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے تار کے ہر کردار کے ذریعے تکرار کرتا ہے۔ہر کردار کے ل the ، فنکشن ایک ہی فنکشن کا استعمال کرتے ہوئے باقی کرداروں کی تمام ترتیب کو بار بار تیار کرتا ہے ، اور کردار کو ہر اجازت کے آغاز میں شامل کرتا ہے۔فنکشن اجازت ناموں کی فہرست لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ کسی دیئے گئے تار کے تمام ممکنہ اجازت ناموں کو پیدا کرنے کے لئے ALL_PERMUTATIONS () فنکشن کا استعمال کرتا ہے: ازگر = \"ABC\" نتیجہ = all_permutations (S) پرنٹ (نتیجہ) اس سے پیداوار ہوگی:۔اگر ان پٹ اسٹرنگ نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ سٹرنگ میں کم از کم ایک کردار ہوتا ہے۔اگر ان پٹ سٹرنگ خالی ہے تو ، فنکشن خالی فہرست 123456.1DATAGY2TUTURIALSPOINT3TECHBEAMERS4TECHIDELITELIGHT5GEEKSFORGEEKS6Program"
    },
    {
        "Question": "سرکلر سے منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس ہے جو سرکلر منسلک فہرست کی نمائندگی کرتی ہے اور اس کے طریقہ کار کو کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے لئے ہے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈی اے ٹی اے = ڈیٹا سیلف۔ نیکسٹ = نونیکلاس سرکلر لنکڈ لسٹ: ڈیف __init __ (خود):self.head = کوئی بھی Def داخل (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر سیلف ہیڈ کوئی نہیں ہے: سیلف۔ ہیڈ = نیا_نوڈ new_node.next = self.head else: curr = self.head جبکہ curr.next!= self.head: curr = curr.next curr.next = new_node new_node.next = self.head def ڈیلیٹ_ٹ_پوزیشن (خود ، پوزیشن): اگر سیلف۔ ہیڈ کوئی نہیں ہے: واپسی کرور = خود نہیں۔i <پوزیشن: prev = curr curr = curr.next i += 1 اگر کرر == سیلف ہیڈ: واپس نہیں ہے اگر پریف کوئی نہیں ہے: جبکہ curr.next! = self.head: curr = curr.next curr.next = self.ed.next self.head = self.head.next elif curr.next == self.head: prev.next = self.head else: prev.next = curr.next اس کلاس میں ایک نوڈ کلاس ہے جو نوڈ کی نمائندگی کرتا ہےسرکلر منسلک فہرست ، دو صفات کے ساتھ: ڈیٹا اور اگلا۔سرکلر لنکڈ لسٹ کلاس میں ایک مثال متغیر ہیڈ ہوتا ہے جو سرکلر لنکڈ فہرست کے ہیڈ نوڈ کو محفوظ کرتا ہے۔کلاس کے دو طریقے ہیں: داخل کریں () اور حذف کریں_ٹ_پوزیشن ()۔داخل () کا طریقہ کار میں ڈیٹا ان پٹ لیتا ہے اور سرکلر منسلک فہرست کے آخر میں ڈیٹا کے ساتھ ایک نیا نوڈ داخل کرتا ہے۔ڈیلیٹ_ٹ_پوزیشن () کا طریقہ ایک پوزیشن ان پٹ لیتا ہے اور سرکلر لنکڈ لسٹ میں اس پوزیشن پر نوڈ کو حذف کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ ایک سرکلر لنکڈ لسٹ آبجیکٹ تیار کرتا ہے ، کچھ نوڈس داخل کرتا ہے ، اور دیئے گئے پوزیشن پر نوڈ کو حذف کرتا ہے: پائیتھونکل = سرکلر لنک لسٹ.. نوٹ کریں کہ سرکلر لنکڈ لسٹ کلاس یہ فرض کرتی ہے کہ ان پٹ ڈیٹا درست ہے اور یہ کہ ان پٹ پوزیشن ایک مثبت عدد ہے۔اگر ان پٹ درست نہیں ہے تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ ان پٹ پوزیشن سرکلر منسلک فہرست کی حد میں ہے۔اگر ان پٹ پوزیشن کی حد سے باہر ہے تو ، فنکشن کسی بھی نوڈ 1234.1 ٹیوٹوریالس پوائنٹ 2 ٹیوٹورالس پوائنٹ 3 javatPoint4geeksforgeks کو حذف نہیں کرے گا"
    },
    {
        "Question": "کسی فہرست میں اکثریت عنصر (N/2 سے زیادہ ظاہر ہوتا ہے) تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "کسی فہرست میں اکثریت کا عنصر (N/2 بار سے زیادہ ظاہر ہوتا ہے) تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: کسی فہرست میں اکثریت کے عنصر کو تلاش کرنے کے ل access واقعات کو گننے کے لئے لغت کا استعمال کرنا یہ ہے کہ فہرست میں ہر عنصر کی موجودگی کو گننے کے لئے لغت کا استعمال کیا جائے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پیتھونڈف اکثریت_ایلمنٹ (LST): LST میں نمبر کے لئے شمار = {}: اگر گنتی میں نمبر: گنتی [نمبر] += 1 اور: گنتی [نمبر] = 1 نمبر کے لئے ، گنتی میں ، گنتی کریں ، گنتی کریںگنتی۔ آئٹمز (): اگر گنتی> لین (LST) / 2: ریٹرن نمبر ریٹرن ریٹرن نانتھیس فنکشن لسٹ ان پٹ لیتا ہے ، لسٹ میں ہر عنصر کی گنتی کو ذخیرہ کرنے کے لئے لغت کی گنتی کا آغاز کرتا ہے ، اور فہرست کے ہر عنصر کے ذریعے تکرار کرتا ہےلوپ کا استعمال کرتے ہوئے۔ہر عنصر کے ل the ، فنکشن چیک کرتا ہے کہ آیا یہ پہلے سے ہی گنتی کی لغت میں ہے ، اور اگر یہ ہے تو ، اس کی گنتی میں 1 اضافہ کرتا ہے۔ اگر ایسا نہیں ہے تو ، اس کو 1 کی گنتی کے ساتھ لغت میں شامل کرتا ہے۔گنتی کی لغت اور چیکوں میں سے اگر کسی عنصر میں لین (LST) / 2 سے زیادہ گنتی ہوتی ہے ، جس سے یہ ظاہر ہوتا ہے کہ یہ اکثریت کا عنصر ہے۔اگر اکثریت کا عنصر مل جاتا ہے تو ، فنکشن اسے لوٹاتا ہے۔بصورت دیگر ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔ میتھوڈ 2: فہرست میں اکثریت کے عنصر کو تلاش کرنے کے لئے چھانٹنگ کا استعمال کرنا فہرست کو ترتیب دینا ہے اور پھر چیک کرنا ہے کہ آیا درمیانی عنصر اکثریت کا عنصر ہے یا نہیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پیتھونڈف اکثریت_ایلمنٹ (LST): lst.sort () مڈ = لین (LST) // 2 اگر LST [MID] == LST [0]: لوٹ لوٹ [0] ELIF LST [مڈ] == ایل ایس ٹی [-1]: لوٹ لوٹ ایل ایس ٹی [-1] اور: ریٹرن نانتھیس فنکشن ایک فہرست میں ان پٹ لیتا ہے ، فہرست کے ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے فہرست کو ترتیب دیتا ہے ، اور عدد کا استعمال کرتے ہوئے فہرست کا درمیانی عنصر تلاش کرتا ہے۔ڈویژناس کے بعد یہ کام چیک کرتا ہے کہ آیا درمیانی عنصر فہرست کے پہلے عنصر یا فہرست کے آخری عنصر کے برابر ہے۔اگر یہ ہے تو ، فنکشن درمیانی عنصر کو اکثریتی عنصر کے طور پر لوٹاتا ہے۔بصورت دیگر ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: دوسرا نوٹ کہ اکثریت_ایلمنٹ () فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ کوئی فہرست نہیں ہے یا اس میں غیر انٹیجر عناصر شامل ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ میں کم از کم ایک عنصر ہوتا ہے۔اگر ان پٹ لسٹ خالی ہے تو ، فنکشن کوئی بھی نہیں لوٹائے گا۔"
    },
    {
        "Question": "یہاں تک کہ کسی بھی حد تک فبونیکی نمبروں کی رقم کا حساب لگانے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی بھی حد تک فبونیکی نمبروں کے جوڑے کا حساب لگانے کے ل we ، ہم فبونیکی ترتیب پیدا کرنے اور یہاں تک کہ نمبروں کو شامل کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھونڈف ایور_فیبوناکسی_سم (حد): اے ، بی = 1 ، 2 کل = 0 جبکہ ایک <= حد: اگر اے ٪ 2 == 0: کل += اے ، بی = بی ، اے+ B ریٹرن کل یہ فنکشن ایک حد ان پٹ کی حد لیتا ہے ، دو متغیرات A اور B کو بالترتیب 1 اور 2 سے شروع کرتا ہے ، اور ایک متغیر کل کو 0 پر شروع کرتا ہے۔ اس کے بعد فنکشن ایک لوپ میں داخل ہوتا ہے جو A اور B کو ایک ساتھ شامل کرکے اور تبدیل کرکے فبونیکی ترتیب پیدا کرتا ہےان کی اقدار۔A کی ہر قیمت کے ل the ، فنکشن چیک کرتا ہے کہ آیا یہ ماڈیولو آپریٹر کا استعمال بھی کررہا ہے ، اور اگر یہ ہے تو ، اسے کل میں شامل کرتا ہے۔فنکشن لوپ کو جاری رکھے گا جب تک کہ A حد سے زیادہ نہ ہو۔آخر میں ، فنکشن کل کو دیئے گئے حد تک تمام فیبونیکی نمبروں کے مجموعہ کے طور پر لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ ایک دیئے گئے حد تک یہاں تک کہ فبونیکی نمبروں کی رقم کا حساب لگانے کے لئے Eve_fibonacci_sum () فنکشن کا استعمال کرتا ہے: Pythonlimit= 400result = eve_fibonacci_sum (حد) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 188 نوٹ کریں کہ Eve_fibonacci_sum () فنکشن یہ فرض کرتا ہے کہ ان پٹ کی حد ایک مثبت عدد ہے۔اگر ان پٹ مثبت عدد نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ بھی فرض کرتا ہے کہ فبوناکی ترتیب 1 اور 2 کے ساتھ شروع ہوتی ہے۔ اگر ترتیب مختلف اقدار سے شروع ہوتی ہے تو ، فنکشن صحیح تسلسل 123456.1 جی ای ای ای ایس ایف ایس 2 اسٹیک اوور فلو 3 پی وائی ٹی آر او ایس او ایل ویور 4 اسٹیک ایکسچینج 6 پلینجلیش نہیں پیدا کرے گا۔"
    },
    {
        "Question": "اندراج ترتیب والے الگورتھم کا استعمال کرتے ہوئے تاروں کی فہرست کو ترتیب دینے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "اندراج کی ترتیب الگورتھم کا استعمال کرتے ہوئے تاروں کی فہرست کو ترتیب دینے کے لئے یہاں ایک ازگر پروگرام ہے: پیتھونڈف داخلہ_سورٹ (LST): I میں رینج (1 ، لین (LST)) کے لئے: کلیدی = lst [i] j = i - 1 جبکہ j> =0 اور لین (کلید) <لین (lst [j]): lst [j + 1] = lst [j] j -= 1 lst [j + 1] = کلیدی واپسی lstthis فنکشن ایک فہرست میں ان پٹ لسٹ لیتا ہے اور اس میں اضافے کا اطلاق کرتا ہےان کی لمبائی کی بنیاد پر چڑھنے والے ترتیب میں تاروں کی فہرست کو ترتیب دینے کے لئے الگورتھم کو ترتیب دیں۔فنکشن دوسرے عنصر سے شروع ہونے والی لوپ کا استعمال کرتے ہوئے فہرست کے ہر عنصر کے ذریعے تکرار کرتا ہے۔ہر عنصر کے ل the ، فنکشن عنصر کو ذخیرہ کرنے کے لئے ایک متغیر کلید ، اور پچھلے عنصر کے اشاریہ کو اسٹور کرنے کے لئے ایک متغیر J کی ابتدا کرتا ہے۔اس کے بعد فنکشن ایک لوپ میں داخل ہوتا ہے جو کلید کی لمبائی کو پچھلے عنصر کی لمبائی سے موازنہ کرتا ہے ، اور پچھلے عنصر کو دائیں طرف منتقل کرتا ہے اگر اس کی لمبائی کلید کی لمبائی سے زیادہ ہو۔فنکشن اس وقت تک لوپ جاری رکھے گا جب تک کہ اسے کلید کے لئے صحیح پوزیشن نہ مل جائے ، اور اسے اس پوزیشن پر داخل نہ کرے۔آخر میں ، فنکشن ترتیب شدہ فہرست کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ تار کی فہرست کو ترتیب دینے کے لئے داخلہ_سورٹ () فنکشن کا استعمال کرتا ہے: پائیٹونلسٹ = ['ایپل' ، 'کیلے' ، 'ناشپاتیاں' ، 'سنتری' ، 'کیوی'] نتیجہ = اندراج_سورٹ (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: [' کیوی '،' ناشپاتیاں '،' ایپل '،' کیلے '،' اورنج '] نوٹ کریں کہ اندراج_سورٹ () فنکشن فرض کرتا ہے کہ ان پٹ کی فہرست LST LSTڈور کی ایک درست فہرست ہے۔اگر ان پٹ کوئی فہرست نہیں ہے یا اس میں غیر تار والے عناصر شامل ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ میں کم از کم ایک عنصر ہوتا ہے۔اگر ان پٹ لسٹ خالی ہے تو ، فنکشن خالی فہرست 123.1dremendo2programiz3javatPoint واپس کرے گا"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "عدد کی ایک دی گئی فہرست میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے بہت سے طریقے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: عددیوں کی ایک دی گئی فہرست میں زیادہ سے زیادہ سبریے کی رقم تلاش کرنے کا کڈانے کا الگورتھمون طریقہ کڈانے کے الگورتھم کو استعمال کرنا ہے۔کڈانے کا الگورتھم ایک متحرک پروگرامنگ الگورتھم ہے جو لکیری وقت میں عددیوں کی ایک دی گئی فہرست میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرتا ہے۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھونڈف میکس_سوبری_سم (ایل ایس ٹی): میکس_سو_فار = ایل ایس ٹی [0] میکس_نینڈنگ_ہری = ایل ایس ٹی [0] I IN کے لئے (1 ، لین (LST)): میکس_نینڈنگ_ہری = میکس (LST [i]میکس_نینڈنگ_ہیر + ایل ایس ٹی [i]) میکس_سو_فار = زیادہ سے زیادہ (میکس_سو_فار ، میکس_ننگ_ہیر) واپسی میکس_سو_فارٹس فنکشن ایک فہرست ان پٹ لسٹ لیتا ہے ، فہرست کے پہلے عنصر کا استعمال کرتے ہوئے دو متغیرات میکس_سو_فر اور میکس_نینڈنگ_ہیر کو شروع کرتا ہے ، اور اس فہرست کے ہر عنصر کا استعمال کرتے ہیں ، اور اس کی فہرست کے ہر عنصر کے ذریعہ ، اور اس کی فہرست میں ہر عنصر کے ذریعے کام کیا جاتا ہے ، اور اس کی فہرست میں ہر عنصر کے ذریعے دو متغیرات کو شروع کرتا ہے۔دوسرے عنصر سے شروع ہو رہا ہے۔ہر عنصر کے ل the ، فنکشن میکس_نینڈنگ_ہیر کو موجودہ عنصر کی زیادہ سے زیادہ اور موجودہ عنصر اور میکس_نینڈنگ_ہیر کے جوڑے پر تازہ کاری کرتا ہے ، اور زیادہ سے زیادہ میکس_سو_فار اور میکس_نینڈنگ_ہیر کی زیادہ سے زیادہ میں میکس_سو_فار کو اپ ڈیٹ کرتا ہے۔فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ وہ فہرست کے اختتام تک نہ پہنچے ، اور زیادہ سے زیادہ سبراے رقم کے طور پر میکس_سو_فار کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ انٹیجرز کی ایک دی گئی فہرست میں زیادہ سے زیادہ سبراے رقم تلاش کرنے کے لئے میکس_سوبری_سم () فنکشن کا استعمال کرتا ہے: پائیٹھلسٹ= [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، 1 ، -5 ، 4] نتیجہ = زیادہ سے زیادہ_سوبری_سم (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 6 میتھوڈ 2: زیادہ سے زیادہ سبری کا خلاصہ تلاش کرنے کے لئے بریٹ فورسین کا طریقہانٹیجرز کی ایک دی گئی فہرست میں بروٹ فورس کا استعمال کرنا ہے۔بروٹ فورس کے نقطہ نظر میں فہرست کے ہر ممکنہ ذیلی حصے کی جانچ کرنا اور زیادہ سے زیادہ رقم تلاش کرنا شامل ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف میکس_سوبری_سم (ایل ایس ٹی): میکس_سم = ایل ایس ٹی [0] رینج (لین (ایل ایس ٹی)) کے لئے: رینج میں جے کے لئے (I ، لین (LST)): subarray_sum = sum (subarray_sum = sum (subarray_sum = sum (subarray_sum)LST [i: J+1]) میکس_سم = زیادہ سے زیادہ (میکس_سم ، سبری_سم) ریٹرن میکس_سومی فنکشن ایک فہرست ان پٹ لسٹ لیتا ہے ، فہرست کے پہلے عنصر میں ایک متغیر میکسم کو شروع کرتا ہے ، اور نیسڈ لوپوں کا استعمال کرتے ہوئے فہرست کے ہر ممکنہ ذیلی حصے میں تکرار کرتا ہے۔ہر سبریے کے ل the ، فنکشن فہرست کے مجموعہ () فنکشن کا استعمال کرتے ہوئے سبری کے جوڑے کا حساب لگاتا ہے ، اور میکس_سم کو زیادہ سے زیادہ میکس_سم اور سبری کے جوڑے میں اپ ڈیٹ کرتا ہے۔فنکشن اس وقت تک جاری رہتا ہے جب تک کہ وہ فہرست کے ہر ممکنہ ذیلی حصے کی جانچ نہ کرے ، اور زیادہ سے زیادہ سبری کے طور پر میکس_سم کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ انٹیجرز کی دی گئی فہرست میں زیادہ سے زیادہ سبراے رقم تلاش کرنے کے لئے میکس_سوبری_سم () فنکشن کا استعمال کرتا ہے:pythonlst = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] نتیجہ = میکس_سوبری_سم (LST) پرنٹ (نتیجہ) اس سے آؤٹ پٹ ہوجائے گا: 6 نوٹ کریں کہ میکس_سوبری_سم () فنکشن یہ فرض کرتا ہے کہ ان پٹفہرست LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ کوئی فہرست نہیں ہے یا اس میں غیر انٹیجر عناصر شامل ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ لسٹ میں کم از کم ایک عنصر ہوتا ہے۔اگر ان پٹ لسٹ خالی ہے تو ، فنکشن ایک غلطی کو بڑھا دے گا۔"
    },
    {
        "Question": "ایک ازگر کی کلاس لکھیں جو ہدایت والے وزن والے گراف کی نمائندگی کرتے ہیں اور کناروں کو شامل کرنے اور ڈجکسٹرا کے الگورتھم کو انجام دینے کے طریقوں کو نافذ کرتے ہیں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو ہدایت شدہ وزن والے گراف کی نمائندگی کرتی ہے اور اس کے طریقوں کو شامل کرنے اور ڈجکسٹرا کے الگورتھم کو انجام دینے کے ل methods اس کے طریقوں: پائیتھونیمپورٹ ہیپق کلاس گراف: ڈیف __init __ (خود): self.nodes = set () self.edges = {} def_eded_nodeto_node ، وزن): self.nodes.add (from_node) self.nodes.add (to_node) اگر from_node sellڈجکسٹرا (خود ، start_node): فاصلوں = {نوڈ: فلوٹ ('انف') نوڈ کے لئے نوڈ کے لئے۔ نوڈس} فاصلوں [start_node] = 0 pq = [(0 ، start_nod..کلاس کے دو طریقے ہیں: add_edge () اور dijkstra ()۔ADD_EDGE () کا طریقہ تین آدانوں میں لیتا ہے: from_node ، to_node ، اور وزن ، اور دیئے گئے وزن سے _Node سے TO_Node تک دیئے گئے وزن کے ساتھ ایک ہدایت نامہ شامل کرتا ہے۔ڈجکسٹرا () کا طریقہ ایک اسٹارٹ_ نوڈ ان پٹ لیتا ہے اور گراف میں موجود دیگر تمام نوڈس تک اسٹارٹ_نوڈ سے مختصر فاصلوں کو تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو انجام دیتا ہے۔یہ طریقہ فاصلوں کی لغت کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ ایک گراف آبجیکٹ تیار کرتا ہے ، کچھ کناروں کو شامل کرتا ہے ، اور ڈجکسٹرا کا الگورتھم انجام دیتا ہے: ازگر گراف = گراف () گراف.اڈی_ج ('اے' ، 'بی' ، 5) گراف۔add_edge ('a' ، 'c' ، 3) گراف.اڈی_ج ('بی' ، 'سی' ، 1) گراف.اڈی_ج ('بی' ، 'ڈی' ، 2) گراف.اڈی_ج ('سی' ، 'ڈی'، 4) دوری = گراف.ڈیجکسٹرا (' اے ') پرنٹ (فاصلوں) اس کی پیداوار ہوگی: {' A ': 0 ،' B ': 5 ،' C ': 3 ،' D ': 7} نوٹ کریں کہگراف کلاس فرض کرتا ہے کہ ان پٹ نوڈس اور وزن درست ہیں۔اگر ان پٹ درست نہیں ہے تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ ان پٹ گراف منسلک ہے۔اگر گراف منسلک نہیں ہے تو ، فنکشن کو تمام نوڈس 123456.1youtube2stackabuse3educative4github5builtin6idacity کے لئے مختصر ترین فاصلے نہیں مل سکتے ہیں۔"
    },
    {
        "Question": "تار سے تمام ڈپلیکیٹ حروف کو ہٹانے اور اصل ترتیب کو برقرار رکھنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "اصل آرڈر کو برقرار رکھتے ہوئے تمام ڈپلیکیٹ حروف کو اسٹرنگ سے ہٹانے کے ل we ، ہم تار میں منفرد کرداروں کو ٹریک رکھنے کے لئے ایک فہرست اور ایک سیٹ استعمال کرسکتے ہیں جو پہلے ہی دیکھے گئے کرداروں کا سراغ لگائیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف ہٹانے_ڈیپلیکیٹس (زبانیں): دیکھا = سیٹ () منفرد = [] ایس میں چار کے لئے: اگر چار نہیں دیکھا گیا: دیکھا گیا۔'.جین (منفرد) یہ فنکشن ایک تار ان پٹ ایس لیتا ہے ، ان حروف کو ذخیرہ کرنے کے لئے دیکھا گیا ایک خالی سیٹ شروع کرتا ہے جو پہلے ہی دیکھا گیا ہے ، اور تار میں منفرد کرداروں کو ذخیرہ کرنے کے لئے منفرد ایک خالی فہرست شروع کرتا ہے۔اس کے بعد فنکشن لوپ کا استعمال کرتے ہوئے تار کے ہر کردار کے ذریعے تکرار کرتا ہے ، اور چیک کرتا ہے کہ اگر کردار پہلے سے ہی دیکھا ہوا سیٹ میں ہے۔اگر یہ نہیں ہے تو ، فنکشن کردار کو دیکھنے والے سیٹ میں شامل کرتا ہے اور اسے منفرد فہرست میں شامل کرتا ہے۔فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ وہ تار کے ہر کردار کی جانچ نہ کرے ، اور سٹرنگ کے طور پر انوکھی فہرست کو لوٹائے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ اصل ترتیب کو برقرار رکھتے ہوئے سٹرنگ سے تمام ڈپلیکیٹ حروف کو ہٹانے کے لئے ہٹ_ ڈوپلیکیٹس () فنکشن کا استعمال کرتا ہے۔ازگر = 'geeksforgeeks'result = remost_duplicates (s) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: geksfornote کہ remost_duplicates () فنکشن فرض کرتا ہے کہ ان پٹ سٹرنگ s ایک درست تار ہے۔اگر ان پٹ اسٹرنگ نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ ان پٹ سٹرنگ میں کم از کم ایک کردار ہوتا ہے۔اگر ان پٹ سٹرنگ خالی ہے تو ، فنکشن خالی سٹرنگ 12345.1geeksforgeeks2geeksforgeeks3w3resource4codescracker5stackoverflow واپس کرے گا"
    },
    {
        "Question": "\"کسی مخصوص تعداد میں سیڑھی پر چڑھنے کے طریقوں کی تعداد تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں ، اس بات پر غور کرتے ہوئے کہ آپ ایک وقت میں 1 یا 2 قدم اٹھاسکتے ہیں۔\"",
        "Answer": "ایک دیئے گئے تعداد کے ساتھ سیڑھی پر چڑھنے کے طریقوں کی تعداد تلاش کرنے کے ل ، ، اس بات پر غور کرتے ہوئے کہ آپ ایک وقت میں 1 یا 2 قدم اٹھاسکتے ہیں ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔اس الگورتھم کو نافذ کرنے کے بہت سے طریقے ہیں ، لیکن سب سے عام نقطہ نظر فبونیکی تسلسل کو استعمال کرنا ہے۔اس مسئلے کو حل کرنے کے لئے یہاں اقدامات ہیں: اگر اقدامات کی تعداد 0 یا 1 ہے تو ، سیڑھیاں پر چڑھنے کا ایک ہی راستہ ہے۔ اگر اقدامات کی تعداد 1 سے زیادہ ہے تو ، ہم فبوناکی ترتیب کو استعمال کرسکتے ہیں تاکہ اس کی تعداد تلاش کی جاسکے۔سیڑھی پر چڑھنے کے طریقے۔نویں مرحلے پر چڑھنے کے طریقوں کی تعداد (N-1) ویں قدم پر چڑھنے کے طریقوں کی تعداد اور (N-2) ویں قدم پر چڑھنے کے طریقوں کی تعداد کے برابر ہے۔ یہاں ایک مثال ہے کہ ازگر کی ایک مثال ہے۔یہ اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف چڑھنے_سٹیئرز (این): اگر n == 0 یا n == 1: رینج (2 ، n + 1) میں 1 کے لئے 1 پریو 1 = 1 پریو 2 = 1 واپس کریں: کرر = پریف 1 + پریو 2 پریو 2 = پریو 1پری 1 = کرر ریٹرن کریوس فنکشن سیڑھی میں اقدامات کی تعداد کی نمائندگی کرنے والے ایک عدد ان پٹ لیتا ہے ، اور سیڑھی پر چڑھنے کے طریقوں کی تعداد کو واپس کرتا ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا اقدامات کی تعداد 0 یا 1 ہے ، اور اگر 1 ہے تو 1 ، اور اگر یہ ہے۔بصورت دیگر ، فنکشن دو متغیرات پرو 1 اور پریو 2 سے 1 سے شروع کرتا ہے ، اور تیسرے مرحلے سے شروع ہونے والے ، لوپ کا استعمال کرتے ہوئے سیڑھیاں کے ہر مرحلے میں تکرار کرتا ہے۔ہر مرحلے کے ل the ، فنکشن اس مرحلے پر چڑھنے کے طریقوں کی تعداد کا حساب لگاتا ہے جیسے پرو 1 اور پریو 2 ، پریو 2 کو پری 2 کو اپ ڈیٹ کرتا ہے ، اور موجودہ طریقوں کی موجودہ تعداد میں پریو 1 کو اپ ڈیٹ کرتا ہے۔فنکشن لوپ کو جاری رکھے گا جب تک کہ وہ نویں مرحلے تک نہ پہنچے ، اور سیڑھیاں پر چڑھنے کے طریقوں کی تعداد کے طور پر موجودہ طریقوں کی تعداد کو واپس کردیتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ چڑھنے کے طریقوں کی تعداد تلاش کرنے کے لئے چڑھنے_سٹیور () فنکشن کا استعمال کرتا ہے۔ایک سیڑھیوں کے ساتھ ایک سیڑھیاں جس میں ایک دیئے گئے اقدامات ہیں: پائیتھن = 5 ریزولٹ = چڑھنے_سٹیئرز (این) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 8 نوٹ کریں کہ چڑھنے_سٹیئرز () فنکشن یہ فرض کرتا ہے کہ ان پٹ این ایک درست مثبت عدد ہے۔اگر ان پٹ ایک مثبت عدد نہیں ہے تو ، فنکشن متوقع 123456.1Interviewibit2geEKSFORGEEKS3ENAYALGORITHMS4GEEKSFORGEEKS5FAVTOUTOURDEV کے طور پر کام نہیں کرسکتا ہے"
    },
    {
        "Question": "کسی دیئے گئے تار میں ہر کردار کے واقعات کی تعداد کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ہر کردار کے واقعات کی تعداد کو کسی دیئے گئے تار میں گننے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: دیئے گئے تار میں ہر کردار کے واقعات کی تعداد کو گننے کے لئے ایک لغت کا طریقہ استعمال کرنا ہر کردار کی گنتی کو ذخیرہ کرنے کے لئے لغت کا استعمال کرنا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف کاؤنٹی_چارٹرز (زبانیں): گنتی = {} s کے لئے چار میں: اگر گنتی میں چار: گنتی [چار] += 1 کوئی اور: گنتی [چار]سٹرنگ ان پٹ ایس ، ہر کردار کی گنتی کو تار میں ذخیرہ کرنے کے لئے ایک خالی لغت گنتی کا آغاز کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے تار کے ہر کردار کے ذریعے تکرار کرتا ہے۔ہر کردار کے ل the ، فنکشن چیک کرتا ہے کہ آیا یہ پہلے سے ہی گنتی کی لغت میں ہے ، اور اگر یہ ہے تو ، اس کی گنتی میں 1 اضافہ کرتا ہے۔ اگر ایسا نہیں ہے تو ، اس کو لغت میں شامل کرتا ہے۔جیسا کہ سٹرنگ میں ہر کردار کی گنتی ہوتی ہے۔(نتیجہ) اس کی پیداوار: {'H': 1 ، 'E': 1 ، 'L': 3 ، 'O': 2 ، '': 1 ، 'W': 1 ، 'r': 1 ، 'D ': 1} طریقہ 2: دیئے گئے تار میں ہر کردار کے واقعات کی تعداد کو گننے کے لئے سٹرنگ گنتی () طریقہ کار کا استعمال کرتے ہوئے سٹرنگ گنتی () طریقہ استعمال کرنا ہے۔گنتی () کا طریقہ دیئے گئے تار میں کسی سٹرنگ کے واقعات کی تعداد کو لوٹاتا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف کاؤنٹی_چارٹرز (زبانیں): گنتی = {} چار میں چار کے لئے: گنتی [چار] = ایس کاؤنٹ (چار) ریٹرن گنتی ایک سٹرنگ ان پٹ لیتا ہے ، خالی لغت گنتی کا آغاز کرتا ہے۔ہر کردار کی گنتی کو تار میں ذخیرہ کرنے کے ل and ، اور لوپ کا استعمال کرتے ہوئے تار کے ہر کردار کے ذریعے تکرار کرتا ہے۔ہر کردار کے ل the ، فنکشن اسٹرنگ کی گنتی () کا طریقہ استعمال کرتا ہے تاکہ تار میں کردار کے واقعات کی تعداد کو گننے کے ل. ، اور اسے گنتی کی لغت میں شامل کرتا ہے۔اس کے بعد فنکشن کا شمار لغت کو تار میں ہر کردار کی گنتی کے طور پر لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ ایک دیئے گئے تار میں ہر کردار کے واقعات کی تعداد کو گننے کے لئے COUNT_CHARACTERS () فنکشن کا استعمال کرتا ہے: ازگر = 'ہیلو ورلڈ'نتیجہ = گنتی_چارٹرز (زبانیں) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: {'H': 1 ، 'E': 1 ، 'L': 3 ، 'O': 2 ، '': 1 ، 'W': 1 ، 1 ،'r': 1 ، 'd': 1} نوٹ کریں کہ دونوں طریقے یہ فرض کرتے ہیں کہ ان پٹ سٹرنگ ایس ایک درست تار ہے۔اگر ان پٹ اسٹرنگ نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال ہر کردار کو الگ سے گنتے ہیں ، بشمول وائٹ اسپیس اور اوقاف۔اگر آپ وائٹ اسپیس یا اوقاف کو خارج کرنا چاہتے ہیں تو ، آپ اس کے مطابق افعال میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "ایک ازگر کلاس بنائیں جس میں سرکلر دوگنا منسلک فہرست کی نمائندگی کی جائے اور آخر میں نوڈ داخل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو سرکلر دوگنا منسلک فہرست کی نمائندگی کرتی ہے اور اس کے آخر میں ایک نوڈ داخل کرنے کے طریقہ کار کی نمائندگی کرتی ہے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ = کوئی بھی نہیں۔__init __ (خود): self.head = کوئی بھی Def داخل_ایٹ_ینڈ (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر سیلف ہیڈ کوئی نہیں ہے: خود نہیں ہے۔self.head.prev last_node.next = new_node new_node.prev = last_node new_node.next = self.head self.head.prev = new_nodethis کلاس میں ایک نوڈ کلاس ہے جو سرکلر ڈبل سے منسلک فہرست میں نوڈ کی نمائندگی کرتا ہے ، تین مثال کے متغیر ڈیٹا کے ساتھ، اگلا ، اور پچھلا۔کلاس میں ایک سرکولارڈبل لنکڈ لسٹ کلاس ہے جو ایک مثال کے متغیر ہیڈ کے ساتھ سرکلر دوگنا منسلک فہرست کی نمائندگی کرتی ہے۔کلاس کے پاس ایک طریقہ داخل کریں۔یہ طریقہ پہلے چیک کرتا ہے کہ آیا سر کوئی نہیں ہے ، اور اگر یہ ہے تو ، سر کو نئے نوڈ پر سیٹ کرتا ہے اور نئے نوڈ کے اگلے اور پری پوائنٹرز کو خود پر سیٹ کرتا ہے۔بصورت دیگر ، اس طریقہ کار کو سر کے پری پوائنٹر کا استعمال کرتے ہوئے سرکلر دوگنا منسلک فہرست کا آخری نوڈ مل جاتا ہے ، اور آخری نوڈ کے بعد آخری نوڈ کے بعد آخری نوڈ اور نئے نوڈ کے اگلے اور پری پوائنٹرز کو داخل کرتا ہے۔ مثال کے طور پر ، مثال کے طور پر ،مندرجہ ذیل ازگر کا کوڈ ایک سرکلرڈبللی لنکڈ لسٹ آبجیکٹ تیار کرتا ہے ، آخر میں کچھ نوڈس داخل کرتا ہے ، اور نوڈس کے اعداد و شمار کو پرنٹ کرتا ہے: پائیتھونک ڈیل = سرکلرڈیول لنکڈ لسٹ () CDLL.INSERT_AT_END (1) CDLL.INSERT_AT_END (2) CDLL.INSERT_END (2) CDLL.INSERT_END.edhile node.next! = cdll.head: پرنٹ (نوڈ.ڈیٹا) نوڈ = نوڈ. نیکسٹ پرنٹ (نوڈ ڈاٹ ڈیٹا) اس کی پیداوار ہوگی: 123 نوٹ کریں کہ سرکولرڈیول لنکڈ لسٹ کلاس یہ فرض کرتی ہے کہ ان پٹ ڈیٹا درست ہے۔اگر ان پٹ درست نہیں ہے تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ سرکلر دوگنا منسلک فہرست خالی نہیں ہے۔اگر سرکلر دوگنا منسلک فہرست خالی ہے تو ، داخل_ایٹ_ینڈ () کا طریقہ توقع کے مطابق 123456.1 ٹیوٹورالس پوائنٹ 2 ایلفاکوڈنگسکلس 3 جےواٹ پوائنٹ 4 ایلفاکوڈنگز کِل ایس 5 ٹیوٹوریلس پوائنٹ 6 جی ای ای ایکسفورجیکس کے طور پر کام نہیں کرسکتا ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا دیئے گئے تار ایک درست قوسین کا اظہار ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے سٹرنگ ایک درست قوسین کا اظہار ہے ، ہم افتتاحی قوسین کو ٹریک رکھنے کے لئے اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں اور یہ چیک کرسکتے ہیں کہ آیا ہر اختتامی قوسین حالیہ ابتدائی قوسین سے مماثل ہے یا نہیں۔یہاں ازگر کے افعال کی کچھ مثالیں ہیں جو اس نقطہ نظر کو نافذ کرتی ہیں: طریقہ 1: ایک اسٹیک اور لغت کا استعمال کرتے ہوئے یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ ایک درست قوسین کا اظہار ہے کہ افتتاحی اور بند ہونے والے قوسین کو ذخیرہ کرنے کے لئے اسٹیک اور لغت کا استعمال کرنا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف is_valid_parentheses (s): اسٹیک = [] میپنگ = {\")\": \"(\" ، \"}\": \"{\" ، \"]\": \"[\" char چار کے لئے چار کے لئےایس: اگر میپنگ میں چار: ٹاپ_یلیمنٹ = اسٹیک.پپ () اگر اسٹیک اور اسٹیک اور '' اگر میپنگ [چار]! = ٹاپ_یلیمنٹ: غلط لوٹنا: اسٹیک ۔پینڈ (چار) ریٹرن نہیں اسٹیک اس فنکشن میں ایک تار ان پٹ لیتا ہے ، ایک شروع کرتا ہے ، ایک شروع کرتا ہے۔افتتاحی قوسین کو ذخیرہ کرنے کے لئے خالی اسٹیک اسٹیک اسٹیک ، اور افتتاحی اور بند ہونے والے قوسین کو ذخیرہ کرنے کے لئے ایک لغت کی نقشہ سازی کا آغاز کرتا ہے۔ اس کے بعد یہ کام لوپ کا استعمال کرتے ہوئے تار کے ہر کردار کے ذریعے تکرار کرتا ہے ، اور چیک کرتا ہے کہ اگر کردار بند ہونے والی قوسین ہے۔فنکشن اسٹیک سے حالیہ افتتاحی قوسین کو پاپ کرتا ہے اور چیک کرتا ہے کہ اگر یہ میپنگ لغت کا استعمال کرتے ہوئے اختتامی قوسین سے میل کھاتا ہے۔ اگر یہ مماثل نہیں ہوتا ہے تو ، فنکشن غلط لوٹتا ہے۔ اگر کردار اختتامی قوسین نہیں ہے تو ، فنکشن اسے اس میں شامل کرتا ہے۔اسٹیکفنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ یہ تار کے ہر کردار کی جانچ نہ کرے ، اور اگر اسٹیک خالی ہے تو سچائی واپس آجائے گا ، اس بات کی نشاندہی کرتی ہے کہ تمام افتتاحی قوسین بند ہونے والے قوسین کے ساتھ مماثل ہیں۔اگر دیئے گئے تار ایک درست قوسین کا اظہار ہے: ازگر = '() [] {}' نتیجہ = is_valid_parentheses (s) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truemethod 2: ایک اسٹیک کا استعمال کرتے ہوئے اور اگر Else کے بیانات کا استعمال کرتے ہیں تو ایکدیئے گئے اسٹرنگ ایک درست قوسین کا اظہار ہے جو ہر افتتاحی اور بند ہونے والے قوسین کو چیک کرنے کے لئے اسٹیک اور اگر الیس بیانات کا استعمال کرنا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف is_valid_parentheses (s): stac = [] S کے لئے S: اگر چار == '(' یا چار == '[' یا چار == '{': اسٹیک.ایپینڈ(چار) ایلف چار == ')' اور اسٹیک اور اسٹیک [-1] == '(': اسٹیک.پپ () ایلف چار == ']' اور اسٹیک اور اسٹیک [-1] == '[':اسٹیک.پپ () ایلف چار == '}' اور اسٹیک اور اسٹیک [-1] == '{': stac.pop () اور: غلط واپسی نہیں اسٹیک اس فنکشن میں تار ان پٹ لیتا ہے ، خالی اسٹیک اسٹیک کو شروع کرتا ہےافتتاحی قوسین کو ذخیرہ کرنے کے ل and ، اور لوپ کا استعمال کرتے ہوئے تار کے ہر ایک کردار کے ذریعے تکرار کرتا ہے۔ ہر کردار کے لئے ، فنکشن چیک کرتا ہے کہ اگر یہ افتتاحی قوسین ہے ، اور اگر یہ ہے تو ، اسے اسٹیک میں شامل کرتا ہے۔فنکشن چیک کرتا ہے کہ آیا اسٹیک خالی نہیں ہے اور حالیہ افتتاحی قوسین بند ہونے والی قوسین سے میل کھاتا ہے۔ اگر یہ مماثل نہیں ہوتا ہے تو ، فنکشن غلط لوٹتا ہے۔ اگر کردار قوسین نہیں ہے تو ، فنکشن لوپ جاری رکھے گا۔فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ یہ تار کے ہر کردار کی جانچ نہ کرے ، اور اگر اسٹیک خالی ہے تو سچائی واپس آجائے گا ، اس بات کی نشاندہی کرتی ہے کہ تمام افتتاحی قوسین بند ہونے والے قوسین کے ساتھ مماثل ہیں۔اگر دیئے گئے تار ایک درست قوسین کا اظہار ہے: ازگر = '() [] {}' نتیجہ = is_valid_parentheses (s) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: ٹرو نٹ کہ دونوں طریقوں سے یہ فرض ہوتا ہے کہ ان پٹ سٹرنگ ایس ایک درست تار ہے۔اگر ان پٹ اسٹرنگ نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال صرف قوسین کی جانچ پڑتال کرتے ہیں اور دوسری قسم کے بریکٹ یا ڈیلیمیٹرز 123456.1Favtutor2geekflare3gitconnected4w3resource5geeksforgeex6leetcode کی جانچ نہیں کرتے ہیں۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عددیوں کی دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: عدد کی ایک دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عددی تلاش کرنے کے لئے سیٹ ون کا استعمال کرنا یہ ہے کہ اس فہرست میں مثبت عدد کو ذخیرہ کرنے کے لئے ایک سیٹ کا استعمال کیا جائے ، اور پھر 1 سے شروع ہونے والے مثبت عدد کے ذریعے تکرار کریں۔جب تک کہ ہمیں سب سے چھوٹا گمشدہ مثبت عدد نہیں مل جاتا ہے۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سب سے چھوٹا_مشنگ_پوزیٹو_ٹیجر (ایل ایس ٹی): مثبت_ٹیجرز = سیٹ (فلٹر (لیمبڈا ایکس: ایکس> 0 ، ایل ایس ٹی)) i = 1 جبکہ میں مثبت_اینٹجرز میں ہوں: i += 1 ریٹرن آئی ٹی ایچ آئی ایس فنکشن ایک فہرست لیتا ہے۔ان پٹ ایل ایس ٹی ، فہرست میں مثبت انٹیجرز کو ذخیرہ کرنے کے لئے ایک سیٹ مثبت_ٹیجرز کی ابتدا کرتا ہے ، اور ایک متغیر I کو 1 سے شروع کرتا ہے۔ اس کے بعد فنکشن لوپ کا استعمال کرتے ہوئے 1 سے شروع ہونے والے ہر مثبت عدد کے ذریعے تکرار کرتا ہے ، اور چیک کرتا ہے کہ آیا یہ مثبت_انٹیجر سیٹ میں ہے۔اگر یہ ہے تو ، فنکشن میں اضافہ ہوتا ہے اور لوپ جاری رکھتا ہے۔اگر یہ نہیں ہے تو ، فنکشن I کو سب سے چھوٹا گمشدہ مثبت عدد کے طور پر لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ انٹیجرز کی ایک دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عددی تلاش کرنے کے لئے سب سے چھوٹا_مشنگ_پوسیٹیو_ٹیجر () فنکشن استعمال کرتا ہے: پائیٹونلسٹ = [2 ، 3 ، 3 ،-7 ، 6 ، 8 ، 1 ، -10 ، 15] نتیجہ = سب سے چھوٹا_مشنگ_پوسٹیٹو_ٹیجر (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 4 میتھوڈ 2: انٹیجرز کی ایک دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے لئے چھانٹنا دوسرے کا طریقہ استعمال کرنا ہے۔سب سے چھوٹی گمشدہ مثبت عددی تلاش کرنے کے لئے فہرست اور پھر ترتیب شدہ فہرست کے ذریعے تکرار کریں۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سب سے چھوٹا_مشنگ_پوزیٹیو_ٹیجر (ایل ایس ٹی): lst.sort () i = 1 LST میں نمبر کے لئے: اگر num == i: i += 1 الیف num> i: واپسی میں واپس آئی ٹی آئی ایس فنکشن لیتا ہوںایک فہرست ان پٹ LST ، اوپر چڑھتے ہوئے ترتیب میں فہرست کو ترتیب دیتا ہے ، متغیر I کو 1 سے شروع کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے ترتیب شدہ فہرست میں ہر نمبر کے ذریعے تکرار کرتا ہے۔ہر تعداد کے ل the ، فنکشن چیک کرتا ہے کہ آیا یہ i کے برابر ہے۔اگر یہ ہے تو ، فنکشن میں اضافہ ہوتا ہے اور لوپ جاری رکھتا ہے۔اگر یہ I سے زیادہ ہے تو ، فنکشن I کو سب سے چھوٹی گمشدہ مثبت عدد کے طور پر لوٹاتا ہے۔فنکشن اس وقت تک لوپ جاری رکھے گا جب تک کہ وہ ترتیب شدہ فہرست میں ہر نمبر کی جانچ نہ کرے ، اور اگر فہرست میں موجود تمام تعداد I سے کم یا اس کے برابر ہو تو میں سب سے چھوٹا سا مثبت عدد کے طور پر واپس آجاتا ہے۔انٹیجرز کی دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے لئے فنکشن: پائیتھونلسٹ = [2 ، 3 ، -7 ، 6 ، 8 ، 1 ، -10 ، 15] نتیجہ = سب سے چھوٹا_مشنگ_پوسیٹو_ٹیجر (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی:4 نوٹ کریں کہ دونوں طریقے یہ فرض کرتے ہیں کہ ان پٹ لسٹ LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ انٹیجرز کی فہرست نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال یہ فرض کرتے ہیں کہ سب سے چھوٹا لاپتہ مثبت عدد 1 سے زیادہ یا اس کے برابر ہے۔"
    },
    {
        "Question": "وائٹ اسپیس کو محفوظ رکھتے ہوئے کسی دیئے گئے تار میں الفاظ کے ترتیب کو پلٹنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "وائٹ اسپیس کو محفوظ رکھتے ہوئے الفاظ کی ترتیب کو کسی دیئے گئے تار میں پلٹانے کے ل we ، ہم تار کو الفاظ میں تقسیم کرسکتے ہیں ، الفاظ کی ترتیب کو الٹ سکتے ہیں ، اور پھر ان کے ساتھ اصل وائٹ اسپیس کے ساتھ مل کر شامل ہوسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف ریورس_ ورڈز (ایس): الفاظ = s.split () الفاظ۔اسپلٹ () کا طریقہ ، الٹ () طریقہ کار کا استعمال کرتے ہوئے الفاظ کے ترتیب کو تبدیل کرتا ہے ، اور جوائن () طریقہ کار کا استعمال کرتے ہوئے اصل وائٹ اسپیس کے ساتھ مل کر الفاظ میں شامل ہوتا ہے۔اس کے بعد فنکشن الٹ سٹرنگ کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کا کوڈ وائٹ اسپیس کو محفوظ رکھتے ہوئے الفاظ کے ترتیب کو تبدیل کرنے کے لئے ریورس_ورڈز () فنکشن کا استعمال کرتا ہے: ازگر = 'ہیلو ورلڈ ریزولٹ = ریورس_ورڈز (ایس) پرنٹ (نتیجہ (نتیجہ)) یہ آؤٹ پٹ ہوگا: ورلڈ ہیلونوٹ کہ ریورس_ ورڈز () فنکشن فرض کرتا ہے کہ ان پٹ سٹرنگ ایس ایک درست تار ہے۔اگر ان پٹ اسٹرنگ نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ تار میں الفاظ وائٹ اسپیس کے ذریعہ الگ ہوجاتے ہیں۔اگر الفاظ دوسرے ڈیمیٹرز کے ذریعہ الگ ہوجاتے ہیں تو ، آپ اس کے مطابق فنکشن میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "دی گئی فہرست میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "دی گئی فہرست میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: دی گئی فہرست میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل lo لوپون طریقہ کا استعمال کرنا یہ ہے کہ ہر جوڑے کے جوڑے کے ذریعے تکرار کے لئے لوپ کا استعمال کیا جائے اور زیادہ سے زیادہ مصنوع تلاش کریں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف میکس_ پروڈکٹ (ایل ایس ٹی): میکس_ پروڈکٹ = فلوٹ ('-انف') میں رینج (لین (ایل ایس ٹی)) کے لئے: رینج میں جے کے لئے (I+1 ، لین (LNST)): پروڈکٹ = lst [i] * lst [j] اگر پروڈکٹ> میکس_ پروڈکٹ: میکس_ پروڈکٹ = پروڈکٹ ریٹرن میکس_ پروڈکٹ یہ فنکشن ایک فہرست ان پٹ لسٹ لیتا ہے ، ایک متغیر میکس_ پروڈکٹ کو منفی انفینٹی کے لئے شروع کرتا ہے ، اور دو گھوںسلیوں کا استعمال کرتے ہوئے فہرست میں ہر جوڑے کے ذریعے تکرار کرتا ہے۔لوپسانٹیجرز کے ہر جوڑے کے ل the ، فنکشن انٹیجرز کی مصنوعات کا حساب لگاتا ہے اور چیک کرتا ہے کہ آیا یہ موجودہ میکس_ پروڈکٹ سے زیادہ ہے۔اگر یہ ہے تو ، فنکشن میکس_ پروڈکٹ کو انٹیجرز کی پیداوار میں اپ ڈیٹ کرتا ہے۔فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ وہ فہرست میں موجود ہر انٹیجرز کی جانچ نہ کرے ، اور فہرست میں دو عدد کی زیادہ سے زیادہ مصنوعات کے طور پر میکس_ پروڈکٹ کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ دو کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے میکس_ پروڈکٹ () فنکشن کا استعمال کرتا ہے۔ایک دی گئی فہرست میں انٹیجرز: پائیٹونلسٹ = [2 ، 3 ، -7 ، 6 ، 8 ، 1 ، -10 ، 15] نتیجہ = میکس_ پروڈکٹ (ایل ایس ٹی) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: -2 میتھوڈ 2: تلاش کرنے کے لئے چھانٹنگ کا طریقہ استعمال کرنادی گئی فہرست میں دو انٹیجرز کی زیادہ سے زیادہ پیداوار فہرست کو ترتیب دینا ہے اور پھر پہلے دو عدد اور آخری دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنا ہے۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پیتھنڈف میکس_ پروڈکٹ (ایل ایس ٹی): lst.sort () n = len (lst) واپسی میکس (Lst [0] * lst [1] ، lst [n-1] * lst [nst [nst [n-2]) یہ فنکشن ایک فہرست ان پٹ LST لیتا ہے ، ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے چڑھتے ترتیب میں فہرست کو ترتیب دیتا ہے ، متغیر N کو فہرست کی لمبائی میں شروع کرتا ہے ، اور پہلے دو عدد اور آخری دو کی زیادہ سے زیادہ مصنوعات کو واپس کرتا ہے۔زیادہ سے زیادہ () فنکشن کا استعمال کرتے ہوئے ترتیب شدہ فہرست میں انٹیجرز۔8 ، 1 ، -10 ، 15] نتیجہ = میکس_ پروڈکٹ (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 120 نوٹ کہ دونوں طریقوں سے یہ فرض کیا جاتا ہے کہ ان پٹ لسٹ LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ انٹیجرز کی فہرست نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال یہ فرض کرتے ہیں کہ اس فہرست میں کم از کم دو عدد ہیں۔اگر فہرست میں دو سے کم انٹیجرز ہیں تو ، افعال توقع کے مطابق 123456.1W3RESOURCE2TUTOURIALSTUTORIALSPOINT3W3RESOURCE4TUTORIALSTUTORIALSPOINT5GEEKSFORGEEKS6TECHIDELIGHT کے طور پر کام نہیں کرسکتے ہیں"
    },
    {
        "Question": "ایک اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور مستقل وقت میں کم سے کم عنصر تلاش کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "مستقل وقت میں کم سے کم عنصر کی تلاش کے ل a ایک اسٹیک اور اس کے طریقہ کار کی نمائندگی کرنے والی ایک ازگر کلاس یہاں ہے: پائیٹونکلاس اسٹیک: ڈیف __init __ (خود): سیلف اسٹیک = [] سیلف.مین_ اسٹیک = [] ڈیف پش (خود ، x): خود۔اسٹیک.ایپینڈ (x) اگر نہیں اگر سیلف نہیں ہے۔) اگر x == self.min_stack [-1]: self.min_stack.pop () Def ٹاپ (خود): اگر سیلف اسٹیک: خود واپس کریں اسٹیک۔سیلف ایم این_ اسٹیک [-1] اس کلاس میں ایک اسٹیک کلاس ہے جو اسٹیک کی نمائندگی کرتا ہے ، جس میں دو مثال کے متغیر اسٹیک اور من_ اسٹیک کے ساتھ ہے۔کلاس میں ایک طریقہ پش () ہوتا ہے جو ایک انٹیجر ان پٹ X لیتا ہے اور اسے اسٹیک پر دھکیل دیتا ہے ، اور اسے MIN_STACK پر بھی دھکیل دیتا ہے اگر یہ موجودہ کم سے کم عنصر سے کم یا اس کے برابر ہے۔کلاس میں ایک طریقہ پاپ () ہوتا ہے جو اسٹیک سے اوپر عنصر کو ہٹاتا ہے ، اور اسے MIN_STACK سے بھی ہٹاتا ہے اگر یہ موجودہ کم سے کم عنصر ہے۔کلاس میں ایک طریقہ ٹاپ () ہوتا ہے جو اسٹیک کے اوپری عنصر کو لوٹاتا ہے۔کلاس کے پاس ایک طریقہ get_min () ہے جو اسٹیک کے موجودہ کم سے کم عنصر کو مستقل وقت میں لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ اسٹیک آبجیکٹ بناتا ہے ، کچھ عناصر کو اسٹیک پر دھکیلتا ہے ، اور اسٹیک کے کم سے کم عنصر کو پرنٹ کرتا ہے: پائیٹون اسٹیک= اسٹیک () اسٹیک۔ پش (3) اسٹیک۔ پش (2) اسٹیک۔ پش (5) اسٹیک۔ پش (1) من_ایلیمنٹ = اسٹیک۔ گیٹ_مین () پرنٹ (MIN_ELENTEM) اس کی پیداوار ہوگی: 1 نوٹ کہ اسٹیک کلاس یہ فرض کرے گا کہ یہ فرض کرے گا۔ان پٹ عناصر درست عدد ہیں۔اگر ان پٹ ایک درست عددی نہیں ہے تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ اسٹیک خالی نہیں ہے۔اگر اسٹیک خالی ہے تو ، پاپ () ، اوپر () ، اور get_min () طریقے توقع کے مطابق 12345.1tutorialsPoint2Medium3Techedelight4leetCode5Stackoverflow کے طور پر کام نہیں کرسکتے ہیں۔"
    },
    {
        "Question": "عدد کی ایک دی گئی فہرست میں متناسب سبری کی سب سے بڑی رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عددیوں کی ایک دی گئی فہرست میں متناسب سبری کی سب سے بڑی رقم تلاش کرنے کے ل we ، ہم کڈانے کا الگورتھم استعمال کرسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر کا فنکشن ہے جو اس الگورتھم کو نافذ کرتا ہے: پائیتھونڈف میکس_سوبری_سم (ایل ایس ٹی): میکس_سم = ایل ایس ٹی [0] موجودہ_سم = ایل ایس ٹی [0] رینج (1 ، لین (ایل ایس ٹی)) کے لئے: کرنٹ_سم = میکس (ایل ایس ٹی [i] ، ،کرنٹ_سم + ایل ایس ٹی [i]) میکس_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) ریٹرن میکس_سومتھ فنکشن ایک فہرست ان پٹ ایل ایس ٹی لیتا ہے ، دو متغیرات میکس_سم اور کرنٹ_سم کو فہرست کے پہلے عنصر میں شروع کرتا ہے ، اور دوسرے سے شروع ہونے والے لوپ کا استعمال کرتے ہوئے فہرست میں تکرار کرتا ہے۔عنصرہر عنصر کے ل the ، فنکشن اس عنصر پر ختم ہونے والے ایک متضاد سبری کی زیادہ سے زیادہ رقم کا حساب لگاتا ہے جس کا استعمال فارمولا موجودہ_سم = میکس (LST [i] ، کرنٹ_سم + ایل ایس ٹی [i]) کا استعمال کرتے ہیں ، اور زیادہ سے زیادہ میکس_سم اور کرنٹ_سم کی زیادہ سے زیادہ_سم کو اپ ڈیٹ کرتے ہیں۔فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ وہ فہرست میں ہر عنصر کی جانچ نہ کرے ، اور فہرست میں ایک متنازعہ سبری کے سب سے بڑے رقم کے طور پر میکس_سم کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ میں میکس_سوبری_سم () فنکشن کا استعمال کیا جاتا ہے تاکہ کسی متنازعہ کی سب سے بڑی رقم تلاش کی جاسکے۔انٹیجرز کی ایک دی گئی فہرست میں سباریMAX_SUBARRAY_SUM () فنکشن فرض کرتا ہے کہ ان پٹ لسٹ LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ انٹیجرز کی فہرست نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ فہرست میں کم از کم ایک عنصر ہوتا ہے۔اگر فہرست خالی ہے تو ، فنکشن متوقع 123.1GURU992GEEKSFORGEEEKS3ENJEYALGORITHMS کے طور پر کام نہیں کرسکتا ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر خوش کن نمبر ہے۔",
        "Answer": "ایک خوشگوار نمبر ایک ایسی تعداد ہے جو اقدامات کے تسلسل کے بعد 1 کی طرف جاتا ہے ، جہاں ہر قدم اپنے ہندسوں کے چوکوں کا مجموعہ ہوتا ہے۔اگر عمل 1 کی طرف جاتا ہے تو ، نمبر ایک خوش کن نمبر ہے۔بصورت دیگر ، یہ ایک چکر میں نہ ختم ہونے والے لوپ ہوجائے گا۔یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد خوشگوار نمبر ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: یہ چیک کرنے کے لئے سیٹ ون کا طریقہ استعمال کرنا کہ آیا کوئی دیا ہوا نمبر ایک خوش نمبر ہے یا نہیں کہ نمبر کو ترتیب میں اسٹور کرنے کے لئے ایک سیٹ کا استعمال کیا جائے ، اور پھر اس ترتیب کے ذریعے تکرار کریں جب تک کہ ہمیں 1 یا ایک نمبر نہ ملے۔پہلے ہی سیٹ میں رہا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف is_happy_number (n): ملاحظہ کریں = سیٹ () جبکہ n! = 1 اور n نہیں ملاحظہ کریں: ملاحظہ کیا گیا۔ ایڈ (n) n = sum (int (ہندسہ) ** 2 کے لئےڈیجیٹ ان st (n)) واپسی n == 1 یہ فنکشن ایک عدد ان پٹ N لے جاتا ہے ، نمبروں کو ترتیب میں ذخیرہ کرنے کے لئے ایک خالی سیٹ شروع کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے تسلسل کے ذریعے تکرار کرتا ہے جب تک کہ اس میں 1 یا ایک نمبر موجود نہ ہو جو پہلے ہی موجود ہے۔سیٹ میں رہا ہے۔تسلسل میں ہر ایک نمبر کے ل the ، فنکشن اپنے ہندسوں کے چوکوں کا مجموعہ () () اور انٹ () افعال کا استعمال کرتے ہوئے ، اور رقم کو اپ ڈیٹ کرتا ہے۔فنکشن اس وقت تک لوپ جاری رکھے گا جب تک کہ اسے 1 یا ایک نمبر مل جائے جو پہلے ہی سیٹ میں موجود ہو ، اور اگر اسے 1 یا غلط مل جاتا ہے تو وہ سچ ثابت ہوتا ہے۔ایک خوش نمبر ہے: پائیٹون = 19 ریزولٹ = is_happy_number (n) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truemethod 2: یہ چیک کرنے کے لئے تکرار کرنے کا دوسرا طریقہ استعمال کرنا کہ آیا ایک خوش نمبر ہے یا نہیں اس کے مربع کا حساب کتاب کرنے کے لئے تکرار کا استعمال کرنا ہے یا نہیں۔ہندسوں کو جب تک کہ اسے 1 یا ایک نمبر مل جائے جو پہلے ہی ترتیب میں رہا ہو۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف is_happy_number (n ، ملاحظہ نہیں = کوئی نہیں): اگر ملاحظہ کیا گیا تو کوئی نہیں ہے: ملاحظہ کریں = سیٹ () اگر n == 1: اگر nise میں واپس آئے تو: غلط ملاحظہ کریں۔) واپسی is_happy_number (SUM (int (ہندسہ) ** 2 ہندسے کے لئے st (n)) ، ملاحظہ کریں) اس فنکشن میں ایک عدد ان پٹ N اور ایک اختیاری سیٹ ان پٹ لیتا ہے جس میں نمبروں کو ترتیب میں ذخیرہ کرنے کے لئے ملاحظہ کیا جاتا ہے ، اور حساب کتاب کرنے کے لئے تکرار کا استعمال کیا جاتا ہےاس کے ہندسوں کے چوکوں کا مجموعہ جب تک کہ اسے 1 یا ایک نمبر مل جائے جو پہلے ہی ترتیب میں رہا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا کوئی بھی نہیں ہے ، اور اگر یہ ہے تو ، نمبروں کو ترتیب میں ذخیرہ کرنے کے لئے ایک خالی سیٹ کی ابتدا کرتا ہے۔اس کے بعد یہ کام چیک کرتا ہے کہ اگر n 1 ہے ، اور اگر یہ ہے تو ، سچ واپس آجاتا ہے۔اس کے بعد یہ کام چیک کرتا ہے کہ اگر N کا دورہ کیا گیا ہے ، اور اگر یہ ہے تو ، غلط لوٹاتا ہے۔اس کے بعد فنکشن N کو دیکھنے میں شامل کرتا ہے ، اس کے ہندسوں کے مربعوں کا مجموعہ (جو) () اور انٹ () افعال کا استعمال کرتے ہوئے کرتا ہے ، اور اپنے آپ کو رقم کے ساتھ کال کرنے اور ملنے کے لئے تکرار کا استعمال کرتا ہے۔فنکشن تکرار کو جاری رکھے گا جب تک کہ اسے 1 یا ایک نمبر نہ مل جائے جو پہلے ہی ترتیب میں رہا ہو ، اور اگر اسے 1 یا غلط مل جاتا ہے تو سچائی واپس آجاتا ہے۔ایک خوش کن نمبر ہے: pythonn = 19result = is_happy_number (n) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truenote جس سے دونوں طریقوں سے یہ فرض ہوتا ہے کہ ان پٹ نمبر n ایک درست عدد ہے۔اگر ان پٹ درست عدد نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال کو بڑے ان پٹ نمبروں کے لئے چلانے میں کافی وقت لگ سکتا ہے جو خوش نہیں ہیں نمبر 123456.1 جی ای ای ہسفور جی ای ای ایس 2 ٹیوٹوریلس پوائنٹ 3 ٹیوٹوریلس پوائنٹ 4onecompiler5javat6w3resource"
    },
    {
        "Question": "سککوں کے سیٹ کا استعمال کرتے ہوئے دیئے گئے رقم میں تبدیلی لانے کے طریقے کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "سکے کے ایک سیٹ کا استعمال کرتے ہوئے دیئے گئے رقم میں تبدیلی لانے کے طریقوں کی تعداد تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پیتھونڈف سکے_چینج (سکے ، رقم): ڈی پی = [0] * (رقم + 1) ڈی پی [0] = 1 سکے میں سکے کے لئے: رینج میں (سکے ، مقدار + 1): DP [i] + = dp [i - سکے] واپسی DP [رقم] یہ فنکشن ایک فہرست ان پٹ سکے لیتا ہے جس میں سکے کے سیٹ کی نمائندگی ہوتی ہے اور ہدف کی رقم کی نمائندگی کرنے والی ایک عدد ان پٹ رقم ، لمبائی کی رقم + 1 کی فہرست DP شروع کرتی ہے۔ہر رقم کے ل change تبدیلی کرنے کے طریقوں کی تعداد کو ذخیرہ کرنے کے ل D ، ڈی پی کو 1 پر سیٹ کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے سکے کی فہرست میں ہر سکے کے ذریعے تکرار کرتا ہے۔ہر سکے کے ل the ، فنکشن سکے سے لے کر کسی دوسرے لوپ کا استعمال کرتے ہوئے مقدار میں ہر رقم کے ذریعے تکرار کرتا ہے ، اور ڈی پی [i] کو ڈی پی [i] اور ڈی پی [i - سکے] کی رقم میں اپ ڈیٹ کرتا ہے۔فنکشن اس وقت تک جاری رہتا ہے جب تک کہ وہ ہر سکے اور ہر رقم کی جانچ نہ کرے ، اور ڈی پی [رقم] کو ہدف کی رقم کے ل change تبدیلی کے طریقوں کی تعداد کے طور پر واپس کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ نمبر تلاش کرنے کے لئے COIN_CHANGE () فنکشن کا استعمال کرتا ہے۔سکے کے ایک سیٹ کا استعمال کرتے ہوئے دیئے گئے رقم کے ل change تبدیلی کرنے کے طریقوں کے: پائیٹونکوائنز = [1 ، 2 ، 5] رقم = 11 ریزولٹ = COIN_CHANG (سکے ، رقم) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 3 نوٹ کریں کہ COIN_CHANG () فنکشن فرض کرتا ہےکہ ان پٹ سکے کی فہرست عدد کی ایک درست فہرست ہے اور ان پٹ کی رقم ایک درست عدد ہے۔اگر ان پٹ درست نہیں ہیں تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ سککوں کے سیٹ کا استعمال کرتے ہوئے ہدف کی رقم میں تبدیلی لانے کے لئے کم از کم ایک راستہ ہے۔اگر ہدف کی رقم میں تبدیلی لانے کا کوئی طریقہ نہیں ہے تو ، فنکشن متوقع 123.1Simplilearn2geeksforgeeks3leetcode کے طور پر کام نہیں کرسکتا ہے۔"
    },
    {
        "Question": "بائنری AVL درخت کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "بائنری AVL درخت کی نمائندگی کرنے اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کرنے والے ایک ازگر کلاس بنانے کے ل we ، ہم وسائل 1،2 ، And3as حوالہ جات استعمال کرسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر کلاس ہے جو اس نقطہ نظر کو نافذ کرتی ہے: پائیتھونکلاس avlnode: def __init __ (خود ، کلید): self.key = key self.left = کوئی بھی نہیں۔ خود نہیں۔کلیدی): اگر جڑ نہیں ہے تو: ریٹرن Avlnod.ہائٹ = 1 + زیادہ سے زیادہ (سیلف.گیٹ_ہائٹ (روٹ.لفٹ) ، سیلف۔گیٹ_ہائٹ (روٹ. رائٹ)) توازن = خود۔ گیٹ_ بیلنس (جڑ) اگر توازن> 1 اور کلید <روٹ.لفٹ.کی: واپس کریں سیلف۔ رائٹ_روٹیٹ(روٹ) اگر توازن <-1 اور key> root.right.key: retull.left_rotate (جڑ) اگر توازن> 1 اور key> root.left.key: root.left = self.left_rotate (روٹ. لیفٹ) ریٹرنself.right_rotate (روٹ) اگر توازن <-1 اور کلیدی <root.right.key: روٹ. رائٹ = سیلف۔ رائٹ_روٹیٹ (روٹ۔ رائٹ) واپس لوٹیں۔: اگر جڑ نہیں ہے تو: جھوٹے الیف روٹ کو واپس کریں۔ ککی == کلید: ریٹرن ٹرو ایلف کی کلید <روٹ.کی: سیلف۔ سرچ (روٹ. لیفٹ ، کلید) اور خود کو لوٹائیں۔ خود کی تلاش کریں۔ تلاش کریں۔..)) Y.Height = 1 + زیادہ سے زیادہ (سیلف۔ گیٹ_ہائٹ (Y.Left) ، سیلف۔ گیٹ_ہائٹ (Y.Right)) ریٹرن وائی ڈیف رائٹ_روٹیٹ (خود ، زیڈ): y = z.left t3 = y.right y۔دائیں = z z.left = t3 z.height = 1 + زیادہ سے زیادہ (سیلف۔ گیٹ_ہائٹ (z.left) ، سیلف.گیٹ_ہائٹ (زیڈ رائٹ)) Y.Height = 1 + زیادہ سے زیادہ (self.get_height (y.left).کلاس میں ایک آولٹری کلاس ہے جو اے وی ایل کے درخت کی نمائندگی کرتی ہے ، جس میں طریقوں کے داخل () ، تلاش () ، get_height () ، get_balance () ، بائیں_روٹیٹ () ، اور دائیں_روٹیٹ () کے ساتھ۔داخل () کا طریقہ نوڈ ان پٹ جڑ اور ایک کلیدی ان پٹ کلید لیتا ہے ، درخت میں کلید داخل کرتا ہے ، اور تازہ ترین درخت کی جڑ لوٹاتا ہے۔تلاش () کا طریقہ نوڈ ان پٹ روٹ اور ایک کلیدی ان پٹ کلید لیتا ہے ، درخت میں کلید کی تلاش کرتا ہے ، اور اگر کلید مل جاتی ہے اور غلط ہے تو وہ سچ ہے۔get_height () کا طریقہ نوڈ ان پٹ جڑ لیتا ہے ، نوڈ کی اونچائی کو لوٹاتا ہے ، اور اگر نوڈ کوئی نہیں ہے تو 0 لوٹاتا ہے۔get_balance () کا طریقہ نوڈ ان پٹ جڑ لیتا ہے ، نوڈ کے بیلنس عنصر کو لوٹاتا ہے ، اور اگر نوڈ کوئی نہیں ہے تو 0 لوٹاتا ہے۔بائیں_روٹیٹ () کا طریقہ نوڈ ان پٹ زیڈ لیتا ہے ، نوڈ پر بائیں گردش کرتا ہے ، اور تازہ ترین سب ٹری کی جڑ لوٹاتا ہے۔دائیں_روٹیٹ () کا طریقہ نوڈ ان پٹ زیڈ لیتا ہے ، نوڈ پر صحیح گردش انجام دیتا ہے ، اور تازہ ترین سب ٹری کی جڑ لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ ایک آولٹری آبجیکٹ بناتا ہے ، درخت میں کچھ نوڈس داخل کرتا ہے ، اور تلاش کرتا ہےدرخت میں ایک نوڈ: پائیٹونٹری = avltree () جڑ = noneroot = tree.insert (جڑ ، 10) جڑ = درخت. insert (جڑ ، 20) جڑ = درخت۔ insert (جڑ ، 30) جڑ = درخت۔ insert (جڑ = درخت (جڑ)، 40) روٹ = ٹری۔ INSERT (جڑ ، 50) جڑ = درخت۔ INSERT (جڑ ، 25) نتیجہ = درخت کی تلاش (جڑ ، 30) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: ٹرو نٹ کہ آولٹری کلاس یہ فرض کرتی ہے کہ ان پٹنوڈس اور چابیاں درست ہیں۔اگر ان پٹ درست نہیں ہیں تو ، کلاس توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، کلاس یہ فرض کرتی ہے کہ ہر اندراج کے بعد اے وی ایل کا درخت متوازن ہے۔اگر اے وی ایل کا درخت متوازن نہیں ہے تو ، داخل () کا طریقہ توقع کے مطابق 123.1favtutor2askpython3Program کے مطابق کام نہیں کرسکتا ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے یا نہیں ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: یہ چیک کرنے کے لئے اسٹیکون طریقہ کا استعمال کرتے ہوئے کہ آیا دیئے گئے سٹرنگ ایک درست قوسین کا اظہار ہے جس میں مختلف قسم کے قوسین کے ساتھ افتتاحی قوسین کو ذخیرہ کرنے کے لئے ایک اسٹیک کا استعمال کرنا ہے ، اور پھر ہر ایک کو چیک کرنے کے لئے سٹرنگ کے ذریعے تکرار کریں۔بند کرنے والا قوسین اسٹیک کے اوپری حصے سے مماثل ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف is_valid_parentheses (s): اسٹیک = [] میپنگ = {')': '(' ، '}': '{' ، ']': '['} چار کے لئے چار کے لئےایس: اگر میپنگ میں چار: اگر اسٹیک یا اسٹیک نہیں ہے۔افتتاحی قوسین ، اور اسی طرح کے افتتاحی اور بند ہونے والے قوسین کو ذخیرہ کرنے کے لئے ایک لغت کی نقشہ سازی کا آغاز کرتا ہے۔ اس کے بعد یہ فنکشن لوپ کا استعمال کرتے ہوئے تار میں ہر کردار کے ذریعے تکرار کرتا ہے ، اور چیک کرتا ہے کہ اگر کردار بند ہونے والا قوسین ہے۔اسٹیک خالی ہے یا اگر اسٹیک کا سب سے اوپر میپنگ لغت میں متعلقہ افتتاحی قوسین سے مماثل نہیں ہے۔ اگر ان دونوں میں سے کوئی بھی صحیح ہے تو ، فنکشن غلط لوٹتا ہے۔ اگر کردار اختتامی قوسین نہیں ہے تو ، فنکشن اس کو آگے بڑھاتا ہے۔اسٹیک. فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ وہ تار میں ہر کردار کی جانچ نہ کرے ، اور اگر اسٹیک خالی اور غلط ہے تو سچائی واپس آجائے۔قوسین کی مختلف اقسام کے ساتھ درست قوسین کا اظہار: ازگر = '({[()]]})' نتیجہ = is_valid_parentheses (s) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truemethod 2: چیک کرنے کے لئے recursionanandother طریقہ کا استعمال کرنا ایک درست ہے یا نہیں۔قوسین کی مختلف اقسام کے ساتھ قوسین کا اظہار یہ ہے کہ قوسین کا ہر جوڑا میچ کرتا ہے یا نہیں اس کی جانچ پڑتال کے لئے تکرار کا استعمال کرنا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف is_valid_parentheses (s): اگر نہیں ہے تو: اگر لین (s) ٪ 2 == 1: غلط لوٹیں تو غلط واپس کریں [0] in ')}]میں رینج (1 ، لین (ایس) ، 2): اگر ایس [i] نہیں ')}]': غلط لوٹائیں اگر s [i-1] + s [i] میں نہیں ['()' ، '{} '،' [] '']]: غلط واپسی is_valid_parentheses (s [1: i]) اور is_valid_parentheses (s [i+1:]) واپس لوٹائیں اس فنکشن میں تار ان پٹ S لیتا ہے ، اگر تار کی لمبائی عجیب ہے تو چیک کرتا ہے۔، اور اگر یہ ہے تو غلط لوٹتا ہے۔اس کے بعد یہ کام چیک کرتا ہے کہ آیا تار کا پہلا کردار ایک اختتامی قوسین ہے ، اور اگر یہ ہے تو غلط لوٹتا ہے۔اس کے بعد فنکشن ایک لوپ کا استعمال کرتے ہوئے تار میں قوسین کے ہر جوڑے کے ذریعے تکرار کرتا ہے ، اور چیک کرتا ہے کہ اگر یہ جوڑا قوسین کے درست جوڑے میں سے کسی سے مماثل ہے۔اگر ایسا نہیں ہوتا ہے تو ، فنکشن غلط لوٹاتا ہے۔اگر یہ جوڑی قوسین کے ایک درست جوڑے سے مماثل ہے تو ، اس فنکشن میں قوسین کے جوڑے سے پہلے اور اس کے بعد خود کو اسٹرنگ کے ساتھ کال کرنے کے لئے تکرار کا استعمال کیا جاتا ہے۔فنکشن تکرار کو جاری رکھے گا جب تک کہ وہ تار میں قوسین کے ہر جوڑے کی جانچ نہ کرے ، اور اگر تمام جوڑے قوسین کے جوڑے میچ اور غلط ہیں۔قوسین کی مختلف اقسام کے ساتھ درست قوسین کا اظہار: ازگر = '({[()]]})' نتیجہ = is_valid_parentheses (s) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: truenote جس سے دونوں طریقوں سے یہ فرض ہوتا ہے کہ ان پٹ سٹرنگ S ایک درست تار ہے۔اگر ان پٹ ایک درست تار نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال یہ فرض کرتے ہیں کہ قوسین اچھی طرح سے تشکیل پائے ہیں اور ان میں کوئی اور کردار نہیں ہیں۔اگر قوسین اچھی طرح سے تشکیل یا دوسرے حرفوں پر مشتمل نہیں ہیں تو ، افعال متوقع 123456.1favtutor2geeksforgeyks3geekflare4redequark5geeksforgeeetcode کے طور پر کام نہیں کرسکتے ہیں۔"
    },
    {
        "Question": "سب سے چھوٹا گمشدہ مثبت عدد تلاش کرنے کے لئے ایک پروگرام لکھیں جو عددی کی دی گئی فہرست میں ظاہر نہیں ہوتا ہے۔",
        "Answer": "سب سے چھوٹا لاپتہ مثبت عددی تلاش کرنے کے ل that جو عددیوں کی دی گئی فہرست میں ظاہر نہیں ہوتا ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: سب سے چھوٹی گمشدہ مثبت عددی تلاش کرنے کے لئے سیٹ ون کا استعمال کرنا جو عددی کی دی گئی فہرست میں ظاہر نہیں ہوتا ہے اس کی فہرست میں مثبت انٹیجرز کو ذخیرہ کرنے کے لئے ایک سیٹ کا استعمال کرنا ہے ، اور پھر مثبت کے ذریعے تکرار کریں۔سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے لئے 1 سے شروع ہونے والے عدد۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سب سے چھوٹا_مشنگ_پوزیٹو_ٹیجر (LST): مثبت_ٹیجرز = سیٹ (فلٹر (لیمبڈا ایکس: ایکس> 0 ، ایل ایس ٹی)) میں رینج (1 ، لین (ایل ایس ٹی) + 2) کے لئے: اگر میں نہیں کرتا ہوں۔مثبت_انٹیجرز میں: ریٹرن آئی ٹی ایچ آئی ایس فنکشن ایک فہرست ان پٹ LST لیتا ہے ، فہرست میں مثبت انٹیجرز کو ذخیرہ کرنے کے لئے ایک سیٹ مثبت_ٹیجرز کی ابتدا کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے 1 سے شروع ہونے والے مثبت عدد کے ذریعے تکرار کرتا ہے۔ہر مثبت عدد کے ل the ، فنکشن چیک کرتا ہے کہ آیا یہ مثبت_ٹیجرز سیٹ میں ہے۔اگر یہ نہیں ہے تو ، فنکشن مثبت انٹیجر کو سب سے چھوٹی گمشدہ مثبت عدد کے طور پر لوٹاتا ہے۔فنکشن اس وقت تک جاری رہتا ہے جب تک کہ اس کو سب سے چھوٹا گمشدہ مثبت عدد نہ مل جائے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ سب سے چھوٹا لاپتہ مثبت عددی تلاش کرنے کے لئے سب سے چھوٹا_مشنگ_پوسیٹیو_ٹیجر () فنکشن استعمال کرتا ہے جو عددیوں کی دی گئی فہرست میں ظاہر نہیں ہوتا ہے: پائیتھنلسٹ = [2 ، 2 ، [2 ،3 ، -7 ، 6 ، 8 ، 1 ، -10 ، 15] نتیجہ = سب سے چھوٹا_مشنگ_پوسیٹیو_ٹیجر (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 4 میتھوڈ 2: سب سے چھوٹا لاپتہ مثبت عدد تلاش کرنے کا طریقہ استعمال کرنا جو کسی دیئے گئے میں ظاہر نہیں ہوتا ہے۔انٹیجرز کی فہرست فہرست کو ترتیب دینا ہے ، اور پھر سب سے چھوٹی گمشدہ مثبت عددی تلاش کرنے کے لئے ترتیب شدہ فہرست کے ذریعے تکرار کریں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف سب سے چھوٹا_مشنگ_پوسٹیٹو_ٹیجر (LST): LST.Sort () سب سے چھوٹا_مشنگ = 1 LST میں نمبر کے لئے: اگر num == سب سے چھوٹا_مشنگ: سب سے چھوٹا_مشنگ += 1 الیف نمبر> سب سے چھوٹا_مشنگ: سب سے چھوٹا_مشنگ: سب سے چھوٹا_مشنگ: سب سے چھوٹا_مشنگ: سب سے چھوٹا_مشنگ واپسایک فہرست ان پٹ LST ، ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے فہرست کو ترتیب دیتا ہے ، ایک متغیر سب سے چھوٹی_مشنگ 1 کو شروع کرتا ہے ، اور لوپ کا استعمال کرتے ہوئے ترتیب شدہ فہرست کے ذریعے تکرار کرتا ہے۔فہرست میں ہر ایک نمبر کے ل the ، فنکشن چیک کرتا ہے کہ آیا یہ سب سے چھوٹی_مشنگ کے برابر ہے۔اگر یہ ہے تو ، فنکشن سب سے چھوٹی_مشنگ میں اضافہ کرتا ہے۔فنکشن اس وقت تک جاری رہتا ہے جب تک کہ اس کو سب سے چھوٹا گمشدہ مثبت عدد نہ مل جائے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ سب سے چھوٹا لاپتہ مثبت عددی تلاش کرنے کے لئے سب سے چھوٹا_مشنگ_پوسیٹیو_ٹیجر () فنکشن استعمال کرتا ہے جو عددیوں کی دی گئی فہرست میں ظاہر نہیں ہوتا ہے: پائیتھنلسٹ = [2 ، 2 ، [2 ،3 ، -7 ، 6 ، 8 ، 1 ، -10 ، 15] نتیجہ = سب سے چھوٹا_مشنگ_پوسیٹیو_ٹیجر (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 4 نوٹ کہ دونوں طریقے یہ فرض کریں گے کہ ان پٹ LST عدد کی ایک درست فہرست ہے۔اگر ان پٹ انٹیجرز کی درست فہرست نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال یہ فرض کرتے ہیں کہ فہرست میں کم از کم ایک لاپتہ مثبت عددی ہے۔اگر فہرست میں کوئی مثبت انٹیجر نہیں ہے تو ، افعال متوقع 1234.1Interviewibit2CODINGNINJAS3GEEKSFORGEEKS4TECHIDELight کے طور پر کام نہیں کرسکتے ہیں۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں زیادہ تر K الگ الگ کرداروں کے ساتھ سب سے طویل تر اسٹرنگ تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": ""
    },
    {
        "Question": "\"کسی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں ، دوسرے عنصر کے ساتھ پہلے کے بعد ظاہر ہوتا ہے۔\"",
        "Answer": "کسی دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے کسی فنکشن کو نافذ کرنے کے ل ، ، دوسرے عنصر کے ساتھ پہلے کے بعد ، ہم وسائل 123456AS حوالہ جات استعمال کرسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف میکس_ ڈفینفرنس (ایل ایس ٹی): اگر لین (لسٹ) <2: کوئی بھی نہیں لوٹ کوئی نہیں۔لین (LST)): اگر Lst [i] - Min_elem> میکس_ ڈف: میکس_ ڈف = lst [i] - min_elem اگر lst [i] <min_elem: min_elem = lst [i] واپسی میکس_ ڈفٹیس فنکشن ایک فہرست ان پٹ LST لیتا ہے ، متغیرات من_elem شروع کرتا ہے۔اور میکس_ ڈف ، اور لوپ کا استعمال کرتے ہوئے فہرست میں تکرار کرتا ہے۔فہرست میں ہر عنصر کے ل the ، فنکشن MIN_ELEM کو اب تک دیکھنے والے کم سے کم عنصر کی تازہ کاری کرتا ہے ، اور میکس_ ڈف کو اب تک دیکھنے میں آنے والے زیادہ سے زیادہ فرق کو اپ ڈیٹ کرتا ہے۔فنکشن اس وقت تک لوپ کو جاری رکھے گا جب تک کہ وہ فہرست میں ہر عنصر کی جانچ نہ کرے ، اور فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق کے طور پر میکس_ ڈف کو واپس کرتا ہے ، دوسرے عنصر کے ساتھ پہلے کے بعد۔دیئے گئے فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے: پائیٹونلسٹ = [2 ، 3 ، 8 ، 0 ، 7] نتیجہ = زیادہ سے زیادہ_ڈیفینس (ایل ایس ٹی) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 8 نوٹ کریں کہ یہ طریقہ یہ فرض کرتا ہے کہ ان پٹ ایل ایس ٹی ہےعدد کی ایک درست فہرست۔اگر ان پٹ انٹیجرز کی درست فہرست نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ دوسرا عنصر پہلے کے بعد ظاہر ہوتا ہے۔اگر یہ مفروضہ درست نہیں ہے تو ، فنکشن متوقع 123456.1stackoverflow2rosettacode3enayalgorithms4geeksforgeeks5techidelight6geeksforgeks کے طور پر کام نہیں کرسکتا ہے۔"
    },
    {
        "Question": "\"ہیش نقشہ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور کلیدی قیمت کے جوڑے داخل کرنے ، بازیافت کرنے اور ان کو ہٹانے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "ایک ہیش نقشہ کی نمائندگی کرنے اور کلیدی قیمت کے جوڑے کو داخل کرنے ، بازیافت کرنے اور ان کو دور کرنے کے طریقوں کو نافذ کرنے والے ایک ازگر کلاس لکھنے کے ل we ، ہم وسائل 123456 اے حوالہ جات استعمال کرسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر کلاس ہے جو اس نقطہ نظر کو نافذ کرتی ہے: پائیٹونکلاس ہیش میپ: ڈیف __init __ (خود): خود۔ سائز = 10 سیلف۔ میپ = [کوئی بھی](کلیدی): ہیش += آرڈ (چار) ریٹرن ہیش ٪ سیلف۔ سائز ڈیف ایڈ (خود ، کلیدی ، قدر): کلیدی_ہش = سیلف۔کوئی نہیں: سیلف ایم اے پی [key_hash] = فہرست ([key_value]) سچائی واپس لوٹیں: خود میں جوڑی کے لئے۔ میپ [key_hash]: اگر جوڑی [0] == کلید: جوڑی [1] = ویلیو ریٹرن سچی سیلف۔ میپ [key_hash] .append (key_value) واپس حقیقی Def get get get (key ، key): key_hash = self._get_hash (key) اگر sell] == کلید: واپسی کی جوڑی [1] واپسی کوئی نہیں ڈیف ڈیلیٹ (خود ، کلید): key_hash = self._get_hash (key) اگر self.map [key_hash] کوئی بھی نہیں ہے: رینج میں I کے لئے جھوٹا واپس کریں (0 ، لین (خود (خود).MAP [key_hash])): اگر self.map [key_hash] [i] [0] == key: self.map [key_hash] .pop (i) واپسی حقیقی واپسی فالسٹی کلاس کا ایک __init__ طریقہ ہے جو ہیش میپ کو شروع کرتا ہے۔10 کے سائز اور خالی فہرست کا نقشہ۔کلاس میں ایک _get_hash کا طریقہ ہے جو ایک کلیدی ان پٹ کلید لیتا ہے ، کلید کے لئے ہیش ویلیو کی گنتی کرتا ہے ، اور ہیش ویلیو ماڈیولو کو ہیش نقشہ کے سائز کو واپس کرتا ہے۔کلاس کے پاس ایک ADD طریقہ ہے جو ایک کلیدی ان پٹ کلید اور ویلیو ان پٹ ویلیو لیتا ہے ، _get_hash کے طریقہ کار کا استعمال کرتے ہوئے کلید کے لئے ہیش ویلیو کی گنتی کرتا ہے ، اور ہیش کے نقشے میں کلیدی قدر کی جوڑی کو شامل کرتا ہے۔اگر ہیش نقشہ میں کلید پہلے سے موجود ہے تو ، طریقہ ویلیو کو اپ ڈیٹ کرتا ہے۔کلاس کے پاس ایک گیٹ طریقہ ہے جو ایک کلیدی ان پٹ کلید لیتا ہے ، _get_hash کے طریقہ کار کا استعمال کرتے ہوئے کلید کے لئے ہیش ویلیو کی گنتی کرتا ہے ، اور اگر ہیش کے نقشے میں موجود ہے تو کلید سے وابستہ قدر واپس کرتا ہے۔کلاس میں ایک حذف کرنے کا طریقہ ہے جو ایک اہم ان پٹ کلید لیتا ہے ، _get_hash کے طریقہ کار کا استعمال کرتے ہوئے کلید کے لئے ہیش ویلیو کی گنتی کرتا ہے ، اور ہیش نقشہ سے کلیدی قیمت کی جوڑی کو ہٹاتا ہے اگر یہ موجود ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ ہیش میپ کا استعمال کرتا ہے۔کلیدی قدر کے جوڑے داخل کرنے ، بازیافت کرنے اور اسے ہٹانے کے لئے کلاس: پائیٹون ہاش_ میپ = ہیش میپ () ہیش_ میپ.اڈڈ ('ایپل' ، 1) ہیش_مپ.اڈ ('کیلے' ، 2) ہیش_ میپ.ایڈ ('چیری' ، 3) پرنٹ ('چیری' ، 3) پرنٹ ('چیری' ، 3) پرنٹ ('چیری' ، 3) پرنٹہیش_مپ.جیٹ ('ایپل')) پرنٹ (ہیش_ میپ.یٹ ('کیلے')) پرنٹ (ہیش_مپ.جیٹ ('چیری')) ہیش_ میپ.ڈیلیٹ ('کیلے') پرنٹ (ہیش_ میپ.جیٹ ('کیلے'))اس سے آؤٹ پٹ ہوگا: 123 نونوٹ کہ یہ طریقہ یہ فرض کرتا ہے کہ ان پٹ کیز اور اقدار درست ہیں۔اگر ان پٹ درست نہیں ہیں تو ، توقع کے مطابق طریقے کام نہیں کرسکتے ہیں۔نیز ، طریقے یہ فرض کرتے ہیں کہ _get_hash کے طریقہ کار میں استعمال ہونے والا ہیش فنکشن ایک درست ہیش فنکشن ہے۔اگر ہیش فنکشن درست نہیں ہے تو ، طریقوں کو متوقع 123456.1geeksforgeeks2eduredureka3geeksforgeeks4realpython5scaler6tutorialsPoint کے طور پر کام نہیں کیا جاسکتا ہے"
    },
    {
        "Question": "یہ پروگرام بنائیں کہ آیا دیئے گئے اسٹرنگ ایک درست سوڈوکو حل ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی سٹرنگ ایک درست سوڈوکو حل ہے ، ہم وسائل 12345AS حوالہ جات استعمال کرسکتے ہیں۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف IS_Valid_sudoku (بورڈ): # بورڈ میں قطار کے لئے قطاریں چیک کریں: اگر نہیں ہے IS_Valid_unit (قطار): رینج میں کالم کے لئے غلط # کالم واپس کریں (9): کالم = [بورڈ [ROW [ROW] [کرنل] رینج میں قطار کے لئے (9)] اگر نہیں is_valid_unit (کالم): رینج (0 ، 9 ، 3) میں قطار کے لئے غلط # چیک سب گرڈ واپس کریں (0 ، 9 ، 3) کے لئے (0 ، 9 ، 3):subgrid = [بورڈ [r] [c] R کے لئے رینج (قطار ، قطار+3) سی کے لئے رینج (کرنل ، کرنل+3)] اگر نہیں is_valid_unit (subgrid): غلط واپسی truedef is_valid_unit (یونٹ): یونٹ= [i i in یونٹ کے لئے اگر میں!فنکشن سب سے پہلے IS_Valid_unit فنکشن کا استعمال کرتے ہوئے بورڈ کی ہر قطار کی جانچ پڑتال کرتا ہے ، جس کی جانچ پڑتال کرتی ہے کہ اگر قطار میں صرف 1 سے 9 تک کے منفرد ہندسے موجود ہیں۔ پھر فنکشن بورڈ کے ہر کالم کو فہرست کی تفہیم کا استعمال کرتے ہوئے چیک کرتا ہے ، اور ہر ایک سب گرڈ کو چیک کرتا ہے۔نیسڈ لوپ کا استعمال کرتے ہوئے بورڈ۔اگر کوئی قطار ، کالم ، یا سب گرڈ غلط ہے تو ، فنکشن غلط لوٹاتا ہے۔اگر تمام قطاریں ، کالم ، اور سب گرڈ درست ہیں تو ، فنکشن درست لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ میں آئی ایس_والڈ_سوڈوکو () فنکشن کا استعمال کیا جاتا ہے تاکہ یہ جانچ پڑتال کی جاسکے کہ دیئے گئے سٹرنگ ایک درست سوڈوکو حل ہے: ازگر بورڈ = [[\"5\"، \"3\" ، \".\" ، \".\" ، \"7\" ، \".\" ، \"،\". \"،\". \"،\". \"] ، [\" 6 \"،\". \"،\". \"،\" 1 \"، \"9\" ، \"5\" ، \".\" ، \".\" ، \".\"] ، [\".\" ، \"9\" ، \"8\" ، \".\" ، \".\" ، \".\". \"،\". \".\"، \"6\" ، \"۔4 \"،\". \"،\". \"،\" 8 \"،\". \"،\" 3 \"،\" ، \".\" ، \".\" ، \"1\"] ، [\"7\" ، \".\" ، \".\" ، \"،\" ، \". \"،\" 2 \"،\". \"،\". \"،\". \"،\" 6 \"] ، [\". \"،\" 6 \"،\". \"،\". \"،\". \"،\". \".\" ، \"،\"2 \"،\" 8 \"،\". \"] ، [\". \"،\". \"،\". \"،\" 4 \"،\" 1 \"،\" 9 \"،\". \"،\". \"،\" ، \"5\"] ،[\".\" ، \".\" ، \".\" ، \".\" ، \"8\" ، \"،\". \".\" ، \"7\" ، \"9\"]] نتیجہ = is_valid_sudoku (بورڈ) پرنٹ (نتیجہ) یہ ہوگاآؤٹ پٹ: ٹرو نٹ کہ یہ طریقہ یہ فرض کرتا ہے کہ ان پٹ بورڈ ایک درست 2D فہرست ہے جو سوڈوکو حل کی نمائندگی کرتی ہے۔اگر ان پٹ درست نہیں ہے تو ، فنکشن توقع کے مطابق کام نہیں کرسکتا ہے۔نیز ، فنکشن یہ فرض کرتا ہے کہ سوڈوکو حل سوڈوکو کے معیاری قواعد کی پیروی کرتا ہے ، جس میں ہر قطار ، کالم اور سب گرڈ کی ضرورت ہوتی ہے جس میں صرف 1 سے 9 تک کے انوکھے ہندسے ہوتے ہیں۔ اگر سوڈوکو حل ان قواعد پر عمل نہیں کرتا ہے تو ، فنکشن ہوسکتا ہے۔توقع 12345.1 interviewive2leetcode3geeksforgeeks4educative5geeksforgeeks کے طور پر کام نہیں کریں"
    },
    {
        "Question": "بلٹ ان افعال کا استعمال کیے بغیر دیئے گئے نمبر کے مربع جڑ کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "بلٹ ان افعال کا استعمال کیے بغیر دیئے گئے نمبر کے مربع جڑ کا حساب لگانے کے لئے ، بہت سارے نقطہ نظر ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: بلٹ ان افعال کا استعمال کیے بغیر دیئے گئے نمبر کے مربع جڑ کا حساب لگانے کے لئے بابل کے طریقہ کار کا استعمال بابل کے طریقہ کار کو استعمال کرنا ہے ، جسے ہیرون کے طریقہ کار کے نام سے بھی جانا جاتا ہے۔یہ طریقہ ایک تکراری طریقہ ہے جو ابتدائی اندازہ استعمال کرتا ہے اور اندازہ کو بہتر بناتا ہے جب تک کہ یہ تعداد کے مربع جڑ میں نہ آجائے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف ایس کیو آر ٹی (نمبر): اگر نمبر <0: کوئی بھی نہیں لوٹ اگر نمبر == 0: واپس 0 اندازہ = نمبر / 2 جبکہ ABS (اندازہ * اندازہ - نمبر)> 0.0001: اندازہ =۔فنکشن اس نمبر کے مربع جڑ کے طور پر اندازہ لوٹاتا ہے۔آؤٹ پٹ: 5.000023178253949method 2: بلٹ ان افعال کا استعمال کیے بغیر کسی دیئے گئے نمبر کے مربع جڑ کا حساب لگانے کے لئے بائنری سرچین کا طریقہ استعمال کرنا بائنری تلاش کا استعمال کرنا ہے۔ہم 0 کی نچلی حد اور نمبر کی اوپری حد کے ساتھ شروع کرسکتے ہیں ، اور تکرار سے حدود کو بہتر بنا سکتے ہیں جب تک کہ ہم نمبر کے مربع جڑ میں نہ آجائیں۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف ایس کیو آر ٹی (نمبر): اگر نمبر <0: کوئی بھی نہیں لوٹیں اگر نمبر == 0: واپس 0 لوئر_باؤنڈ = 0 اوپری_باؤنڈ = نمبر جبکہ سچ ہے: وسط = (لوئر_باؤنڈ + اوپری_باؤنڈ) / 2 اگرABS (MID * MID - NUM) <0.0001: مڈ ایلف مڈ * وسط <نمبر: لوئر_باؤنڈ = وسط: اوپری_ باؤنڈ = مڈ اس فنکشن میں ایک نمبر ان پٹ NUM لیتا ہے ، نچلے حصے کو 0 اور اوپری پابند نمبر ہونے کے لئے شروع کرتا ہے، اور بائنری تلاش کا استعمال کرتے ہوئے حدود کو تکرار سے بہتر بناتا ہے جب تک کہ وہ تعداد کے مربع جڑ میں نہ آجائیں۔فنکشن نمبر کے مربع جڑ کے طور پر حدود کے وسط نقطہ کو لوٹاتا ہے۔) اس کی پیداوار ہوگی: 5.00000000000000001 نوٹ جو دونوں طریقوں سے یہ فرض کیا جاتا ہے کہ ان پٹ نمبر ایک درست نمبر ہے۔اگر ان پٹ درست نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال بڑی تعداد میں یا بہت سے اعشاریہ 123456.1jdhao2edureka3stackoverflow4orcodeworld5tutorialspوائنٹ 6youtube کے ساتھ تعداد کے ل accurate درست نہیں ہوسکتے ہیں"
    },
    {
        "Question": "دی گئی فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی دی گئی فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: طریقہ 1: دی گئی فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے لئے سیٹ ون طریقہ کا استعمال ایک سیٹ کا استعمال کرنا ہے۔ہم اس فہرست کو ایک سیٹ میں تبدیل کرسکتے ہیں ، جو نقلیں ہٹاتا ہے ، اور پھر سیٹ میں موجود عناصر کی تعداد گن سکتا ہے۔یہاں ایک مثال کے طور پر ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف کاؤنٹی_ڈیسٹنٹ (ایل ایس ٹی): ریٹرن لین (سیٹ (ایل ایس ٹی)) یہ فنکشن ایک فہرست ان پٹ ایل ایس ٹی لیتا ہے ، اسے سیٹ () فنکشن کا استعمال کرتے ہوئے ایک سیٹ میں تبدیل کرتا ہے ، اور عناصر کی تعداد کو واپس کرتا ہے۔لین () فنکشن کا استعمال کرتے ہوئے سیٹ میں۔فنکشن فہرست میں الگ الگ عناصر کی تعداد کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ کسی دیئے گئے فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے لئے COUNT_DISTINCT () فنکشن کا استعمال کرتا ہے: پائیٹونلسٹ = [1 ، 2 ، 3 ، 2 ، 1 ،4 ، 5 ، 4 ، 6] نتیجہ = گنتی_ڈسٹنٹ (LST) پرنٹ (نتیجہ) اس کی پیداوار ہوگی: 6 میتھوڈ 2: دی گئی فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے لئے لغت کا ایک طریقہ استعمال کرنا لغت کا استعمال کرنا ہے۔ہم لوپ کا استعمال کرتے ہوئے فہرست میں تکرار کرسکتے ہیں ، اور ہر عنصر کو کلید کے طور پر لغت میں شامل کرسکتے ہیں۔چونکہ کسی لغت میں ڈپلیکیٹ کیز نہیں ہوسکتی ہیں ، اس سے نقلیں ختم ہوجائیں گی۔اس کے بعد ہم لغت میں چابیاں کی تعداد گن سکتے ہیں۔یہاں ایک مثال ازگر فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھنڈف کاؤنٹی_ڈیسٹنٹ (ایل ایس ٹی): ایل ایس ٹی میں الیوم کے لئے الگ الگ_ڈکٹ = {}لوپ کا استعمال کرتے ہوئے فہرست میں تکرار کرتا ہے ، ہر عنصر کو کلید کے طور پر لغت میں شامل کرتا ہے ، اور لین () فنکشن کا استعمال کرتے ہوئے لغت میں چابیاں کی تعداد واپس کرتا ہے۔فنکشن فہرست میں الگ الگ عناصر کی تعداد کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل ازگر کوڈ کسی دیئے گئے فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے لئے COUNT_DISTINCT () فنکشن کا استعمال کرتا ہے: پائیٹونلسٹ = [1 ، 2 ، 3 ، 2 ، 1 ،4 ، 5 ، 4 ، 6] نتیجہ = گنتی_ڈسٹنٹ (LST) پرنٹ (نتیجہ) اس کی پیداوار: 6 نوٹ کریں گے کہ دونوں طریقے یہ فرض کرتے ہیں کہ ان پٹ LST ایک درست فہرست ہے۔اگر ان پٹ درست فہرست نہیں ہے تو ، افعال توقع کے مطابق کام نہیں کرسکتے ہیں۔نیز ، افعال یہ فرض کرتے ہیں کہ فہرست میں صرف ہاشیبل عناصر شامل ہیں۔اگر اس فہرست میں ناقابل شکست عناصر شامل ہیں تو ، لغت کے نقطہ نظر کی توقع کی توقع 123456.1pythonpool2Datagy3studytonight4geeksforgeeks5geeksforgeeks6finxter کے طور پر نہیں ہوسکتی ہے"
    },
    {
        "Question": "ایک ازگر کی کلاس بنائیں جس میں ایک ہدایت شدہ وزن والے گراف کی نمائندگی کی جائے اور ٹوپولوجیکل قسم کو انجام دینے کے طریقوں کو نافذ کریں۔",
        "Answer": "ایک ازگر کلاس بنانے کے لئے جو ایک ہدایت شدہ وزن والے گراف کی نمائندگی کرتا ہے اور ٹوپولوجیکل طرح کے انجام دینے کے طریقوں کو نافذ کرتا ہے ، ہم وسائل 123456 اے حوالہ جات کو استعمال کرسکتے ہیں۔یہاں ایک مثال کے طور پر ازگر کلاس ہے جو اس نقطہ نظر کو نافذ کرتی ہے: ازگر کے کلیکشن درآمد ڈیفالٹ ڈکٹکلاس گراف: ڈیف __init __ (خود): سیلف گراف = ڈیفالٹ ڈکٹ (فہرست) سیلف ۔ٹوریس = سیٹ () ڈیف ایڈ_ج (سیلف ، یو ، وی ، وزن): خود: خود). گراف [u] .append ((v ، وزن)) self.vertices.add (u) self.vertices.add (v) Def topological_sort (خود)u میں خود۔.لین (نتیجہ)! = لین (سیلف .ورٹیکس): واپسی کسی کے پاس نہیں واپسی کے نتیجے میں اس کلاس میں __init__ کا طریقہ ہوتا ہے جو گراف کے عمودی حصے کو ذخیرہ کرنے کے لئے کناروں کو ذخیرہ کرنے کے لئے خالی لغت کا گراف شروع کرتا ہے۔کلاس میں ایک ایڈ_ج کا طریقہ ہے جو ایک ماخذ ورٹیکس یو ، منزل مقصود ورٹیکس وی ، اور وزن کے وزن میں لیتا ہے ، اور گراف میں کنارے اور عمودی سیٹ میں شامل کرتا ہے۔کلاس کے پاس ٹوپولوجیکل_سورٹ کا طریقہ ہے جو کاہن کے الگورتھم کا استعمال کرتے ہوئے گراف پر ٹوپولوجیکل ترتیب دیتا ہے۔اس طریقہ کار میں سب سے پہلے ہر خطوط کی ان ڈگری کو ذخیرہ کرنے کے لئے ایک ڈکشنری in_degree شروع کرتا ہے ، اور کناروں کے ذریعے تکرار کرکے ہر دور کی ڈگری کی گنتی کرتا ہے۔اس کے بعد یہ طریقہ کار میں ایک قطار کا آغاز کرتا ہے جس میں ڈگری 0 ہوتی ہے ، اور تکرار سے قطار سے ایک چوٹی کو ہٹا دیتا ہے ، اسے نتائج کی فہرست میں شامل کرتا ہے ، اور جب تک قطار خالی نہ ہو تب تک اپنے پڑوسیوں کی ان ڈگری کو اپ ڈیٹ کرتا ہے۔طریقہ کار نتیجہ کی فہرست کو لوٹاتا ہے اگر اس میں تمام عمودی حصے ہوں ، یا کوئی بھی نہیں تو اگر یہ نہیں ہوتا ہے۔('a' ، 'b' ، 1) g.add_edge ('a' ، 'c' ، 1) g.add_edge ('b' ، 'd' ، 1) g.add_edge ('c' ، 'd'.E '] نوٹ کریں کہ یہ طریقہ یہ فرض کرتا ہے کہ ان پٹ ایج درست ہیں اور گراف ایک ہدایت شدہ ایسائکلک گراف ہے۔اگر ان پٹ درست نہیں ہے یا گراف میں سائیکل شامل ہیں تو ، طریقہ کار کی توقع کے مطابق 123456.1stackexchange2geeksforgeks3stackoverflow4favtor5youtube6geeksforgeks کے طور پر کام نہیں کرسکتا ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین کے ساتھ ایک درست اظہار ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین کے ساتھ ایک درست اظہار ہے یا نہیں ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔خیال یہ ہے کہ تار کو عبور کرنا اور ہر افتتاحی قوسین کو اسٹیک پر دھکیلنا ہے۔جب ہم کسی اختتامی قوسین کا سامنا کرتے ہیں تو ، ہم اسٹیک سے ٹاپ عنصر کو پاپ کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ اختتامی قوسین سے مماثل ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، ہم ٹراورسل کے ساتھ جاری رہتے ہیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم جانتے ہیں کہ اظہار درست نہیں ہے اور ہم غلط کو واپس کرسکتے ہیں۔ٹریورسل کے اختتام پر ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین متوازن ہیں اور ہم سچ کو لوٹ سکتے ہیں۔بصورت دیگر ، اظہار درست نہیں ہے ۔123. C ++ میں مذکورہ بالا نقطہ نظر کی ایک مثال کے نفاذ <iostream>#شامل <اسٹیک>#شامل <سٹرنگ> بول isvalidexpression (std :: string s) {std :: اسٹیک <چار> st ؛(چار سی: ایس) کے لئے {اگر (c == '(' || c == '{' || c == '[') {st.push (c) ؛} else اگر (c == ')'|| c =='} '|| c =='] ') {اگر (st.empty ()) {غلط واپس ؛} دوسری صورت میں ((c == ')' && st.top () == '(')) || (c == '}' && st.top () == '{') || (c ==']' && St.top () == '[' ')) {st.pop () ؛} دوسری {جھوٹی لوٹ ؛}}} واپس St.empty () ؛} INT مین () {std :: سٹرنگ S1 = \"((()))) () ()\" ؛std :: سٹرنگ s2 = \"()) ((())\" ؛ std :: cout << s1 << \"IS\" << (isvalidexpression (s1)؟ \"درست\": \"غلط\") << std ::اینڈل ؛ std :: cout << s2 << \"IS\" << (isvalidexpression (s2)؟ \"درست\": \"غلط\") << std :: endl ؛ واپسی 0 ؛} یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے isvalidexpression ())ان پٹ کے طور پر ایک تار لیتا ہے اور سچ واپس آجاتا ہے اگر متوازن قوسین کے ساتھ سٹرنگ ایک درست اظہار ہے ، اور دوسری صورت میں۔ یہ کرداروں کا ایک اسٹیک شروع کرتا ہے اور کردار کے ذریعہ تار کے کردار کو عبور کرتا ہے۔ اگر کردار افتتاحی قوسین ہے تو ، اسے اس پر دھکیل دیا جاتا ہے۔اسٹیک. اگر کردار بند ہونے والی قوسین ہے تو ، اس کا موازنہ اسٹیک کے اوپری عنصر سے کیا جاتا ہے۔ اگر وہ میچ کرتے ہیں تو ، اوپر عنصر اسٹیک سے پاپ ہوتا ہے۔ اگر وہ مماثل نہیں ہیں تو ، اظہار درست نہیں ہے۔ آخر میں۔ٹراورسل میں سے ، اگر اسٹیک خالی ہے تو ، اظہار درست ہے۔ بصورت دیگر ، یہ درست نہیں ہے۔ پھر پروگرام دو مثال کے تاروں کے ساتھ اس کی جانچ کرتا ہے اور نتائج کو پرنٹ کرتا ہے۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عدد کی ایک دی گئی فہرست میں غیر ملکی عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ان پٹ لسٹ کی طرح لمبائی کے ایک سرنی ڈی پی کی وضاحت کرسکتے ہیں ، جہاں ڈی پی [i] انڈیکس I پر ختم ہونے والے غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم کی نمائندگی کرتا ہے۔اس کے بعد ہم ڈی پی سرنی کو پُر کرنے کے لئے درج ذیل تکرار کے تعلق کا استعمال کرسکتے ہیں: ڈی پی [0] = آر آر [0] ڈی پی [1] = زیادہ سے زیادہ (ار [0] ، آر آر [1]) ڈی پی [i] = زیادہ سے زیادہ (ڈی پی [I-2] + arr [i] ، dp [i-1]) پہلے دو بیس کیس سیدھے ہیں۔عام معاملے کے ل we ، ہمارے پاس دو انتخاب ہیں: یا تو ہم موجودہ عنصر کو رقم میں شامل کرتے ہیں ، اس صورت میں زیادہ سے زیادہ رقم DP [I-2] + arr [i] ہے ، یا ہم موجودہ عنصر کو خارج کرتے ہیں ، اس صورت میںزیادہ سے زیادہ رقم DP [I-1] ہے۔ہم ان دو انتخابوں میں سے زیادہ سے زیادہ ڈی پی [i] کی قیمت کے طور پر لیتے ہیں۔آخر میں ، ان پٹ لسٹ میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم ڈی پی [N-1] کے ذریعہ دی گئی ہے ، جہاں N ان پٹ لسٹ کی لمبائی ہے۔ ہورہ میں مذکورہ بالا نقطہ نظر کا ایک مثال عمل میں ہے: پائیتھنڈف میکس_سم_نون_اڈجینٹ (اے آر آر): n = len (arr) اگر n == 0: واپس 0 Elif n == 1: واپسی arr [0] dp = [0] * n dp [0] = arr [0] dp [1] = زیادہ سے زیادہ (arr[0] ، arr [1]) I in range (2 ، n) کے لئے: dp [i] = زیادہ سے زیادہ (dp [i-2] + arr [i] ، dp [i-1]) واپسی dp [n-1] اس پروگرام میں ایک فنکشن میکس_سم_نون_اڈجینٹ () کی وضاحت کی گئی ہے جو ان پٹ کے طور پر عددیوں کی فہرست لیتا ہے اور فہرست میں غیر ملکی عناصر کی زیادہ سے زیادہ رقم واپس کرتا ہے۔یہ پہلے بیس معاملات کو سنبھالتا ہے جہاں ان پٹ لسٹ خالی ہے یا اس میں صرف ایک عنصر ہوتا ہے۔اس کے بعد یہ ڈی پی سرنی کو شروع کرتا ہے اور مذکورہ بالا تکرار رشتہ کا استعمال کرتے ہوئے اسے بھرتا ہے۔آخر میں ، یہ غیر ملکی عناصر کی زیادہ سے زیادہ رقم واپس کرتا ہے ، جو ڈی پی [N-1] کے ذریعہ دیا جاتا ہے ، جہاں N ان پٹ کی فہرست کی لمبائی ہے۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک سٹرنگ تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے ل several کئی نقطہ نظر موجود ہیں۔سب سے زیادہ سیدھے سادے طریقوں میں سے ایک بروٹ فورس نقطہ نظر ہے ، جس میں یہ چیک کرنا شامل ہے کہ آیا ہر سٹرنگ ایک پیلنڈرووم ہے یا نہیں۔اس نقطہ نظر میں O (n^3) کی وقت کی پیچیدگی ہے اور O (1) 12 کی خلائی پیچیدگی ہے۔ ایک زیادہ موثر نقطہ نظر متحرک پروگرامنگ کا استعمال کرنا ہے۔ہم سائز N X N کی 2D بولین سرنی ٹیبل کی وضاحت کرسکتے ہیں ، جہاں ٹیبل [i] [j] سچ ہے اگر انڈیکس I سے انڈیکس جے تک سبسٹرنگ ایک پیلنڈرووم ہے ، اور دوسری صورت میں غلط ہے۔اس کے بعد ہم ٹیبل سرنی کو پُر کرنے کے لئے درج ذیل تکرار کا رشتہ استعمال کرسکتے ہیں: ٹیبل [i] [i] = truetable [i] [i+1] = (s [i] == s [i+1]) ٹیبل [i] [j] = (s [i] == s [j] && ٹیبل [i+1] [J-1]) پہلے دو بیس کیس سیدھے ہیں۔عام معاملے کے ل we ، ہمارے پاس دو انتخاب ہیں: یا تو انڈیکس I سے انڈیکس جے تک کا سبسٹرنگ ایک پیلنڈرووم ہے ، اس صورت میں ٹیبل [i] [j] سچ ہے اگر انڈیکس I اور J کے کردار برابر ہوں اور انڈیکس سے سٹرنگI+1 سے انڈیکس J-1 ایک پالندرووم ہے ، یا یہ کوئی پیلنڈرووم نہیں ہے۔آخر میں ، ہم ٹیبل سرنی پر تکرار کرسکتے ہیں اور سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرسکتے ہیں۔اس نقطہ نظر میں O (n^2) کی ایک وقت کی پیچیدگی اور O (n^2) 134526 کی جگہ کی پیچیدگی ہے۔ ہر ایک مثال کے طور پر ازگر میں متحرک پروگرامنگ نقطہ نظر کی ایک مثال ہے: پائیتھونڈف طویل ترین_پالینڈرمک_سوبسٹرنگ (s): n = len (s)اگر n == 0: واپس \"ٹیبل = [[غلط] * n _ _ رینج (n) کے لئے]] شروع کریں = 0 میکسلن = 1 کے لئے I کے لئے (n): ٹیبل [i] [i] = I کے لئے سچ ہےرینج (N-1) میں: اگر s [i] == s [i+1]: ٹیبل [i] [i+1] = حقیقی آغاز = i میکسلن = 2 رینج میں K کے لئے (3 ، n+1): I In Range (n-k+1): j = i+k-1 اگر s [i] == s [j] اور ٹیبل [i+1] [j-1]: ٹیبل [i] [j] = سچ ہے اگر K> میکسلن: اسٹارٹ = i میکسلن = K ریٹرن ایس [اسٹارٹ: اسٹارٹ+میکسلن] یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے جس میں سب سے طویل_palindromic_substring () ہوتا ہے جو ان پٹ کے طور پر ایک تار لیتا ہے اور تار میں سب سے طویل پیلنڈرمک سبسٹرنگ کو لوٹاتا ہے۔یہ پہلے بیس کیس کو سنبھالتا ہے جہاں ان پٹ سٹرنگ خالی ہے۔اس کے بعد یہ ٹیبل سرنی کو شروع کرتا ہے اور مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے اسے بھرتا ہے۔آخر میں ، یہ ٹیبل سرنی کے اوپر تکرار کرتا ہے اور سب سے طویل پیلنڈرومک اسٹرنگ پایا جاتا ہے۔اس کے بعد یہ پروگرام سب سے طویل پیلنڈرومک اسٹرنگ لوٹتا ہے"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ کم سے کم حرفوں کی کم سے کم تعداد کو کسی تار سے نکال دیا جاسکے تاکہ اسے پیلنڈرو کر دیا جاسکے۔",
        "Answer": "اس کو ایک پالندرووم بنانے کے لئے کسی تار سے ہٹانے کے لئے کم سے کم حرفوں کی تلاش کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم سائز N X N کے 2D سرنی DP کی وضاحت کرسکتے ہیں ، جہاں DP [i] [J] انڈیکس I سے انڈیکس جے تک کے سب سے طویل عرصے میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے.اس کے بعد ہم ڈی پی سرنی کو پُر کرنے کے لئے درج ذیل تکرار کے تعلق کا استعمال کرسکتے ہیں: ڈی پی [i] [i] = 1dp [i] [j] = dp [i + 1] [j-1] + 2 اگر s [i] == s [j] dp [i] [j] = زیادہ سے زیادہ (dp [i+1] [j] ، dp [i] [j-1]) اگر s [i]! = s [j] پہلا بیس کیسسیدھا ہے۔عام معاملے کے ل we ، ہمارے پاس دو انتخاب ہیں: یا تو انڈیکس I اور J کے کردار برابر ہیں ، اس صورت میں سب سے طویل palindromic متضاد کی لمبائی DP [I + 1] [J-1] + 2 ہے ، یا وہ نہیں ہیںبرابر ، جس معاملے میں ہم انڈیکس I+1 سے انڈیکس جے تک اور انڈیکس I سے انڈیکس I تک انڈیکس I تک کے سب سے زیادہ لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے لیتے ہیں۔آخر میں ، اس کو ایک پالندرووم بنانے کے لئے تار سے ہٹانے کے لئے کم سے کم حرفوں کی کم سے کم تعداد N - DP [N -1] کے ذریعہ دی گئی ہے ، جہاں N ان پٹ سٹرنگ کی لمبائی ہے۔ یہاں متحرک پروگرامنگ نقطہ نظر کی ایک مثال عمل میں ہے۔ازگر: پائیتھنڈف من_ڈیلیٹیشن_ٹو_میک_پالینڈرووم (ایس): این = لین (ایس) اگر این == 0: واپس 0 ڈی پی = [[[0] * n رینج (این)] کے لئے رینج (این) کے لئے (این): ڈی پی [i][i] = 1 رینج میں K کے لئے (2 ، n+1): رینج میں Ii] [j] = dp [i+1] [J-1]+2 اور: dp [i] [j] = زیادہ سے زیادہ (dp [i+1] [j] ، dp [i] [J-1]) واپسی N - DP [0] [N -1] اس پروگرام میں ایک فنکشن Min_deletions_to_make_palindrome () کی وضاحت کی گئی ہے جو ان پٹ کے طور پر ایک تار لیتا ہے اور اس کو ایک پیلنڈرووم بنانے کے لئے کم سے کم حرفوں کو تار سے ہٹانے کے لئے واپس کرتا ہے۔یہ پہلے بیس کیس کو سنبھالتا ہے جہاں ان پٹ سٹرنگ خالی ہے۔اس کے بعد یہ ڈی پی سرنی کو شروع کرتا ہے اور مذکورہ بالا تکرار رشتہ کا استعمال کرتے ہوئے اسے بھرتا ہے۔آخر میں ، اس کو ایک پالندرووم بنانے کے لئے تار سے ہٹانے کے لئے کم سے کم تعداد کو واپس کرتا ہے ، جسے N - DP [N -1] نے دیا ہے ، جہاں N ان پٹ کی لمبائی ہے۔"
    },
    {
        "Question": "بائنری میکس ہیپ کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور زیادہ سے زیادہ عنصر کو داخل کرنے اور نکالنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "زیادہ سے زیادہ عنصر داخل کرنے اور نکالنے کے لئے بائنری میکس ہیپ اور طریقوں کی نمائندگی کرنے والے ایک ازگر کلاس کا نفاذ یہاں ہے: ازگر کلاس میکسیپ: ڈیف __init __ (خود): سیلف ۔ہپ = [] ڈیف والدین (خود ، i): واپسی (i - -1) // 2 ڈیف بائیں (خود ، i): واپسی 2 * i + 1 ڈیف دائیں (خود ، i): واپس 2 * i + 2 def get_max (خود): اگر len (self.heap) == 0:کوئی بھی واپس نہیں لوٹ کر۔ ہیپ [0] ڈیف ایکسٹریکٹ_میکس (خود): اگر لین (سیلف ایچ ای اے پی) == 0: اگر لین (سیلف۔ ہیپ) == 1: واپس نہیں کریں تو خود واپس کریں۔.HEAP [0] self.heap [0] = self.heap.pop () self.max_heapify (0) واپسی میکس_وال ڈیف میکس_ہیپائیف (خود ، i): l = sell.left (i) r = self.right (i) سب سے بڑا = i اگر l <len (self.heap) اور self.heap [l]> سیلف۔ ہیپ [سب سے بڑا]: سب سے بڑا = l اگر r <len (self.heap) اور self.heap [r]> خود۔ہیپ [سب سے بڑا]: سب سے بڑا = r اگر سب سے بڑا! = i: self.swap (i ، سب سے بڑا) سیلف۔ میکس_ہیپائیف (سب سے بڑا) ڈیف سویپ (خود ، i ، j)] = self.heap [j] ، self.heap [i] Def داخل کریں (خود ، کلید): self.heap.append (key) i = len (self.heap) - 1 جبکہ میں![سیلف پیئرنٹ (i)] <سیلف۔ ہیپ [i]: سیلف.سوپ (i ، self.palent (i)) i = self.palent (i) یہ کلاس بائنری میکس ہیپ کی وضاحت کرتا ہے اور مندرجہ ذیل طریقوں کو نافذ کرتا ہے: __ init__: ایک خالی ڈھیر۔ پیرنٹ ، بائیں ، دائیں: والدین ، بائیں بچے ، اور دیئے گئے انڈیکس کے دائیں بچے کے اشارے حاصل کرنے کے لئے مددگار طریقے۔ گیٹ_میکس: ڈھیر میں زیادہ سے زیادہ عنصر کو اسے ہٹائے بغیر واپس کرتا ہے۔ڈھیر میں زیادہ سے زیادہ عنصر لوٹاتا ہے۔ میکس_ہایپائف: کسی دیئے گئے انڈیکس پر زیادہ سے زیادہ ہیپ پراپرٹی کو برقرار رکھتا ہے۔ ایس ڈبلیو اے پی: ڈھیر میں دو عناصر کو تبدیل کرتا ہے۔ INSERT: ڈھیر میں ایک نیا عنصر داخل کرتا ہے اور زیادہ سے زیادہ ہیپ پراپرٹی کو برقرار رکھتا ہے۔ اس کو استعمال کریں۔کلاس ، آپ میکسیپ کی ایک مثال تشکیل دے سکتے ہیں اور اس کے طریقوں کو مندرجہ ذیل طور پر کال کرسکتے ہیں: پائیتھونھیپ = میکس ہیپ () ہیپ۔ انرٹ (5) ہیپ.نسرٹ (3) ہیپ.سرٹ (8) پرنٹ (ہیپ.جیٹ_میکس ()) # آؤٹ پٹ:8 پرنٹ (ہیپ.ایکسٹرک_میکس ()) # آؤٹ پٹ: 8 پرنٹ (ہیپ.جیٹ_میکس ()) # آؤٹ پٹ: 5 یہ پروگرام میکس ہیپ کی ایک مثال بناتا ہے ، ڈھیر میں تین عناصر داخل کرتا ہے ، اور get_max کے طریقہ کار کا استعمال کرتے ہوئے زیادہ سے زیادہ عنصر کو پرنٹ کرتا ہے۔اس کے بعد یہ نچوڑ_میکس کے طریقہ کار کا استعمال کرتے ہوئے زیادہ سے زیادہ عنصر نکالتا ہے اور اسے پرنٹ کرتا ہے۔آخر میں ، یہ get_max کے طریقہ کار کا استعمال کرتے ہوئے نیا زیادہ سے زیادہ عنصر پرنٹ کرتا ہے۔"
    },
    {
        "Question": "کسی فہرست میں پہلا دہرانے والے عنصر کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "فہرست میں پہلا دہرانے والے عنصر کو تلاش کرنے کے بہت سے طریقے ہیں۔ایک آسان ترین طریقوں میں سے ایک یہ ہے کہ ہر عنصر کا موازنہ کرنے والے تمام عناصر کے ساتھ ہر عنصر کا موازنہ کرنے کے لئے گھوںسلا لوپ کا استعمال کیا جائے۔اگر دہرانے والا عنصر مل جاتا ہے تو ، ہم اسے واپس کرسکتے ہیں۔اس نقطہ نظر میں O (n^2) کی وقت کی پیچیدگی اور O (1) 12 کی خلائی پیچیدگی ہے۔ ایک زیادہ موثر نقطہ نظر ہر عنصر کی تعدد کو ٹریک رکھنے کے لئے ہیش ٹیبل کا استعمال کرنا ہے۔ہم فہرست میں تکرار کرسکتے ہیں اور ہر عنصر کو ہیش ٹیبل میں شامل کرسکتے ہیں۔اگر کوئی عنصر پہلے ہی ہیش ٹیبل میں ہے تو ، اس کا مطلب ہے کہ یہ ایک دہرانے والا عنصر ہے اور ہم اسے واپس کرسکتے ہیں۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (n) کی جگہ کی پیچیدگی ہے۔میں فریک میں: ریٹرن I freq [i] = 1 ریٹرن نونتھیس پروگرام ایک فنکشن کی وضاحت کرتا ہے جس میں فرسٹ_ریپیٹنگ_یلیمنٹ () کی وضاحت ہوتی ہے جو ان پٹ کے طور پر ایک فہرست لیتا ہے اور فہرست میں پہلا دہرانے والا عنصر لوٹاتا ہے۔یہ ایک خالی لغت فریک کی ابتدا کرتا ہے اور فہرست میں تکرار کرتا ہے۔ہر عنصر کے ل it ، یہ چیک کرتا ہے کہ آیا یہ پہلے ہی لغت میں ہے۔اگر یہ ہے تو ، اس کا مطلب ہے کہ یہ ایک دہرانے والا عنصر ہے اور پروگرام اسے واپس کرتا ہے۔بصورت دیگر ، اس کی تعدد کے ساتھ لغت میں عنصر کو شامل کرتا ہے۔6 ، 6] پرنٹ (فرسٹ_ریپیٹنگ_یلیمنٹ (ایل ایس ٹی)) # آؤٹ پٹ: 3 اس پروگرام میں ایک فہرست ایل ایس ٹی تشکیل دی جاتی ہے ، فہرست کے ساتھ ان پٹ کے ساتھ فرسٹ_ریپیٹنگ_لیمنٹ () فنکشن کو کال کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔آؤٹ پٹ فہرست میں پہلا دہرانے والا عنصر ہے ، جو 3.1educative2java2blog3geeksforgeeks4geeksforgeeks ہے"
    },
    {
        "Question": "دو ڈوروں کے مابین سب سے طویل عام مشترکہ حصول کی لمبائی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دو ڈوروں کے مابین سب سے طویل مشترکہ حصول کی لمبائی تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم سائز M+1 x n+1 کے 2D سرنی ڈی پی کی وضاحت کرسکتے ہیں ، جہاں ڈی پی [i] [j] پہلے سٹرنگ کے پہلے I حرفوں اور دوسرے کے پہلے J حروف کے درمیان سب سے طویل عام مشترکہ حصے کی لمبائی کی نمائندگی کرتا ہے۔تاراس کے بعد ہم ڈی پی سرنی کو پُر کرنے کے لئے درج ذیل تکرار کا رشتہ استعمال کرسکتے ہیں: ڈی پی [i] [j] = 0 اگر i == 0 یا j == 0dp [i] [j] = dp [i-1] [j-1] + 1 اگر s1 [i-1] == s2 [j-1] dp [i] [j] = زیادہ سے زیادہ (dp [i-1] [j] ، dp [i] [j-1]) اگرS1 [I-1]! = S2 [J-1] پہلا بیس کیس سیدھا ہے۔عام معاملے کے ل we ، ہمارے پاس دو انتخاب ہیں: یا تو دونوں ڈوروں کے آخری کردار برابر ہیں ، اس صورت میں سب سے طویل عام مشترکہ کی لمبائی DP [I-1] [J-1] + 1 ہے ، یا وہ نہیں ہیں۔برابر ، جس معاملے میں ہم پہلے سٹرنگ کے پہلے I-1 حروف اور دوسرے تار کے پہلے J حروف کے درمیان ، اور پہلے تار کے پہلے I حرفوں اور پہلے کے درمیان زیادہ سے زیادہ عام مشترکہ حصول کی لمبائی لیتے ہیں۔دوسرے تار کے پہلے J-1 حروف۔آخر میں ، دونوں ڈوروں کے مابین سب سے طویل مشترکہ حصول کی لمبائی ڈی پی [ایم] [این] کے ذریعہ دی گئی ہے ، جہاں ایم اور این دو ان پٹ ڈوروں کی لمبائی ہیں۔ یہاں ازگر میں متحرک پروگرامنگ نقطہ نظر کی ایک مثال عمل: پائیتھنڈف: پائیتھنڈفسب سے طویل_کومون_سوبسینس (S1 ، S2): M ، n = لین (S1) ، لین (S2) dp = [[0] * (n+1) _ کے لئے _ کے لئے (M+1)] I کے لئے (1 ، ایم)+1): رینج میں جے کے لئے (1 ، n+1): اگر S1 [I-1] == S2 [J-1]: DP [i] [j] = dp [i-1] [J-1] + 1 اور: ڈی پی [i] [j] = زیادہ سے زیادہ (dp [i-1] [j] ، dp [i] [j-1]) واپسی dp [m] [n] یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے۔) جو ان پٹ کے طور پر دو ڈور لیتا ہے اور دونوں ڈوروں کے مابین سب سے طویل عام مشترکہ حصے کی لمبائی کو لوٹاتا ہے۔یہ ڈی پی سرنی کی ابتدا کرتا ہے اور مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے اسے بھرتا ہے۔آخر میں ، یہ دو تاروں کے مابین سب سے طویل عام مشترکہ کی لمبائی کو لوٹاتا ہے ، جو ڈی پی [ایم] [این] کے ذریعہ دیا جاتا ہے ، جہاں ایم اور این دو ان پٹ ڈوروں کی لمبائی ہیں۔ اس فنکشن کی ایک مثال ہے: ازگر 1= \"Aggtab\" S2 = \"gxtxayb\" پرنٹ (طویل ترین_کومون_سوبسینس (S1 ، S2)) # آؤٹ پٹ: 4 اس پروگرام میں دو ڈور S1 اور S2 تخلیق ہوتا ہے ، ان پٹ کے طور پر دو تار کے ساتھ طویل ترین_کومن_سوبسینس () کام کرتا ہے ، اور اس کے نتیجے میں پرنٹ کرتا ہے۔آؤٹ پٹ دونوں ڈوروں کے مابین سب سے طویل عام مشترکہ کی لمبائی ہے ، جو 4.1leetcode2geeksforgeeks3javatPoint4geeksforgeeks5programize ہے"
    },
    {
        "Question": "فہرست سے تمام ڈپلیکیٹ عناصر کو ہٹانے اور اصل ترتیب کو برقرار رکھنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "تمام ڈپلیکیٹ عناصر کو کسی فہرست سے ہٹانے اور اصل ترتیب کو برقرار رکھنے کے ل we ، ہم ان عناصر کو ٹریک رکھنے کے لئے ایک لغت کا استعمال کرسکتے ہیں جو پہلے ہی دیکھے گئے ہیں۔ہم فہرست میں تکرار کرسکتے ہیں اور ہر عنصر کو لغت میں شامل کرسکتے ہیں جس کی کلید سچ کی قدر ہے۔اگر کوئی عنصر پہلے سے ہی لغت میں ہے تو ، اس کا مطلب ہے کہ یہ ایک نقل ہے اور ہم اسے چھوڑ سکتے ہیں۔اس کے بعد ہم ایک نئی فہرست تشکیل دے سکتے ہیں جس میں وہ اصل فہرست میں نظر آنے والے ترتیب میں انفرادی عناصر کے ساتھ ہیں۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (n) 123 کی خلائی پیچیدگی ہے۔ یہاں ازگر میں لغت کے نقطہ نظر کی مثال کے طور پر عمل درآمد: Pythondef remost_duplicates (LST): دیکھا = {} نتیجہ = [] I in کے لئے I in کے لئےایل ایس ٹی: اگر میں نے نہیں دیکھا: دیکھا [i] = صحیح نتیجہ۔ اپینڈ (i) واپسی کے نتیجے میں یہ پروگرام ایک فنکشن کو ہٹانے کی وضاحت کرتا ہے۔ترتیب.یہ ایک خالی لغت اور خالی فہرست کا نتیجہ شروع کرتا ہے ، اور ان پٹ لسٹ پر تکرار کرتا ہے۔ہر عنصر کے ل it ، یہ چیک کرتا ہے کہ آیا یہ پہلے ہی لغت میں ہے۔اگر یہ نہیں ہے تو ، یہ لغت میں عنصر کو سچ کی قدر کے ساتھ شامل کرتا ہے اور اسے نتائج کی فہرست میں شامل کرتا ہے۔اگر یہ پہلے ہی لغت میں ہے تو ، یہ عنصر کو چھوڑ دیتا ہے۔آخر میں ، یہ نتیجہ کی فہرست لوٹاتا ہے۔ فنکشن کا ایک مثال استعمال ہے: پائیٹونلسٹ = [1 ، 2 ، 3 ، 2 ، 4 ، 3 ، 5 ، 6 ، 5] پرنٹ (ہٹائیں_ ڈوپلیکیٹس (LST)) # آؤٹ پٹ: [1 ،2 ، 3 ، 4 ، 5 ، 6] یہ پروگرام ایک فہرست LST تشکیل دیتا ہے ، ان پٹ کے بطور فہرست کے ساتھ ہٹ_ ڈوپلیکیٹس () فنکشن کو کال کرتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ ایک نئی فہرست ہے جس میں تمام ڈپلیکیٹ عناصر کو ہٹا دیا گیا ہے جبکہ اصل آرڈر کو برقرار رکھتے ہوئے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے یا نہیں ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔خیال یہ ہے کہ تار کو عبور کرنا اور ہر افتتاحی قوسین کو اسٹیک پر دھکیلنا ہے۔جب ہم کسی اختتامی قوسین کا سامنا کرتے ہیں تو ، ہم اسٹیک سے ٹاپ عنصر کو پاپ کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ اختتامی قوسین سے مماثل ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، ہم ٹراورسل کے ساتھ جاری رہتے ہیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم جانتے ہیں کہ اظہار درست نہیں ہے اور ہم غلط کو واپس کرسکتے ہیں۔ٹریورسل کے اختتام پر ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین متوازن ہیں اور ہم سچ کو لوٹ سکتے ہیں۔بصورت دیگر ، اظہار درست نہیں ہے۔ہم ہر اختتامی قوسین کے لئے ہر اختتامی قوسین کو نقشہ بنانے کے لئے لغت کا استعمال کرکے مختلف قسم کے قوسین کو سنبھالنے کے لئے مذکورہ بالا نقطہ نظر میں ترمیم کرسکتے ہیں۔اس کے بعد ہم چیک کرسکتے ہیں کہ آیا اسٹیک کا اوپری عنصر اختتامی قوسین کے لئے اسی افتتاحی قوسین سے مماثل ہے یا نہیں۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (n) 123 کی ایک جگہ کی پیچیدگی ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی ایک مثال عمل ہے: پائیتھنڈف is_valid_parenthess (s): اسٹیک = [] میپنگ = {\")\": \":\"(\" ، \"}\": \"{\" ، \"]\": \"[\" c میں سی کے لئے: اگر سی میپنگ میں سی: اگر اسٹیک یا اسٹیک نہیں ہے تو [-1]! = میپنگ [سی]: غلط اسٹیک لوٹائیں۔پاپ () الیف سی میپنگ۔ ویلیوز () (): اسٹیک.ایپینڈ (سی) ریٹرن نہیں اسٹیکتس پروگرام ایک فنکشن کی وضاحت کرتا ہے جس میں ایک فنکشن ہوتا ہے۔، اور دوسری صورت میں۔ یہ ایک اسٹیک اور ایک لغت کی نقشہ سازی کا آغاز کرتا ہے جو ہر بند ہونے والی قوسین کو اپنے اسی افتتاحی قوسین کے نقشوں کا نقشہ بناتا ہے۔ پھر اس کے ذریعہ تار کے کردار کو عبور کرتا ہے۔ اگر کردار اختتامی قوسین ہے تو ، یہ چیک کرتا ہے کہ کیا اسٹیک کا اوپری عنصر اسٹیک کا اوپری عنصراختتامی قوسین کے لئے اسی افتتاحی قوسین سے میل کھاتا ہے۔اگر ایسا ہوتا ہے تو ، اوپر عنصر اسٹیک سے پاپ ہوتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، اظہار درست نہیں ہے۔اگر کردار افتتاحی قوسین ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔آخر میں ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین متوازن ہیں اور پروگرام درست ہوجاتا ہے۔بصورت دیگر ، یہ جھوٹی لوٹاتا ہے۔ اس فنکشن کا ایک مثال استعمال ہے: ازگر 1 = \"() [] {}\" S2 = \"([)]\" S3 = \"{[]}\" پرنٹ (is_valid_parenthess (S1)) # آؤٹ پٹ:سچ پرنٹ (is_valid_parenthess (S2)) # آؤٹ پٹ: غلط پرنٹ (is_valid_parenthess (S3)) # آؤٹ پٹ: Truethis پروگرام تین ڈور S1 ، S2 ، اور S3 تیار کرتا ہے ، ہر تار کے ساتھ IS_Valid_parenthisis () کو ان پٹ کے طور پر فون کرتا ہے ، اور اس کے نتیجے میں پرنٹ کرتا ہے۔آؤٹ پٹ سچ ہے اگر تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے ، اور دوسری صورت میں غلط ہے۔"
    },
    {
        "Question": "سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور سامنے والے عنصر کو ہٹائے بغیر اسے حاصل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو سرکلر قطار کی نمائندگی کرتا ہے اور سامنے والے عنصر کو اسے ہٹائے بغیر حاصل کرنے کے لئے ایک طریقہ: پائیٹونکلاس سرکلر کیوئو: ڈیف __init __ (خود ، کے): سیلف۔ہیڈ = -1 سیلف۔خود ، اعداد و شمار): اگر self.is_full (): جھوٹا لوٹ اگر self.is_empty (): self.head = 0 سیلف۔ڈیٹا ریٹرن ٹرو ڈیف ڈی کیوئو (خود): اگر سیلف۔ آئی ایس_پٹی (): کوئی بھی نہیں ڈیٹا = سیلف۔ کیوئو [خود۔ ہیڈ] اگر سیلف۔ ہیڈ == سیلف۔ ٹیل: سیلف۔ ہیڈ = -1 سیلف۔ورنہ: self.head = (self.head + 1) ٪ خود.ایک مقررہ سائز K اور مندرجہ ذیل طریقوں کو نافذ کرتا ہے: __ init__: ایک مقررہ سائز K.IS_EMPTY کے ساتھ خالی سرکلر قطار کا آغاز کرتا ہے: اگر سرکلر قطار خالی ہے ، اور غلط ہے تو یہ سچ ہے۔غلط دوسری صورت میں۔.get_front: سرکلر قطار کے سامنے والے عنصر کو بغیر ہٹائے بغیر لوٹاتا ہے ، اور اگر سرکلر قطار خالی ہے تو کوئی بھی نہیں لوٹاتا ہے۔ اس کلاس کو استعمال کرنے کے ل you ، آپ سرکلر کیو کی مثال بناسکتے ہیں اور اس کے طریقوں کو مندرجہ ذیل طور پر کال کرسکتے ہیں: پائیتھونکق = سرکلر کیوئ (5)cq.enqueue (1) cq.enqueue (2) cq.enqueue (3) پرنٹ (cq.get_front ()) # آؤٹ پٹ: 1 یہ پروگرام سرکلر کیوئ کی ایک مثال 5 کے مقررہ سائز کے ساتھ تشکیل دیتا ہے ، سرکلر قطار میں تین عناصر کا اضافہ کرتا ہے۔enqueue طریقہ کا استعمال کرتے ہوئے ، اور get_front طریقہ کا استعمال کرتے ہوئے سرکلر قطار کے سامنے والے عنصر کو پرنٹ کرتا ہے۔آؤٹ پٹ سرکلر قطار کا پہلا عنصر ہے ، جو 1.1Studytonight2youtube3dremendo4pythoncentral5towardsDatacience ہے"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں غیر خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عددیوں کی ایک دی گئی فہرست میں غیر خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم کڈانے کا الگورتھم استعمال کرسکتے ہیں۔الگورتھم فہرست پر تکرار کرکے اور ہر انڈیکس پر ختم ہونے والے سبری کے زیادہ سے زیادہ رقم کو ٹریک کرتے ہوئے کام کرتا ہے۔ہر انڈیکس میں ، ہم یا تو ایک نیا سبری شروع کرسکتے ہیں یا پچھلے سبری کو بڑھا سکتے ہیں۔پچھلے سبری کو بڑھانے کے ل we ، ہم موجودہ عنصر کو پچھلے سبری کے مجموعہ میں شامل کرتے ہیں۔اگر پچھلے سبری کا مجموعہ منفی ہے تو ، ہم ایک نیا سبری شروع کرتے ہیں۔اس کے بعد ہم اب تک دکھائی دینے والی زیادہ سے زیادہ رقم کو اپ ڈیٹ کرسکتے ہیں اور اسے تکرار کے اختتام پر واپس کرسکتے ہیں۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (1) 123 کی جگہ کی پیچیدگی ہے۔ یہاں ازگر میں کڈانے کے الگورتھم کی مثال کے طور پر عمل درآمد: پائیتھنڈف میکس_سوبری_سم (LST): میکس_سو_فار = لسٹ [0] میکس_نینڈنگ_ہیر = ایل ایس ٹی [0]میں رینج (1 ، لین (LST)) کے لئے: زیادہ سے زیادہ_اینڈنگ_حیر = میکس (lst [i] ، میکس_نینڈنگ_ہیر + ایل ایس ٹی [i]) میکس_سو_فار = میکس (میکس_سو_فار ، میکس_نینڈنگ_ہیر) میکس_سو_فارٹیس پروگرام ایک فہرست میں میکس_سوبری_سم کی وضاحت کرتا ہے۔ان پٹ کے طور پر عدد کا اور فہرست میں غیر خالی سبری کی زیادہ سے زیادہ رقم واپس کرتا ہے۔یہ دو متغیرات میکس_سو_فار اور میکس_ننگ_ہیر کو فہرست کے پہلے عنصر میں شروع کرتا ہے ، اور دوسرے عنصر سے شروع ہونے والی فہرست میں تکرار کرتا ہے۔ہر عنصر کے ل it ، یہ MAX_INDEND_HERE کو موجودہ عنصر کی زیادہ سے زیادہ اور پچھلے سبری کے علاوہ موجودہ عنصر کی رقم کو اپ ڈیٹ کرتا ہے۔اگر پچھلے سبری کا مجموعہ منفی ہے تو ، یہ ایک نیا سبری شروع کرتا ہے۔اس کے بعد یہ MAX_SO_FAR کو زیادہ سے زیادہ MAX_SO_FAR اور MAX_ENDENT_HERE کی تازہ کاری کرتا ہے۔آخر میں ، یہ میکس_سو_فار لوٹتا ہے۔ اس فنکشن کا ایک مثال استعمال ہے: پائیتھونلسٹ = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، 1 ، -5 ، 4] پرنٹ (میکس_سوبری_سم (ایل ایس ٹی)) # آؤٹ پٹ: 6 اس میں 6پروگرام ایک فہرست LST تیار کرتا ہے ، میکس_سوبری_سم () کو فہرست کے ساتھ ان پٹ کے طور پر کال کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔آؤٹ پٹ فہرست میں غیر خالی سبری کا زیادہ سے زیادہ مجموعہ ہے ، جو 6.1geeksforgeeks2interviewivebit3techedlight ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دی گئی تعداد ایک بہترین نمبر ہے یا نہیں۔",
        "Answer": "ایک کامل نمبر ایک مثبت عدد ہے جو اس کے مناسب تفریقوں کے جوہر کے برابر ہے۔یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے نمبر ایک بہترین نمبر ہے ، ہم نمبر کے تمام تقسیم کاروں کو خود ہی تلاش کرسکتے ہیں اور یہ چیک کرسکتے ہیں کہ آیا تقسیم کاروں کا مجموعہ نمبر کے برابر ہے یا نہیں۔اگر یہ ہے تو ، نمبر ایک بہترین نمبر ہے۔بصورت دیگر ، یہ ایک کامل نمبر 1234 نہیں ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی مثال کے طور پر عمل درآمد ہے: پائیتھنڈف آئی ایس_پیرفیکٹ_نمبر (نمبر): تقسیم کار = [] میں I میں (1 ، نمبر) کے لئے: اگر NUM ٪ i == 0: تقسیم کار۔ضمیمہ (i) ریٹرن سم (تفریق) == Numthis پروگرام ایک فنکشن کی وضاحت کرتا ہے IS_PERFECT_NUMBER () جو ان پٹ کے طور پر ایک مثبت عدد لیتا ہے اور اگر نمبر ایک بہترین نمبر ہے ، اور دوسری صورت میں غلط ہے تو سچائی واپس آجاتا ہے۔یہ خالی فہرست تقسیم کرنے والوں کی ابتدا کرتا ہے اور 1 سے ان پٹ نمبر تک کی حد سے زیادہ تکرار کرتا ہے۔رینج میں ہر ایک نمبر کے ل it ، یہ چیک کرتا ہے کہ آیا یہ ان پٹ نمبر کا تقسیم کرنے والا ہے۔اگر یہ ہے تو ، یہ اسے تقسیم کرنے والوں کی فہرست میں شامل کرتا ہے۔آخر میں ، یہ سچ واپس آجاتا ہے اگر تقسیم کاروں کا مجموعہ ان پٹ نمبر کے برابر ہے ، اور دوسری صورت میں غلط ہے۔ اس فنکشن کا ایک مثال استعمال ہے: پائیتھونوم 1 = 6num2 = 28num3 = 496num4 = 8128num5 = 10 پرنٹ (is_perfect_number (num1)) # آؤٹ پٹ:سچ پرنٹ (is_perfect_number (num2)) # آؤٹ پٹ: ٹروپنٹ (is_perfect_number (num3)) # آؤٹ پٹ: ٹروپنٹ (is_perfect_number (num4)) # آؤٹ پٹ: ٹروپنٹ (is_perfect_number (num5)) # آؤٹ پٹ: فالستھیس پروگرام پانچ مثبت انٹیگرز نمبر 1 ، نمبر 1 ، نمبر 2 ،NUM3 ، NUM4 ، اور NUM5 ، IS_PERFECT_NUMBUR () کو ہر نمبر کے ساتھ ان پٹ کے طور پر کال کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔آؤٹ پٹ سچ ہے اگر نمبر ایک بہترین نمبر ہے ، اور دوسری صورت میں غلط ہے۔"
    },
    {
        "Question": "کسی دی گئی فہرست میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عدد کی دی گئی فہرست میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ نقطہ نظر ہیں: نزولی ترتیب میں فہرست کو ترتیب دیں اور کے ٹی ایچ عنصر کو واپس کریں۔چھانٹنے کے عمل کی وجہ سے اس نقطہ نظر میں O (n لاگ این) کی وقت کی پیچیدگی ہے۔مزید برآں ، بڑی تعداد میں انوکھے عناصر کے ساتھ فہرست کو چھانٹنا بہت زیادہ میموری کا استعمال کرسکتا ہے۔ازگر 1 میں اس نقطہ نظر کا ایک مثال عمل ہے: پیتھونڈف Kth_largest_el (LST ، K): Lst.Sort (rest = true) واپس LST [K-1] فہرست میں موجود کے سب سے بڑے عناصر کو ٹریک رکھنے کے لئے ایک زیادہ سے زیادہ ہیپ کا استعمال کریں۔اس نقطہ نظر میں O (n لاگ K) کی وقت کی پیچیدگی اور O (K) کی خلائی پیچیدگی ہے۔پائیتھون 2 میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونیمپورٹ ہیپ کیو ڈیف Kth_larget_el (LST ، K): ہیپ = LST [: K] ہیپ کیو ہائپائیفائ (ہیپ) I میں I (K ، LEN (LST)): اگر LST [I]> ہیپ [0]: ہیپ کیو.ہپپپ (ہیپ) ہیپ کیو ہپش (ہیپ ، ایل ایس ٹی [i]) ہیپ کی واپسی [0] کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے کوئیک سلیکٹ کا استعمال کریں۔کوئیک سلیکٹ کوئکسورٹ کی ایک تغیر ہے جو صرف ان عناصر کو تقسیم کرتی ہے جن کی KTH کے سب سے بڑے عنصر کو تلاش کرنے کے لئے درکار ہوتا ہے۔اس نقطہ نظر میں اوسط وقت کی پیچیدگی O (n) اور O (n^2) کی بدترین وقت کی پیچیدگی ہے۔ازگر 3 میں اس نقطہ نظر کا ایک مثال نفاذ: پائیتھونیمپورٹ رینڈم ڈیف پارٹیشن (ایل ایس ٹی ، بائیں ، دائیں): پیوٹ_ انڈیکس = بے ترتیب۔ رینڈینٹ (بائیں ، دائیں) پیوٹ = ایل ایس ٹی [پیوٹ_ انڈیکس] ایل ایس ٹی [پیوٹ_ انڈیکس] ، ایل ایس ٹی [دائیں] = ایل ایس ٹی [دائیں] = ایل ایس ٹی [دائیں [دائیں]] ، lst [pivot_index] اسٹور_ انڈیکس = رینج (بائیں ، دائیں) میں I کے لئے بائیں بائیں: اگر lst [i]> محور: lst [i] ، lst [store_index] = lst [store_index] ، lst [i] store_index += 1LST [دائیں] ، LST [اسٹور_ انڈیکس] = LST [اسٹور_ انڈیکس] ، LST [دائیں] واپس اسٹور_ انڈیکس ڈیف کوئیک سلیکٹ (LST ، بائیں ، دائیں ، K): اگر بائیں == دائیں: LST [بائیں] PIVOT_INDEX = پارٹیشن (LST ، بائیں.LST ، K): واپس کوئیک سلیکٹ (LST ، 0 ، LEN (LST) - 1 ، LEN (LST) - K) ان عددیوں کی دی گئی فہرست میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے یہ بہت سارے طریقوں میں سے کچھ ہیں۔نقطہ نظر کا انتخاب فہرست کے سائز ، K کی قدر ، اور مطلوبہ وقت اور جگہ کی پیچیدگی پر منحصر ہے۔"
    },
    {
        "Question": "ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور الفاظ کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو ٹری (پریفکس ٹری) کی نمائندگی کرتا ہے اور الفاظ داخل کرنے اور تلاش کرنے کے طریقوں: پائیتھنکلاس ٹرائنوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈرین = {} سیلف۔ آئی ایس_ڈی_ف_ ورڈ = فالسکلاس ٹرائی: ڈیف __init __ (خود).چار] نوڈ۔ is_end_of_word = سچے ڈیف سرچ (خود ، لفظ): نوڈ = سیلف۔ لفظ میں چار کے لئے۔ اگر چار نہیں نوڈ میں نہیں۔ٹری (پریفکس ٹری) ڈیٹا کا ڈھانچہ اور مندرجہ ذیل طریقوں کو نافذ کرتا ہے: __ init__: ایک روٹ نوڈ کے ساتھ ایک خالی ٹری کی ابتدا کرتا ہے۔ INSERT: ہر کردار کو لفظ میں تکرار کرکے اور ٹرائی میں ایک نیا نوڈ شامل کرکے ٹرائی میں ایک لفظ داخل کرتا ہے اگرکردار پہلے سے ہی ٹرائی میں نہیں ہے۔ تلاش: ہر ایک کردار کو لفظ میں تکرار کرکے اور اگر لفظ ٹرائی میں ہے اور غلط ہے تو سچ میں واپس آکر ٹری میں کسی لفظ کی تلاش کرتا ہے۔ اس کلاس کو استعمال کرنے کے ل you ، آپ ایک مثال تشکیل دے سکتے ہیں۔ٹری اور اس کے طریقوں کو مندرجہ ذیل طور پر کال کریں: پائیٹونٹری = ٹری () ٹری۔ انرٹ (\"ایپل\") ٹری.سرٹ (\"کیلے\") ٹرائی.سرٹ (\"اورنج\") پرنٹ (ٹری.سرچ (\"ایپل\")) # آؤٹ پٹ: ٹروپنٹ (ٹری۔ سرچ (\"ناشپاتیاں\")) # آؤٹ پٹ: فالسیتس پروگرام ٹری کی ایک مثال تیار کرتا ہے ، داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں تین الفاظ شامل کرتا ہے ، اور تلاش کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں دو الفاظ تلاش کرتا ہے۔آؤٹ پٹ سچ ہے اگر یہ لفظ ٹرائی میں ہے ، اور غلط ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین اور بریکٹ کے ساتھ ایک درست اظہار ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار متوازن قوسین اور بریکٹ کے ساتھ ایک درست اظہار ہے یا نہیں ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔خیال یہ ہے کہ تار کے اوپر تکرار کرنا اور ہر افتتاحی قوسین یا بریکٹ کو اسٹیک پر دھکیلنا ہے۔جب ہمیں کسی اختتامی قوسین یا بریکٹ کا سامنا کرنا پڑتا ہے تو ، ہم اسٹیک سے ٹاپ عنصر کو پاپ کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ اختتامی قوسین یا بریکٹ سے میل کھاتا ہے۔اگر ایسا ہوتا ہے تو ، ہم تکرار کے ساتھ جاری رکھیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم جانتے ہیں کہ اظہار درست نہیں ہے اور ہم غلط کو واپس کرسکتے ہیں۔تکرار کے اختتام پر ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین اور بریکٹ متوازن ہیں اور ہم سچ کو واپس کرسکتے ہیں۔بصورت دیگر ، اظہار درست نہیں ہے۔ہم ہر اختتامی قوسین یا بریکٹ کے لئے ہر اختتامی قوسین یا بریکٹ کو نقشہ بنانے کے لئے لغت کا استعمال کرکے مختلف قسم کے قوسین اور بریکٹ کو سنبھالنے کے لئے مذکورہ بالا نقطہ نظر میں ترمیم کرسکتے ہیں۔اس کے بعد ہم یہ چیک کرسکتے ہیں کہ آیا اسٹیک کا اوپری عنصر اختتامی قوسین یا بریکٹ کے لئے اسی طرح کے افتتاحی قوسین یا بریکٹ سے میل کھاتا ہے۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (n) 123 کی جگہ کی پیچیدگی ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی ایک مثال عمل ہے: پائیتھونڈف is_valid_expression (s): اسٹیک = [] میپنگ = {\")\":\"(\" ، \"}\": \"{\" ، \"]\": \"[\" c میں سی کے لئے: اگر سی میپنگ میں سی: اگر اسٹیک یا اسٹیک نہیں ہے تو [-1]! = میپنگ [سی]: غلط اسٹیک لوٹائیں۔پاپ () الیف سی میپنگ میں۔اور غلط دوسری صورت میں۔ یہ ایک اسٹیک اور ایک لغت کی نقشہ سازی کا آغاز کرتا ہے جو ہر اختتامی قوسین یا بریکٹ کو اس سے متعلقہ افتتاحی قوسین یا بریکٹ کے نقشوں کا نقشہ بناتا ہے۔ اس کے بعد یہ تار کے کردار کو کردار کے لحاظ سے عبور کرتا ہے۔ اگر کردار بند ہونے والی قوسین یا بریکٹ ہے تو ، یہ چیک کرتا ہے کہ اگر اس کی جانچ پڑتال کی جائے تو ، یہ چیک کرتا ہے۔اسٹیک کا سب سے اوپر عنصر اختتامی قوسین یا بریکٹ کے لئے اسی افتتاحی قوسین یا بریکٹ سے میل کھاتا ہے۔اگر ایسا ہوتا ہے تو ، اوپر عنصر اسٹیک سے پاپ ہوتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، اظہار درست نہیں ہے۔اگر کردار افتتاحی قوسین یا بریکٹ ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔آخر میں ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین اور بریکٹ متوازن ہیں اور پروگرام درست ہوجاتا ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ اس فنکشن کا ایک مثال استعمال ہے: ازگر 1 = \"(({} []))\" s2 = \"({[}])\" s3 = \"({[]})\" پرنٹ (is_valid_expression (is_valid_expression (is_valid_expressS1) # آؤٹ پٹ: ٹروپنٹ (is_valid_expression (S2)) # آؤٹ پٹ: غلط پرنٹ (is_valid_expression (S3)) # آؤٹ پٹ: Truethis پروگرام تین ڈور S1 ، S2 ، اور S3 تخلیق کرتا ہے ، IS_Valid_expression () کو ان پٹ کے طور پر ہر تار کے ساتھ کام کرتا ہے ،اور نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ سچ ہے اگر سٹرنگ متوازن قوسین اور بریکٹ کے ساتھ ایک درست اظہار ہے ، اور دوسری صورت میں غلط ہے۔"
    },
    {
        "Question": "دی گئی فہرست میں تین عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دی گئی فہرست میں تین عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل we ، ہم کچھ مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ ہیں: بروٹ فورس اپروچ: ان کی مصنوعات کی زیادہ سے زیادہ قیمت کو برقرار رکھتے ہوئے صف میں تمام ٹرپلٹس تلاش کرنے کی کوشش کریں۔اس نقطہ نظر میں O (n^3) کی وقت کی پیچیدگی ہے اور یہ بڑی فہرستوں کے لئے بہت موثر نہیں ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف میکس_ پروڈکٹ (ایل ایس ٹی): این = لین (ایل ایس ٹی) میکس_ پروڈکٹ = فلوٹ ('-انف') میں رینج (این) کے لئے: رینج میں جے کے لئے (i+1 ، n): رینج میں K کے لئے (J+1 ، N): پروڈکٹ = lst [i] * lst [j] * lst [k] میکس_ پروڈکٹ = زیادہ سے زیادہ (میکس_ پروڈکٹ ، پروڈکٹ) واپسی میکس_ پروڈکٹنگ چھانٹ رہا ہے: ان پٹ سرنی کو ترتیب دیں۔زیادہ سے زیادہ مصنوعات آخری تین عناصر یا آخری عنصر کے ساتھ شروع ہونے والے دو عناصر کی پیداوار ہوگی۔چھانٹنے کے عمل کی وجہ سے اس نقطہ نظر میں O (n لاگ این) کی وقت کی پیچیدگی ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پیتھونڈف میکس_ پروڈکٹ (ایل ایس ٹی): lst.sort () n = len (lst) واپسی میکس (Lst [0] * lst [1] * lst [n-1] ، lst [n-1]-3] * lst [n-2] * lst [n-1]) ایک ہی پاس کا استعمال کرتے ہوئے: ہم ایک ہی پاس میں زیادہ سے زیادہ ، دوسری زیادہ سے زیادہ اور تیسری زیادہ سے زیادہ عناصر تلاش کرسکتے ہیں اور ان کی مصنوعات کو واپس کرسکتے ہیں۔اس نقطہ نظر میں O (n) کی وقت کی پیچیدگی ہے اور یہ تینوں طریقوں میں سب سے زیادہ موثر ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف میکس_ پروڈکٹ (ایل ایس ٹی): میکس 1 = میکس 2 = میکس 3 = فلوٹ ('-انف') من 1 = من 2 = فلوٹ ('انف') ایل ایس ٹی میں نمبر کے لئے: اگر نمبر> زیادہ سے زیادہ: زیادہ سے زیادہ 3= میکس 2 میکس 2 = میکس 1 میکس 1 = نمبر ایلف نمبر> زیادہ سے زیادہ 2: میکس 3 = میکس 2 میکس 2 = نمبر ایلف نمبر> زیادہ سے زیادہ 3 = نمبر اگر نمبر <منٹ 1: منٹ 2 = منٹ 1 منٹ 1 = نمبر ایلف نمبر <منٹ 2: منٹ 2 = نمبر ریٹرن میکس (زیادہ سے زیادہ 1* میکس 2 * میکس 3 ، میکس 1 * منٹ 1 * منٹ 2) یہ ایک دی گئی فہرست میں تین عدد کی زیادہ سے زیادہ مصنوعات کی تلاش کے ل many بہت سے طریقوں میں سے کچھ ہیں۔نقطہ نظر کا انتخاب فہرست کے سائز اور مطلوبہ وقت کی پیچیدگی پر منحصر ہے۔"
    },
    {
        "Question": "الگ الگ انٹیجرز کی دی گئی فہرست کی ہر ممکنہ اجازت نامے تیار کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "الگ الگ عدد کی دی گئی فہرست کی ہر ممکنہ اجازت نامے تیار کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ نقطہ نظر ہیں: Itertools.permutations () کا استعمال کرتے ہوئے: ہم فہرست کے ہر ممکنہ اجازت نامے پیدا کرنے کے لئے ITertools ماڈیول سے بلٹ ان پرمٹیشن فنکشن استعمال کرسکتے ہیں۔یہ فنکشن ایک ایسے ایٹریٹر کو لوٹاتا ہے جو ان پٹ لسٹ کے ہر ممکنہ اجازت نامے پر مشتمل ٹوپل تیار کرتا ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونیمپورٹ Itertoolsdef جنریٹ_پرموٹیشنز (LST): ریٹرن لسٹ (Itertools.permutations (LST)) تکرار کا استعمال کرتے ہوئے: ہم کسی فہرست کی ہر ممکن ترتیب کو پیدا کرنے کے لئے ایک بار بار بار چلنے والی تقریب کا استعمال کرسکتے ہیں۔خیال یہ ہے کہ ہر عنصر کو فہرست میں ہر دوسرے عنصر کے ساتھ تبدیل کیا جائے اور باقی عناصر کی ہر ممکن اجازت نامہ تیار کریں۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف جنریٹ_پرموٹیشنز (ایل ایس ٹی): اگر لین (ایل ایس ٹی) == 0: واپسی [] اگر لین (ایل ایس ٹی) == 1: رینج [ایل ایس ٹی] نتیجہ = [] رینج میں (]لین (LST)): REST = LST [: I] + LST [I + 1:] جنریٹ_پرمیوٹیشن (REST) میں ترتیب کے لئے (REST): نتیجہ۔ اپینڈ ([LST [I]] + اجازت نامہ) کے نتیجے میں ڈھیر کا الگورتھم: ہیپ کا الگورتھم ہےایک غیر منافع بخش الگورتھم جو فہرست کے ہر ممکن اجازت پیدا کرتا ہے۔الگورتھم فہرست میں ہر دوسرے عنصر کے ساتھ ہر عنصر کو تبدیل کرکے اور بقیہ عناصر کی ہر ممکن اجازت نامہ تیار کرکے کام کرتا ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف جنریٹ_پرموٹیشنز (LST): n = len (lst) c = [0] * n نتیجہ = [lst] i = 0 جبکہ i <n: if c [i] <i:اگر i ٪ 2 == 0: lst [0] ، lst [i] = lst [i] ، lst [0] else: lst [c [i]] ، lst [i] = lst [i] ، lst [c[i]] نتیجہ۔ اپینڈ (lst [:]) c [i] += 1 i = 0 else: c [i] = 0 i += 1 واپسی اس کے نتیجے میں تمام ممکنہ اجازت نامے پیدا کرنے کے لئے بہت سارے نقطہ نظر میں سے کچھ ہیں۔الگ الگ عدد کی ایک دی گئی فہرست کی۔نقطہ نظر کا انتخاب فہرست کے سائز اور مطلوبہ وقت کی پیچیدگی پر منحصر ہے۔"
    },
    {
        "Question": "دو نمبروں کے جی سی ڈی (سب سے بڑے عام تقسیم کار) کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ازگر میں دو نمبروں کے جی سی ڈی (سب سے بڑے مشترکہ تقسیم کار) کا حساب لگانے کے لئے یہاں ایک فنکشن کا نفاذ ہے: پیتھنڈف جی سی ڈی (اے ، بی): اگر بی == 0: واپس ایک اور واپس کریں: جی سی ڈی (بی ، اے ٪ بی) اس پروگرام کو لوٹائیں۔ایک فنکشن جی سی ڈی () کی وضاحت کرتا ہے جو ان پٹ کے طور پر دو عدد لیتا ہے اور ان کی جی سی ڈی لوٹاتا ہے۔یہ جی سی ڈی کو بار بار تلاش کرنے کے لئے یوکلیڈین الگورتھم کا استعمال کرتا ہے۔الگورتھم بار بار بڑی تعداد کو چھوٹی تعداد میں تقسیم کرکے اور بقیہ وقت تک کام کرتا ہے جب تک کہ بقیہ صفر نہ ہو۔اس کے بعد جی سی ڈی آخری غیر صفر باقی ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا دوسرا نمبر صفر ہے۔اگر یہ ہے تو ، یہ GCD کے بطور پہلا نمبر واپس کرتا ہے۔بصورت دیگر ، یہ دوسرے نمبر کے ذریعہ تقسیم کردہ دوسرے نمبر اور بقیہ نمبر کے ساتھ بار بار خود کو فون کرتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پیتھونا = 24 بی = 36 پرنٹ (جی سی ڈی (اے ، بی)) # آؤٹ پٹ: 12 اس پروگرام کی تخلیق ہےدو عدد A اور B ، GCD () کو ان پٹ کے طور پر دو عدد کے ساتھ فنکشن کہتے ہیں ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ دو انٹیجرز کی جی سی ڈی ہے ، جو اس معاملے میں 12 ہے۔"
    },
    {
        "Question": "\"ایک ہیش سیٹ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور داخل کرنے ، ہٹانے اور جانچنے کے طریقوں کو نافذ کریں کہ آیا عنصر موجود ہے یا نہیں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو ہیش سیٹ کی نمائندگی کرتا ہے اور داخل کرنے ، ہٹانے اور چیک کرنے کے طریقوں کی نمائندگی کرتا ہے اگر کوئی عنصر موجود ہے تو: ازگرکلاس ہیشسیٹ: ڈیف __init __ (خود): سیلف۔ہش_سیٹ = سیٹ () ڈیف داخل کریں (خود ، قیمت).hash_set.add (value) Def ہٹائیں (خود ، قدر): self.hash_set.discard (ویلیو) ڈیف پر مشتمل ہوتا ہے (خود ، قدر): خود میں واپسی کی قیمت۔ ہاش_سیٹ یہ کلاس ایک ہیش سیٹ ڈیٹا ڈھانچے کی وضاحت کرتا ہے اور مندرجہ ذیل طریقوں کو نافذ کرتا ہے۔__init__: ایک خالی ہیش سیٹ شروع کرتا ہے۔ INSERT: بلٹ ان سیٹ کلاس کے ADD () طریقہ کا استعمال کرتے ہوئے ہیش سیٹ میں ایک قدر داخل کرتا ہے۔سیٹ کلاس میں شامل ہیں۔) پرنٹ (hash_set.contains (2)) # آؤٹ پٹ: truehash_set.remove (2) پرنٹ (ہیش_سیٹ.کونٹینز (2)) # آؤٹ پٹ: فالسیتیس پروگرام ہیشسیٹ کی ایک مثال تیار کرتا ہے ، داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ہیش سیٹ میں تین اقدار شامل کرتا ہے۔، چیک کرتا ہے کہ اگر کوئی قیمت ہیش سیٹ میں ہے تو اس پر مشتمل طریقہ کا استعمال کرتے ہوئے ، ہٹانے کے طریقہ کار کا استعمال کرتے ہوئے ہیش سیٹ سے ایک قدر ہٹاتا ہے ، اور چیک کرتا ہے کہ اگر قیمت ابھی بھی ہیش سیٹ میں موجود ہے جس میں موجود طریقہ کار کا استعمال کیا جاتا ہے۔اگر قیمت ہیش سیٹ میں ہے ، اور دوسری صورت میں غلط ہے۔"
    },
    {
        "Question": "\"اوپر بائیں کونے سے لے کر گرڈ کے نیچے دائیں کونے تک راستوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، صرف دائیں یا نیچے منتقل کریں۔\"",
        "Answer": "اوپر سے بائیں کونے سے لے کر کسی گرڈ کے نیچے دائیں کونے تک راستوں کی تعداد تلاش کرنے کے ل only ، صرف دائیں یا نیچے منتقل ہوتا ہے ، ہم امتزاج کو استعمال کرسکتے ہیں۔راستوں کی تعداد بائنومیئل گتانک کے برابر ہے (N کا انتخاب K) ، جہاں N اقدامات کی کل تعداد (قطار + کالم - 2) ہے اور K دائیں (یا نیچے) کے اقدامات کی تعداد ہے۔ہم کنگھی () فنکشن کا استعمال کرتے ہوئے بائنومیئل گتانک کا حساب لگانے کے لئے ازگر میں ریاضی کے ماڈیول کا استعمال کرسکتے ہیں۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونیم پورٹ میتھ ڈیف گنتی_پاتھس (قطاریں ، COLS): n = قطاریں + کالس - 2 K = COLS - 1 ریٹرن ریاضی ڈاٹ کام (N ، K) یہ پروگرام ایک فنکشن COUNT_PATHS () کی وضاحت کرتا ہے۔گرڈ میں قطار اور کالموں کی تعداد ان پٹ کے طور پر اور اوپر کے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک کے راستوں کی تعداد کو واپس کردیتی ہے ، جو صرف دائیں یا نیچے منتقل ہوتی ہے۔یہ سب سے پہلے قطاروں اور کالموں کے منفی 2 کی تعداد کے طور پر اقدامات کی کل تعداد کا حساب لگاتا ہے۔ اس کے بعد یہ دائیں K کے مراحل کی تعداد کا حساب لگاتا ہے جیسا کہ کالم مائنس کی تعداد 1. آخر میں ، یہ کنگھی () فنکشن کا استعمال کرتا ہے۔ریاضی کے ماڈیول سے بائنومیئل گتانک کا حساب لگانے کے لئے (n کا انتخاب کریں) اور نتیجہ لوٹاتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پائیٹونروز = 3 کولس = 3 پرنٹ (گنتی_پاتھ (قطاریں ، کولس)) # آؤٹ پٹ: 6 اس پروگرام سے دو عددی قطاریں پیدا ہوتی ہیں اورCOLS ، کاؤنٹ_پاتھ () کو ان پٹ کے طور پر دو عدد کے ساتھ فنکشن کہتے ہیں ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ اوپری بائیں کونے سے گرڈ کے نیچے دائیں کونے تک کے راستوں کی تعداد ہے ، جو صرف دائیں یا نیچے منتقل ہوتا ہے ، جو اس معاملے میں 6 ہے۔"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔خیال یہ ہے کہ تار کے اوپر تکرار کرنا اور ہر افتتاحی قوسین ، بریکٹ ، یا گھوبگھرالی تسمہ کو اسٹیک پر دھکیلنا ہے۔جب ہمیں کسی اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی تسمہ کا سامنا کرنا پڑتا ہے تو ، ہم اسٹیک سے اوپر والے عنصر کو پاپ کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی سے مماثل ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، ہم تکرار کے ساتھ جاری رکھیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم جانتے ہیں کہ اظہار درست نہیں ہے اور ہم غلط کو واپس کرسکتے ہیں۔تکرار کے اختتام پر ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی متوازن ہیں اور ہم سچ کو واپس کرسکتے ہیں۔ہم ہر اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی تسمہ کو اس کے اسی افتتاحی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط پر نقشہ بنانے کے لئے ایک لغت کا استعمال کرکے مختلف قسم کے قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کو سنبھالنے کے لئے مذکورہ بالا نقطہ نظر میں ترمیم کرسکتے ہیں۔اس کے بعد ہم چیک کرسکتے ہیں کہ آیا اسٹیک کا اوپری عنصر اختتامی قوسین ، بریکٹ ، یا اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی کے لئے گھوبگھرالی تسمہ سے مماثل ہے یا نہیں۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (n) 123456 کی خلائی پیچیدگی ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی مثال کے طور پر عمل درآمد: پائیتھونڈف is_valid_expression: اسٹیک = [] میپنگ = {\")\": \":\"(\" ، \"}\": \"{\" ، \"]\": \"[\" c میں سی کے لئے: اگر سی میپنگ میں سی: اگر اسٹیک یا اسٹیک نہیں ہے تو [-1]! = میپنگ [سی]: غلط اسٹیک لوٹائیں۔پاپ () الیف سی میپنگ میں۔اور گھوبگھرالی منحنی خطوط وحدانی۔کریکٹر ایک اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی ہے ، یہ چیک کرتا ہے کہ اگر اسٹیک کا اوپری عنصر اختتامی قوسین ، بریکٹ ، یا اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی کے لئے اسی طرح کے افتتاحی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط سے میل کھاتا ہے۔اگر ایسا ہوتا ہے تو ، اوپر عنصر اسٹیک سے پاپ ہوتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، اظہار درست نہیں ہے۔اگر کردار افتتاحی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔آخر میں ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی متوازن ہیں اور پروگرام درست ہوجاتا ہے۔بصورت دیگر ، یہ غلط کام کرتا ہے۔S1) # آؤٹ پٹ: ٹروپنٹ (is_valid_expression (S2)) # آؤٹ پٹ: غلط پرنٹ (is_valid_expression (S3)) # آؤٹ پٹ: Truethis پروگرام تین ڈور S1 ، S2 ، اور S3 تخلیق کرتا ہے ، IS_Valid_expression () کو ان پٹ کے طور پر ہر تار کے ساتھ کام کرتا ہے ،اور نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ سچ ہے اگر سٹرنگ متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، اور غلط ہے۔"
    },
    {
        "Question": "لکیری وقت میں نمبروں کی فہرست کا اوسط تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "لکیری وقت میں نمبروں کی فہرست کا میڈین تلاش کرنے کا ایک طریقہ یہ ہے کہ میڈین آف میڈین الگورتھم کا استعمال کیا جائے۔یہ الگورتھم فہرست کو پانچ عناصر کے گروپوں میں بار بار تقسیم کرکے کام کرتا ہے ، ہر گروہ کے وسط کو تلاش کرتا ہے ، اور پھر اس وقت تک بار بار میڈین کے میڈین کو تلاش کرتا ہے جب تک کہ ایک ہی عنصر نہ رہ جائے۔یہ عنصر فہرست کا درمیانی ہے۔الگورتھم لکیری وقت کی پیچیدگی کی ضمانت دیتا ہے ، لیکن اس کا ایک بہت بڑا مستقل عنصر ہوتا ہے اور چھوٹی فہرستوں کے لئے عملی نہیں ہوتا ہے۔1: لوٹ لوٹ [0] گروپس = [lst [i: i+5] میں I کے لئے رینج (0 ، LEN (LST) ، 5)] میڈین = [ترتیب شدہ (گروپ) [لین (گروپ) // 2] کے لئےگروپوں میں گروپ] محور = میڈین_ف_میڈینز (میڈینز) بائیں = [x لسٹ میں x کے لئے x <pivot] دائیں = [x کے لئے x کے لئے اگر x> pivot] k = len (بائیں) اگر k == لین (lst)// 2: ریٹرن پیوٹ ایلیف کے <لین (LST) // 2: واپسی median_of_medians (دائیں) دوسری: واپس median_of_medians (بائیں) یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے median_of_medians ()فہرست.یہ پہلے چیک کرتا ہے کہ آیا فہرست میں صرف ایک عنصر ہے اور وہ اس عنصر کو میڈین کی حیثیت سے لوٹاتا ہے۔بصورت دیگر ، یہ اس فہرست کو پانچ عناصر کے گروپوں میں تقسیم کرتا ہے ، ہر گروپ کا درمیانی حص find ہ ڈھونڈتا ہے ، اور جب تک ایک ہی عنصر نہیں رہ جاتا ہے تب تک میڈین کے میڈین کو بار بار مل جاتا ہے۔یہ عنصر محور ہے۔اس کے بعد یہ تقریب فہرست کو دو سببلسٹوں میں تقسیم کرتی ہے ، ایک ایسے عناصر کے ساتھ جو محور سے کم اور ایک محور سے زیادہ عناصر کے ساتھ ہے۔اس کے بعد یہ جانچ پڑتال کرتا ہے کہ آیا بائیں سبلسٹ کی لمبائی اصل فہرست کی نصف لمبائی کے برابر ہے۔اگر یہ ہے تو ، محور فہرست کا درمیانی ہے اور واپس آگیا ہے۔اگر ایسا نہیں ہے تو ، فنکشن بار بار اپنے آپ کو دائیں یا بائیں sublist کے ساتھ کال کرتا ہے اس پر منحصر ہے کہ آیا بائیں sublist کی لمبائی اصل فہرست کی لمبائی سے کم یا اس سے زیادہ ہے۔ فنکشن کی ایک مثال استعمال: ازگرلسٹ =[3 ، 1 ، 4 ، 2 ، 5] پرنٹ (میڈین_ف_میڈینز (ایل ایس ٹی)) # آؤٹ پٹ: 3 اس پروگرام میں ایل ایس ٹی کی تعداد کی ایک فہرست تیار کی گئی ہے ، ان کو ان پٹ کے طور پر فہرست کے ساتھ میڈین_ف_میڈینز () فنکشن کو کال کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔آؤٹ پٹ فہرست کا درمیانی ہے ، جو اس معاملے میں 3 ہے۔"
    },
    {
        "Question": "بائنری سرچ ٹری کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور نوڈ کو حذف کرنے اور کے ٹی ایچ ٹی کا سب سے چھوٹا عنصر تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو بائنری سرچ ٹری کی نمائندگی کرتا ہے اور نوڈ کو حذف کرنے اور کے ٹی ایچ کے سب سے چھوٹے عنصر کو تلاش کرنے کے طریقوں کی نمائندگی کرتا ہے: پائیٹونکلاس ٹرینوڈ: ڈیف __init __ (سیلف ، ویل): سیلف.وال = ویل سیلف۔نان کلاس بائنری سرچ ٹری: Def __init __ (خود): سیلف.روٹ = کوئی بھی نہیں ڈیف داخل کریں (خود ، ویل): اگر نہیں سیلف۔ روٹ: سیل.روٹ = ٹرینوڈ (ویل) اور: سیلف۔ ensert (ویل ، سیل. روٹ) Def _ insert..نوڈ نہیں: کوئی بھی نہیں لوٹیں اگر ویل <نوڈ.ول: نوڈ.لفٹ = سیلف۔node.left نہیں: واپسی نوڈ۔ رائٹ الیف نہیں نوڈ۔ رائٹ: ریٹرن نوڈ۔ لیفٹ اور: ٹیمپ = سیلف۔نوڈ۔ رائٹ) ریٹرن نوڈ ڈیف _find_min (خود ، نوڈ): جبکہ نوڈ۔ لیفٹ: نوڈ = نوڈ۔ لیفٹ ریٹرن نوڈ ڈیف Kth_smallest (سیلف ، کے): اسٹیک = [] نوڈ = سیلف۔: stac.append (نوڈ) نوڈ = نوڈ۔ لیفٹ نوڈ = اسٹیک.پپ () K -= 1 اگر k == 0: واپس نوڈ۔ وول نوڈ = نوڈ۔طریقے: __ init__: ایک جڑوں کے نوڈ کے ساتھ خالی بائنری سرچ درخت کی ابتدا کرتا ہے۔ INSERT: درخت کو بار بار گھومنے اور ایک نیا نوڈ شامل کرکے بائنری سرچ درخت میں ایک قیمت داخل کرتا ہے۔داخل کرنے کا طریقہ جو درخت کو بار بار عبور کرتا ہے اور ایک نیا نوڈ شامل کرتا ہے اگر قیمت پہلے سے ہی درخت میں نہیں ہے۔ ڈیلیٹ: بائنری سرچ ٹری سے ایک قیمت کو بار بار درخت کو عبور کرکے اور نوڈ کو دیئے گئے قدر کے ساتھ ہٹا کر حذف کرتا ہے ۔_ ڈیلیٹ: ہیلپرحذف کرنے والے طریقہ کار کے لئے کام جو درخت کو بار بار عبور کرتا ہے اور دیئے گئے قدر کے ساتھ نوڈ کو ہٹاتا ہے۔اسٹیک کے ساتھ تکراری ان آرڈر ٹریورسل کا استعمال کرکے درخت تلاش کریں۔ کلاس کا ایک مثال استعمال: پائیٹونبسٹ = بائنری سرچ ٹری () بی ایس ٹی. Insert (5) BST.Insert (3) BST.Insert (7) BST.INSERT (2) bst.insert (4) bst.insert (6) bst.insert (8) bst.delete (5) پرنٹ (bst.kth_smallest (3)) # آؤٹ پٹ: 4 یہ پروگرام بائنری سرچ ٹری کی ایک مثال تشکیل دیتا ہے ، اس میں سات اقدار کا اضافہ کرتا ہےدرخت داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ، حذف کرنے کے طریقہ کار کا استعمال کرتے ہوئے درخت سے ایک قدر کو حذف کردیتا ہے ، اور Kth_smallest طریقہ کا استعمال کرتے ہوئے درخت میں Kth سب سے چھوٹا عنصر تلاش کرتا ہے۔آؤٹ پٹ درخت کا سب سے چھوٹا عنصر ہے ، جو اس معاملے میں 4 ہے۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "عددیوں کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔خیال یہ ہے کہ ان پٹ لسٹ جیسی لمبائی کا ایک سرنی ڈی پی بنانا ہے ، جہاں ڈی پی [i] انڈیکس I پر ختم ہونے والے طویل ترین بڑھتے ہوئے متضاد کی لمبائی کی نمائندگی کرتا ہے۔ہم ڈی پی کو سبھی لوگوں کے لئے شروع کرسکتے ہیں ، کیونکہ کسی ایک عنصر کی سب سے طویل عرصہ تک بڑھتی ہوئی تعداد ہمیشہ ایک ہوتی ہے۔اس کے بعد ہم ان پٹ لسٹ پر تکرار کرسکتے ہیں اور ہر انڈیکس I کے ل we ، ہم پچھلے تمام انڈیکس جے سے کم کر سکتے ہیں اور یہ چیک کریں کہ انڈیکس I میں عنصر انڈیکس جے میں عنصر سے زیادہ ہے یا نہیں۔اگر یہ ہے تو ، ہم DP [i] کو زیادہ سے زیادہ DP [i] اور DP [j] + 1. کی تازہ کاری کرتے ہیں۔ہم ان پٹ لسٹ پر تکرار کرکے اور ہر عنصر کو اس کے بعد میں شامل کرکے ڈی پی سرنی کا استعمال بھی کرسکتے ہیں اگر اس کی ڈی پی ویلیو موجودہ زیادہ سے زیادہ ڈی پی ویلیو مائنس ون کے برابر ہے۔اس نقطہ نظر میں O (n^2) کی وقت کی پیچیدگی اور O (n) 12345 کی خلائی پیچیدگی ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی ایک مثال نافذ ہے: پائیٹھنڈف طویل ترین_انکریزنگ_سوبسینس (LST): n = len (lst) dp = [1] * N کے لئے I (1 ، n): J J میں حد (i): اگر lst [i]> lst [j]: dp [i] = زیادہ سے زیادہ (dp [i] ، dp [j] +1) میکس_ لمبائی = زیادہ سے زیادہ (ڈی پی) مشترکہ = [] I میں I کے لئے (N -1 ، -1 ، -1): اگر DP [i] == میکس_ لمبائی: متضاد.ایپینڈ (lst [i]) میکس_ لمبائی -= 1متضاد۔ ریورس () واپسی کے بعد کے بعد کے پروگرام میں ایک فنکشن کی وضاحت کی گئی ہے۔یہ سب سے پہلے اسی لمبائی کے ایک سرنی ڈی پی کو شروع کرتا ہے جس میں ان پٹ لسٹ تمام لوگوں کو ہوتا ہے۔اس کے بعد ان پٹ لسٹ پر تکرار کرتا ہے اور ہر انڈیکس I کے ل it ، یہ پچھلے تمام انڈیکس جے سے کم ہوتا ہے جس سے I سے کم ہوتا ہے اور ڈی پی [i] کو ڈی پی [i] اور ڈی پی [j] + 1 کی زیادہ سے زیادہ بننے کے ل. اگر انڈیکس میں عنصر ہوتا ہے۔میں انڈیکس جے کے عنصر سے بڑا ہے۔اس کے بعد ڈی پی میں زیادہ سے زیادہ قیمت مل جاتی ہے کیونکہ طویل عرصے تک بڑھتی ہوئی تعداد کی لمبائی اور ان پٹ لسٹ پر تکرار کرکے اور ہر عنصر کو بعد میں شامل کرنے کے لئے ڈی پی صف کا استعمال کرتا ہے اگر اس کی ڈی پی ویلیو موجودہ زیادہ سے زیادہ ڈی پی ویلیو کے برابر ہے۔مائنس ون۔آخر میں ، یہ کام کی ایک مثال کا استعمال ہے۔.آؤٹ پٹ فہرست کا سب سے طویل عرصہ تک بڑھتا ہوا حصہ ہے ، جو اس کیس میں 102233506080in ہے۔"
    },
    {
        "Question": "تکرار کا استعمال کرتے ہوئے دیئے گئے غیر منفی عدد کے حقیقت کا حساب لگانے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ازگر میں تکرار کا استعمال کرتے ہوئے دیئے گئے غیر منفی عدد کے حقیقت کا حساب لگانے کے لئے ، ہم ایک ایسے فنکشن کی وضاحت کرسکتے ہیں جو خود کو ایک چھوٹی ان پٹ کے ساتھ کال کرتا ہے جب تک کہ یہ بیس کیس تک نہ پہنچ جائے ، جو 1 کی حقیقت ہے ، جو 1 ہے۔ یہاں ایک مثال ہے۔اس نقطہ نظر کا نفاذ: پائیتھنڈف فیکٹوریئل (این): اگر n == 1: واپسی 1 اور: ریٹرن این * فیکٹوریئل (این -1) یہ پروگرام ایک فنکشن فیکٹوریل () کی وضاحت کرتا ہے جو غیر منفی عدد ان پٹ کے طور پر لیتا ہے اور واپسی کرتا ہے۔اس کا حقیقتیہ پہلے جانچ پڑتال کرتا ہے کہ آیا ن 1 کے برابر ہے ، جو بیس کیس ہے۔اگر یہ ہے تو ، یہ واپس آجاتا ہے۔ بصورت دیگر ، یہ بار بار ان پٹ N-1 کے ساتھ فون کرتا ہے اور اس کے نتیجے میں N.HERE کی ایک مثال کے استعمال کے استعمال کے ذریعہ اس کا نتیجہ بڑھتا ہے: پائیٹون = 5 پرنٹ (فیکٹوریئل (این)) # آؤٹ پٹ: 120 اس پروگرام کی تخلیق ہوتا ہے۔ایک انٹیجر این ، این کے ساتھ فیکٹوریئل () فنکشن کو ان پٹ کے طور پر کال کرتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ N کا حقیقت پسند ہے ، جو اس معاملے میں 120 ہے۔ نوٹ کریں کہ مذکورہ بالا عمل درآمد یہ فرض کرتا ہے کہ ان پٹ غیر منفی عدد ہے۔اگر ان پٹ منفی ہے تو ، فنکشن لامحدود طور پر دوبارہ پیدا ہوگا۔منفی آدانوں کو سنبھالنے کے ل we ، ہم غلطی کا پیغام واپس کرنے یا استثناء اٹھانے کے لئے فنکشن کے آغاز میں ایک چیک شامل کرسکتے ہیں۔"
    },
    {
        "Question": "\"2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں '1' زمین کی نمائندگی کرتا ہے اور '0' پانی کی نمائندگی کرتا ہے۔\"",
        "Answer": "2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ، جہاں '1' زمین کی نمائندگی کرتا ہے اور '0' پانی کی نمائندگی کرتا ہے ، ہم گہرائی سے پہلے تلاش (DFs) یا چوڑائی کی پہلی تلاش (BFS) استعمال کرسکتے ہیں۔خیال یہ ہے کہ گرڈ کو عبور کرنا ہے اور ہر ایک سیل کے لئے جس میں '1' ہوتا ہے ، ہم اسے ملاحظہ کی طرح نشان زد کرتے ہیں اور اس کے تمام پڑوسی خلیوں کو بار بار عبور کرتے ہیں جس میں '1' ہوتا ہے۔ہم جزیروں کی تعداد کے طور پر ایک نیا ڈی ایف ایس یا بی ایف ایس شروع کرنے کی تعداد کو گنتے ہیں۔ہم ملاحظہ کرنے والے خلیوں کو ٹریک رکھنے کے لئے بولین میٹرکس کا استعمال کرسکتے ہیں۔اس نقطہ نظر میں O (Mn) کی وقت کی پیچیدگی ہے ، جہاں ایم قطار کی تعداد ہے اور N کالموں کی تعداد ہے ، اور O (Mn) 12345 کی جگہ کی پیچیدگی ہے۔ یہاں ازگر میں DFs کا استعمال کرتے ہوئے مذکورہ بالا نقطہ نظر کی ایک مثال عمل ہے۔: پائیتھنڈف نمبر_س لینڈز (گرڈ): اگر گرڈ نہیں: واپس 0 میٹر ، این = لین (گرڈ) ، لین (گرڈ [0]) ملاحظہ کیا گیا = [[رینج میں _ کے لئے غلط (این)] _ کے لئے _ (ایم)]]رینج (م) کے لئے گنتی = 0 کے لئے: رینج (این) کے لئے: اگر گرڈ [i] [j] == '1' اور نہیں ملتا [i] [j]: ڈی ایف ایس (گرڈ ، ملاحظہ کیا گیا ، میں ، i ،j) گنتی += 1 ریٹرن کاؤنٹ ڈیف ڈی ایف ایس (گرڈ ، ملاحظہ کیا ، i ، j): اگر میں <0 یا i> = لین (گرڈ) یا j <0 یا j> = لین (گرڈ [0]) یا گرڈ [i] [j] == '0' یا دورہ [i] [j]: واپسی کا دورہ [i] [j] = سچے ڈی ایف ایس (گرڈ ، وزٹ ، I-1 ، J) ڈی ایف ایس (گرڈ ، ملاحظہ کیا گیا ، I+1 ،جے) ڈی ایف ایس (گرڈ ، وزٹ ، I ، J-1) DFS (گرڈ ، وزٹ ، I ، J+1) اس پروگرام میں ایک فنکشن NUM_ISLALD () کی وضاحت کی گئی ہے جو '1 اور' 0 کی 2D گرڈ کو ان پٹ کے طور پر لیتا ہے اور واپس کرتا ہے۔گرڈ میں جزیروں کی تعداد۔یہ پہلے چیک کرتا ہے کہ آیا گرڈ خالی ہے اور 0 لوٹتا ہے اگر یہ ہے۔اس کے بعد یہ ایک بولین میٹرکس کا آغاز کرتا ہے جس میں گرڈ کی طرح ہی سائز کا دورہ کیا جاتا ہے تاکہ وہ جزیروں کی تعداد پر نظر رکھنے کے لئے دورے والے خلیوں اور کاؤنٹر گنتی کو ٹریک رکھیں۔اس کے بعد یہ گرڈ پر اور ہر ایک سیل کے لئے تکرار کرتا ہے جس میں '1' ہوتا ہے اور اس کا دورہ نہیں کیا جاتا ہے ، یہ سیل اور اس کے تمام ہمسایہ خلیوں کو نشان زد کرنے کے لئے DFS () فنکشن کہتے ہیں جس میں '1' ہوتا ہے جیسا کہ '1' ہوتا ہے اور گنتی میں اضافہ ہوتا ہے۔ڈی ایف ایس () فنکشن ایک تکرار کرنے والا فنکشن ہے جو گرڈ ، ملاحظہ شدہ میٹرکس ، اور موجودہ سیل کے اشارے کو ان پٹ کے طور پر لیتا ہے اور ان تمام پڑوسی خلیوں کو بار بار عبور کرتا ہے جن میں '1' ہوتا ہے اور اس کا دورہ نہیں کیا جاتا ہے۔ یہاں کی ایک مثال استعمال ہےفنکشن: پائیٹونگگریڈ = [['1' ، '1' ، '0' ، '0' ، '0'] ، ['1' ، '1' ، '0' ، '0' ، '0'] ، ['0' ، '0' ، '1' ، '0' ، '0'] ، ['0' ، '0' ، '0' ، '1' ، '1']] پرنٹ (num_islands (گرڈ))# آؤٹ پٹ: 3 اس پروگرام میں 2D گرڈ گرڈ تشکیل دیتا ہے ، گرڈ کے ساتھ Num_island () کو ان پٹ کے طور پر کال کرتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ گرڈ میں جزیروں کی تعداد ہے ، جو اس معاملے میں 3 ہے۔"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی اور قیمت درج کرنے کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، اور قیمت درج کرنے کے ساتھ ایک درست اظہار ہے ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔خیال یہ ہے کہ تار کے اوپر تکرار کرنا اور ہر افتتاحی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اسٹیک پر حوالہ دینا ہے۔جب ہمیں اختتامی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اقتباس کا سامنا کرنا پڑتا ہے تو ، ہم اسٹیک سے اوپر والے عنصر کو پاپ کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ بند ہونے والی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط یا اقتباس سے مماثل ہے۔اگر ایسا ہوتا ہے تو ، ہم تکرار کے ساتھ جاری رکھیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم جانتے ہیں کہ اظہار درست نہیں ہے اور ہم غلط کو واپس کرسکتے ہیں۔تکرار کے اختتام پر ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، اور قیمتیں متوازن ہیں اور ہم سچ کو واپس کرسکتے ہیں۔ہم ہر اختتامی قوسین ، بریکٹ ، گھوبگھرے دار منحنی خطوط پر نقشہ بنانے کے لئے لغت کا استعمال کرکے مختلف قسم کے قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی اور قیمتوں کو سنبھالنے کے لئے مذکورہ بالا نقطہ نظر میں ترمیم کرسکتے ہیں۔اس کے بعد ہم چیک کرسکتے ہیں کہ آیا اسٹیک کا اوپری عنصر اسی افتتاحی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اختتامی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اقتباس سے مماثل ہے یا نہیں۔اس نقطہ نظر میں O (n) کی ایک وقت کی پیچیدگی اور O (n) 123456 کی خلائی پیچیدگی ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی مثال کے طور پر عمل درآمد: پائیتھونڈف is_valid_expression: اسٹیک = [] میپنگ = {\")\": \":\"(\" ، \"}\": \"{\" ، \"]\": \"[\" ، \"\" \":\" \"\" \"\" \"\": \"\" \"} سی میں سی کے لئے: اگر سی میپنگ میں سی: اگر اسٹیک نہیں ہے تو یااسٹیک [-1]! = میپنگ [c]: غلط اسٹیک۔ پاپ () میپنگ میں ایلف سی واپس کریں۔اور سچ واپس آجاتا ہے اگر سٹرنگ متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی اور قیمتوں کے ساتھ ایک درست اظہار ہے۔افتتاحی قوسین ، بریکٹ ، گھوبگھرالی برنس ، یا اقتباس۔ اس کے بعد یہ تار کے کردار کو کردار کے ذریعہ عبور کرتا ہے۔ اگر کردار ایک اختتامی قوسین ، بریکٹ ، گھوبگھرالی تسمہ ، یا اقتباس ہے تو ، یہ چیک کرتا ہے کہ اگر اسٹیک کا اوپری عنصر اسی طرح کے افتتاحی والدین سے میل کھاتا ہے۔، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اختتامی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اقتباس کے لئے اقتباس۔اگر ایسا ہوتا ہے تو ، اوپر عنصر اسٹیک سے پاپ ہوتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، اظہار درست نہیں ہے۔اگر کردار افتتاحی قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، یا اقتباس ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔آخر میں ، اگر اسٹیک خالی ہے تو ، اس کا مطلب یہ ہے کہ تمام قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، اور قیمتیں متوازن ہیں اور یہ پروگرام درست ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ فنکشن کا ایک مثال استعمال ہے: ازگر 1 = \"{[()]} {}\" s2 = \"{[(])}\" S3 = \"{[() ']}\" پرنٹ (is_valid_expression.، اور نتیجہ پرنٹ کرتا ہے.آؤٹ پٹ سچ ہے اگر سٹرنگ متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، اور قیمتوں کے ساتھ ایک درست اظہار ہے۔"
    },
    {
        "Question": "ایک اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور مستقل وقت میں کم سے کم عنصر کی تلاش کے ل methods طریقوں کو نافذ کریں اور لوگرتھمک وقت میں زیادہ سے زیادہ عنصر کو بازیافت کریں۔",
        "Answer": "ازگر میں اسٹیک کلاس کو نافذ کرنے کے لئے جو کم سے کم عنصر کو مستقل وقت میں تلاش کرسکتا ہے اور لوگرتھمک وقت میں زیادہ سے زیادہ عنصر کو بازیافت کرسکتا ہے ، ہم دو معاون اسٹیکس استعمال کرسکتے ہیں۔ایک اسٹیک اب تک نظر آنے والے کم سے کم عناصر کا سراغ لگائے گا ، اور دوسرا اسٹیک اب تک دکھائے جانے والے زیادہ سے زیادہ عناصر پر نظر رکھے گا۔اس کے بعد ہم پش () ، پاپ () ، جھانکنے () ، get_min () ، اور get_max () طریقوں کو مندرجہ ذیل کے طور پر نافذ کرسکتے ہیں: پش (): اسٹیک پر کسی عنصر کو دھکیل دیتا ہے اور اگر ضروری ہو تو کم سے کم اور زیادہ سے زیادہ اسٹیک کو اپ ڈیٹ کرتا ہے۔(): اسٹیک سے اوپر کا عنصر پاپ کرتا ہے اور اگر ضروری ہو تو کم سے کم اور زیادہ سے زیادہ اسٹیکس کو اپ ڈیٹ کرتا ہے۔کم سے کم اسٹیک کے اوپری عنصر کو واپس کرناخود): self.stack = [] self.min_stack = [] self.max_stack = [] Def Push (self ، val): self.stack.append (val) اگر نہیں ہے تو۔-1]: self.min_stack.append (ویل) اگر نہیں اگر سیلف۔ میکس_ اسٹیک یا ویل> = سیلف۔ میکس_ اسٹیک [-1]: سیلف۔ میکس_ اسٹیک۔ اے پی پیینڈ (ویل) ڈیف پاپ (خود)کوئی بھی نہیں ہےDef peek (self): اگر خود نہیں۔ اسٹیک: کوئی بھی واپس نہیں کریں گے۔ اسٹیک [-1] Def get_min (self): اگر خود نہیں ہے۔ min_stack: کوئی بھی واپس نہیں لوٹ کر خود واپس کریں۔اگر سیلف نہیں ہے۔ میکس_ اسٹیک: کوئی بھی واپس نہیں لوٹ کر۔ max_stack [-1] یہ پروگرام ایک کلاس اسٹیک کی وضاحت کرتا ہے جو مستقل وقت میں کم سے کم عنصر کو تلاش کرنے اور لوگرتھمک وقت میں زیادہ سے زیادہ عنصر کو بازیافت کرنے کے طریقوں کے ساتھ اسٹیک ڈیٹا ڈھانچے کو نافذ کرتا ہے۔یہ تین اسٹیکس کی ابتدا کرتا ہے: عناصر کو تھامنے کے لئے اسٹیک ، اب تک نظر آنے والے کم سے کم عناصر کو تھامنے کے لئے MIN_STACK ، اور اب تک نظر آنے والے زیادہ سے زیادہ عناصر کو روکنے کے لئے میکس_ اسٹیک۔اس کے بعد یہ پش () ، پاپ () ، جھانکنے () ، get_min () ، اور get_max () طریقوں کو نافذ کرتا ہے۔پش (2) ایس پش (5) ایس پش (1) پرنٹ (S.Get_min ()) # آؤٹ پٹ: 1 پرنٹ (S.Get_max ()) # آؤٹ پٹ: 5.pop () پرنٹ (s.get_min ()) # آؤٹ پٹ: 2 پرنٹ (s.get_max ()) # آؤٹ پٹ: 5 یہ پروگرام اسٹیک کی ایک مثال تیار کرتا ہے ، پش () کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک میں چار اقدار شامل کرتا ہے ، get_min () کا استعمال کرتے ہوئے اسٹیک میں کم سے کم اور زیادہ سے زیادہ عناصر کو بازیافت کرتا ہے۔اور get_max () طریقوں ، پاپ () کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک سے اوپر عنصر کو ہٹا دیتا ہے ، اور اسٹیک میں کم سے کم اور زیادہ سے زیادہ عناصر کو دوبارہ بازیافت کرتا ہے۔آؤٹ پٹ ہر مرحلے میں اسٹیک میں کم سے کم اور زیادہ سے زیادہ عنصر ہے۔"
    },
    {
        "Question": "مختلف سائز کی دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "مختلف سائز کے دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے ل several ، بہت سارے نقطہ نظر ہیں۔ایک آسان نقطہ نظر یہ ہے کہ دونوں ترتیب شدہ صفوں کو ایک ہی ترتیب شدہ صف میں ضم کریں اور پھر انضمام شدہ صف کا میڈین تلاش کریں۔اگر ضم شدہ صف میں عناصر کی کل تعداد عجیب ہے تو ، میڈین درمیانی عنصر ہے۔اگر عناصر کی کل تعداد بھی ہے تو ، میڈین دو درمیانی عناصر کی اوسط ہے۔اس نقطہ نظر میں O (M+N) کی وقت کی پیچیدگی ہے ، جہاں M اور N دو ان پٹ صفوں کے سائز ہیں ، اور O (M+N) کی خلائی پیچیدگی 123. یہاں ازگر میں مذکورہ بالا نقطہ نظر کا ایک مثال عمل ہے۔.j]: ضم شدہ۔ اپینڈ (arr1 [i]) i += 1 اور: ضم شدہ۔ اپینڈ (arr2 [j]) j += 1 جبکہ میں <m: ضم شدہ۔ append (arr1 [i]) i += 1 جبکہj <n: ضم شدہ۔ اپینڈ (arr2 [j]) j + = 1 ٹوٹل = m + n اگر کل ٪ 2 == 0: وسط = کل // 2 واپسی (ضم شدہ [وسط -1] + ضم شدہ [وسط])/ 2 اور: مڈ = کل // 2 ریٹرن ضم شدہ [وسط] یہ پروگرام ایک فنکشن Find_median () کی وضاحت کرتا ہے جو دو ترتیب شدہ صفوں ARR1 اور ARR2 کو ان پٹ کے طور پر لیتا ہے اور دونوں صفوں کے میڈین کو واپس کرتا ہے۔یہ سب سے پہلے ایک خالی فہرست کا آغاز کرتا ہے جس میں ضم شدہ سرنی اور دو انڈیکس I اور J کو تھامنے کے لئے بالترتیب ARR1 اور ARR2 میں موجودہ پوزیشنوں پر نظر رکھنے کے ل. مل جاتا ہے۔اس کے بعد یہ دونوں صفوں پر تکرار کرتا ہے اور چھوٹے عنصر کو ضم شدہ فہرست میں شامل کرتا ہے جب تک کہ ایک صف ختم نہ ہوجائے۔اس کے بعد یہ غیر منقولہ سرنی کے باقی عناصر کو ضم شدہ فہرست میں شامل کرتا ہے۔آخر میں ، یہ ضم شدہ صف میں عناصر کی کل تعداد کا حساب لگاتا ہے اور درمیانی عنصر کے طور پر میڈین کو لوٹاتا ہے اگر عناصر کی کل تعداد عجیب ہے ، یا دو درمیانی عناصر کی اوسط اگر عناصر کی کل تعداد بھی ہے تو۔ یہاں ایک مثال ہے۔فنکشن کا استعمال: پائیتھونر 1 = [1 ، 3 ، 4 ، 6 ، 9] arr2 = [2 ، 5 ، 7 ، 8 ، 10] پرنٹ (Find_median (arr1 ، arr2)) # آؤٹ پٹ: 5.5 اس پروگرام سے دو ترتیب شدہ صفیں تخلیق ہوتی ہیں۔ARR1 اور ARR2 ، ان پٹ کے طور پر صفوں کے ساتھ Find_median () فنکشن کو کال کرتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ ان دو صفوں کا درمیانی ہے ، جو اس معاملے میں 5.5 ہے۔ مختلف سائز کے دو ترتیب دیئے ہوئے صفوں کی اوسط تلاش کرنے کے لئے ایک اور نقطہ نظر بائنری تلاش کا استعمال کرنا ہے۔اس نقطہ نظر میں O (لاگ (منٹ (M ، M ، N))) کی وقت کی پیچیدگی ہے ، جہاں M اور N دو ان پٹ صفوں کے سائز ہیں ، اور O (1) 45 کی خلائی پیچیدگی ہے۔تاہم ، یہ نقطہ نظر زیادہ پیچیدہ ہے اور اس کے لئے کنارے کے معاملات کو محتاط طریقے سے سنبھالنے کی ضرورت ہے۔"
    },
    {
        "Question": "کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر ایک نرگسسٹک نمبر ہے۔",
        "Answer": "ایک منشیات کی تعداد ایک ایسی تعداد ہے جو نمبر میں ہندسوں کی تعداد کی طاقت کے لئے اٹھائے اپنے ہندسوں کی رقم کے برابر ہے۔مثال کے طور پر ، 153 ایک نرگسسٹک نمبر ہے کیونکہ 1^3 + 5^3 + 3^3 = 153. کسی فنکشن کو نافذ کرنے کے لئے یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد ایک نارکی نمبر ہے ، ہم اس نمبر کو تار میں تبدیل کرسکتے ہیں اور اس کے اوپر تکرار کرسکتے ہیں۔ہندسوں میں ہندسوں کی تعداد کی طاقت کے لئے اٹھائے گئے ہر ہندسے کا خلاصہ۔اس کے بعد ہم اس رقم کا موازنہ اصل نمبر سے کر سکتے ہیں تاکہ یہ معلوم کیا جاسکے کہ آیا یہ ایک نرگسسٹک نمبر ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف is_narcissistic_number (num): ہندسے = str (num) n = لین (ہندسے) کل = رقم (int (ہندسہ) ** n ہندسوں میں ہندسے کے لئے) واپس کل == Numthis پروگرامایک فنکشن کی وضاحت کرتا ہے is_narcissistic_number () جو ایک نمبر کو ان پٹ کے طور پر لیتا ہے اور اگر نمبر ایک نارکیوں کی تعداد ہے ، اور دوسری صورت میں غلط ہے۔یہ پہلے نمبر کو تار میں تبدیل کرتا ہے اور ہندسوں کی تعداد کا حساب لگاتا ہے۔اس کے بعد یہ تار کے ہندسوں پر تکرار کرتا ہے ، ہر ہندسے کو ایک عدد میں تبدیل کرتا ہے ، اسے N کی طاقت میں اٹھاتا ہے ، اور نتائج کا خلاصہ کرتا ہے۔آخر میں ، اس کا موازنہ اصل نمبر سے ہوتا ہے اور اگر وہ برابر ہیں اور غلط ہیں۔سچ پرنٹ (is_narcissistic_number (num2)) # آؤٹ پٹ: سچ پرنٹ (is_narcissistic_number (num3)) # آؤٹ پٹ: ٹروپنٹ (is_narcissistic_number (num4)) # آؤٹ پٹ: ٹروپنٹ (is_narcissistic_number (num5)) # آؤٹ پٹ: فالستھیس پروگرام تخلیق کرتا ہے: falsethis پروگرام تخلیق کرتا ہے: فالستھیس پروگرام تخلیق کرتا ہے ، فالستھیس پروگرام تخلیق کرتا ہے۔، NUM4 ، اور NUM5 ، ہر نمبر کے ساتھ IS_NARCISSISTIST_NUMBER () کو ان پٹ کے طور پر کال کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔آؤٹ پٹ سچ ہے اگر نمبر ایک نرگسسٹک نمبر ہے ، اور غلط ہے۔"
    },
    {
        "Question": "\"ایک پروگرام لکھیں تاکہ اوپر کے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک کے راستوں کی تعداد تلاش کی جاسکے ، صرف دائیں ، نیچے یا اخترن میں منتقل ہو۔\"",
        "Answer": "اوپر سے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک راستوں کی تعداد تلاش کرنے کے لئے ، صرف دائیں ، نیچے ، یا اخترن کے ساتھ ، بہت سے نقطہ نظر موجود ہیں۔ایک آسان نقطہ نظر متحرک پروگرامنگ کا استعمال کرنا ہے۔ہم گرڈ کی طرح ایک ہی سائز کا 2D سرنی ڈی پی تشکیل دے سکتے ہیں ، جہاں ڈی پی [i] [j] قطار I اور کالم جے کے اوپر والے بائیں کونے سے سیل تک کے راستوں کی تعداد کی نمائندگی کرتا ہے۔ہم ڈی پی کو 1 سے 1 تک شروع کرسکتے ہیں ، کیونکہ اوپر کے بائیں کونے تک پہنچنے کے لئے صرف ایک ہی راستہ ہے۔اس کے بعد ہم گرڈ پر تکرار کرسکتے ہیں اور ہر ایک سیل کے لئے جو پہلی صف یا پہلے کالم پر نہیں ہے ، ہم ڈی پی [i] [j] کو ڈی پی [I-1] [j] ، ڈی پی [i] کے لئے اپ ڈیٹ کرتے ہیں۔[J-1] ، اور ڈی پی [I-1] [J-1] ، چونکہ ہم مذکورہ سیل سے سیل ، بائیں طرف سیل ، یا اوپر کے اوپر اور بائیں طرف سیل تک پہنچ سکتے ہیں۔آخر میں ، ہم DP [M-1] [N-1] کو واپس کرتے ہیں ، جہاں M اور N گرڈ میں قطار اور کالموں کی تعداد ہیں ، جیسا کہ نیچے دائیں کونے تک اوپر والے کونے سے اوپر کے کونے تک کے راستوں کی تعداد ہے۔اس نقطہ نظر میں O (Mn) کی ایک وقت کی پیچیدگی اور O (Mn) 123 کی خلائی پیچیدگی ہے۔ یہاں ازگر میں مذکورہ بالا نقطہ نظر کی مثال کے طور پر عمل درآمد: Pythondef Count_paths (Grid): M ، n = len (grid) ، لین (لین (گرڈ [0]) dp = [[_ کے لئے _ _ رینج (n)] کے لئے _ کے لئے (م)] ڈی پی [0] [0] = 1 میں رینج میں (ایم) کے لئے: رینج میں جے کے لئے (این): اگر i> 0 اور j> 0: dp [i] [j] = dp [i-1] [j] + dp [i] [j-1] + dp [i-1] [j-1] الیفi> 0: dp [i] [j] = dp [i-1] [j] elif j> 0: dp [i] [j] = dp [i] [j-1] واپسی dp [M-1][N-1] یہ پروگرام ایک فنکشن COUNT_PATHS () کی وضاحت کرتا ہے جو ایک گرڈ کو ان پٹ کے طور پر لیتا ہے اور اوپر سے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک راستوں کی تعداد واپس کرتا ہے۔یہ سب سے پہلے اسی سائز کے 2D سرنی ڈی پی کو شروع کرتا ہے جیسے گرڈ ہر سیل کے راستوں کی تعداد کا پتہ لگانے کے لئے۔اس کے بعد یہ ڈی پی کو 1 سے شروع کرتا ہے ، کیونکہ اوپر کے بائیں کونے تک پہنچنے کے لئے صرف ایک ہی راستہ ہے۔اس کے بعد گرڈ پر اور ہر سیل کے لئے جو پہلی صف یا پہلے کالم پر نہیں ہے ، اس کے لئے ڈی پی [i] [j] کو ڈی پی [i-1] [j] ، ڈی پی [i] [i] [کی تازہ کاری کرتا ہے۔J-1] ، اور ڈی پی [I-1] [J-1]۔آخر میں ، یہ DP [M-1] [N-1] کو اوپر سے بائیں کونے سے نیچے دائیں کونے تک جانے والے راستوں کی تعداد کے طور پر واپس کرتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پائیتھونگریڈ = [[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]] پرنٹ (گنتی_پاتھ (گرڈ)) # آؤٹ پٹ: 6 یہ پروگرام 2D گرڈ گرڈ بناتا ہے ، ان پٹ کے طور پر گرڈ کے ساتھ گنتی_پاتھ () کو کال کرتا ہے ، اور پرنٹسنتیجہ.آؤٹ پٹ اوپری بائیں کونے سے گرڈ کے نیچے دائیں کونے تک کے راستوں کی تعداد ہے ، جو اس معاملے میں 6 ہے۔"
    },
    {
        "Question": "ایک ازگر کلاس بنائیں جس میں سرکلر دوگنا منسلک فہرست کی نمائندگی کی جائے اور کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "ایک سرکلر دوگنا منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس بنانے کے ل and اور کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرنے کے ل we ، ہم فہرست میں ہر نوڈ کی نمائندگی کرنے کے لئے کلاس نوڈ کی وضاحت کرسکتے ہیں ، اور اس فہرست کی نمائندگی کرنے کے لئے ایک کلاس سرکلرڈیول لنکڈ لسٹ۔نوڈ کلاس میں تین صفات ہونی چاہئیں: نوڈ کے ڈیٹا کو ذخیرہ کرنے کے لئے اعداد و شمار ، پچھلے نوڈ کا حوالہ دینے کے لئے ، اور اگلے نوڈ کا حوالہ اسٹور کرنے کے بعد۔سرکولارڈبل لنک لسٹ کلاس میں دو صفات ہونی چاہئیں: فہرست میں نوڈس کی تعداد کو ذخیرہ کرنے کے لئے فہرست کے ہیڈ نوڈ کا حوالہ دینے کے لئے سربراہ بنائیں۔کلاس کو شروع ، اختتام ، یا فہرست کے ایک دیئے گئے مقام پر نوڈ داخل کرنے ، اور فہرست کی ایک مخصوص پوزیشن پر نوڈ کو حذف کرنے کے طریقوں کو بھی نافذ کرنا چاہئے۔کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے ل we ، ہم پہلے چیک کرسکتے ہیں کہ آیا فہرست خالی ہے یا اگر پوزیشن حد سے باہر ہے۔اگر یہ نہیں ہے تو ، ہم دیئے گئے پوزیشن پر نوڈ پر فہرست کو عبور کرسکتے ہیں ، نوڈ کو حذف کرنے کے لئے نوڈ کو چھوڑنے کے لئے ملحقہ نوڈس کے سابقہ اور اگلے پوائنٹرز کو اپ ڈیٹ کرسکتے ہیں ، اور فہرست کے سائز کو کم کرسکتے ہیں۔ازگر میں اس نقطہ نظر کا ایک مثال نفاذ: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹا = ڈیٹا خود۔.size = 0 def insert_beginning (خود ، ڈیٹا): نوڈ = نوڈ (ڈیٹا) اگر خود نہیں ہے۔ خود نہیں۔node.next = self.head self.head.prev.next = نوڈ سیلف۔self.head: self.head = node node.prev = نوڈ نوڈ. نیکسٹ = نوڈ اور: node.prev = self.head.prev node.next = self.head self.head.prev.next = نوڈ سیل. ہیڈ۔prev = نوڈ سیلف۔: self.insert_end (ڈیٹا) دوسری: نوڈ = نوڈ (ڈیٹا) کرر = سیلف۔ خود کے لئے۔= نوڈ curr.prev = نوڈ سیلف۔ سائز += 1 ڈیف ڈیلیٹ_ٹ_پوزیشن (خود ، پوزیشن): اگر خود نہیں ہے۔ ہیڈ یا پوزیشن <0 یا پوزیشن> = خود۔= کوئی اور نہیں: curr = self.head کے لئے I (پوزیشن) میں: curr = curr.next curr.prev.next = curr.next curr.next.prev = curr.prev اگر پوزیشن == 0: سیلف۔ ہیڈ =curr.next self.size -= 1 یہ پروگرام فہرست میں ہر نوڈ کی نمائندگی کرنے کے لئے ایک کلاس نوڈ کی وضاحت کرتا ہے ، اور اس فہرست کی نمائندگی کرنے کے لئے ایک کلاس سرکلرڈبل لنکڈ لسٹ ہے۔یہ سر کی وصف کو کسی کو بھی نہیں اور سائز کی وصف 0 کا آغاز کرتا ہے۔ اس کے بعد شروع ، اختتام ، یا فہرست کے ایک دیئے گئے مقام پر نوڈ داخل کرنے کے طریقوں کی وضاحت کرتا ہے ، اور فہرست کی دی گئی پوزیشن پر نوڈ کو حذف کرنے کے لئے۔INSERT_BEGINNING () طریقہ فہرست کے آغاز میں ایک نیا نوڈ تشکیل دے کر ، بالترتیب آخری نوڈ اور ہیڈ نوڈ کی طرف اشارہ کرنے کے لئے ایک نیا نوڈ تیار کرکے ، اور آخری نوڈ کے سابقہ اور اگلے پوائنٹرز کو اپ ڈیٹ کرنے کے ذریعہ فہرست کے آغاز میں ایک نوڈ داخل کرتا ہے۔اور نئے نوڈ کی طرف اشارہ کرنے کے لئے ہیڈ نوڈ۔INSERT_END () کا طریقہ فہرست کے آخر میں اسی طرح داخل کرتا ہے جس طرح داخل_بیگیننگ () طریقہ ہے۔INSERT_AT_POSISON () کا طریقہ دی گئی پوزیشن پر نوڈ پر فہرست کو عبور کرکے ، فہرست کی ایک دی گئی پوزیشن پر نوڈ داخل کرتا ہے ، ایک نیا نوڈ بناتا ہے ، بالترتیب پچھلے نوڈ اور موجودہ نوڈ کی طرف اشارہ کرنے کے لئے اس کے سابقہ اور اگلے پوائنٹرز کو اپ ڈیٹ کرتا ہے۔، اور نئے نوڈ کی طرف اشارہ کرنے کے لئے پچھلے نوڈ اور موجودہ نوڈ کے سابقہ اور اگلے پوائنٹرز کو اپ ڈیٹ کرنا۔ڈیلیٹ_ٹ_پوزیشن () کا طریقہ فہرست کی ایک دی گئی پوزیشن پر دیئے گئے پوزیشن پر نوڈ پر لسٹ کا سفر کرکے ، نوڈ کو حذف کرتا ہے ، اس سے ملحقہ نوڈس کے Prep اور اگلے پوائنٹرز کو اسکیپ کرنے کے لئے اپ ڈیٹ کرتے ہیں۔"
    },
    {
        "Question": "کوئکسورٹ الگورتھم کا استعمال کرتے ہوئے عددیوں کی فہرست کو ترتیب دینے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "کوئکسورٹ ایک موثر ، عمومی مقصد کے چھانٹنے والا الگورتھم ہے جو ایک صف کو دو ذیلی اراکین میں تقسیم کرکے کام کرتا ہے ، اس کے مطابق کہ وہ محور عنصر سے کم یا اس سے زیادہ ہیں ، اور پھر اس کے بعد ذیلی ایریا کو بار بار ترتیب دیتے ہیں۔محور عنصر کو مختلف طریقوں سے منتخب کیا جاسکتا ہے ، جیسے صف کا پہلا ، آخری ، یا درمیانی عنصر ، یا بے ترتیب عنصر۔کوئکسورٹ میں O (n*لاگ این) کی اوسط اور بہترین وقت کی وقت کی پیچیدگی ، اور O (n^2) کی بدترین وقت کی پیچیدگی ہے ، حالانکہ اس سے اچھے محور عنصر کا انتخاب کرکے یا بے ترتیب کوئکسٹورٹ کا استعمال کرکے اس سے بچا جاسکتا ہے۔کوئکسورٹ اس کی سادگی اور کارکردگی کی وجہ سے ایک مقبول چھانٹ رہا الگورتھم ہے ، اور اکثر دوسرے چھانٹنے والے الگورتھم کے لئے بینچ مارک کے طور پر استعمال کیا جاتا ہے۔ان پٹ کے طور پر ایک فہرست ARR لیتا ہے ، ایک محور عنصر کا انتخاب کرتا ہے ، فہرست کو دو ذیلی فہرستوں میں تقسیم کرتا ہے ، اور ذیلی فہرستوں کو بار بار ترتیب دیتا ہے۔تکرار کا بنیادی معاملہ اس وقت ہوتا ہے جب فہرست میں صفر ہوتا ہے یا ایک عناصر ہوتے ہیں ، اس معاملے میں یہ پہلے ہی ترتیب دیا گیا ہے۔فہرست کی تقسیم مختلف طریقوں سے کی جاسکتی ہے ، جیسے لوموٹو پارٹیشن اسکیم یا ہوور پارٹیشن اسکیم۔یہاں ازگر میں لوموٹو پارٹیشن اسکیم کا استعمال کرتے ہوئے کوئکسورٹ الگورتھم کا ایک مثال عمل ہے: پیتھونڈف کوئکسورٹ (اے آر آر): اگر لین (آر آر) <= 1: رینٹ آر پیوٹ = آر اے آر [-1] i = 0 J کے لئے رینج میں (لین (لین (arr) -1): اگر arr [j] <محور: arr [i] ، arr [j] = arr [j] ، arr [i] i += 1 arr [i] ، arr [-1] = arr [-1] ، آر آر [i] بائیں = کوئکسٹورٹ (arr [: i]) دائیں = کوئکسٹورٹ (arr [i + 1:]) بائیں طرف لوٹیں + [arr [i]] + رائٹ یہ پروگرام ایک فنکشن کوئکورٹ () کی وضاحت کرتا ہے جس میں لیتا ہے۔ایک فہرست ARR ان پٹ کے طور پر اور ایک ترتیب شدہ فہرست لوٹاتی ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا اس فہرست میں صفر ہے یا ایک عناصر ، ایسی صورت میں اس کو پہلے سے ہی ترتیب دیا گیا ہے اور واپس کیا جاسکتا ہے۔اس کے بعد یہ فہرست کے آخری عنصر کو محور عنصر کے طور پر منتخب کرتا ہے ، اور فہرست میں تکرار کرکے اور ان عناصر کو تبدیل کرکے جو اس فہرست سے کم ہوتا ہے جو محور سے زیادہ یا اس کے برابر ہوتا ہے۔اس کے بعد یہ محور عنصر کو پہلے عنصر کے ساتھ تبدیل کرکے اپنی صحیح پوزیشن میں رکھتا ہے جو محور سے زیادہ یا اس کے برابر ہوتا ہے۔اس کے بعد یہ بار بار بائیں اور دائیں ذیلی لسٹوں کو ترتیب دیتا ہے اور ترتیب دیئے گئے بائیں ذیلی فہرست ، محور عنصر ، اور ترتیب شدہ دائیں ذیلی فہرست کی تشکیل کو واپس کرتا ہے۔ اس فنکشن کا ایک مثال استعمال: ازگر = [3 ، 1 ،4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5] ترتیب شدہ_ار = کوئکسورٹ (آر اے آر) پرنٹ (چھانٹ_ر) # آؤٹ پٹ: [1 ، 1 ، 2 ، 3 ، 3 ، 4 ، 5 ، 5 ، 5 ،6 ، 9] یہ پروگرام ایک فہرست ARR تشکیل دیتا ہے ، فہرست کے ساتھ کوئکسورٹ () فنکشن کو ان پٹ کے بطور کال کرتا ہے ، اور ترتیب شدہ فہرست کو پرنٹ کرتا ہے۔آؤٹ پٹ ترتیب شدہ فہرست ہے ، جو اس کیس میں IS11233455569 میں ہے۔"
    },
    {
        "Question": "\"کسی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے ایک پروگرام لکھیں ، دوسرا عنصر پہلے کے بعد ظاہر ہوتا ہے ، اور پہلا عنصر چھوٹا ہوتا ہے۔\"",
        "Answer": "کسی دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے ل the ، دوسرے عنصر کے ساتھ پہلے کے بعد اور پہلا عنصر چھوٹا ہونے کے ساتھ ، ہم ایک سادہ نقطہ نظر استعمال کرسکتے ہیں جس میں فہرست میں تکرار کرنا اور کم سے کم عنصر کو ٹریک رکھنا شامل ہے۔دور اور اب تک زیادہ سے زیادہ فرق دیکھا گیا۔فہرست میں ہر عنصر کے ل we ، ہم چیک کرتے ہیں کہ آیا یہ موجودہ کم سے کم سے چھوٹا ہے یا نہیں۔اگر یہ ہے تو ، ہم کم سے کم اپ ڈیٹ کرتے ہیں۔بصورت دیگر ، ہم موجودہ عنصر اور کم سے کم کے درمیان فرق کا حساب لگاتے ہیں ، اور اگر موجودہ زیادہ سے زیادہ فرق سے زیادہ ہے تو زیادہ سے زیادہ فرق کو اپ ڈیٹ کریں۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف میکس_ ڈفینس (اے آر آر): اگر لین (اے آر آر) <2: کوئی بھی نہیں لوٹ کوئی نہیں۔= الیم اور: فرق = الیم - من_elem اگر فرق> زیادہ سے زیادہ_ڈیف: میکس_ ڈف = ڈف ریٹرن میکس_ ڈففیس پروگرام ایک فنکشن میکس_ ڈفینفینس () کی وضاحت کرتا ہے جو فہرست میں ایک فہرست آر آر لیتا ہے اور فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق لوٹاتا ہے ، جس میں دوسرا عنصر ظاہر ہوتا ہے۔پہلے ، اور پہلا عنصر چھوٹا ہونے کے بعد۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا اس فہرست میں دو سے کم عناصر ہیں ، ایسی صورت میں یہ کوئی نہیں لوٹاتا ہے۔اس کے بعد اس فہرست کے پہلے عنصر کے لئے اب تک نظر آنے والے کم سے کم عنصر کی ابتداء کی جاتی ہے ، اور اب تک زیادہ سے زیادہ فرق 0 تک دیکھا جاتا ہے۔ پھر اس فہرست کے باقی عناصر پر تکرار کرتا ہے ، اور ہر عنصر کے ل it ، یہ چیک کرتا ہے کہ آیا یہ چھوٹا ہے یا نہیں۔موجودہ کم سے کماگر یہ ہے تو ، یہ کم سے کم اپ ڈیٹ کرتا ہے۔بصورت دیگر ، یہ موجودہ عنصر اور کم سے کم کے درمیان فرق کا حساب لگاتا ہے ، اور زیادہ سے زیادہ فرق کو اپ ڈیٹ کرتا ہے اگر یہ موجودہ زیادہ سے زیادہ فرق سے زیادہ ہے۔آخر میں ، یہ زیادہ سے زیادہ فرق لوٹاتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہوتا ہے: ازگر = [2 ، 3 ، 8 ، 0 ، 7] میکس_ ڈف = میکس_ ڈفینس (اے آر آر) پرنٹ (میکس_ ڈف) # آؤٹ پٹ: 7 اس پروگرام میں ایک فہرست کی تشکیل ہوتی ہے ، کالزمیکس_ ڈفینس () فہرست کے ساتھ ان پٹ کے طور پر کام کرتا ہے ، اور فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق کو پرنٹ کرتا ہے ، دوسرے عنصر کے ساتھ پہلے کے بعد ظاہر ہوتا ہے ، اور پہلا عنصر چھوٹا ہوتا ہے۔اس معاملے میں آؤٹ پٹ 7 ہے"
    },
    {
        "Question": "عددیوں کی فہرست میں دیئے گئے ہدف کے ساتھ کسی بھی خالی سبری کی سب سے بڑی رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عدد کی فہرست میں دیئے گئے ہدف کے ساتھ کسی خالی خالی سبری کی سب سے بڑی رقم تلاش کرنے کے ل we ، ہم سلائیڈنگ ونڈو نقطہ نظر کو استعمال کرسکتے ہیں۔ہم فہرست کے آغاز تک دو پوائنٹرز ، بائیں اور دائیں شروع کرسکتے ہیں۔اس کے بعد ہم فہرست پر تکرار کرسکتے ہیں ، اور ہر عنصر کو چلتی ہوئی رقم میں شامل کرتے ہوئے۔اگر کرر_سم ہدف کی رقم سے زیادہ یا اس کے برابر ہے تو ، ہم اب تک دکھائی دینے والی زیادہ سے زیادہ رقم کو اپ ڈیٹ کرسکتے ہیں اور بائیں پوائنٹر کو دائیں طرف منتقل کرسکتے ہیں ، اور کرر_سم سے پچھلی بائیں پوزیشن پر عنصر کو گھٹا دیتے ہیں۔ہم اس عمل کو اس وقت تک جاری رکھتے ہیں جب تک کہ ہم فہرست کے اختتام تک نہ پہنچیں یا زیادہ سے زیادہ رقم ہدف کی رقم کے برابر نہ ہو۔اگر زیادہ سے زیادہ رقم ٹارگٹ کی رقم سے کم ہے تو ، ہدف کی رقم کے برابر رقم کے ساتھ کوئی سبری نہیں ہے۔ازگر میں اس نقطہ نظر کا ایک مثال نفاذ: پائیتھونڈف میکس_سوبری_سم (آر آر ، ٹارگٹ_سم): بائیں = 0 دائیں = 0 کریری_سم = 0 میکس_سم = فلوٹ ('-انف') جبکہ دائیں <لین (آر آر): کرن_سم += آر [دائیں] جبکہ curr_sum> = target_sum: max_sum = زیادہ سے زیادہ (زیادہ سے زیادہ_سم ، curr_sum) curr_sum -= arr [بائیں] بائیں += 1 دائیں += 1 میکس_سم!() جو ان پٹ کے طور پر ایک فہرست ARR اور ایک ٹارگٹ سم ٹارگٹ_سم لیتا ہے اور ہدف کی رقم سے کم یا اس کے برابر رقم کے ساتھ نان خالی سبری کی سب سے بڑی رقم واپس کرتا ہے۔یہ فہرست کے آغاز تک دو پوائنٹرز ، بائیں اور دائیں شروع کرتا ہے ، اور بالترتیب 0 اور منفی انفینٹی کو کرر_سم اور میکس_سم کو شروع کرتا ہے۔اس کے بعد ہر عنصر کو کرر_سم میں شامل کرتے ہوئے ، فہرست میں تکرار کرتا ہے۔اگر Curr_sum ہدف کی رقم سے زیادہ یا اس کے برابر ہے تو ، یہ Max_sum کو اپ ڈیٹ کرتا ہے اور بائیں پوائنٹر کو دائیں طرف منتقل کرتا ہے ، جس سے عنصر کو پچھلی بائیں پوزیشن پر کرر_سم سے گھٹا دیتا ہے۔یہ اس عمل کو جاری رکھے گا جب تک کہ وہ فہرست کے اختتام تک نہ پہنچ جائے یا زیادہ سے زیادہ رقم ہدف کے رقم کے برابر نہ ہو۔اگر زیادہ سے زیادہ رقم ہدف کے حساب سے کم ہے تو ، یہ کوئی بھی نہیں لوٹاتا ہے۔ اس فنکشن کی ایک مثال استعمال ہے: پائیتھونر = [1 ، 2 ، 3 ، 4 ، 5] ٹارگٹ_سم = 11max_sum = میکس_سوبری_سم (اے آر آر ، ٹارگٹ_سم) پرنٹ (زیادہ سے زیادہ_سم) پرنٹ (میکس_سم)# آؤٹ پٹ: 10 اس پروگرام میں ایک فہرست ARR اور ایک ہدف کے ہدف کو نشانہ بناتا ہے ، میکس_سوبری_سم () فنکشن کو فہرست اور ہدف کے ساتھ ان پٹ کے طور پر کال کرتا ہے ، اور غیر خالی سبری کی سب سے بڑی رقم کو پرنٹ کرتا ہے جس کے ساتھ اس سے کم یا اس کے برابر رقم کم ہوتی ہے۔ہدف رقماس معاملے میں آؤٹ پٹ 10 ہے"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، قیمتیں اور زاویہ بریکٹ کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط و قیمت ، اور زاویہ بریکٹ کے ساتھ ایک درست اظہار ہے یا نہیں ، ہم نقطہ نظر کا ایک مجموعہ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ افتتاحی علامتوں کو ٹریک رکھنے کے لئے اسٹیک کا استعمال کیا جائے ، اور جب بند ہونے والی علامت کا سامنا کرنا پڑتا ہے تو انہیں اسٹیک سے دور کردیں۔اگر تار کے آخر میں اسٹیک خالی ہے تو ، اظہار متوازن ہے۔ہم افتتاحی اور اختتامی علامتوں سے ملنے کے لئے باقاعدہ تاثرات بھی استعمال کرسکتے ہیں ، اور ہر علامت کے واقعات کی تعداد گن سکتے ہیں تاکہ یہ یقینی بنایا جاسکے کہ وہ متوازن ہیں۔یہاں کچھ وسائل ہیں جو ان طریقوں کی مزید معلومات اور مثالیں فراہم کرتے ہیں: اسٹیک نقطہ نظر: 1234 ریگولر اظہارات نقطہ نظر: 5 ازگر میں اسٹیک نقطہ نظر کی مثال کے طور پر عمل درآمد: پائیتھنڈف آئی ایس_بلنسڈ (ایکسپریس): اسٹیک = [] علامت کے لئے علامت: اگر علامت میں اگر علامت ہے تو علامت'([{<': stack.append (علامت) الیف علامت ')]}>': اگر اسٹیک نہیں ہے تو: غلط لوٹائیں اگر علامت == ')' اور اسٹیک [-1]! = '(': غلط واپساگر علامت == ']' اور اسٹیک [-1]! = '[': اگر علامت == '}' اور اسٹیک [-1]! = '{': جھوٹی لوٹائیں تو علامت == '>' اور اسٹیک کریںاسٹیک [-1]! = '<': غلط اسٹیک۔ پاپ () ریٹرن نہیں اسٹیک اس پروگرام میں ایک فنکشن کی وضاحت کی گئی ہے جس میں IS_BLANCED () ہوتا ہے جو ان پٹ کے طور پر سٹرنگ ایکسپریس لیتا ہے اور اگر اظہار میں متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ہے ، تو وہ درست ہے۔قیمتیں ، اور زاویہ بریکٹ ، اور دوسری صورت میں۔اگر کوئی علامت افتتاحی علامت ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔اگر کوئی علامت بند ہونے والی علامت ہے تو ، اس کا موازنہ اسٹیک کے اوپری حصے سے کیا جاتا ہے ، اور اگر وہ میچ کرتے ہیں تو ، افتتاحی علامت اسٹیک سے پاپ ہوجاتی ہے۔اگر تار کے اختتام پر اسٹیک خالی ہے تو ، اظہار متوازن ہے۔ فنکشن کی ایک مثال استعمال ہے: پائیتھون ایکس پی آر 1 = '({[<>]})' ایکسپریس 2 = '({[<]})' پرنٹ (پرنٹ (is_balanced (expr1)) # آؤٹ پٹ: ٹروپنٹ (is_balanced (expr2)) # آؤٹ پٹ: فالسیتیس پروگرام دو تاثرات Expr1 اور expr2 تخلیق کرتا ہے ، ہر اظہار کے ساتھ is_balanced () فنکشن کو ان پٹ کے طور پر کال کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔اگر اظہار خیال میں متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، اور زاویہ بریکٹ ، اور غلط ہے تو آؤٹ پٹ درست ہے۔ایکسپریس 1 کے لئے آؤٹ پٹ درست ہے ، اور ایکسپریس 2 کے لئے آؤٹ پٹ غلط ہے۔"
    },
    {
        "Question": "\"تصادم کی قرارداد کے لئے علیحدہ زنجیروں کا استعمال کرتے ہوئے ہیش نقشہ کی نمائندگی کرنے والے ایک ازگر کلاس لکھیں اور کلیدی قیمت کے جوڑے داخل کرنے ، بازیافت کرنے اور ان کو دور کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا ایک مثال ہے جس میں ہیش نقشہ کی نمائندگی ہوتی ہے جس میں تصادم کی قرارداد کے لئے علیحدہ زنجیروں کا استعمال کرتے ہوئے اور وسائل کی بنیاد پر کلیدی قدر کے جوڑے کو داخل کرنے ، بازیافت کرنے اور ان کو ہٹانے کے طریقوں کا استعمال کرتے ہوئے ، پیتھونکلاس نوڈ: ڈیف __init __ (خود ، کلید ، قیمت): self.key = key self.value = value self.next = noneclass ہیش میپ: Def __init __ (خود ، سائز = 16): خود۔): ریٹرن ہیش (کلیدی) خود۔) دوسری: کرر = سیلف۔ ہش_ٹیبل [انڈیکس] جبکہ کرور. نیکسٹ: اگر curr.key == key: curr.value = ویلیو ریٹرن کرور = کرور. نیکسٹ اگر curr.key == key: curr.value = ویلیو = ویلیو کوئی اور:curr.next = نوڈ (کلید ، قدر) ڈیف بازیافت (خود ، کلید): انڈیکس = سیلف۔= curr.next واپس کوئی نہیں ڈیف کو ہٹائیں (خود ، کلید): انڈیکس = سیلف۔= curr.next else: self.hash_table [index] = curr.next ریٹرن پریف = کرور کرور = کرر۔ نیکسٹ یہ پروگرام ایک لنکڈ فہرست میں نوڈ کی نمائندگی کرنے کے لئے کلاس نوڈ کی وضاحت کرتا ہے ، اور علیحدہ علیحدہ استعمال کرتے ہوئے ہیش نقشہ کی نمائندگی کرنے کے لئے ایک کلاس ہیش میپتصادم کے حل کے لئے زنجیرنوڈ کلاس میں تین صفات ہیں: نوڈ کی کلید کو ذخیرہ کرنے کی کلید ، نوڈ کی قیمت کو ذخیرہ کرنے کی قدر ، اور اس کے بعد فہرست میں اگلے نوڈ کا حوالہ اسٹور کرنے کے لئے۔ہیش میپ کلاس میں دو صفات ہیں: ہیش ٹیبل کے سائز کو ذخیرہ کرنے کے لئے سائز ، اور ہیش ٹیبل کے ہر انڈیکس پر منسلک فہرستوں کو محفوظ کرنے کے لئے ہیش_ٹیبل۔کلاس تین طریقوں کی بھی وضاحت کرتی ہے: ہیش کے نقشے میں کلیدی قدر کی جوڑی داخل کرنے کے لئے () داخل کریں ، ہیش کے نقشے سے کسی کلید سے وابستہ قدر کو بازیافت کرنے کے لئے () بازیافت کریں ، اور () کو حذف کرنے کے لئے () کو ہٹائیں ()ہیش کا نقشہ۔ داخل () کا طریقہ پہلے _hash_func () طریقہ کار کا استعمال کرتے ہوئے کلید کی ہیش ویلیو کا حساب لگاتا ہے ، اور اگر ہیش ٹیبل کا متعلقہ انڈیکس خالی ہے تو چیک کرتا ہے۔اگر یہ ہے تو ، یہ کلیدی قدر کی جوڑی کے ساتھ ایک نیا نوڈ تیار کرتا ہے اور اسے انڈیکس میں داخل کرتا ہے۔اگر یہ خالی نہیں ہے تو ، یہ انڈیکس میں لنکڈ لسٹ پر تکرار کرتا ہے ، اس بات کی جانچ پڑتال کرتے ہیں کہ آیا کلید پہلے سے موجود ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، یہ موجودہ نوڈ کی قدر کو اپ ڈیٹ کرتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، یہ ایک نیا نوڈ بناتا ہے اور اسے فہرست کے آخر میں شامل کرتا ہے۔ بازیافت () طریقہ پہلے _hash_func () طریقہ کار کا استعمال کرتے ہوئے کلید کی ہیش ویلیو کا حساب لگاتا ہے ، اور متعلقہ انڈیکس میں منسلک فہرست پر تکرار کرتا ہے۔ہیش ٹیبل کے ، جانچ پڑتال کرتے ہوئے کہ آیا کلید فہرست میں نوڈ کی کلید سے مماثل ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، یہ نوڈ کی قیمت لوٹاتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، یہ کوئی بھی نہیں لوٹاتا ہے۔ ہٹ () کا طریقہ پہلے _hash_func () طریقہ کار کا استعمال کرتے ہوئے کلید کی ہیش ویلیو کا حساب لگاتا ہے ، اور ہیش ٹیبل کے متعلقہ انڈیکس میں منسلک فہرست پر تکرار کرتا ہے ، اس بات کی جانچ پڑتال کرتے ہیں کہ آیا کلید مماثل ہے یا نہیںفہرست میں نوڈ کی کلید۔اگر ایسا ہوتا ہے تو ، یہ نوڈ کو ختم کرنے کے لئے پچھلے نوڈ کے اگلے پوائنٹر کو اپ ڈیٹ کرکے نوڈ کو ہٹا دیتا ہے۔ یہاں کلاس کا ایک مثال استعمال ہے: پائیتھون ہاش_ میپ = ہیش میپ () ہیش_ میپ.سرٹ ('ایپل' ، 1) ہیش_مپ.سرٹ ('کیلے' ، 2) ہیش_مپ.سرٹ ('چیری' ، 3) پرنٹ (ہیش_مپ.ریٹرائیو ('کیلے')) # آؤٹ پٹ: 2 ہش_مپ.موو ('کیلے') پرنٹ (ہیش_ میپ.ریٹریو (''کیلے ')) # آؤٹ پٹ: نونتیس پروگرام ہیش میپ کی ایک مثال تیار کرتا ہے ، داخل () کے طریقہ کار کا استعمال کرتے ہوئے ہیش نقشہ میں تین کلیدی قدر کے جوڑے داخل کرتا ہے ، بازیافت () کے طریقہ کار کا استعمال کرتے ہوئے کلیدی' کیلے 'سے وابستہ قدر کو بازیافت کرتا ہے ، ہٹاتا ہے۔کلیدی قدر کی جوڑی کلیدی 'کیلے' سے وابستہ () کے طریقہ کار کا استعمال کرتے ہوئے ، اور کلیدی 'کیلے' سے وابستہ قدر کو دوبارہ حاصل کرتی ہے تاکہ اس بات کی تصدیق کی جاسکے کہ یہ کوئی بھی نہیں ہے۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ کی لمبائی تلاش کرنے کے ل we ، ہم ایک متحرک پروگرامنگ نقطہ نظر استعمال کرسکتے ہیں جس میں ذیلی مسائل کے نتائج کو ذخیرہ کرنے کے لئے ایک ٹیبل بنانا شامل ہے۔ہم سائز N X N کی ٹیبل ٹیبل شروع کرسکتے ہیں ، جہاں N تار کی لمبائی ہے ، اور ٹیبل سیٹ کریں [i] [i] سب کے لئے سچ ہے۔اس کے بعد ہم تار کے اوپر تکرار کرسکتے ہیں ، یہ چیک کرتے ہوئے کہ آیا لمبائی K کی ہر سب اسٹرنگ ایک پیلنڈرووم ہے ، جہاں K 2 سے N تک ہے۔اگر ایک سٹرنگ ایک پیلینڈرووم ہے تو ، ہم نے ٹیبل [i] [i+K-1] کو سچ پر سیٹ کیا۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونڈف طویل ترین_پالندرووم (ایس): این = لین (ایس) ٹیبل = [[رینج میں _ کے لئے غلط (این)] کے لئے _ کے لئے (n)] میکس_لین = 1 کے لئے I I IN RAND(n): ٹیبل [i] [i] = رینج میں K کے لئے سچ (2 ، n+1): رینج میں I (n -k+1): j = i+k - 1 اگر s [i] == s [j] اور (k == 2 یا ٹیبل [i+1] [j-1]): ٹیبل [i] [j] = سچ میکس_لن = زیادہ سے زیادہ (میکس_لن ، کے) واپسی میکس_لینٹیس پروگرام ایک فنکشن کی وضاحت کرتا ہے۔) جو ان پٹ کے طور پر ایک تار لیتا ہے اور تار میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے۔یہ سب سے پہلے سائز N X N کی ٹیبل ٹیبل کی ابتدا کرتا ہے ، جہاں N تار کی لمبائی ہے ، اور ٹیبل [i] [i] کو سب کے لئے درست کرنے کے لئے سیٹ کرتا ہے۔اس کے بعد یہ تار کے اوپر تکرار کرتا ہے ، یہ جانچتے ہوئے کہ آیا لمبائی K کی ہر ذخیرہ ایک پالندرووم ہے ، جہاں K 2 سے N تک ہے۔اگر ایک سٹرنگ ایک پیلینڈرووم ہے تو ، یہ ٹیبل [i] [i+k-1] کو سچ پر سیٹ کرتا ہے۔یہ اب تک دیکھا جانے والا سب سے طویل پیلنڈرووم پر نظر رکھتا ہے اور اس کی لمبائی لوٹاتا ہے۔ یہاں فنکشن کی ایک مثال استعمال ہے: ازگر = 'فورجیکسکیگفور'میکس_لن = سب سے طویل_palindrome (s) پرنٹ (میکس_لین) # آؤٹ پٹ: 10 اس پروگرام کو ایک تار تیار کرتا ہے ، کال کرتا ہے ، کال کرتا ہے ،اس معاملے میں آؤٹ پٹ 10 ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا بائنری سرچ کا استعمال کرتے ہوئے دیئے گئے نمبر ایک بہترین مربع ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا بائنری سرچ کا استعمال کرتے ہوئے ایک دیئے گئے نمبر ایک بہترین مربع ہے ، ہم اس حقیقت کو استعمال کرسکتے ہیں کہ کسی بڑی تعداد کا مربع ہمیشہ غیر منفی اور بڑھتا رہتا ہے۔لہذا ، ہم نمبر کے مربع جڑ کو تلاش کرنے کے لئے بائنری سرچ کا استعمال کرسکتے ہیں ، اور چیک کریں کہ آیا وسط نقطہ کا مربع نمبر کے برابر ہے یا نہیں۔اگر یہ ہے تو ، نمبر ایک کامل مربع ہے۔اگر وسط نقطہ کا مربع تعداد سے زیادہ ہے تو ، ہم رینج کے بائیں نصف حصے کو تلاش کرتے ہیں۔اگر یہ تعداد سے کم ہے تو ، ہم رینج کے دائیں نصف حصے کو تلاش کرتے ہیں۔ہم اس عمل کو اس وقت تک دہراتے ہیں جب تک کہ ہمیں مربع جڑ یا رینج ختم نہ ہوجائے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف is_perfect_square (n): اگر n <2: بائیں طرف لوٹائیں = 2 دائیں = n // 2 جبکہ بائیں <= دائیں: وسط = (بائیں + دائیں) // 2 مربع =وسط * وسط اگر مربع == n: واپس ٹرو ایلف مربع> n: دائیں = وسط - 1 اور: بائیں = وسط + 1 ریٹرن فالسیتیس پروگرام ایک فنکشن کی وضاحت کرتا ہے۔ایک کامل مربع ہے ، اور دوسری صورت میں غلط ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا نمبر 2 سے کم ہے ، اس صورت میں یہ ایک بہترین مربع ہے۔اس کے بعد یہ 2 سے N // 2 تک کی حد کا آغاز کرتا ہے ، اور بائنری تلاش کا استعمال کرتے ہوئے نمبر کے مربع جڑ کی تکرار سے تلاش کرتا ہے۔اگر وسط نقطہ کا مربع تعداد کے برابر ہے تو ، یہ سچ واپس آجاتا ہے۔اگر وسط نقطہ کا مربع تعداد سے زیادہ ہے تو ، یہ حد کے بائیں نصف حصے کو تلاش کرتا ہے۔اگر یہ تعداد سے کم ہے تو ، یہ رینج کے دائیں نصف حصے کو تلاش کرتا ہے۔یہ اس عمل کو دہراتا ہے جب تک کہ اسے مربع جڑ نہ مل جائے یا حد ختم ہوجائے۔اگر اسے مربع جڑ نہیں ملتی ہے تو ، یہ جھوٹی لوٹاتا ہے۔ یہاں فنکشن کی ایک مثال استعمال ہے: پائیتھونن 1 = 16 این 2 = 14 پرنٹ (is_perfect_square (n1)) # آؤٹ پٹ: سچ پرنٹ (is_perfect_square (n2)) # آؤٹ پٹ: فالسیتھ پروگرام دو نمبر بناتا ہے۔N1 اور N2 ، IS_PERFECT_SQUARE () کو ہر نمبر کے ساتھ ان پٹ کے طور پر فون کرتا ہے ، اور نتیجہ کو پرنٹ کرتا ہے۔اگر نمبر ایک کامل مربع ہے ، اور دوسری صورت میں غلط ہے تو آؤٹ پٹ درست ہے۔N1 کے لئے آؤٹ پٹ درست ہے ، اور N2 کے لئے آؤٹ پٹ غلط ہے۔"
    },
    {
        "Question": "\"بائنری درخت میں زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں ، جہاں کسی بھی نوڈ پر راستہ شروع اور ختم ہوسکتا ہے۔\"",
        "Answer": "بائنری درخت میں زیادہ سے زیادہ رقم کا راستہ تلاش کرنے کے ل where ، جہاں راستہ کسی بھی نوڈ پر شروع ہوسکتا ہے اور ختم ہوسکتا ہے ، ہم ایک متحرک پروگرامنگ نقطہ نظر استعمال کرسکتے ہیں جس میں درخت کے ہر نوڈ کے ذریعے زیادہ سے زیادہ راستے کا حساب کتاب کرنا شامل ہوتا ہے۔ہم ایک تکرار فنکشن میکس_پاتھ_سم () کی وضاحت کرسکتے ہیں جو ان پٹ کے طور پر ایک نوڈ لیتا ہے اور اس نوڈ کے ذریعے زیادہ سے زیادہ راستہ کا مجموعہ واپس کرتا ہے۔نوڈ کے ذریعے زیادہ سے زیادہ راستہ کا مجموعہ نوڈ ویلیو کی زیادہ سے زیادہ ، نوڈ ویلیو کے علاوہ بائیں بچے کے ذریعے زیادہ سے زیادہ راستہ ، نوڈ ویلیو کے علاوہ دائیں بچے کے ذریعے زیادہ سے زیادہ راستہ کا مجموعہ ، اور نوڈ ویلیو کے علاوہ زیادہ سے زیادہ راستہ کا مجموعہ ہےبائیں بچے اور دائیں بچے کے ذریعے۔اس کے بعد ہم درخت کے ہر نوڈ کے ذریعے زیادہ سے زیادہ راہ کے مجموعی طور پر حساب کتاب کر سکتے ہیں ، اب تک دیکھنے میں آنے والے زیادہ سے زیادہ راستے کا سراغ لگاتے ہوئے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ویل): سیلف.وال = ویل خود۔نوڈ نہیں: واپس 0 بائیں_سم = زیادہ سے زیادہ (میکس_پاتھ_سم_ہیلپر (نوڈ. لیفٹ) ، 0) دائیں_سم = زیادہ سے زیادہ (زیادہ سے زیادہ_پاتھ_سم_ہیلپر (نوڈ. رائٹ) ، 0) میکس_سم = زیادہ سے زیادہ (زیادہ سے زیادہ_سم ، نوڈ.ول + بائیں_سم + ریٹرن نوڈ۔زیادہ سے زیادہ (بائیں_سم ، دائیں_سم) میکس_سم = فلوٹ ('-انف') میکس_پاتھ_سم_ہیلپر (جڑ) ریٹرن میکس_سومتھ پروگرام بائنری درخت میں نوڈ کی نمائندگی کرنے کے لئے ایک کلاس نوڈ کی وضاحت کرتا ہے ، اور ایک فنکشن میکس_پاتھ_سم () جو جڑ نوڈ کو ان پٹ اور ریٹرن کے طور پر لیتا ہے۔بائنری درخت میں زیادہ سے زیادہ رقم کا راستہ۔فنکشن ایک ہیلپر فنکشن میکس_پاتھ_سم_ہیلپر () کی وضاحت کرتا ہے جو ان پٹ کے طور پر نوڈ لیتا ہے اور اس نوڈ کے ذریعے زیادہ سے زیادہ راہ کا مجموعہ واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا نوڈ کوئی نہیں ہے ، اس معاملے میں یہ واپس آجاتا ہے۔ اس کے بعد یہ بائیں بچے اور دائیں بچے کے ذریعے تکرار کا استعمال کرتے ہوئے زیادہ سے زیادہ راستے کا حساب لگاتا ہے ، اور منفی اقدار کو سنبھالنے میں ان اقدار میں سے زیادہ سے زیادہ اور 0 لیتا ہے۔اس کے بعد نوڈ کی قیمت ، بائیں بچے کے ذریعے زیادہ سے زیادہ راستہ کا مجموعہ ، اور دائیں بچے کے ذریعہ زیادہ سے زیادہ راستہ کا مجموعہ شامل کرکے نوڈ کے ذریعے زیادہ سے زیادہ راستے کا حساب کتاب کرتا ہے۔یہ اب تک دیکھنے میں آنے والے زیادہ سے زیادہ راستے کی تازہ کاری کرتا ہے اگر موجودہ زیادہ سے زیادہ راستہ کی رقم پچھلے زیادہ سے زیادہ راستے کے مجموعی سے زیادہ ہے۔اس کے بعد یہ نوڈ کے ذریعے زیادہ سے زیادہ راہ کا مجموعہ لوٹاتا ہے۔میکس_پاتھ_سم () فنکشن منفی انفینٹی کے لئے اب تک دیکھا جانے والے زیادہ سے زیادہ راستے کی شروعات کرتا ہے ، میکس_پاتھ_سوم_ہیلپر () کو روٹ نوڈ کے ساتھ ان پٹ کے طور پر کال کرتا ہے ، اور اب تک دیکھا جانے والا زیادہ سے زیادہ راہ کا مجموعہ واپس کرتا ہے۔ اس فنکشن کا ایک مثال استعمال: پائیٹونروٹ =نوڈ (10) روٹ. لیفٹ = نوڈ (2) روٹ۔ رائٹ = نوڈ (10) روٹ۔ لیفٹ.لیفٹ = نوڈ (20) روٹ۔ لیفٹ. رائٹ = نوڈ (1) جڑ۔ رائٹ. رائٹ = نوڈ (-25 (-25 (-25) روٹ. رائٹ. رائٹ.left = نوڈ (3) جڑ۔) جڑ نوڈ کے ساتھ ان پٹ کے طور پر کام کریں ، اور بائنری درخت میں زیادہ سے زیادہ رقم کا راستہ پرنٹ کریں۔اس معاملے میں آؤٹ پٹ 42 ہے"
    },
    {
        "Question": "ڈائریکٹرا کے الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے ہدایت والے وزن والے گراف کی نمائندگی کرنے والے ایک ازگر کلاس بنائیں اور طریقوں کو نافذ کریں۔",
        "Answer": "ڈائریکٹرا کے الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے ہدایت والے وزن والے گراف کی نمائندگی کرنے اور طریقوں کو نافذ کرنے کے لئے ایک ازگر کلاس بنانے کے ل we ، ہم نقطہ نظر کا ایک مجموعہ استعمال کرسکتے ہیں۔ایک نقطہ نظر ایک کلاس گراف کی وضاحت کرنا ہے جو ملحقہ میٹرکس کا استعمال کرتے ہوئے ہدایت والے وزن والے گراف کی نمائندگی کرتا ہے ، اور ایک طریقہ جس کی وضاحت ڈجکسٹرا () کی ہے جو گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرتا ہے۔ایک اور نقطہ نظر ایک کلاس گراف کی وضاحت کرنا ہے جو نوڈس اور کناروں کی لغت کا استعمال کرتے ہوئے ہدایت والے وزن والے گراف کی نمائندگی کرتا ہے ، اور ایک طریقہ ڈجکسٹرا () کی وضاحت کرنا ہے جو گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرتا ہے۔یہاں کچھ وسائل ہیں جو ان طریقوں کی مزید معلومات اور مثالیں فراہم کرتے ہیں: ملحقہ میٹرکس کا استعمال کرتے ہوئے: نوڈس اور کناروں کی 12 لغت کا استعمال: 3456 اس کی مثال ازدواجی میں ملحقہ میٹرکس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: پائیٹونیمپورٹ سیسکلاس گراف: Def __init __ (خود ، عمودی).= وزن ڈیف ڈجکسٹرا (خود ، شروع): ملاحظہ کیا گیا = [غلط] * خود سے متعلق فاصلوں = [sys.maxsize] * سیلف.ورٹیسس فاصلوں [start] = 0 _ کے لئے _ رینج میں (سیلف ۔ورٹیسس): من_ڈیسٹنس = سیس۔رینج (سیلف.ورٹیکس) میں وی کے لئے زیادہ سے زیادہ: اگر نہیں ملاحظہ کیا گیا ہے [v] اور فاصلوں [v] <min_distance: min_distance = فاصلوں [v] u = v ملاحظہ [u] = v کے لئے سچائی (سیلف ۔ورٹیکس):اگر سیلف گراف [u] [v]> 0 اور نہیں ملتا [v]: new_distance = فاصلوں [u] + سیلف گراف [u] [v] اگر new_distance <فاصلوں [v]: فاصلوں [v] = new_distance واپسیڈسنسیسٹس پروگرام ایک کلاس گراف کی وضاحت کرتا ہے جو ملحقہ میٹرکس کا استعمال کرتے ہوئے ہدایت والے وزن والے گراف کی نمائندگی کرتا ہے۔کلاس میں دو صفات ہیں: گراف میں عمودی کی تعداد کو ذخیرہ کرنے کے لئے عمودی ، اور گراف میں گراف میں گراف کو میٹرکس کے طور پر ذخیرہ کرنے کے لئے گراف۔کلاس دو طریقوں کی بھی وضاحت کرتی ہے: گراف میں ایک کنارے شامل کرنے کے لئے ADD_EDGE () ، اور گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرنے کے لئے ڈجکسٹرا ()۔ADD_EDGE () کا طریقہ تین آدانوں میں لیتا ہے: کنارے کے نوڈس کی نمائندگی کرنے کے لئے U اور V ، اور وزن کے وزن کی نمائندگی کرنے کے لئے وزن۔یہ کنارے کے وزن کے ساتھ ملحقہ میٹرکس میں متعلقہ اندراج کو اپ ڈیٹ کرتا ہے۔ڈجکسٹرا () کا طریقہ ایک ان پٹ لیتا ہے: مختصر ترین راستے کے ابتدائی نوڈ کی نمائندگی کرنا شروع کریں۔اس میں دو فہرستوں کا آغاز ہوتا ہے: دورے والے نوڈس کو ٹریک رکھنے کے لئے ملاحظہ کیا گیا ، اور گراف میں شروع ہونے والے نوڈ سے کم ترین فاصلے پر ٹریک رکھنے کے لئے فاصلے۔یہ شروعاتی نوڈ کا فاصلہ 0 پر طے کرتا ہے ، اور تکراری طور پر ڈجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے غیر منحصر نوڈس کے فاصلوں کو اپ ڈیٹ کرتا ہے۔یہ قلیل فاصلوں کی فہرست لوٹاتا ہے۔ یہاں کلاس کا ایک مثال استعمال ہے: پائیتھونگ = گراف (4) جی.اڈ_ج (0 ، 1 ، 1) جی.اڈی_ج (0 ، 2 ، 4) جی. ایڈڈ_ج (1 ، 2 ، 2 ،2) g.add_edge (1 ، 3 ، 5) g.add_edge (2 ، 3 ، 1) دوری = g.dijkStra (0) پرنٹ (فاصلوں) # آؤٹ پٹ: [0 ، 1 ، 3 ، 4] یہ پروگرام ایک تخلیق کرتا ہےگراف جی 4 عمودی کے ساتھ ، add_edge () کے طریقہ کار کا استعمال کرتے ہوئے گراف میں 5 کناروں کا اضافہ کرتا ہے ، شروعاتی نوڈ 0 کے ساتھ ڈجکسٹرا () کے طریقہ کار کو ان پٹ کے طور پر کال کرتا ہے ، اور گراف میں شروع ہونے والے نوڈ سے کم ترین فاصلوں کی فہرست کو پرنٹ کرتا ہے۔آؤٹ پٹ IS0134IN اس معاملے میں۔ یہاں ازگر میں لغت کے نقطہ نظر کی ایک مثال کے نفاذ: پائیتھونیمپورٹ ہیپقیمپورٹ سیسکلاس گراف: ڈیف __init __ (خود): سیلف ڈاٹ نوڈس = سیٹ () سیلف () خود۔وزن): self.nodes.add (u) self.nodes.add (v) اگر آپ خود میں نہیں ہیں۔) ڈیف ڈجکسٹرا (خود ، شروع): فاصلوں = {نوڈ: sys.maxsize self.nodes} فاصلوں [start] = 0 قطار = [(0 ، start)] جبکہ قطار: (ڈسٹرکٹ ، یو) = ہیپ کیو۔ہیپپپ (قطار) اگر ڈسٹرکٹ> دوری [u]: خود میں (v ، وزن) کے لئے جاری رکھیں۔new_distance ہیپ کیو۔ ہیپش (قطار ، (new_distance ، v)) ریٹرن ڈسنسٹیس پروگرام ایک کلاس گراف کی وضاحت کرتا ہے جو نوڈس اور کناروں کی لغت کا استعمال کرتے ہوئے ہدایت شدہ وزن والے گراف کی نمائندگی کرتا ہے۔کلاس میں دو صفات ہیں: گراف میں نوڈس کے سیٹ کو ذخیرہ کرنے کے لئے نوڈس ، اور گراف میں کناروں کو فہرستوں کی لغت کے طور پر ذخیرہ کرنے کے لئے کناروں۔کلاس دو طریقوں کی بھی وضاحت کرتی ہے: گراف میں ایک کنارے شامل کرنے کے لئے ADD_EDGE () ، اور ڈجکسٹرا () کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرنے کے لئے ڈجکسٹرا ()"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، قیمتیں ، زاویہ بریکٹ اور سلیش کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط و قیمت ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے یا نہیں ، ہم نقطہ نظر کا ایک مجموعہ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ افتتاحی علامتوں کو ٹریک رکھنے کے لئے اسٹیک کا استعمال کیا جائے ، اور جب بند ہونے والی علامت کا سامنا کرنا پڑتا ہے تو انہیں اسٹیک سے دور کردیں۔اگر تار کے آخر میں اسٹیک خالی ہے تو ، اظہار متوازن ہے۔ہم افتتاحی اور اختتامی علامتوں سے ملنے کے لئے باقاعدہ تاثرات بھی استعمال کرسکتے ہیں ، اور ہر علامت کے واقعات کی تعداد گن سکتے ہیں تاکہ یہ یقینی بنایا جاسکے کہ وہ متوازن ہیں۔یہاں کچھ وسائل ہیں جو ان طریقوں کی مزید معلومات اور مثالیں فراہم کرتے ہیں: اسٹیک کا استعمال کرتے ہوئے: 123 باقاعدہ اظہار کا استعمال: 4 ہیری کی مثال ازگر میں اسٹیک نقطہ نظر کی ایک مثال عمل: پائیتھنڈف آئی ایس_بلانسڈ (ایکسپریس): اسٹیک = [] اوپننگ = \"([{<\\ \"\" \"بند کرنا =\")]]}> \\ \"\" \"فرار میں علامت کے لئے =\" \\\\ \"فرار ہوجاتا ہے: اگر افتتاحی علامت: اسٹیک.ایپینڈ (علامت) الیف علامت بند ہونے میں: اگر اسٹیک نہیں ہے تو: جھوٹا واپس کریں اگر کھلیں تو غلط واپس کریں.Index (اسٹیک [-1])! = کلوزنگ۔ انڈیکس (علامت): غلط اسٹیک واپس کریں۔سچ ہے کہ اگر تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیشز ، اور غلط کے ساتھ ایک درست اظہار ہے۔یہ سب سے پہلے افتتاحی علامتوں کو ٹریک رکھنے کے لئے ایک اسٹیک کی ابتدا کرتا ہے ، اور افتتاحی اور اختتامی علامتوں اور فرار کے کرداروں کی وضاحت کرتا ہے۔اس کے بعد یہ تار کے اوپر تکرار کرتا ہے ، جانچ پڑتال کرتے ہوئے کہ آیا ہر علامت ایک ابتدائی علامت ، اختتامی علامت ، یا فرار کا کردار ہے۔اگر علامت ایک ابتدائی علامت ہے تو ، یہ اسے اسٹیک پر دھکیل دیتی ہے۔اگر علامت بند ہونے والی علامت ہے تو ، یہ چیک کرتا ہے کہ اگر اسٹیک خالی ہے ، اور اگر اسٹیک کے اوپری حصے میں ابتدائی علامت بند ہونے والی علامت سے مماثل ہے۔اگر علامت فرار کا کردار ہے تو ، یہ اسے چھوڑ دیتا ہے۔اگر تار کے آخر میں اسٹیک خالی ہے ، اور دوسری صورت میں غلط ہے تو یہ سچ ہے۔ اس فنکشن کا ایک مثال استعمال ہے: پائیتھون ایکس پی آر 1 = \"((a+b)*c)\" expt2 = \"{[(a+b)*c]/d} \"expr3 =\" ((a+b)*c \"پرنٹ (is_balanced (expt1)) # آؤٹ پٹ: ٹروپنٹ (is_balanced (expr2)) # آؤٹ پٹ: ٹروپنٹ (is_balanced (expr3)) # آؤٹ پٹ: فالستھیسپروگرام میں تین ڈور ایکسپریس 1 ، ایکسپریس 2 ، اور ایکسپریس پیدا ہوتا ہے ، ہر تار کے ساتھ IS_BLANCED () کو ان پٹ کے طور پر کال کرتا ہے ، اور اس کا نتیجہ پرنٹ کرتا ہے۔ آؤٹ پٹ سچ ہے اگر اسٹرنگ متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، کے ساتھ ایک درست اظہار ہے۔زاویہ بریکٹ ، اور سلیشز ، اور دوسری صورت میں۔"
    },
    {
        "Question": "کسی بائنری صف میں 0s اور 1s کی برابر تعداد کے ساتھ سبری کی زیادہ سے زیادہ لمبائی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دیئے گئے بائنری صف میں 0s اور 1s کی مساوی تعداد کے ساتھ سبری کی زیادہ سے زیادہ لمبائی تلاش کرنے کے ل we ، ہم ایک متحرک پروگرامنگ نقطہ نظر استعمال کرسکتے ہیں جس میں اب تک دیکھا جانے والے 0s اور 1s کی گنتی پر نظر رکھنا شامل ہے ، اور وہ انڈیکس جس میں وہ تھےدیکھاہم دو متغیرات کی گنتی اور میکس_لین کو 0 پر شروع کرسکتے ہیں ، اور اب تک دیکھے جانے والے 0 اور 1s کی گنتی اور ان کے متعلقہ اشاریوں کو ذخیرہ کرنے کے لئے ایک لغت گنتی_ڈکٹ۔اس کے بعد ہم بائنری صف پر تکرار کرسکتے ہیں ، اگر موجودہ عنصر 1 ہے تو 1 کی گنتی میں اضافہ کریں ، اور اگر موجودہ عنصر 0 ہے تو 1 سے گنتی کو 1 سے کم کریں۔اب تک ، اور ہم موجودہ انڈیکس اور انڈیکس کی زیادہ سے زیادہ حد تک نظر آنے والی زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرسکتے ہیں جس میں گنتی 0 مائنس انڈیکس تھی جس میں پہلے وہی گنتی نظر آتی تھی۔اگر گنتی پہلے سے ہی لغت میں نہیں ہے تو ہم موجودہ گنتی اور انڈیکس کے ساتھ لغت کو اپ ڈیٹ کرسکتے ہیں۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونڈف میکس_لنتھ_سبرے (اے آر آر): گنتی = 0 میکس_لن = 0 گنتی_ڈکٹ = {0: -1 in میں رینج (لین (اے آر آر)) کے لئے: اگر آر آر [i] == 1:گنتی += 1 اور: گنتی - = 1 اگر گنتی میں گنتی_ ڈکٹ: میکس_لن = میکس (میکس_لن ، i - گنتی_ ڈکٹ [گنتی]) ورنہ: گنتی_ ڈکٹ [گنتی] = میں میکس_لینٹیس پروگرام ایک فنکشن کی وضاحت کرتا ہے جس میں ایک فنکشن میکس_لنتھ_سوبری () ہوتا ہے جس میں بائنری کا آغاز ہوتا ہے۔اے آر آر ان پٹ کے طور پر اور سرنی میں 0s اور 1s کی برابر تعداد کے ساتھ سبری کی زیادہ سے زیادہ لمبائی واپس کرتا ہے۔یہ پہلے 0s اور 1s کی گنتی کا آغاز کرتا ہے جو اب تک 0 سے دیکھا گیا ہے ، اب تک کی زیادہ سے زیادہ لمبائی 0 سے دیکھا جاتا ہے ، اور اب تک دیکھا جانے والے 0s اور 1s کی گنتی کو ذخیرہ کرنے کے لئے ایک لغت گنتی_ ڈکٹ۔اس کے بعد یہ بائنری صف کے اوپر تکرار کرتا ہے ، اگر موجودہ عنصر 1 ہے تو 1 کی گنتی میں اضافہ ہوتا ہے ، اور اگر موجودہ عنصر 0 ہے تو 1 کی گنتی کو 1 سے کم کرنا ہے ، اگر گنتی 0 ہے تو ، اس کی حد تک زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرتا ہے۔موجودہ انڈیکس اور انڈیکس کا زیادہ سے زیادہ جس میں گنتی 0 مائنس انڈیکس تھی جس میں پہلے وہی گنتی نظر آتی تھی۔یہ موجودہ گنتی اور انڈیکس کے ساتھ لغت کو اپ ڈیٹ کرتا ہے اگر گنتی پہلے سے ہی لغت میں نہیں ہے۔یہ اب تک نظر آنے والی زیادہ سے زیادہ لمبائی لوٹتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: ازگر = [0 ، 1 ، 0 ، 1 ، 1 ، 0 ، 1 ، 1] میکس_لن = میکس_لنتھ_سبرے (اے آر آر) پرنٹ (میکس_لن) # آؤٹ پٹ: 6 اس میں 6پروگرام ایک بائنری سرنی آر آر تیار کرتا ہے ، ان پٹ کے طور پر سرنی کے ساتھ میکس_لنتھ_سبرے () فنکشن کو کال کرتا ہے ، اور صف میں برابر تعداد میں 0 اور 1s کی برابر تعداد کے ساتھ سبری کی زیادہ سے زیادہ لمبائی پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 6 ہے"
    },
    {
        "Question": "مثبت عدد کی فہرست میں دیئے گئے ہدف کے ساتھ کسی بھی خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "مثبت عدد کی فہرست میں دیئے گئے ہدف کے ساتھ کسی خالی خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم سلائیڈنگ ونڈو نقطہ نظر کو استعمال کرسکتے ہیں۔ہم فہرست کے پہلے عنصر کے آغاز اور اختتام کو شروع کرسکتے ہیں ، اور پہلے عنصر کی قدر کے لئے ایک متغیر curr_sum شروع کرسکتے ہیں۔اس کے بعد ہم موجودہ عنصر کی قیمت کو کرر_سم میں شامل کرتے ہوئے اس فہرست میں تکرار کرسکتے ہیں۔اگر کرر_سم ہدف کی رقم سے زیادہ یا اس کے برابر ہے تو ، ہم موجودہ رقم کی زیادہ سے زیادہ اور اب تک کی زیادہ سے زیادہ رقم کی زیادہ سے زیادہ رقم کو اپ ڈیٹ کرسکتے ہیں۔اس کے بعد ہم اسٹارٹ پوائنٹر پر کریری_سم سے عنصر کی قدر کو گھٹا سکتے ہیں ، اور اسٹارٹ پوائنٹر میں اضافہ کرسکتے ہیں۔ہم اس عمل کو اس وقت تک دہراتے ہیں جب تک کہ اختتامی پوائنٹر فہرست کے اختتام تک نہ پہنچ جائے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونڈف میکس_سم_سوبری (آر آر ، ٹارگٹ_سم): اسٹارٹ = 0 اختتام = 0 کریری_سم = آر آر [0] میکس_سم = فلوٹ ('-انف') جبکہ اختتام <لین (آر آر): اگر کرر_سم == ٹارگٹ_سم: زیادہ سے زیادہ_سم = زیادہ سے زیادہ (زیادہ سے زیادہ_سم ، کرور_سم) کری_سم -= آر آر [شروع] شروع کریں += 1 الیف کرور_سم <ٹارگٹ_سم: اختتام += 1 اگر اختتام <لین (اے آر آر): کریری_سم += آرک [اینڈ] دوسری: کرن_سم -= arr [start] شروع کریں += 1 میکس_سم کی واپسی اگر زیادہ سے زیادہ_سم! = فلوٹ ('-انف') دوسری نیتھیس پروگرام ایک فنکشن میکس_سوم_سوبری () کی وضاحت کرتا ہے جو مثبت انٹیجرز آر آر کی فہرست لیتا ہے اور ان پٹ کے طور پر ٹارگٹ سم ٹارگٹ_سم کی فہرست لیتا ہے ، اور واپس کرتا ہے۔فہرست میں ہدف کی رقم کے ساتھ غیر خالی سبری کی زیادہ سے زیادہ رقم۔یہ پہلے فہرست کے پہلے عنصر کی شروعات اور اختتامی پوائنٹرز ، پہلے عنصر کی قدر کے لئے CURR_SUM متغیر ، اور میکس_سم متغیر کو منفی انفینٹی کا آغاز کرتا ہے۔اس کے بعد موجودہ عنصر کی قیمت کو کرر_سم میں شامل کرتے ہوئے ، فہرست میں تکرار کرتا ہے۔اگر کرر_سم ہدف کے رقم کے برابر ہے ، تو یہ موجودہ رقم کی زیادہ سے زیادہ اور اب تک دیکھنے میں آنے والی زیادہ سے زیادہ رقم کی زیادہ سے زیادہ رقم کو اپ ڈیٹ کرتا ہے ، اسٹارٹ پوائنٹر میں کریری_سم سے عنصر کی قدر کو گھٹا دیتا ہے ، اور اسٹارٹ میں اضافہ کرتا ہے۔پوائنٹراگر کرر_سم ہدف کے مجموعی سے کم ہے تو ، یہ اختتامی پوائنٹر میں اضافہ کرتا ہے اور نئے سرے کے پوائنٹر میں عنصر کی قدر کو کرر_سم میں شامل کرتا ہے۔اگر کرر_سم ہدف کے خلا سے زیادہ ہے تو ، یہ اسٹارٹ پوائنٹر میں کرر_سم سے عنصر کی قدر کو گھٹا دیتا ہے ، اور اسٹارٹ پوائنٹر میں اضافہ کرتا ہے۔یہ اس عمل کو دہراتا ہے جب تک کہ آخری پوائنٹر فہرست کے اختتام تک نہ پہنچ جائے۔اگر یہ منفی انفینٹی نہیں ہے تو اب تک دیکھا جانے والا زیادہ سے زیادہ رقم واپس کردیتا ہے ، اور کوئی بھی نہیں۔ اس فنکشن کی مثال کے طور پر استعمال: ازگر = [1 ، 2 ، 3 ، 4 ، 5] ٹارگٹ_سم = 11 میکس_سم = میکس_سم_سوبری (اے آر آر ، ٹارگٹ_سم)پرنٹ (میکس_سم) # آؤٹ پٹ: 10 یہ پروگرام مثبت انٹیجرز آر آر کی فہرست بناتا ہے ، ہدف کا مجموعہ 11 پر طے کرتا ہے ، فہرست کے ساتھ میکس_سم_سوبری () فنکشن کو فون کرتا ہے اور ان پٹ کے طور پر ہدف کا مجموعہ ، اور غیر خالی ہونے کی زیادہ سے زیادہ رقم پرنٹ کرتا ہے۔فہرست میں ہدف کی رقم کے ساتھ سبری۔اس معاملے میں آؤٹ پٹ 10 ہے"
    },
    {
        "Question": "ایک فنکشن کو نافذ کریں تاکہ کم سے کم حرفوں کی کم سے کم تعداد کو تلاش کیا جاسکے تاکہ اس کو ایک پیلنڈرووم بنایا جاسکے۔",
        "Answer": "اس کو ایک پیلنڈرووم بنانے کے ل a کسی تار میں شامل کرنے کے لئے کم سے کم حرفوں کی تلاش کے ل we ، ہم ایک متحرک پروگرامنگ نقطہ نظر کا استعمال کرسکتے ہیں جس میں تار کی سب سے لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی تعداد کو تلاش کرنے کے ل we ، ہم ایک متحرک پروگرامنگ نقطہ نظر استعمال کرسکتے ہیں۔ہم ایک بار بار چلنے والے فنکشن ایل پی ایس () کی وضاحت کرسکتے ہیں جو ان پٹ کے طور پر تار لیتا ہے اور تار کے سب سے طویل پیلنڈرومک متضاد کی لمبائی کو لوٹاتا ہے۔تار کے سب سے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے.پہلے اور آخری کردار ایک جیسے ہیں ، اور 0 دوسری صورت میں۔اس کے بعد ہم اس فنکشن کو ان پٹ سٹرنگ کے ساتھ کال کرسکتے ہیں ، اور اس کی لمبائی کو ان پٹ سٹرنگ کی لمبائی سے گھٹا سکتے ہیں تاکہ اس کو ایک پیلنڈرووم بنانے کے ل string اسٹرنگ میں کم سے کم تعداد کو شامل کیا جاسکے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف من_چارس_ٹو_پالندرووم (ایس): ڈیف ایل پی ایس (ایس ، آئی ، جے ، میمو): اگر i> j: واپس 0 اگر i == j: واپس 1 (i ، j) in inمیمو: ریٹرن میمو [(i ، j)] اگر s [i] == s [j]: میمو [(i ، j)] = lps (s ، i + 1 ، J-1 ، میمو) + 2 اور:میمو [(i ، j)] = زیادہ سے زیادہ (lps (s ، i+1 ، j ، میمو) ، ایل پی ایس (ایس ، i ، j-1 ، میمو)) ریٹرن میمو [(i ، j)] واپسی لین (s) - ایل پی ایس (ایس ، 0 ، لین (ایس) -1 ، {}) اس پروگرام میں ایک فنکشن من_چارس_ٹو_پالینڈوم () کی وضاحت کی گئی ہے جو اسٹرنگ کو ان پٹ کے طور پر لیتا ہے اور اس کو ایک بنانے کے لئے کم سے کم حرفوں کی تعداد کو واپس کرتا ہے۔پالندرووم۔یہ سب سے پہلے ایک مددگار فنکشن ایل پی ایس () کی وضاحت کرتا ہے جس میں ایک تار s ، دو اشارے I اور J ، اور ایک لغت میمو ہوتا ہے جس کی لمبائی سب سے طویل palindromic string s [i: j+1] کی لمبائی کو محفوظ کرتی ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا اشاریے حد سے باہر ہیں ، ایسی صورت میں یہ 0 یا 1 لوٹتا ہے جس کی لمبائی کی لمبائی کے مطابق ہوتا ہے۔اس کے بعد یہ جانچ پڑتال کرتا ہے کہ اگر سب سے طویل پیلنڈرومک کی لمبائی پہلے ہی میمو میں ہے ، اور اگر ایسا ہے تو اسے لوٹاتا ہے۔اگر سٹرنگ کے پہلے اور آخری حروف ایک جیسے ہیں تو ، یہ پہلی اور آخری حروف کے بغیر ٹی آر ایس کے ساتھ ایل پی ایس () کو بار بار کال کرتا ہے ، اور اس کے نتیجے میں 2 کا اضافہ کرتا ہے۔بصورت دیگر ، یہ بار بار ایل پی ایس () کو پہلے کردار کے بغیر اسٹرنگ کے ساتھ ، اور آخری کردار کے بغیر اسٹرنگ کے ساتھ کال کرتا ہے ، اور دونوں نتائج میں سے زیادہ سے زیادہ واپس کرتا ہے۔اس کا نتیجہ میمو کو واپس کرنے سے پہلے اسٹور کرتا ہے۔MIN_CHARS_TO_PALINDROME () فنکشن ان پٹ سٹرنگ کے ساتھ LPS () فنکشن کو کال کرتا ہے ، اور اس کی لمبائی کو ان پٹ سٹرنگ کی لمبائی سے گھٹا دیتا ہے تاکہ کم سے کم حرفوں کی کم سے کم تعداد کو تار میں شامل کیا جاسکے۔فنکشن کا: ازگر = \"آبائی\" من_چارس = Min_chars_to_palindrome (s) پرنٹ (MIN_CHARS) # آؤٹ پٹ: 2 اس پروگرام میں ایک سٹرنگ ایس تخلیق ہوتا ہے ، ان پٹ کے طور پر تار کے ساتھ من_چارس_ٹو_پالنڈرووم () فنکشن کو کال کرتا ہے ، اور اس کے کم سے کم تعداد میں حروف کی کم سے کم تعداد کو پرنٹ کرتا ہے۔اس کو ایک پالندرووم بنانے کے لئے تار میں شامل کیا گیا۔اس معاملے میں آؤٹ پٹ 2 ہے"
    },
    {
        "Question": "بائنری ٹری کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور بائنری نمبر داخل کرنے اور تلاش کرنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو بائنری ٹری کی نمائندگی کرتی ہے اور بائنری نمبروں کو داخل کرنے اور اس کی تلاش کے ل methods عمل کے طریقوں کو وسائل 1 اور پر مبنی: پائیٹونکلاس بائنری ٹرینائڈ: ڈیف __init __ (خود): سیلف.چولین = [کوئی بھی نہیں ، کوئی بھی نہیں] کلاس بائنری ٹری: ڈیف __init __ (خود).[بٹ]: کرنٹ۔ بچوں [بٹ] = بائنری ٹریئنوڈ () موجودہ = کرنٹ۔ چلڈرن [بٹ] ڈیف سرچ (خود ، نمبر): موجودہ = خود۔= (num >> i) اور 1 اگر موجودہ نہیں ہے۔ بچوں [بٹ]: غلط موجودہ = موجودہ۔ بچوں کو واپس کریں۔بائنری ٹری اور بائنری نمبروں کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کرتا ہے۔بائنری ٹریئنوڈ کلاس میں ایک وصف بچے ہیں جو دو عناصر کی فہرست ہے ، جو نوڈ کے بائیں اور دائیں بچوں کی نمائندگی کرتا ہے۔بائنری ٹری کلاس میں ایک وصف کی جڑ ہے جو ایک بائنری ٹرینائڈ ہے جو ٹری کی جڑ کی نمائندگی کرتی ہے۔بائنری ٹری کلاس دو طریقوں کی وضاحت کرتی ہے: ٹرائی میں بائنری نمبر داخل کرنے کے لئے () داخل کریں ، اور ٹرائی میں بائنری نمبر تلاش کرنے کے لئے تلاش کریں ()۔داخل () کا طریقہ ان پٹ کے طور پر بائنری نمبر نمبر لیتا ہے ، اور بائیں سے دائیں تک اس کے بٹس پر تکرار کرتا ہے۔یہ چیک کرتا ہے کہ آیا موجودہ بٹ پہلے ہی موجودہ نوڈ کا بچہ ہے ، اور اگر ایسا نہیں ہے تو نیا بچہ نوڈ بناتا ہے۔اس کے بعد یہ موجودہ بٹ کے مطابق بچے کے نوڈ میں منتقل ہوتا ہے۔تلاش () کا طریقہ ان پٹ کے طور پر بائنری نمبر نمبر لیتا ہے ، اور بائیں سے دائیں تک اس کے بٹس پر تکرار کرتا ہے۔یہ جانچ پڑتال کرتا ہے کہ آیا موجودہ بٹ موجودہ نوڈ کا بچہ ہے ، اور اگر یہ ہے تو موجودہ بٹ کے مطابق بچے کے نوڈ کی طرف جاتا ہے۔اگر بائنری نمبر کا اختتام پہنچ گیا ہے اور حتمی نوڈ کوئی نہیں ہے تو ، طریقہ درست واپس آجاتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ بائنری نمبر ٹرائی میں ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ کلاس کا ایک مثال استعمال ہے: پائیتھونٹری = بائنری ٹری () ٹری۔ انرٹ (0b1010) ٹری۔ انرٹ (0b1101) ٹری.سرٹ (0B1111) پرنٹ (ٹری۔ تلاش (0b1010)) # آؤٹ پٹ: سچے پرنٹ.پہلی تلاش کے لئے آؤٹ پٹ درست ہے اور دوسری تلاش کے لئے غلط ہے۔"
    },
    {
        "Question": "تار کی فہرست میں سب سے طویل عام پریفکس تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "تار کی فہرست میں سب سے طویل عام پریفکس تلاش کرنے کے ل several ، بہت سارے نقطہ نظر ہیں جو ہم استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ فہرست میں ڈور کے کرداروں کا ایک ایک کرکے اس وقت تک موازنہ کیا جائے جب تک کہ کوئی مماثلت نہ ہو۔ایک اور نقطہ نظر میں مشترکہ سابقہ نکالنے کے لئے بلٹ ان زپ () فنکشن اور سٹرنگ سلائسنگ کا استعمال شامل ہے۔ایک تیسرا نقطہ نظر یہ ہے کہ تاروں کی فہرست کو ترتیب دیں اور ترتیب شدہ فہرست کے پہلے اور آخری تار کا مشترکہ سابقہ تلاش کریں۔یہاں کچھ وسائل ہیں جو ان طریقوں کی مزید معلومات اور مثالیں فراہم کرتے ہیں: حروف کا موازنہ: 123 زپ () اور سٹرنگ سلائسنگ: 4 ترتیب: 56 اس کی مثال ازگر میں حروف کے نقطہ نظر کی موازنہ کی ایک مثال کے طور پر عمل درآمد: پائیٹھنڈف طویل ترین_کومون_پریفکس (ایس ٹی آر ایس): اگر ایس ٹی آر نہیں ہے تو: اگر نہیں ہے: اگر نہیں تو:رینج (لین (strs [0])) کے لئے \"\" واپس کریں: رینج میں جے کے لئے (1 ، لین (ایس ٹی آر ایس)): اگر i> = لین (strs [j]) یا strs [j] [i]!= strs [0] [i]: واپسی strs [0] [: i] واپسی strs [0] یہ پروگرام ایک طویل عرصے سے ایک فنکشن کی وضاحت کرتا ہے جس میں طویل ترین_کومون_پریفکس () ہوتا ہے جو اسٹرنگ ایس ٹی آر کی فہرست کو ان پٹ کے طور پر لیتا ہے اور تار کے درمیان سب سے طویل عام سابقہ واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست خالی ہے ، اور اگر یہ خالی تار واپس کرتا ہے۔اس کے بعد یہ فہرست میں پہلے تار کے کرداروں پر تکرار کرتا ہے ، اور ہر کردار کا موازنہ فہرست میں موجود دوسرے تار میں اسی کردار سے کرتا ہے۔اگر کوئی مماثلت پائی جاتی ہے تو ، یہ اس وقت تک کا سابقہ واپس کرتا ہے۔اگر کوئی مماثلت نہیں ملتی ہے تو ، یہ پوری پہلی تار کو لوٹاتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہوتا ہے: پائیتھنسٹرنس = [\"پھول\" ، \"فلو\" ، \"فلائٹ\"] پریفکس = طویل ترین_کومون_پریفکس (ایس ٹی آر ایس) پرنٹ (سابقہ) # آؤٹ پٹ: \"ایف ایل \"یہ پروگرام اسٹرنگز ایس ٹی آر کی ایک فہرست تیار کرتا ہے ، فہرست کے ساتھ طویل ترین_کومون_پریفکس () فنکشن کو ان پٹ کے طور پر کال کرتا ہے ، اور ڈوروں میں سب سے طویل عام سابقہ پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ \"FL\" ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا بائنری نمائندگی میں دیئے گئے نمبر ایک پالندرووم ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا بائنری نمائندگی میں دیئے گئے نمبر ایک پالندرووم ہے ، ہم ایک دو نقطہ نظر استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ نمبر کو اس کی بائنری نمائندگی میں تبدیل کیا جائے ، بائنری نمائندگی کو الٹا کریں ، اور اس کا موازنہ اصل بائنری نمائندگی سے کریں۔ایک اور نقطہ نظر یہ ہے کہ نمبر کے ٹکڑوں کو بائیں سے دائیں سے دائیں سے بائیں سے دائیں سے بائیں تک موازنہ کیا جائے جب تک کہ کوئی مماثلت نہ ہو۔یہاں کچھ وسائل ہیں جو ان طریقوں کی مزید معلومات اور مثالیں فراہم کرتے ہیں: بائنری میں تبدیل ہونا اور الٹ جانا: 1234 کامپرینگ بٹس: 56 اس کی مثال ازگر میں بائنری اور ریورسنگ نقطہ نظر میں تبدیل ہونے کی ایک مثال ہے: پائیتھنڈف آئی ایس_بائنری_پالینڈوم (نمبر): بائنری = بن (نمبر)[2:] بائنری == بائنری [::-1] واپس لوٹائیں اس پروگرام میں ایک فنکشن کی وضاحت کی گئی ہے جو IS_BINARY_PALINDROME () ہے جو ان پٹ کے طور پر ایک نمبر نمبر لیتا ہے اور اگر اس تعداد کی بائنری نمائندگی ایک پیلینڈرووم ہے ، اور غلط ہے۔یہ سب سے پہلے بلٹ ان بن () فنکشن کا استعمال کرتے ہوئے اس کی ثنائی نمائندگی میں تبدیل کرتا ہے ، اور بائنری تار حاصل کرنے کے لئے پہلے دو حرف (\"0b\") سے ٹکرا جاتا ہے۔اس کے بعد یہ بائنری تار کا موازنہ سٹرنگ سلائسنگ کا استعمال کرتے ہوئے اس کے الٹ سے کرتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پائیتھونوم 1 = 9num2 = 10 پرنٹ (is_binary_palindrome (Num1)) # آؤٹ پٹ: ٹروپنٹ (IS_BINARY_PALINDROME (Num2)) # آؤٹ پٹ: فالسیتھ پروگرام دو نمبر تخلیق کرتا ہےNUM1 اور NUM2 ، IS_BINARY_PALINDROME () کو ہر نمبر کے ساتھ ان پٹ کے بطور فنکشن کہتے ہیں ، اور اس کا نتیجہ پرنٹ کرتا ہے۔آؤٹ پٹ NUM1 کے لئے درست ہے اور NUM2 کے لئے غلط ہے۔ دوسرا نقطہ نظر بائیں سے دائیں سے دائیں سے بائیں سے دائیں سے بائیں تک کے ٹکڑوں کا موازنہ کرنا ہے جب تک کہ کوئی مماثلت نہیں مل جاتی ہے۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھنڈف آئی ایس_بائنری_پالنڈرووم (نمبر): بائیں = 31 دائیں = 0 جبکہ بائیں> دائیں: اگر (نمبر >> بائیں) اور 1! = (نمبر >> دائیں) اور 1: غلط بائیں واپس-= 1 دائیں += 1 ریٹرن ٹروتیس پروگرام ایک فنکشن کی وضاحت کرتا ہے۔یہ دو پوائنٹرز کو بالترتیب بالترتیب بائیں اور دائیں بائیں اور دائیں بٹس تک شروع کرتا ہے۔اس کے بعد یہ بائیں سے دائیں اور دائیں سے بائیں نمبر کے ٹکڑوں پر تکرار کرتا ہے ، جب تک کہ ہر جوڑے کے بٹس کا موازنہ اس وقت تک ہوتا ہے جب تک کہ کوئی مماثلت نہ ہوجائے یا پوائنٹرز کو پار نہ کریں۔اگر کوئی مماثلت پائی جاتی ہے تو ، یہ غلط لوٹتا ہے۔اگر پوائنٹرز بغیر کسی مماثلت کے عبور کرتے ہیں تو ، یہ حقیقت کو واپس کرتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پائیتھونوم 1 = 9num2 = 10 پرنٹ (is_binary_palindrome (num1)) # آؤٹ پٹ: ٹروپنٹ (is_binary_palindrome (num2)) # آؤٹ پٹ: فالسیتیس پروگرام: فالسیتیس پروگرام تخلیق کرتا ہے۔NUM1 اور NUM2 ، IS_BINARY_PALINDROME () کو ہر نمبر کے ساتھ ان پٹ کے بطور فنکشن کہتے ہیں ، اور اس کا نتیجہ پرنٹ کرتا ہے۔NUM1 کے لئے آؤٹ پٹ درست ہے اور NUM2.1stackoverflow2tutorialsPoint3geEKSFORGEEKS4GEEKSFORGEEKS5TECHEIDELIGHTICATIVE کے لئے غلط"
    },
    {
        "Question": "دیئے گئے بائنری صف میں 0s اور 1s کی برابر تعداد کے ساتھ طویل ترین بڑھتی ہوئی سبری کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دیئے گئے بائنری سرنی میں 0s اور 1s کی برابر تعداد کے ساتھ سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے ل we ، ہم اسی طرح کا نقطہ نظر استعمال کرسکتے ہیں جیسے 0 اور 1s کا سب سے بڑا سبری تلاش کریں۔ہم پہلے بائنری صف کو 1s اور -1s کی صف میں تبدیل کرسکتے ہیں ، جہاں 1 بائنری صف میں 1 کی نمائندگی کرتا ہے اور -1 بائنری صف میں 0 کی نمائندگی کرتا ہے۔اس کے بعد ہم 1s اور -1s کی صف میں 0 کی رقم کے ساتھ سب سے طویل عرصے سے متنازعہ سبری کو تلاش کرسکتے ہیں جس میں 0 اور 1s کا سب سے بڑا سب اریے تلاش کرنے کے طور پر اسی نقطہ نظر کا استعمال کیا جاتا ہے۔اس کے بعد ہم بائنری صف میں 1s اور -1s کے سبری کو واپس 0s اور 1s کے سبیرے میں تبدیل کرسکتے ہیں۔یہاں ازگر میں اس نقطہ نظر کا ایک مثال عمل ہے: پائیتھونڈف طویل ترین_انکریزنگ_سوبری (اے آر آر): رینج (لین (آر آر)) کے لئے: اگر آر آر [i] == 0: arr [i] = -1 پریفکس_سم = 0 sum_dict = {0: -1} میکس_لن = 0 اسٹارٹ = -1 اینڈ = -1 کے لئے I (لین (ARR)) کے لئے (LEN (ARR)): precix_sum += arr [i] اگر SUM_DICT میں پریفکس_سم: اگر i -sum_dict [prefix_sum]> میکس_لین: میکس_لین =i - sum_dict [prefix_sum] start = sum_dict [prefix_sum] end = i else: sum_dict [prefix_sum] = i range in range (start ، end+1): اگر arr [i] == -1: arr [i] =0 ریٹرن آر آر [اسٹارٹ: اختتام+1] یہ پروگرام ایک طویل عرصے سے ایک فنکشن کی وضاحت کرتا ہے۔یہ پہلے بائنری صف کو 1s اور -1s کی صف میں تبدیل کرتا ہے ، جہاں 1 بائنری صف میں 1 کی نمائندگی کرتا ہے اور -1 بائنری صف میں 0 کی نمائندگی کرتا ہے۔اس کے بعد یہ ایک سابقہ رقم کو 0 ، ایک لغت SUM_DICT کے لئے ابتدائی طور پر شروع کرتا ہے اور اس سے متعلقہ اشاریہ کو اسٹور کرنے کے لئے ایک لغت SUM_DICT ، اب تک نظر آنے والی زیادہ سے زیادہ لمبائی کو ذخیرہ کرنے کے لئے ایک متغیر میکس_لن ، اور دو متغیر شروع اور ختم ہونے کے ل start شروع اور اختتام کو شروع کرتے ہیں۔سبری اب تک دیکھا ہے۔اس کے بعد یہ 1s اور -1s کی صف پر تکرار کرتا ہے ، ہر عنصر کو سابقہ رقم میں شامل کرتا ہے اور جانچ پڑتال کرتا ہے کہ آیا پہلے سے ہی لغت میں موجود ہے۔اگر پریفکس کا مجموعہ لغت میں ہے تو ، یہ اب تک نظر آنے والی زیادہ سے زیادہ لمبائی اور اب تک دیکھا جانے والا سب سے طویل سبری کے آغاز اور اختتامی اشاریوں کو اپ ڈیٹ کرتا ہے اگر موجودہ سبیرے پچھلے لمبے لمبے سبری سے لمبا ہے۔اگر سابقہ رقم لغت میں نہیں ہے تو ، اس میں لغت میں سابقہ رقم اور اس سے متعلقہ اشاریہ شامل کیا جاتا ہے۔اس کے بعد یہ بائنری صف کے اوپر شروع ہوتا ہے اسٹارٹ انڈیکس سے اب تک دیکھا جانے والا سب سے طویل سبری کے اختتام انڈیکس تک ، ہر -1 کو 0 میں تبدیل کرتا ہے۔فنکشن کی ایک مثال کے طور پر استعمال: ازگر = [1 ، 0 ، 1 ، 0 ، 1 ، 1 ، 1 ، 0 ، 1 ، 0] subarray = سب سے طویل_increasing_subarray (arr) پرنٹ (سبری) # آؤٹ پٹ: [1 ، 0 ، 1، 0 ، 1 ، 1] یہ پروگرام ایک بائنری سرنی آر آر تشکیل دیتا ہے ، ان پٹ کے طور پر صف کے ساتھ سب سے طویل_increasing_subarray () فنکشن کو کال کرتا ہے ، اور بائنری صف میں 0s اور 1s کی برابر تعداد کے ساتھ طویل ترین بڑھتی ہوئی سبری کو پرنٹ کرتا ہے۔آؤٹ پٹ IS101011IN اس معاملے میں"
    },
    {
        "Question": "سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور کسی مخصوص تعداد میں پوزیشنوں کے ذریعہ قطار کو گھومنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو سرکلر قطار کی نمائندگی کرتی ہے اور وسائل 1،2 ، اور 3: پیتھونکلاس سرکلر کیوئو: ڈیف __init __ (خود ، کے): سیلف کے K = K سیلف پر مبنی پوزیشنوں کی ایک مخصوص تعداد کے ذریعہ قطار کو گھمانے کے لئے ایک طریقہ کو نافذ کرتی ہے۔قطار = [کوئی نہیں] * k self.head = -1 self.tail = -1 def is_empty (self): خود واپس کریں۔k == self.head def enqueue (self ، x): اگر self.is_empty (): self.head = 0 self.tail = (self.tail + 1) ٪ self.k.k.k.queue [self.tail] =x def dequeue (خود): اگر self.is_empty (): کوئی بھی نہیں x = self.queue [self.head] اگر self.head == self.tail: self.head = -1 self.tail = -1 اور:self.head = (self.head + 1) ٪ self.k ریٹرن x Def rotate (self ، n): in in range (n): x = self.dequeue () self.enqueue (x) یہ پروگرام a کی وضاحت کرتا ہے aکلاس سرکلر کیوئ جو ایک سرکلر قطار کی نمائندگی کرتا ہے اور یہ چیک کرنے کے لئے طریقوں کو نافذ کرتا ہے کہ آیا قطار خالی ہے یا مکمل ہے ، عنصر کو ختم کرنے ، کسی عنصر کو ختم کرنے اور پوزیشنوں کی ایک مخصوص تعداد کے ذریعہ قطار کو گھمانے کے ل .۔سرکلر کیو کلاس میں صف کے عناصر کو ذخیرہ کرنے والی صف کی نمائندگی کرنے والی قطار کے زیادہ سے زیادہ سائز کی نمائندگی کرتی ہے ، قطار میں پہلے عنصر کی اشاریہ کی نمائندگی کرنے والی سر ، اور قطار میں آخری عنصر کے انڈیکس کی نمائندگی کرنے والی دم۔اگر قطار خالی اور غلط ہے تو IS_EMPTY () کا طریقہ درست لوٹتا ہے۔اگر قطار بھری اور غلط ہے تو آئی ایس_فل () کا طریقہ درست لوٹتا ہے۔enqueue () کا طریقہ ایک عنصر x کو ان پٹ کے طور پر لیتا ہے اور اسے قطار کے آخر میں شامل کرتا ہے۔ڈی کیو () کا طریقہ قطار میں پہلا عنصر ہٹاتا ہے اور واپس کرتا ہے۔گھومنے والا () طریقہ ان پٹ کے طور پر ایک عدد N لیتا ہے اور قطار کو N پوزیشنوں کے ذریعہ دائیں طرف گھماتا ہے۔یہ قطار کے پہلے عنصر کو ختم کرنے اور قطار کے اختتام پر اس کی مدد سے کرتا ہے۔ یہاں کلاس کا ایک مثال استعمال ہے: پائیٹونکیو = سرکلر کیو (5) قطار۔ انکیو (1) قطار (2) قطار (2) قطار.enqueue (3) قطار. enqueue (4) قطار. enqueue (5) پرنٹ (قطار.کیو) # آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5] قطار.روٹیٹ (2) پرنٹ (قطار.کیو) #آؤٹ پٹ: [4 ، 5 ، 1 ، 2 ، 3] یہ پروگرام 5 کے زیادہ سے زیادہ سائز کے ساتھ ایک سرکلر کیو آبجیکٹ قطار تیار کرتا ہے ، انکیو () طریقہ کار کا استعمال کرتے ہوئے پانچ عناصر کو قطار میں جوڑتا ہے ، قطار کو پرنٹ کرتا ہے ، قطار کو 2 پوزیشنوں کے ذریعہ گھومتا ہے۔گھومنے () کے طریقہ کار کا استعمال کرتے ہوئے دائیں طرف ، اور دوبارہ قطار کو پرنٹ کرتا ہے۔آؤٹ پٹ IS12435 BEFORE گھومنے اور 35124 کے بعد گردش"
    },
    {
        "Question": "دیئے گئے سرکلر صف میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "دیئے گئے سرکلر صف میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے ل we ، ہم کڈانے کے الگورتھم کا ایک ترمیم شدہ ورژن استعمال کرسکتے ہیں۔الگورتھم میں صف میں زیادہ سے زیادہ رقم سبری کو تلاش کرنا شامل ہے ، اور پھر زیادہ سے زیادہ رقم کا سبری ڈھونڈنا جو شروع تک صف کے آخر میں لپیٹتا ہے۔اس کے بعد ہم دونوں سبریوں کا موازنہ کرسکتے ہیں اور دونوں میں سے زیادہ سے زیادہ واپس کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کی مزید معلومات اور مثالیں فراہم کرتے ہیں: لیٹ کوڈ ایڈیٹوریل: 1leetcode مسئلہ: 2 ٹکی ڈیلائٹ: 3 جیکسفورجیکس: 4 میڈیم آرٹیکل: 5 کوڈنگ ننجا: 6 ہیرے کی مثال کے طور پر پائیتھون میں ترمیم شدہ کیڈین کے الگورتھم اپروچ کا ایک مثال: پائتھونڈف میکس_سوم میں اپروچ: پائتھونڈف میکس_سم۔ڈیف کڈانے (اے آر آر): زیادہ سے زیادہ_سم = فلوٹ ('-انف') کرور_سم = 0 نمبر کے لئے آر اے آر آر: کرور_سم = زیادہ سے زیادہ (کرن_سم + نمبر) زیادہ سے زیادہ_سم = زیادہ سے زیادہ (زیادہ سے زیادہ_سم ، کرر_سم) میکس_سم میکس_سم = کڈین (آر آر) سرکلر_سم= رقم (arr) + کڈانے ([-نمبر کے لئے نمبر کے لئے نمبر]) زیادہ سے زیادہ (زیادہ سے زیادہ_سم ، سرکلر_سم) اگر سرکلر_سم! = 0 میکس_سومتس پروگرام ایک فنکشن میکس_سوم_سرکلر_سوبری () کی وضاحت کرتا ہے جو سرکلر سرنی آر آر کو زیادہ سے زیادہ لوٹاتا ہے اور زیادہ سے زیادہ لوٹاتا ہے۔صف میں سومی سبری۔یہ سب سے پہلے ایک مددگار فنکشن کڈنے () کی وضاحت کرتا ہے جو ان پٹ کے طور پر ایک سرنی آر آر لیتا ہے اور کڈانے کے الگورتھم کا استعمال کرتے ہوئے سرے میں زیادہ سے زیادہ رقم واپس کرتا ہے۔اس کے بعد یہ سرے میں زیادہ سے زیادہ رقم سبری حاصل کرنے کے لئے کڈانے () کو ان پٹ سرنی کے ساتھ کال کرتا ہے ، اور زیادہ سے زیادہ رقم سبری کی گنتی کرتا ہے جو صف کے اختتام کے ارد گرد لپیٹتا ہے اور سرنی میں موجود تمام عناصر کا خلاصہ کرکے اور کم سے کم کو گھٹا کرنفی سرنی میں سبری۔اس کے بعد یہ دو سبریوں میں سے زیادہ سے زیادہ لوٹاتا ہے ، جب تک کہ سرکلر کا مجموعہ 0 نہ ہو ، اس صورت میں یہ زیادہ سے زیادہ رقم واپس کردیتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: ازگر = [8 ، -8 ، 9 ، -9 ، 10 ،-11 ، 12] میکس_سم = میکس_سم_سرکلر_سوبری (اے آر آر) پرنٹ (میکس_سم) # آؤٹ پٹ: 22 یہ پروگرام ایک سرکلر سرنی آر آر تشکیل دیتا ہے ، ان پٹ کے طور پر سرنی کے ساتھ میکس_سوم_سرکلر_سبرے () کو کال کرتا ہے ، اور صف میں زیادہ سے زیادہ رقم کے سب کو پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 22 ہے"
    },
    {
        "Question": "\"ایک پروگرام لکھیں تاکہ اوپر سے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک منفرد راستوں کی تعداد تلاش کی جاسکے ، صرف دائیں یا نیچے کی طرف بڑھتا ہے ، جس میں گرڈ میں '1' کی نمائندگی کی جانے والی رکاوٹیں ہیں۔\"",
        "Answer": "گرڈ کے نیچے دائیں کونے سے اوپر کے کونے تک منفرد راستوں کی تعداد تلاش کرنے کے لئے ، گرڈ میں '1' کی نمائندگی کرنے والی رکاوٹوں کے ساتھ ، صرف دائیں یا نیچے کی طرف بڑھتی ہے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم گرڈ کی طرح ایک ہی سائز کے 2D سرنی ڈی پی کی وضاحت کرسکتے ہیں ، جہاں ڈی پی [i] [j] اوپر سے بائیں کونے سے سیل (I ، J) تک منفرد راستوں کی تعداد کی نمائندگی کرتا ہے۔اس کے بعد ہم ڈی پی کی پہلی صف اور پہلے کالم کو 1 سے شروع کرسکتے ہیں اگر متعلقہ خلیوں میں کوئی رکاوٹیں نہ ہوں ، اور 0 دوسری صورت میں۔اس کے بعد ہم ڈی پی کے باقی خلیوں پر تکرار کرسکتے ہیں ، اگر سیل میں کوئی رکاوٹ ہے ، اور ڈی پی [I-1] [j] اور ڈی پی [i] [کے جوڑے میں ، ڈی پی [i] [j] کو 0 میں ترتیب دے سکتے ہیں۔J-1] دوسری صورت میں۔گرڈ کے نیچے دائیں کونے سے اوپر کے کونے سے اوپر کے کونے تک منفرد راستوں کی تعداد اس وقت DP [M-1] [N-1] ہے ، جہاں ایم اور این بالترتیب گرڈ کی قطار اور کالموں کی تعداد ہیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کی مزید معلومات اور مثالیں فراہم کرتے ہیں: گیکسفورجیکس: 1 کوڈفورسس: 2 انٹرویوئٹ: 3 ٹکیفورورڈ: 4leetCode: 5youtube ویڈیو: 6 ہیرے کی مثال کے طور پر پائیتھن میں متحرک پروگرامنگ نقطہ نظر کی ایک مثال ہے: Pythondef منفرد_بسٹیکلز (GRID).رینج میں (1 ، م): اگر گرڈ [i] [0] == 0: dp [i] [0] [0] = dp [i-1] [0] رینج میں جے کے لئے (1 ، این): اگر گرڈ [اگر گرڈ [0] [j] == 0: dp [0] [j] = dp [0] [j-1] i in range (1 ، m) کے لئے: J کے لئے حد (1 ، n): اگر گرڈ [i] [j] == 0: dp [i] [j] = dp [i-1] [j] + dp [i] [j-1] واپسی DP [M-1] [N-1] یہ پروگرام وضاحت کرتا ہےایک فنکشن منفرد_پاتھ_ت_بسٹیکلز () جو ان پٹ کے طور پر گرڈ گرڈ لیتا ہے اور اوپر سے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک منفرد راستوں کی تعداد کو واپس کرتا ہے ، صرف دائیں یا نیچے منتقل ہوتا ہے ، جس میں رکاوٹوں کے ساتھ '1' کی نمائندگی کی جاتی ہے۔گرڈیہ پہلے گرڈ کی قطاروں اور کالموں کی تعداد ، اور اسی سائز کے 2D سرنی ڈی پی کی شروعات کرتا ہے جس میں گرڈ کی طرح منفرد راستوں کی تعداد محفوظ ہوتی ہے۔اس کے بعد اس سے متعلقہ خلیوں میں کوئی رکاوٹیں نہ ہونے کی صورت میں ، ڈی پی کی پہلی صف اور پہلے کالم کو 1 سے شروع کیا جاتا ہے۔اس کے بعد یہ ڈی پی کے باقی خلیوں پر تکرار کرتا ہے ، اگر سیل میں کوئی رکاوٹ ہے ، اور ڈی پی [I-1] [j] اور DP [i] [J کی رقم میں ، DP [i] [j] کو 0 پر ترتیب دیتا ہے۔-1] دوسری صورت میں۔فنکشن DP [M-1] [N-1] کو لوٹاتا ہے ، جو گرڈ کے نیچے دائیں کونے سے اوپر کے کونے سے اوپر کے کونے تک منفرد راستوں کی تعداد کی نمائندگی کرتا ہے۔ اس فنکشن کا ایک مثال استعمال ہے: پائیتھونگگریڈ = [[[[[[0 ، 0 ، 0] ، [0 ، 1 ، 0] ، [0 ، 0 ، 0]] num_paths = منفرد_پاتھس_تھ_بسٹیکلز (گرڈ) پرنٹ (Num_paths) # آؤٹ پٹ: 2 یہ پروگرام ایک گرڈ گرڈ بناتا ہے ، منفرد_پاتھ_ویت_بسٹیکلز () کے ساتھ کام کرتا ہے۔گرڈ ان پٹ کے طور پر ، اور اوپر بائیں کونے سے گرڈ کے نیچے دائیں کونے تک منفرد راستوں کی تعداد پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 2 ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار کو لغت کے الفاظ کے خلائی الگ الگ ترتیب میں تقسیم کیا جاسکتا ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار کو لغت کے الفاظ کے خلائی الگ الگ ترتیب میں تقسیم کیا جاسکتا ہے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ان پٹ سٹرنگ کی طرح لمبائی کے 1D سرنی ڈی پی کی وضاحت کرسکتے ہیں ، جہاں ڈی پی [i] نمائندگی کرتا ہے کہ آیا ان پٹ سٹرنگ میں انڈیکس 0 سے I تک کے سب اسٹرنگ کو لغت کے الفاظ میں تقسیم کیا جاسکتا ہے۔اس کے بعد ہم ڈی پی کو سچ میں شروع کرسکتے ہیں اگر ان پٹ سٹرنگ کا پہلا کردار لغت میں ہے ، اور دوسری صورت میں غلط ہے۔اس کے بعد ہم ان پٹ سٹرنگ کے بقیہ کرداروں پر تکرار کرسکتے ہیں ، اگر ڈی پی [i] کو سچ میں ترتیب دیتے ہیں تو اگر کوئی جے موجود ہے کہ ڈی پی [جے] سچ ہے اور انڈیکس جے+1 سے آئی لغت میں ہے ، اور دوسری صورت میں غلط ہے۔فنکشن DP [-1] لوٹاتا ہے ، جو اس کی نمائندگی کرتا ہے کہ آیا پورے ان پٹ سٹرنگ کو لغت کے الفاظ میں تقسیم کیا جاسکتا ہے۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کی مزید معلومات اور مثالیں فراہم کرتے ہیں: ایجوکیٹو.یو: 1 ٹکی ڈیلائٹ: 2 گیکسفورجیکس: 3 سکلر: 4leetcode: 5Interviewibit: 6 ہیرے کی ایک مثال کے طور پر ازگر میں متحرک پروگرامنگ نقطہ نظر کا نفاذ: پائیتھنڈف کین_سیشن_سٹرینگ (ایس ، لوٹیشنری): این ایس ، لغت)= لین (s) dp = [غلط] * n اگر s [0] لغت میں: dp [0] = in in range (1 ، n) کے لئے سچ ہے: اگر s [: i+1] لغت میں: dp [i [i] = سچ J J میں جاری رکھیں (i): اگر dp [j] اور s [j+1: i+1] لغت میں: dp [i] = سچ بریک ریٹرن DP [-1] یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے۔() اس میں تار اور لغت کے الفاظ لغت کا ایک مجموعہ لیتا ہے اور ان پٹ کے طور پر لوٹ آتا ہے اور اگر ان پٹ سٹرنگ کو لغت کے الفاظ میں مکمل طور پر تقسیم کیا جاسکتا ہے ، اور دوسری صورت میں غلط ہے۔یہ سب سے پہلے ان پٹ سٹرنگ کی لمبائی اور اسی لمبائی کے 1D سرنی ڈی پی کو شروع کرتا ہے جس میں ان پٹ سٹرنگ کو اسٹور کرنے کے لئے اسٹور کیا جاسکتا ہے کہ آیا ہر سٹرنگ کو لغت کے الفاظ میں تقسیم کیا جاسکتا ہے۔اس کے بعد اگر ان پٹ سٹرنگ کا پہلا کردار لغت میں ہے ، اور دوسری صورت میں غلط ہے۔اس کے بعد یہ ان پٹ سٹرنگ کے باقی کرداروں پر تکرار کرتا ہے ، اگر ڈی پی [i] کو سچ میں ترتیب دیتا ہے تو اگر کوئی جے موجود ہے کہ ڈی پی [جے] سچ ہے اور انڈیکس جے+1 سے آئی لغت میں ہے ، اور دوسری صورت میں غلط ہے۔فنکشن ڈی پی [-1] لوٹاتا ہے ، جو اس بات کی نمائندگی کرتا ہے کہ آیا پورے ان پٹ سٹرنگ کو لغت کے الفاظ میں تقسیم کیا جاسکتا ہے۔ یہاں فنکشن کی ایک مثال استعمال ہے: ازگر = \"ایپلپینپل\" لغت = {\"ایپل\" ، \"قلم\"} can_segment = can_segment_string.لغت کے الفاظ میں۔اس معاملے میں آؤٹ پٹ درست ہے"
    },
    {
        "Question": "کسی دیئے گئے لغت میں سب سے طویل لفظ تلاش کرنے کے لئے ایک پروگرام لکھیں جو کسی دیئے گئے تار سے حروف کو حذف کرکے تعمیر کیا جاسکتا ہے۔",
        "Answer": "کسی دیئے گئے لغت میں سب سے طویل لفظ تلاش کرنے کے لئے جو کسی دیئے گئے تار سے حروف کو حذف کرکے تعمیر کیا جاسکتا ہے ، ہم لغت میں ہر لفظ پر تکرار کرسکتے ہیں اور چیک کرسکتے ہیں کہ آیا یہ دیئے گئے تار سے حروف کو حذف کرکے تشکیل دے سکتا ہے۔ہم لفظ کے کرداروں اور دیئے گئے تار کے متوازی کرداروں پر تکرار کرکے ، اور دیئے گئے اسٹرنگ کے اشاریہ کو صرف اس صورت میں پیش کر سکتے ہیں جب لفظ کا موجودہ کردار دیئے گئے تار کے موجودہ کردار سے مماثل ہو۔اگر ہم لفظ کے اختتام پر پہنچ جاتے ہیں تو ، ہم جانتے ہیں کہ دیئے گئے تار سے حروف کو حذف کرکے یہ لفظ تشکیل دیا جاسکتا ہے ، اور ہم اب تک دکھائے جانے والے لمبے لمبے لفظ کو اپ ڈیٹ کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کی مزید معلومات اور مثالیں فراہم کرتے ہیں: لیٹ کوڈ: 1 ڈی ای وی کمیونٹی: 2 گیکسفورجیکس: 3 کوڈنگ ننجا: 4 ہیرے کی ایک مثال ازگر میں نقطہ نظر کی ایک مثال: پائیتھنڈف فائنڈ_ لانگسٹ_ورڈ (ایس ، لغت): i ، j = 0 ، 0 جبکہ میں <لین (ورڈ) اور جے <لین (s): اگر لفظ [i] == s [j]: i += 1 j += 1 اگر i == لین (لفظ (لفظ)) اور لین (ورڈ)> لین (سب سے طویل_ ورڈ): طویل ترین_ورڈ = ورڈ ریٹرن سب سے طویل ترین_ ورڈ یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے جس میں ایک سٹرنگ ایس اور الفاظ کی لغت کی فہرست کو ان پٹ کے طور پر لایا جاتا ہے اور لغت میں سب سے طویل لفظ واپس کرتا ہے جس کی تشکیل ہوسکتی ہے۔دیئے گئے تار سے حروف کو حذف کرنا۔یہ سب سے پہلے خالی تار میں اب تک دیکھا جانے والا سب سے طویل لفظ شروع کرتا ہے۔اس کے بعد یہ لغت میں ہر لفظ پر تکرار کرتا ہے ، اور ہر لفظ کے ل it ، یہ دو پوائنٹرز I اور J کو 0 سے شروع کرتا ہے ، جو بالترتیب کلام اور دیئے گئے تار کے موجودہ انڈیکس کی نمائندگی کرتا ہے۔اس کے بعد یہ لفظ کے کرداروں اور دیئے گئے تار کے متوازی طور پر تکرار کرتا ہے ، دیئے گئے تار کے اشاریہ کو صرف اسی صورت میں پیش کرتا ہے جب لفظ کا موجودہ کردار دیئے گئے تار کے موجودہ کردار سے مماثل ہوتا ہے۔اگر یہ لفظ کے اختتام تک پہنچ جاتا ہے تو ، یہ جانتا ہے کہ دیئے گئے تار سے حروف کو حذف کرکے یہ لفظ تشکیل دیا جاسکتا ہے ، اور اگر موجودہ لفظ پچھلے لمبے لمبے لفظ سے لمبا ہے تو اب تک دیکھا جانے والا سب سے طویل لفظ اپ ڈیٹ کرتا ہے۔فنکشن اب تک دیکھا جانے والا سب سے طویل لفظ لوٹتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: ازگر = \"ABPCLEAQ\" لغت = [\"ale\" ، \"ایپل\" ، \"بندر\" ، \"درخواست\"] طویل ترین_ ورڈ = Find_longest_word (s ، لغت)پرنٹ (سب سے طویل_ ورڈ) # آؤٹ پٹ: \"ایپل\" یہ پروگرام سٹرنگ ایس تیار کرتا ہے ، الفاظ کی لغت کی ایک فہرست ، ان پٹ کے طور پر تار اور لغت کے ساتھ Find_longest_word () فنکشن کو کال کرتا ہے ، اور لغت میں سب سے طویل لفظ پرنٹ کرتا ہے جس کے ذریعہ تشکیل دیا جاسکتا ہے۔دیئے گئے تار سے حروف کو حذف کرنا۔اس معاملے میں آؤٹ پٹ \"ایپل\" ہے"
    },
    {
        "Question": "سوڈوکو سولور کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور دیئے گئے سوڈوکو پہیلی کو حل کرنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "بہت سارے وسائل دستیاب ہیں جو مختلف طریقوں کا استعمال کرتے ہوئے ازگر میں سوڈوکو سولور کو نافذ کرنے کی مثالیں فراہم کرتے ہیں۔ان میں سے کچھ یہ ہیں: کوڈ ریویو اسٹیک ایکسچینج: 1 یہ وسائل ازگر میں ایک آبجیکٹ پر مبنی سوڈوکو سولور کی ایک مثال پیش کرتا ہے جو سوڈوکو بورڈ اور فیلڈز کی نمائندگی کے لئے کلاسوں کا استعمال کرتا ہے۔سولور بورڈ کے خالی خلیوں کو پُر کرنے کے لئے بیک ٹریکنگ الگورتھم کا استعمال کرتا ہے۔ گیتھب: 2 یہ وسائل ازگر میں ایک سادہ ، بنیادی سوڈوکو کلاس مہیا کرتا ہے جو 9x9 سوڈوکو بورڈ کے لئے ڈیٹا ڈھانچہ فراہم کرتا ہے اور ایک بنیادی محلول جو بروٹ فورس الگورتھم استعمال کرتا ہے۔بورڈ کے خالی خلیوں کو پُر کرنے کے لئے ۔اسکپیتھون: 3 یہ وسائل ازگر میں سوڈوکو سولور کی ایک مثال پیش کرتا ہے جو بورڈ کے خالی خلیوں کو پُر کرنے کے لئے بیک ٹریکنگ کا طریقہ استعمال کرتا ہے۔حلور ہر خالی سیل کے ل different مختلف اقدار کی کوشش کرنے کے لئے ایک تکرار کرنے والی تقریب کا استعمال کرتا ہے جب تک کہ کوئی حل نہ مل جائے۔ لیئر سینا: 4 یہ وسائل ازگر میں سوڈوکو سولور کی ایک مثال پیش کرتا ہے جو خالی خلیوں کے خالی خلیوں کو بھرنے کے لئے گہرائی کی پہلی تلاش اور رکاوٹ کے پھیلاؤ کا استعمال کرتا ہے۔بورڈ.سولور ہر سیل کے لئے سوڈوکو بورڈ اور امیدواروں کی اقدار کی نمائندگی کرنے کے لئے دو جہتی صف کا استعمال کرتا ہے۔ ٹم کے ساتھ ٹیک: 5 یہ وسائل بیکٹریکنگ الگورتھم کا استعمال کرتے ہوئے ازگر میں سوڈوکو سولور بنانے کا طریقہ فراہم کرتا ہے۔حلور ہر خالی سیل کے ل different مختلف اقدار کو آزمانے کے لئے ایک بار بار چلنے والی تقریب کا استعمال کرتا ہے جب تک کہ کوئی حل نہ مل جائے۔ آپ کو: یہ وسائل ایک ویڈیو ٹیوٹوریل فراہم کرتا ہے کہ بیک ٹریکنگ الگورتھم کا استعمال کرتے ہوئے ازگر میں سوڈوکو سولور بنانے کا طریقہ۔حلور ہر خالی سیل کے ل different مختلف اقدار کی کوشش کرنے کے لئے ایک بار بار چلنے والی تقریب کا استعمال کرتا ہے جب تک کہ کوئی حل نہ مل جائے۔ ان وسائل کی بنیاد پر ، آپ ایک ایسا نقطہ نظر منتخب کرسکتے ہیں جو آپ کی ضروریات کے مطابق ہو اور سوڈوکو سولور کو ازگر میں لاگو کیا جاسکے۔"
    },
    {
        "Question": "کسی مخصوص عدد کی فہرست سے K الگ الگ عدد کے تمام ممکنہ امتزاج پیدا کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یہاں تک کہ ایک فنکشن کا ایک مثال ہے جس میں K الگ الگ عدد کے تمام ممکنہ امتزاج کو پیدا کرنے کے لئے ایک بار بار بار پیش آنے والے نقطہ نظر کا استعمال کرتے ہوئے ازگر میں عدد کی فہرست سے تمام ممکنہ امتزاج پیدا کیا جاسکتا ہے: پائیتھنڈف کے امتزاج (اے آر آر ، کے): ڈیف بیک ٹریک (اسٹارٹ ، کرور): اگر لین (کرر)== K: آؤٹ پٹ.ایپینڈ (کرر [:]) رینج (اسٹارٹ ، لین (اے آر آر)) کے لئے واپسی: کریری.اپی اینڈ (آر آر [آئی]) بیک ٹریک (i+1 ، کرور) کرور.پپ () آؤٹ پٹ= [] بیک ٹریک (0 ، []) ریٹرن آؤٹ پٹ یہ پروگرام ایک فنکشن کے امتزاج () کی وضاحت کرتا ہے جو ان پٹ کے طور پر انٹیجر آر آر اور ایک انٹیجر کے کی فہرست لیتا ہے اور فہرست سے K الگ الگ عدد کے ہر ممکنہ امتزاج کی فہرست واپس کرتا ہے۔یہ پہلے ایک ہیلپر فنکشن بیک ٹریک () کی وضاحت کرتا ہے جو ابتدائی انڈیکس اسٹارٹ اور موجودہ مجموعہ CURR کے طور پر ان پٹ لیتا ہے اور موجودہ امتزاج سے شروع ہونے والے K الگ الگ عدد کے تمام ممکنہ امتزاج پیدا کرتا ہے۔یہ شروعاتی اشاریہ سے شروع ہونے والے ان پٹ لسٹ کے باقی عناصر پر تکرار کرکے ، ہر عنصر کو موجودہ امتزاج میں شامل کرتے ہوئے ، اگلے شروع ہونے والے انڈیکس اور تازہ ترین موجودہ امتزاج کے ساتھ بیک ٹریک () کو بار بار کال کریں ، اور آخری عنصر کو رن سے ہٹاتے ہیں۔موجودہ امتزاجاگر موجودہ امتزاج کی لمبائی K کے برابر ہے تو ، یہ موجودہ مجموعہ کو آؤٹ پٹ لسٹ میں شامل کرتا ہے۔اس کے بعد فنکشن ایک خالی آؤٹ پٹ لسٹ کی ابتدا کرتا ہے ، بیک ٹریک () کو 0 کے ابتدائی انڈیکس اور ایک خالی موجودہ امتزاج کے ساتھ کال کرتا ہے ، اور آؤٹ پٹ لسٹ کو واپس کرتا ہے۔ اس فنکشن کی مثال کے طور پر استعمال: ازگر = [1 ، 2 ، 3 ، 4]k = 2combs = امتزاج (arr ، k) پرنٹ (کنگس) # آؤٹ پٹ: [[1 ، 2] ، [1 ، 3] ، [1 ، 4] ، [2 ، 3] ، [2 ، 4] ، [3، 4]] یہ پروگرام انٹیجرز آر آر کی فہرست تیار کرتا ہے ، ایک انٹیجر کے ، فہرست کے ساتھ مل کر کام () کو ان پٹ کے طور پر کال کرتا ہے ، اور فہرست سے K الگ الگ انٹیجرز کے تمام ممکنہ امتزاج کی فہرست کو پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ [12،13،14،23،24،34] ہے"
    },
    {
        "Question": "بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے ل we ، ہم ہسٹوگرام میں سب سے بڑے آئتاکار علاقے کا تصور استعمال کرسکتے ہیں۔ہم بائنری میٹرکس کی ہر قطار کو ہسٹگرام کے طور پر علاج کرسکتے ہیں اور ہر ہسٹگرام میں سب سے بڑے آئتاکار علاقے کا حساب لگاسکتے ہیں۔اس کے بعد ہم تمام ہسٹگراموں میں زیادہ سے زیادہ علاقہ تلاش کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کی مزید معلومات اور مثالیں فراہم کرتے ہیں: ٹیکنڈ لائٹ: 1 کوڈنگ ننجا: 2 گیکسفورجیکس: 3،4،5 جب ازگر میں نقطہ نظر کی ایک مثال کا نفاذ: پائیتھنڈف سب سے بڑے_ریکٹنگل_اریہ (میٹرکس): ڈیف سب سے زیادہ_اریہ_ہسٹگرام (اونچائی): اسٹیک =-1] میکس_یریا = 0 میں رینج (لین (اونچائی)) میں I()] curr_width = i -اسٹیک [-1] -1 میکس_یریا = زیادہ سے زیادہ (میکس_یریا ، کریری_ہائٹ * کری_ وڈتھ) اسٹیک.ایپینڈ (i) جبکہ اسٹیک [-1]! = -1: curr_height = اونچائی [اسٹیک.اپپ () ())] curr_width = len (اونچائی) - اسٹیک [-1] - 1 میکس_یریا = زیادہ سے زیادہ (میکس_یریا ، کریری_ہائٹ * کری_ وڈتھ) رینج (لین (میٹرکس)) میں I کے لئے میکس_یریا میکس_یریہ = 0 کی حد (لین (میٹرکس)): رینج میں جے (میٹرکس [میٹرکس [0])): اگر i> 0 اور میٹرکس [i] [j] == 1: میٹرکس [i] [j] += میٹرکس [i-1] [j] میکس_یریہ = میکس (میکس_یریا ، سب سے بڑا_اریہ_ہسٹگرام (میٹرکس [i])) واپسی MAX_ARETHIS پروگرام ایک فنکشن کی وضاحت کرتا ہے سب سے بڑے_ریکٹنگل_یریا () جو بائنری میٹرکس میٹرکس کو ان پٹ کے طور پر لیتا ہے اور میٹرکس میں 1s کے سب سے بڑے آئتاکار علاقے کو لوٹاتا ہے۔یہ سب سے پہلے ایک مددگار فنکشن سب سے بڑی_اریہ_ہسٹگرام () کی وضاحت کرتا ہے جو اونچائیوں کی اونچائیوں کی فہرست لیتا ہے کیونکہ ان پٹ کے طور پر اور اونچائیوں کے ذریعہ بننے والے ہسٹگرام میں سب سے بڑا آئتاکار علاقہ واپس کرتا ہے۔یہ بڑھتی ہوئی ترتیب میں اونچائیوں کے اشاریوں کو ٹریک رکھنے ، اور موجودہ اونچائی اور اسٹیک میں پچھلی اونچائی کے ذریعہ تشکیل پانے والے ہر مستطیل کے علاقے کا حساب لگانے کے لئے ایک اسٹیک کا استعمال کرکے یہ کام کرتا ہے۔اس کے بعد اب تک دیکھنے میں آنے والے زیادہ سے زیادہ علاقے کو اپ ڈیٹ کرتا ہے۔اس کے بعد یہ فنکشن بائنری میٹرکس کی ہر قطار پر تکرار کرتا ہے ، اور ہر قطار کے ل it ، یہ موجودہ سیل کی قیمت کو اس کے اوپر والے سیل کی قیمت میں شامل کرکے ہر ہسٹوگرام کی اونچائی کا حساب لگاتا ہے اگر موجودہ سیل 1 ہے۔ہسٹگرام کے ساتھ سب سے بڑا_اریہ_ہسٹگرام () ان پٹ کے طور پر اور اب تک دیکھنے میں آنے والے زیادہ سے زیادہ علاقے کو اپ ڈیٹ کرتا ہے۔فنکشن اب تک دیکھا جانے والا زیادہ سے زیادہ رقبہ لوٹاتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پائیتھون میٹرکس = [[[0 ، 1 ، 1 ، 0 ، 1] ، [1 ، 1 ، 1 ، 1 ، 1] ، [1 ، 1 ، [1 ، 1 ،1 ، 1 ، 1] ، [1 ، 1 ، 0 ، 0 ، 1]] میکس_یریا = سب سے بڑا_راٹینگل_اریہ (میٹرکس) پرنٹ (میکس_یریا) # آؤٹ پٹ: 6 یہ پروگرام بائنری میٹرکس میٹرکس تشکیل دیتا ہے ، میٹرکس کے ساتھ سب سے بڑے_Rectangle_area () فنکشن کو کال کرتا ہے۔ان پٹ ، اور میٹرکس میں 1s کے سب سے بڑے آئتاکار علاقے کو پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 6 ہے"
    },
    {
        "Question": "\"2D گرڈ میں الگ الگ جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں جزیروں کی تعریف '1 کے منسلک علاقوں سے ہوتی ہے۔\"",
        "Answer": "2D گرڈ میں الگ الگ جزیروں کی تعداد تلاش کرنے کے لئے ، جہاں جزیروں کی تعریف '1 کے منسلک علاقوں سے کی جاتی ہے ، ہم گہرائی میں پہلی تلاش (DFS) نقطہ نظر استعمال کرسکتے ہیں۔ہم گرڈ کے ہر سیل پر تکرار کرسکتے ہیں ، اور ہر ایک سیل کے لئے جس میں '1' ہوتا ہے ، ہم '1 کے منسلک خطے کو تلاش کرنے کے لئے ایک DFs انجام دے سکتے ہیں اور ایک ہی جزیرے کی گنتی سے بچنے کے لئے' 0 کی حیثیت سے ملاحظہ کرنے والے خلیوں کو نشان زد کرسکتے ہیں۔ہم ہر جزیرے کی شکل کو اس کے خلیوں کے رشتہ دار کوآرڈینیٹ کے ایک سیٹ کے طور پر اسٹور کرسکتے ہیں ، اور تمام وزٹ شدہ جزیروں کی شکلوں کا سیٹ ایک سیٹ میں محفوظ کرسکتے ہیں۔تمام دیکھنے والے جزیروں کی شکلوں کے سیٹ کا سائز گرڈ میں الگ الگ جزیروں کی تعداد ہے۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کی مزید معلومات اور مثالیں فراہم کرتے ہیں: لیٹ کوڈ: 1 لینٹ کوڈ: 2 ٹکیفورورڈ: 3 ٹیوٹورالس پوائنٹ: 4 جی ای ای ایکسفورجیکس: 5 ہیرے میں ازگر میں ڈی ایف ایس نقطہ نظر کا ایک مثال عمل: پائیتھونڈف نمبر_ڈسٹینٹ_ آئی ایس لینڈز (گرڈ): ڈیف ڈی ایف ایس (آئی ، جے ، شکل): اگر 0 <= i <لین (گرڈ) اور 0 <= j <لین (گرڈ [0]) اور گرڈ [i] [j] == 1: گرڈ [i] [j] = 0 شکل۔ add ((I - قطار ، J - COL)) DFS (I+1 ، J ، شکل) DFS (I -1 ، J ، شکل) DFS (I ، J+1 ، شکل) DFS (I ، J -1 ، شکل) شکلیں= سیٹ () رینج میں قطار کے لئے (لین (گرڈ)): رینج میں کرنل کے لئے (لین (گرڈ [0])): اگر گرڈ [قطار] [کرنل] == 1: شکل = سیٹ () ڈی ایف ایس (قطار ،کرنل ، شکل) شکلیں۔ ایڈ (فریوزنسیٹ (شکل)) ریٹرن لین (شکلیں) یہ پروگرام ایک فنکشن NUM_DISTINCT_ISLALDS () کی وضاحت کرتا ہے جو 2D گرڈ گرڈ کو ان پٹ کے طور پر لیتا ہے اور گرڈ میں الگ الگ جزیروں کی تعداد کو واپس کرتا ہے۔یہ پہلے ایک مددگار فنکشن ڈی ایف ایس () کی وضاحت کرتا ہے جو ایک قطار انڈیکس I ، ایک کالم انڈیکس جے ، اور رشتہ دار کوآرڈینیٹ شکل کا ایک سیٹ ان پٹ کے طور پر لیتا ہے اور سیل سے شروع ہونے والے سیل سے شروع ہونے والے خطے کو تلاش کرنے کے لئے ڈی ایف ایس انجام دیتا ہے (I ،جے)۔یہ پڑوسی خلیوں پر بار بار ڈی ایف ایس () کو کال کرنے کے ذریعہ کرتا ہے جس میں '1' ہوتا ہے ، اور ہر ملاحظہ کرنے والے سیل کے رشتہ دار کوآرڈینیٹ کو شکل سیٹ میں شامل کرتے ہیں۔اس کے بعد ایک ہی جزیرے کو متعدد بار گننے سے بچنے کے ل each ہر ملاحظہ کرنے والے سیل کو '0' کے طور پر نشان زد کرتا ہے۔اس کے بعد فنکشن شکلوں کا ایک خالی سیٹ شروع کرتا ہے ، اور گرڈ کے ہر سیل پر تکرار کرتا ہے ، ہر سیل پر ڈی ایف ایس () کو کال کرتا ہے جس میں '1' ہوتا ہے تاکہ '1' کے منسلک خطے کو تلاش کیا جاسکے اور جزیرے کی شکل کو سیٹ میں شامل کیا جاسکے۔شکلوں کیاس کے بعد یہ شکلوں کے سیٹ کے سائز کو لوٹاتا ہے ، جو گرڈ میں الگ الگ جزیروں کی تعداد کی نمائندگی کرتا ہے۔ اس فنکشن کا ایک مثال استعمال ہے: پائیٹنگگریڈ = [[1 ، 1 ، 0 ، 0 ، 0] ، [1 ، 1 ، [1 ، 1 ،0 ، 0 ، 0] ، [0 ، 0 ، 0 ، 1 ، 1] ، [0 ، 0 ، 0 ، 1 ، 1 ، 1]] num_islands = num_distinct_islands (گرڈ) پرنٹ (num_islands) # آؤٹ پٹ: 1 اس پروگرام نے 2D گرڈ تشکیل دیا ہےگرڈ ، Num_distinct_islands () کو گرڈ کے ساتھ ان پٹ کے بطور فنکشن کہتے ہیں ، اور گرڈ میں الگ الگ جزیروں کی تعداد کو پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 1 ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا ملر-ریبین پرائمری ٹیسٹ کا استعمال کرتے ہوئے ایک دیئے گئے نمبر ایک اہم نمبر ہے یا نہیں۔",
        "Answer": "ملر-ریبن پرائمریت ٹیسٹ اس بات کا تعین کرنے کے لئے ایک امکانی الگورتھم ہے کہ آیا کوئی نمبر بنیادی ہے یا جامع۔یہاں کچھ وسائل ہیں جو ازگر میں ملر ریبن پرائملٹی ٹیسٹ کو نافذ کرنے کی معلومات اور مثالیں فراہم کرتے ہیں: لٹریٹ پروگگرام: 1 یہ وسائل کسی تعداد کی کمپوزٹ کو ثابت کرنے کے لئے فارمولوں کا استعمال کرتے ہوئے ازگر میں ملر ریبین پرائمری ٹیسٹ کا نفاذ فراہم کرتا ہے۔عمل درآمد جی سی ڈی کو جانچنے کے لئے استعمال کرتا ہے کہ آیا کوئی نمبر N سے N-1 ہے ، اور N-1 کو 2^D * R کے طور پر لکھتا ہے ، جہاں R عجیب ہے۔اس کے بعد یہ جانچ پڑتال کرتا ہے کہ اگر A^r 1 Mod N یا A^(2^j * r) کے ساتھ مل کر ایک J کے لئے -1 Mod N کے ساتھ ہے [0 ، D -1] .Rosetta کوڈ: 2 یہ وسائل فراہم کرتا ہےویکیپیڈیا سے سیڈوکوڈ کا استعمال کرتے ہوئے ازگر میں ملر ریبین پرائملٹی ٹیسٹ کا نفاذ۔عمل درآمد ایک دیئے گئے تعداد کے لئے ٹیسٹ انجام دینے کے لئے ایک لوپ کا استعمال کرتا ہے ، اور یہ جانچنے کے لئے فرمیٹ کے چھوٹے سے نظریہ کا استعمال کرتا ہے کہ آیا کوئی نمبر N.just کریپٹوگرافی میں شامل ہے یا نہیں۔U اور K کو تلاش کرنے کے فارمولے ، اور ایک دیئے گئے راؤنڈ کی تعداد کے لئے ٹیسٹ انجام دینے کے ل a ایک لوپ کا استعمال۔عمل درآمد کسی نمبر کے ماڈیولر اخراج کا حساب لگانے کے لئے POW () فنکشن کا استعمال کرتا ہے۔ یہاں اور K کو تلاش کرنے کے لئے فارمولوں کا استعمال کرتے ہوئے اور کسی دیئے گئے نمبر کے لئے ٹیسٹ انجام دینے کے ل a ایک لوپ کا استعمال کرتے ہوئے ازگر میں ملر-ریبین پرائمری ٹیسٹ کی مثال کے طور پر عمل درآمدراؤنڈ کے: پائیٹونیمپورٹ رینڈم ڈف ملر_رابین (این ، کے = 10): اگر n <= 3: واپسی n == 2 یا n == 3 اگر n ٪ 2 == 0: غلط u ، k = n - 1 ، 0 واپس لوٹائیںu ٪ 2 == 0: u // = 2 k += 1 _ کے لئے _ میں حد (k): a = بے ترتیب۔ رینڈنٹ (2 ، n - 2) x = pow (a ، u ، n) اگر x ==1 یا x == n - 1: رینج میں _ کے لئے جاری رکھیں (k - 1): x = pow (x ، 2 ، n) اگر x == n - 1: بریک ریٹرن ٹریوئٹیس پروگرام ایک فنکشن کی وضاحت کرتا ہے ملر_رابین() جو ان پٹ کے طور پر ایک انٹیجر این اور ایک انٹیجر K لیتا ہے اور اگر ان پٹ انٹیجر اہم ہے ، اور دوسری صورت میں غلط ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا ان پٹ انٹیجر 3 سے کم یا اس کے برابر ہے ، اور اگر ان پٹ انٹیجر 2 یا 3 ہے تو یہ سچ واپس آجاتا ہے تو پھر یہ چیک کرتا ہے کہ اگر ان پٹ انٹیجر بھی ہے ، اور اگر یہ ہے تو غلط لوٹتا ہے۔اس کے بعد یہ U اور K کی اقدار کو مل جاتا ہے کہ N-1 = 2^K * U ، جہاں آپ عجیب ہے۔اس کے بعد یہ K راؤنڈ کی ایک رینج پر تکرار کرتا ہے ، اور ہر دور کے ل it ، یہ رینج [2 ، N-2] میں بے ترتیب عددی A تیار کرتا ہے ، اور x = a^u mod n کا حساب لگاتا ہے۔اگر X 1 Mod N یا X کے ساتھ مل کر -1 Mod N سے متفق ہے ، تو یہ اگلے دور تک جاری رہتا ہے۔بصورت دیگر ، یہ K-1 مراحل کی ایک رینج پر تکرار کرتا ہے ، اور ہر قدم کے ل it ، یہ x = x^2 Mod n کا حساب لگاتا ہے۔اگر X -1 Mod N کے ساتھ ہے ، تو یہ لوپ سے ٹوٹ جاتا ہے۔اگر یہ X -1 Mod N پر X یکجہتی کے بغیر تمام K -1 اقدامات مکمل کرتا ہے تو ، یہ غلط لوٹتا ہے۔اگر یہ x x mod n کے ساتھ مل کر تمام k راؤنڈ مکمل کرتا ہے تو ، یہ سچ واپس آجاتا ہے۔ یہاں فنکشن کی ایک مثال استعمال ہے: pythonn = 123456789is_prime = ملر_رابین (n) پرنٹ (is_prime) # آؤٹ پٹ: فالستھس پروگرام این انٹیجر این تخلیق کرتا ہے ،ان پٹ کے طور پر انٹیجر کے ساتھ ملر_رابین () فنکشن کو کال کرتا ہے ، اور پرنٹ کرتا ہے کہ آیا انٹیجر پرائم ہے یا نہیں۔اس معاملے میں آؤٹ پٹ غلط ہے۔"
    },
    {
        "Question": "بیل مین فورڈ الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے وزن والے ہدایت والے ایسائکلک گراف کی نمائندگی کرنے والے ایک ازگر کلاس لکھیں اور طریقوں کو نافذ کریں۔",
        "Answer": "بیل مین فورڈ الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے وزن والے ہدایت والے ایسائکلک گراف اور طریقوں کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل اقدامات کا استعمال کرسکتے ہیں: ایک کلاس گراف کی وضاحت کریں جو وزن والے ہدایت والے ایسائکلک گراف کی نمائندگی کرتا ہے۔کلاس کے پاس ایک کنسٹرکٹر ہونا چاہئے جو عمودی کی تعداد اور کناروں کی خالی فہرست کو شروع کرتا ہے۔اس میں ایک طریقہ add_edge () بھی ہونا چاہئے جو گراف میں دو عمودی کے درمیان وزن کے ساتھ ایک ہدایت نامہ شامل کرتا ہے۔ گراف کلاس میں ایک طریقہ مختصر ترین_پاتھ () کی وضاحت کریں جو ان پٹ کے طور پر ایک ماخذ کو لے جاتا ہے اور اس سے مختصر ترین فاصلوں کی فہرست واپس کرتا ہےگراف میں موجود دیگر تمام عمودی حصے میں ماخذ ورٹیکس۔اس طریقہ کار کو ماخذ ورٹیکس کے علاوہ انفینٹی کے طور پر دوروں کی ایک فہرست کا آغاز کرنا چاہئے ، جسے 0 سے شروع کیا جانا چاہئے۔ اس کے بعد گراف V-1 بار کے تمام کناروں پر تکرار کرنی چاہئے ، اگر کوئی چھوٹا ہو تو ہر حد تک فاصلہ اپ ڈیٹ کریں۔راستہ پایا جاتا ہے۔اگر گراف میں کوئی منفی چکر موجود ہے تو ، طریقہ کو کوئی بھی واپس نہیں کرنا چاہئے۔ یہاں کچھ ایسے وسائل ہیں جو ہدایت شدہ ایسائکلک گراف میں مختصر ترین راستہ تلاش کرنے کے لئے بیل مین فورڈ الگورتھم کو نافذ کرنے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: گیکسفورجیکس: 1،2Favtutor:3 سکلر: 4Algotree: 5Techie Delight: 6 ہیرے کی مثال گراف کلاس کا ایک مثال ہے اور ازگر میں مختصر ترین_پاتھ () کا طریقہ: ازگر کلاس گراف: Def __init __ (خود ، عمودی).رینج میں _ کے لئے (خود[v] = ڈسٹ [u] + w کے لئے u ، v ، w ، w ، wase گراف: اگر ڈسٹ [u]! = فلوٹ (\"inf\") اور ڈسٹرڈسٹ یہ پروگرام ایک کلاس گراف کی وضاحت کرتا ہے جو وزن والے ہدایت والے ایسائکلک گراف کی نمائندگی کرتا ہے۔کلاس میں ایک کنسٹرکٹر ہوتا ہے جو ان پٹ کے طور پر عمودی کی تعداد لیتا ہے اور کناروں کی خالی فہرست کو شروع کرتا ہے۔اس میں ایک طریقہ add_edge () بھی ہوتا ہے جو ماخذ کی شکل ، منزل مقصود ، اور ان پٹ کے طور پر ایک کنارے کا وزن لیتا ہے اور گراف میں کنارے کو شامل کرتا ہے۔ کلاس میں بھی ایک طریقہ مختصر_پاتھ () ہوتا ہے جو ایک ماخذ کو ان پٹ کے طور پر لیتا ہے اور لوٹتا ہے۔ماخذ ورٹیکس سے لے کر گراف میں موجود دیگر تمام عمودی حصے تک مختصر ترین فاصلوں کی ایک فہرست۔یہ طریقہ تمام عمودی حصے میں فاصلوں کی ایک فہرست کو انفینٹی کے طور پر شروع کرتا ہے سوائے سورس ورٹیکس کے ، جو شروع کیا جاتا ہے۔ اس کے بعد گراف V-1 بار کے تمام کناروں پر تکرار کرتا ہے ، اگر ہر ایک کا راستہ مل جاتا ہے تو ہر ایک کے فاصلے کو اپ ڈیٹ کرتا ہے۔اگر گراف میں کوئی منفی چکر موجود ہے تو ، طریقہ کسی کو بھی واپس نہیں کرتا ہے۔ یہاں گراف کلاس کا ایک مثال استعمال ہے اور مختصر_پاتھ () طریقہ: پائیتھونگ = گراف (5) G.Add_edge (0 ، 1 ، 6) G.Add_edge ((0 ، 1 ، 6) (0 ، 1 ، 6) (0 ، 1 ، 6) (0 ، 1 ، 6)0 ، 3 ، 7) g.add_edge (1 ، 2 ، 5) g.add_edge (1 ، 3 ، 8) g.add_edge (1 ، 4 ، -4) g.add_edge (2 ، 1 ، -2) g.add_edge (3 ، 2 ، -3) g.add_edge (3 ، 4 ، 9) g.add_edge (4 ، 0 ، 2) g.add_edge (4 ، 2 ، 7) فاصلوں = g.shortest_path (0) پرنٹ (فاصلوں) # آؤٹ پٹ: [0 ، 2 ، 4 ، 7 ، -2] یہ پروگرام 5 عمودی اور 10 ہدایت والے کناروں کے ساتھ ایک گراف آبجیکٹ جی تشکیل دیتا ہے۔اس کے بعد یہ گراف میں کناروں کو شامل کرنے کے لئے ADD_EDGE () کے طریقہ کار کو کال کرتا ہے۔آخر میں ، یہ 0 کے سورس ورٹیکس کے ساتھ مختصر ترین_پاتھ () کے طریقہ کار کو کہتے ہیں اور گراف میں موجود دیگر تمام عمودی حصے میں ماخذ کی حد سے کم فاصلوں کی فہرست پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ [0 ، 2 ، 4 ، 7 ، -2] ہے۔"
    },
    {
        "Question": "ہندسوں کے دیئے گئے تار سے تمام ممکنہ درست IP پتے تیار کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ہندسوں کے دیئے گئے تار سے تمام ممکنہ درست IP پتے تیار کرنے کے ل we ، ہم بیک ٹریکنگ اپروچ استعمال کرسکتے ہیں۔ہم دیئے گئے تار میں تین نقطوں کو رکھ سکتے ہیں اور پھر تین نقطوں کے لئے تمام ممکنہ امتزاج کو آزما سکتے ہیں۔لوپ میں داخل ہونے سے پہلے ، ہم تار کے سائز کو چیک کرسکتے ہیں اور تار کے ہر ممکنہ امتزاج پیدا کرسکتے ہیں۔اس کے بعد ہم جواز کے لئے کارنر کے تمام معاملات کی جانچ کرسکتے ہیں ، جیسے یہ جانچ پڑتال کرنا کہ آیا نمبر 0-255 کی حد میں ہیں اور اگر نمبر 0 سے پہلے نہیں ہیں جب تک کہ وہ 0 نہ ہوں۔اس نقطہ نظر کو نافذ کرنا: گیکسفورجیکس: 1 ٹیوٹوریالس پوائنٹ: 2 اسٹیک اوور فلو: 3opengenus IQ: 4 جب تک ازگر میں بیک ٹریکنگ نقطہ نظر کی ایک مثال کا نفاذ: پائیتھنڈف ریستور_پ_اڈریسس (ایس): ڈیف بیک ٹریک (اسٹارٹ ، ڈاٹس ، کرر): اگر نقطوں = 3: اگر نقاد == 3: اگر ڈاٹ == 3: اگر آئی ایس_ 3: اگر آئی ایس_ 3: اگر آئی ایس_ 3: اگر آئی ایس۔کرور + ایس [اسٹارٹ:]): آؤٹ پٹ.ایپینڈ (کرر + ایس [اسٹارٹ:]) رینج (اسٹارٹ ، لین (ایس)) کے لئے واپسی: اگر is_valid (curr + s [start: i + 1]):بیک ٹریک (i+1 ، نقطوں+1 ، کرور+ایس [شروع: i+1]+'.') Def is_valid (s): اگر لین (s)> 1 اور s [0] == '0': واپسیغلط اگر int (s)> 255: غلط واپسی سچ آؤٹ پٹ = [] بیک ٹریک (0 ، 0 ، '') ریٹرن آؤٹ پٹ یہ پروگرام ایک فنکشن کی بحالی کی وضاحت کرتا ہے۔IP ایڈریس کے مجموعے جو تار سے حاصل کیے جاسکتے ہیں۔یہ پہلے ایک ہیلپر فنکشن بیک ٹریک () کی وضاحت کرتا ہے جو ابتدائی انڈیکس اسٹارٹ ، متعدد نقطوں کے نقطوں ، اور موجودہ امتزاج کے طور پر ایک موجودہ امتزاج کریور لیتا ہے اور موجودہ امتزاج سے شروع ہونے والے تمام ممکنہ درست IP ایڈریس کے امتزاج کو بار بار تیار کرتا ہے۔یہ شروعاتی اشاریہ سے شروع ہونے والے سٹرنگ کے باقی کرداروں پر تکرار کرکے ، ہر کردار کو موجودہ امتزاج میں شامل کرتے ہوئے ، اگلے شروع ہونے والے انڈیکس کے ساتھ بیک ٹریک () کو بار بار کالنگ کرتے ہیں ، نقطوں کی تازہ کاری کی تعداد ، اور A کے ساتھ تازہ ترین موجودہ مجموعہڈاٹ نے شامل کیا ، اور آخری کردار کو موجودہ امتزاج سے ہٹانا۔اگر نقطوں کی تعداد 3 کے برابر ہے اور موجودہ امتزاج کے علاوہ سٹرنگ کے باقی حروف ایک درست IP ایڈریس تشکیل دیتے ہیں تو ، یہ موجودہ امتزاج کے علاوہ اسٹرنگ کے باقی حروف کو آؤٹ پٹ لسٹ میں شامل کرتا ہے۔اس کے بعد فنکشن ایک مددگار فنکشن کی وضاحت کرتا ہے۔آؤٹ پٹ لسٹ ، 0 کے ابتدائی انڈیکس ، 0 کے متعدد نقطوں ، اور ایک خالی موجودہ امتزاج کے ساتھ بیک ٹریک () کو کال کرتا ہے ، اور آؤٹ پٹ لسٹ کو لوٹاتا ہے۔ فنکشن کی ایک مثال استعمال: ازگر = \"25525511135\" ip_address = restore_ip_address (\"ایس) پرنٹ (IP_ADDRESSES) # آؤٹ پٹ: ['255.255.11.135' ، '255.255.111.35'] یہ پروگرام اسٹرنگ ایس بناتا ہے ، ریسٹور_پ_اڈریس () کو ان پٹ کے طور پر سٹرنگ کے ساتھ کال کرتا ہے ، اور تمام ممکنہ درست آئی پی کی فہرست کو پرنٹ کرتا ہے۔ایڈریس کے امتزاج جو تار سے حاصل کیے جاسکتے ہیں۔اس معاملے میں آؤٹ پٹ ['255.255.11.135' ، '255.255.111.35'] ہے۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں الٹی کی تعداد کو گننے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "عددیوں کی دی گئی فہرست میں الٹی کی تعداد کو گننے کے ل we ، ہم انضمام ترتیب والے الگورتھم کو استعمال کرسکتے ہیں۔جب تک ہم کسی ایک عنصر تک نہ پہنچیں تب تک ہم فہرست کو دو حصوں میں بار بار تقسیم کرسکتے ہیں ، اور پھر الٹا کی تعداد گنتے ہوئے دونوں حصوں کو ضم کرسکتے ہیں۔ایک الٹا اس وقت ہوتا ہے جب ترتیب شدہ فہرست میں ایک چھوٹے عنصر کے سامنے ایک بڑا عنصر ظاہر ہوتا ہے۔ہم ہر آدھے کے پہلے عنصر کا موازنہ کرکے دونوں حصوں کو ضم کرتے ہوئے الٹی کی تعداد پر نظر رکھ سکتے ہیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کو عملی جامہ پہنانے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: گیکسفورجیکس: 1 ٹکیڈ لائٹ: 2 انٹرویوئٹ: 3 ٹیکیوفورورڈ: 4 ٹوپ کوڈر: 5 ہیرے کی مثال کے طور پر ازگر میں انضمام ترتیب کے نقطہ نظر کا ایک مثال عمل: پائیتھنڈف کاؤنٹ_ انوسورنس (اے آر آر): ڈیف انضمام_سورٹ (اے آر آر) ، مرج_سورٹ (اے آر آر) ، ڈی ای ایف مرج_سورٹ (اے آر آر) ، انضمام۔بائیں ، دائیں): inv_count = 0 اگر بائیں <دائیں: درمیانی = (بائیں +دائیں) // 2 انو_کاؤنٹ += انضمام_سورٹ (اے آر آر ، ٹیمپ ، بائیں ، وسط) انو_کاؤنٹ += انضمام_سورٹ (اریر ، ٹمپ ، مڈ +1 ، دائیں) inv_count + = انضمام (arr ، temp ، بائیں ، وسط ، دائیں) واپسی inv_count def انضمام (arr ، temp ، بائیں ، وسط ، دائیں): i = بائیں j = وسط + 1 k = بائیں inv_count = 0 جبکہ i <=وسط اور J <= دائیں: if arr [i] <= arr [j]: عارضی [k] = arr [i] i += 1 اور: عارضی [k] = arr [j] j += 1 inv_count += =وسط - i +1 k += 1 جبکہ i <= وسط: عارضی [k] = arr [i] i += 1 k += 1 جبکہ j <= دائیں: عارضی [k] = arr [j] j +=1 K += 1 میں I کے لئے رینج (بائیں ، دائیں +1): arr [i] = ٹیمپ [i] واپسی inv_count temp = [0] * لین (arr) واپس انضمام_سورٹ (arr ، عارضی ، 0 ، لین (arr (arr)) -1) اس پروگرام میں ایک فنکشن کاؤنٹ_ انورینس () کی وضاحت کی گئی ہے جو ان پٹ کے طور پر انٹیجرز کی فہرست لیتا ہے اور فہرست میں الٹ کی تعداد کو واپس کرتا ہے۔یہ پہلے ایک مددگار فنکشن انضمام_سورٹ () کی وضاحت کرتا ہے جو فہرست میں لیتا ہے ، ایک عارضی فہرست کا عارضی ، بائیں انڈیکس بائیں ، اور دائیں انڈیکس دائیں کے طور پر ان پٹ کے طور پر اور اس فہرست کو دو حصوں میں بار بار تقسیم کرتا ہے جب تک کہ یہ کسی ایک عنصر تک نہ پہنچ جائے۔اس کے بعد یہ انضمام () فنکشن کا استعمال کرتے ہوئے الٹا کی تعداد کی گنتی کرتے ہوئے دونوں حصوں کو ضم کرتا ہے۔انضمام () فنکشن فہرست ، عارضی فہرست ، بائیں انڈیکس ، مڈل انڈیکس مڈ ، اور دائیں انڈیکس کو ان پٹ کے طور پر لیتا ہے اور الٹا کی تعداد گنتے ہوئے دونوں حصوں کو ضم کرتا ہے۔یہ دو حصوں پر تکرار کرکے اور ہر آدھے کے پہلے عنصر کا موازنہ کرکے کرتا ہے۔اگر دائیں آدھے حصے میں عنصر بائیں نصف میں عنصر سے چھوٹا ہے تو ، یہ بائیں نصف میں باقی عناصر کی تعداد کے ذریعہ الٹا گنتی میں اضافہ کرتا ہے۔اس کے بعد یہ عارضی فہرست میں بائیں آدھے یا دائیں نصف کے باقی عناصر کی کاپی کرتا ہے ، اور پھر عارضی فہرست سے ترتیب دیئے گئے عناصر کو اصل فہرست میں واپس کرتا ہے۔اس کے بعد فنکشن الٹا گنتی لوٹاتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہوتا ہے: ازگر = [1 ، 20 ، 6 ، 4 ، 5] inv_count = count_inversions (arr) پرنٹ (inv_count) # آؤٹ پٹ: 5 اس پروگرام میں عددی arr کی فہرست تشکیل دی جاتی ہے۔، فہرست کے ساتھ کاؤنٹ_ انورینسز () کو ان پٹ کے طور پر کال کرتا ہے ، اور فہرست میں الٹی کی تعداد کو پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 5 ہے"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں زیادہ سے زیادہ سبری مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "انٹیجرز کی دی گئی فہرست میں زیادہ سے زیادہ سبری پروڈکٹ تلاش کرنے کے ل we ، ہم کڈانے کے الگورتھم کو استعمال کرسکتے ہیں۔الگورتھم اس مشاہدے پر مبنی ہے کہ زیادہ سے زیادہ پروڈکٹ سبری میں یا تو صف کا آخری عنصر شامل ہوتا ہے یا ایسا نہیں ہوتا ہے۔ہم سرنی کے ہر انڈیکس پر ختم ہونے والے زیادہ سے زیادہ اور کم سے کم پروڈکٹ سبریوں کا سراغ لگاسکتے ہیں ، اور موجودہ عنصر کی زیادہ سے زیادہ زیادہ سے زیادہ مصنوعات ، موجودہ عنصر کے اوقات میں ختم ہونے والی زیادہ سے زیادہ مصنوعات سبری کو اپ ڈیٹ کرتے ہیں ، اورکم سے کم پروڈکٹ سبری کا اختتام موجودہ انڈیکس کے اوقات میں موجودہ عنصر کے اوقات میں ہوتا ہے۔ہم موجودہ عنصر کی کم سے کم کم سے کم ، موجودہ عنصر کے اوقات میں ختم ہونے والے زیادہ سے زیادہ مصنوعات سبری کو موجودہ عنصر کے اوقات میں ختم کرکے کم سے کم پروڈکٹ سبیرے کو بھی اپ ڈیٹ کرسکتے ہیں ، اور کم سے کم پروڈکٹ سبیرے موجودہ عنصر کے اوقات میں ختم ہوتا ہے۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کو نافذ کرنے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: انٹرویو بٹ: 1 سکلر: 2 ٹکی ڈیلیٹ: 3leetCode: 4 ٹیکوفورورڈ: 5 ہیرے کی ایک مثال کے طور پر کڈانے کے الگورتھم کا نفاذ: میکس_پھنڈف میکس_ پروڈکٹ_سبرے (نمبرز): میکس_ پروڈکٹ (نمبر)= nums [0] min_ending_here = nums [0] in in range (1 ، len (nums)) کے لئے: اگر nums [i] <0: max_ending_here ، min_ending_here = min_ending_here ، max_ending_here زیادہ سے زیادہ_ہینڈی_ہیر = زیادہ سے زیادہ (نمبر [i] ، میکس_نینڈنگ_ہیر *نمبر [i]) min_ending_here = min (nums [i] ، min_ending_here * nums [i]) میکس_ پروڈکٹ = زیادہ سے زیادہ (میکس_ پروڈکٹ ، میکس_نینڈنگ_ہیر) میکس_ پروڈکٹیویس پروگرام ایک فنکشن میکس_ پروڈکٹ_سبرے () کی وضاحت کرتا ہے جس میں ان پٹ کی فہرست لی جاتی ہے اور ان پٹ کی فہرست لی جاتی ہے۔فہرست میں زیادہ سے زیادہ پروڈکٹ سبری۔یہ فہرست کے پہلے عنصر پر ختم ہونے والی زیادہ سے زیادہ مصنوعات اور زیادہ سے زیادہ اور کم سے کم مصنوعات کے سبریوں کی ابتدا کرتا ہے۔اس کے بعد یہ فہرست کے باقی عناصر پر تکرار کرتا ہے ، اور کڈانے کے الگورتھم کا استعمال کرتے ہوئے ہر انڈیکس پر ختم ہونے والے زیادہ سے زیادہ اور کم سے کم پروڈکٹ سبریوں کو اپ ڈیٹ کرتا ہے۔یہ موجودہ عنصر کی زیادہ سے زیادہ اور کم سے کم ، زیادہ سے زیادہ مصنوعات سبیرے کو موجودہ عنصر کے اوقات میں ختم کرنے والے زیادہ سے زیادہ اور کم سے کم مصنوعات کے سبریوں کو اپ ڈیٹ کرتا ہے ، اور موجودہ عنصر کے اوقات میں ختم ہونے والے کم سے کم پروڈکٹ سبیرے موجودہ عنصر کے اوقات میں ختم ہوجاتے ہیں۔اس کے بعد موجودہ زیادہ سے زیادہ مصنوعات اور موجودہ انڈیکس پر ختم ہونے والی زیادہ سے زیادہ مصنوعات سبری کو زیادہ سے زیادہ لے کر زیادہ سے زیادہ مصنوعات کو اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن زیادہ سے زیادہ پروڈکٹ کو لوٹاتا ہے۔ فنکشن کی ایک مثال کے استعمال کا استعمال: پائیتھونومس = [2 ، 3 ، -2 ، 4 ، -1] میکس_ پروڈکٹ = میکس_ پروڈکٹ_سوبری (نمبر) پرنٹ (میکس_ پروڈکٹ) # آؤٹ پٹ: 48 اس پروگرام کی فہرست تشکیل دیتی ہے۔انٹیجرز نمبر ، فہرست کے ساتھ میکس_ پروڈکٹ_سوبری () فنکشن کو ان پٹ کے طور پر کال کرتے ہیں ، اور فہرست میں زیادہ سے زیادہ پروڈکٹ سبیرے کو پرنٹ کرتے ہیں۔اس معاملے میں آؤٹ پٹ 48 ہے۔ نوٹ: اگر ان پٹ لسٹ میں صرف مثبت عدد ہوتا ہے تو ، زیادہ سے زیادہ مصنوعات کا سبری صرف فہرست میں موجود تمام عدد کی پیداوار ہے۔اگر ان پٹ لسٹ میں صرف منفی انٹیجرز ہوتے ہیں تو ، زیادہ سے زیادہ پروڈکٹ سبری اس فہرست میں سب سے بڑا منفی عدد ہے۔اگر ان پٹ لسٹ میں مثبت اور منفی دونوں عدد دونوں پر مشتمل ہے تو ، کڈانے کے الگورتھم کو زیادہ سے زیادہ مصنوع سبریئر کو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "ریڈکس ٹری (ٹری) کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور تاروں کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "ریڈکس ٹری (ٹری) کی نمائندگی کرنے اور تاروں کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کرنے کے لئے ایک ازگر کلاس بنانے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک کلاس ٹرینوڈ کی وضاحت کریں جو ریڈکس کے درخت میں نوڈ کی نمائندگی کرتا ہے۔کلاس میں چائلڈ نوڈس کی لغت اور بولین پرچم ہونا چاہئے تاکہ اس بات کی نشاندہی کی جاسکے کہ اگر نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔ ایک کلاس ریڈکس ٹری کی وضاحت کریں جو ریڈکس کے درخت کی نمائندگی کرتا ہے۔کلاس کے پاس درخت میں تاروں کو داخل کرنے اور تلاش کرنے کے لئے جڑ کا نوڈ اور طریقے ہونا چاہئے۔ ریڈکسٹری کلاس میں داخل () کا طریقہ کار جو ان پٹ کے طور پر ایک تار لیتا ہے اور اسے درخت میں داخل کرتا ہے۔طریقہ کو جڑ کے نوڈ پر شروع ہونا چاہئے اور تار کے کرداروں پر تکرار کرنا چاہئے ، جس سے نئے نوڈس کو ضروری طور پر تشکیل دیا جائے اور آخری نوڈ کے لئے اختتامی الفاظ کا پرچم مرتب کیا جائے۔چونکہ ان پٹ اور لوٹتا ہے اگر تار درخت میں ہے اور دوسری صورت میں غلط ہے۔طریقہ کو جڑ کے نوڈ پر شروع ہونا چاہئے اور تار کے کرداروں پر تکرار کرنا چاہئے ، غلط لوٹانا اگر کوئی کردار موجودہ نوڈ کے چائلڈ نوڈس میں نہیں ہے یا اگر آخری لفظ کا پرچم آخری نوڈ کے لئے مقرر نہیں ہے۔ یہاں۔ یہاںکچھ وسائل ہیں جو ازگر میں ریڈکس ٹری کو نافذ کرنے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: ٹیوٹوریلس پوائنٹ: 1 اوپنجینس IQ: 2eleksandr Howhannisyan: 3geeksforgeeks: 4 میڈیم: 5 ہینڈل __ (Pythoned: Pythoned: Pythonode: Pythonode: Pythonode: Pythonode: Pythonode: Pythonode: Pythonode: Pythonode: Def): self.Children.کرین: موجودہ۔ بچوں [چار] = ٹرائینوڈ () موجودہ = موجودہ۔ بچوں [چار] موجودہ۔ is_end_of_word = سچے ڈیف سرچ (خود ، لفظ): موجودہ = سیلف۔ لفظ میں چار کے لئے۔بچے: غلط موجودہ = موجودہ۔ بچوں کو واپس کریں [چار] موجودہ واپس کریں۔ IS_END_OF_WORITIS پروگرام ایک کلاس ٹرائنوڈ کی وضاحت کرتا ہے جو ریڈکس ٹری میں ایک نوڈ کی نمائندگی کرتا ہے۔کلاس میں چائلڈ نوڈس کی ایک لغت اور بولین پرچم ہے جس سے یہ ظاہر ہوتا ہے کہ اگر نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔یہ ایک کلاس ریڈکس ٹری کی بھی وضاحت کرتا ہے جو ریڈکس ٹری کی نمائندگی کرتا ہے۔کلاس میں درخت میں تاروں کو داخل کرنے اور تلاش کرنے کے لئے جڑ کا نوڈ اور طریقے ہیں۔داخل () کا طریقہ ان پٹ کے طور پر ایک تار لیتا ہے اور اسے درخت میں داخل کرتا ہے۔یہ روٹ نوڈ سے شروع ہوتا ہے اور تار کے کرداروں پر تکرار کرتا ہے ، جس سے نئے نوڈس کو ضروری طور پر تشکیل دیا جاتا ہے اور آخری نوڈ کے لئے آخری لفظ کا پرچم مرتب ہوتا ہے۔تلاش () کا طریقہ ان پٹ کے طور پر ایک تار لیتا ہے اور اگر تار درخت میں ہوتا ہے اور غلط ہے تو سچائی واپس آجاتا ہے۔یہ روٹ نوڈ سے شروع ہوتا ہے اور تار کے کرداروں پر تکرار کرتا ہے ، غلط لوٹتا ہے اگر کوئی کردار موجودہ نوڈ کے چائلڈ نوڈس میں نہیں ہے یا اگر آخری لفظ کا جھنڈا آخری نوڈ کے لئے مقرر نہیں ہے۔ یہاں ایک مثال ہے۔ریڈکسٹری کلاس کا استعمال: پائیتھونراڈکس_ٹری = ریڈکسٹری () ریڈکس_ٹری.سرٹ (\"ایپل\") ریڈکس_ٹری.سرٹ (\"کیلے\") ریڈکس_ٹری.سرٹ (\"چیری\") پرنٹ (ریڈکس_ٹری.چارچ (\"ایپل\") # آؤٹ پٹ: پرنٹ: پرنٹ: پرنٹ: پرنٹ.اس معاملے میں آؤٹ پٹ صحیح اور غلط ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا بائنری ٹری ایک درست بائنری سرچ درخت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا بائنری ٹری ایک درست بائنری سرچ ٹری ہے ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: تکرار نقطہ نظر: ہم بار بار یہ چیک کرسکتے ہیں کہ آیا جڑ کے بائیں اور دائیں دونوں ذیلی ذخیرے بھی بائنری تلاش کے درخت ہیں اور اگر ہاں تو سچ واپس آجائیں۔ہم ہر نوڈ کے لئے اجازت دی جانے والی کم سے کم اور زیادہ سے زیادہ اقدار پر بھی نظر رکھ سکتے ہیں اور چیک کریں کہ آیا موجودہ نوڈ کی قیمت اجازت کی حد میں ہے یا نہیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کو عملی جامہ پہنانے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: 1leetcode: 2enjoyalgorithms: 3educative.io: 4 ٹیکوفورورڈ: 5 ٹکی لذت: 6 انڈر آرڈر ٹراورسل اپروچ: ہم بائنری ٹری کا ایک غیر معمولی عذاب انجام دے سکتے ہیں اور اس کے نتیجے میں ترتیب دے سکتے ہیں۔اقدار کی چڑھائی ترتیب میں ترتیب دی جاتی ہے۔اگر ترتیب ترتیب دی گئی ہے ، تو بائنری ٹری ایک درست بائنری سرچ درخت ہے۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کو نافذ کرنے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: گیکسفورجیکس: لیٹ کوڈ: پروگرامیز: ٹیوٹوریلس پوائنٹ: یہاں ازگر میں تکرار نقطہ نظر کی ایک مثال ہے: ازگرکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، کوئی نہیں ،دائیں = کوئی نہیں): self.val = val self.left = بائیں سیلف۔ رائٹ = رائٹ کلاس حل: Def isvalidbst (خود ، جڑ: ٹرینوڈ) -> بول: Def is_valid (نوڈ ، Min_val ، Max_val): اگر نہیں نوڈ: واپسیسچ ہے اگر node.val <= min_val یا node.val> = max_val: واپس غلط واپسی is_valid (نوڈ.لفٹ ، من_وال ، نوڈ.ول) اور is_valid (نوڈ.رائٹ ، نوڈ.ول ، میکس_وال) واپسی آئی ایس_والیڈ (جڑ ، فلوٹ.isvalidbst () کا طریقہ ایک ٹرینوڈ آبجیکٹ کی جڑ کو ان پٹ کے طور پر لیتا ہے اور اگر بائنری ٹری ایک درست بائنری سرچ ٹری ہے اور غلط ہے تو وہ سچ ہے۔یہ ایک ہیلپر فنکشن IS_Valid () کی وضاحت کرکے کرتا ہے جو ایک ٹرینوڈ آبجیکٹ نوڈ ، کم سے کم قیمت MIN_VAL ، اور ان پٹ کے طور پر زیادہ سے زیادہ قیمت میکس_وال لیتا ہے اور اگر نوڈ پر جڑی ہوئی بائنری ٹری کی جڑیں ایک درست بائنری سرچ ٹری ہے جس میں اقدار ہیں۔MIN_VAL اور MAX_VAL کی حد۔یہ جانچ پڑتال کرکے یہ کام کرتا ہے کہ آیا موجودہ نوڈ کی قیمت اجازت شدہ حد میں ہے اور بار بار یہ جانچ پڑتال کرتی ہے کہ آیا بائیں اور دائیں سب ٹری بھی بائنری تلاش کے درست درخت ہیں۔isvalidbst () طریقہ کار پھر IS_Valid () کو روٹ نوڈ کے ساتھ اور منفی اور مثبت انفینٹی کی کم سے کم اور زیادہ سے زیادہ اقدار کے ساتھ کال کرتا ہے۔ بالترتیب حل کلاس کا ایک مثال استعمال: پائیٹونروٹ = ٹرینوڈ (5) روٹ.یلفٹ = ٹرینوڈ(1) روٹ۔ رائٹ = ٹرینوڈ (4) جڑ۔روٹ نوڈ کے ساتھ ایک بائنری درخت بناتا ہے جس کی قیمت 5 ہوتی ہے اور روٹ نوڈ کے ساتھ حل کلاس کے isvalidbst () طریقہ کو ان پٹ کے طور پر کال کرتا ہے۔اس معاملے میں آؤٹ پٹ غلط ہے۔ نوٹ: بائنری تلاش کے ایک درست درخت کی وضاحت کرنے کے مختلف طریقے ہیں ، اور عین مطابق تعریف مسئلے کے بیان پر منحصر ہوسکتی ہے۔کچھ تعریفیں ڈپلیکیٹ اقدار کی اجازت دے سکتی ہیں ، جبکہ دوسروں کو ایسا نہیں ہوسکتا ہے۔کچھ تعریفیں بائیں اور دائیں سبٹریز کو مساوی اقدار کی اجازت دے سکتی ہیں ، جبکہ دوسروں کو ایسا نہیں ہوسکتا ہے۔مسئلے کے بیان کو احتیاط سے پڑھنا اور حل کو نافذ کرنے سے پہلے ایک درست بائنری سرچ ٹری کی تعریف کو سمجھنا ضروری ہے۔"
    },
    {
        "Question": "کسی بھی نوڈ سے کسی دوسرے نوڈ تک درخت میں سب سے طویل راستہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "قطار اور کالموں کے ذریعہ ترتیب دیئے گئے میٹرکس میں کے ٹی ایچ کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ایک میٹرکس میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے ل pros ، جو قطاروں اور کالموں کے ذریعہ ترتیب دیئے گئے ہیں ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: بائنری سرچ اپروچ: ہم میٹرکس میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے بائنری سرچ کا استعمال کرسکتے ہیں۔ہم بالترتیب میٹرکس میں کم سے کم اور زیادہ سے زیادہ اقدار پر بائیں اور دائیں حدود کو ترتیب دے سکتے ہیں ، اور پھر میٹرکس میں موجود عناصر کی تعداد گن سکتے ہیں جو درمیانی قیمت سے کم یا اس کے برابر ہیں۔اگر گنتی K سے کم ہے تو ، ہم بائیں حد کو درمیانی قیمت + میں اپ ڈیٹ کرسکتے ہیں۔ہم اس عمل کو اس وقت تک دہرا سکتے ہیں جب تک کہ بائیں اور دائیں حدود کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر میں نہ آجائیں۔یہاں کچھ وسائل ہیں جو اس نقطہ نظر کو عملی جامہ پہنانے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: انٹرویو کِک اسٹارٹ: 1leetcode: 2 میڈیم: 3youtube: 4 جب ازگر میں بائنری تلاش کے نقطہ نظر کی ایک مثال کا نفاذ: پائیتھنڈف Kth_smallest (میٹرکس ، کے): Def count_less_or_ore_equal (میترکس ، مڈکس ، مڈکس ، مڈکس ، مڈکس ، مڈکس ، مڈکس ، مڈکس ، مڈکس ، مڈکس ، درمیانی): گنتی = 0 i = لین (میٹرکس) - 1 j = 0 جبکہ i> = 0 اور j <لین (میٹرکس [0]): اگر میٹرکس [i] [j] <= وسط: گنتی + = i + 1j + = 1 اور: i-= 1 واپسی کی گنتی بائیں = میٹرکس [0] [0] دائیں = میٹرکس [-1] [-1] جبکہ بائیں <= دائیں: وسط = (بائیں + دائیں) // 2 گنتی =گنتی_ لیس_ور_قال (میٹرکس ، وسط) اگر گنتی <K: بائیں = وسط + 1 اور: دائیں = وسط - 1 ریٹرن لیفٹ اس پروگرام کی وضاحت کرتا ہے جس میں ایک فنکشن Kth_smallest () ہوتا ہے جو انٹیگرز میٹرکس کا میٹرکس اور ان پٹ کے طور پر ایک انٹیجر K لے جاتا ہے اور KTH کو سب سے چھوٹا کرتا ہے۔میٹرکس میں عنصر۔یہ ایک مددگار فنکشن کاؤنٹی_ لیس_ور_قال () کی وضاحت کرکے کرتا ہے جو ایک میٹرکس اور ویلیو مڈ کو ان پٹ کے طور پر لیتا ہے اور میٹرکس میں موجود عناصر کی تعداد کو واپس کرتا ہے جو وسط سے کم یا اس کے برابر ہوتا ہے۔یہ میٹرکس کے نچلے بائیں کونے سے شروع کرکے اور دائیں طرف بڑھ کر یہ کام کرتا ہے جب تک کہ اسے کوئی عنصر نہ مل جائے جو وسط سے زیادہ ہو۔اس کے بعد اس عنصر کے نیچے قطاروں کی تعداد کو گنتی میں شامل کرتا ہے اور دائیں طرف جاتا ہے۔یہ اس عمل کو دہراتا ہے جب تک کہ وہ میٹرکس کے اوپری دائیں کونے تک نہ پہنچ جائے۔Kth_smallest () فنکشن اس کے بعد میٹرکس میں بالترتیب بائیں اور دائیں حدود کو کم سے کم اور زیادہ سے زیادہ اقدار کی شروعات کرتا ہے ، اور KTH کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے بائنری تلاش کا استعمال کرتا ہے۔یہ بائیں اور دائیں حدود کو اپ ڈیٹ کرتا ہے جو گنتی کی بنیاد پر گنتی_لیس_ور_قال () فنکشن کے ذریعہ واپس کی گئی ہے جب تک کہ بائیں اور دائیں حدود کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر میں تبدیل نہ ہوجائیں۔اس کے بعد فنکشن بائیں باؤنڈری کو لوٹاتا ہے۔ Kth_smallest () فنکشن کا ایک مثال استعمال: pythonmatrix = [[1 ، 3 ، 5] ، [2 ، 3 ، 6] ، [3 ، 4 ، 7]] k = 5kth_smallement =Kth_smallest (میٹرکس ، کے) پرنٹ (kth_smallest_element) # آؤٹ پٹ: 3 اس پروگرام میں انٹیجرز میٹرکس کا ایک میٹرکس اور ایک عددی K تیار کیا گیا ہے ، اس کو میٹرکس اور K کے ساتھ kth_smallest () فنکشن کو ان پٹ کے طور پر کال کرتا ہے ، اور میتکس میں Kth سب سے چھوٹا عنصر پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 3 ہے"
    },
    {
        "Question": "دو ڈوروں کے مابین لیونشٹین فاصلے کا حساب لگانے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "لیونشین کا فاصلہ دو ڈوروں کے مابین مماثلت کا ایک پیمانہ ہے۔اس کی وضاحت ایک تار کو دوسرے میں تبدیل کرنے کے لئے درکار تبدیلیوں کی کم سے کم تعداد کے طور پر کی گئی ہے۔ترمیم کی کارروائیوں میں اضافے ، حذف کرنا اور متبادل شامل ہیں۔لیونشٹین فاصلہ فاصلہ میٹرکس کے کنبے میں سب سے زیادہ مقبول میٹرک ہے جسے ترمیم فاصلہ 1 کے نام سے جانا جاتا ہے۔سب سے عام طریقہ متحرک پروگرامنگ کا استعمال کرنا ہے۔ہم سائز (M+1) x (n+1) کا میٹرکس تشکیل دے سکتے ہیں ، جہاں ایم اور این دو تار کی لمبائی ہیں ، اور پہلی صف اور کالم کو 0 ، 1 ، 2 ، ... ، ایم میں شروع کرسکتے ہیں۔اور 0 ، 1 ، 2 ، ... ، n ، بالترتیب۔اس کے بعد ہم میٹرکس کے باقی خلیوں پر تکرار کرسکتے ہیں اور پڑوسی خلیوں کی اقدار کی بنیاد پر ان کو بھر سکتے ہیں۔ہر سیل کی قدر اس مقام تک دونوں ڈوروں کے ذیلی ذیلی حصے کے درمیان لیونشٹین فاصلے کی نمائندگی کرتی ہے۔میٹرکس کے نچلے دائیں کونے میں آخری قیمت دو تاروں کے درمیان لیونشٹین فاصلے کی نمائندگی کرتی ہے۔ یہاں ازگر میں لیونشٹین فاصلہ الگورتھم کا ایک مثال عمل: پائیتھنڈف لیونشٹین_ڈسٹینس (ایس ، ٹی): ایم ، این = لین (ایس) ،لین (t) dp = [[0] * (n + 1) _ کے لئے حد (m + 1)] i in range (m + 1) کے لئے: dp [i] [0] = i j کے لئے j کے لئے (حد میں (n + 1): dp [0] [j] = j in range (1 ، m + 1) کے لئے: J کے لئے حد (1 ، n + 1): اگر s [i - 1] == t [j- 1]: dp [i] [j] = dp [i - 1] [j - 1] اور: dp [i] [j] = 1 + منٹ (dp [i - 1] [j] ، dp [i] [جے - 1] ، ڈی پی [i - 1] [j - 1]) واپسی ڈی پی [ایم] [این] اس پروگرام میں ایک فنکشن لیونشٹین_ڈسٹنس () کی وضاحت کی گئی ہے جو دو ڈوروں کو ان پٹ کے طور پر لیتا ہے اور اس کے درمیان لیونشٹین فاصلہ واپس کرتا ہے۔دو تاریہ سائز (M+1) x (n+1) کا میٹرکس تشکیل دے کر کرتا ہے ، جہاں ایم اور این دو تار کی لمبائی ہیں ، اور پہلی صف اور کالم کو 0 ، 1 ، 2 ، ...، ایم اور 0 ، 1 ، 2 ، ... ، این ، بالترتیب۔اس کے بعد یہ میٹرکس کے باقی خلیوں پر تکرار کرتا ہے اور پڑوسی خلیوں کی اقدار کی بنیاد پر ان کو بھرتا ہے۔ہر سیل کی قدر اس مقام تک دونوں ڈوروں کے ذیلی ذیلی حصے کے درمیان لیونشٹین فاصلے کی نمائندگی کرتی ہے۔میٹرکس کے نچلے دائیں کونے میں آخری قیمت دو ڈوروں کے مابین لیونشٹین فاصلے کی نمائندگی کرتی ہے۔ یہاں لیونشٹین_ڈسٹنس () فنکشن کی ایک مثال استعمال: ازگر 1 = \"بلی کاٹن\" S2 = \"بیٹھنا\" فاصلہ = لیونشٹین_ڈیسٹنس (S1 ، S2)پرنٹ (فاصلہ) # آؤٹ پٹ: 3 اس پروگرام میں دو ڈور S1 اور S2 تخلیق ہوتے ہیں ، ان پٹ کے طور پر دو ڈوروں کے ساتھ لیوینشٹین_ڈیسٹنس () فنکشن کہتے ہیں ، اور دونوں ڈوروں کے درمیان لیونشین فاصلہ پرنٹ کرتا ہے۔اس معاملے میں آؤٹ پٹ 3 ہے"
    },
    {
        "Question": "بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور داخل کرنے اور چیک کریں کہ آیا عنصر موجود ہے یا نہیں۔",
        "Answer": "بلوم فلٹر کی نمائندگی کرنے والے ازگر کی کلاس بنانے کے ل and اور داخل کرنے کے طریقوں کو نافذ کرنے اور یہ چیک کرنے کے لئے کہ آیا عنصر موجود ہے ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک کلاس بلوم فلٹر کی وضاحت کریں جو بلوم فلٹر کی نمائندگی کرتا ہے۔کلاس میں سائز ایم کی تھوڑی سی صف اور کے ہیش فنکشن کی ایک فہرست ہونی چاہئے۔ بلوم فلٹر کلاس میں شامل () کا طریقہ کار جو ان پٹ کے طور پر عنصر لیتا ہے اور اسے بلوم فلٹر میں داخل کرتا ہے۔اس طریقہ کار کو K ہیش کے افعال کا استعمال کرتے ہوئے عنصر کی ہیش اقدار کی گنتی کرنی چاہئے اور بٹ سرنی میں متعلقہ بٹس کو 1 پر طے کرنا چاہئے۔بلوم فلٹر میں اور دوسری صورت میں غلط۔اس طریقہ کار کو K ہیش کے افعال کا استعمال کرتے ہوئے عنصر کی ہیش اقدار کی گنتی کرنی چاہئے اور یہ چیک کرنا چاہئے کہ آیا بٹ سرنی میں متعلقہ بٹس سبھی ہیں۔ ہر ایک کی مثال کے طور پر ازگر میں بلوم فلٹر کی ایک مثال ہے: پائیتھونیمپورٹ ایم ایم ایچ 3 سے بٹیرے امپورٹ بٹلریکلاس بلومفلٹر: ڈیف __ __init __خود ، ایم ، کے): سیلف۔ ایم = ایم سیلف۔1 ، سیلف۔آئٹم): self.bit_array [i] = 1 DEF پر مشتمل ہے (خود ، آئٹم): میں خود میں ہوں۔بلوم فلٹر کی نمائندگی کرتا ہے۔کلاس میں سائز میٹر کی تھوڑی سی صف اور کے ہیش افعال کی فہرست ہے۔get_bit_array_indices () کا طریقہ ان پٹ کے طور پر عنصر لیتا ہے اور بٹ سرنی میں انڈیکس کی ایک فہرست واپس کرتا ہے جو عنصر کی ہیش اقدار کے مطابق ہوتا ہے۔ADD () طریقہ ایک عنصر کو ان پٹ کے طور پر لیتا ہے اور بٹ سرنی میں متعلقہ بٹس کو 1 میں ترتیب دے کر بلوم فلٹر میں داخل کرتا ہے۔اور غلط دوسری صورت میں یہ جانچ کر کے کہ آیا بٹ سرنی میں متعلقہ بٹس سبھی ہیں۔ 1. بلوم فلٹر کلاس کا ایک مثال استعمال ہے: پائیتھنبف = بلومفلٹر (100 ، 3) bf.add (\"ایپل\") bf.add (\"کیلے\")BF.ADD (\"اورنج\") پرنٹ (bf.contains (\"ایپل\")) # آؤٹ پٹ: ٹروپنٹ (bf.contains (\"ناشپاتیاں\")) # آؤٹ پٹ: فالسیتیس پروگرام سائز 100 کی تھوڑی سی صف کے ساتھ بلومفلٹر آبجیکٹ BF تشکیل دیتا ہےاور 3 ہیش کے افعال ، بلوم فلٹر میں ADD () طریقہ کار کا استعمال کرتے ہوئے تین عناصر شامل کرتے ہیں ، اور اگر دو عناصر پر مشتمل () طریقہ () کے طریقہ کار کا استعمال کرتے ہوئے بلوم فلٹر میں ہیں تو چیک کریں۔آؤٹ پٹ بالترتیب صحیح اور غلط ہے"
    },
    {
        "Question": "وقفوں کی دی گئی فہرست میں زیادہ سے زیادہ اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "وقفوں کی ایک دی گئی فہرست میں اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ان کے آغاز کے اوقات کی بنیاد پر وقفوں کو ترتیب دیں۔ دو متغیرات کو ختم کریں: میکس_ اوورلیپس اور کرنٹ_ورلاپس کو ترتیب دیئے گئے وقفوں کے اوپر اور ہر وقفے کے لئے 0.، موجودہ_ اوورلیپس 1 کے ذریعہ اور اپ ڈیٹ کریں میکس_ اوورلاپس اگر موجودہ_ اوورلاپس میکس_ اوورلپس سے زیادہ ہے۔ ہر وقفہ کے لئے ، کمی کی طرف سے 1 کی طرف سے کمی کا وقت 1 سے کم ہوتا ہے اگر اس کا اختتامی وقت اگلے وقفہ کے آغاز کے وقت سے کم یا اس کے برابر ہوتا ہے۔ ریٹرن میکس_ اوورلپس۔ ہر ایک مثال کے طور پر عمل درآمدازگر میں الگورتھم: پائیتھونڈف میکس_ اوورلیپنگ_ انٹولز (وقفے): وقفے۔سورٹ (کلیدی = لیمبڈا ایکس: ایکس [0]) میکس_ اوورلپس = 0 کرنٹ_ورلپس = 0 میں I کے لئے رینج (لین (وقفے)): موجودہ_ اوورلپس += 1 اگر میں <لین (اگر میں <<وقفے) - 1 اور وقفے [i] [1]> وقفے [i + 1] [0]: میکس_ اوورلپس = زیادہ سے زیادہ (زیادہ سے زیادہ_ اوورلپس ، کرنٹ_ اوورلاپس) دوسری: زیادہ سے زیادہ_ اوورلپس = زیادہ سے زیادہ (میکس_ اوورلپس ، کرنٹ_ اوورلیپس) کرنٹ_ اوورلپس = 0 ریٹرن میکس_ اوورلپس ایک فنکشن کی وضاحت کرتا ہے۔MAX_OVERLAPPER_INTERVALS () جو ان پٹ کے طور پر وقفوں کے وقفوں کی ایک فہرست لیتا ہے اور فہرست میں زیادہ سے زیادہ اوور لیپنگ وقفوں کی تعداد واپس کرتا ہے۔یہ ان کے آغاز کے اوقات کی بنیاد پر وقفوں کو چھانٹ کر اور پھر ترتیب دیئے گئے وقفوں پر تکرار کرکے یہ کام کرتا ہے۔ہر وقفے کے ل it ، اس میں موجودہ_ اوورلیپس 1 میں اضافہ ہوتا ہے اور میکس_ اوورلیپس کو اپ ڈیٹ کرتا ہے اگر موجودہ_ اوورلاپس میکس_ اوورلاپس سے زیادہ ہے۔اگر موجودہ وقفہ کا آخری وقت اگلے وقفہ کے آغاز کے وقت سے کم یا اس کے برابر ہے تو اس میں موجودہ_ورلاپ 1 کی کمی بھی ہے۔اس کے بعد فنکشن میکس_ اوورلپس کو لوٹاتا ہے۔ یہاں میکس_ اوورلیپنگ_ انٹرولز () فنکشن کا ایک مثال استعمال ہے: ازگرینٹرلز = [(0 ، 2) ، (3 ، 7) ، (4 ، 6) ، (7 ، 8) ، (1 ، 5)]]]]]]میکس_ اوورلیپس = میکس_ اوورلیپنگ_ انٹروئولز (وقفے) پرنٹ (میکس_ اوورلیپس) # آؤٹ پٹ: 3 اس پروگرام کے وقفوں کے وقفوں کی ایک فہرست تشکیل دیتی ہے ، ان پٹ کے طور پر فہرست کے ساتھ میکس_ اوورلیپنگ_ انٹروئولز () فنکشن کو کال کرتی ہے ، اور فہرست میں اوور لیپنگ کے وقفوں کی زیادہ سے زیادہ تعداد کو پرنٹ کرتی ہے۔اس معاملے میں آؤٹ پٹ 3 ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا دیئے گئے نمبر تینوں کی طاقت ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد تینوں کی طاقت ہے ، اس کے مختلف نقطہ نظر ہیں۔یہاں کچھ وسائل ہیں جو مختلف نقطہ نظر کو نافذ کرنے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: ٹیوٹوریلس پوائنٹ: 1 جیکسفورجیکس: 2 اسٹیک اوور فلو: 3W3reSource: 4leetCode: 5educative.io: 6 ہیرے کی مثال کے طور پر پائیٹون میں الگورتھم کا نفاذ: Pythondef IS_POWER_OF_THERE (N)0: غلط واپس لوٹیں جبکہ n ٪ 3 == 0: n // = 3 ریٹرن n == 1 یہ پروگرام ایک فنکشن کی وضاحت کرتا ہے IS_POWER_OF_THERE () جو ایک نمبر N کو ان پٹ کے طور پر لیتا ہے اور اگر نمبر تین کی طاقت ہے اور غلط ہے تو دوسری صورت میںیہ جانچ کر کے یہ کام کرتا ہے کہ آیا نمبر 0 سے کم یا اس کے برابر ہے اور اگر یہ ہے تو غلط لوٹانا۔اس کے بعد اس کی تعداد کو 3 تک تقسیم کرتا ہے جب تک کہ یہ 3 تک تقسیم ہوتا ہے اور اگر تقسیم کے بعد 1 بن جاتا ہے اور دوسری صورت میں غلط ہوتا ہے تو اس کی قیمت درست ہوجاتی ہے۔ یہاں IS_POWER_OF_THERE () فنکشن کا ایک مثال استعمال ہے: pythonn1 = 27n2 = 45 پرنٹ (IS_POWER_OF_THERE (N1) # آؤٹ پٹ: ٹروپنٹ (is_power_of_three (n2)) # آؤٹ پٹ: فالسیتس پروگرام دو نمبر N1 اور N2 تخلیق کرتا ہے ، IS_POWER_OF_THERE () کو ان پٹ کے طور پر دو نمبروں کے ساتھ کال کرتا ہے ، اور پرنٹ کرتا ہے کہ آیا ہر تعداد تین کی طاقت ہے یا نہیں۔آؤٹ پٹ بالترتیب صحیح اور غلط ہے"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ کسی دیئے گئے تار میں زیادہ تر K الگ الگ کرداروں کے ساتھ سب سے طویل پیلنڈرومک سٹرنگ تلاش کی جاسکے۔",
        "Answer": "کسی دیئے گئے تار میں زیادہ تر K الگ الگ حروف کے ساتھ سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: تار میں ہر کردار پر تکرار کریں اور اسے کسی ممکنہ پیلنڈرووم کا مرکز سمجھتے ہیں۔اگر مرکز کے دونوں اطراف کے کردار ایک جیسے ہیں۔اگر وہ ہیں تو ، پالنڈوم کو بڑھانا جاری رکھیں۔: اگر نہیں s: واپس کریں \"\" n = len (s) سب سے طویل_palindrome = \"\" I کے لئے (n): j = i جبکہ j <n اور لین (Set (s [i: j+1])) <=K: if s [i: j+1] == s [i: j+1] [::-1]: اگر لین (s [i: j+1])> لین (سب سے طویل_palindrome): طویل ترین_پال انڈرووم = s [I: J +1] J += 1 سب سے طویل ترین_پالندروومیٹیس پروگرام ایک فنکشن کی وضاحت کرتا ہے۔یہ تار میں ہر کردار پر تکرار کرکے اور اسے ممکنہ پیلنڈرووم کا مرکز سمجھا جاتا ہے۔اس کے بعد یہ جانچ کر کے مرکز کے چاروں طرف پیلنڈرووم کو وسعت دیتا ہے کہ آیا مرکز کے دونوں اطراف کے حروف ایک جیسے ہیں یا نہیں۔اگر وہ ہیں تو ، یہ پیلنڈرووم کو بڑھانا جاری رکھے ہوئے ہے۔اگر وہ نہیں ہیں تو ، یہ پیلنڈرووم کو بڑھانا بند کردیتا ہے۔) # آؤٹ پٹ: \"بی سی بی ڈی بی ڈی بی بی ڈی سی ڈی\" یہ پروگرام ایک تار اور ایک عدد کے K کی تشکیل کرتا ہے ، سب سے طویل_palindromic_substring_with_k_distinct_characters () کو ان پٹ کے طور پر تار اور عددی کے ساتھ کام کرتا ہے ، اور ایس کے سب سے زیادہ K کے الگ الگ کرداروں میں سب سے طویل پیلنڈروومک سبسٹرنگ پرنٹ کرتا ہے۔آؤٹ پٹ اس معاملے میں \"BCBDBDBBBDCD\" ہے"
    },
    {
        "Question": "ایک لاحقہ درخت کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور ذیلی جگہوں کی تلاش کے ل methods طریقوں کو نافذ کریں۔",
        "Answer": "ایک لاحقہ درخت کی نمائندگی کرنے اور سبسٹرانگز کی تلاش کے طریقوں کو نافذ کرنے کے لئے ایک ازگر کلاس بنانے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک کلاس لاحقہ کی وضاحت کریں جو لاحقہ درخت کی نمائندگی کرتا ہے۔کلاس میں درخت میں تار داخل کرنے اور درخت میں ایک تار کی تلاش کرنے کے لئے جڑ کا نوڈ اور طریقے ہونا چاہئے۔اس طریقہ کار کو لاحقہ درخت کی تعمیر کے لئے یوکونن کے الگورتھم کا استعمال کرنا چاہئے۔ لاحقہ لاحقہ طبقے میں تلاش () کا طریقہ کار جو ان پٹ کے طور پر ایک سٹرنگ لیتا ہے اور اگر سٹرنگ لاحقہ درخت میں ہے اور غلط ہے۔اس طریقہ کار کو لاحقہ درخت کو عبور کرنا چاہئے۔ یہاں کچھ ایسے وسائل ہیں جو لاحقہ درختوں کو نافذ کرنے اور ذیلی جگہوں کی تلاش کی مزید معلومات اور مثالیں فراہم کرتے ہیں: سی ایم یو لیکچر نوٹ: 1 فیوٹیوٹر: 2 گیتھب: 3 جیکفورجیکس: 4 بیلیڈنگ: 5 کوڈنگ نینجاس: 6 ایک مثال کے طور پر عمل درآمد ہے۔ازگر میں لاحقہ درخت کا: پائیتھنکلاس نوڈ: ڈیف __init __ (خود ، شروع ، اختتام): سیلف اسٹارٹ = اسٹارٹ اسٹارٹ = اسٹارٹ سی ای این ڈی = اینڈ خود کو۔= string self.root = نوڈ (-1 ، -1) self.nodes = [self.root] sellself.add_suffix (i) def add_suffix (خود ، i): موجودہ = سیلف.روٹ j = i جبکہ j <len (self.string): اگر sell.جبکہ k <= node.end and self.string [j] == self.String [k]: j += 1 k += 1 اگر k <= node.end: split_node = نوڈ (نوڈ.ایسٹ ، k - 1) نوڈ۔ اسٹارٹ = k split_node.children [self.String [k]] = نوڈ کرنٹ۔ چائلڈین [self.string [j]] = split_node self.nodes.append (split_node) موجودہ = نوڈ ڈیف سرچ (خود ، سبسٹرنگ): کرنٹ = سیلف.روٹ I = 0 جبکہ میں <لین (سبسٹرنگ): اگر سبسٹرنگ [i] موجودہ میں نہیں۔ بچوں کو واپس کریں: غلط اور واپس کریں: نوڈ = کرنٹ۔ بچوں [سبسٹرنگ [i]] j = نوڈ۔ اسٹارٹ جبکہ جے<= node.end اور i <len (string) اور سبسٹرنگ [i] == self.String [j]: i += 1 j += 1 اگر j> نوڈ.اینڈ: موجودہ = نوڈ: غلط واپسی ٹریٹیسپروگرام ایک کلاس نوڈ کی وضاحت کرتا ہے جو لاحقہ درخت میں ایک نوڈ کی نمائندگی کرتا ہے اور ایک کلاس لاحقہ جو لاحقہ درخت کی نمائندگی کرتا ہے۔نوڈ کلاس میں ایک اسٹارٹ اور اینڈ انڈیکس اور بچوں کے نوڈس کی لغت ہے۔لاحقہ کلاس میں جڑ نوڈ اور درخت میں نوڈس کی ایک فہرست ہے۔لاحقہ کلاس میں بلڈ () کا طریقہ یوکونن کے الگورتھم کا استعمال کرتے ہوئے لاحقہ درخت کی تعمیر کرتا ہے۔لاحقہ کلاس میں add_suffix () کا طریقہ درخت کو درخت سے عبور کرکے اور ضرورت کے مطابق نوڈس کو شامل کرکے درخت میں ایک لاحقہ شامل کرتا ہے۔لاحقہ طبقے میں تلاش () کا طریقہ درخت میں ٹریورنگ کرکے اور یہ جانچ پڑتال کرکے درخت میں درختوں میں ڈھلنے کی تلاش کرتا ہے۔ یہاں لاحقہ لاحقہ کلاس کا ایک مثال استعمال ہے: پیتھنسٹرنگ = \"کیلے\" لاحقہ_ٹری = لاحقہ (سٹرنگ)سبسٹرنگ 1 = \"عنا\" سبسٹرنگ 2 = \"anb\" پرنٹ (لاحقہ_ٹری.سرچ (سبسٹرنگ 1)) # آؤٹ پٹ: ٹروپنٹ (لاحقہ_ ٹری۔ سرچ (سبسٹرنگ 2)) # آؤٹ پٹ: فالسیتھس پروگرام لاحقہ درخت کی تشکیل کرتا ہے ، لاحقہ لاحقہ درخت کی تشکیل کرتا ہے ،اور تلاش () کے طریقہ کار کا استعمال کرتے ہوئے دو سبسٹرنگز کی تلاش۔آؤٹ پٹ بالترتیب صحیح اور غلط ہے"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا تاثرات کی اجازت ملتی ہے ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک خالی اسٹیک بنائیں۔ تار میں ہر کردار پر مبنی اور اگر کردار ایک ہے اور اگر کردار ایک ہے۔قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی ، اسے اسٹیک پر دھکیلیں۔ اگر کردار اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی ہے تو ، اسٹیک سے اوپر والے عنصر کو پاپ کریں اور چیک کریں کہ آیا یہ اختتامی کردار سے مماثل ہے یا نہیں۔اگر یہ مماثل نہیں ہے تو ، اظہار درست نہیں ہے۔ اگر تمام حرفوں پر تکرار کرنے کے بعد اسٹیک خالی ہے تو ، اظہار درست ہے۔ اگر تمام کرداروں پر تکرار کرنے کے بعد اسٹیک خالی نہیں ہے تو ، اظہار درست نہیں ہے۔ یہاں کچھ وسائل ہیں۔جو اس نقطہ نظر کو عملی جامہ پہنانے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: گیکسفورجیکس: 1 کوڈنگ ننجا: 2 فائیو ٹیوٹر: 3leetcode: 4baeldung: 5 اسٹیک اوور فلو: 6 ہیرے کی ایک مثال کے طور پر ازگر میں الگورتھم کا نفاذ: Pythondef is_valid_expression (s): اسٹیک = [] [] اسٹیک = []]اگر c in \"({[\": stack.append (c) elif c in \")}]\": اگر اسٹیک نہیں ہے تو: غلط واپس کریں اگر c == \")\" اور اسٹیک [-1]! = \"(\": واپسغلط if c == \"}\" اور اسٹیک [-1]! = \"{\": جھوٹا لوٹ اگر c == \"]\" اور اسٹیک [-1]! = \"[\": غلط اسٹیک۔ پاپ () واپس نہیںاسٹیکتس پروگرام ایک فنکشن کی وضاحت کرتا ہے IS_Valid_expression () جو ایک تار کو ان پٹ کے طور پر لیتا ہے اور اگر اظہار درست اور غلط ہے تو وہ درست لوٹاتا ہے۔یہ ایک خالی اسٹیک بنا کر اور تار میں ہر کردار پر تکرار کرکے یہ کام کرتا ہے۔اگر کردار افتتاحی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی ہے تو ، یہ اسے اسٹیک پر دھکیل دیتا ہے۔اگر کردار اختتامی قوسین ، بریکٹ ، یا گھوبگھرالی منحنی خطوط وحدانی ہے تو ، یہ اسٹیک سے ٹاپ عنصر کو پاپ کرتا ہے اور اگر یہ اختتامی کردار سے میل کھاتا ہے تو چیک کرتا ہے۔اگر یہ مماثل نہیں ہے تو ، اظہار درست نہیں ہے۔اگر تمام کرداروں پر تکرار کرنے کے بعد اسٹیک خالی ہے تو ، اظہار درست ہے۔اگر تمام کرداروں پر تکرار کرنے کے بعد اسٹیک خالی نہیں ہے تو ، اظہار درست نہیں ہے۔ IS_Valid_expression () فنکشن کا ایک مثال استعمال: Pythonexpression1 = \"{[() ()]}\" اظہار 2 = \"[(])\" پرنٹ۔آؤٹ پٹ بالترتیب صحیح اور غلط ہے۔اگر ان پٹ اظہار میں دوسرے کردار شامل ہیں تو ، ان کو نظرانداز کردیا جائے گا۔اگر ان پٹ اظہار میں دوسری قسم کی بریکٹ ، جیسے زاویہ بریکٹ یا مربع بریکٹ شامل ہیں تو ، ان کو غلط حروف کے طور پر سمجھا جائے گا۔"
    },
    {
        "Question": "ایک سٹرنگ کو دو غیر خالی پیلنڈرومک سبسٹرنگز میں تقسیم کرنے کے طریقوں کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "تار کو دو غیر خالی پیلنڈرومک سبسٹرنگز میں تقسیم کرنے کے طریقوں کی تعداد تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: تار میں ہر انڈیکس پر تکرار کریں اور اسے کسی ممکنہ پیلنڈرووم کا مرکز سمجھتے ہیں۔چیک کر رہے ہیں کہ آیا مرکز کے دونوں طرف حروف ایک جیسے ہیں۔اگر وہ ہیں تو ، پالنڈوم کو بڑھانا جاری رکھیں۔اگر وہ نہیں ہیں تو ، پیلیندرووم کو وسعت دینا بند کریں۔ پائے جانے والے ہر پیلنڈرووم کے لئے ، پیلنڈرووم کے بیچ میں تار کو دو ذیلی ذخیروں میں تقسیم کریں اور چیک کریں کہ کیا دونوں ذیلی ذخیرے پیلنڈرومک ہیں۔ اگر دونوں ذیلی ذخیرے ہیں تو ، تار کو تقسیم کرنے کے طریقوں کی گنتی میں اضافہ کریں۔. سٹرنگ کو تقسیم کرنے کے طریقوں کی گنتی کا آغاز کریں۔ یہاں کچھ ایسے وسائل ہیں جو اس نقطہ نظر کو نافذ کرنے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: گیکسفورجیکس: 1leetcode: 2Codeforces: 3 ہیرے کی مثال کے طور پر ازگر میں الگورتھم کا نفاذ: Pythondef count_palindromic_substrings: n = =لین (s) گنتی = 0 کے لئے i in range (n): j = i جبکہ j <n اور s [i: j+1] == s [i: j+1] [::-1]: اگر j- i> 0: بائیں = s [: i]+s [i: j+1] دائیں = s [j+1:] اگر بائیں == بائیں [::- 1] اور دائیں == دائیں [::-1]: گنتی += 1 J += 1 ریٹرن کاؤنٹ یہ پروگرام ایک فنکشن COUNT_Palindromic_substrings () کی وضاحت کرتا ہے جو ان پٹ کے طور پر ایک تار لیتا ہے اور تار کو دو غیر خالی پیلنڈرومک سبسٹرنگ میں تقسیم کرنے کے طریقوں کی تعداد کو واپس کرتا ہے۔یہ تار میں ہر انڈیکس پر تکرار کرکے اور اسے ممکنہ پیلنڈرووم کا مرکز سمجھا جاتا ہے۔اس کے بعد یہ جانچ کر کے مرکز کے چاروں طرف پیلنڈرووم کو وسعت دیتا ہے کہ آیا مرکز کے دونوں اطراف کے حروف ایک جیسے ہیں یا نہیں۔اگر وہ ہیں تو ، یہ پیلنڈرووم کو بڑھانا جاری رکھے ہوئے ہے۔اگر وہ نہیں ہیں تو ، یہ پیلنڈرووم کو بڑھانا بند کردیتا ہے۔پائے جانے والے ہر پیلنڈرووم کے ل it ، یہ پیلنڈوم کے بیچ میں تار کو دو ذیلی ذخیروں میں تقسیم کرتا ہے اور اگر دونوں ذیلی ذخیرے پیلنڈرومک ہیں۔اگر دونوں ذیلی ذخیرے پالندرمک ہیں تو ، اس سے تار کو تقسیم کرنے کے طریقوں کی گنتی میں اضافہ ہوتا ہے۔اس کے بعد فنکشن سٹرنگ کو تقسیم کرنے کے طریقوں کی گنتی کو لوٹاتا ہے۔ یہاں گنتی_پالائنڈرمک_سبسٹرنگس () فنکشن کا ایک مثال استعمال: ازگر = \"اے بی بی اے\" گنتی = گنتی_پالائنڈرومک_سوبسٹرنگ (ایس) پرنٹ (گنتی) پرنٹ (گنتی) # آؤٹ پٹ: 1 اس پروگرام میں سٹرنگ ایس ، کالز تخلیق کرتا ہے۔گنتی_پالینڈرومک_سبسٹرنگس () ان پٹ کے طور پر تار کے ساتھ کام کرتی ہے ، اور تار کو دو غیر خالی پیلنڈرومک سبسٹرنگز میں تقسیم کرنے کے طریقوں کی تعداد کو پرنٹ کرتی ہے۔اس معاملے میں آؤٹ پٹ 1 ہے۔ نوٹ: یہ عمل درآمد فرض کرتا ہے کہ ان پٹ سٹرنگ میں صرف چھوٹے حرف ہوتے ہیں۔اگر ان پٹ سٹرنگ میں دوسرے حروف شامل ہیں تو ، ان کو غلط حروف کے طور پر سمجھا جائے گا۔اگر ان پٹ سٹرنگ میں بڑے حرف ہوتے ہیں تو ، ان کو ان کے چھوٹے ہم منصبوں سے مختلف کرداروں کے طور پر سمجھا جائے گا۔"
    },
    {
        "Question": "وقفوں کی دی گئی فہرست میں زیادہ سے زیادہ تعداد میں غیر اوورلیپنگ وقفوں کی تلاش کے لئے ایک پروگرام بنائیں۔",
        "Answer": "وقفوں کی دی گئی فہرست میں غیر اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: وقفوں کو ان کے اختتامی اوقات کی بنیاد پر ترتیب دیں۔ہر وقفہ ، اگر اس کا آغاز کا وقت اختتام_ٹ ٹائم سے زیادہ یا اس کے برابر ہے تو ، میکس_ انٹروولز 1 کے ذریعہ 1 اور موجودہ وقفہ کے اختتامی وقت پر اختتام_ وقت کو اپ ڈیٹ کریں۔وقفے.سورٹ (کلیدی = لیمبڈا x: x [1]) میکس_ انٹرولز = 0 اختتام_ وقت = 0 وقفوں میں وقفہ کے لئے: اگر وقفہ [0]> = اختتامی وقت: زیادہ سے زیادہ_ intervals += 1 اختتام_ وقت = وقفہ [1] میکس_نٹروولس پروگرام ایک فنکشن کی وضاحت کرتا ہےMAX_NON_OVERLIPEM_INTERVALS () جو ان پٹ کے طور پر وقفوں کے وقفوں کی ایک فہرست لیتا ہے اور فہرست میں غیر اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد واپس کرتا ہے۔یہ ان کے آخری اوقات کی بنیاد پر وقفوں کو چھانٹ کر اور پھر ترتیب شدہ وقفوں پر تکرار کرکے یہ کام کرتا ہے۔ہر وقفے کے ل it ، یہ چیک کرتا ہے کہ آیا اس کا آغاز وقت اختتام_ ٹائم سے زیادہ یا اس کے برابر ہے۔اگر یہ ہے تو ، اس میں MAX_INTERVALS 1 تک اضافہ ہوتا ہے اور موجودہ وقفہ کے آخری وقت تک اختتامی وقت کو اپ ڈیٹ کرتا ہے۔اس کے بعد یہ فنکشن میکس_ٹریللز کو لوٹاتا ہے۔ یہاں میکس_نون_ اوورلیپنگ_ انٹروئلس () فنکشن کا ایک مثال استعمال ہے: پائیتھوننٹورلز = [(0 ، 2) ، (3 ، 7) ، (4 ، 6) ، (7 ، 8) ، (1 ، 5)]]]MAX_INTERVALS = MAX_NON_OVERLAPE_INTERVALS (وقفے) پرنٹ (MAX_INTERVALS) # آؤٹ پٹ: 3 اس پروگرام کے وقفوں کے وقفوں کی ایک فہرست تشکیل دیتی ہے ، فہرست کے ساتھ میکس_نون_ اوورلیپنگ_ٹینٹرلز () کو ان پٹ کے ساتھ فون کرتی ہے ، اور فہرست میں زیادہ سے زیادہ تعداد میں غیر اوور لیپنگ وقفوں کی پرنٹ کرتی ہے۔اس معاملے میں آؤٹ پٹ 3 ہے"
    },
    {
        "Question": "لغت کے ترتیب میں عددیوں کی دی گئی فہرست کی اگلی اجازت پیدا کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "لغت کی ترتیب میں عددیوں کی دی گئی فہرست کی اگلی ترتیب پیدا کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: فہرست کے دائیں سرے سے شروع کرتے ہوئے ، پہلا عنصر تلاش کریں جو عنصر سے اس کے دائیں سے چھوٹا ہے۔اگر اس طرح کا کوئی عنصر موجود نہیں ہے تو ، فہرست پہلے ہی اپنے سب سے بڑے اجازت نامے میں ہے اور ہم اوپر کی ترتیب میں ترتیب دیئے گئے فہرست کو واپس کردیتے ہیں۔ فہرست کے دائیں سرے سے شروع کرتے ہوئے ، سب سے چھوٹا عنصر تلاش کریں جو مرحلہ 1. میں پائے جانے والے عنصر سے زیادہ ہے۔مرحلہ 1 اور 2. میں پائے جانے والے عناصر step میں پائے جانے والے عنصر کے دائیں طرف سبلسٹ کی تصدیق کریں۔ یہاں کچھ وسائل ہیں جو اس نقطہ نظر کو عملی جامہ پہنانے کی مزید معلومات اور مثالیں فراہم کرتے ہیں: اوٹی: 1 اسٹیک اوور فلو: 2 ٹاکیفورورڈ: 3 ٹیوٹوریالس پوائنٹ: 4youtube: 5Geeksforgeeks:6 ہیری میں ازگر میں الگورتھم کا ایک مثال عمل: پائیتھنڈف نیکسٹ_پرموٹیشن (نمبر): این = لین (نمبر) i = n - 2 جبکہ i> = 0 اور نمبر [i]> = nums [i + 1]: i - = 1]اگر i <0: nums.reverse () واپس nums j = n - 1 جبکہ j> i اور nums [j] <= nums [i]: j - = 1 nums [i] ، nums [j] = nums [j [j] ، نمبرز [i] نمبر [i+1:] = الٹ (نمبر [i+1:]) ریٹرن نمبر اس پروگرام میں ایک فنکشن کی وضاحت کی گئی ہے جو اگلے_پرموٹیشن () کو ان پٹ کے طور پر عددی نمبروں کی فہرست لیتا ہے اور فہرست کی اگلی ترتیب کو لوٹاتا ہے۔لغت میں۔یہ دائیں سے پہلے عنصر کو تلاش کرکے یہ کام کرتا ہے جو عنصر سے اس کے دائیں طرف سے چھوٹا ہے اور پھر دائیں سے سب سے چھوٹا عنصر ڈھونڈتا ہے جو پچھلے مرحلے میں پائے جانے والے عنصر سے زیادہ ہے۔اس کے بعد یہ دونوں عناصر کو تبدیل کرتا ہے اور سبلسٹ کو پہلے مرحلے میں پائے جانے والے عنصر کے دائیں طرف تبدیل کرتا ہے۔اگر پہلے مرحلے میں اس طرح کا کوئی عنصر موجود نہیں ہے تو ، وہ اوپر کی فہرست میں ترتیب دی گئی فہرست کو لوٹاتا ہے۔ یہاں نیکسٹ_پرموٹیشن () فنکشن کا ایک مثال استعمال ہے: پائیتھونومس = [1 ، 2 ، 3] نیکسٹ_نومز = نیکسٹ_پرموٹیشن (نمبر) پرنٹ (نیکسٹ_نومز) #آؤٹ پٹ: [1 ، 3 ، 2] یہ پروگرام انٹیگر نمبروں کی ایک فہرست تیار کرتا ہے ، فہرست کے ساتھ اگلے_پرموٹیشن () کو ان پٹ کے طور پر کال کرتا ہے ، اور لیکسیگرافک ترتیب میں فہرست کی اگلی ترتیب کو پرنٹ کرتا ہے۔اس کیس کو آؤٹ پٹ IS132IN ہے۔ نوٹ: اس عمل سے یہ فرض کیا گیا ہے کہ ان پٹ لسٹ میں صرف عددی ہوتا ہے۔اگر ان پٹ لسٹ میں دیگر قسم کے عناصر شامل ہیں تو ، ان کو غلط عناصر سمجھا جائے گا۔اگر ان پٹ لسٹ میں ڈپلیکیٹ عناصر شامل ہیں تو ، آؤٹ پٹ لیکسیگرافک آرڈر میں اگلی ترتیب ہوگی جو ان پٹ کی فہرست سے زیادہ ہے۔"
    },
    {
        "Question": "ایک سرخ رنگ کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "بہت سارے وسائل دستیاب ہیں جو نوڈس کو داخل کرنے اور تلاش کرنے کے لئے ازگر میں سرخ سیاہ درخت اور طریقوں کو نافذ کرنے کے بارے میں معلومات فراہم کرتے ہیں۔ان میں سے کچھ یہ ہیں: AskPython: 1Github: 2geeksforgeeks: 3BOOT.DEV بلاگ: 4 فائیوٹٹر: 5 اس وسائل کو سرخ سیاہ درختوں کی تفصیلی وضاحت ، کوڈ کی مثالوں اور عکاسی فراہم کرتے ہیں۔ایک خود توازن بائنری تلاش کا درخت جس میں ہر نوڈ سرخ یا سیاہ رنگ کا ہوتا ہے۔درخت میں مندرجہ ذیل خصوصیات ہیں: جڑ نوڈ سیاہ ہے۔ ہر پتی نوڈ سیاہ ہے۔ اگر نوڈ سرخ ہے ، تو اس کے دونوں بچے سیاہ ہیں۔ نوڈ سے اولاد کے پتے نوڈ تک ہر آسان راستہ سیاہ نوڈس پر مشتمل ہوتا ہے۔. سرخ رنگ کے درخت میں نوڈ داخل کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک معیاری بائنری سرچ ٹری داخل کریں۔ نیا نوڈ ریڈ۔جیسا کہ ضروری ہے۔ سرخ رنگ کے درخت میں نوڈ کی تلاش کے ل we ، ہم معیاری بائنری سرچ ٹری سرچ الگورتھم کا استعمال کرسکتے ہیں۔ یہاں ازگر میں سرخ رنگ کے درخت کی ایک مثال کے طور پر عمل درآمد: ازگر کلاس نوڈ: ڈیف __ __init __ (خود ، ویل):self.val = val self.left = کوئی نہیں۔ خود نہیں۔رائٹ_چلڈ.لفٹ اگر دائیں_کلیڈ۔ورنہ: نوڈ.پارینٹ. رائٹ = رائٹ_چلیڈ رائٹ_چلڈ۔نوڈ لیفٹ_ڈائلڈ.پارینٹ = نوڈ.پارینٹ اگر نہیں نوڈ۔ پیرنٹ: سیلف۔ روٹ = بائیں_چلی ایلف نوڈ == نوڈ.پارینٹ. رائٹ: نوڈ۔ پرینٹ. رائٹ = بائیں_چھال اور: نوڈ۔node.palent = بائیں_چڈ ڈیف داخل کریں (خود ، ویل): نوڈ = نوڈ (ویل) نوڈ.فینٹ = کوئی بھی نوڈ نہیں۔ وال = ویل نوڈ.لفٹ = کوئی بھی نہیں نوڈ نہیں۔. روٹ جبکہ موجودہ: والدین = موجودہ if node.val <موجودہ۔ وول: موجودہ = موجودہ۔ لیفٹ اور: موجودہ = موجودہ۔ رائٹ نوڈ.فینٹ = والدین اگر والدین نہیں ہیں تو: سیل.روٹ = نوڈ ایلف نوڈ.ول <والدین۔ویل: پیرنٹ. لیفٹ = نوڈ اور: والدین۔ رائٹ = نوڈ اگر نوڈ.فینٹ کوئی نہیں ہے: نوڈ.ایکولر = 0 واپسی اگر نوڈ.فینٹ.فینٹ کوئی بھی نہیں ہے۔: جبکہ نوڈ.فینٹ اور نوڈ۔ پیرینٹ.ایکولر == 1: اگر نوڈ.پارینٹ == نوڈ.پارینٹ.پارینٹ. رائٹ: انکل = نوڈ.پارینٹ.پینٹ.یلفٹ اگر انکل اور انکل۔ کلور == 1: نوڈ۔parent.color = 0 chank.color = 0 node.parent.parent.color = 1 نوڈ = نوڈ. پیرینٹ.پیئرنٹ اور: اگر نوڈ == نوڈ.پارینٹ.یلفٹ: نوڈ = نوڈ۔ پیرینٹ سیلف۔ روٹیٹ_ رائٹ (نوڈ).PARENT.COLOR = 0 node.parent.parent.color = 1 self.rotate_left (node.parent.parent) else: چچا = node.parent.parent.right اگر چچا اور چچا == 1: نوڈ.پینٹ۔رنگین = 0 انکل.کلور = 0 نوڈ.پارینٹ.پارینٹ.الور = 1 نوڈ = نوڈ.پارینٹ.پارینٹ دوسری: اگر نوڈ == نوڈ.پارینٹ. رائٹ: نوڈ = نوڈ.فینٹ سیلف۔.کولر = 0 نوڈ.پارینٹ.پارینٹ.الور = 1 سیلف۔ روٹیٹ_ رائٹ (نوڈ.پارینٹ.پارینٹ) سیلف.روٹ.ایوٹ۔ کالور = 0 ڈیف سرچ (سیلف ، ویل): موجودہ = سیلف۔ روٹ جبکہ موجودہ: اگر موجودہ۔== ویل: ریٹرن ٹرو ایلف کرنٹ۔ وول> ویل: کرنٹ = کرنٹ۔ لیفٹ اور: موجودہ = کرنٹ۔ رائٹ ریٹرن فالسیتیس پروگرام ایک کلاس نوڈ کی وضاحت کرتا ہے جو سرخ رنگ کے درخت میں نوڈ کی نمائندگی کرتا ہے اور کلاس `ریڈ بلک ٹری"
    },
    {
        "Question": "تین دیئے گئے تاروں کی طویل ترین مشترکہ حصول تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "تین دیئے گئے ڈوروں کی سب سے طویل عام مشترکہ حصول تلاش کرنے کے ل we ، ہم دو تاروں کے لئے طویل عرصے سے عام مشترکہ (LCS) الگورتھم کو تین تاروں تک بڑھا سکتے ہیں۔تینوں ڈوروں کے ایل سی ایس کو تینوں دیئے گئے سلسلے میں مشترکہ متضاد کی لمبائی کو ذخیرہ کرنے کے لئے 3D سرنی تشکیل دے کر متحرک پروگرامنگ کا استعمال کرتے ہوئے پایا جاسکتا ہے۔شامل کریں <cstring> نام اسپیس ایس ٹی ڈی کا استعمال کرتے ہوئے ؛ INT LCSOF3 (سٹرنگ X ، سٹرنگ Y ، سٹرنگ Z ، INT M ، INT N ، INT O) {INT L [M + 1] [N + 1] [O + 1] ؛(int i = 0 ؛ i <= m ؛ i ++) {for (int j = 0 ؛ j <= n ؛ j ++) {for (int k = 0 ؛ k <= o ؛ k ++) {اگر (i ==0 || j == 0 || k == 0) {l [i] [j] [k] = 0 ؛} ورنہ اگر (x [i - 1] == y [j - 1] && x [i - 1] == z [k - 1]) {l [i] [j] [k] = l [i -1] [J - 1] [K - 1] + 1 ؛} else {l [i] [j] [k] = زیادہ سے زیادہ (زیادہ سے زیادہ (l [i - 1] [j] [k] ، l [i] [j - 1] [k]) ، l [i] [J] [K - 1]) ؛}}}} واپسی l [m] [n] [o] ؛} انٹ مین () {سٹرنگ x = \"aggt12\" ؛سٹرنگ y = \"12txayb\" ؛سٹرنگ زیڈ = \"12xba\" ؛int m = x.length () ؛int n = y.length () ؛int o = z.length () ؛cout << \"تین تار کے LCs کی لمبائی ہے\" << lcsof3 (x ، y ، z ، m ، n ، o) << endl ؛واپس 0 ؛} اس عمل درآمد میں ، فنکشن LCSOF3 () تین تار x ، y ، اور z ان پٹ کے ساتھ ساتھ ان کی لمبائی M ، N ، اور O کے ساتھ لیتا ہے۔اس کے بعد یہ تینوں دیئے گئے سلسلے میں مشترکہ مشترکہ کی لمبائی کو ذخیرہ کرنے کے لئے ایک 3D سرنی L تشکیل دیتا ہے۔اس کے بعد فنکشن متحرک پروگرامنگ کا استعمال کرتے ہوئے تھری ڈی سرنی کو بھرتا ہے اور تینوں اسٹرنگس 12.1 جی ای ای ایکسفورجیکس 2 انکلیڈ ہیلپ کے ایل سی ایس کی لمبائی کو لوٹاتا ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر چار کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے بہت سے طریقے ہیں کہ آیا ایک دیئے گئے نمبر چار کی طاقت ہے یا نہیں۔ایک آسان حل یہ ہے کہ نمبر کو 4 سے بار بار تقسیم کریں اور یہ چیک کریں کہ آیا recursive ڈویژن کے بعد کی قیمت 11 بن جاتی ہے۔ دوسرا حل یہ ہے کہ نمبر کو 4 سے تقسیم کرنے کے لئے ایک لوپ کا استعمال کریں جب تک کہ یہ 4 سے کم نہ ہو12. تیسرا حل یہ ہے کہ بٹ وائز آپریٹرز کو یہ چیک کرنے کے لئے استعمال کیا جائے کہ آیا نمبر کی بائنری نمائندگی میں صرف ایک سیٹ بٹ ہے اور یہاں تک کہ پوزیشن 3 میں کوئی اور سیٹ بٹس نہیں ہیں۔#شامل کریں <iostream> نام کی جگہ STD کا استعمال کرتے ہوئے Bool بول آئس پاور آفور (انٹ NUM) {اگر (num <= 0) {غلط واپس ؛} جبکہ (num> = 4) {اگر (نمبر ٪ 4! = 0) {غلط واپس ؛} نمبر /= 4 ؛} واپس نمبر == 1 ؛} انٹ مین () {انٹ NUM = 64 ؛اگر (آئس پاور آفور (نمبر)) {cout << num << \"4 کی طاقت ہے\" << اینڈل ؛} دوسری {cout << num << \"4 کی طاقت نہیں ہے\" << اینڈل ؛} واپس 0 ؛} اس نفاذ میں ، فنکشن آئس پاور آفور () ان پٹ کے طور پر ایک عدد نمبر لیتا ہے اور اگر نمبر 4 کی طاقت ہے ، اور دوسری صورت میں غلط ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا نمبر 0 سے کم یا اس کے برابر ہے ، اور اگر ایسا ہے تو ، غلط لوٹتا ہے۔اس کے بعد یہ NUM کو 4 سے تقسیم کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے جب تک کہ یہ 4 سے کم نہ ہو۔ اگر NUM کسی بھی موقع پر 4 سے تقسیم نہیں ہوتا ہے تو ، فنکشن غلط لوٹتا ہے۔آخر میں ، فنکشن چیک کرتا ہے کہ اگر NUM 1 کے برابر ہے ، اور اگر ایسا ہے تو ، سچ 2.1 ٹیوٹورالس پوائنٹ 2 ہیلو اے سی ایم 3 اوپنینس واپس کرتا ہے"
    },
    {
        "Question": "\"ہر سکے کے فرق کی محدود فراہمی کے ساتھ ، تبدیلی کی ایک مقررہ رقم بنانے کے لئے کم سے کم تعداد میں سککوں کی تلاش کے ل a ایک پروگرام لکھیں۔\"",
        "Answer": "ہر سکے کے فرق کی محدود فراہمی کے ساتھ ایک مخصوص مقدار میں تبدیلی کے ل needed کم سے کم سکے کی تلاش کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ ہر قیمت میں 0 سے دی گئی تبدیلی کی مقدار میں تبدیلی کے ل needed ضروری سککوں کی کم سے کم تعداد کو ذخیرہ کرنے کے لئے ایک صف تیار کرنا ہے۔اس کے بعد ہم ہر سکے کے فرق کے ذریعے تکرار کرسکتے ہیں اور اس سکے کے فرق کو استعمال کرکے ہر قیمت کے لئے صف کو اپ ڈیٹ کرسکتے ہیں۔سرنی میں حتمی قیمت دی گئی رقم 12 کے لئے تبدیلی کے ل needed درکار سککوں کی کم سے کم تعداد ہوگی۔ C ++ میں اس نقطہ نظر کا نفاذ ہے: C ++#شامل <iostream>#آب و ہوا> نام اسپیس ایس ٹی ڈی کا استعمال کرتے ہوئے ؛ INT MINCOINS (INT MINT MINCOINS (INTسکے [] ، انٹ ایم ، انٹ وی) {انٹ ڈی پی [وی + 1] ؛ڈی پی [0] = 0 ؛کے لئے (int i = 1 ؛ i <= v ؛ i ++) {dp [i] = int_max ؛} for (int i = 0 ؛ i <m ؛ i ++) {for (int j = coins [i] ؛ j <= v ؛ j ++) {اگر (dp [j - cins [i]]! = int_max) {dp[j] = منٹ (ڈی پی [جے] ، ڈی پی [جے - سکے [i]] + 1) ؛}}} واپسی DP [v] == انٹ_میکس؟-1: dp [v] ؛} انٹ مین () {انٹ سکے [] = {1 ، 5 ، 10 ، 25} ؛انٹ ایم = سائز (سکے) / سائز (سکے [0]) ؛int v = 30 ؛انٹ منوونٹ = منکوائنز (سکے ، ایم ، وی) ؛اگر (MINCOUNT == -1) {cout << \"\" << v << endl کے لئے تبدیلی کرنا ممکن نہیں ہے۔} else {cout << \"کم سے کم\" << منوونٹ << \"سکے\" << v << endl کے لئے تبدیلی کے لئے درکار سکے ؛} واپس 0 ؛} اس نفاذ میں ، فنکشن منکوائنز () سکے کے فرقوں کے سکے ، سکے کے فرقوں کی تعداد ، اور ان پٹ کے بطور تبدیلی V کی مقدار لیتا ہے۔فنکشن سب سے پہلے 0 سے V میں ہر قیمت میں تبدیلی لانے کے لئے درکار سکے کی کم سے کم تعداد کو ذخیرہ کرنے کے لئے ایک سرنی ڈی پی بناتا ہے۔ یہ صف میں پہلی قیمت 0 اور دیگر تمام اقدار کو انفینٹی میں شروع کرتا ہے۔اس کے بعد فنکشن ہر سکے کے فرق کے ذریعے تکرار کرتا ہے اور ہر قیمت کے لئے صف کو اپ ڈیٹ کرتا ہے جو اس سکے کے فرق کو استعمال کرکے بنایا جاسکتا ہے۔آخر میں ، فنکشن تبدیلی کی مقررہ رقم کے لئے صف میں قیمت لوٹاتا ہے ، یا -1 اگر اس رقم میں تبدیلی کرنا ممکن نہیں ہے تو اس رقم میں تبدیلی کرنا ممکن نہیں ہے۔"
    },
    {
        "Question": "ایک لاحقہ سرنی کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور ذیلی جگہوں کی تلاش کے ل methods طریقوں کو نافذ کریں۔",
        "Answer": "ایک لاحقہ سرنی کی نمائندگی کرنے اور سبسٹرانگز کی تلاش کے ل methods طریقوں کو نافذ کرنے کے لئے ایک ازگر کی کلاس بنانے کے ل we ، ہم کسی دیئے گئے تار کے تمام لاحقہ کی ایک صف تیار کرنے اور پھر لچکدار طور پر چھانٹنے کے لئے لاحقہ سرنی کو حاصل کرنے کے نقطہ نظر کو استعمال کرسکتے ہیں۔اس کے بعد ہم لاحقہ سرنی 12 میں ذیلی ذخیروں کی تلاش کے لئے بائنری سرچ کا استعمال کرسکتے ہیں۔ یہاں ایک لاحقہ سرنی کے لئے ایک ازگر کلاس کا نفاذ ہے: پائیتھنکلاس لاحقہ: Def __init __ (خود ، s): self.s = s self.n = len (s) self.suffixes = [s [i:] کے لئے I in range (self.n)] sell، پیٹرن): ایم = لین (پیٹرن) بائیں ، دائیں = 0 ، سیلف۔ این - 1 جبکہ بائیں <= دائیں: درمیانی = (بائیں + دائیں) // 2 لاحقہ = سیلف۔ سوفکس [سیل.فکس_ریری [وسط]]اگر پیٹرن> لاحقہ: بائیں = وسط + 1 الیف پیٹرن <لاحقہ: دائیں = وسط - 1 اور: خود واپس کریں۔ suffix_array [MID] واپسی -1 -1 اس پر عمل درآمد میں ، لاحقہ کلاس ان پٹ کے طور پر ایک تار لیتا ہے اور لاحقہ لاحقہ سرنی کو شروع کرتا ہےلاحقہ کے ترتیب شدہ اشاریوں کو تھامنے کے لئے ایس اور لاحقہ_ اری سرنی کے تمام لاحقہ تھامیں۔تلاش کا طریقہ ان پٹ کے طور پر ایک پیٹرن کی تار لیتا ہے اور لاحقہ سرنی میں پیٹرن کے پہلے واقعے کا انڈیکس تلاش کرنے کے لئے لاحقہ_ری سرنی پر بائنری تلاش کرتا ہے۔اگر پیٹرن نہیں مل جاتا ہے تو ، طریقہ کار -11. یہاں لاحقہ لاحقہ کلاس کا ایک مثال استعمال ہے: ازگر = \"کیلے\" سا = لاحقہ (s) پرنٹ (sa.suffix_array) # پرنٹس [5 ، 3 ، 1 ، 0 ،4 ، 2] پرنٹ (sa.search (\"ana\")) # پرنٹ 1 پرنٹ (sa.search (\"xyz\")) # پرنٹس -1 اس مثال کے طور پر ، ہم \"کیلے\" کے تار کے لئے ایک لاحقہ لاحقہ آبجیکٹ بناتے ہیں اور ترتیب دیئے گئے پرنٹ کرتے ہیںلاحقہ_ری۔اس کے بعد ہم لاحقہ سرنی میں \"عنا\" کے نمونے کی تلاش کرتے ہیں اور پہلے واقعہ کے اشاریہ کو پرنٹ کرتے ہیں ، جو 1 ہے۔ آخر کار ، ہم اس نمونہ \"XYZ\" کی تلاش کرتے ہیں جو لاحقہ سرنی میں موجود نہیں ہے۔"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "کسی فنکشن کو عملی جامہ پہنانے کے ل a کسی فنکشن کو متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے نیسٹڈ اظہارات کی اجازت دی جاسکتی ہے ، ہم افتتاحی علامتوں اور پاپ کو ٹریک رکھنے کے لئے ایک اسٹیک کا استعمال کرسکتے ہیں۔جب ہمیں کسی اختتامی علامت کا سامنا کرنا پڑتا ہے تو وہ اسٹیک سے دور رہتے ہیں۔اگر اختتامی علامت اسٹیک کے اوپری حصے سے مماثل ہے تو ، ہم جاری رکھیں۔بصورت دیگر ، اظہار متوازن نہیں ہے۔ہم کوڈ کو مزید جامع 12 بنانے کے لئے افتتاحی اور اختتامی علامتوں کا نقشہ بنانے کے لئے ایک لغت کا استعمال بھی کرسکتے ہیں۔ یہاں ازگر میں فنکشن کا نفاذ ہے: پائیتھونڈف آئی ایس_والیڈ_ ایکسپریشن (ایس): اسٹیک = [] میپنگ = {')': '(' ، '،']:' ['،'} ':' {'،'> ':' <'،'/':'/'} quots = [' '' '،' '،' '،' `']ایس: اگر میپنگ میں سی۔اس پر عمل درآمد کو اسٹیک کریں ، فنکشن IS_Valid_expression () ان پٹ کے طور پر ایک تار لیتا ہے اور اگر سٹرنگ متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات ، اور جھوٹے ویسے ہی اجازت دی جاتی ہے۔. فنکشن پہلے ایک خالی اسٹیک اور ایک لغت کی نقشہ سازی کا آغاز کرتا ہے تاکہ اختتامی علامتوں کو ان کے اسی افتتاحی علامتوں کا نقشہ بنایا جاسکے۔ اس کے بعد تار میں ہر کردار کے ذریعے تکرار ہوتا ہے اور اسٹیک پر افتتاحی علامتوں اور حوالہ جات کو دھکیل دیتا ہے۔اگر اس کا اختتامی علامت کا سامنا کرنا پڑتا ہے تو ، یہ اسٹیک کے اوپری حصے کو پاپ کرتا ہے اور چیک کرتا ہے کہ اگر یہ اسی افتتاحی علامت سے مماثل ہے۔اگر نہیں تو ، فنکشن غلط لوٹتا ہے۔آخر میں ، اگر اسٹیک خالی ہے تو ، فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ تمام علامتیں مماثل ہوچکی ہیں ، اور دوسری صورت میں غلط ہے۔اگر is_valid_expression (s): پرنٹ (f '{s} ایک درست اظہار ہے') اور: پرنٹ (f '{s} ایک درست اظہار نہیں ہے') اس مثال میں ، ہم چیک کرتے ہیں کہ سٹرنگ ایس کے ساتھ ایک درست اظہار ہے یا نہیں۔متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، قیمتیں ، زاویہ بریکٹ اور سلیش ، جس سے گھریلو تاثرات کی اجازت مل جاتی ہے۔فنکشن سچ کی طرف لوٹتا ہے ، اس بات کی نشاندہی کرتا ہے کہ ایس ایک درست اظہار 12.1 جیکسفورجیکس 2leetCode ہے"
    },
    {
        "Question": "کسی دیئے گئے تار میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے",
        "Answer": "دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد کی لمبائی تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم دیئے گئے تار کے ہر ایک حص to ہ کے ل the لمبے لمبے پیلنڈرومک متضاد کی لمبائی کو ذخیرہ کرنے کے لئے 2D سرنی تشکیل دے سکتے ہیں۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو پُر کرسکتے ہیں: اگر سبسٹرنگ میچ کے پہلے اور آخری حروف ، لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے ہیں۔بصورت دیگر ، لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے ہیںپورے سٹرنگ 12 کے لئے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف طویل ترین_پالندروومک_سوبسینس (ایس): این = لین (ایس) ڈی پی = [[0] * این رینج میں (این)] کے لئے (این) کے لئے (n):dp [i] [i] = 1 میں I کے لئے رینج (n -1 ، -1 ، -1): J کے لئے رینج (i + 1 ، n): اگر s [i] == s [j]: dp[i] [j] = 2 + dp [i + 1] [j - 1] اور: dp [i] [j] = زیادہ سے زیادہ (dp [i + 1] [j] ، dp [i] [j - 1]) واپسی DP [0] [n - 1] اس عمل میں ، فنکشن سب سے طویل_palindromic_subsence () ان پٹ کے طور پر ایک تار لیتا ہے اور s میں سب سے طویل palindromic متضاد کی لمبائی کو واپس کرتا ہے۔اس کے بعد یہ صف کے اخترن کو 1 کے ساتھ بھرتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ ہر کردار لمبائی کا ایک پالندرووم ہے۔ پھر یہ الٹا ترتیب میں صف کے ذریعے تکرار کرتا ہے اور مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے باقی خلیوں کو بھرتا ہے۔آخر میں ، فنکشن صف کے اوپری دائیں کونے میں قدر لوٹاتا ہے ، جو پورے سٹرنگ 12 کے لئے سب سے طویل پیلنڈرومک مشترکہ کی لمبائی کی نمائندگی کرتا ہے۔ یہاں طویل ترین_پالائنڈرومک_سوبسینس () فنکشن کی ایک مثال استعمال ہے: ازگروں کی طرف(s)) # پرنٹس 7 ان مثال کے طور پر ، ہمیں تار s میں سب سے طویل palindromic متضاد کی لمبائی ملتی ہے۔فنکشن 7 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سب سے طویل پیلنڈرومک متضاد ہے"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں غیر اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عدد کی ایک دی گئی فہرست میں نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ بالترتیب بائیں اور دائیں سے ہر انڈیکس پر ختم ہونے والے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے دو صفیں بنائیں۔اس کے بعد ہم سرنی کے ذریعے تکرار کرسکتے ہیں اور ہر انڈیکس I کے لئے لمبائی کے لمبائی کے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم کا حساب لگاسکتے ہیں کیونکہ I-K پر ختم ہونے والے غیر اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم کا مجموعہ اور I+1 سے شروع ہوتا ہے۔دائیںآخری قیمت لمبائی کے 12 کے غیر اوورلیپنگ سبریوں کا زیادہ سے زیادہ مجموعہ ہوگی۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ: پائیتھنڈف میکس_سم_نون_ اوورلیپنگ_سوبری (اے آر آر ، کے): این = لین (آر آر) بائیں = [0] * این رائٹ = [0] * n بائیں_میکس = 0 دائیں_میکس = 0 میں I کے لئے (n): بائیں_میکس = زیادہ سے زیادہ (بائیں_میکس ، 0) + آر ہی [i] بائیں [i] = بائیں_میکس اگر i> = K: بائیں_میکس -= arr [i -K] J = N - I - 1 دائیں_میکس = زیادہ سے زیادہ (دائیں_میکس ، 0) + ار [J] دائیں [j] = دائیں_میکس اگر J <N - K: RITE_MAX - = J + K] MAX_SUM = 0 I in کے لئےرینج (کے ، این - کے): میکس_سم = زیادہ سے زیادہ (میکس_سم ، بائیں [i - k] + دائیں [i]) میکس_سومن لوٹ کر اس نفاذ ، فنکشن میکس_سوم_نون_ اوورلیپنگ_سوبیریز () ان پٹ کے طور پر انٹیجر آر اور ایک عددی K کی فہرست لیتا ہے اوراے آر آر میں لمبائی K کے غیر اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم واپس کرتا ہے۔اس فنکشن میں پہلے بالترتیب بائیں اور دائیں سے ہر انڈیکس پر ختم ہونے والے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم کو اسٹور کرنے کے لئے بائیں اور دائیں دو صفوں کا آغاز ہوتا ہے۔اس کے بعد یہ سرنی کے ذریعے تکرار کرتا ہے اور ہر انڈیکس I کے ل length لمبائی کے لمبائی کے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم کا حساب لگاتا ہے جس میں I-K پر ختم ہونے والے نان اوورلیپنگ subarrays کی زیادہ سے زیادہ رقم کا مجموعہ ہوتا ہے اور دائیں سے I+1 پر شروع ہوتا ہے۔اس کے بعد اس فنکشن میں لمبائی K کے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم کا حساب لگایا جاتا ہے جس میں سرے کے ذریعے تکرار کرتے ہوئے اور I-K پر ختم ہونے والے غیر اوورلیپنگ subarrays کی زیادہ سے زیادہ رقم کا خلاصہ کیا جاتا ہے اور دائیں سے I پر شروع ہوتا ہے۔آخر میں ، فنکشن زیادہ سے زیادہ SUM12 کو لوٹاتا ہے۔ یہاں میکس_سم_نون_ اوورلیپنگ_سبریز () فنکشن کا ایک مثال استعمال: پائیتھونر = [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] K = 3 پرنٹ (میکس_سم_نون_ورلیپنگ_سبریز (ای آر آر ، کے)) # پرنٹس 21 ان مثال کے طور پر ، ہمیں فہرست ARR میں لمبائی کے لمبائی کے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم ملتی ہے۔فنکشن 21 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ لمبائی 3 کے نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم 21 ہے ، جو subarrays123and78912.1ros2geeksforgeeks کو منتخب کرکے حاصل کی جاتی ہے۔"
    },
    {
        "Question": "مستقل وقت اور جگہ کی پیچیدگی میں عددی کے دھارے کے وسط کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "مستقل وقت اور جگہ کی پیچیدگی میں عدد کے دھارے کے درمیانی حصے کو تلاش کرنے کے ل we ، ہم انٹیجرز کے چھوٹے نصف حصے کو ذخیرہ کرنے کے لئے دو ڈھیر ، ایک زیادہ سے زیادہ ڈھیر اور ایک منٹ کا ڈھیر استعمال کرسکتے ہیں تاکہ انٹیجرز کا بڑا نصف حصہ ذخیرہ کیا جاسکے۔ہم اس پراپرٹی کو برقرار رکھ سکتے ہیں کہ زیادہ سے زیادہ ڈھیر کا سائز یا تو کے برابر ہے یا من ڈھیر کے سائز سے ایک زیادہ ہے۔میڈین زیادہ سے زیادہ ڈھیر کا اوپری عنصر ہوگا اگر ڈھیروں کے سائز برابر ہوں ، یا زیادہ سے زیادہ ڈھیر اور منٹ کے ڈھیر کے اوپری عناصر کی اوسط اگر زیادہ سے زیادہ ڈھیر کا سائز کم سے کم کے سائز سے زیادہ ہو توHep123. یہاں ازگر میں اس نقطہ نظر کا نفاذ: پائیتھونیمپورٹ ہیپقکلاس میڈین فائنڈر: ڈیف __init __ (خود): سیلف۔ میکس_ہپ = [] سیلف۔ مین_ہپ = [] ڈیف ایڈ_نم (خود): اگر لین (سیلف۔ میکس_ہپ) ==لین (self.min_heap): اگر خود نہیں ہے۔.min_heap)) ہیپ کیو۔ ہیپش (سیلف.مین_ہپ ، نمبر) اور: اگر num> = -ell.eappop (self.max_heap)) ہیپ کیو۔ ہیپش (سیلف۔ میکس_ہپ ، -نوم) ڈیف فائنڈ_میڈین (سیلف): اگر لین (سیلف۔میکس_ہپ) == لین (سیلف مین_ہپ): ریٹرن ( -سیلف۔میکس_ہپ [0]+ self.min_heap [0]) / 2 اور: واپس -سیلف۔ میکس_ہپ [0] اس نفاذ میں ، میڈین فائنڈر کلاس دو ڈھیروں ، میکس_ہپ اور من_ہپ کو برقرار رکھتی ہے ، تاکہ بالترتیب انٹیجرز کے چھوٹے اور بڑے حصوں کو ذخیرہ کریں۔add_num کا طریقہ ان پٹ کے طور پر ایک عدد نمبر لیتا ہے اور اس پراپرٹی کو برقرار رکھتے ہوئے مناسب ڈھیر میں شامل کرتا ہے کہ زیادہ سے زیادہ ڈھیر کا سائز یا تو کے برابر ہے یا من ڈھیر کے سائز سے ایک زیادہ ہے۔Find_median طریقہ ڈھیروں کے سائز کی جانچ کرکے اور زیادہ سے زیادہ ڈھیر کے اوپر عنصر کو واپس کرکے ندی میں انٹیجرز کے میڈین کو واپس کرتا ہے اگر سائز برابر ہوں ، یا زیادہ سے زیادہ ڈھیر اور من ڈھیر کے اوپری عناصر کی اوسطزیادہ سے زیادہ ہیپ کا سائز من ہپ 123 کے سائز سے زیادہ ہے۔ میڈین فائنڈر کلاس کا ایک مثال استعمال: پائیٹون ایم ایف = میڈین فائنڈر () ایم ایف.اڈی_نوم (1) ایم ایف.اڈی_نم (2) ایم ایف.اڈی_نم (3) ایم ایف۔add_num (4) پرنٹ (mf.find_median ()) # پرنٹس 2.5 میں اس مثال کے طور پر ، ہم ایک میڈین فائنڈر آبجیکٹ بناتے ہیں اور ندی میں عددی 1 ، 2 ، 3 ، اور 4 شامل کرتے ہیں۔اس کے بعد ہمیں ندی کا درمیانی حصہ ملتا ہے ، جو 2.5123.1opengenus2geeksforgeeks3stackoverflow ہے"
    },
    {
        "Question": "ایک ازگر کلاس لکھیں جو ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتے ہیں اور یونین کو انجام دینے اور کاموں کو تلاش کرنے کے طریقوں کو نافذ کرتے ہیں۔",
        "Answer": "یونین کو انجام دینے اور آپریشنز تلاش کرنے کے ل a ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرنے اور طریقوں کو نافذ کرنے والے ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم ہر سیٹ کو درخت کی حیثیت سے نمائندگی کرنے کے نقطہ نظر کو استعمال کرسکتے ہیں ، جہاں ہر نوڈ اپنے والدین کی طرف اشارہ کرتا ہے۔ہم درخت کو متوازن رکھنے کے لئے ہر نوڈ کے درجے کا استعمال کرسکتے ہیں اور فائنڈ آپریشن کی کارکردگی کو بہتر بنانے کے لئے راستے کے کمپریشن کا استعمال کرسکتے ہیں۔یونین آپریشن میں درختوں کی جڑوں کو تلاش کرنا اور چھوٹے درخت کو بڑے درخت 12 میں ضم کرنا شامل ہے۔.]) خود کو واپس کریں۔.rank [روٹ_ی]: سیلف۔ پیرینٹ [روٹ_ ایکس] = روٹ_ی الیف سیلف۔ رینک [روٹ_ ایکس]> سیلف۔ رینک [روٹ_ی]: سیلف پیئرنٹ [روٹ_ی] = روٹ_ ایکس دوسری: خود۔[روٹ_ ایکس] += 1 اس پر عمل درآمد میں ، ناگوار کلاس ان پٹ کے طور پر ایک عدد این لیتا ہے اور والدین کو شروع کرتا ہے اور این ناشائستہ سیٹوں کی نمائندگی کرنے کے لئے درجہ بندی کی صفوں کو شروع کرتا ہے۔تلاش کا طریقہ ایک عنصر X کو ان پٹ کے طور پر لیتا ہے اور درخت کی جڑ کو X پر مشتمل کرتا ہے ، جبکہ مستقبل کی تلاش کے کاموں کی کارکردگی کو بہتر بنانے کے لئے راستہ کمپریشن انجام دیتا ہے۔یونین کا طریقہ دو عناصر کو X اور y کو ان پٹ کے طور پر لیتا ہے اور درختوں کو X اور Y پر مشتمل ہوتا ہے ، جبکہ ہر نوڈ کے درجہ کو برقرار رکھتے ہوئے درخت کو متوازن رکھیں۔یونین (0 ، 1) ds.union (1 ، 2) ds.union (3 ، 4) پرنٹ (ds.find (2)) # پرنٹ 0 پرنٹ (ds.find (4)) # پرنٹ 3 میں یہ مثال ہے ، ہم تخلیق کرتے ہیں ، ہم تخلیق کرتے ہیں5 عناصر کے ساتھ ایک ناگوار آبجیکٹ اور عناصر کو سیٹوں میں ضم کرنے کے لئے کئی یونین کی کاروائیاں انجام دیں۔اس کے بعد ہمیں درختوں کی جڑیں ملتی ہیں جن میں عناصر 2 اور 4 پر مشتمل ہوتا ہے ، جو بالترتیب 0 اور 3 ہیں ، 12.1 ٹکیڈ لائٹ 2 پلیننگلیش"
    },
    {
        "Question": "کسی دیئے گئے تار میں الگ الگ حصوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "کسی دیئے گئے تار میں الگ الگ متضاد افراد کی تعداد تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ دیئے گئے تار کے ہر سابقہ کے لئے الگ الگ حصوں کی تعداد کو ذخیرہ کرنے کے لئے ایک صف تیار کی جائے۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھر سکتے ہیں: اگر موجودہ کردار ایک نقل نہیں ہے تو ، الگ الگ متضاد افراد کی تعداد پچھلے سابقہ کے لئے الگ الگ متناسب کی تعداد سے دوگنا ہے۔پچھلے سابقہ پریفکس مائنس کے لئے الگ الگ حصوں کی تعداد موجودہ کردار کے پچھلے واقعے کے لئے الگ الگ متضاد افراد کی تعداد۔ صف میں حتمی قیمت پورے سٹرنگ 12 کے لئے الگ الگ حصول کی تعداد ہوگی۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ:پائیتھنڈف الگ الگ_سوبسنس (ایس): این = لین (ایس) ڈی پی = [0] * (این + 1) آخری = {} ڈی پی [0] = 1 میں رینج (1 ، این + 1): ڈی پی [i] =2 * dp [i - 1] اگر s [i - 1] آخری میں: dp [i] - = dp [آخری [s [i - 1]] - 1] آخری [s [i - 1]] = i -1 واپسی DP [n] - 1 اس پر عمل درآمد میں ، فنکشن الگ الگ_سبسنس () ان پٹ کے طور پر ایک تار لیتا ہے اور ایس میں الگ الگ حصوں کی تعداد کو واپس کرتا ہے۔فنکشن سب سے پہلے ایس کے ہر سابقہ کے لئے الگ الگ حصول کی تعداد کو اسٹور کرنے کے لئے ایک سرنی ڈی پی کی ابتدا کرتا ہے اور ہر ایک کردار کے آخری واقعے کے اشاریہ کو اسٹور کرنے کے لئے آخری لغت کو آخری کرتا ہے۔اس کے بعد مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھرتا ہے۔آخر میں ، فنکشن سرنی مائنس 1 کے آخری سیل میں قیمت لوٹاتا ہے ، جو پورے سٹرنگ 12 کے لئے الگ الگ حصول کی تعداد کی نمائندگی کرتا ہے۔)) # پرنٹس 15 ان مثال کے طور پر ، ہمیں سٹرنگ ایس میں الگ الگ حصوں کی تعداد ملتی ہے۔فنکشن 15 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ S12.1geeksforgeeks2baeldung میں 15 الگ الگ متناسب ہیں"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر بٹ وائز آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے نمبر بٹ وائس آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے ، ہم اس پراپرٹی کو استعمال کرسکتے ہیں جس کی دو طاقتوں کی بائنری نمائندگی میں صرف ایک سیٹ بٹ ہے۔ہم یہ چیک کرنے کے لئے بٹ وائز اور آپریٹر کا استعمال کرسکتے ہیں کہ آیا دیئے گئے نمبر میں صرف ایک سیٹ بٹ ہے جس کا موازنہ اس سے حاصل کردہ نمبر سے حاصل کیا گیا ہے۔اگر نتیجہ 0 ہے ، تو یہ نمبر دو12 کی طاقت ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف is_power_of_two (n): واپسی n> 0 اور (n & (n - 1)) == 0 اس پر عمل درآمد ،فنکشن IS_POWER_OF_TWO () ان پٹ کے طور پر ایک عدد N لیتا ہے اور اگر N دو کی طاقت ہے اور غلط ہے تو سچائی واپس آجاتا ہے۔فنکشن پہلے چیک کرتا ہے کہ اگر N 0 سے زیادہ ہے اس بات کا یقین کرنے کے لئے کہ یہ ایک مثبت عدد ہے۔اس کے بعد یہ بٹ وائز اور آپریٹر کا استعمال یہ چیک کرنے کے لئے کرتا ہے کہ آیا اس سے 1 کو گھٹا کر حاصل کردہ نمبر سے موازنہ کرکے صرف ایک ہی سیٹ بٹ ہے۔اگر نتیجہ 0 ہے تو ، پھر n دو کی طاقت ہے اور فنکشن درست 12 ہے۔ یہاں IS_POWER_OF_TWO () فنکشن کی مثال کے طور پر استعمال: pythonn = 16if is_offower_of_two (n): پرنٹ (f '{n} دو کی طاقت ہے۔') اور: پرنٹ (f' {n} دو کی طاقت نہیں ہے ') اس مثال میں ، ہم چیک کرتے ہیں کہ آیا INTEGER N IS_POWER_OF_TWO () فنکشن کا استعمال کرتے ہوئے دو کی طاقت ہے۔فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ n دو12.1geeksforgeeks2java67 کی طاقت ہے"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ سب سے طویل عرصہ تک بڑھتے ہوئے سبری کو تلاش کریں جس میں زیادہ تر K الگ الگ انٹیجرس انٹیجرز کی ایک فہرست میں شامل ہوں۔",
        "Answer": "انٹیجرز کی ایک دی گئی فہرست میں زیادہ تر K الگ الگ عدد کے ساتھ سب سے طویل عرصے تک بڑھتے ہوئے سبری کو تلاش کرنے کے ل we ، ہم سلائیڈنگ ونڈو نقطہ نظر کو استعمال کرسکتے ہیں۔ہم سب سے زیادہ کے الگ الگ عدد کے ساتھ سبری کی بڑھتی ہوئی ونڈو کو برقرار رکھ سکتے ہیں اور ونڈو کو اپ ڈیٹ کرسکتے ہیں جب ہم فہرست میں شامل ہوتے ہیں۔ہم ونڈو کے آغاز اور اختتام کی نمائندگی کرنے کے لئے بالترتیب دو پوائنٹرز ، بائیں اور دائیں استعمال کرسکتے ہیں۔ہم ونڈو میں ہر عدد کی فریکوئنسی کو ٹریک رکھنے کے لئے ایک لغت بھی استعمال کرسکتے ہیں۔اگر ونڈو میں الگ الگ انٹیجرز کی تعداد K سے تجاوز کرتی ہے تو ، ہم بائیں پوائنٹر کو دائیں طرف منتقل کرتے ہیں جب تک کہ الگ الگ عدد کی تعداد K سے کم یا اس کے برابر نہ ہو۔ ہم بڑھتی ہوئی سبری کی زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرتے ہیں کیونکہ ہم فہرست 1 کے ذریعے تکرار کرتے ہیں۔ازگر میں اس نقطہ نظر کا ایک نفاذ یہاں ہے: پائیتھونڈف طویل ترین_Increasing_subarray_with_k_distinct (arr ، k): n = len (arr) بائیں = 0 freq = {} max_len = 0 رینج میں دائیں کے لئے (n): فریق [arr [دائیں]] = فریق.get (arr [دائیں] ، 0) + 1 جبکہ لین (فریق)> k: freq [arr [بائیں]] -= 1 اگر freq [arr [بائیں]] == 0: ڈیل فریک [arr [بائیں]]بائیں + = 1 اگر دائیں - بائیں + 1> میکس_لن: میکس_لن = دائیں - بائیں + 1 میکس_لینن اس پر عمل درآمد ، سب سے طویل_increasing_subarray_with_k_distinct () ان پٹ کے طور پر ان پٹ کے طور پر انٹیجرز آر آر اور ایک انٹیجر K کی فہرست لیتا ہے اور ان پٹ کے طور پر لوٹاتا ہے۔سب سے زیادہ کے ساتھ سب سے زیادہ K الگ الگ انٹیجرز آر اے آر میں۔فنکشن سب سے پہلے بائیں پوائنٹر کو 0 پر شروع کرتا ہے ، ونڈو میں ہر عدد کی تعدد کو ٹریک رکھنے کے لئے ایک لغت فریک ، اور بڑھتی ہوئی سبری کی زیادہ سے زیادہ لمبائی 0 میں۔ونڈو میںاگر ونڈو میں الگ الگ انٹیجرز کی تعداد K سے تجاوز کرتی ہے تو ، فنکشن بائیں پوائنٹر کو دائیں طرف منتقل کرتا ہے جب تک کہ الگ الگ عدد کی تعداد K سے کم یا اس کے برابر نہ ہو۔اس کے بعد یہ فنکشن بڑھتی ہوئی سبری کی زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرتا ہے کیونکہ یہ فہرست میں شامل ہوتا ہے۔آخر میں ، فنکشن زیادہ سے زیادہ لمبائی کو لوٹاتا ہے۔ یہاں طویل ترین_Increasing_subarray_with_k_distinct () فنکشن کا ایک مثال استعمال ہے: پائیتھونر = [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] K = 3 پرنٹ (طویل ترین_INCresing_subarray_with_k_distinc)) # پرنٹس 3 اس مثال کے طور پر ، ہمیں فہرست ARR میں زیادہ تر K الگ الگ عدد کے ساتھ طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی ملتی ہے۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ زیادہ سے زیادہ 3 الگ الگ انٹیجرس کے ساتھ سب سے طویل عرصہ میں بڑھتا ہوا سبری IS1231.1geeksforgeeks"
    },
    {
        "Question": "ایک AVL درخت کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "\"کسی دیئے گئے تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں ، جہاں ہر خط کو ایک نمبر (A = 1 ، B = 2 ، وغیرہ) میں نقش کیا جاتا ہے۔\"",
        "Answer": "کسی دیئے گئے تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد تلاش کرنے کے ل where ، جہاں ہر خط کو ایک نمبر (A = 1 ، B = 2 ، وغیرہ) میں نقش کیا جاتا ہے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ تار کے ہر سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد کو ذخیرہ کرنے کے لئے ایک صف تیار کرنا ہے۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھر سکتے ہیں: اگر موجودہ کردار 0 نہیں ہے تو ، موجودہ سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد پچھلے سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد کے برابر ہے اور اس کے علاوہ سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد کی تعداد کے برابر ہے۔دو حرف پہلے اگر موجودہ پریفکس ایک درست دو ہندسوں کا نمبر ہے۔ دوسرے کے مطابق ، اگر موجودہ کردار 0 ہے اور پچھلا کردار 1 یا 2 نہیں ہے تو ، تار غلط ہے اور موجودہ سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد 0 ہے۔بصورت دیگر ، اگر موجودہ کردار 0 ہے اور پچھلا کردار 1 یا 2 ہے تو ، موجودہ سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد دو حرفوں سے پہلے کے سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد کے برابر ہے۔ صف میں حتمی قیمت ہوگیپورے سٹرنگ 12 کو ڈی کوڈ کرنے کے طریقوں کی تعداد۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ: پائیتھونڈف نمبر_ڈیکوڈنگز (s): n = len (s) dp = [0] * (n + 1) dp [0] = 1 اگر s [0]! = '0': DP [1] = 1 میں I کے لئے (2 ، n + 1): اگر s [i - 1]! = '0': dp [i] = dp [i - 1]اگر s [i - 2] == '1' یا (s [i - 2] == '2' اور s [i - 1] <= '6'): dp [i] += dp [i - 2 - 2] ڈی پی کو واپس کریں [n] اس نفاذ میں ، فنکشن NUM_DECODINGS () ان پٹ کے طور پر ایک تار لیتا ہے اور ایس کو ڈی کوڈ کرنے کے طریقوں کی تعداد کو واپس کرتا ہے۔فنکشن سب سے پہلے ایس کے ہر سابقہ کو ڈی کوڈ کرنے کے طریقوں کی تعداد کو اسٹور کرنے کے لئے ایک سرنی ڈی پی کی ابتدا کرتا ہے۔اس کے بعد مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھرتا ہے۔آخر میں ، فنکشن سرنی کے آخری سیل میں قدر لوٹاتا ہے ، جو پورے سٹرنگ 12 کو ڈی کوڈ کرنے کے طریقوں کی تعداد کی نمائندگی کرتا ہے۔ NUM_DECODINGS () فنکشن کا ایک مثال استعمال: ازگر = '123'Print (num_decodings (s))# پرنٹ 3 میں اس مثال میں ، ہمیں تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد ملتی ہے۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سٹرنگ کی 3 ممکنہ ضابطہ بندی ہیں: اے بی سی ، ایل سی ، اور AW12.1Geeksforgeeks2stackoverflow"
    },
    {
        "Question": "اس رکاوٹ کے ساتھ مل کر زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں کہ اس کے بعد میں کوئی دو عناصر ملحقہ نہیں ہیں۔",
        "Answer": "اس رکاوٹ کے ساتھ مل کر زیادہ سے زیادہ رقم تلاش کرنے کے لئے کہ اس کے بعد میں کوئی دو عناصر ملحقہ نہیں ہیں ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ایک نقطہ نظر یہ ہے کہ ہر انڈیکس پر ختم ہونے والے غیر ملکی متضاد متضاد کے زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے ایک صف تیار کرنا ہے۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو پُر کرسکتے ہیں: اگر موجودہ عنصر کو شامل نہیں کیا گیا ہے تو ، موجودہ انڈیکس پر ختم ہونے والے غیر ملحق متضاد کی زیادہ سے زیادہ رقم پچھلے انڈیکس میں ختم ہونے والے غیر ملحقہ متضاد کے زیادہ سے زیادہ رقم کے برابر ہے۔بصورت دیگر ، اگر موجودہ عنصر کو شامل کیا گیا ہے تو ، موجودہ انڈیکس پر ختم ہونے والے غیر ملحق متضاد کی زیادہ سے زیادہ رقم موجودہ عنصر کی رقم کے برابر ہے اور موجودہ انڈیکس سے پہلے انڈیکس دو پوزیشنوں پر ختم ہونے والے غیر ملحق متضاد کی زیادہ سے زیادہ رقم۔. سرے میں حتمی قیمت دیئے گئے فہرست 12 میں غیر متنازعہ متضاد کی زیادہ سے زیادہ رقم ہوگی۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف میکس_سم_نون_اڈجینٹ (اے آر آر): این = لین (آر آر) اگر n == 0: واپسی0 الیف این == 1: واپسی کی واپسی [0] ڈی پی = [0] * این ڈی پی [0] = آر آر [0] ڈی پی [1] = زیادہ سے زیادہ (ارا [0] ، ار [1])2 ، این): ڈی پی [i] = زیادہ سے زیادہ (ڈی پی [i - 1] ، ڈی پی [i - 2] + arr [i]) واپسی ڈی پی [n - 1] اس عمل میں ، فنکشن میکس_سم_نون_اڈجینٹ () ایک فہرست لیتا ہے۔ان پٹ کے طور پر انٹیجرز آر اے آر میں سے اور اے آر آر میں غیر ملکی متناسب کی زیادہ سے زیادہ رقم واپس کرتا ہے۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست کی لمبائی 0 یا 1 ہے اور مناسب قیمت لوٹاتی ہے۔اس کے بعد یہ ہر انڈیکس پر ختم ہونے والے غیر ایڈجسٹ متضاد کے زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے ایک سرنی ڈی پی کی ابتدا کرتا ہے۔اس کے بعد مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھرتا ہے۔آخر میں ، فنکشن سرنی کے آخری سیل میں قیمت لوٹاتا ہے ، جو دیئے گئے فہرست 12 میں غیر ملکی متضاد کی زیادہ سے زیادہ رقم کی نمائندگی کرتا ہے۔100 ، 10 ، 5] پرنٹ (میکس_سم_نون_اڈجینٹ (اے آر آر)) # پرنٹس 110in اس مثال کے طور پر ، ہمیں فہرست اے آر آر میں غیر ایڈجسٹ متضاد کی زیادہ سے زیادہ رقم ملتی ہے۔فنکشن 110 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اے آر آر میں غیر ملکی متنازعہ کی زیادہ سے زیادہ رقم 110 ہے ، جو متضاد {5 ، 100 ، 5} 2.1 کوڈنگنجاس 2 جی ای ای ایس ایففجیکس کو چن کر حاصل کی جاتی ہے۔"
    },
    {
        "Question": "\"2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں جزیروں کی تعریف '1 کے منسلک علاقوں سے ہوتی ہے ، لیکن اخترن رابطوں پر غور نہیں کیا جاتا ہے۔\"",
        "Answer": "2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ، جہاں جزیروں کی تعریف '1 کے منسلک علاقوں سے ہوتی ہے ، لیکن اخترن رابطوں پر غور نہیں کیا جاتا ہے ، ہم گہرائی سے پہلے تلاش (DFS) الگورتھم استعمال کرسکتے ہیں۔ہم گرڈ کو عبور کرسکتے ہیں اور ہر سیل کے لئے جس میں '1' ہوتا ہے ، ہم ملحقہ تمام خلیوں کو نشان زد کرنے کے لئے ایک DFs انجام دے سکتے ہیں جن میں '1' ہوتا ہے۔اس کے بعد ہم گرڈ میں جزیروں کی کل تعداد تلاش کرنے کے لئے ڈی ایف ایس کی تعداد کو گن سکتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف نمبر_س لینڈز (گرڈ): اگر گرڈ نہیں ہے تو: 0 ڈیف ڈی ایف ایس (گرڈ ، I.[j] = '#' DFS (گرڈ ، I + 1 ، J) DFS (گرڈ ، I - 1 ، J) DFS (گرڈ ، I ، J + 1) DFS (گرڈ ، I ، J - 1) گنتی = 0میں رینج (لین (گرڈ)) کے لئے: رینج میں جے کے لئے (لین (گرڈ [0])): اگر گرڈ [i] [j] == '1': ڈی ایف ایس (گرڈ ، آئی ، جے) گنتی +=1 اس نفاذ کا حساب کتاب کریں ، فنکشن Num_islands () ان پٹ کے طور پر حروف گرڈ کا 2D گرڈ لیتا ہے اور گرڈ میں جزیروں کی تعداد واپس کرتا ہے۔فنکشن پہلے چیک کرتا ہے کہ اگر گرڈ خالی ہے اور 0 لوٹتا ہے اگر یہ ہے۔اس کے بعد یہ کسی دیئے گئے سیل سے شروع ہونے والے گرڈ پر ڈی ایف ایس انجام دینے کے لئے ایک مددگار فنکشن ڈی ایف ایس کی وضاحت کرتا ہے۔ڈی ایف ایس فنکشن موجودہ سیل کو نشان زد کرتا ہے جیسا کہ ملاحظہ کیا جاتا ہے اور بار بار اپنے آپ کو ملحقہ خلیوں پر کال کرتا ہے جس میں '1' ہوتا ہے۔اس کے بعد یہ فنکشن 0 پر کاؤنٹر کی گنتی کا آغاز کرتا ہے اور گرڈ کے ذریعے تکرار کرتا ہے ، ہر سیل پر DFS فنکشن کو کال کرتا ہے جس میں '1' ہوتا ہے اور ہر بار DFS انجام دینے پر گنتی متغیر میں اضافہ ہوتا ہے۔آخر میں ، فنکشن گنتی کے متغیر کو لوٹاتا ہے ، جو گرڈ میں جزیروں کی کل تعداد کی نمائندگی کرتا ہے۔ Num_islands () فنکشن کی مثال کے طور پر استعمال: pythongrid = [['1' ، '1' ، '0' ، '0'، '0'] ، ['1' ، '1' ، '0' ، '0' ، '0'] ، ['0' ، '0' ، '1' ، '0' ، '0'] ،۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ گرڈ میں 3 جزیرے موجود ہیں۔"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کی اجازت ملتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور آپریٹرز کی اجازت ملتی ہے ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔ہم تار کے ذریعے تکرار کرسکتے ہیں اور ہر افتتاحی بریکٹ کو اسٹیک پر دھکیل سکتے ہیں۔جب ہمیں کسی اختتامی بریکٹ کا سامنا کرنا پڑتا ہے تو ، ہم اسٹیک سے ٹاپ عنصر کو پاپ کرسکتے ہیں اور چیک کرسکتے ہیں کہ آیا یہ اختتامی بریکٹ سے مماثل ہے یا نہیں۔اگر یہ مماثل نہیں ہے تو ، تار درست نہیں ہے۔اگر ہم تار کے اختتام پر پہنچ جاتے ہیں اور اسٹیک خالی ہے تو ، تار درست ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف is_valid_expression (s): st کے لئے S: if c in '({[': stac.append (c) elif c in')}] ': اگر اسٹیک نہیں ہے تو: غلط واپس کریں اگر c ==') 'اور اسٹیک [-1]! =' (': غلط واپس کریں اگر c =='}'اور اسٹیک [-1]! =' {': غلط لوٹائیں اگر c =='] 'اور اسٹیک [-1]! =' [': غلط اسٹیک کریں۔() ایک تار کو ان پٹ کے طور پر لیتا ہے اور اگر متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہوتا ہے تو وہ سچ ہوتا ہے۔، فنکشن چیک کرتا ہے کہ آیا یہ افتتاحی بریکٹ ہے اور اسے اسٹیک پر دھکیل دیتا ہے۔ اگر یہ اختتامی بریکٹ ہے تو ، فنکشن چیک کرتا ہے کہ اگر اسٹیک کا اوپری عنصر بند ہونے والے بریکٹ سے میل کھاتا ہے۔اگر یہ مماثل نہیں ہے تو ، فنکشن غلط لوٹاتا ہے۔اگر ہم تار کے اختتام پر پہنچ جاتے ہیں اور اسٹیک خالی ہوتا ہے تو ، فنکشن درست ہوجاتا ہے۔بصورت دیگر ، فنکشن غلط لوٹاتا ہے۔ IS_Valid_expression () فنکشن کا ایک مثال استعمال: ازگر = '[(1 + 2) * {3 - 4}]' اگر is_valid_expression (s): پرنٹ (f '{s} A ہے a ہےدرست اظہار ') اور: پرنٹ (f' {s} ایک درست اظہار نہیں ہے ') اس مثال میں ، ہم چیک کرتے ہیں کہ آیا STRING S_Valid_expression () فنکشن کا استعمال کرتے ہوئے متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے۔فنکشن درست لوٹتا ہے ، اس بات کی نشاندہی کرتا ہے کہ s ایک درست اظہار ہے۔"
    },
    {
        "Question": "طبقہ کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اقدار کو اپ ڈیٹ کرنے کے طریقوں کو نافذ کریں اور حدود کی رقم کے لئے استفسار کریں۔",
        "Answer": "ازگر میں طبقہ کے درخت کو نافذ کرنے کے ل we ، ہم ایک طبقاتی طبقہ کی وضاحت کرسکتے ہیں جو درخت کی نمائندگی کرتا ہے۔کلاس کے پاس درخت کو ذخیرہ کرنے کے لئے ایک صف ، درخت کی تعمیر کے لئے ایک طریقہ ، اور قدروں کو اپ ڈیٹ کرنے کے طریقے اور حدود کے لئے استفسار کرنا چاہئے۔ ہر ازگر میں سیگمنٹ ٹری کلاس کا نفاذ: ازگرکلاس سیگمنٹٹری: ڈیف __ __init __ (خود ، arr):self.arr = arse سیلف۔== اختتام: self.tree [نوڈ] = سیلف.ار [شروع] اور: وسط = (اسٹارٹ + اینڈ) // 2 سیلف۔ بلڈ_ٹری (2 * نوڈ + 1 ، اسٹارٹ ، مڈ) سیلف۔ بلڈ_ٹری (2 * نوڈ+ 2 ، وسط + 1 ، اختتام) سیلف ٹری [نوڈ] = سیلف ٹری [2 * نوڈ + 1] + سیلف ٹری [2 * نوڈ + 2] ڈیف اپ ڈیٹ (خود ، نوڈ ، اسٹارٹ ، اختتام ، IDX ،ویل): اگر اسٹارٹ == اختتام: سیلف۔ آئر [idx] = ویل سیلف ٹری [نوڈ] = ویل کوئی اور: وسط = (اسٹارٹ + اینڈ) // 2 اگر اسٹارٹ <= idx <= درمیانی: خود۔ اپ ڈیٹ (2 * نوڈ + 1 ، اسٹارٹ ، مڈ ، آئی ڈی ایکس ، ویل) اور: سیلف۔ اپ ڈیٹ (2 * نوڈ + 2 ، مڈ + 1 ، اینڈ ، آئی ڈی ایکس ، ویل) سیلف ٹری [نوڈ] = سیلف ٹری [2 * نوڈ+ 1] + سیلف ٹری [2 * نوڈ + 2] ڈیف استفسار (خود ، نوڈ ، اسٹارٹ ، اینڈ ، ایل ، آر): اگر r <آغاز یا اختتام <l: واپس 0 <= شروع کریں اور اختتام <=r: واپس return.tree [نوڈ] وسط = (اسٹارٹ + اینڈ) // 2 بائیں_سم = سیلف۔ کیوری (2 * نوڈ + 1 ، اسٹارٹ ، مڈ ، ایل ، آر) رائٹ_سم = سیلف۔کوری (2 * نوڈ + 2.کلاس میں ایک کنسٹرکٹر ہوتا ہے جو اصل صف کو ان پٹ کے طور پر لیتا ہے اور بلڈ_ٹری کے طریقہ کار کا استعمال کرتے ہوئے درخت بناتا ہے۔بلڈ_ٹری کا طریقہ کار کو دو حصوں میں تقسیم کرکے اور بائیں اور دائیں سبٹریز کی تعمیر کرکے درخت کو بار بار بناتا ہے۔تازہ کاری کا طریقہ اصل صف میں ایک قدر اور درخت میں اسی قدر کو اپ ڈیٹ کرتا ہے۔استفسار کا طریقہ ایک دیئے گئے حد میں اقدار کے جوڑے کے لئے درخت سے استفسار کرتا ہے۔استفسار (0 ، 0 ، LEN (ARR) - 1 ، 1 ، 3)) # پرنٹس 15 ٹری۔ اپ ڈیٹ (0 ، 0 ، LEN (ARR) - 1 ، 2 ، 6) پرنٹ (درخت.کوری (0 ، 0 ، لین)(اے آر آر) - 1 ، 1 ، 3)) # پرنٹس 16 ان مثال کے طور پر ، ہم سیگمنٹ ٹری کلاس کا استعمال کرتے ہوئے سرنی آر آر سے ایک طبقہ کا درخت بناتے ہیں۔اس کے بعد ہم استفسار کے طریقہ کار کا استعمال کرتے ہوئے رینج 13 میں اقدار کی رقم کے لئے درخت سے استفسار کرتے ہیں اور اس کے نتائج کو پرنٹ کرتے ہیں۔فنکشن 15 ، جو اقدار 3 ، 5 اور 7 کا مجموعہ ہے ، اس کے بعد ہم تازہ ترین طریقہ کار کا استعمال کرتے ہوئے انڈیکس 2 سے 6 پر قیمت کو اپ ڈیٹ کرتے ہیں اور حد 13 میں اقدار کی رقم کے لئے درخت کو دوبارہ استفسار کرتے ہیں۔فنکشن 16 لوٹتا ہے ، جو اقدار 3 ، 6 ، اور 7.1leetcode2leetcode3geeksforgeeks4hackerearth5geeksforgeeks کا مجموعہ ہے"
    },
    {
        "Question": "عدد کی دی گئی فہرست کو ترتیب دینے کے لئے درکار کم سے کم تعداد میں تبدیلیاں تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عددیوں کی دی گئی فہرست کو ترتیب دینے کے لئے درکار تبدیلیاں کی کم سے کم تعداد تلاش کرنے کے ل we ، ہم مختلف طریقوں کو استعمال کرسکتے ہیں۔یہاں کچھ نقطہ نظر اور ان کے نفاذ ہیں: نقطہ نظر 1: گراف پر مبنی نقطہ نظر ہم اس مسئلے کو گراف کے طور پر تصور کرسکتے ہیں۔ہمارے پاس ن نوڈس اور نوڈ I سے نوڈ J کی ہدایت کی جائے گی اگر Ith انڈیکس کا عنصر ترتیب شدہ صف میں J'th انڈیکس میں موجود ہونا چاہئے۔گراف میں اب بہت سے غیر اندرونی چکروں پر مشتمل ہوگا۔اب 2 نوڈس کے ساتھ ایک سائیکل کو صحیح ترتیب تک پہنچنے کے لئے صرف 1 سویپ کی ضرورت ہوگی ، اسی طرح ، 3 نوڈس والا سائیکل صرف 2 تبادلوں کی ضرورت ہوگی۔لہذا ، اس کا جواب سائیکل_سائز کا مجموعہ ہے - 1 گراف 1 میں تمام چکروں کے لئے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف من_سوپس (اے آر آر): این = لین (اے آر آر) ملاحظہ کریں = [غلط] * این نوڈ_ ڈکٹ = {آر اے آر[i]: i range (n)} ans = 0 کے لئے I (n) کے لئے (n): اگر ملاحظہ کیا جاتا ہے [i] یا نوڈ_ ڈکٹ [arr [i]] == i: سائیکل_سائز = 0 j = i جاری رکھیں جبکہ نہیںدورہ [J]: ملاحظہ کیا [j] = سچ j = نوڈ_ڈکٹ [arr [j]] سائیکل_سائز += 1 جواب += سائیکل_سائز - 1 واپسی اس پر عمل درآمد ، فنکشن MIN_SWAPS () ان پٹ اور ریٹرن کے طور پر عددی ARR کی فہرست لیتا ہے۔صف کو ترتیب دینے کے لئے کم از کم تبادلوں کی تعداد۔فنکشن سب سے پہلے ملاحظہ کرنے والے نوڈس اور لغت نوڈ_ڈکٹ کو ٹریک میں رکھنے کے لئے ملاحظہ کی گئی فہرست کا آغاز کرتا ہے۔اس کے بعد یہ سرنی کے ذریعے تکرار کرتا ہے اور چیک کرتا ہے کہ آیا موجودہ عنصر کا دورہ کیا گیا ہے یا اگر یہ پہلے سے ہی صحیح پوزیشن میں ہے۔اگر اس کا دورہ کیا گیا ہے یا پہلے ہی صحیح پوزیشن میں ہے تو ، فنکشن اگلے عنصر تک جاری رہتا ہے۔بصورت دیگر ، فنکشن سائیکل کو تلاش کرتا ہے جس میں موجودہ عنصر ہوتا ہے اور سائیکل کے سائز کا حساب لگاتا ہے۔اس کے بعد فنکشن سائیکل_ سائز - 1 کو جواب میں شامل کرتا ہے۔آخر میں ، فنکشن جواب واپس کرتا ہے ، جو Array1 کو ترتیب دینے کے لئے درکار کم سے کم تعداد کی نمائندگی کرتا ہے۔ہم موجودہ عنصر کے مقابلے میں دائیں جانب چھوٹے عناصر کی تعداد گن سکتے ہیں۔ہر عنصر کے ل we ، ہم اسے دائیں طرف کے سب سے چھوٹے عنصر کے ساتھ تبدیل کرتے ہیں جو اس سے چھوٹا ہے۔ہم اس عمل کو اس وقت تک دہراتے ہیں جب تک کہ سرنی کو ترتیب نہیں دیا جاتا ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پیتھونڈف من_سوپس (اے آر آر): این = لین (اے آر آر) آر_پوس = [(ارر [i] ، i) I کے لئے I (n) کے لئے (n)]]arr_pos.sort () ملاحظہ کریں = [غلط] * n ans = 0 I in Range (n) کے لئے: اگر ملاحظہ کیا گیا ہے [i] یا arr_pos [i] [1] == i: سائیکل_سائز = 0 j = i تشریف لاتے ہوئے نہیں جاتے ہیں۔[j]: ملاحظہ کیا [j] = سچ j = arr_pos [j] [1] سائیکل_سائز += 1 جواب += سائیکل_سائز - 1 واپسی انسن اس عمل کو ، فنکشن من_ساپس () ان پٹ کے طور پر عددی arr کی فہرست لیتا ہے اور واپس کرتا ہےسرنی کو ترتیب دینے کے لئے ضروری تبادلوں کی کم از کم تعداد۔فنکشن سب سے پہلے ٹپلس آر_پوس کی ایک فہرست بناتا ہے جس میں صف میں ہر عنصر اور اس کا انڈیکس ہوتا ہے۔اس کے بعد یہ فہرست کو عنصر کی قیمت کے ذریعہ ترتیب دیتا ہے۔اس کے بعد فنکشن ملاحظہ کرنے والے نوڈس کا ٹریک رکھنے اور صف کے ذریعے تکرار کرنے کے لئے ایک فہرست کی ابتدا کرتا ہے۔ہر عنصر کے ل the ، فنکشن چیک کرتا ہے کہ آیا اس کا دورہ کیا گیا ہے یا اگر یہ پہلے ہی صحیح پوزیشن میں ہے۔اگر اس کا دورہ کیا گیا ہے یا پہلے ہی صحیح پوزیشن میں ہے تو ، فنکشن اگلے عنصر تک جاری رہتا ہے۔بصورت دیگر ، فنکشن سائیکل کو تلاش کرتا ہے جس میں موجودہ عنصر ہوتا ہے اور سائیکل کے سائز کا حساب لگاتا ہے۔اس کے بعد فنکشن سائیکل_ سائز - 1 کو جواب میں شامل کرتا ہے۔آخر میں ، فنکشن جواب واپس کرتا ہے ، جو سرنی کو ترتیب دینے کے لئے درکار کم از کم تعداد کی نمائندگی کرتا ہے۔)) # پرنٹس 2 ان مثال کے طور پر ، ہمیں MIN_SWAPS () فنکشن کا استعمال کرتے ہوئے سرنی آر آر کو ترتیب دینے کے لئے کم سے کم تعداد میں تبدیلیاں ملتی ہیں۔فنکشن 2 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ 2 تبادلوں کی ضرورت ہے۔"
    },
    {
        "Question": "دو دیئے گئے ڈوروں کی سب سے طویل عام مشترکہ تلاش کے ل a ایک فنکشن کو نافذ کریں۔",
        "Answer": "دو دیئے گئے ڈوروں کی سب سے طویل عام مشترکہ حصول تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم دونوں ڈوروں کے سابقے کے سب سے طویل مشترکہ حصول کی لمبائی کو ذخیرہ کرنے کے لئے 2D سرنی تشکیل دے سکتے ہیں۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو پُر کرسکتے ہیں: اگر دونوں ڈوروں کے موجودہ حروف ملتے ہیں تو ، طویل ترین مشترکہ متضاد کی لمبائی موجودہ کرداروں کے بغیر دونوں ڈوروں کے سب سے طویل عرصے سے مشترکہ حصول کی لمبائی کے برابر ہے۔اس کے علاوہ 1. ایک دوسرے کے ساتھ ، سب سے طویل عام مشترکہ حصول کی لمبائی موجودہ کردار کے بغیر پہلے سٹرنگ کے سابقہ کے ماقبل کی لمبائی کے زیادہ سے زیادہ کے برابر ہے اور موجودہ کردار کے ساتھ دوسرے سٹرنگ کا سابقہ ، اورموجودہ کردار کے ساتھ پہلے سٹرنگ کے سابقہ کے سابقہ کی لمبائی اور موجودہ کردار کے بغیر دوسرے سٹرنگ کا سابقہ۔ازگر میں اس نقطہ نظر کا نفاذ: پائیتھنڈف طویل ترین_کومون_سوبسینس (S1 ، S2): M ، N = LEN (S1) ، لین (S2) DP = [[0] * (n + 1) رینج میں _ کے لئے (M + 1)] میں رینج (1 ، ایم + 1) کے لئے: رینج میں جے کے لئے (1 ، n + 1): اگر S1 [i - 1] == s2 [j - 1]: dp [i] [j] = dp۔j = m ، n جبکہ i> 0 اور j> 0: اگر S1 [i - 1] == s2 [j - 1]: lcs.append (s1 [i - 1]) i - = 1 j - = 1 alifڈی پی [i - 1] [j]> dp [i] [j - 1]: i - = 1 اور: j - = 1 واپسی ''. join (الٹ (LCS)) اس عمل میں ، طویل ترین_کومون_سوبسینس () فنکشن ())ان پٹ کے طور پر دو ڈور S1 اور S2 لیتا ہے اور دونوں ڈوروں کے سب سے طویل عام حصے کو لوٹاتا ہے۔فنکشن سب سے پہلے دونوں ڈوروں کے سابقے کے سب سے طویل مشترکہ حصول کی لمبائی کو محفوظ کرنے کے لئے 2D سرنی ڈی پی کی ابتدا کرتا ہے۔اس کے بعد مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھرتا ہے۔اس کے بعد فنکشن سرنی کے آخری سیل سے پیچھے کھوج کر سب سے طویل عام مشترکہ تشکیل دیتا ہے۔آخر میں ، فنکشن سٹرنگ 12 کے طور پر سب سے طویل عام مشترکہ حصول کو لوٹاتا ہے۔طویل ترین_کومون_سوبسینس () فنکشن کا استعمال کرتے ہوئے دونوں تار S1 اور S2 کی سب سے طویل عام مشترکہ ملاحظہ کریں۔فنکشن جی ٹی اے بی کو لوٹاتا ہے ، جو دو تاروں کا سب سے طویل عام حصول ہے۔"
    },
    {
        "Question": "\"عددیوں کی دی گئی فہرست میں ریاضی کے ٹکڑوں کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں ، جہاں ایک ریاضی کا ٹکڑا ایک متنازعہ سبری ہے جس میں کم از کم تین عناصر ایک ہی فرق رکھتے ہیں۔\"",
        "Answer": "عددیوں کی دی گئی فہرست میں ریاضی کے ٹکڑوں کی تعداد تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ہر انڈیکس پر ختم ہونے والے ریاضی کے ٹکڑوں کی تعداد کو ذخیرہ کرنے کے لئے ایک صف تشکیل دے سکتے ہیں۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھر سکتے ہیں: اگر موجودہ عنصر ، پچھلے عنصر ، اور عنصر دو پوزیشنوں سے پہلے موجودہ عنصر ایک ریاضی کی ترتیب تشکیل دیتے ہیں تو ، موجودہ انڈیکس پر ختم ہونے والے ریاضی کے سلائسس کی تعداد تعداد کے برابر ہے۔پچھلے انڈیکس پلس پر ختم ہونے والے ریاضی کے سلائسوں میں سے 1. ایک دوسرے کے ساتھ ، موجودہ انڈیکس پر ختم ہونے والے ریاضی کے سلائسس کی تعداد 0. ہے جو سرے میں آخری قیمت دی گئی فہرست 1 میں ریاضی کے ٹکڑوں کی کل تعداد ہوگی۔ اس کا نفاذ ہے۔ازگر میں نقطہ نظر: پائیتھنڈف num_arithmetic_slices (arr): n = len (arr) اگر n <3: واپس 0 dp = [0] * n کی حد میں (2 ، n): if arr [i] - arr [i -1] == آر آر [i - 1] - arr [i - 2]: dp [i] = dp [i - 1] + 1 واپسی رقم (DP) اس عمل میں ، فنکشن num_arithmetic_slices () عددیوں کی فہرست لیتا ہےاے آر آر ان پٹ کے طور پر اور فہرست میں ریاضی کے ٹکڑوں کی تعداد لوٹاتا ہے۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست کی لمبائی 3 سے کم ہے اور اگر 0 ہے تو 0 لوٹ آئے گی۔اس کے بعد یہ ہر انڈیکس پر ختم ہونے والے ریاضی کے ٹکڑوں کی تعداد کو ذخیرہ کرنے کے لئے ایک سرنی ڈی پی کی ابتدا کرتا ہے۔اس کے بعد مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھرتا ہے۔آخر میں ، فنکشن صف میں اقدار کا مجموعہ لوٹاتا ہے ، جو دیئے گئے فہرست 1 میں ریاضی کے ٹکڑوں کی کل تعداد کی نمائندگی کرتا ہے۔ Num_arithmetic_slices () فنکشن کا ایک مثال استعمال: ازگر = [1 ، 2 ، 3 ، 4] پرنٹ۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ فہرست میں 3 ریاضی کے ٹکڑے ہیں: 123،234 ، اور 1234.1geeksforgeeks"
    },
    {
        "Question": "نوڈس کو داخل کرنے اور تلاش کرنے کے لئے بی ٹری کی نمائندگی کرنے والے ایک ازگر کلاس بنائیں اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ازگر میں ایک بی ٹری کا نفاذ ہے جو 1 کے کوڈ پر مبنی داخل اور سرچ کارروائیوں کی حمایت کرتا ہے: ازگرکلاس بری: کلاس نوڈ: ڈیف __init __ (خود ، ٹی): سیلف.کیئز = [] خود۔ بچوں = [] خود.leaf = true self.t = t def split (خود ، والدین ، i): new_node = خود .__ کلاس __ (self.t) mid = self.t - 1 new_node.children = self.children [مڈ + 1:] نیا_نوڈ.keys = self.keys [MID:] self.children = self.children [: mid + 1] self.ke.keys = self.keys [: وسط] اگر والدین: والدین۔ Insert_child (i + 1 ، new_node ، self.keys[وسط]) اور: نیا_روٹ = خود= new_rot def insert_child (خود ، i ، child ، key): self.children.insert (i ، child) self.ke.keys.insert (i - 1 ، key) child.Pearnt = self def __repr __ (خود): واپسی f \"<btree.node: {self.keys}> \"def __init __ (خود ، t): self.t = t اگر sell) sell.root = self.node (t) Def سرچ (خود ، کلید ، نوڈ = کوئی بھی نہیں): اگر نوڈ کوئی نہیں ہے: نوڈ = سیلف.روٹ اگر کلید میں نوڈ۔: i = 0 جب میں <لین (نوڈ.کیس) اور کلیدی> نوڈ.کیس [i]: i += 1 سیلف۔ سرچ (کلید ، نوڈ.کرن [i]) ڈیف داخل کریں (خود ، کلید): نوڈ= sell.root اگر لین (node.keys) == 2 * self.t - 1: new_root = self.nod.split (new_root ، 0) self.root = new_root نوڈ = نیا_روٹ جبکہ نوڈ نہیں ہے۔node.children [i] .keys) == 2 * self.t - 1: نوڈ.کرینین [i] .split (نوڈ ، i) اگر کلید> نوڈ.کیس [i]: i += 1 نوڈ = نوڈ۔بچے [i] اگر نوڈ میں کلید ہوں۔نفاذ ، بی ٹی آر ای کلاس ایک دیئے گئے ڈگری ٹی کے ساتھ بی ٹری کی نمائندگی کرتی ہے۔کلاس میں اندرونی کلاس نوڈ ہوتا ہے جو درخت میں نوڈ کی نمائندگی کرتا ہے۔نوڈ کلاس میں نوڈ میں چابیاں ذخیرہ کرنے کے لئے ایک سرنی کیز ہیں ، بچوں کے نوڈس کو ذخیرہ کرنے کے لئے ایک سرے کے بچے ، ایک بولین پتی ہے کہ اس بات کی نشاندہی کریں کہ آیا نوڈ ایک پتی نوڈ ہے ، اور ڈگری ٹی ہے۔نوڈ کلاس کے پاس نوڈ کو تقسیم کرنے ، چائلڈ نوڈ داخل کرنے ، اور نوڈ کی تار کی نمائندگی واپس کرنے کے طریقے بھی ہیں۔ بی ٹری کلاس میں ایک کنسٹرکٹر ہوتا ہے جو ان پٹ کے طور پر ڈگری ٹی لیتا ہے اور جڑ نوڈ کو شروع کرتا ہے۔کلاس کے پاس درخت میں ایک چابی تلاش کرنے اور درخت میں ایک چابی داخل کرنے کے طریقے بھی ہیں۔تلاش کا طریقہ جڑ کے نوڈ سے شروع ہونے والے درخت میں ایک چابی کی بار بار تلاش کرتا ہے۔داخل کرنے کا طریقہ درخت میں درخت کو جڑ کے نوڈ سے پتی کے نوڈ تک اور تقسیم کرنے والے نوڈس کو ضروری کے طور پر داخل کرکے ایک چابی داخل کرتا ہے۔ یہاں بٹی ٹری کلاس کا ایک مثال استعمال ہے: پائیٹونٹری = بی ٹی آر ای (3) درخت۔ INSERT (1) درخت۔داخل کریں (2) درخت۔ INSERT (3) ٹری۔ INSERT (4) ٹری.نسرٹ (5) پرنٹ (درخت.چارچ (3)) # پرنٹس <btree.nodBTREE کلاس کا استعمال کرتے ہوئے ڈگری 3 کے ساتھ ٹری۔اس کے بعد ہم داخل کرنے کا طریقہ استعمال کرکے درختوں میں 1 ، 2 ، 3 ، 4 ، اور 5 کی چابیاں داخل کرتے ہیں۔آخر میں ، ہم تلاش کے طریقہ کار کا استعمال کرتے ہوئے درخت میں کلیدی 3 کی تلاش کرتے ہیں اور نتیجہ پرنٹ کرتے ہیں ، جو نوڈ ہے جس میں کلید 3.1 گیتھب ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دی گئی تعداد کسی دوسرے نمبر کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد کسی بھی دوسرے نمبر کی طاقت ہے ، ہم مختلف طریقوں کو استعمال کرسکتے ہیں۔یہاں کچھ نقطہ نظر اور ان کے نفاذات ہیں: نقطہ نظر 1: بار بار ڈویژن کا آسان حل یہ ہے کہ جب تک کوئٹینٹ 1 نہ ہوجائے تب تک دیئے گئے نمبر کو ممکنہ بیس نمبر کے ذریعہ بار بار تقسیم کرنا ہے۔ اگر باقی ہر قدم پر 0 ہے تو ، دی گئی تعداد ایک طاقت ہےممکنہ بیس نمبر کی۔بصورت دیگر ، یہ نہیں ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف آئی ایس_ پاور (ایکس ، وائی): اگر x == 1: واپس y == 1 جبکہ y ٪ x == 0: y // = x ریٹرن y == 1 میں اس نفاذ میں ، فنکشن IS_POWER () دو عدد X اور Y کو ان پٹ کے طور پر لیتا ہے اور اگر Y X کی طاقت ہے اور غلط ہے تو وہ سچ ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ اگر ایکس 1 کے برابر ہے اور y 1 کے برابر ہے ، اس صورت میں y x کی طاقت ہے۔اس کے بعد بار بار Y کو X کے ذریعہ تقسیم کیا جاتا ہے جب تک کہ کوئٹینٹ 1 نہ ہوجائے۔ اگر باقی ہر قدم پر 0 ہوتا ہے تو ، فنکشن درست ہوجاتا ہے۔بصورت دیگر ، یہ غلط 1. اپرچ 2 کو لوٹاتا ہے۔اگر نتیجہ ایک عدد ہے تو ، دی گئی تعداد ممکنہ بیس نمبر کی طاقت ہے۔بصورت دیگر ، یہ نہیں ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونیمپورٹ میتھ ڈیف آئی ایس_ پاور (ایکس ، وائی): اگر x == 1: واپسی y == 1 پاور = انٹ (math.log (y ، x) + 0.5)واپسی x ** پاور == اس پر عمل درآمد ، فنکشن IS_POWER () دو عدد X اور y کو ان پٹ کے طور پر لیتا ہے اور اگر Y X کی طاقت ہے اور غلط ہے تو وہ سچ ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ اگر ایکس 1 کے برابر ہے اور y 1 کے برابر ہے ، اس صورت میں y x کی طاقت ہے۔اس کے بعد یہ ریاضی کا استعمال کرتے ہوئے X کے سلسلے میں Y کے لوگرتھم لیتا ہے۔اگر X کو نتیجہ کی طاقت میں اٹھایا گیا ہے تو یہ Y کے برابر ہے تو ، فنکشن درست لوٹتا ہے۔بصورت دیگر ، یہ غلط 2 کو لوٹاتا ہے۔ یہاں IS_POWER () فنکشن کا ایک مثال استعمال ہے: پائیتھن پرنٹ (IS_POWER (2 ، 8)) # پرنٹس ٹرو پرنٹ (IS_POWER (3 ، 8)) # پرنٹس پرنٹس ، ہم چیک کرتے ہیں کہ آیا نمبر 8 ہے یا نہیںآئی ایس_ پاور () فنکشن کا استعمال کرتے ہوئے 2 اور 3 کی طاقت۔فنکشن پہلی کال کے لئے سچ اور دوسری کال کے لئے غلط ہے ، جس سے یہ ظاہر ہوتا ہے کہ 8 2 کی طاقت ہے لیکن 3.1Geeksforgeeks2geeksforgeeks کی طاقت نہیں ہے۔"
    },
    {
        "Question": "\"ایک پروگرام لکھیں تاکہ کسی سبری کی زیادہ سے زیادہ رقم کو اس رکاوٹ کے ساتھ تلاش کیا جاسکے کہ سبری میں کوئی دو عناصر ملحقہ نہیں ہیں ، اور سبری اس فہرست کے اختتام پر لپیٹ سکتا ہے۔\"",
        "Answer": "اس رکاوٹ کے ساتھ کسی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے کہ سبری میں کوئی دو عناصر ملحقہ نہیں ہیں ، اور سبری اس فہرست کے اختتام پر لپیٹ سکتا ہے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ہر انڈیکس پر ختم ہونے والے غیر ملکی عناصر کی زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے ایک صف تشکیل دے سکتے ہیں۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے صف کو بھر سکتے ہیں: اگر موجودہ عنصر کو رقم میں شامل کیا گیا ہے تو ، موجودہ انڈیکس پر ختم ہونے والے غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم انڈیکس میں ختم ہونے والے غیر ایڈجینٹ عناصر کی زیادہ سے زیادہ رقم کے برابر ہے۔موجودہ انڈیکس کے علاوہ موجودہ عنصر سے پہلے دو پوزیشنیں۔ اگر موجودہ عنصر کو رقم میں شامل نہیں کیا گیا ہے تو ، موجودہ انڈیکس پر ختم ہونے والے غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم پچھلے حصے میں ختم ہونے والے غیر ایڈجینٹ عناصر کی زیادہ سے زیادہ رقم کے برابر ہے۔اشاریہ۔ سرنی میں حتمی قیمت فہرست 1 میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم ہوگی۔ اس رکاوٹ کو سنبھالنے کے لئے کہ سبری اس فہرست کے اختتام پر لپیٹ سکتا ہے ، ہم غیر ملکی عناصر کی زیادہ سے زیادہ رقم کی گنتی کرسکتے ہیں۔فہرست دو بار: ایک بار پہلے عنصر کے بغیر اور ایک بار آخری عنصر کے بغیر۔اس کے بعد ہم دونوں نتائج میں سے زیادہ سے زیادہ حتمی جواب کے طور پر لے سکتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف میکس_سم_نون_اڈجینٹ (اے آر آر): این = لین (اے آر آر) اگر این == 0: واپس 0 اگر ن == 1:واپسی er [0] اگر n == 2: زیادہ سے زیادہ واپسی (arr [0] ، arr [1]) dp1 = [0] * n dp2 = [0] * n dp1 [0] = arr [0] dp1 [1 [1] = زیادہ سے زیادہ (arr [0] ، arr [1]) dp2 [1] = arr [1] dp2 [2] = زیادہ سے زیادہ (arr [1] ، arr [2]) in in range (2 ، n - 1): dp1 [i] = زیادہ سے زیادہ (dp1 [i - 2] + arr [i] ، dp1 [i - 1]) میں in in range (3 ، n): dp2 [i] = زیادہ سے زیادہ (dp2 [i - 2 - 2] + آر آر [آئی] ، ڈی پی 2 [i-1]) اس عمل درآمد میں زیادہ سے زیادہ (ڈی پی 1 [-2] ، ڈی پی 2 [-1]) کی واپسی ، فنکشن میکس_سم_نون_اڈجینٹ () ان پٹ کے طور پر عددی arr کی فہرست لیتا ہے اور زیادہ سے زیادہ واپس کرتا ہے۔فہرست میں غیر ملکی عناصر کا مجموعہ۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا فہرست کی لمبائی 2 سے کم یا اس کے برابر ہے اور اگر یہ ہے تو دونوں عناصر میں سے زیادہ سے زیادہ واپس آجائے۔اس کے بعد یہ ہر انڈیکس پر ختم ہونے والے غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے دو صفوں DP1 اور DP2 کی ابتدا کرتا ہے۔اس کے بعد یہ مذکورہ بالا تکرار رشتہ کا استعمال کرتے ہوئے صفوں کو بھرتا ہے۔آخر میں ، فنکشن DP1 کے دوسرے سے آخری عنصر کی زیادہ سے زیادہ اور DP2 کے آخری عنصر کو لوٹاتا ہے ، جو فہرست 12 میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم کی نمائندگی کرتا ہے۔ یہاں میکس_سم_نون_اڈجینٹ () فنکشن کی ایک مثال استعمال: پائیٹونر۔= [3 ، 2 ، 5 ، 10 ، 7] پرنٹ (میکس_سم_نون_اڈجینٹ (اے آر آر)) # پرنٹس 15 میں اس مثال کے طور پر ، ہمیں اس رکاوٹ کے ساتھ ایک سبری کا زیادہ سے زیادہ رقم مل جاتا ہے کہ سبری میں کوئی دو عناصر ملحق نہیں ہیں ، اور سبریے کر سکتے ہیںمیکس_سم_نون_اڈجینٹ () فنکشن کا استعمال کرتے ہوئے ، فہرست کے اختتام کے ارد گرد لپیٹیں۔فنکشن 15 لوٹاتا ہے ، جو فہرست میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم ہے۔"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "متحرک پروگرامنگ کا استعمال کرتے ہوئے کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے ، ہم نیچے اپ اپروچ کو استعمال کرسکتے ہیں۔اس نقطہ نظر میں ، ہم فبونیکی تسلسل (0 اور 1) کے بنیادی معاملات سے شروع کرتے ہیں اور پچھلے دو نمبروں کا خلاصہ کرکے اگلے نمبروں کو تسلسل میں گنتی کرتے ہیں۔ہم حسابی اقدار کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرسکتے ہیں اور سرنی میں اقدار کو دوبارہ استعمال کرکے بے کار کمپیوٹوں سے بچنے کے ل .۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف فبونیکی (این): اگر n == 0: واپس [] اگر n == اگر n ==1: واپسی [0] fib = [0 ، 1] I in range (2 ، n) کے لئے: fib.append (fib [i - 1] + fib [i - 2]) اس عمل درآمد ، فنکشن fibonacci (فنکشن fibonacci () ان پٹ کے طور پر ایک عدد N لیتا ہے اور N-TH نمبر تک Fibonacci ترتیب کی فہرست واپس کرتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے اگر n 0 یا 1 کے برابر ہے اور بالترتیب 0 پر مشتمل خالی فہرست یا فہرست واپس کرتا ہے۔اس کے بعد یہ فبونیکی تسلسل میں پہلے دو نمبروں کے ساتھ ایک سرنی فب کا آغاز کرتا ہے۔اس کے بعد یہ پچھلے دو نمبروں کا خلاصہ کرکے اور نتائج کو صف میں شامل کرکے تسلسل میں اگلے نمبروں کی تکرار کرتا ہے۔آخر میں ، فنکشن سرنی کو لوٹاتا ہے ، جس میں فبونیکی تسلسل پر مشتمل ہوتا ہے۔3 ، 5 ، 8 ، 13 ، 21 ، 34] اس مثال میں ، ہم فبونیکی () فنکشن کا استعمال کرتے ہوئے 10 ویں نمبر تک فبونیکی تسلسل کا حساب لگاتے ہیں۔فنکشن لوٹتا ہے 01112358132134 ، جو 10 ویں نمبر پر فبونیکی سلسلے ہے۔"
    },
    {
        "Question": "سب سے بڑا پرائم پیلنڈرووم کسی دیئے گئے نمبر سے کم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "سب سے بڑے پرائم پیلنڈرووم کو کسی دیئے گئے نمبر سے کم تلاش کرنے کے ل we ، ہم مندرجہ ذیل الگورتھم کا استعمال کرسکتے ہیں: دیئے گئے نمبر سے شروع کریں اور پیچھے کی طرف تکرار کریں جب تک کہ ہمیں کوئی ایسی تعداد نہ مل جائے جو پرائم اور ایک پیلنڈرووم ہو۔ چیک کریں اگر ہر نمبر 2 سے تکرار کرکے بنیادی ہے۔نمبر کے مربع روٹ پر اور جانچ پڑتال کرنا کہ آیا اس حد میں کسی بھی عدد کے ذریعہ نمبر تقسیم ہے یا نہیں۔ چیک کریں کہ اگر ہر نمبر ایک تار میں اس کو تار میں تبدیل کرکے اور جانچ پڑتال کرکے اس کے ریورس کے برابر ہے تو اس پر عمل درآمد ہوتا ہے۔پائیون میں اس الگورتھم کا: پائیتھنڈف آئی ایس_پرائم (این): اگر ن <2: رینج میں I کے لئے غلط واپس لوٹیں (2 ، انٹ (این ** 0.5) + 1): اگر n ٪ i == 0: غلط ریٹرن ٹریوڈف is_palindrome واپس کریں(n): ریٹرن str (n) == str (n) [:: -1] Def سب سے بڑا_پائیم_پالینڈرووم (n): in کی حد میں (n -1 ، 0 ، -1): اگر is_prime (i) اور is_palindrome (is_palindrome (i): واپسی میں اس پر عمل درآمد کو واپس نہیں کرتا ، فنکشن IS_PRIME () ان پٹ کے طور پر ایک عدد N لیتا ہے اور اگر N بنیادی اور غلط ہے تو وہ سچ ہے۔فنکشن سب سے پہلے چیک کرتا ہے اگر n 2 سے کم ہے اور اگر یہ ہے تو غلط لوٹاتا ہے۔اس کے بعد یہ 2 سے ن کے مربع جڑ تک پہنچ جاتا ہے اور چیک کرتا ہے کہ اگر n اس حد میں کسی بھی عدد کے ذریعہ تقسیم ہوتا ہے۔اگر n ان میں سے کسی بھی عدد سے تقسیم ہوتا ہے تو ، فنکشن غلط لوٹاتا ہے۔بصورت دیگر ، یہ سچ لوٹتا ہے۔ فنکشن IS_PALINDROME () ان پٹ کے طور پر ایک عدد N لیتا ہے اور اگر n ایک palindrome ہے اور غلط ہے تو وہ سچ ہے۔فنکشن سب سے پہلے N کو ایک تار میں تبدیل کرتا ہے اور چیک کرتا ہے کہ اگر اسٹرنگ سلائس اشارے کا استعمال کرتے ہوئے اس کے الٹ کے برابر ہے۔ فنکشن سب سے بڑا_پائم_پالینڈرووم () ان پٹ کے طور پر ایک عدد N لیتا ہے اور N سے کم سب سے بڑا پرائم پیلنڈرووم واپس کرتا ہے۔فنکشن N - 1 سے 1 سے پیچھے کی طرف تکرار کرتا ہے اور چیک کرتا ہے کہ اگر ہر نمبر IS_PRIME () اور is_palindrome () افعال کا استعمال کرتے ہوئے دونوں پرائم اور ایک پالنڈرووم ہے۔اگر کوئی نمبر پرائم اور ایک پالنڈرووم دونوں ہی ہے تو ، فنکشن اس نمبر کو لوٹاتا ہے۔اگر اس طرح کی کوئی تعداد نہیں ملتی ہے تو ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔ یہاں سب سے بڑے_پائیم_پالنڈرووم () فنکشن کا ایک مثال استعمال: پائیتھون پرنٹ (سب سے بڑا_پائیم_پالنڈرووم (1000)) # پرنٹس 929 ان مثال کے طور پر ، ہمیں سب سے بڑا پرائم پیلنڈرووم 1000 سے کم سب سے بڑا پرائم پیلنڈرووم ملتا ہے جس کا استعمال کرتے ہوئے 1000 سے کم ہوتا ہے۔تقریبفنکشن 929 لوٹتا ہے ، جو 1000.1github2leetcode3wikedia4geeksforgeeks5reddit سے کم 1000.1 گیتھوب 2 لیئٹ کوڈ 3 وائی پیڈیا 4 جی ای ای ایکسفورجیکس سے کم ہے"
    },
    {
        "Question": "ایک ازگر کی کلاس بنائیں جو خود توازن بائنری سرچ درخت (جیسے AVL درخت یا سرخ رنگ کے درخت) کی نمائندگی کرتی ہے اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقے نافذ کریں۔",
        "Answer": "ازگر میں بائنری سرچ کے درختوں اور سرخ رنگ کے درختوں جیسے خود سے توازن بائنری سرچ ٹری کے نفاذ دستیاب ہیں۔یہاں کچھ وسائل ہیں جو ان اعداد و شمار کے ڈھانچے کی نفاذ اور وضاحت فراہم کرتے ہیں: PYPI پر خود توازن بائنری سرچ-ٹری پیکیج ایک AVL Treath1 کا ازگر کا نفاذ فراہم کرتا ہے۔پیکیج میں ایک ٹرینوڈ کلاس شامل ہے جو درخت میں ایک نوڈ کی نمائندگی کرتا ہے اور ایس بی بی ایس ٹی کلاس جو درخت کی نمائندگی کرتا ہے۔ایس بی بی ایس ٹی کلاس درخت میں نوڈس ڈالنے اور تلاش کرنے کے طریقے مہیا کرتی ہے۔ گٹ ہب پر AVL_TREE ذخیرہ ازگر 2 میں AVL درخت کا نفاذ فراہم کرتا ہے۔ذخیرہ میں ایک نوڈ کلاس شامل ہے جو درخت میں نوڈ کی نمائندگی کرتا ہے اور ایک آولٹری کلاس جو درخت کی نمائندگی کرتا ہے۔اولٹری کلاس درخت میں نوڈس ڈالنے اور تلاش کرنے کے طریقے مہیا کرتی ہے۔ اسکیپیتھون کی ویب سائٹ متوازن بائنری درختوں کی وضاحت اور ازگر میں کسی پروگرام کے نفاذ کی وضاحت فراہم کرتی ہے تاکہ اس بات کا تعین کیا جاسکے کہ بائنری کا درخت متوازن ہے یا 33۔مضمون میں ایک الگورتھم شامل ہے کہ یہ چیک کرنے کے لئے کہ آیا بائنری ٹری متوازن ہے اور الگورتھم کا ازگر کا نفاذ ہے۔ گیکسفورجیکس ویب سائٹ ان کے 4 کو نافذ کرنے کے لئے خود توازن بائنری تلاش کے درختوں اور ایک ازگر لائبریری کی وضاحت فراہم کرتی ہے۔لائبریری میں اے وی ایل کے درختوں ، سرخ سیاہ درختوں ، اور چھڑکنے والے درختوں کے لئے کلاسوں کے ساتھ ساتھ درختوں میں نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقے بھی شامل ہیں۔ ڈبلیو 3 ریسورس ویب سائٹ متوازن بائنری بنانے کے لئے ازگر میں ایک پروگرام کا نفاذ فراہم کرتی ہے۔ایک ترتیب شدہ سرنی 5 سے درخت تلاش کریں۔مضمون میں ایک ٹرینوڈ کلاس شامل ہے جو درخت میں ایک نوڈ کی نمائندگی کرتا ہے اور ایک ترتیب شدہ سرنی سے ایک متوازن بائنری سرچ ٹری تیار کرتا ہے۔ ٹیوٹوریلس پوائنٹ کی ویب سائٹ متوازن بائنری درختوں کی وضاحت فراہم کرتی ہے اور یہ چیک کرنے کے لئے تکرون میں کسی پروگرام کے نفاذ کی وضاحت فراہم کرتی ہے۔بائنری کا درخت متوازن ہے یا نہیں۔مضمون میں ایک نوڈ کلاس شامل ہے جو درخت میں ایک نوڈ کی نمائندگی کرتا ہے اور آئی ایس_بلنسڈ فنکشن ہے جو چیک کرتا ہے کہ اگر بائنری ٹری متوازن ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کسی بھی بلٹ ان فنکشن کا استعمال کیے بغیر دیئے گئے نمبر ایک بہترین مربع ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کسی بھی بلٹ ان فنکشن کا استعمال کیے بغیر دیئے گئے نمبر ایک بہترین مربع ہے ، ہم مختلف طریقوں کو استعمال کرسکتے ہیں۔یہاں کچھ نقطہ نظر اور ان کے نفاذ ہیں: نقطہ نظر 1: انٹیجر اسکوائر روٹ الگورتھمون حل انٹیجر اسکوائر روٹ الگورتھم کو استعمال کرنا ہے اور اس بات کی تصدیق کرنا ہے کہ جڑ کی مربع قیمت اصل تعداد ہے۔ہم مربع جڑ کے ابتدائی اندازے کے ساتھ شروع کرسکتے ہیں اور تکراری طور پر اندازہ کو بہتر بنا سکتے ہیں جب تک کہ یہ اصل مربع جڑ میں نہ آجائے۔اس کے بعد ہم یہ چیک کرسکتے ہیں کہ آیا اندازہ کا مربع اصل نمبر 1 کے برابر ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف آئی ایس_پیرفیکٹ_سکیئر (این): اگر این <0: غلط واپس لوٹیں اگر n == 0: واپس سچ اندازہ = n واپس کریں۔// 2 جبکہ اندازہ کریں * اندازہ> n: اندازہ = (اندازہ + n // اندازہ) // 2 واپسی کا اندازہ * اندازہ == اس پر عمل درآمد ، فنکشن IS_PERFECT_SQUARE () ان پٹ کے طور پر ایک عدد N لیتا ہے اور اگر N ہے تو سچ واپس آجاتا ہے۔ایک کامل مربع اور غلط۔فنکشن سب سے پہلے چیک کرتا ہے اگر n 0 سے کم ہے اور اگر یہ ہے تو غلط لوٹاتا ہے۔اس کے بعد یہ جانچ پڑتال کرتا ہے کہ آیا ن 0 کے برابر ہے اور اگر یہ ہے تو سچائی واپس آجاتا ہے۔اس کے بعد N کے مربع جڑ کا ابتدائی اندازہ N // 2 کے طور پر شروع کرتا ہے۔ پھر یہ اندازہ اور N // اندازہ کی اوسط کی اوسط کمپیوٹنگ کرکے اور // آپریٹر کا استعمال کرتے ہوئے قریب ترین عددی تک پہنچ کر اندازہ لگاتا ہے۔اس کے بعد یہ جانچ پڑتال کرتا ہے کہ آیا اندازہ کا مربع N کے برابر ہے اور اگر یہ ہے تو وہ سچ ہے۔بصورت دیگر ، یہ غلط لوٹتا ہے۔اگر کسی وقت قیمت 0 ہوجاتی ہے تو ، ہم کہہ سکتے ہیں کہ نمبر ایک بہترین مربع ہے۔بصورت دیگر ، یہ نہیں ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف is_perfect_square (n): اگر n <0: غلط i = 1 واپس لوٹائیں جبکہ n> 0: n -= i += 2 واپسی n == 0 اس پر عمل درآمد، فنکشن is_perfect_square () ان پٹ کے طور پر ایک عدد n لیتا ہے اور اگر n ایک کامل مربع ہے اور غلط ہے تو وہ سچ ہے۔فنکشن سب سے پہلے چیک کرتا ہے اگر n 0 سے کم ہے اور اگر یہ ہے تو غلط لوٹاتا ہے۔اس کے بعد یہ متغیر I کو 1 سے شروع کرتا ہے اور بار بار ن سے عجیب تعداد کو گھٹا دیتا ہے جب تک کہ یہ 0 یا منفی نہ ہوجائے۔اگر کسی وقت N 0 بن جاتا ہے تو ، فنکشن درست ہوجاتا ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ IS_PERFECT_SQUARE () فنکشن کا ایک مثال استعمال: ازگر پرنٹ (is_perfect_square (16)) # پرنٹس ٹرو پرنٹ (IS_PERFECT_SQUARE (17)) # پرنٹس پرنٹس اس مثال کے طور پر ، ہم چیک کرتے ہیں کہ نمبر 16 اور 17 کامل اسکوائر ہیں یا نہیں۔is_perfect_square () فنکشن کا استعمال کرتے ہوئے۔فنکشن پہلی کال کے لئے سچ اور دوسری کال کے لئے غلط ہے ، جس سے یہ ظاہر ہوتا ہے کہ 16 ایک کامل مربع ہے لیکن 17 نہیں ہے۔"
    },
    {
        "Question": "دو دیئے گئے ڈوروں کی سب سے طویل عام سسٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دو دیئے گئے ڈوروں کی سب سے طویل مشترکہ تزئین کی تلاش کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔اس کے بعد ہم ٹیبل میں زیادہ سے زیادہ قیمت تلاش کرسکتے ہیں اور اسے سب سے طویل عام سبسٹرنگ نکالنے کے لئے استعمال کرسکتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف طویل ترین_کومون_سبسٹرنگ (ایس 1 ، ایس 2): ایم ، این = لین (ایس 1) ، لین (ایس 2)جدول = [[0] * (n + 1) رینج میں _ کے لئے (m + 1)] میکس_لن = 0 اختتام = 0 کے لئے رینج (1 ، ایم + 1): رینج میں جے کے لئے (1 ، n + 1): اگر S1 [i - 1] == s2 [j - 1]: ٹیبل [i] [j] = ٹیبل [i - 1] [j - 1] + 1 اگر ٹیبل [i] [j]> میکس_لن:میکس_لن = ٹیبل [i] [j] اختتام = i else: ٹیبل [i] [j] = 0 واپس S1 [اختتام - میکس_لن: اختتام] اس عمل میں ، فنکشن سب سے طویل_کومن_سبسٹرنگ () دو تاریں S1 اور S2 کو ان پٹ کے طور پر لیتا ہے اوردونوں ڈوروں کی سب سے طویل عام سبسٹرنگ لوٹتا ہے۔فنکشن سب سے پہلے طول و عرض (M + 1) X (n + 1) کے ساتھ ٹیبل ٹیبل کی ابتدا کرتا ہے ، جہاں M اور N بالترتیب S1 اور S2 کی لمبائی ہیں۔یہ متغیرات میکس_لن کو بھی شروع کرتا ہے اور 0 پر اختتام پذیر ہوتا ہے تاکہ S1 میں زیادہ سے زیادہ لمبائی اور اس کی آخری پوزیشن کو ٹریک رکھنے کے ل .۔اس کے بعد یہ S1 اور S2 کے تمام ممکنہ ذیلی ذخیروں پر تکرار کرتا ہے اور ہر ایک کے سب سے لمبے لمبے عام لاحقہ کی لمبائی کے ساتھ ٹیبل کو بھرتا ہے۔اگر کسی عام لاحقہ کی لمبائی میکس_لن سے زیادہ ہے تو ، فنکشن میکس_لن کو اپ ڈیٹ کرتا ہے اور نئی زیادہ سے زیادہ لمبائی اور اختتامی پوزیشن کی عکاسی کرنے کے لئے اختتام پذیر ہوتا ہے۔آخر میں ، فنکشن S1 اور S2 کے سب سے طویل عام سبسٹرنگ کو واپس کرتا ہے جس میں S1 کے سٹرنگ کو نکالا جاتا ہے جو پوزیشن کے اختتام پر ختم ہوتا ہے اور اس کی لمبائی زیادہ ہے۔پرنٹ (طویل ترین_کومون_سبسٹرنگ (S1 ، S2)) # پرنٹس \"ABC\" اس مثال میں ، ہمیں طویل ترین_کومون_سبسٹرنگ () فنکشن کا استعمال کرتے ہوئے تاروں کی \"ABABC\" اور \"BABCA\" کی سب سے طویل عام سبسٹرنگ ملتی ہے۔فنکشن \"ABC\" لوٹاتا ہے ، جو دو تاروں کی سب سے طویل عام سبسٹرنگ ہے۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "انٹیجرز کی ایک دی گئی فہرست میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت تلاش کرنے کے ل we ، ہم فہرست میں موجود ہر ممکنہ جوڑے کے XOR کی گنتی کرنے اور زیادہ سے زیادہ قیمت پر نظر رکھنے کے لئے بٹ ویس XOR آپریٹر (^) کا استعمال کرسکتے ہیں۔تاہم ، اس نقطہ نظر میں O (n^2) کی وقت کی پیچیدگی ہے ، جہاں N فہرست کی لمبائی ہے ، جو بڑی فہرستوں کے لئے موثر نہیں ہے۔ ایک زیادہ موثر نقطہ نظر یہ ہے کہ بائنری نمائندگی کو ذخیرہ کرنے کے لئے ٹرائی ڈیٹا ڈھانچے کا استعمال کیا جائے۔فہرست میں شامل نمبروں کو اور دو نمبروں کی زیادہ سے زیادہ XOR قیمت کو ٹرائی کو عبور کرکے اور بٹس کا انتخاب کرکے جو XOR کی قیمت کو زیادہ سے زیادہ بناتے ہیں۔اس نقطہ نظر میں O (n لاگ ایم) کی وقت کی پیچیدگی ہے ، جہاں ایم فہرست میں تعداد کی ثنائی نمائندگی میں بٹس کی زیادہ سے زیادہ تعداد ہے ، جو بروٹ فورس کے نقطہ نظر سے کہیں بہتر ہے۔ اس نقطہ نظر کا نفاذ ہے۔ازگر میں: پائیتھونکلاس ٹرائینوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈرین = {} سیلف۔ آئس_ینڈ = فالسکلاس ٹری: ڈیف __Init __ (خود): سیل.روٹ = ٹرائینوڈ () ڈیف داخل (خود ، نمبر): نوڈ = خود۔رینج (31 ، -1 ، -1) میں I کے لئے جڑ: بٹ = (num >> i) اور 1 اگر تھوڑا سا نوڈ میں نہیں ہے۔ بچوں میں: نوڈ.کرینین [بٹ] = ٹرائینوڈ () نوڈ = نوڈ۔ چائلڈر [بٹ] node.is_end = حقیقی Def find_max_xor (خود ، نمبر): نوڈ = سیلف.روٹ xor = 0 میں I کے لئے رینج (31 ، -1 ، -1): بٹ = (نمبر >> i) اور 1 اگر 1 -بٹنوڈ میں۔ بچوں میں: نوڈ = نوڈ.کرز [1 - بٹ] زور | = (1 << i) اور: نوڈ = نوڈ.کرنین [بٹ] واپس xordef میکس_ ایکسور (نمبر): ٹری = ٹری () نمبر میں نمبر کے لئے نمبر: trie.insert (num) max_xor = 0 nums میں نمبر کے لئے: میکس_ ایکسور = میکس (میکس_ ایکسور ، ٹری۔فائنڈ_میکس_ ایکسور (نمبر)) میکس_ ایکسورین کی واپسی اس پر عمل درآمد ، ٹرینوڈ کلاس ٹری میں ایک نوڈ کی نمائندگی کرتا ہے اور اس میں ذخیرہ کرنے کے لئے ایک لغت کے بچے ہیں۔چائلڈ نوڈس اور ایک بولین آئی ایس ای ڈی اس بات کی نشاندہی کرنے کے لئے کہ آیا نوڈ کسی نمبر کے اختتام کی نمائندگی کرتا ہے۔ٹری کلاس خود ہی ٹری کی نمائندگی کرتی ہے اور اس کی جڑ نوڈ ہے۔ٹری کلاس ٹرائی میں ایک نمبر داخل کرنے اور ٹرائی میں کسی نمبر کی زیادہ سے زیادہ XOR قیمت تلاش کرنے کے طریقے مہیا کرتی ہے۔ میکس_ ایکسور () فنکشن ان پٹ کے طور پر انٹیجر نمبروں کی فہرست لیتا ہے اور فہرست میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت لوٹاتا ہے۔فنکشن سب سے پہلے ایک ٹری تشکیل دیتا ہے اور فہرست میں موجود تمام نمبروں کو ٹرائی میں داخل کرتا ہے۔اس کے بعد اس فہرست میں موجود تمام نمبروں پر تکرار کرتا ہے اور Find_max_xor () طریقہ کار کا استعمال کرتے ہوئے ٹری میں ہر نمبر کی زیادہ سے زیادہ XOR قیمت تلاش کرتی ہے۔آخر میں ، فنکشن زیادہ سے زیادہ XOR ویلیو لوٹاتا ہے۔ یہاں میکس_ ایکسور () فنکشن کا ایک مثال استعمال ہے: پائیتھونومس = [3 ، 10 ، 5 ، 25 ، 2 ، 8] پرنٹ (میکس_ ایکسور (نمبر)) # پرنٹ 28 ان مثال کے طور پر ، ہمMAX_XOR () فنکشن کا استعمال کرتے ہوئے لسٹ 31052528 میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت تلاش کریں۔فنکشن 28 لوٹتا ہے ، جو فہرست میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت ہے۔"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کو پیش نظارہ کیا جاسکتا ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو اظہار اور آپریٹرز کو پیشگی پیش کرنے کی اجازت دی جاسکتی ہے ، ہم افتتاحی علامتوں کو ٹریک رکھنے اور اسٹیک سے دور رکھنے کے لئے اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔ہمیں ایک اختتامی علامت کا سامنا کرنا پڑتا ہے۔اگر اختتامی علامت اسٹیک کے اوپری حصے سے مماثل ہے تو ، ہم جاری رکھیں۔بصورت دیگر ، اظہار متوازن نہیں ہے۔جب ہم اسی طرح کے اختتامی علامتوں کا سامنا کرتے ہیں تو ہم افتتاحی علامتوں کو اسٹیک پر دھکیل کر اور ان کو پاپ کرتے ہوئے بھی گھریلو تاثرات کو سنبھال سکتے ہیں۔ یہاں تک کہ ازگر میں اس نقطہ نظر کا نفاذ: پائتھونڈف آئی ایس_والیڈ_ ایکسپریشن (ایس): اسٹیک = [] ایس میں سی کے لئے:اگر c in \"({[\": stack.append (c) elif c in \")}]\": اگر اسٹیک نہیں ہے تو: جھوٹا الیف واپس لوٹائیں c == \")\" اور اسٹیک [-1] == \"(\": اسٹیک.POP () ELIF C == \"}\" اور اسٹیک [-1] == \"{\": stack.pop () elif c == \"]\" اور اسٹیک [-1] == \"[\": stack.pop() اور: غلط ریٹرن اس عمل کو اسٹیک نہ کریں ، فنکشن IS_Valid_expression () ان پٹ کے طور پر ایک تار لیتا ہے اور اگر متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے۔ایک خالی اسٹیک۔ پھر یہ ایس کے تمام کرداروں پر تکرار کرتا ہے اور ابتدائی علامتوں کو اسٹیک پر دھکیل دیتا ہے اور جب ہم اسی طرح کے اختتامی علامتوں کا سامنا کرتے ہیں تو انہیں پاپ کردیتے ہیں۔اگر اختتامی علامت اسٹیک کے اوپری حصے سے مماثل ہے تو ، ہم جاری رکھیں۔بصورت دیگر ، اظہار متوازن نہیں ہے اور فنکشن غلط لوٹتا ہے۔اگر ہم تار کے اختتام پر پہنچ جاتے ہیں اور اسٹیک خالی ہوتا ہے تو ، اظہار متوازن ہوتا ہے اور فنکشن سچ ہوتا ہے۔ یہاں IS_Valid_expression () فنکشن: ازگر = \"((2 + 3) * 5) / (4) کی ایک مثال استعمال ہے۔- 1) \"پرنٹ (is_valid_expression (s)) # پرنٹس سچ ہے ، اس مثال کے طور پر ، ہم چیک کرتے ہیں کہ آیا تار\" (2 + 3) * 5) / (4 - 1) \"متوازن قوسین ، بریکٹ ، اور کے ساتھ ایک درست اظہار ہےis_valid_expression () فنکشن کا استعمال کرتے ہوئے گھوبگھرالی منحنی خطوط وحدانی۔فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اظہار درست اور متوازن ہے۔"
    },
    {
        "Question": "موثر سابقہ تلاش اور الفاظ کی گنتی کی حمایت کے ساتھ ایک ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "\"ایک مقررہ تعداد کے ساتھ سیڑھیاں چڑھنے کے لئے الگ الگ طریقوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں آپ ایک وقت میں 1 یا 2 قدم اٹھاسکتے ہیں۔\"",
        "Answer": "سیڑھی پر چڑھنے کے الگ الگ طریقوں کی تعداد تلاش کرنے کے ل a ، ایک دیئے گئے اقدامات کے ساتھ ، جہاں آپ ایک وقت میں 1 یا 2 قدم لے سکتے ہیں ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم 1 قدم اور 2 قدموں کے بنیادی معاملات سے شروع کرسکتے ہیں ، جن میں بالترتیب 1 راستہ اور 2 طریقے چڑھنے کے لئے ہیں۔اس کے بعد ہم اس تکرار کے رشتے کو استعمال کرسکتے ہیں کہ ن اقدامات پر چڑھنے کے طریقوں کی تعداد N-1 اقدامات اور N-2 اقدامات پر چڑھنے کے طریقوں کی تعداد کے برابر ہے۔اس کی وجہ یہ ہے کہ ہم یا تو (N-1) ویں قدم سے 1 قدم اٹھاسکتے ہیں یا NTH مرحلے تک پہنچنے کے لئے (N-2) ویں قدم سے 2 قدم اٹھا سکتے ہیں۔ہم ہر قدم پر چڑھنے اور اقدار کی تکراری کے طریقوں کی تعداد کو ذخیرہ کرنے کے لئے ایک فہرست کا استعمال کرسکتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف کاؤنٹ_ ویز (این): اگر n == 1: واپس 1 اگر n == 2:2 طریقے واپس کریں = [0] * (n + 1) طریقوں [1] = 1 طریقے [2] = 2 میں I کے لئے (3 ، n + 1): طریقے [i] = طریقے [i - 1] + طریقے[i - 2] اس عمل میں لوٹنے والے طریقے [n] ، فنکشن کاؤنٹ_ ویز () ایک ان پٹ کے طور پر ایک عدد N لیتا ہے اور ن قدموں کے ساتھ سیڑھیاں چڑھنے کے الگ الگ طریقوں کی تعداد کو واپس کرتا ہے ، جہاں آپ یا تو 1 یا 2 قدم اٹھاسکتے ہیں۔ایک وقت.فنکشن سب سے پہلے چیک کرتا ہے کہ اگر n 1 یا 2 کے برابر ہے اور اس سے متعلقہ بیس کیس کی اقدار کو لوٹاتا ہے۔اس کے بعد یہ لمبائی کے ایک فہرست کے طریقوں کا آغاز کرتا ہے جس میں تمام اقدار 0 پر سیٹ کی جاتی ہیں۔اس کے بعد تکرار کے ساتھ رشتہ کا استعمال کرتے ہوئے 3 سے N تک کے طریقوں کی اقدار [i] کی اقدار کی گنتی کرتی ہے۔آخر میں ، یہ ان طریقوں کی قدر کو واپس کرتا ہے [n] ، جو ن مراحل کے ساتھ سیڑھیاں چڑھنے کے الگ الگ طریقوں کی تعداد ہے۔ یہاں گنتی_ایس () فنکشن کا ایک مثال استعمال: پائیتھن = 5 پرنٹ (گنتی_ایس (این)) # پرنٹس 8inاس مثال کے طور پر ، ہمیں گنتی_ایس () فنکشن کا استعمال کرتے ہوئے 5 اقدامات کے ساتھ سیڑھیاں چڑھنے کے الگ الگ طریقوں کی تعداد ملتی ہے۔فنکشن 8 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سیڑھیاں پر چڑھنے کے 8 الگ الگ طریقے ہیں۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر لاگ ان کے وقت کی پیچیدگی کا استعمال کرتے ہوئے کسی اور نمبر کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے نمبر کسی دوسرے نمبر کی طاقت ہے جو لوگرتھمک ٹائم پیچیدگی کا استعمال کرتے ہوئے ، ہم لوگرتھمک پراپرٹی کا استعمال کرسکتے ہیں کہ اگر کوئی نمبر Y X کی طاقت ہے تو ، پھر بیس X میں Y کا لوگرتھم ایک عدد ہے۔ہم اس پراپرٹی کا استعمال ممکنہ بیس نمبر کی بنیاد پر دیئے گئے نمبر کے لوگرتھم کو تلاش کرنے کے لئے کرسکتے ہیں اور چیک کریں کہ آیا یہ کوئی عدد ہے۔ہم دیئے گئے نمبر کے 2 سے مربع روٹ تک تمام ممکنہ بیس نمبروں پر تکرار کرسکتے ہیں اور یہ چیک کریں کہ آیا لوگرتھم ایک عدد ہے۔ یہ ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونیمپورٹ میتھ ڈیف آئی ایس_ پاور_ف (نمبر): اگر نمبر ==1: رینج (2 ، int (math.sqrt (num)) + 1) میں I کے لئے سچ واپس لوٹیں: اگر math.log (num ، i) .is_integer (): سچ واپس لوٹائیں اس پر عمل درآمد ، فنکشن is_power_of ()ان پٹ کے طور پر دو انٹیجر نمبر اور بیس لیتا ہے اور اگر نمبر بیس کی طاقت ہے ، اور دوسری صورت میں غلط ہے تو وہ سچ ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ اگر نمبر 1 کے برابر ہے اور سچ واپس آجاتا ہے ، کیونکہ 1 کسی بھی اڈے کی طاقت ہے۔اس کے بعد یہ تمام ممکنہ بیس نمبروں پر 2 سے نمبر کے مربع جڑ تک پہنچ جاتا ہے اور چیک کرتا ہے کہ اگر ممکنہ بیس نمبر کی بنیاد پر NUM کا لوگرتھم فلوٹ کلاس کے IS_Integer () طریقہ کار کا استعمال کرتے ہوئے ایک عدد ہے۔اگر یہ ایک عدد ہے تو ، فنکشن درست لوٹتا ہے۔اگر ممکنہ بیس نمبروں میں سے کسی کے نتیجے میں کوئی انٹیجر لوگرتھم نہیں ہوتا ہے تو ، فنکشن غلط کو واپس کرتا ہے۔ IS_POWER_OF () فنکشن کی مثال کے طور پر استعمال: Pythonnum = 64base = 2 پرنٹ (IS_POWER_OF (Num ، base)) # پرنٹ اس مثال کے طور پر ، ہم چیک کرتے ہیں ، ہم چیک کرتے ہیں۔اگر نمبر 64 IS_POWER_OF () فنکشن کا استعمال کرتے ہوئے 2 کی طاقت ہے۔فنکشن سچ کی طرف لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ 64 2.1CODINGNINJAS2GEEKSFORGEEKS3TOWARDASDASDASCINCEINCE 4MATHOVERFLOW5RITAMBHARA کی طاقت ہے"
    },
    {
        "Question": "اونچائیوں کی ایک دی گئی فہرست میں ہسٹگرامس کے ذریعہ تشکیل شدہ مستطیل کا زیادہ سے زیادہ رقبہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "اونچائیوں کی دی گئی فہرست میں ہسٹگرامس کے ذریعہ تشکیل شدہ مستطیل کا زیادہ سے زیادہ رقبہ تلاش کرنے کے ل we ، ہم ہسٹوگرام میں سب سے بڑا مستطیل تلاش کرنے کے نقطہ نظر کو استعمال کرسکتے ہیں۔ہم فہرست میں ہر اونچائی کو ہسٹوگرام میں بار کے طور پر علاج کرسکتے ہیں ، اور سب سے بڑا مستطیل تلاش کرسکتے ہیں جو سلاخوں کا استعمال کرتے ہوئے تشکیل دیا جاسکتا ہے۔سب سے بڑے مستطیل کی اونچائی مختصر ترین بار کی اونچائی کے برابر ہوگی اور چوڑائی بائیں اور دائیں طرف کی سلاخوں کے درمیان فاصلے کے برابر ہوگی جو مختصر بار سے کم ہیں۔ہم ہسٹگرام میں سلاخوں کے اشاریوں کو ٹریک رکھنے اور ہر بار کے لئے سب سے بڑے مستطیل کے علاقے کی گنتی کے لئے ایک اسٹیک کا استعمال کرسکتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف میکس_ریکٹنگل_اریہ (اونچائی): اسٹیک = [] میکس_یریا =0 i = 0 جب میں <لین (اونچائی): اگر اسٹیک یا اونچائی نہیں تو [i]> = اونچائی [اسٹیک [-1]]: اسٹیک.ایپینڈ (i) i += 1 اور: ٹاپ = اسٹیک.پپ ()رقبہ = اونچائی [اوپر] * (i - اسٹیک [-1] - 1 اگر اسٹیک ورنہ I) میکس_یریا = زیادہ سے زیادہ (میکس_یریا ، ایریا) جبکہ اسٹیک: ٹاپ = اسٹیک.پپ () رقبہ = اونچائی [اوپر] * (i -اسٹیک [-1] - 1 اگر اسٹیک اور اسٹیک I) میکس_یریا = زیادہ سے زیادہ (میکس_یریا ، ایریا) میکس_یرین لوٹائیں اس پر عمل درآمد ، فنکشن میکس_ریکٹنگل_یریا () ان پٹ کے طور پر انٹیگرس کی اونچائیوں کی فہرست لیتا ہے اور ہسٹگرام میں پیدا ہونے والے مستطیل کا زیادہ سے زیادہ رقبہ لوٹاتا ہے۔فہرست.فنکشن سب سے پہلے ایک خالی اسٹیک اور متغیر میکس_یریا کو 0 پر شروع کرتا ہے۔ یہ پھر ہسٹوگرام میں سلاخوں کے اوپر تکرار کرتا ہے اور ہر بار کے انڈیکس کو اسٹیک پر دھکیل دیتا ہے اگر یہ پچھلی بار سے لمبا ہے۔اگر یہ چھوٹا ہے تو ، فنکشن اسٹیک سے ٹاپ انڈیکس کو پاپ کرتا ہے اور سب سے بڑے مستطیل کے علاقے کی گنتی کرتا ہے جو پاپڈ انڈیکس میں بار کا استعمال کرتے ہوئے مختصر ترین بار کے طور پر تشکیل دے سکتا ہے۔مستطیل کی چوڑائی موجودہ انڈیکس اور اسٹیک کے اوپری حصے میں انڈیکس کے درمیان فاصلے کے برابر ہے ، یا اگر اسٹیک خالی ہے تو موجودہ انڈیکس۔فنکشن MAX_AREA متغیر کو اب تک کے حساب سے زیادہ سے زیادہ علاقے کے ساتھ اپ ڈیٹ کرتا ہے۔ایک بار جب اس نے ہسٹگرام میں تمام سلاخوں پر کارروائی کرلی ہے تو ، فنکشن اسٹیک سے باقی اشاریوں کو پاپ کرتا ہے اور سب سے بڑے مستطیل کے علاقے کی گنتی کرتا ہے جو ہر انڈیکس کو مختصر ترین بار کے طور پر استعمال کرتے ہوئے تشکیل دیا جاسکتا ہے۔فنکشن زیادہ سے زیادہ رقبے کو لوٹاتا ہے۔ یہاں میکس_ریکٹنگل_اریہ () فنکشن کا ایک مثال استعمال ہے: پائیتھون ہائٹس = [2 ، 1 ، 5 ، 6 ، 2 ، 3] پرنٹ (میکس_ریکٹنگل_اریہ (اونچائی))زیادہ سے زیادہ مستطیل کا زیادہ سے زیادہ رقبہ جو MAX_RECTANGELL_AREA () فنکشن کا استعمال کرتے ہوئے لسٹ 215623 میں ہسٹگرامس کے ذریعہ تشکیل دیا گیا ہے۔فنکشن 10 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سب سے بڑا مستطیل جس کی تشکیل کی جاسکتی ہے اس کا رقبہ 10.1afteracademy2leetcode3interviewiewbit4takeuforword5javatPoint ہوتا ہے"
    },
    {
        "Question": "ایک گراف کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور ڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے دو عمودیوں کے مابین مختصر ترین راستہ تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "ایک گراف کی نمائندگی کرنے والے ازگر کی کلاس بنانے کے ل and اور ڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے دو عمودیوں کے مابین مختصر ترین راستہ تلاش کرنے کے طریقوں کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: گراف کی نمائندگی کے لئے ایک گراف کلاس بنائیں۔گراف کلاس میں عمودی اور ان کے کناروں کو ذخیرہ کرنے کے لئے ایک لغت ہونی چاہئے ، اور گراف میں عمودی اور کناروں کو شامل کرنے کے طریقے فراہم کرنا چاہئے۔ڈیجکسٹرا کا الگورتھم غیر منحصر عمودیوں کا ایک سیٹ اور اسٹارٹ ورٹیکس سے ان کے عارضی فاصلوں کا ایک سیٹ برقرار رکھتے ہوئے کام کرتا ہے۔ہم سب سے چھوٹے عارضی فاصلے کے ساتھ عمودی کو موثر انداز میں منتخب کرنے اور اس کے ہمسایہ ممالک کے عارضی فاصلوں کو اپ ڈیٹ کرنے کے لئے ترجیحی قطار کا استعمال کرسکتے ہیں۔ہم پچھلے عمودی حصے پر بھی نظر رکھ سکتے ہیں جو مختصر ترین راستے میں ہر ایک چوٹی کی طرف جاتا ہے۔ ڈیجکسٹرا کے الگورتھم کے حساب سے پچھلے ورٹیکس معلومات کا استعمال کرتے ہوئے دو عمودیوں کے درمیان مختصر ترین راستہ واپس کرنے کا ایک طریقہ۔ہیپ کیو کلاس گراف: ڈیف __init __ (خود): سیلف ۔ورٹیکس = {} ڈیف ایڈ_ورٹیکس (سیلف ، ورٹیکس): سیل.ورٹیکس [ورٹیکس] = {} ڈیف ایڈ_ج (سیلف ، ورٹیکس 1 ، ورٹیکس 2 ، وزن): سیل.ورٹیکس [ورٹیکس 1]۔{vertex: self.vertices میں vertex کے لئے کوئی نہیں} ملاحظہ کریں = سیٹ () ہیپ = [(0 ، start_vertex)] جبکہ ہیپ: کرنٹ_ڈیسٹینس ، کرنٹ_ورٹیکس = ہیپ کیو.اپپپ (ہیپ) اگر موجودہ_ڈسٹنس> دوری [موجودہ_ورٹیکس]: جاری رکھیں۔(کرنٹ_ورٹیکس) پڑوسی کے لئے ، خود میں وزن۔(فاصلہ ، پڑوسی)) پچھلے_ورٹیس ، فاصلوں کو واپس کریں ، مختصر ترین_پاتھ (سیلف ، اسٹارٹ_ٹورٹیکس ، اینڈ_ورٹیکس): پچھلے_ورٹیسس ، ڈسٹنس = سیلف۔ ڈجکسٹرا (اسٹارٹ_ورٹیکس) راستہ = [] کرنٹ_ورٹیکس = اینڈورٹیکس جبکہ کرنٹ_ورٹیکس! = اسٹارٹ_ورٹیکس!) کرنٹ_ورٹیکس = پچھلی_ورٹیکس [کرنٹ_ورٹیکس] راستہ۔ INSERT (0 ، اسٹارٹ_ورٹیکس) واپسی کا راستہ ، فاصلوں [end_vertex] اس نفاذ میں ، گراف کلاس گراف کی نمائندگی کرتا ہے اور اس میں عمودی اور ان کے کناروں کو ذخیرہ کرنے کے لئے ایک لغت کی شکل ہے۔گراف کلاس گراف میں عمودی اور کناروں کو شامل کرنے کے طریقے مہیا کرتا ہے۔ڈجکسٹرا () طریقہ دو عمودیوں کے مابین مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرتا ہے۔یہ طریقہ ان پٹ کے طور پر ایک اسٹارٹ ورٹیکس لیتا ہے اور دو لغات واپس کرتا ہے: پچھلے_ورٹیسس اور فاصلے۔پچھلی_ورٹیسس پچھلے عمودی حصے کو اسٹور کرتا ہے جو ہر ایک عمودی کو مختصر ترین راستے میں جاتا ہے ، اور فاصلوں کو اسٹارٹ ورٹیکس سے تمام عمودی فاصلوں کے عارضی فاصلوں کو اسٹور کرتا ہے۔مختصر ترین_پاتھ () کا طریقہ ان پٹ کے طور پر ایک اسٹارٹ ورٹیکس اور ایک اختتام ورٹیکس لیتا ہے اور ایک ٹپل (راستہ ، فاصلہ) لوٹاتا ہے جہاں شروع اور اختتامی عمودی اور فاصلہ کے درمیان راستہ سب سے کم راستہ ہوتا ہے۔گراف کلاس کا: پائیٹونگ = گراف () g.add_vertex ('a') g.add_vertex ('b') g.add_vertex ('c') g.add_vertex ('d') g.add_vertex ('e')g.add_edge ('a' ، 'b' ، 4) g.add_edge ('a' ، 'c' ، 2) g.add_edge ('b' ، 'c' ، 1) g.add_edge ('b' ، ''d' ، 5) g.add_edge ('c' ، 'd' ، 8) g.add_edge ('c' ، 'e' ، 10) g.add_edge ('d' ، 'e' ، 2) راستہ ،فاصلہ = g.shortest_path ('a' ، 'e') پرنٹ (راستہ) # پرنٹس ['a' ، 'b' ، 'c' ، 'd' ، 'e'] پرنٹ (فاصلہ) # پرنٹس 11 ان مثال، ہم ایک گراف آبجیکٹ جی بناتے ہیں اور گراف میں پانچ عمودی اور سات کناروں کو شامل کرتے ہیں۔اس کے بعد ہم مختصر ترین_پاتھ () کے طریقہ کار کا استعمال کرتے ہوئے عمودی 'A' اور 'E' کے درمیان مختصر ترین راستہ تلاش کرتے ہیں اور نتیجہ پرنٹ کرتے ہیں۔طریقہ راستہ ['a' ، 'B' ، 'C' ، 'D' ، 'E'] اور فاصلہ 11 ، اس بات کا اشارہ کرتا ہے کہ 'A' اور 'E' کے درمیان مختصر ترین راستہ 11.1stackabuse2udacity3builtin4pieriantraining5gitconnected کا فاصلہ ہے"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے انٹیجرز کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "متحرک پروگرامنگ کا استعمال کرتے ہوئے عددیوں کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے ل we ، ہم فہرست کے ہر انڈیکس میں ختم ہونے والے طویل ترین بڑھتے ہوئے حصول کی ایک سرنی ڈی پی کو برقرار رکھنے کے نقطہ نظر کو استعمال کرسکتے ہیں۔ہم 1 پر مقرر کردہ تمام اقدار کے ساتھ صف کو شروع کرسکتے ہیں ، کیونکہ ہر انڈیکس میں ختم ہونے والا سب سے طویل عرصہ تک بڑھتا ہوا کم از کم 1 (عنصر خود) ہوتا ہے۔اس کے بعد ہم فہرست پر تکرار کرسکتے ہیں اور ہر عنصر کے ل we ، ہم پچھلے تمام عناصر پر تکرار کرسکتے ہیں اور بڑھتی ہوئی متضاد کی زیادہ سے زیادہ لمبائی کے ساتھ ڈی پی سرنی کو اپ ڈیٹ کرسکتے ہیں جو موجودہ عنصر کو پچھلے عنصر پر ختم ہونے والے حصے میں شامل کرکے تشکیل دے سکتے ہیں۔ایک بار جب ہم نے ڈی پی سرنی کی گنتی کرلی ہے تو ، ہم سب سے زیادہ بڑھتے ہوئے حصول کی لمبائی حاصل کرنے کے لئے صف میں زیادہ سے زیادہ قیمت تلاش کرسکتے ہیں۔اس کے بعد ہم خود کو خود کی تشکیل نو کے لئے ڈی پی سرنی کا استعمال کرسکتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف طویل ترین_ان کریزنگ_سوبسینس (نمبر): این = لین (نمبر) ڈی پی = [1] * ن کی حد میں (1 ، این): J میں حد (i) کے لئے: اگر نمبر [i]> نمبر [j]: dp [i] = زیادہ سے زیادہ (dp [i] ، dp [j] + 1) میکس_ لمبائی = زیادہ سے زیادہ (dp) مشترکہ = [] کے لئےi in Range (n -1 ، -1 ، -1): اگر dp [i] == max_length: compence.append (nums [i]) میکس_ لمبائی -= 1 متضاد۔() ان پٹ کے طور پر عددی نمبروں کی ایک فہرست لیتا ہے اور فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو لوٹاتا ہے۔فنکشن سب سے پہلے لمبائی کے ایک سرنی ڈی پی کو 1 پر مقرر کردہ تمام اقدار کے ساتھ شروع کرتا ہے ، جہاں N فہرست کی لمبائی ہے۔اس کے بعد اس فہرست میں اور ہر عنصر کے ل it ، یہ پچھلے تمام عناصر پر تکرار کرتا ہے اور ڈی پی سرنی کو زیادہ سے زیادہ لمبائی کے ساتھ اپ ڈیٹ کرتا ہے جو موجودہ عنصر کو پچھلے عنصر پر ختم ہونے والے حصے میں شامل کرکے تشکیل دیا جاسکتا ہے۔ایک بار جب اس نے ڈی پی سرنی کا حساب لگایا تو ، فنکشن کو صف میں زیادہ سے زیادہ قیمت مل جاتی ہے تاکہ طویل عرصے تک بڑھتی ہوئی تعداد کی لمبائی حاصل کی جاسکے۔اس کے بعد یہ ڈی پی سرنی کا استعمال کرتے ہوئے خود کو دائیں سے بائیں سرے پر تکرار کرکے اور عناصر کو الٹ ترتیب میں شامل کرنے میں شامل کرکے خود کو دوبارہ تشکیل دینے کے لئے استعمال کرتا ہے۔فنکشن اس کے بعد لوٹاتا ہے۔ یہاں سب سے طویل_increasing_subsence () فنکشن کا ایک مثال استعمال: پائیتھونومس = [3 ، 4 ، -1 ، 0 ، 6 ، 2 ، 3] پرنٹ (طویل ترین_انکریزنگ_ سبسینس (نمبر)) # پرنٹس [-1 ، 0 ،2 ، 3] اس مثال میں ، ہمیں فہرست میں سب سے طویل عرصہ تک بڑھتا ہوا حصہ ملتا ہے [3 ، 4 ، -1 ، 0 ، 6 ، 2 ، 2 ، 3] طویل ترین_Increasing_subsence () فنکشن کا استعمال کرتے ہوئے۔فنکشن [-1 ، 0 ، 2 ، 3] لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ فہرست میں سب سے طویل عرصہ تک بڑھتی ہوئی تعداد [-1 ، 0 ، 2 ، 3] .1duke2baeldung3techidelight4youtube5cp-algorithms ہے۔"
    },
    {
        "Question": "منفرد بی ایس ٹی (بائنری سرچ درختوں) کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں جو نوڈس کی ایک بڑی تعداد کے ساتھ تشکیل دی جاسکتی ہے۔",
        "Answer": ""
    },
    {
        "Question": "اسٹیک پر مبنی نقطہ نظر کا استعمال کرتے ہوئے بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "اسٹیک پر مبنی نقطہ نظر کا استعمال کرتے ہوئے بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے ل we ، ہم مندرجہ ذیل اقدامات کا استعمال کرسکتے ہیں: لمبائی N کی فہرست کی اونچائیوں کو 0 پر مقرر کردہ تمام اقدار کے ساتھ بنائیں ، جہاں ن میٹرکس میں کالموں کی تعداد ہے۔میٹرکس کی ہر قطار پر اور ہر کالم کے لئے ، اونچائیوں کی فہرست میں اسی قدر کو 1s کے سب سے بڑے مستطیل کی اونچائی کے لئے اپ ڈیٹ کریں جو موجودہ قطار کے ساتھ بنیاد کے طور پر تشکیل دے سکتے ہیں۔ہم ہر کالم کے لئے 1s کے سب سے بڑے مستطیل کی اونچائی کی گنتی کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں۔ہر کالم کے لئے مستطیل کی اونچائی موجودہ قطار سے شروع ہونے والے کالم میں لگاتار 1s کی تعداد کے برابر ہے۔ ہر صف کے لئے ، 1s کے سب سے بڑے آئتاکار علاقے کی گنتی کریں جو قطار کے ساتھ اوپر کی قطار کے طور پر تشکیل دی جاسکتی ہے۔ہائٹس لسٹ کا استعمال کرتے ہوئے۔ہم موجودہ صف میں کالموں کے اشاریوں کو ٹریک رکھنے کے لئے ایک اسٹیک کا استعمال کرسکتے ہیں جس پر ابھی عمل نہیں ہوا ہے۔ہم پہلے کالم کے انڈیکس کو اسٹیک پر دھکیل سکتے ہیں اور باقی کالموں پر تکرار کرسکتے ہیں۔ہر کالم کے ل we ، ہم اسٹیک سے ٹاپ انڈیکس کو پاپ کرتے ہیں اور سب سے بڑے مستطیل کے علاقے کی گنتی کرتے ہیں جو پاپڈ انڈیکس میں کالم کا استعمال کرتے ہوئے دائیں حد اور موجودہ کالم کو بائیں حد کے طور پر تشکیل دے سکتے ہیں۔مستطیل کی اونچائی پاپڈ انڈیکس میں اونچائی کی فہرست میں قدر کے برابر ہے ، اور چوڑائی اسٹیک کے اوپری حصے میں موجودہ انڈیکس اور انڈیکس کے درمیان فاصلے کے برابر ہے ، یا موجودہ انڈیکس اگر اسٹیک خالی ہے۔ہم اب تک دیکھنے والے زیادہ سے زیادہ علاقے کو اپ ڈیٹ کرتے ہیں اور باقی کالموں پر تکرار کرتے رہتے ہیں۔اگر اسٹیک خالی ہے تو ، ہم موجودہ انڈیکس کو اسٹیک پر دھکیلتے ہیں اور باقی کالموں پر تکرار کرتے رہتے ہیں۔ اب تک دیکھا جانے والا زیادہ سے زیادہ علاقہ۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف میکس_ریکٹنگل_اریہ (میٹرکس): اگر میٹرکس نہیں ہے: واپسی0 n = لین (میٹرکس [0]) اونچائی = [0] * n میکس_یریا = 0 میٹرکس میں قطار کے لئے: رینج میں I کے لئے (n): اونچائی [i] = اونچائی [i] + 1 اگر قطار [i] == 1 اور 0 اسٹیک = [] i = 0 جبکہ i <n: اگر اسٹیک یا اونچائی نہیں ہے [i]> = اونچائی [اسٹیک [-1]]: اسٹیک.ایپینڈ (i) i += 1 اور: ٹاپ = اسٹیک.POP () ایریا = اونچائی [اوپر] * (i - اسٹیک [-1] - 1 اگر اسٹیک ورنہ I) میکس_یریا = زیادہ سے زیادہ (میکس_یریا ، علاقہ) جبکہ اسٹیک: ٹاپ = اسٹیک.پپ () ایریا = اونچائی [اوپر]* (i - اسٹیک [-1] - 1 اگر اسٹیک ورنہ I) میکس_یریا = زیادہ سے زیادہ (میکس_یریا ، ایریا) میکس_یرین لوٹ کر اس نفاذ ، فنکشن میکس_ریکٹنگل_اریہ () بائنری میٹرکس کو ان پٹ کے طور پر لیتا ہے اور 1 میں 1s کا سب سے بڑا آئتاکار رقبہ واپس کرتا ہےمیٹرکس.فنکشن سب سے پہلے چیک کرتا ہے کہ آیا میٹرکس خالی ہے اور 0 لوٹتا ہے اگر یہ ہے۔اس کے بعد یہ لمبائی N کی فہرست کی اونچائیوں کو 0 پر سیٹ کردہ تمام اقدار کے ساتھ شروع کرتا ہے ، جہاں ن میٹرکس میں کالموں کی تعداد ہے۔یہ میٹرکس کی ہر قطار پر تکرار کرتا ہے اور ہر کالم کے ل it ، یہ اونچائیوں کی فہرست میں اسی قدر کو 1s کے سب سے بڑے مستطیل کی اونچائی کے لئے اپ ڈیٹ کرتا ہے جو موجودہ قطار کے ساتھ متحرک پروگرامنگ کا استعمال کرتے ہوئے بیس کے طور پر تشکیل دیا جاسکتا ہے۔اس کے بعد میٹرکس کی ہر قطار پر دوبارہ تکرار ہوجاتا ہے اور ہر قطار کے ل it ، یہ 1s کے سب سے بڑے آئتاکار علاقے کی گنتی کرتا ہے جو اسٹیک پر مبنی نقطہ نظر کا استعمال کرتے ہوئے اوپری قطار کے طور پر قطار کے ساتھ تشکیل دیا جاسکتا ہے۔یہ ایک خالی اسٹیک اور متغیر میکس_یریا کو 0 پر شروع کرتا ہے۔ پھر یہ قطار کے کالموں پر تکرار کرتا ہے اور ہر کالم کے ل it ، یہ اسٹیک سے اوپر کی اشاریہ کو پاپ کرتا ہے اور سب سے بڑے مستطیل کے علاقے کی گنتی کرتا ہے جو کالم کے استعمال سے تشکیل پایا جاسکتا ہے۔پاپڈ انڈیکس کو دائیں حد اور موجودہ کالم کے طور پر بائیں باؤنڈری کے طور پر۔اگر اسٹیک خالی ہے تو ، یہ موجودہ انڈیکس کو اسٹیک پر دھکیل دیتا ہے اور باقی کالموں پر تکرار جاری رکھے ہوئے ہے۔فنکشن MAX_AREA متغیر کو اب تک کے حساب سے زیادہ سے زیادہ علاقے کے ساتھ اپ ڈیٹ کرتا ہے۔ایک بار جب اس نے قطار میں موجود تمام کالموں پر کارروائی کرلی ، تو یہ اسٹیک سے باقی اشاریوں کو پاپ کرتا ہے اور سب سے بڑے مستطیل کے علاقے کی گنتی کرتا ہے جو ہر انڈیکس کو صحیح حد کے طور پر استعمال کرتے ہوئے تشکیل دیا جاسکتا ہے۔فنکشن زیادہ سے زیادہ علاقے کی گنتی کرتا ہے۔ یہاں میکس_ریکٹنگل_اریہ () فنکشن کا ایک مثال استعمال ہے: پائیتھون میٹرکس = [[1 ، 0 ، 1 ، 1 ، 0] ، [1 ، 0 ، 1 ، 1 ، 1] ، [1 ، 1 ، 1، 1 ، 1 ، 1] ، [1 ، 0 ، 0 ، 1 ، 1 ، 0]] پرنٹ (میکس_ریکٹنگل_یریا (میٹرکس)) # پرنٹس 6 ان مثال کے طور پر ، ہمیں بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ MAX_RECTANGALLE_AREA () کا استعمال کرتے ہوئے ملتا ہے۔تقریبفنکشن 6 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ 6.1 پریپ بائٹس 2 ٹی ای سی ای ڈی لائٹ 3 کوڈنگنگنجاس 4 لیئٹ کوڈ 5 جی ای ای ایکسفورجیکس ہے"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کی پیش کش کی جاسکتی ہے۔\"",
        "Answer": "کسی فنکشن کو عملی جامہ پہنانے کے لئے یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے نیسڈ اظہار اور آپریٹرز کی پیش کش کے ساتھ ، ہم اسٹیک پر مبنی نقطہ نظر کا استعمال کرسکتے ہیں۔جب ہم اسی طرح کے اختتامی علامتوں کا سامنا کرتے ہیں تو ہم تار میں درپیش افتتاحی علامتوں کو ٹریک رکھنے کے لئے ایک اسٹیک کا استعمال کرسکتے ہیں۔ہم افتتاحی علامتوں کو ان کے متعلقہ علامتوں کا نقشہ بنانے کے لئے ایک لغت بھی استعمال کرسکتے ہیں۔ہم تار پر تکرار کرسکتے ہیں اور ہر کردار کے ل we ، ہم چیک کرسکتے ہیں کہ آیا یہ افتتاحی علامت ہے یا نہیں۔اگر یہ ہے تو ، ہم اسے اسٹیک پر دھکیلتے ہیں۔اگر یہ اختتامی علامت ہے تو ، ہم چیک کرتے ہیں کہ آیا اسٹیک خالی ہے یا اگر اسٹیک کے اوپری حصے میں اسی طرح کی افتتاحی علامت ہوتی ہے۔اگر ایسا ہوتا ہے تو ، ہم ابتدائی علامت کو اسٹیک سے پاپ کرتے ہیں اور تار پر تکرار کرتے رہتے ہیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم غلط لوٹتے ہیں ، اس بات کی نشاندہی کرتے ہیں کہ اظہار متوازن نہیں ہے۔ایک بار جب ہم نے تار میں تمام کرداروں پر کارروائی کرلی تو ہم چیک کرتے ہیں کہ اسٹیک خالی ہے یا نہیں۔اگر یہ ہے تو ، ہم صحیح لوٹتے ہیں ، اس بات کی نشاندہی کرتے ہیں کہ اظہار متوازن ہے۔بصورت دیگر ، ہم جھوٹے کو واپس کرتے ہیں۔ اس نقطہ نظر کا عمل پیرا میں اس نقطہ نظر کا نفاذ: پائیتھونڈف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_سیمبولز = {'(': ')' ، ':'] '،' {':' {':' {':' {':' {':' {''،' <':'> '،' '' '\"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" ،'/':'/'} closing_symbols = سیٹ (اوپننگ_سیمبولس۔ ویلیوز ()) اظہار کے لئے: اگر: اگراوپننگ_سیمبولس میں چار: اسٹیک.اپی اینڈ (چار) الیف چار کلوزنگ_سیمبولز میں: اگر اسٹیک نہیں ہے تو: غلط افتتاحی_سیمبول = اسٹیک.پوپ () اگر اوپننگ_سمبولز [اوپننگ_سیمبول]!ان پٹ کے طور پر ایک تار کا اظہار لیتا ہے اور اگر متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ اظہار ایک درست اظہار ہے تو ، گھوںسلا اظہار اور آپریٹرز کو پیش نظارہ کے ساتھ ، اور غلط اور دوسری صورت میں غلط ہے۔فنکشن سب سے پہلے ایک خالی اسٹیک اور ایک لغت اوپننگ_سیمبولز کی ابتدا کرتا ہے جو ابتدائی علامتوں کو ان کے متعلقہ علامتوں پر نقشہ بناتا ہے۔یہ تمام اختتامی علامتوں کے ساتھ ایک سیٹ بند کرنے_ سائبولس کو بھی شروع کرتا ہے۔اس کے بعد یہ تار میں حروف پر تکرار کرتا ہے اور ہر کردار کے ل it ، یہ چیک کرتا ہے کہ آیا یہ افتتاحی علامت ہے۔اگر یہ ہے تو ، یہ اسے اسٹیک پر دھکیل دیتا ہے۔اگر یہ بند ہونے والی علامت ہے تو ، یہ چیک کرتا ہے کہ آیا اسٹیک خالی ہے یا اگر اسٹیک کے اوپری حصے میں اسی طرح کی افتتاحی علامت موجود ہے۔اگر ایسا ہوتا ہے تو ، یہ اسٹیک سے ابتدائی علامت کو پاپ کرتا ہے اور تار کے اوپر تکرار کرتا رہتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، یہ غلط لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اظہار متوازن نہیں ہے۔ایک بار جب اس نے تار میں تمام کرداروں پر کارروائی کرلی تو ، فنکشن چیک کرتا ہے کہ اگر اسٹیک خالی ہے۔اگر یہ ہے تو ، یہ درست لوٹتا ہے ، اس بات کی نشاندہی کرتا ہے کہ اظہار متوازن ہے۔بصورت دیگر ، یہ غلط واپس آجاتا ہے۔ IS_Valid_expression () فنکشن کا ایک مثال استعمال: پائیتھون ایکسپریشن = '[(a + b) * c - d] / e'print (is_valid_expression (اظہار)) # پرنٹس اس مثال کے طور پر ، ہم چیک کرتے ہیں ، اگر ہم چیک کرتے ہیں تو ، ہم چیک کرتے ہیں ، اگر ہم چیک کرتے ہیں تو ، ہم جانچ پڑتال کرتے ہیں۔اظہار [(a + b) * c - d] / e متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کو مثال کے طور پر ، IS_Valid_expression () کا استعمال کرتے ہوئے اجازت دی جاتی ہے۔تقریبفنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اظہار درست اور متوازن ہے۔"
    },
    {
        "Question": "موثر اضافے اور ممبرشپ چیک کے لئے تعاون کے ساتھ بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں۔",
        "Answer": "موثر اضافے اور ممبرشپ چیک کی حمایت کے ساتھ بلوم فلٹر کی نمائندگی کرنے والے ایک ازگر کلاس بنانے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: بلوم فلٹر کو لمبائی M اور K ہیش فنکشن کی تھوڑی سی صف کے ساتھ شروع کریں۔بلوم فلٹر میں عنصر۔اس طریقہ کار کو عنصر کے لئے کے ہیش اقدار کی گنتی کرنی چاہئے اور اس سے متعلق بٹس کو بٹ سرنی میں 1. پر مشتمل ہے۔اس طریقہ کار کو عنصر کے لئے کے ہیش اقدار کی گنتی کرنی چاہئے اور یہ چیک کرنا چاہئے کہ آیا بٹ سرنی میں متعلقہ بٹس سب پر سیٹ ہیں۔فلٹراگر بٹس میں سے کسی کو 1 پر سیٹ نہیں کیا گیا ہے تو ، طریقہ غلط لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ عنصر یقینی طور پر بلوم فلٹر میں نہیں ہے۔ ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونیمپورٹ ایم ایم ایچ 3 کلاس بلوم فلٹر: ڈیف __init __ (خود ، ایم ، کے): self.m = m سیلف۔.m self.bit_array [ہیش_والیو] = سچے ڈیف پر مشتمل ہوتا ہے (خود ، عنصر): میں رینج میں (خود) کے لئے: ہیش_ویلیو = ایم ایم ایچ 3. ہش (عنصر ، i) ٪ سیلف۔ اگر خود نہیں ہے۔: غلط ریٹرن کو واپس کریں اس پر عمل درآمد ، بلوم فلٹر کلاس بلوم فلٹر کی نمائندگی کرتا ہے اور اس میں تین طریقے ہیں: __init __ () ، شامل کریں () ، اور () پر مشتمل ہے۔__init __ () کا طریقہ بلوم فلٹر کو لمبائی M اور K ہیش افعال کی تھوڑی سی صف کے ساتھ شروع کرتا ہے۔ADD () طریقہ ایک عنصر کو ان پٹ کے طور پر لیتا ہے اور Mummurhash3 ہیش فنکشن کا استعمال کرتے ہوئے عنصر کے لئے K ہیش اقدار کی گنتی کرتا ہے۔اس کے بعد اس سے متعلق بٹس کو بٹ سرنی میں سچ پر سیٹ کیا جاتا ہے۔پرہین () طریقہ ایک عنصر کو ان پٹ کے طور پر لیتا ہے اور mummurhash3 ہیش فنکشن کا استعمال کرتے ہوئے عنصر کے لئے K ہیش اقدار کی گنتی کرتا ہے۔اس کے بعد یہ جانچ پڑتال کرتا ہے کہ آیا بٹ سرنی میں متعلقہ بٹس بالکل درست ہیں۔اگر تمام بٹس درست ہیں تو ، طریقہ کار درست ہوجاتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ عنصر شاید بلوم فلٹر میں ہے۔اگر بٹس میں سے کوئی بھی درست نہیں ہے تو ، طریقہ غلط واپس آجاتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ عنصر یقینی طور پر بلوم فلٹر میں نہیں ہے۔ بلوم فلٹر کلاس کا ایک مثال استعمال ہے: پائیتھنبف = بلوم فلٹر (100 ، 3) بی ایف۔ اے ڈی ڈی ('ایپل ') bf.add (' کیلے ') bf.add (' چیری ') پرنٹ (bf.contains (' ایپل ')) # پرنٹس ٹرو پرنٹ (bf.contains (' کیلے ')) # پرنٹس ٹروپنٹ (bf.contains.اس کے بعد ہم ADD () طریقہ کار کا استعمال کرتے ہوئے بلوم فلٹر میں تین عناصر 'ایپل' ، 'کیلے' ، اور 'چیری' شامل کرتے ہیں۔آخر میں ، ہم چیک کرتے ہیں کہ آیا عناصر 'ایپل' ، 'کیلے' ، 'چیری' ، اور 'اورنج' پر مشتمل () () طریقہ استعمال کرتے ہوئے بلوم فلٹر میں ہیں۔یہ طریقہ 'ایپل' ، 'کیلے' ، اور 'چیری' کے لئے سچ ہے ، جس سے یہ ظاہر ہوتا ہے کہ یہ عناصر شاید بلوم فلٹر میں ہیں ، اور 'سنتری' کے لئے غلط ہیں ، جس سے یہ ظاہر ہوتا ہے کہ یہ عنصر یقینی طور پر بلوم فلٹر میں نہیں ہے۔"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے دیئے گئے اسٹرنگ میں الگ الگ حصوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "متحرک پروگرامنگ کا استعمال کرتے ہوئے دیئے گئے اسٹرنگ میں الگ الگ حصوں کی تعداد تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: لمبائی N+1 کی فہرست DP کو شروع کریں جس میں تمام اقدار 0 پر سیٹ کی جائیں ، جہاں N تار کی لمبائی ہے۔1 ، چونکہ ایک خالی تار کا صرف ایک ہی حصہ ہے۔ تار کے اوپر اور ہر کردار کے لئے ، تار میں پچھلے حروف کے اوپر تکرار کریں۔اگر موجودہ کردار پچھلے کردار کے برابر ہے تو ، موجودہ کردار کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد ان الگ الگ اجتماعی تعداد کے برابر ہے جو پچھلے کردار کے ساتھ ختم ہوتی ہے۔اگر موجودہ کردار پچھلے کردار کے برابر نہیں ہے تو ، موجودہ کردار کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد ان الگ الگ حصوں کی تعداد کے برابر ہے جو پچھلے کردار کے ساتھ ختم ہوتی ہے اور اس کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد کے ساتھ ختم ہوتی ہے۔پچھلے کردار لیکن موجودہ کردار کو شامل نہیں کرتے ہیں۔ہم ڈی پی سرنی کا استعمال ان الگ الگ حصوں کی تعداد پر نظر رکھنے کے لئے کرسکتے ہیں جو ہر کردار کے ساتھ ختم ہوجاتے ہیں۔ ڈی پی [این] کی قدر کو دوبارہ بنائیں ، جو تار میں الگ الگ حصوں کی تعداد ہے۔ ازگر میں اس نقطہ نظر کا نفاذ:پائیتھنڈف COUNT_DISTINCT_SUBCENSENS (s): n = len (s) dp = [0] * (n + 1) dp [0] = 1 آخری_سین = {} i in range (1 ، n + 1): dp [i] =2 * dp [i - 1] اگر s [i - 1] آخری_سین میں: dp [i] - = dp [last_seen [s [i - 1]] - 1] آخری_سین [s [i - 1]] = میں واپسڈی پی [این] - 1 اس پر عمل درآمد میں ، فنکشن کاؤنٹی_ڈسٹنٹ_سبسنس () ان پٹ کے طور پر ایک تار لیتا ہے اور تار میں الگ الگ حصوں کی تعداد کو واپس کرتا ہے۔فنکشن سب سے پہلے لمبائی N+1 کی فہرست DP کو شروع کرتا ہے جس میں تمام اقدار 0 پر سیٹ کی جاتی ہیں ، جہاں N تار کی لمبائی ہے۔یہ ڈی پی کو 1 پر سیٹ کرتا ہے ، کیونکہ خالی تار کا صرف ایک ہی حصہ ہے۔اس کے بعد یہ تار پر تکرار کرتا ہے اور ہر کردار کے ل it ، یہ تار میں پچھلے حروف پر تکرار کرتا ہے۔اگر موجودہ کردار پچھلے کردار کے برابر ہے تو ، موجودہ کردار کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد ان الگ الگ اجتماعی تعداد کے برابر ہے جو پچھلے کردار کے ساتھ ختم ہوتی ہے۔اگر موجودہ کردار پچھلے کردار کے برابر نہیں ہے تو ، موجودہ کردار کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد ان الگ الگ حصوں کی تعداد کے برابر ہے جو پچھلے کردار کے ساتھ ختم ہوتی ہے اور اس کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد کے ساتھ ختم ہوتی ہے۔پچھلے کردار لیکن موجودہ کردار کو شامل نہیں کرتے ہیں۔فنکشن ڈی پی سرنی کا استعمال ہر کردار کے ساتھ ختم ہونے والے الگ الگ حصوں کی تعداد پر نظر رکھنے کے لئے کرتا ہے۔آخر میں ، فنکشن ڈی پی [این] مائنس 1 کی قدر لوٹاتا ہے ، جو سٹرنگ میں الگ الگ حصوں کی تعداد ہے۔ گنتی_ڈسٹنٹ_سوبسنس () فنکشن کا ایک مثال استعمال: ازگر = 'اباب' پرنٹ (گنتی_ڈسٹنٹ_سوبسنس (زبانیں)) #اس مثال کے طور پر 7 ان پرنٹس ، ہمیں COUNT_DISTINCT_SUBSECSENES () فنکشن کا استعمال کرتے ہوئے اسٹرنگ 'اباب' میں الگ الگ حصوں کی تعداد ملتی ہے۔فنکشن 7 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سٹرنگ میں 7 الگ الگ متضاد ہیں۔"
    },
    {
        "Question": "کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے نمبر کو ایرٹوسٹینس الگورتھم کی چھلنی کا استعمال کرتے ہوئے ایک اہم نمبر ہے۔",
        "Answer": "کسی فنکشن کو عملی جامہ پہنانے کے ل re یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے نمبر ایک اہم نمبر ہے جس کا استعمال ایرٹوسٹینس الگورتھم کی چھلنی ہے ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک فہرست بنائیں جس کی لمبائی N+1 کی تمام حقیقی اقدار سے بھری ہوئی ہے ، جہاں N دی گئی تعداد ہے۔فہرست کے پہلے دو عناصر کو غلط پر سیٹ کریں ، کیونکہ 0 اور 1 بنیادی تعداد نہیں ہیں۔ 2 سے لے کر 2 سے N کے مربع جڑ تک کی تعداد کا تعین کریں۔ہر تعداد کے ل if ، اگر یہ ایک اہم نمبر ہے (یعنی ، is_prime [i] سچ ہے) تو ، اس کے تمام ضربوں کو غیر پرائم نمبر کے طور پر نشان زد کریں۔نمبر چیک کرکے نمبر پر آئی ایس_ پرائم لسٹ میں متعلقہ عنصر درست ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونیمپورٹ میتھ ڈیف آئی ایس_پرائم (این): is_prime = [true] * (n + 1) is_prime [0] = غلط is_prime [1] = رینج (2 ، int (math.sqrt (n)) + 1) میں i کے لئے غلطغلط واپسی IS_PRIME [n] اس نفاذ میں ، فنکشن IS_PRIME () ایک نمبر N کو ان پٹ کے طور پر لیتا ہے اور اگر نمبر ایک اہم نمبر ہے اور غلط ہے تو وہ درست ہے۔فنکشن سب سے پہلے ایک فہرست کی شروعات کرتا ہے جس کی لمبائی N+1 کی تمام حقیقی اقدار سے بھری ہوئی ہے۔اس کے بعد یہ فہرست کے پہلے دو عناصر کو غلط پر سیٹ کرتا ہے ، کیونکہ 0 اور 1 بنیادی تعداد نہیں ہیں۔اس کے بعد 2 سے N کے مربع جڑ تک نمبروں پر تکرار کرتا ہے۔ہر ایک نمبر کے ل if ، اگر یہ ایک اہم نمبر ہے (یعنی ، is_prime [i] سچ ہے) ، تو یہ اپنے تمام ضربوں کو غیر پرائم نمبر کے طور پر نشان زد کرتا ہے جس سے متعلقہ عناصر کو IS_PRIME فہرست میں غلط میں ترتیب دیا جاتا ہے۔آخر میں ، فنکشن چیک کرتا ہے کہ اگر دیئے گئے نمبر کی جانچ پڑتال کرکے دی گئی تعداد ایک اہم نمبر ہے یا نہیں کہ آیا IS_PRIME فہرست میں متعلقہ عنصر درست ہے۔ IS_PRIME () فنکشن کا ایک مثال استعمال: Pythonn = 17 پرنٹ (is_prime (n)) # پرنٹس اس بات کو درست کریں۔مثال کے طور پر ، ہم چیک کرتے ہیں کہ آیا نمبر 17 IS_PRIME () فنکشن کا استعمال کرتے ہوئے ایک اہم نمبر ہے۔فنکشن درست لوٹتا ہے ، اس بات کی نشاندہی کرتا ہے کہ 17 ایک اہم نمبر ہے۔"
    },
    {
        "Question": "\"عددیوں کی دی گئی فہرست کے اختتام تک کم سے کم چھلانگ کی تلاش کے ل a ایک پروگرام لکھیں ، جہاں ہر عدد زیادہ سے زیادہ تعداد میں مراحل کی نمائندگی کرتا ہے جو اس پوزیشن سے چھلانگ لگائے جاسکتے ہیں۔\"",
        "Answer": "عددیوں کی دی گئی فہرست کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگ کی تلاش کے ل ، ، جہاں ہر عدد اس پوزیشن سے کود پائے جانے والے اقدامات کی زیادہ سے زیادہ تعداد کی نمائندگی کرتا ہے ، ہم متحرک پروگرامنگ کا استعمال کرسکتے ہیں۔یہاں ایک نقطہ نظر ہے: انفینٹی کے لئے مقرر کردہ تمام اقدار کے ساتھ لمبائی N کی ایک فہرست DP شروع کریں ، جہاں N فہرست کی لمبائی ہے۔ DP فہرست کا پہلا عنصر 0 پر سیٹ کریں ، کیونکہ ہمیں پہلے پہنچنے کے لئے کودنے کی ضرورت نہیں ہےعنصر۔ فہرست سے زیادہ اور ہر عنصر کے لئے ، فہرست میں پچھلے عناصر پر تکرار کریں۔ہر پچھلے عنصر کے ل check ، چیک کریں کہ آیا یہ موجودہ عنصر سے قابل رسائ ہے یا نہیں۔اگر یہ ہے تو ، پچھلے عنصر کے لئے ڈی پی لسٹ میں قیمت کو اپ ڈیٹ کریں اس کی موجودہ قیمت کی کم سے کم اور ڈی پی لسٹ میں موجودہ عنصر کی قیمت کے علاوہ 1. آخری عنصر کے لئے ڈی پی لسٹ میں قیمت کا ازالہ کریں ، جوفہرست کے اختتام تک پہنچنے کے لئے درکار چھلانگوں کی کم سے کم تعداد کی نمائندگی کرتا ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پیتھونڈف من_جپس (نمبر): این = لین (نمبر) ڈی پی = [فلوٹ ('انف')] * این ڈی پی [0] = 0 کے لئے I (1 ، n): J کے لئے رینج میں (i): اگر j + nums [j]> = i: dp [i] = منٹ (dp [i] ، dp [j] +1) واپسی DP [n - 1] اس نفاذ میں ، فنکشن MIN_JUMPS () ان پٹ کے طور پر انٹیجر نمبروں کی ایک فہرست لیتا ہے اور فہرست کے اختتام تک پہنچنے کے لئے درکار چھلانگ کی کم سے کم تعداد واپس کرتا ہے۔فنکشن سب سے پہلے انفینٹی کے لئے مقرر کردہ تمام اقدار کے ساتھ لمبائی N کی فہرست DP کی ابتدا کرتا ہے ، جہاں N فہرست کی لمبائی ہے۔اس کے بعد یہ ڈی پی لسٹ کا پہلا عنصر 0 پر طے کرتا ہے ، کیونکہ ہمیں پہلے عنصر تک پہنچنے کے لئے کودنے کی ضرورت نہیں ہے۔اس کے بعد یہ فہرست میں تکرار کرتا ہے اور ہر عنصر کے ل it ، یہ فہرست میں پچھلے عناصر پر تکرار کرتا ہے۔ہر پچھلے عنصر کے ل it ، یہ چیک کرتا ہے کہ آیا یہ موجودہ عنصر سے قابل رسائ ہے۔اگر یہ ہے تو ، یہ پچھلے عنصر کے لئے ڈی پی لسٹ میں قیمت کو اپ ڈیٹ کرتا ہے جو اس کی موجودہ قیمت کی کم سے کم ہے اور ڈی پی لسٹ پلس میں موجودہ عنصر کی قیمت 1. آخر میں ، فنکشن ڈی پی لسٹ میں قیمت لوٹاتا ہے۔آخری عنصر ، جو فہرست کے اختتام تک پہنچنے کے لئے درکار چھلانگ کی کم سے کم تعداد کی نمائندگی کرتا ہے۔ یہاں من_جپس () فنکشن کا ایک مثال استعمال: پائیٹونومز = [1 ، 3 ، 5 ، 8 ، 9 ، 2 ، 6 ، 7 ،6 ، 8 ، 9] پرنٹ (MIN_JUMPS (Nums)) # پرنٹ 3 میں اس مثال کے طور پر ، ہمیں فہرست کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگ کی ضرورت ہوتی ہے [1] [3] [5] [5] [8] [9] [2] [6] [7] [6] [8] [9] من_جپس () فنکشن کا استعمال کرتے ہوئے۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ ہمیں فہرست کے اختتام تک پہنچنے کے لئے 3 چھلانگ لگانے کی ضرورت ہے۔"
    },
    {
        "Question": "ایک لاحقہ درخت کی نمائندگی کرنے والے ایک ازگر کلاس بنائیں جو موثر اسٹرنگ تلاش اور طویل ترین عام سابقہ کے لئے معاونت کے ساتھ۔",
        "Answer": ""
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "کسی فنکشن کو عملی جامہ پہنانے کے لئے یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت دی جاسکتی ہے ، ہم اسٹیک پر مبنی نقطہ نظر استعمال کرسکتے ہیں۔جب ہم اسی طرح کے اختتامی علامتوں کا سامنا کرتے ہیں تو ہم تار میں درپیش افتتاحی علامتوں کو ٹریک رکھنے کے لئے ایک اسٹیک کا استعمال کرسکتے ہیں۔ہم افتتاحی علامتوں کو ان کے متعلقہ علامتوں کا نقشہ بنانے کے لئے ایک لغت بھی استعمال کرسکتے ہیں۔ہم تار پر تکرار کرسکتے ہیں اور ہر کردار کے ل we ، ہم چیک کرسکتے ہیں کہ آیا یہ افتتاحی علامت ہے یا نہیں۔اگر یہ ہے تو ، ہم اسے اسٹیک پر دھکیلتے ہیں۔اگر یہ اختتامی علامت ہے تو ، ہم چیک کرتے ہیں کہ آیا اسٹیک خالی ہے یا اگر اسٹیک کے اوپری حصے میں اسی طرح کی افتتاحی علامت ہوتی ہے۔اگر ایسا ہوتا ہے تو ، ہم ابتدائی علامت کو اسٹیک سے پاپ کرتے ہیں اور تار پر تکرار کرتے رہتے ہیں۔اگر ایسا نہیں ہوتا ہے تو ، ہم غلط لوٹتے ہیں ، اس بات کی نشاندہی کرتے ہیں کہ اظہار متوازن نہیں ہے۔ایک بار جب ہم نے تار میں تمام کرداروں پر کارروائی کرلی تو ہم چیک کرتے ہیں کہ اسٹیک خالی ہے یا نہیں۔اگر یہ ہے تو ، ہم صحیح لوٹتے ہیں ، اس بات کی نشاندہی کرتے ہیں کہ اظہار متوازن ہے۔بصورت دیگر ، ہم جھوٹے کو واپس کرتے ہیں۔ اس نقطہ نظر کا عمل پیرا میں اس نقطہ نظر کا نفاذ: پائیتھونڈف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_سیمبولز = {'(': ')' ، ':'] '،' {':' {':' {':' {':' {':' {''،' <':'> '،' '' '\"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" ،'/':'/'} closing_symbols = سیٹ (اوپننگ_سیمبولس۔ ویلیوز ()) اظہار کے لئے: اگر: اگراوپننگ_سیمبولس میں چار: اسٹیک.اپی اینڈ (چار) الیف چار کلوزنگ_سیمبولز میں: اگر اسٹیک نہیں ہے تو: غلط افتتاحی_سیمبول = اسٹیک.پوپ () اگر اوپننگ_سمبولز [اوپننگ_سیمبول]!ان پٹ کے طور پر ایک تار کا اظہار لیتا ہے اور اگر متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیشس کے ساتھ اظہار ایک درست اظہار ہے تو ، گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت دیتا ہے ، اور دوسری صورت میں غلط ہے۔فنکشن سب سے پہلے تار میں درپیش افتتاحی علامتوں کو ٹریک رکھنے کے لئے ایک اسٹیک کی ابتدا کرتا ہے۔اس کے بعد یہ ابتدائی علامتوں کو ان کے متعلقہ اختتامی علامتوں کا نقشہ بنانے کے لئے ایک لغت اوپننگ_سیمبولز کا آغاز کرتا ہے۔یہ تار میں درپیش اختتامی علامتوں پر نظر رکھنے کے لئے ایک سیٹ بند_سمبولز کو بھی شروع کرتا ہے۔اس کے بعد یہ تار پر تکرار کرتا ہے اور ہر کردار کے ل it ، یہ چیک کرتا ہے کہ آیا یہ افتتاحی علامت ہے۔اگر یہ ہے تو ، یہ اسے اسٹیک پر دھکیل دیتا ہے۔اگر یہ بند ہونے والی علامت ہے تو ، یہ چیک کرتا ہے کہ آیا اسٹیک خالی ہے یا اگر اسٹیک کے اوپری حصے میں اسی طرح کی افتتاحی علامت موجود ہے۔اگر ایسا ہوتا ہے تو ، یہ اسٹیک سے ابتدائی علامت کو پاپ کرتا ہے اور تار کے اوپر تکرار کرتا رہتا ہے۔اگر ایسا نہیں ہوتا ہے تو ، یہ غلط لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اظہار متوازن نہیں ہے۔آخر میں ، تار میں تمام حرفوں پر کارروائی کرنے کے بعد ، اگر اسٹیک خالی ہے ، تو اظہار متوازن ہے۔بصورت دیگر ، یہ نہیں ہے۔ IS_Valid_expression () فنکشن کا ایک مثال استعمال: Pythonexpression = 'if (a == b) {c = d ؛print 'پرنٹ (is_valid_expression (اظہار)) # پرنٹ کرتا ہے۔} 'متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے IS_Valid_expression () فنکشن کا استعمال کرتے ہوئے گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت ملتی ہے۔فنکشن درست لوٹتا ہے ، اس بات کا اشارہ کرتا ہے کہ یہ اظہار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت ملتی ہے۔"
    },
    {
        "Question": "کڈانے کے الگورتھم کا استعمال کرتے ہوئے دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کڈانے کے الگورتھم کا استعمال کرتے ہوئے دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: کڈانے کے الگورتھم کا استعمال کرتے ہوئے زیادہ سے زیادہ رقم سبری کو تلاش کریں۔اس سے ہمیں زیادہ سے زیادہ رقم سب اریے ملے گی جو سرنی کے اختتام کے گرد لپیٹ نہیں پائے گی۔ کڈانے کے الگورتھم کا استعمال کرتے ہوئے کم سے کم مجموعی سبری کو تلاش کریں۔اس سے ہمیں کم سے کم رقم کا سب اریے ملیں گے جو سرنی کے اختتام پر لپیٹ نہیں پائے گا۔ سرنی کی کل رقم کو بہتر بنائیں۔سرنی میں سے زیادہ سے زیادہ زیادہ سے زیادہ رقم کا سب سے زیادہ سے زیادہ جو سرنی کے اختتام پر لپیٹ نہیں کرتا ہے اور زیادہ سے زیادہ رقم سبری جو سرنی کے اختتام کے گرد لپیٹتا ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ: پائیتھنڈف میکس_سم_سیرکولر_سبرے (نمبر): Def Kadane (arr): max_so_far = 0 max_ending_here = 0 in in range (len (arr)): میکس_نینڈنگ_ہیر += آر [i] اگر زیادہ سے زیادہ_نینڈی_ہیر <0: زیادہ سے زیادہ_ہیر = 0 اگر زیادہ سے زیادہ_سو_فار <میکس_فیر = میکس_فیر = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_فار = میکس_= کڈانے (نمبرز) من_سم = کڈانے ([-نمبر کے لئے نمبر])) کل_سم = رقم (نمبرز) میکس_روپ_سم = ٹوٹل_سم + منٹ_سم اگر زیادہ سے زیادہ_روپ_سم == 0: واپسی میکس_سم ریٹرن میکس (زیادہ سے زیادہ_سم ، میکس_روپ_سم) اس عمل میں ، فنکشن میں ، فنکشن ، فنکشن ، فنکشن میں زیادہ سے زیادہمیکس_سم_سرکلر_سوبری () ان پٹ کے طور پر انٹیجر نمبروں کی ایک فہرست لیتا ہے اور سرکلر صف میں زیادہ سے زیادہ رقم سبری کو واپس کرتا ہے۔اس فنکشن میں پہلے ایک مددگار فنکشن کڈنے () کی وضاحت کی گئی ہے جو کسی دیئے گئے صف کے زیادہ سے زیادہ رقم کو تلاش کرنے کے لئے کڈانے کے الگورتھم کو نافذ کرتی ہے۔اس کے بعد یہ زیادہ سے زیادہ رقم کے سبری کو تلاش کرنے کے لئے کڈانے کے الگورتھم کا استعمال کرتا ہے جو صف کے اختتام کے گرد لپیٹ نہیں کرتا ہے اور کم سے کم رقم سبری جو صف کے اختتام کے گرد لپیٹ نہیں ہوتا ہے۔اس کے بعد یہ صف کی کل رقم اور زیادہ سے زیادہ رقم سبری کی گنتی کرتا ہے جو صف کے اختتام کے گرد لپیٹتا ہے۔آخر میں ، فنکشن زیادہ سے زیادہ رقم کے سب سے زیادہ سے زیادہ کو لوٹاتا ہے جو صف کے اختتام کے گرد لپیٹ نہیں ہوتا ہے اور زیادہ سے زیادہ رقم سبری جو سرنی کے اختتام کے گرد لپیٹتا ہے۔ یہاں میکس_سم_سرکلر_سوبری () فنکشن کی ایک مثال استعمال ہے: پائیتھونومز = [[1 ، -2 ، 3 ، -2] پرنٹ (زیادہ سے زیادہ_سم_سیرکولر_سوبری (نمبرز)) # پرنٹس 3 میں اس مثال کے طور پر ، ہمیں زیادہ سے زیادہ رقم سبری [1 ، -2 ، 3 ، -2] میں زیادہ سے زیادہ رقم ملتی ہے [1 ، -2 ، 3 ، -2] میکس_سم_سرکلر_سوبری () فنکشن کا استعمال کرتے ہوئے۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سرکلر سرنی میں زیادہ سے زیادہ رقم سبری ہے [1]"
    },
    {
        "Question": "\"ہندسوں کے دیئے گئے تار کو حروف تہجی میں ڈیکوڈ کرنے کے لئے الگ الگ طریقوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں A = 1 ، B = 2 ، وغیرہ۔\"",
        "Answer": "ہندسوں کے دیئے گئے تار کو حرف تہجی میں ڈیکوڈ کرنے کے الگ الگ طریقوں کی تعداد تلاش کرنے کے ل ، ، جہاں A = 1 ، B = 2 ، وغیرہ ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم لمبائی N+1 کی ایک فہرست DP استعمال کرسکتے ہیں تاکہ سٹرنگ کو ITH کردار تک ڈیکوڈ کرنے کے طریقوں کی تعداد کو ٹریک کیا جاسکے ، جہاں N تار کی لمبائی ہے۔ہم ڈی پی کو 1 سے شروع کرسکتے ہیں ، کیونکہ خالی تار کو ڈی کوڈ کرنے کا صرف ایک ہی راستہ ہے۔اس کے بعد ہم تار کے اوپر تکرار کرسکتے ہیں اور ہر کردار کے ل we ، ہم چیک کرسکتے ہیں کہ آیا اسے ایک ہندسے کے طور پر یا دو ہندسوں کے نمبر کے طور پر ضابطہ کشائی کی جاسکتی ہے۔اگر اسے کسی ایک ہندسے کی حیثیت سے ضابطہ کشائی کی جاسکتی ہے تو ، ہم I-1-th کردار تک تار کو ڈیکوڈ کرنے کے طریقوں کی تعداد کو شامل کرسکتے ہیں جس میں ITH کے کردار تک تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد میں شامل کیا جاسکتا ہے۔اگر اسے دو ہندسوں کی تعداد کے طور پر ضابطہ کشائی کی جاسکتی ہے تو ، ہم I-2 ویں کردار تک تار کو ڈیکوڈ کرنے کے طریقوں کی تعداد کو شامل کرسکتے ہیں جس میں ITH کے کردار تک تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد میں شامل کیا جاسکتا ہے۔ہم ہندسوں کو ان کے متعلقہ حرفوں کے نقشہ بنانے کے لئے ایک لغت استعمال کرسکتے ہیں۔آخر میں ، ہم ڈی پی [این] کی قیمت کو واپس کرسکتے ہیں ، جو تار کو ڈی کوڈ کرنے کے لئے الگ الگ طریقوں کی تعداد ہے۔ ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف نمبر_ڈیکوڈنگز (ایس): این = لین (ایس) ڈی پی = [0 [0] * (n + 1) dp [0] = 1 میپنگ = {str (i): ch (i + 64) i in range (1 ، 27) in in range (1 ، n + 1) کے لئے: اگر: اگرs [i - 1] نقشہ سازی میں: dp [i] += dp [i - 1] اگر i> 1 اور s [i - 2: i] نقشہ سازی میں: dp [i] += dp [i - 2] واپسیڈی پی [این] اس نفاذ میں ، فنکشن نمبر_ڈیکوڈنگز () ان پٹ کے طور پر ایک تار لیتا ہے اور تار کو ڈی کوڈ کرنے کے الگ الگ طریقوں کی تعداد کو واپس کرتا ہے۔فنکشن سب سے پہلے لمبائی N+1 کی فہرست DP کو شروع کرتا ہے جس میں تمام اقدار 0 پر سیٹ کی جاتی ہیں ، جہاں N تار کی لمبائی ہے۔یہ ڈی پی کو 1 پر سیٹ کرتا ہے ، کیونکہ خالی تار کو ڈی کوڈ کرنے کا صرف ایک ہی راستہ ہے۔اس کے بعد یہ ہندسوں کو ان کے متعلقہ حرفوں پر نقشہ بنانے کے لئے ایک لغت کی نقشہ سازی کا آغاز کرتا ہے۔اس کے بعد یہ تار پر تکرار کرتا ہے اور ہر کردار کے ل it ، یہ چیک کرتا ہے کہ آیا اسے ایک ہندسے کے طور پر یا دو ہندسوں کے نمبر کے طور پر ضابطہ کشائی کی جاسکتی ہے۔اگر اسے کسی ایک ہندسے کی حیثیت سے ضابطہ کشائی کی جاسکتی ہے تو ، اس میں I-1-Th کردار تک تار کو ڈیکوڈ کرنے کے طریقوں کی تعداد شامل کردی گئی ہے جس میں ITH کے کردار تک تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد میں شامل کیا جاتا ہے۔اگر اسے دو ہندسوں کی تعداد کے طور پر ضابطہ کشائی کی جاسکتی ہے تو ، اس میں I-2-TH کردار تک تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد شامل کردی گئی ہے جس میں ITH کے کردار تک تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد میں شامل کیا جاتا ہے۔آخر میں ، فنکشن ڈی پی [این] کی قدر لوٹاتا ہے ، جو تار کو ڈی کوڈ کرنے کے لئے الگ الگ طریقوں کی تعداد ہے۔ NUM_DECODINGS () فنکشن کا ایک مثال استعمال: ازگر = '226' پرنٹ (num_decodings (s)) # پرنٹس3 اس مثال میں ، ہمیں Num_decodings () فنکشن کا استعمال کرتے ہوئے حرف '226' کو حرفوں میں ڈیکوڈ کرنے کے الگ الگ طریقوں کی تعداد ملتی ہے۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ تار کو ڈی کوڈ کرنے کے 3 الگ الگ طریقے ہیں: 'BZ' ، 'VF' ، اور 'BBF'.1geeksforgeeks2stackoverflow3geeksforgeeks4leetcode5leetcode"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے تین دیئے گئے تاروں کی سب سے طویل مشترکہ حصول تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "متحرک پروگرامنگ کا استعمال کرتے ہوئے تین دیئے گئے تاروں کی سب سے طویل عرصے تک عام طور پر تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: طول و عرض کی 3D لسٹ ڈی پی شروع کریں (ایم+1) ایکس (این+1) ایکس (او+1) ، جہاں ایم ، این ، این۔، اور o بالترتیب تینوں تاروں کی لمبائی ہیں۔فہرست میں شامل تمام اقدار کو 0. پر تین تاروں پر اور ہر کردار کے لئے شروع کریں ، چیک کریں کہ آیا یہ تینوں ڈوروں میں عام ہے یا نہیں۔اگر یہ ہے تو ، موجودہ انڈیکس کے لئے ڈی پی لسٹ میں قیمت کو اپ ڈیٹ کریں جو پچھلے انڈیکس پلس کے لئے ڈی پی لسٹ میں قیمت ہیں۔موجودہ اشارے تینوں تاروں میں سے ہر ایک کے لئے پچھلے اشاریوں کے لئے ڈی پی لسٹ میں زیادہ سے زیادہ اقدار کی حیثیت رکھتے ہیں۔ سب سے طویل عام مشترکہ حصول کی لمبائی اشاریہ جات (ایم ، این ، او) کے لئے ڈی پی لسٹ میں قدر ہے۔ازگر میں اس نقطہ نظر کا نفاذ: پائیتھنڈف LCS_OF_THERE_STRINGS (X ، Y ، Z): M ، N ، O = لین (X) ، لین (Y) ، لین (Z) DP = [[[0 کے لئے _+ 1)] رینج (n + 1)] کے لئے _ کے لئے _ کے لئے (M + 1)] I کے لئے (1 ، m + 1): J کے لئے رینج (1 ، n + 1): K کے لئےرینج میں (1 ، o + 1): اگر x [i - 1] == y [j - 1] == z [k - 1]: dp [i] [j] [k] = dp [i - 1] [j - 1] [k - 1] + 1 اور: dp [i] [j] [k] = زیادہ سے زیادہ (dp [i - 1] [j] [k] ، dp [i] [j - 1][K] ، DP [i] [j] [K - 1]) واپسی DP [M] [n] [o] اس عمل میں ، فنکشن LCS_OF_THERE_STRINGS () تین ڈوروں کو X ، Y ، اور Z کو ان پٹ اور ریٹرن کے طور پر لیتا ہے۔تینوں ڈوروں کے سب سے طویل عام مشترکہ حصے کی لمبائی۔فنکشن سب سے پہلے طول و عرض (M+1) X (n+1) X (O+1) کی 3D فہرست DP کی ابتدا کرتا ہے ، جہاں M ، N ، اور O بالترتیب تین تار کی لمبائی ہیں۔یہ فہرست میں شامل تمام اقدار کو 0 پر شروع کرتا ہے۔ پھر یہ تینوں تاروں پر تکرار کرتا ہے اور ہر کردار کے لئے ، یہ چیک کرتا ہے کہ آیا یہ تینوں ڈوروں میں عام ہے۔اگر یہ ہے تو ، یہ موجودہ انڈیکس کے لئے ڈی پی لسٹ میں قیمت کو اپ ڈیٹ کرتا ہے جس میں پچھلے اشاریہ کے علاوہ ڈی پی لسٹ میں قیمت ہوتی ہے۔موجودہ اشاریہ جات میں سے ہر ایک کے لئے پچھلے اشاریہ کے لئے ڈی پی لسٹ میں زیادہ سے زیادہ اقدار کی حیثیت سے ہیں۔آخر میں ، فنکشن انڈیکس (ایم ، این ، او) کے لئے ڈی پی لسٹ میں قیمت لوٹاتا ہے ، جو سب سے طویل عام مشترکہ کی لمبائی ہے۔ LCS_OF_THERE_STRINGS () فنکشن کا ایک مثال استعمال: پائیٹونکس = 'ایگٹاب' ='gxtxayb'z =' gtab'print (lcs_of_three_strings (x ، y ، z)) # پرنٹس 2 میں ، اس مثال کے طور پر ، ہمیں تین ڈور 'ایگٹاب' ، 'gxtxayb' ، اور 'gtab' کی سب سے طویل عام مشترکہ کی لمبائی ملتی ہے۔LCS_OF_THERE_STRINGS () فنکشن کا استعمال کرتے ہوئے۔فنکشن 2 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ تینوں تاروں کا سب سے طویل عام حصول 'gt'.1stackoverflow2includhelp3tutorialcup4geeksforgeeks5codingninjas ہے"
    },
    {
        "Question": "\"اسکیپ لسٹ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور عناصر کو موثر طریقے سے داخل کرنے ، تلاش کرنے اور ان کو دور کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس ہے جو اسکیپ لسٹ کی نمائندگی کرتی ہے اور عناصر کو موثر طریقے سے داخل کرنے ، تلاش کرنے اور ان کو دور کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد اور عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد اور عمل درآمد کرنے کے طریقوں کو نافذ کرنے کے طریقوں اور عمل کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد اور عمل کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں اور عمل کو نافذ کرنے کے طریقوں کو نافذ کرنے کے طریقوں پر عمل درآمد کرنے کے طریقوں کو نافذ کرنا۔] * اونچائی کلاس اسکیپلسٹ: Def __init __ (خود): سیلف ہیڈ = اسکیپ نوڈ () سیلف۔ لن = 0 سیلف۔ میکس_ہائٹ = 0 ڈیف __len __ (خود)رینڈم () <0.5 اور اونچائی <لین (سیلف۔ ہیڈ. نیکسٹ) + 1: اونچائی + = 1 ریٹرن اونچائی ڈیف تلاش کریں (خود ، الیوم ، اپ ڈیٹ = کوئی بھی نہیں): اگر اپ ڈیٹ کوئی نہیں ہے: اپ ڈیٹ = [کوئی نہیں] * لین (self.head.next) نوڈ = سیلف ہیڈ کے لئے الٹ (رینج (لین (node.next))) میں Iاگلا [i] اگر اپ ڈیٹ: اپ ڈیٹ [i] = نوڈ ریٹرن نوڈ۔ نیکسٹ [0] ، اپ ڈیٹ ڈیف پر مشتمل ہے (خود ، الیوم): نوڈ ، _ = سیلف۔فائنڈ (الیم) ریٹرن نوڈ کوئی نہیں اور نوڈ نہیں ہے۔= الیم ڈیف داخل کریں (خود ، الیوم): نوڈ ، اپ ڈیٹ = سیلف۔ فائنڈ (الیوم) اگر نوڈ کوئی نہیں ہے یا نوڈ۔ ایلیم! = الیم: اونچائی = سیلف۔ رینڈوم_ہائٹ () اگر اونچائی> لین (سیلف۔ ہیڈ ڈاٹ نیکسٹ).[i] .next [i] اپ ڈیٹ [i] .next [i] = نوڈ سیل. لن += 1 ڈیف کو ہٹائیں (خود ، الیوم): نوڈ ، اپ ڈیٹ = سیلف۔ فائنڈ (الیم) اگر نوڈ کوئی نہیں ہے اور نوڈ نہیں ہے۔.elem == elem: I میں الٹ (رینج (len (node.next))) میں I کے لئے: اگر اپ ڈیٹ [i]. نیکسٹ [i]! = نوڈ: بریک اپ ڈیٹ [i]. نیکسٹ [i] = نوڈ. نیکسٹ[i] جبکہ لین (سیلف ہیڈ ڈاٹ نیکسٹ)> 1 اور سیلف۔ ہیڈ. نیکسٹ [-1] کوئی بھی نہیں ہے: سیلف۔ ہیڈ.نیکسٹ.پوپ () سیلف ۔لین -= 1 اس پر عمل درآمد میں ، اسکیپ نوڈ کلاس ایک کی نمائندگی کرتا ہے۔اسکیپ لسٹ میں نوڈ اور اس کی دو صفات ہیں: الیم اور اگلا ، جہاں الیم نوڈ میں ذخیرہ عنصر ہے اور اگلا اگلے نوڈس کے پوائنٹرز کی فہرست ہے۔اسکیپلسٹ کلاس اسکیپ لسٹ کی نمائندگی کرتی ہے اور اس میں تین صفات ہیں: ہیڈ ، لین ، اور میکس_ہائٹ ، جہاں سر ایک سینٹینل نوڈ ہے ، لین اس فہرست میں عناصر کی تعداد ہے ، اور میکس_ہائٹ فہرست میں کسی بھی نوڈ کی زیادہ سے زیادہ اونچائی ہے۔کلاس کے چار طریقے بھی ہیں: __len __ () ، بے ترتیب_ہائٹ () ، تلاش () ، () پر مشتمل ہے () ، داخل کریں () ، اور ہٹائیں ()۔__len __ () طریقہ فہرست میں موجود عناصر کی تعداد لوٹاتا ہے۔بے ترتیب_ہائٹ () طریقہ ایک نئے نوڈ کے لئے بے ترتیب اونچائی پیدا کرتا ہے۔تلاش () کا طریقہ دیئے گئے عنصر کے ساتھ نوڈ تلاش کرتا ہے اور نوڈ اور نوڈس کی فہرست لوٹاتا ہے جس کو اپ ڈیٹ کرنے کی ضرورت ہوتی ہے۔اگر فہرست میں دیئے گئے عنصر پر مشتمل ہے تو () طریقہ کار چیک کرتا ہے۔داخل () کا طریقہ فہرست میں دیئے گئے عنصر کے ساتھ ایک نیا نوڈ داخل کرتا ہے۔ہٹانے () کا طریقہ فہرست سے دیئے گئے عنصر کے ساتھ نوڈ کو ہٹا دیتا ہے۔ اسکیپلسٹ کلاس کا ایک مثال استعمال: پائیتھونسل = اسکیپلسٹ () sl.insert (1) sl.insert (2) SL.Insert (3) پرنٹ (پرنٹ (3) پرنٹ (3) پرنٹ (3) پرنٹ (3)لین (ایس ایل)) # پرنٹ 3 پرنٹ (sl.contains (2)) # پرنٹس trusel.remove (2) پرنٹ (لین (ایس ایل)) # پرنٹ 2 پرنٹ (sl.contains (2)) # پرنٹس فالس مثال ، ہم تخلیق کرتے ہیں ، ہم تخلیق کرتے ہیں۔ایک نیا اسکیپلسٹ آبجیکٹ ایس ایل اور عناصر 1 ، 2 ، اور 3 کو داخل () کے طریقہ کار کا استعمال کرتے ہوئے فہرست میں داخل کریں۔اس کے بعد ہم __len __ () کے طریقہ کار کا استعمال کرتے ہوئے فہرست کی لمبائی پرنٹ کرتے ہیں اور چیک کرتے ہیں کہ آیا اس فہرست میں عنصر 2 شامل ہے () پر مشتمل () طریقہ کار کا استعمال کرتے ہوئے۔اس کے بعد ہم ہٹ () کے طریقہ کار کا استعمال کرتے ہوئے عنصر 2 کو فہرست سے ہٹاتے ہیں اور دوبارہ فہرست کی لمبائی پرنٹ کریں اور چیک کریں کہ آیا اس فہرست میں عنصر 2.1 ورڈ پریس 2 سی آئی پی آئی سیپلسٹ 4 جی ای ای ای ایس ایف ایف ای جی ایم یو پر مشتمل ہے۔"
    },
    {
        "Question": "\"ہر سکے کے فرق کی لامحدود فراہمی کے ساتھ ، ایک مقررہ مقدار میں تبدیلی کے ل needed کم سے کم تعداد میں سککوں کی تلاش کے ل a ایک پروگرام بنائیں ، جبکہ سکے کی کل تعداد کو کم سے کم کریں۔\"",
        "Answer": "ہر سکے کے فرق کی لامحدود فراہمی کے ساتھ ، تبدیلیوں کی ایک مقررہ رقم کے لئے درکار سککوں کی کم سے کم تعداد تلاش کرنے کے ل ، ، جبکہ سکے کی کل تعداد کو کم سے کم کرتے ہوئے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم لمبائی کی رقم+1 کی ایک فہرست ڈی پی تشکیل دے سکتے ہیں اور فہرست میں موجود تمام اقدار کو انفینٹی کے لئے شروع کرسکتے ہیں سوائے انڈیکس 0 کی قیمت کے ، جسے ہم 0 پر سیٹ کرتے ہیں۔ پھر ہم سکے کے فرق کی فہرست اور ہر فرق کے لئے تکرار کرسکتے ہیں ،ہم ڈی پی لسٹ پر تکرار کرسکتے ہیں اور ہر انڈیکس میں قیمت کو کم سے کم موجودہ قیمت کی کم سے کم اور انڈیکس مائنس ڈینومینیشن پلس ون میں قدر کی اپ ڈیٹ کرسکتے ہیں۔آخر میں ، ہم ڈی پی لسٹ میں انڈیکس رقم پر قیمت واپس کرسکتے ہیں۔ اس نقطہ نظر کا نفاذ ازگر میں ہے: پیتھونڈف من_ کوائنز (رقم ، سکے): ڈی پی = [فلوٹ ('انف')] * (رقم + 1) ڈی پی [0] = 0 سکے میں سکے کے لئے: میں رینج (سکے ، رقم + 1) کے لئے: ڈی پی [i] = منٹ (ڈی پی [i] ، ڈی پی [i - سکے] + 1) اس عمل میں ڈی پی [رقم] واپس کریں، فنکشن MIN_COIONS () ان پٹ کے طور پر ایک عددی رقم اور انٹیجرس سککوں کی ایک فہرست لیتا ہے اور تبدیلی کی دی گئی مقدار کو بنانے کے لئے درکار سککوں کی کم سے کم تعداد واپس کرتا ہے۔فنکشن سب سے پہلے انڈیکس 0 کی قیمت کے علاوہ لامحدودیت کے لئے مقرر کردہ تمام اقدار کے ساتھ لمبائی کی رقم+1 کی فہرست ڈی پی کی ابتدا کرتا ہے ، جو 0 پر سیٹ کیا جاتا ہے۔ پھر یہ سکے کے فرق کی فہرست پر تکرار کرتا ہے اور ہر فرق کے ل it ، یہ اس پر تکرار کرتا ہے۔ڈی پی ہر انڈیکس کی قیمت کو موجودہ قیمت کی کم سے کم اور انڈیکس مائنس ڈینومیشن پلس ون میں قیمت کی فہرست اور تازہ کاری کرتا ہے۔آخر میں ، فنکشن ڈی پی لسٹ میں انڈیکس رقم پر قیمت لوٹاتا ہے۔ یہاں MIN_COINS () فنکشن کا ایک مثال استعمال: پائیتھوناماؤنٹ = 11 کوائنز = [1 ، 5 ، 6 ، 8] پرنٹ (MIN_COINS (رقم ، سکے)) # پرنٹس)2 اس مثال میں ، ہمیں سکے کے فرقوں کا استعمال کرتے ہوئے 11 رقم بنانے کے لئے درکار سککوں کی کم سے کم تعداد ملتی ہے [1] [5] [6] [8] MIN_COIONS () فنکشن کا استعمال کرتے ہوئے۔فنکشن 2 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سککوں کی کم از کم تعداد 2 (ایک 6 فیصد کا سکے اور ایک 5 فیصد سکے) ہے ۔1 وولفرم کے ذریعہ پاور | الفا 2 میڈیم 3 ایڈیوکیٹیو 4youtube5Enayalgorithms"
    },
    {
        "Question": "سلائڈنگ ونڈو نقطہ نظر کا استعمال کرتے ہوئے عددی کی ایک دی گئی فہرست میں زیادہ تر K الگ الگ عدد کے ساتھ طویل ترین بڑھتی ہوئی سبری کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "سلائیڈنگ ونڈو نقطہ نظر کا استعمال کرتے ہوئے انٹیجرز کی ایک دی گئی فہرست میں زیادہ تر K الگ الگ انٹیجرز کے ساتھ سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے ل we ، ہم مندرجہ ذیل اقدامات کا استعمال کرسکتے ہیں: فہرست کے آغاز تک بائیں اور دائیں دو پوائنٹرز کو شروع کریں۔ رکھنے کے لئے لغت کی گنتی کو غیر منقولہ بنائیںموجودہ subarray میں ہر انٹیجر کے واقعات کی تعداد کا سراغ لگائیں۔ موجودہ subarray میں الگ الگ عدد کی تعداد پر نظر رکھنے کے لئے 0 سے الگ الگ متغیر بنائیں۔سب سے زیادہ کے ساتھ سب سے زیادہ کے الگ الگ عدد کے ساتھ۔ اس فہرست کی لمبائی سے کم ہے۔الگ الگ ہے K سے یا انڈیکس دائیں طرف انٹیجر انڈیکس دائیں -1 میں عدد سے کم ہے۔. انکریمنٹ بائیں۔ اپ ڈیٹ میکس_ لمبائی زیادہ سے زیادہ میکس_ لمبائی اور دائیں بائیں+1. انکریمنٹ دائیں۔ ریٹورن میکس_ لمبائی۔ ہر لمبائی کا عمل ازگر میں اس نقطہ نظر کا نفاذ: پائیتھونڈف سب سے طویل_increasing_subarray_with_dist_dist_livet = sigle = sigl = sigl = signs = signs = signs = signs = signs = signs = signs = signs = signs = sigle = signs = signs = signs = signs = signss = signs = signs = sigl = max)0 گنتی = {} جبکہ دائیں <لین (نمبر): اگر نمبر [صحیح] گنتی میں نہیں: الگ الگ + = 1 گنتی [نمبر [دائیں]] = گنتی۔k یا (دائیں> 0 اور نمبر [دائیں] <= nums [دائیں -1]): گنتی [نمبر [بائیں]] -= 1 اگر گنتی [نمبر [بائیں]] == 0: الگ -= 1 بائیں +=1 میکس_ لمبائی = زیادہ سے زیادہ (زیادہ سے زیادہ_ لمبائی ، دائیں - بائیں + 1) دائیں + = 1 میکس_ لمبائی کی واپسی اس نفاذ میں ، فنکشن سب سے طویل_increasing_subarray_with_k_distinct () ان پٹ کے طور پر انٹیجرز کی فہرست اور ایک انٹیجر K کی فہرست لیتا ہے اور ان پٹ کے طور پر ایک طویل عرصہ تک بڑھتی ہوئی سب کے ساتھ لوٹتا ہے۔زیادہ تر K الگ الگ عدد۔اس فنکشن نے پہلے فہرست کے آغاز تک دو پوائنٹرز کو بائیں اور دائیں شروع کیا ہے ، موجودہ سبری میں ہر عدد کے واقعات کی تعداد پر نظر رکھنے کے لئے ایک لغت کی گنتی ، ایک متغیر 0 سے مختلف ہے تاکہ الگ الگ انٹیجرز کی تعداد کو ٹریک کیا جاسکے۔زیادہ تر K الگ الگ انٹیجرز کے ساتھ طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی کا سراغ لگانے کے لئے موجودہ سبری ، اور متغیر میکس_ لمبائی 0 سے زیادہ۔اس کے بعد یہ دو پوائنٹرز اور لغت کا استعمال کرتے ہوئے فہرست میں تکرار کرتا ہے۔ہر انٹیجر کے ل it ، یہ چیک کرتا ہے کہ آیا یہ لغت کی گنتی میں ہے۔اگر یہ نہیں ہے تو ، اس میں اضافہ ہوتا ہے۔اس کے بعد لغت کی گنتی میں عددی کی گنتی میں اضافہ ہوتا ہے۔اگر الگ الگ ہے K یا انڈیکس دائیں طرف انٹیجر انڈیکس رائٹ 1 میں انٹیجر سے کم یا اس کے برابر ہے تو ، یہ لغت کی گنتی میں رہ جانے والے انڈیکس میں عدد کی گنتی کو کم کرتا ہے۔اگر انڈیکس بائیں طرف انٹیجر کی گنتی 0 ہے تو ، یہ الگ الگ اور باقی رہ جانے والی اضافہ کرتا ہے۔اس کے بعد یہ زیادہ سے زیادہ میکس_ لمبائی اور دائیں بائیں+1 کی زیادہ سے زیادہ میکس_لنتھ کو اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن میکس_ لمبائی کو لوٹاتا ہے۔ یہاں سب سے طویل_increasing_subarray_with_k_distinct () فنکشن: [1 ، 3 ، 1 ، 2 ، 2 ، 3 ، 4] K = 3 پرنٹ (لمبے لمبے_انکریزنگ_سوبری_ ڈسٹنٹ (نمبر) کے ساتھ)مثال کے طور پر ، ہمیں فہرست میں زیادہ سے زیادہ 3 الگ الگ عدد کے ساتھ سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی [1] [3] [1] [2] [2] [2] [3] [4] سب سے طویل_increasing_subarray_with_k_distinct () فنکشن کا استعمال کرتے ہوئے ملتی ہے۔فنکشن 5 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ زیادہ سے زیادہ 3 الگ الگ عدد کے ساتھ سب سے طویل عرصہ تک بڑھتا ہوا سبری ہے [1] [2] [2] [3] [3] [4]"
    },
    {
        "Question": "لوگرتھمک ٹائم پیچیدگی میں مساوی سائز کی دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "لوگرتھمک ٹائم پیچیدگی میں مساوی سائز کی دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے بہت سارے طریقے ہیں۔ایک نقطہ نظر میڈین کو تلاش کرنے کے لئے بائنری سرچ الگورتھم کا استعمال کرنا ہے۔الگورتھم کیسے کام کرتا ہے یہاں ہے: بالترتیب ، بائیں اور دائیں سے بائیں اور دائیں سے دو پوائنٹرز کو شروع کریں۔ جب بائیں بائیں اور دائیں سے کم یا اس کے برابر ہے: درمیانی اشاریہ وسط کا حساب بائیں اور دائیں کی اوسط کے طور پر کریں۔ اگر عنصر اے ٹی پر ہے۔پہلی صف میں انڈیکس مڈ دوسری صف میں انڈیکس N-MID-1 میں عنصر سے کم ہے ، جس کو بائیں طرف+1. اور اس کے بعد سیٹ کریں ، اگر پہلی صف میں انڈیکس مڈ میں عنصر انڈیکس ن میں عنصر سے زیادہ ہے۔-مڈ -1 دوسری صف میں ، وسط 1 کے وسط تک مقرر کریں۔.یہ ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف Find_median_sorted_arrays (nums1 ، nums2): n = len (nums1) بائیں ، دائیں = 0 ، n - 1 جبکہ بائیں <= دائیں: درمیانی = (بائیں + دائیں) // 2 اگرNums1 [Mid] <nums2 [n - وسط - 1]: بائیں = وسط + 1 الیف nums1 [Mid]> nums2 [n - وسط - 1]: دائیں = وسط - 1 اور: واپس نمبر 1 [وسط] واپسی -1 ان میں اس کی واپسینفاذ ، فنکشن Find_median_sorted_arrays () ان پٹ کے طور پر دو ترتیب شدہ صفوں نمبر 1 اور برابر سائز کے نمبر 2 لیتا ہے اور ان دونوں صفوں کے وسط کو واپس کرتا ہے۔فنکشن سب سے پہلے بالترتیب اریوں کے آغاز اور اختتام تک بائیں اور دائیں دو پوائنٹرز کا آغاز کرتا ہے۔اس کے بعد یہ دونوں صفوں کے وسط کو تلاش کرنے کے لئے بائنری سرچ الگورتھم کا استعمال کرتا ہے۔بائنری تلاش کے ہر تکرار کے ل it ، یہ درمیانی انڈیکس وسط کا حساب بائیں اور دائیں کی اوسط کے طور پر کرتا ہے۔اگر پہلی صف میں انڈیکس وسط میں عنصر دوسری صف میں انڈیکس N-MID-1 کے عنصر سے کم ہے تو ، یہ درمیانی+1 پر بائیں طرف جاتا ہے۔اگر پہلی صف میں انڈیکس مڈ میں عنصر دوسری صف میں انڈیکس این-ایم آئی ڈی -1 کے عنصر سے زیادہ ہے تو ، یہ وسط -1 کے دائیں طرف طے کرتا ہے۔بصورت دیگر ، یہ یا تو میڈین کی حیثیت سے کسی بھی صف میں انڈیکس مڈ میں عنصر کو لوٹاتا ہے۔اگر ابھی تک الگورتھم واپس نہیں آیا ہے تو ، اس سے یہ ظاہر ہوتا ہے کہ میڈین نہیں ملا تھا۔4 ، 6 ، 8 ، 10] پرنٹ (find_median_sorted_arrays (nums1 ، nums2)) # پرنٹس 5 اس مثال کے طور پر ، ہمیں دو ترتیب شدہ صفوں کا درمیانی [1] [3] [5] [7] [9] اور [2 مل جاتا ہے] [4] [6] [8] [10] find_median_sorted_arrays () فنکشن کا استعمال کرتے ہوئے۔فنکشن 5 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ دونوں صفوں کا میڈین 5.1stackexchange2leetcode3youtube4youtube5geeksforgeeks ہے"
    },
    {
        "Question": "کواڈٹری کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور پوائنٹس کو موثر طریقے سے داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو ایک کواڈٹری کی نمائندگی کرتی ہے اور پوائنٹس کو موثر طریقے سے داخل کرنے اور تلاش کرنے کے ل methods طریقوں کو نافذ کرنے کے طریقوں کی نمائندگی کرتی ہے: پائیٹونکلاس پوائنٹ: Def __init __ (خود ، x ، y ، ڈیٹا = کوئی نہیں): self.x = x sellکواڈٹری: Def __init __ (خود ، حد ، میکس_پوائنٹ = 4 ، میکس_ڈیپتھ = 10 ، گہرائی = 0): سیلف بائونڈری = باؤنڈری خود۔ میکس_پوائنٹس = میکس_پوائنٹس سیلف۔ میکس_ڈیپتھ = میکس_ڈیپتھ خود۔ ڈیپتھ = گہرائی خود۔بچے = [] ڈیف داخل کریں (خود ، نقطہ): اگر خود نہیں ہے۔ضمیمہ (نقطہ) اگر خود نہیں تو سچائی لوٹیں۔self.boundary.y w = self.boundary.w / 2 h = self.boundary.h / 2 self.children.append (Quadtree (rect (x - w ، y - h ، w ، h) ، سیلف۔ میکس_پوائنٹس ، خود ، خود.max_depth ، self.depth + 1)) self.children.append (Quadtree (rect (x + w ، y - h ، w ، h) ، self.max_points ، self.max_depth ، self.depth + 1) خود۔بچوں کو۔Y + H ، W ، H) ، self.max_Points ، self.max_depth ، self.depth + 1)) ڈیف سرچ (خود ، حد): نتیجہ = [] اگر خود نہیں ہے۔خود نقطہ نظر میں نقطہ: اگر حد سے زیادہ۔، ڈبلیو ، ایچ): سیلف۔ ایکس = ایکس سیلف۔self.x + self.w and self.y - self.h <= point.y <= self.y + self.h) def ایک دوسرے کے ساتھ.x + other.w and self.x + self.w> = دیگر. x - دیگر.W اور self.y - sellدیگر - y - Y.H) اس نفاذ میں ، پوائنٹ کلاس اختیاری اعداد و شمار کے ساتھ دو جہتی جگہ میں ایک نقطہ کی نمائندگی کرتا ہے۔ریکٹ کلاس اپنے مرکز ، چوڑائی اور اونچائی کے ذریعے دو جہتی جگہ میں مستطیل کی نمائندگی کرتا ہے۔کواڈٹری کلاس خود کواڈٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس کی وضاحت بار بار کی جاتی ہے ، اس طرح کہ جب نوڈ کو تقسیم کرنے کی ضرورت ہوتی ہے تو ، اس سے چار بچوں کے نوڈس پیدا ہوتے ہیں۔کلاس کے چار طریقے ہیں: __init __ () ، داخل کریں () ، سب ڈیوڈ () ، اور تلاش ()۔__init __ () طریقہ کواڈٹری کے ایک نوڈ کو شروع کرتا ہے۔داخل () کا طریقہ کواڈٹری میں ایک نقطہ داخل کرتا ہے۔سب ڈیوڈ () کا طریقہ چار بچوں کے نوڈس میں ایک نوڈ کو ذیلی تقسیم کرتا ہے۔تلاش () طریقہ کسی دیئے گئے حدود میں تمام نکات کی تلاش کرتا ہے۔ یہاں کواڈٹری کلاس کا ایک مثال استعمال ہے: پائیٹون بائونڈری = ریکٹ (0 ، 0 ، 100 ، 100) کواڈٹری = کواڈٹری (حدود ، میکس_پوائنٹ = 4 ، میکس_ڈیپتھ = 10) پوائنٹس= [نقطہ (10 ، 10) ، پوائنٹ (20 ، 20) ، پوائنٹ (30 ، 30) ، پوائنٹ (40 ، 40)] پوائنٹس میں نقطہ کے لئے: quadtree.insert (نقطہ) نتیجہ = quadtree.search (rect (0، 0 ، 50 ، 50))) اس کے نتیجے میں نقطہ کے لئے: اس مثال میں پرنٹ (پوائنٹ. ایکس ، پوائنٹ.ای) ، ہم (0 ، 0 ، 100 ، 100) کی حد کے ساتھ ایک نیا کواڈٹری آبجیکٹ کواڈٹری بناتے ہیںفی نوڈ 4 پوائنٹس اور گہرائی کی 10 سطح۔اس کے بعد ہم کواڈٹری میں چار پوائنٹس داخل کرتے ہیں اور (0 ، 0 ، 50 ، 50) کی حدود میں موجود تمام پوائنٹس کی تلاش کرتے ہیں۔فنکشن پوائنٹس (10 ، 10) اور (20 ، 20) واپس کرتا ہے ، جو تلاش کی حد کے اندر ہیں۔"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، سلیش ، اور کسٹم آپریٹرز کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور آپریٹر کی پیش کش کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، سلیشس ، اور کسٹم آپریٹرز کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا تاثرات اور آپریٹر کی پیش کش کی اجازت ہے ، ہم اسٹیک ڈیٹا ڈھانچے کا استعمال کرسکتے ہیں۔ہم تار پر تکرار کرسکتے ہیں اور ہر کردار کے ل we ، ہم چیک کرسکتے ہیں کہ آیا یہ افتتاحی علامت ہے یا بند ہونے والی علامت۔اگر یہ افتتاحی علامت ہے تو ، ہم اسے اسٹیک پر دھکیلتے ہیں۔اگر یہ بند ہونے والی علامت ہے تو ، ہم اسٹیک سے ٹاپ عنصر کو پاپ کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ اختتامی علامت سے مماثل ہے یا نہیں۔اگر یہ مماثل نہیں ہے یا اسٹیک خالی ہے تو ، اظہار متوازن نہیں ہے۔اگر ہم تار کے اختتام پر پہنچ جاتے ہیں اور اسٹیک خالی ہے تو ، اظہار متوازن ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف آئی ایس_والیڈ_کسپریشن (ایکسپریس): اسٹیک = [] اوپننگ_سیمبولس = \"]}> \"ایکسپریس میں چار کے لئے: اگر اوپننگ_سیمبولز میں چار: اسٹیک.اپینڈ (چار) الیف چار میں بند_سیمبولز میں: اگر اسٹیک نہیں ہے تو: غلط ٹاپ = اسٹیک ۔پوپ () اگر اوپننگ_سیمبولس۔ انڈیکس (اوپر)!(CHAR): غلط ریٹرن واپس نہ کریں اس پر عمل درآمد کو اسٹیک نہیں کریں گے ، فنکشن IS_Valid_expression () ان پٹ کے طور پر سٹرنگ ایکسپریس لیتا ہے اور اگر اظہار درست اور غلط ہے تو اگر کوئی دوسری صورت میں غلط ہے۔فنکشن پہلے ایک خالی اسٹیک اور دو ڈور اوپننگ_سیمبولز اور کلوزنگ_سیمبولس کا آغاز کرتا ہے جس میں بالترتیب افتتاحی اور اختتامی علامتیں ہوتی ہیں۔اس کے بعد یہ تار پر تکرار کرتا ہے اور ہر کردار کے ل it ، یہ چیک کرتا ہے کہ آیا یہ افتتاحی علامت ہے یا بند علامت ہے۔اگر یہ افتتاحی علامت ہے تو ، یہ اسے اسٹیک پر دھکیل دیتا ہے۔اگر یہ بند ہونے والی علامت ہے تو ، یہ اسٹیک سے ٹاپ عنصر کو پاپ کرتا ہے اور چیک کرتا ہے کہ اگر یہ اختتامی علامت سے مماثل ہے۔اگر یہ مماثل نہیں ہے یا اسٹیک خالی ہے تو ، اظہار متوازن نہیں ہے اور فنکشن غلط لوٹتا ہے۔اگر ہم سٹرنگ کے اختتام پر پہنچ جاتے ہیں اور اسٹیک خالی ہے تو ، اظہار متوازن ہے اور فنکشن سچ واپس آجاتا ہے۔ یہاں IS_Valid_expression () فنکشن: پائیتھون ایکس پی آر = \"(A + B) * (C - D) کی ایک مثال استعمال ہے۔\"پرنٹ (is_valid_expression (exprison)) # پرنٹس سچے اس مثال کے طور پر ، ہم چیک کرتے ہیں کہ آیا اظہار (a + b) * (c - d) is_valid_expression () فنکشن کا استعمال کرتے ہوئے درست ہے یا نہیں۔فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ اظہار درست ہے۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سبری کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عددیوں کی ایک دی گئی فہرست میں کسی سبری کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل we ، ہم کڈانے کے الگورتھم کو استعمال کرسکتے ہیں۔الگورتھم سرنی کے ہر انڈیکس پر ختم ہونے والے زیادہ سے زیادہ اور کم سے کم مصنوعات کے سبریوں کو ٹریک کرتے ہوئے کام کرتا ہے۔ہم دو متغیرات میکس_سو_فر اور من_سو_فار کو صف کے پہلے عنصر میں شروع کرتے ہیں اور صف کے باقی عناصر پر تکرار کرتے ہیں۔ہر عنصر کے ل we ، ہم max_so_far اور min_so_far کو مندرجہ ذیل طور پر اپ ڈیٹ کرتے ہیں: اگر عنصر مثبت ہے تو ، ہم زیادہ سے زیادہ MAX_SO_FAR * عنصر اور عنصر کی زیادہ سے زیادہ ، اور MIN_SO_FAR کو کم سے کم MIN_SO_FAR * عنصر اور عنصر کے طور پر اپ ڈیٹ کرتے ہیں۔ اگر عنصر صفر ہے ، تو ہم ہیں ، ہم ہیں۔MAX_SO_FAR اور MIN_SO_FAR کو دوبارہ ترتیب دیں۔ 1. اگر عنصر منفی ہے تو ، ہم MAX_SO_FAR اور MIN_SO_FAR کو تبدیل کرتے ہیں اور MAX_SO_FAR کو زیادہ سے زیادہ میکس_سو_فر * عنصر اور عنصر کی حیثیت سے اپ ڈیٹ کرتے ہیں ، اور من_سو_فار کو کم سے کم منٹ_سو_فر * عنصر اور عنصر کی حیثیت سے اپ ڈیٹ کرتے ہیں۔متغیر نتیجہ نتیجہ کا زیادہ سے زیادہ اور میکس_سو_فار ہے۔آخر میں ، ہم نتیجہ لوٹتے ہیں۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھونڈف میکس_ پروڈکٹ_سوبری (نمبر): میکس_سو_فار = من_سو_فار = نتیجہ = نمبر [0] رینج (1 ، لین (نمبر)) کے لئے: اگر نمبر [i]>0: میکس_سو_فار = زیادہ سے زیادہ (میکس_سو_فار * نمبر [i] ، نمبر [i]) من_سو_فار = منٹ (منٹ_سو_فار * نمبر [i] ، نمبر [i]) ایلف نمبر [i] == 0: زیادہ سے زیادہ_سو_فر = منٹ_سو_فر = 1 اور:میکس_سو_فار ، Min_so_far = زیادہ سے زیادہ (min_so_far * nums [i] ، nums [i]) ، کم سے کم (زیادہ سے زیادہ_سو_فار * نمبر [i] ، نمبر [i]) نتیجہ = زیادہ سے زیادہ (نتیجہ ، زیادہ سے زیادہ_سو_فار) واپسی کے نتیجے میں ، فنکشن میکس_ پروڈکٹ_) ان پٹ کے طور پر انٹیجر نمبروں کی ایک فہرست لیتا ہے اور فہرست میں سبری کی زیادہ سے زیادہ مصنوعات کو لوٹاتا ہے۔فنکشن سب سے پہلے تین متغیرات میکس_سو_فار ، MIN_SO_FAR کی ابتدا کرتا ہے ، اور اس کے نتیجے میں صف کے پہلے عنصر کا نتیجہ ہوتا ہے۔اس کے بعد یہ صف کے باقی عناصر پر تکرار کرتا ہے اور میکس_سو_فر اور من_سو_فار کو اپ ڈیٹ کرتا ہے جیسا کہ اوپر بیان کیا گیا ہے۔ہر تکرار پر ، اس کے نتیجے میں زیادہ سے زیادہ نتیجہ اور میکس_سو_فر کی تازہ کاری ہوتی ہے۔آخر میں ، فنکشن نتیجہ لوٹاتا ہے۔ یہاں میکس_ پروڈکٹ_سوبری () فنکشن کا ایک مثال استعمال ہے: پائیتھونومس = [2 ، 3 ، -2 ، 4] پرنٹ (میکس_ پروڈکٹ_سوبری (نمبر)) # پرنٹس 6 ان مثال کے طور پر ، ہمیں A کی زیادہ سے زیادہ مصنوعات ملتی ہے ،فہرست میں subarray [1] [2] [-2] [3] میکس_ پروڈکٹ_سوبری () فنکشن کا استعمال کرتے ہوئے۔فنکشن 6 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سبری کی زیادہ سے زیادہ مصنوعات 6 ہے ، جو سبری سے حاصل کی جاتی ہے [1] [2]"
    },
    {
        "Question": "بائنری تلاش کا استعمال کرتے ہوئے عددیوں کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "بائنری سرچ کا استعمال کرتے ہوئے عددیوں کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک خالی فہرست کی دم شروع کریں۔ عددی کی فہرست اور ہر عدد کے لئے اس کا تعین کریں: اگر انٹیجر اس سے زیادہ ہے تو اس سے زیادہ ہے۔دم میں آخری عنصر ، اسے دم میں شامل کریں۔ دوسرے کے مطابق ، دم میں پہلے عنصر کا انڈیکس تلاش کریں جو بائنری تلاش کا استعمال کرتے ہوئے عدد سے زیادہ یا اس کے برابر ہوتا ہے اور اس عنصر کو انٹیجر کے ساتھ تبدیل کریں۔ دم کی لمبائی کو دوبارہ بنائیں۔ازگر میں اس نقطہ نظر کا نفاذ: پائیتھونڈف طویل ترین_انکریزنگ_سوبسینس (نمبر): دم = [] نمبر کے لئے نمبر: اگر دم نہیں یا نمبر> دم نہیں ہے تو [-1]: ٹیلس۔ اے پی پیینڈ (نمبر): بائیں ، دائیں = 0 ، لین ((دائیں = 0 ، لین (دم) - 1 جبکہ بائیں <دائیں: درمیانی = (بائیں + دائیں) // 2 اگر دم [وسط] <نمبر: بائیں = وسط + 1 اور: دائیں = وسط دم [بائیں] = نمبر لوٹ لین (دم) اس میں اس میںنفاذ ، فنکشن سب سے طویل_increasing_subsecence () ان پٹ کے طور پر انٹیجر نمبروں کی ایک فہرست لیتا ہے اور فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی کو لوٹاتا ہے۔فنکشن سب سے پہلے خالی فہرست کی دم کو شروع کرتا ہے۔اس کے بعد یہ انٹیجرز کی فہرست پر تکرار کرتا ہے اور ہر عدد کے لئے ، یہ چیک کرتا ہے کہ آیا یہ دم کے آخری عنصر سے زیادہ ہے یا نہیں۔اگر یہ ہے تو ، یہ اسے دم میں جوڑ دیتا ہے۔بصورت دیگر ، یہ دم میں پہلے عنصر کا انڈیکس تلاش کرنے کے لئے بائنری سرچ کا استعمال کرتا ہے جو عدد سے زیادہ یا اس کے برابر ہوتا ہے اور اس عنصر کو عددی کے ساتھ تبدیل کرتا ہے۔آخر میں ، فنکشن دم کی لمبائی لوٹاتا ہے۔ یہاں طویل ترین_Incresing_subsecence () فنکشن کی مثال کے طور پر استعمال: پائیتھونومس = [10 ، 9 ، 2 ، 5 ، 3 ، 7 ، 101 ، 18] پرنٹ (سب سے طویل_increasing_subsecence) # پرنٹس 4inاس مثال کے طور پر ، ہمیں فہرست میں سب سے طویل عرصہ تک بڑھتا ہوا ملحق پایا جاتا ہے [1] [2] [3] [101] سب سے طویل_increasing_subsence () فنکشن کا استعمال کرتے ہوئے۔فنکشن 4 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سب سے طویل عرصہ تک بڑھتی ہوئی تعداد [1] [3] [101] .1cp-algorithms2stackoverflow3opengenus ہے"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے دو ڈوروں کے مابین لیونشٹین فاصلے کا حساب لگانے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "لیونشین کا فاصلہ دو ڈوروں کے مابین مماثلت کا ایک پیمانہ ہے۔اس کی وضاحت ایک تار کو دوسرے میں تبدیل کرنے کے لئے درکار تبدیلیوں کی کم سے کم تعداد کے طور پر کی گئی ہے ، جہاں تبدیلی ایک اندراج ، حذف کرنے یا کسی کردار کا متبادل ہوسکتی ہے۔لیونشین فاصلہ ترمیم کے فاصلے کے نام سے بھی جانا جاتا ہے۔اس میں انفارمیشن تھیوری ، لسانیات ، اور کمپیوٹر سائنس میں ایپلی کیشنز موجود ہیں۔ متحرک پروگرامنگ کا استعمال کرتے ہوئے دو ڈوروں کے مابین لیونشین فاصلے کا حساب لگانے کے لئے ، ہم دونوں تاروں کے سابقہ جوڑے کے درمیان فاصلوں کو ذخیرہ کرنے کے لئے میٹرکس کا استعمال کرسکتے ہیں۔ہم خالی سابقہ اور دونوں ڈوروں کے سابقہوں کے درمیان فاصلوں کے ساتھ میٹرکس کا آغاز کرسکتے ہیں۔اس کے بعد ہم سابقہ تکرار کے رشتے کا استعمال کرتے ہوئے سابقہ جوڑے کے باقی جوڑے پر تکرار کرسکتے ہیں اور میٹرکس کو پُر کرسکتے ہیں: اگر دونوں ڈوروں میں موجودہ پوزیشنوں کے حروف ایک جیسے ہیں تو ، فاصلہ موجودہ کے بغیر سابقہ کے درمیان فاصلہ جیسا ہی ہے۔حروف۔ازگر: پائیتھنڈف لیونشٹین_ڈسٹینس (ایس 1 ، ایس 2): ایم ، این = لین (ایس 1) ، لین (ایس 2) ڈی پی = [[0] * (این + 1) رینج میں _ کے لئے (ایم + 1)] کے لئے (ایم + 1)ایم + 1): ڈی پی [i] [0] = i رینج میں جے کے لئے (n + 1): ڈی پی [0] [j] = j in range (1 ، m + 1) کے لئے (1 ، m + 1): J کے لئے رینج میں (1 ، n + 1): اگر S1 [i - 1] == s2 [j - 1]: dp [i] [j] = dp [i - 1] [j - 1] Else: dp [i] [j] = 1 + منٹ (ڈی پی [i - 1] [j] ، ڈی پی [i] [j - 1] ، ڈی پی [i - 1] [j - 1]) اس عمل میں ڈی پی [ایم] [این] لوٹائیں ، اس عمل میں ،فنکشن لیونشٹین_ڈسٹینس () دو ڈوروں کو ایس 1 اور ایس 2 کو ان پٹ کے طور پر لیتا ہے اور دونوں ڈوروں کے درمیان لیونشین فاصلہ لوٹاتا ہے۔فنکشن سب سے پہلے طول و عرض (M+1) X (n+1) کے ساتھ میٹرکس DP کی ابتدا کرتا ہے ، جہاں M اور N بالترتیب S1 اور S2 کی لمبائی ہیں۔اس کے بعد میٹرکس کی پہلی قطار اور کالم کو خالی سابقہ اور دو ڈوروں کے سابقہوں کے درمیان فاصلوں کے ساتھ شروع کیا جاتا ہے۔اس کے بعد مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے میٹرکس میں باقی جوڑے اور میٹرکس میں بھرتا ہے۔آخر میں ، فنکشن میٹرکس کے نیچے دائیں کونے میں قدر لوٹاتا ہے۔ لیونشٹین_ڈسٹنس () فنکشن کا ایک مثال استعمال: ازگر 1 = \"بلی کاٹن\" S2 = \"بیٹھے\" پرنٹ (لیونشٹین_ڈسٹنس (S1 ، S2)) # پرنٹس 3 اناس مثال کے طور پر ، ہم لیونشٹین_ڈسٹنس () فنکشن کا استعمال کرتے ہوئے \"بلی کے بچے\" اور \"بیٹھے\" کے درمیان لیونشٹین فاصلے کا حساب لگاتے ہیں۔فنکشن 3 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ \"بلی کے بچے\" کو \"بیٹھنے\" میں تبدیل کرنے کے لئے کم سے کم تعداد میں تبدیلی کی ضرورت ہے۔"
    },
    {
        "Question": "\"وقفہ کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور وقفوں کو موثر انداز میں داخل کرنے ، تلاش کرنے اور دور کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": ""
    },
    {
        "Question": "اس رکاوٹ کے ساتھ کسی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں کہ سبری میں کوئی تین عناصر لگاتار نہیں ہیں۔",
        "Answer": "اس رکاوٹ کے ساتھ کسی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے کہ سبری میں کوئی تین عناصر لگاتار نہیں ہیں ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم نتیجہ تلاش کرنے کے لئے ان پٹ سرنی کی طرح ایک ہی سائز کے معاون سرنی کا مجموعہ برقرار رکھ سکتے ہیں۔رقم [i] سبری ارا [0..i] کے نتائج کو اسٹور کرتی ہے ، یعنی سبری آر آر میں زیادہ سے زیادہ ممکنہ رقم [0..i] اس طرح کہ کوئی تین عناصر لگاتار نہیں ہوتے ہیں۔ہم مندرجہ ذیل تکرار کے تعلق کو رقم بھرنے کے ل use استعمال کرسکتے ہیں: رقم [i] = زیادہ سے زیادہ (رقم [i-1] ، رقم [i-2] + arr [i] ، رقم [i-3] + arr [i [i] + آر آر [I-1]) اس رکاوٹ کے ساتھ ایک سبری کا زیادہ سے زیادہ مجموعہ کہ سبری میں کوئی تین عناصر لگاتار نہیں ہیں ، مجموعی طور پر زیادہ سے زیادہ قیمت ہے۔ یہاں ازگر میں اس نقطہ نظر کا نفاذ: پائیٹھنڈف میکس_سم_سوبری (نمبر): n = len (nums) اگر n == 0: واپس 0 اگر n == 1: واپسی نمبر [0] اگر n == 2: واپس زیادہ سے زیادہ (نمبر [0] ، نمبر [1]) رقم = [0]* n رقم [0] = نمبر [0] رقم [1] = زیادہ سے زیادہ (نمبر [0] ، نمبر [1]) رقم [2] = زیادہ سے زیادہ (نمبر [0] + نمبر [2] ، نمبر [1] ،نمبر [2]) I میں I (3 ، n) کے لئے: رقم [i] = زیادہ سے زیادہ (رقم [i-1] ، رقم [i-2] + نمبر [i] ، رقم [i-3] + نمبر [i] + nums [I-1]) اس نفاذ میں زیادہ سے زیادہ (رقم) کی واپسی ، فنکشن میکس_سم_سوبری () ان پٹ کے طور پر انٹیجر نمبروں کی ایک فہرست لیتا ہے اور اس کی تشکیل کے ساتھ ایک سب سے زیادہ سے زیادہ کا مجموعہ واپس کرتا ہے کہ سبارے میں تین عناصر کوئی بھی عناصر نہیں ہے۔لگاتار ہیں۔فنکشن سب سے پہلے ان پٹ سرنی کی طرح ایک ہی سائز کے معاون سرنی مجموعہ کی ابتدا کرتا ہے۔اس کے بعد یہ مذکورہ بالا تکرار کے رشتے کا استعمال کرتے ہوئے مجموعی صف میں بھرتا ہے۔آخر میں ، فنکشن زیادہ سے زیادہ قیمت کو رقم میں واپس کرتا ہے۔ یہاں میکس_سم_سوبری () فنکشن کا ایک مثال استعمال: پائیٹونومس = [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8] پرنٹ (میکس_سم_سوبری (نمبر))# پرنٹس 27 ان مثال کے طور پر ، ہمیں اس رکاوٹ کے ساتھ ایک سبری کا زیادہ سے زیادہ مجموعہ ملتا ہے کہ سبری میں کوئی تین عناصر لگاتار فہرست میں نہیں ہیں [1] [2] [3] [4] [4] [5] [6] میکس_سم_سوبری کا استعمال کرتے ہوئے() فنکشنفنکشن 27 لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ سبری کا زیادہ سے زیادہ مجموعہ 27 ہے ، جو سبری سے حاصل کیا جاتا ہے [1] [3] [5]"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر بٹ وائز آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کسی دیئے گئے نمبر میں بٹ وائز آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے ، ہم بائنری نمبروں کی مندرجہ ذیل پراپرٹی کو استعمال کرسکتے ہیں جو دو کے اختیارات ہیں: ان کی بائنری نمائندگی میں ان کا صرف ایک سیٹ تھوڑا سا ہے۔ہم اس پراپرٹی کو یہ چیک کرنے کے لئے استعمال کرسکتے ہیں کہ آیا اس کی ثنائی نمائندگی میں سیٹ بٹس کی تعداد گن کر کوئی نمبر دو کی طاقت ہے۔اگر گنتی 1 ہے تو ، نمبر دو کی طاقت ہے۔تاہم ، اس نقطہ نظر کو مسئلہ حل کرنے میں O (لاگ این) وقت لگتا ہے۔ہم بٹ وائز آپریشنز کا استعمال کرتے ہوئے O (1) میں وقت کی پیچیدگی کو بہتر بنا سکتے ہیں۔ یہ چیک کرنے کے لئے کہ آیا کوئی نمبر بٹ وائس آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے یا نہیں ، ہم مندرجہ ذیل مشاہدے کو استعمال کرسکتے ہیں: اگر کوئی نمبر دو کی طاقت ہے تو ، اس کی بائنری نمائندگی صرف ہے۔ایک سیٹ بٹمثال کے طور پر ، 8 کی بائنری نمائندگی 1000 ہے ، جس میں صرف ایک سیٹ بٹ ہے۔ہم اس مشاہدے کو یہ چیک کرنے کے لئے استعمال کرسکتے ہیں کہ آیا کوئی نمبر بٹ وائز اور آپریٹر کا استعمال کرتے ہوئے دو کی طاقت ہے۔ اگر ہم دو کی طاقت سے 1 کو گھٹاتے ہیں تو ، ہمیں ایک نمبر مل جاتا ہے جس میں سیٹ بٹ پلٹ جانے کے دائیں طرف کے تمام ٹکڑے ہوتے ہیں۔مثال کے طور پر ، اگر ہم 8 سے 1 کو گھٹاتے ہیں تو ، ہمیں 7 مل جاتا ہے ، جس کی بائنری نمائندگی 0111 ہے۔ اگر ہم بٹ وائز اور دو اور اس کے پیشرو کی طاقت لیتے ہیں تو ، ہمیں 0 مل جاتا ہے۔ مثال کے طور پر ، اگر ہم بٹ وائز اور 8 سے لیں۔اور 7 ، ہمیں 0 مل جاتا ہے۔ اگر کوئی نمبر دو کی طاقت نہیں ہے تو ، اس کی ثنائی نمائندگی میں ایک سے زیادہ سیٹ بٹ ہے۔مثال کے طور پر ، 6 کی بائنری نمائندگی 0110 ہے ، جس میں دو سیٹ بٹس ہیں۔اگر ہم بٹ وائز اور 6 اور 5 کے لیتے ہیں تو ، ہمیں غیر صفر کی قیمت مل جاتی ہے۔ ازگر میں اس نقطہ نظر کا نفاذ ہے: پائیتھنڈف آئی ایس_ پاور_ف_ٹیو (این): واپسی n> 0 اور (n & (n - 1)) ==0 اس نفاذ میں ، فنکشن IS_POWER_OF_TWO () ان پٹ کے طور پر ایک عدد N لیتا ہے اور اگر N دو اور جھوٹی کی طاقت ہے تو وہ سچ واپس آجاتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے اگر n مثبت ہے۔اگر یہ مثبت نہیں ہے تو ، فنکشن غلط لوٹاتا ہے۔اگر ن مثبت ہے تو ، فنکشن بٹ وائز اور N اور اس کے پیشرو N-1 لیتا ہے۔اگر نتیجہ 0 ہے تو ، فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ N دو کی طاقت ہے۔بصورت دیگر ، فنکشن غلط لوٹاتا ہے۔ IS_POWER_OF_TWO () فنکشن کی مثال کے طور پر استعمال: Pythonn = 8 پرنٹ (is_power_of_two (n)) # پرنٹس اس مثال کے طور پر ، ہم چیک کرتے ہیں کہ آیا نمبر 8 IS_POWER_OF_TWO () فنکشن کا استعمال کرتے ہوئے دو کی طاقت ہے یا نہیں۔فنکشن درست لوٹتا ہے ، اس بات کی نشاندہی کرتا ہے کہ 8 دو کی طاقت ہے۔"
    },
    {
        "Question": "\"کڈانے کے الگورتھم کا استعمال کرتے ہوئے دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے لئے ایک پروگرام لکھیں ، اس رکاوٹ کے ساتھ کہ سبری میں سرکلر صف کے ہر نصف حصے سے کم از کم ایک عنصر ہونا ضروری ہے۔\"",
        "Answer": "کڈانے کے الگورتھم کا استعمال کرتے ہوئے دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے ل the ، اس رکاوٹ کے ساتھ کہ سبری کو سرکلر سرنی کے ہر نصف حصے سے کم از کم ایک عنصر ہونا ضروری ہے ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: کڈانے کے الگورتھم کا استعمال کرتے ہوئے زیادہ سے زیادہ رقم سبری کو تلاش کریں۔دیئے گئے سرنی کے لئے کدانے کے الگورتھم کا استعمال کرتے ہوئے دی گئی سرنی کے لئے۔بصورت دیگر ، زیادہ سے زیادہ رقم واپس کریں۔ اس نقطہ نظر کے پیچھے خیال یہ ہے کہ زیادہ سے زیادہ رقم سبری یا تو ایک سبری ہوسکتی ہے جو سرکلر سرنی کے گرد لپیٹ نہیں لیتی ہے یا سرکلر صف کے گرد لپیٹنے والا سب اری۔اگر زیادہ سے زیادہ رقم سبری سرکلر سرنی کے گرد لپیٹ نہیں لیتی ہے تو ، ہم اسے تلاش کرنے کے لئے کڈانے کے الگورتھم کا استعمال کرسکتے ہیں۔اگر"
    }
]