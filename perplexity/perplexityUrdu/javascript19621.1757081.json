[
    {
        "Question": "ٹائپ اسکرپٹ میں لنکڈ فہرست کا استعمال کرتے ہوئے اسٹیک کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں لنکڈ فہرست کا استعمال کرتے ہوئے اسٹیک کو نافذ کرنے کے ل we ، ہم ایک نوڈ کلاس کی وضاحت کرسکتے ہیں جو منسلک فہرست میں نوڈ کی نمائندگی کرتا ہے ، اور اسٹیک کلاس جو اسٹیک کو نافذ کرنے کے لئے اس نوڈ کلاس کا استعمال کرتا ہے۔اسٹیک کلاس میں ایک اعلی وصف ہونا چاہئے جو اسٹیک کے اوپری حصے کی طرف اشارہ کرتا ہے (یعنی لنکڈ فہرست میں پہلا نوڈ)۔کسی شے کو اسٹیک پر دھکیلنے کے ل we ، ہم دیئے گئے آئٹم کے ساتھ ایک نیا نوڈ تیار کرتے ہیں اور اس کا اگلا پوائنٹر اسٹیک کے موجودہ اوپر پر سیٹ کرتے ہیں۔اس کے بعد ہم نے اسٹیک کے اوپری حصے کو نئے نوڈ پر سیٹ کیا ، اور اسے مؤثر طریقے سے اسٹیک کا نیا اوپر بنا دیا۔کسی آئٹم کو اسٹیک سے پاپ کرنے کے ل we ، ہم لسٹ میں اگلے نوڈ پر اسٹیک کے اوپری حصے کو ترتیب دے کر لنکڈ لسٹ سے پہلا نوڈ نکال دیتے ہیں (یعنی ، نوڈ نے موجودہ اوپر کی طرف اشارہ کیا ہے) 1. ہر ایک مثال کے طور پر عمل درآمدٹائپ اسکرپٹ میں لنکڈ فہرست کا استعمال کرتے ہوئے اسٹیک کی: ٹائپ اسکرپٹ کلاس نوڈ <t> {ڈیٹا: ٹی ؛اگلا: نوڈ <t> |خالی؛کنسٹرکٹر (ڈیٹا: ٹی) {this.data = ڈیٹا ؛this.next = null ؛}} کلاس اسٹیک <t> {اوپر: نوڈ <t> |خالی؛کنسٹرکٹر () {this.top = null ؛} پش (ڈیٹا: ٹی): باطل {کانسٹ نوڈ = نیا نوڈ (ڈیٹا) ؛node.next = this.top ؛this.top = نوڈ ؛} پاپ (): ٹی |null {if (! this.top) {واپس NULL ؛} کانس ڈیٹا = this.top.data ؛this.top = this.top.next ؛ڈیٹا ڈیٹا ؛} جھانکنے (): t |null {if (! this.top) {واپس NULL ؛this اس کو واپس کریں۔} isempty (): بولین {اس کو واپس کریں۔ ٹاپ === null ؛} سائز (): نمبر {آئیے گنتی = 0 ؛آئیے موجودہ = this.top ؛جبکہ (موجودہ) {گنتی ++ ؛موجودہ = موجودہ۔ نیکسٹ ؛} واپسی کی گنتی ؛}} // مثال کے طور پر USEAGECONST اسٹیک = نیا اسٹیک <نمبر> () ؛ اسٹیک.پش (1) ؛ اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛ کنسول.لوگ (اسٹیک.پپ ()) ؛// 3console.log (stack.peek ()) ؛// 2console.log (stack.isempty ()) ؛// falseconsole.log (stack.size ()) ؛// 2 میں اس مثال کے طور پر ، ہم ایک نوڈ کلاس کی وضاحت کرتے ہیں جس میں ڈیٹا وصف اور اگلی وصف ہے جو لنکڈ فہرست میں اگلے نوڈ کی طرف اشارہ کرتا ہے۔ہم ایک اسٹیک کلاس کی بھی وضاحت کرتے ہیں جس میں ایک ٹاپ وصف ہوتا ہے جو اسٹیک کے اوپری حصے کی طرف اشارہ کرتا ہے۔پش () کا طریقہ دیئے گئے اعداد و شمار کے ساتھ ایک نیا نوڈ تیار کرتا ہے اور اس کا اگلا پوائنٹر اسٹیک کے موجودہ اوپری حصے پر سیٹ کرتا ہے۔پاپ () کا طریقہ اسٹیک سے اوپر والے نوڈ کو ہٹا دیتا ہے اور اس کا ڈیٹا لوٹاتا ہے۔جھانکنے والا () طریقہ اوپر نوڈ کا ڈیٹا اسے ہٹائے بغیر لوٹاتا ہے۔اگر اسٹیک خالی ہے تو isempty () کا طریقہ چیک کرتا ہے۔سائز () کا طریقہ اسٹیک میں نوڈس کی تعداد لوٹاتا ہے۔آخر میں ، ہم ایک نیا اسٹیک مثال تیار کرتے ہیں ، اس پر کچھ اقدار کو آگے بڑھاتے ہیں ، اور اس کی فعالیت کو ظاہر کرنے کے لئے اس کے کچھ طریقوں کو کال کرتے ہیں۔"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ آیا بائنری کا درخت ٹائپ اسکرپٹ میں متوازن بائنری سرچ ٹری ہے یا نہیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا بائنری کا درخت ٹائپ اسکرپٹ میں متوازن بائنری سرچ درخت ہے ، ہمیں یہ چیک کرنے کی ضرورت ہے کہ آیا کسی بھی نوڈ پر بائیں اور دائیں سبٹری کی اونچائی کے درمیان مطلق فرق 1 سے کم یا اس کے برابر ہے ، اور اگر دونوں بائیں اور دونوں کے برابر ہے۔دائیں سبٹریز خود متوازن بائنری درخت ہیں۔ اس پر عمل درآمد کرنے کا ایک طریقہ یہ ہے کہ ایک بار بار چلنے والی تقریب کی وضاحت کی جائے جو نوڈ کو ایک دلیل کے طور پر لیتا ہے اور اس نوڈ پر جڑے ہوئے سب ٹری کی اونچائی کو لوٹاتا ہے۔فنکشن کو پہلے یہ چیک کرنا چاہئے کہ آیا نوڈ کالعدم ہے ، اس صورت میں اونچائی 0 ہے۔ بصورت دیگر ، اسے بائیں اور دائیں سب ٹریوں کی اونچائیوں کی بار بار گنتی کرنی چاہئے ، اور چیک کرنا چاہئے کہ وہ متوازن ہیں اور ان کا مطلق فرق کم یا اس کے برابر ہے یا اس کے برابر ہے یا نہیں۔1. اگر دونوں ذیلی ذیلی متوازن ہیں تو ، فنکشن کو موجودہ نوڈ پر جڑی ہوئی سب ٹری کی اونچائی کو واپس کرنا چاہئے ، جو اس کے بائیں اور دائیں سب ٹریوں کی اونچائیوں کی زیادہ سے زیادہ ہے۔1 اس بات کی نشاندہی کرنے کے لئے کہ پورا درخت غیر متوازن ہے۔ یہاں کسی فنکشن کی ایک مثال کے نفاذ کا تعین کرنے کے لئے کہ آیا بائنری درخت ٹائپ اسکرپٹ میں متوازن بائنری تلاش کا درخت ہے: ٹائپ اسکرپٹ کلاس ٹرینیوڈ <t> {ویل: ٹی ؛بائیں: Treenode <T> |خالی؛دائیں: ٹرینوڈ <t> |خالی؛کنسٹرکٹر (ویل: ٹی) {this.val = ویل ؛this.left = null ؛this.right = null ؛}} فنکشن isbalanced (جڑ: ٹرینوڈ <کوئی بھی> | null): بولین {فنکشن گیٹھائٹ (نوڈ: ٹرینوڈ <کوئی بھی> | null): نمبر {اگر (! نوڈ) {واپس 0 ؛} کونسٹ لیفٹ ہائٹ = getheight (node.left) ؛کانسٹ رائٹ ہائٹ = گیٹھائٹ (نوڈ. رائٹ) ؛if (liftheight === -1 || rightight === -1 || math.abs (liftheight -rightight)> 1) {واپسی -1 ؛math ریاضی کی واپسی۔ میکس (لیف لائٹ ، رائٹ ہائٹ) + 1 ؛get گیٹ ہائٹ (جڑ)! == -1 ؛} اس مثال میں ، ہم ایک ویل وصف اور بائیں اور دائیں صفات کے ساتھ ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بالترتیب بائیں اور دائیں بچوں کے نوڈس کی طرف اشارہ کرتے ہیں۔ہم ایک متوازن فنکشن کی بھی وضاحت کرتے ہیں جو ٹرینوڈ مثال کے طور پر ایک دلیل کے طور پر لیتا ہے اور ایک بولین کو لوٹاتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا اس نوڈ پر جڑا ہوا درخت متوازن بائنری تلاش کا درخت ہے۔آئی ایس بیلنس فنکشن ایک گھونسلے والے گیٹ نائٹ فنکشن کو کہتے ہیں جو ایک دلیل کے طور پر ٹرینوڈ مثال لیتا ہے اور اس نوڈ پر جڑی ہوئی سب ٹری کی اونچائی کو لوٹاتا ہے ، یا اگر سب ٹری غیر متوازن ہے۔جیٹ لائٹ فنکشن پہلے جانچ پڑتال کرتا ہے اگر نوڈ کالعدم ہے ، اس صورت میں اونچائی 0 ہے۔ بصورت دیگر ، یہ بار بار بائیں اور دائیں سبٹریز کی اونچائیوں کی گنتی کرتا ہے ، اور چیک کرتا ہے کہ آیا وہ متوازن ہیں اور ان کا مطلق فرق 1 سے کم یا اس کے برابر ہے یا اس کے برابر ہے۔. اگر دونوں ذیلی ذیلی متوازن ہیں تو ، فنکشن موجودہ نوڈ پر جڑے ہوئے سب ٹری کی اونچائی کو لوٹاتا ہے ، جو اس کے بائیں اور دائیں سب ٹریوں کی اونچائیوں کی زیادہ سے زیادہ ہے۔کہ پورا درخت غیر متوازن ہے۔آخر میں ، اگر روٹ نوڈ کی اونچائی -1 نہیں ہے تو ، isblanced فنکشن درست لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ پورا درخت متوازن ہے ، اور غلط ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو اسٹیکس کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں دو اسٹیکوں کا استعمال کرتے ہوئے قطار کے اعداد و شمار کے ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: دو اسٹیک ، اسٹیک 1 اور اسٹیک 2 بنائیں۔ عنصر کو ختم کرنے کے ل stac ، اسے اسٹیک 1 پر دبائیں۔ عنصر کو ڈی کیوئو کرنے کے ل. ، اگر اسٹیک 2 خالی نہیں ہے تو ، پاپ این کو پاپ کریں۔اسٹیک 2 سے عنصر اور اسے لوٹائیں۔بصورت دیگر ، جبکہ اسٹیک 1 خالی نہیں ہے ، اسٹیک 1 سے کسی عنصر کو پاپ کریں اور اسے اسٹیک 2 پر دبائیں۔پھر اسٹیک 2 سے کسی عنصر کو پاپ کریں اور اسے واپس کردیں۔ یہاں ٹائپ اسکرپٹ میں دو اسٹیکوں کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کلاس قطار <t> {نجی اسٹیک 1: ٹی [] = [] ؛نجی اسٹیک 2: t [] = [] ؛enqueue (آئٹم: t): باطل {this.stack1.push (آئٹم) ؛} dequeue (): t |غیر متعینہ {اگر (this.stack2.length === 0) {جبکہ (this.stack1.length> 0) {this.stack2.push (this.stack1.pop ()!) ؛}} this.stack2.pop () واپس کریں ؛} سائز (): نمبر {اس کو واپس کریں۔ اسٹیک 1.length + this.stack2.length ؛} isempty (): بولین {اس کو واپس کریں۔ سائز () === 0 ؛}} // مثال کے طور پر usageconst قطار = نئی قطار <نمبر> () ؛ قطار۔ enqueue (1) ؛ قطار۔ enqueue (2) ؛ قطار. enqueue (3) ؛ کنسول.لوگ (قطار.Dequeue ()) ؛// 1console.log (قطار.Dequeue ()) ؛// 2console.log (قطار۔ آئیسٹی ()) ؛// falseconsole.log (قطار. سائز ()) ؛// 1 میں یہ مثال ، ہم دو نجی اسٹیک ، اسٹیک 1 اور اسٹیک 2 کے ساتھ ایک قطار کلاس کی وضاحت کرتے ہیں۔Enqueue () کا طریقہ کسی شے کو اسٹیک 1 پر دھکیل دیتا ہے۔ڈیکیو () کا طریقہ چیک کرتا ہے کہ اگر اسٹیک 2 خالی نہیں ہے ، اور اگر ایسا ہے تو ، اسٹیک 2 سے عنصر کو پاپ کرتا ہے اور اسے لوٹاتا ہے۔بصورت دیگر ، یہ اسٹیک 1 سے تمام عناصر کو پاپ کرتا ہے اور انہیں اسٹیک 2 پر دھکیل دیتا ہے ، اور پھر اسٹیک 2 سے عنصر کو پاپ کرتا ہے اور اسے لوٹاتا ہے۔سائز () کا طریقہ قطار میں موجود عناصر کی کل تعداد لوٹاتا ہے ، جو اسٹیک 1 اور اسٹیک 2 کی لمبائی کا مجموعہ ہے۔isempty () طریقہ چیک کرتا ہے کہ آیا قطار خالی ہے یا نہیں جانچ کر کے کہ آیا اس کا سائز 0 ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے سٹرنگ میں الفاظ کی ترتیب کو الٹا کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تار میں الفاظ کی ترتیب کو پلٹانے کے ل we ، ہم تار کو الفاظ کی صف میں تقسیم کرنے کے لئے اسپلٹ () کا طریقہ استعمال کرسکتے ہیں ، پھر صف میں الفاظ کی ترتیب کو الٹ کرنے کے لئے الٹ () طریقہ استعمال کرسکتے ہیں ، اور آخر میںالفاظ کو سٹرنگ 12 میں شامل کرنے کے لئے جوائن () کا طریقہ استعمال کریں۔('') ؛الفاظ کی واپسی۔فنکشن سب سے پہلے ان پٹ سٹرنگ کو الفاظ کی ایک صف میں تقسیم کرتا ہے جس میں اسپلٹ () کے طریقہ کار کو کسی جگہ کے ساتھ ڈیمیمٹر کی حیثیت سے استعمال کیا جاتا ہے۔اس کے بعد یہ الٹ () طریقہ کار کا استعمال کرتے ہوئے صف میں الفاظ کی ترتیب کو تبدیل کرتا ہے ، اور آخر کار الفاظ کو ایک جگہ کے ساتھ جوائن () کے طریقہ کار کا استعمال کرتے ہوئے سٹرنگ میں شامل کرتا ہے۔ یہاں ریورسورڈز فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹstr = 'ہیلو ورلڈ' ؛ کانسٹ الٹ = ریورسورڈز (str) ؛ کنسول.لوگ (الٹ) ؛// 'ورلڈ ہیلو' اس مثال کے طور پر ، ہم 'ہیلو ورلڈ' کی قدر کے ساتھ ایک نیا سٹرنگ STR تیار کرتے ہیں۔اس کے بعد ہم STR کے ساتھ ریورسورڈز فنکشن کو دلیل کے طور پر کہتے ہیں اور نتیجہ کو ایک نئے متغیر کو الٹ دیتے ہیں۔آخر میں ، ہم کنسول میں الٹ کی قیمت کو لاگ ان کرتے ہیں ، جو 'ورلڈ ہیلو' ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک کم سے کم میکس ہیپ ڈیٹا ڈھانچہ نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں کم سے کم میکس ہیپ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے بہت سارے وسائل دستیاب ہیں۔ایک نقطہ نظر بائنری ہیپ کا استعمال کرنا ہے ، جو درختوں کی طرح کا ڈیٹا ڈھانچہ ہے جو ہیپ پراپرٹی 1 کو مطمئن کرتا ہے۔بائنری ہیپ کو ایک صف کے طور پر نافذ کیا جاسکتا ہے ، جہاں درخت کی جڑ انڈیکس 0 پر ہے ، اور انڈیکس I میں نوڈ کے بائیں اور دائیں بچے بالترتیب 2i+1 اور 2i+2 انڈیکس میں ہیں۔ ایک منٹ کو نافذ کرنے کے لئے۔-میکس ہیپ ، ہم ڈھیر کے کم سے کم اور زیادہ سے زیادہ عناصر کو ذخیرہ کرنے کے لئے بائنری ہیپ سرنی کا استعمال کرسکتے ہیں۔خاص طور پر ، ہم سرنی (1 ، 3 ، 5 ، وغیرہ) کے عجیب اشارے میں کم سے کم عناصر اور سرنی (0 ، 2 ، 4 ، 4 ، وغیرہ) کے یہاں تک کہ زیادہ سے زیادہ عناصر کو اسٹور کرسکتے ہیں۔اس سے ہمیں ڈھیر کے کم سے کم اور زیادہ سے زیادہ عناصر دونوں کو موثر انداز میں رسائی حاصل کرنے اور اینٹریشنز اور ڈیلیٹ 2 کے دوران ضرورت کے مطابق عناصر کو تبدیل کرکے ہیپ پراپرٹی کو برقرار رکھنے کی اجازت ملتی ہے۔ یہاں بائنری ہیپ سرنی کا استعمال کرتے ہوئے ایک کم میکس ہیپ ڈیٹا ڈھانچے کا ایک مثال عمل ہے۔ٹائپ اسکرپٹ: ٹائپ اسکرپٹ کلاس من میک ہاپ <t> {نجی ہیپ: ٹی [] = [] ؛نجی getParentIndex (انڈیکس: نمبر): نمبر {ریٹرن میتھ.فلور ((انڈیکس - 1) / 2) ؛} نجی getMinChildIndex (انڈیکس: نمبر): نمبر {کانسٹیٹ لیفٹائلڈ انڈیکس = 2 * انڈیکس + 1 ؛کونٹ رائٹچلڈ انڈیکس = 2 * انڈیکس + 2 ؛اگر (بائیں طرف سے index> = this.heap.length) {واپسی -1 ؛} اگر (رائٹچلڈ انڈیکس> = this.heap.length) {واپس بائیں طرف کینڈیکس ؛this اس کو واپس کریں۔لیفٹائڈائڈ انڈیکس: دائیں بچے کی انڈیکس ؛} نجی گیٹ میکسچلڈ انڈیکس (انڈیکس: نمبر): نمبر {کونٹ لیفٹائڈ انڈیکس = 2 * انڈیکس + 1 ؛کونٹ رائٹچلڈ انڈیکس = 2 * انڈیکس + 2 ؛اگر (بائیں طرف سے index> = this.heap.length) {واپسی -1 ؛} اگر (رائٹچلڈ انڈیکس> = this.heap.length) {واپس بائیں طرف کینڈیکس ؛this اس کو واپس کریں۔لیفٹائڈائڈ انڈیکس: دائیں بچے کی انڈیکس ؛} نجی بلبلاپ (انڈیکس: نمبر): باطل {const isminlevel = math.floor (math.log2 (انڈیکس + 1)) ٪ 2 === 0 ؛if (index === 0 ||this.getParentIndex (انڈیکس)])) {واپسی ؛} CONT پیرنٹ انڈیکس = this.getParentIndex (انڈیکس) ؛const temp = this.heap [انڈیکس] ؛this.heap [index] = this.heap [پیرنٹ انڈیکس] ؛this.heap [parentindex] = عارضی ؛this.bbbleup (پیرنٹ انڈیکس) ؛} نجی بلبلیڈاؤن (انڈیکس: نمبر): باطل {کانسٹ isminlevel = math.floor (math.log2 (index + 1)) ٪ 2 === 0 ؛Const MinChildIndex = this.getminchildindex (انڈیکس) ؛کانسٹ میکسچلڈ انڈیکس = this.getMaxChild index (انڈیکس) ؛if (mindidedex === -1) {واپسی ؛target ٹارگٹائڈائڈ انڈیکس = منیچلڈ انڈیکس دیں ؛اگر (! isminlevel && میکسچلڈ انڈیکس! == -1 && اس میں۔} if ((isminlevel && this.heap [index] <= this.heap [targetchildindex])} const temp = this.heap [انڈیکس] ؛this.heap [index] = this.heap [ٹارگٹائڈائڈ انڈیکس] ؛this.heap [targetChildindex] = عارضی ؛this.bubbledown (ٹارگٹچلڈ انڈیکس) ؛} داخل کریں (آئٹم: ٹی): باطل {this.heap.push (آئٹم) ؛this.bubbleup (this.heap.length - 1) ؛} ڈیلیٹیمین (): ٹی |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛} const min = this.heap [0] ؛this.heap [0] = this.heap.pop () !؛this.bbbledown (0) ؛واپسی منٹ ؛} ڈیلیٹیمیکس (): ٹی |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛} کانسٹ میکس انڈیکس = this.heap [1]> this.heap [2]؟1: 2 ؛کانسٹ میکس = this.heap [میکس انڈیکس] ؛this.heap [میکس انڈیکس] = this.heap.pop () !؛this.bbbledown (میکس انڈیکس) ؛زیادہ سے زیادہ واپسی ؛} getmin (): t |غیر وضاحتی {اس کو واپس کریں۔this.heap [0]: غیر وضاحتی ؛} getMax (): t |غیر وضاحتی {اس کو واپس کریں۔(this.heap [1]> this.heap [2]؟ this.heap [1]: this.heap [2]): غیر متعینہ ؛} سائز (): نمبر {اس کو واپس کریں۔} isempty (): بولین {اس کو واپس کریں۔ سائز () === 0 ؛}} اس مثال میں ، ہم ایک من میک ہاپ کلاس کی وضاحت کرتے ہیں جس میں نجی ہیپ سرنی ہوتی ہے جو ڈھیر کے عناصر کو محفوظ کرتی ہے۔کلاس ہیپ کے عناصر تک رسائی اور ان میں ہیرا پھیری کرنے کے لئے متعدد نجی مددگار طریقوں کی بھی وضاحت کرتا ہے۔getParentIndex () کا طریقہ کسی دیئے گئے نوڈ کے والدین نوڈ کا انڈیکس لوٹاتا ہے۔getminchildindex () اور getMaxChild index () کے طریقے کسی دیئے گئے نوڈ کے بالترتیب کم سے کم اور زیادہ سے زیادہ چائلڈ نوڈس کا انڈیکس لوٹاتے ہیں۔بلبلاپ () طریقہ کار سے بار بار تبادلہ ہوتا ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو ڈوروں کے مابین سب سے طویل عام حصول تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں دو ڈوروں کے مابین سب سے طویل عام مشترکہ حصول تلاش کرنے کے ل we ، ہم O (Mn) وقت میں مسئلے کو حل کرنے کے لئے متحرک پروگرامنگ کا استعمال کرسکتے ہیں ، جہاں M اور N دونوں اسٹرنگز 12 کی لمبائی ہیں۔بنیادی خیال یہ ہے کہ سائز (M+1) X (n+1) کی دو جہتی صف DP بنانا ہے ، جہاں DP [i] [j] پہلے کے پہلے I حرفوں کے درمیان سب سے طویل عام مشترکہ کی لمبائی کی نمائندگی کرتا ہے۔سٹرنگ اور دوسرے تار کے پہلے جے کردار۔اس کے بعد ہم مندرجہ ذیل تکرار کے رشتے کا استعمال کرتے ہوئے سرنی ڈی پی کو پُر کرسکتے ہیں: ڈی پی [i] [j] = 0 ، اگر i = 0 یا j = 0dp [i] [j] = dp [i-1] [J-1]+ 1 ، اگر S1 [I-1] = S2 [J-1] DP [i] [J] = زیادہ سے زیادہ (DP [I-1] [J] ، DP [I] [J-1]) ، دوسری صورت میں ، دوسری صورت میں ،S1 اور S2 دو ان پٹ ڈور ہیں ، اور زیادہ سے زیادہ () ایک ایسا فنکشن ہے جو اپنے دو دلائل میں سے زیادہ سے زیادہ لوٹاتا ہے۔پہلا معاملہ بیس کیس کی نمائندگی کرتا ہے ، جہاں سب سے طویل عام مشترکہ حصے کی لمبائی 0 ہوتی ہے اگر کوئی تار خالی ہو۔دوسرا معاملہ اس معاملے کی نمائندگی کرتا ہے جہاں دونوں اسٹرنگز کے آخری حروف میچ ہوتے ہیں ، اس معاملے میں ہم سب سے طویل عرصے سے مشترکہ حصول کو 1 تک بڑھا سکتے ہیں۔ تیسرا معاملہ اس معاملے کی نمائندگی کرتا ہے جہاں دونوں ڈوروں کے آخری کردار مماثل نہیں ہوتے ہیں ، جس معاملے میں ہمیں ضرورت ہے۔ایک تار کے آخری کردار کے ساتھ دو ڈوروں کے سب سے طویل عرصے سے عام حصول کی لمبائی کا زیادہ سے زیادہ انتخاب کرنے کے لئے۔ ایک بار ہم نے ڈی پی سرنی میں بھر دیا ہے ، ہم ڈی پی [ایم] [این سے شروع کرکے سب سے طویل مشترکہ حصول کی تشکیل نو کرسکتے ہیں۔] اور سرنی میں زیادہ سے زیادہ اقدار کے راستے پر چلتے ہوئے ، تکرار کے رشتے کا استعمال کرتے ہوئے: اگر S1 [I-1] = S2 [J-1] ، S1 [I-1] کو نتیجہ میں شامل کریں اور اخترتی طور پر ڈی پی میں منتقل کریں [I-1] [J-1] بصورت دیگر ، زیادہ سے زیادہ قیمت کے ساتھ ملحقہ سیل میں جائیں: اگر DP [I-1] [j]> DP [I] [J-1] ، DP پر جائیں [I-1] [J] ، بصورت دیگر ڈی پی [i] [J-1] میں جائیں کہ ٹائپ اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے دو تاروں کے درمیان طویل ترین مشترکہ حصول تلاش کرنے کے لئے یہاں ایک فنکشن کا نفاذ ہے: ٹائپ اسکرپٹ فنکشن سب سے طویل عرصے سے کامنسوبسینس (S1: سٹرنگ ، سٹرنگ): سٹرنگ {Const M = S1.length ؛const n = s2.length ؛کانسٹ ڈی پی: نمبر [] [] = نئی سرنی (ایم + 1)کے لئے (i = 1 ؛ i <= m ؛ i ++) {for (j = 1 ؛ j <= n ؛ j ++) {اگر (s1 [i-1] === s2 [j-1]) {dp[i] [j] = dp [i-1] [J-1] + 1 ؛} else {dp [i] [j] = math.max (dp [i-1] [j] ، dp [i] [j-1]) ؛}}} آئیے i = m ؛j = n ؛کانسٹنگ نتیجہ: سٹرنگ [] = [] ؛جبکہ (i> 0 && j> 0) {اگر (S1 [I-1] === S2 [J-1]) {نتیجہ۔ انشفٹ (S1 [I-1]) ؛میں--؛J-- ؛} ورنہ اگر (dp [i-1] [j]> dp [i] [j-1]) {i-- ؛} else {j-- ؛}} واپسی کا نتیجہ۔ join ('') ؛} اس مثال میں ، ہم ایک طویل عرصے سے کامنسوبسنس فنکشن کی وضاحت کرتے ہیں جو دو ڈوروں کو دلائل کے طور پر لیتا ہے اور دونوں ڈوروں کے مابین سب سے طویل عرصے سے عام طور پر پیش آنے والی ایک تار کو لوٹاتا ہے۔فنکشن سب سے پہلے سائز (M+1) X (N+1) کے دو جہتی سرنی DP کی ابتدا کرتا ہے ، جہاں M اور N دونوں تار کی لمبائی ہیں ، اور متحرک پروگرامنگ تکرار کے تعلقات کا استعمال کرتے ہوئے صف میں بھرتی ہیں۔اس کے بعد یہ ڈی پی سرنی میں زیادہ سے زیادہ اقدار کی راہ پر عمل کرتے ہوئے سب سے طویل عام مشترکہ حصول کی تشکیل نو کرتا ہے ، اور نتیجہ کو تار کے طور پر لوٹاتا ہے۔ یہاں طویل عرصے سے کامنسوبسنس فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ S1 = 'ABCDGH' ؛ Const S2 = 'aedfhr' ؛CONST LCS = longestcommonsubsence (S1 ، S2) ؛ کنسول.لوگ (LCS) ؛// 'اس مثال کے طور پر ، ہم بالترتیب' ABCDGH 'اور' AEDFHR 'اقدار کے ساتھ دو نئے تار S1 اور S2 تیار کرتے ہیں۔اس کے بعد ہم S1 اور S2 کے ساتھ طویل ترین کامنسوبسنس فنکشن کو دلائل کے طور پر کہتے ہیں اور نتیجہ کو ایک نئے متغیر LCs کو تفویض کرتے ہیں۔آخر میں ، ہم LCS کی قیمت کو کنسول پر لاگ ان کریں ، جو 'adh'.1leetcode2geeksforgeeks ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ڈجکسٹرا کے مختصر ترین راستے الگورتھم کو نافذ کریں۔",
        "Answer": "گراف میں نوڈس کے مابین مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کا الگورتھم ایک مقبول الگورتھم ہے۔ٹائپ اسکرپٹ میں ڈجکسٹرا کے الگورتھم کو نافذ کرنے کے لئے بہت سے وسائل دستیاب ہیں۔یہاں کچھ مثالیں ہیں: سیرجیگالکوسکی/ڈجکسٹررا ایس-ایلگوریتھم-نفاذ کی قسم کی اسکرپٹ-یہ ایک گٹ ہب ریپوزٹری ہے جس میں ٹائپ اسکرپٹ میں ڈجکسٹرا کے الگورتھم کا نفاذ ہوتا ہے۔اس پر عمل درآمد اگلے نوڈ کو دیکھنے کے لئے موثر انداز میں تلاش کرنے کے لئے ترجیحی قطار کا استعمال کرتا ہے ، اور نوڈس کی ایک صف کو واپس کرتا ہے جس میں شروع اور اختتامی نوڈس کے درمیان مختصر ترین راستے کی نمائندگی ہوتی ہے۔ٹائپ اسکرپٹ میں۔عمل درآمد کے لئے اگلے نوڈ کو موثر انداز میں تلاش کرنے کے لئے ایک ہیپ ڈیٹا ڈھانچے کا استعمال کرتا ہے ، اور شروع اور اختتامی نوڈس کے مابین مختصر ترین راستے کی نمائندگی کرنے والی کسی شے کو واپس کرتا ہے۔ جاوا اسکرپٹ میں مختصر ترین راہ پر عمل کرنا: ڈجکسٹرا کا الگورتھم - یہ ایک ایسا بلاگ پوسٹ ہے جس میں یہ بتایا گیا ہے کہ کس طرح کی بات ہے۔جاوا اسکرپٹ میں ڈجکسٹرا کے الگورتھم کو نافذ کریں ، لیکن کوڈ کو آسانی سے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔اس عمل میں گراف میں ہر نوڈ سے لے کر فاصلے پر نظر رکھنے کے لئے ہیش ٹیبل کا استعمال کیا گیا ہے ، اور اگلی نوڈ کو دیکھنے کے لئے موثر انداز میں تلاش کرنے کے لئے ترجیحی قطار اور ترجیحی قطار۔فنکشن ایک شے لوٹتا ہے جو شروع اور اختتامی نوڈس کے درمیان مختصر ترین راستے کی نمائندگی کرتا ہے۔ جاوا اسکرپٹ میں ڈیجکسٹرا کا الگورتھم |ریجینا فرنس کے ذریعہ - یہ ایک اور بلاگ پوسٹ ہے جس میں یہ بتایا گیا ہے کہ جاوا اسکرپٹ میں ڈیجکسٹرا کے الگورتھم کو کیسے نافذ کیا جائے ، لیکن اس کوڈ کو ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔عمل درآمد اگلے نوڈ کو دیکھنے کے لئے موثر انداز میں تلاش کرنے کے لئے ترجیحی قطار کا استعمال کرتا ہے ، اور اسٹارٹ اور اینڈ نوڈس کے مابین مختصر ترین راستے کی نمائندگی کرنے والی کسی شے کو واپس کرتا ہے۔ٹائپ اسکرپٹ۔اس پر عمل درآمد اگلے نوڈ کو دیکھنے کے لئے موثر انداز میں تلاش کرنے کے لئے ترجیحی قطار کا استعمال کرتا ہے ، اور شروع اور اختتامی نوڈس کے مابین مختصر ترین راہ کی نمائندگی کرنے والی کسی شے کو واپس کرتا ہے۔ جاوا اسکرپٹ میں ڈجکسٹرا کے الگورتھم کو کس طرح نافذ کرنے کا طریقہ |ہیکرنون - یہ ایک اور بلاگ پوسٹ ہے جس میں یہ بتایا گیا ہے کہ جاوا اسکرپٹ میں ڈیجکسٹرا کے الگورتھم کو کیسے نافذ کیا جائے ، لیکن اس کوڈ کو ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔اس عمل میں گراف میں ہر نوڈ سے لے کر فاصلے پر نظر رکھنے کے لئے ہیش ٹیبل کا استعمال کیا گیا ہے ، اور اگلی نوڈ کو دیکھنے کے لئے موثر انداز میں تلاش کرنے کے لئے ترجیحی قطار اور ترجیحی قطار۔فنکشن ایک ایسی شے کو واپس کرتا ہے جو شروع اور اختتامی نوڈس کے مابین مختصر ترین راستے کی نمائندگی کرتا ہے۔ یہ وسائل ٹائپ اسکرپٹ میں ڈیجکسٹرا کے الگورتھم کو نافذ کرنے کے لئے مختلف نقطہ نظر فراہم کرتے ہیں ، لہذا آپ اس میں سے ایک کا انتخاب کرسکتے ہیں جو آپ کی ضروریات کو بہتر بناتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو ترتیب شدہ صفوں کے میڈین کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں دو ترتیب شدہ صفوں کے درمیانی درجے کی تلاش کے ل several کئی نقطہ نظر ہیں۔یہاں کچھ مثالیں ہیں: انضمام اور ترتیب دیں: ایک نقطہ نظر یہ ہے کہ دونوں ترتیب شدہ صفوں کو ایک ہی ترتیب شدہ صف میں ضم کریں ، اور پھر انضمام شدہ صف کا میڈین تلاش کریں۔یہ دونوں صفوں کو جوڑنے ، نتیجے میں ہونے والی صفوں کو چھانٹ کر ، اور پھر میڈین تلاش کرکے کیا جاسکتا ہے۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ فانکشن فائنڈ میڈیسورٹری (نمبر [نمبر [] ، نمبر [] ، نمبر []): نمبر {cont ضم شدہ = [... nums1 ، ... nums2] .Sort (a ، b) => a - b - b) ؛const n = ضم شدہ۔ لمبائی ؛اگر (n ٪ 2 === 0) {واپسی (ضم شدہ [n/2 - 1] + ضم شدہ [n/2])/2 ؛} دوسری {واپسی ضم شدہ [(N-1)/2] ؛}} اس مثال میں ، ہم ایک فائنڈ میڈیسورٹ ڈریڈری فنکشن کی وضاحت کرتے ہیں جو دو ترتیب شدہ صفوں کو دلائل کے طور پر لیتا ہے اور انضمام شدہ صف کے وسط کو واپس کرتا ہے۔فنکشن سب سے پہلے اسپریڈ آپریٹر (...) کا استعمال کرتے ہوئے دونوں صفوں کو ہم آہنگ کرتا ہے ، جس کے نتیجے میں سرنی کو ایک موازنہ فنکشن کے ساتھ ترتیب دیتے ہیں جو چڑھتے ترتیب میں ترتیب دیتے ہیں ، اور پھر اس کی لمبائی کا استعمال کرتے ہوئے ضم شدہ صف کے وسط کا حساب لگاتے ہیں۔سرنی اور مناسب فارمولا۔ بائنری تلاش: ایک اور نقطہ نظر یہ ہے کہ دو ترتیب شدہ صفوں کے وسط کو تلاش کرنے کے لئے بائنری سرچ کا استعمال کیا جائے۔یہ نقطہ نظر انضمام اور ترتیب کے نقطہ نظر سے زیادہ موثر ہے ، جس میں O (لاگ (کم (منٹ (M ، N))) کی ایک وقت کی پیچیدگی ہے ، جہاں M اور N دونوں صفوں کی لمبائی ہیں۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ فنکشن فائنڈ میڈیسورٹ ڈریڈ (نمبر 1: نمبر [] ، نمبر 2: نمبر []): نمبر {const m = nums1.length ؛const n = nums2.length ؛اگر (m> n) {findMediansortedarrays (nums2 ، nums1) واپس کریں ؛let lo = 0 ؛آئیے ہائے = ایم ؛جبکہ (LO <= HI) {CONST پارٹیشن ایکس = (لو + ہائے) >> 1 ؛const پارٹیشن = ((m + n + 1) >> 1) - پارٹیشنکس ؛کانسٹ میکسلفٹیکس = پارٹیشن ایکس === 0؟-infinity: nums1 [پارٹیشنیکس - 1] ؛کانسٹ مائنرائٹیکس = پارٹیشن ایکس === ایم؟انفینٹی: نمبر 1 [پارٹیشنیکس] ؛کانسٹ میکسلیفٹی = پارٹیشن === 0؟-انفینیٹی: نمبر 2 [پارٹیشن - 1] ؛کانسٹ مائنریٹی = پارٹیشن === این؟انفینٹی: نمبر 2 [پارٹیشن] ؛if (maxleftx <= minrighty && میکسلیفٹی <= minrightx) {اگر ((m + n) ٪ 2 === 0) {واپسی (math.max (میکسلیفٹیکس ، میکسلیفٹی) + math.min (minrightx ، minrighty)) / 2؛} else {واپس math.max (میکسلیفٹیکس ، میکسلیفٹی) ؛}} دوسری صورت میں اگر (میکسلفٹیکس> مائنرائٹی) {ہائے = پارٹیشن ایکس - 1 ؛} else {lo = partitionx + 1 ؛}} ریٹرن -1 ؛} اس مثال میں ، ہم ایک فائنڈ میڈیمورٹ ڈریڈری فنکشن کی وضاحت کرتے ہیں جو دو ترتیب شدہ صفوں کو دلائل کے طور پر لیتا ہے اور ضم شدہ صف کے وسط کو لوٹاتا ہے۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا پہلی صف کی لمبائی دوسری صف کی لمبائی سے زیادہ ہے ، اور اگر ایسا ہے تو ، صفوں کو تبدیل کرتے ہیں تاکہ یہ یقینی بنایا جاسکے کہ پہلی صف ہمیشہ چھوٹی ہوتی ہے۔اس کے بعد یہ فنکشن دونوں صفوں کے پارٹیشن پوائنٹس کو تلاش کرنے کے لئے بائنری تلاش کا استعمال کرتا ہے ، اس طرح کہ ضم شدہ صف کے بائیں نصف حصے میں وہ تمام عناصر شامل ہیں جو ضم شدہ صف کے دائیں نصف سے کم یا برابر ہیں۔اس کے بعد یہ فنکشن پارٹیشن پوائنٹس اور مناسب فارمولے کا استعمال کرتے ہوئے انضمام شدہ سرنی کے وسط کا حساب لگاتا ہے۔ یہ صرف چند مثالیں ہیں کہ ٹائپ اسکرپٹ میں دو ترتیب شدہ صفوں کا میڈین کیسے تلاش کیا جائے۔اس کے علاوہ اور بھی نقطہ نظر ہیں ، جیسے ڈھیروں کا استعمال کرنا یا الگورتھم کو تقسیم کرنا اور فتح کرنا۔نقطہ نظر کا انتخاب مسئلے کی مخصوص ضروریات اور سسٹم کی رکاوٹوں پر منحصر ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں خود توازن رکھنے والے AVL درخت کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں خود توازن رکھنے والے AVL درخت کو نافذ کرنے کے لئے بہت سارے وسائل دستیاب ہیں۔یہاں کچھ مثالیں ہیں: GWTW/TS-AVL-Tree-یہ ایک گٹ ہب ذخیرہ ہے جس میں ٹائپ اسکرپٹ میں AVL درخت کے ڈیٹا ڈھانچے کا نفاذ ہوتا ہے۔اس پر عمل درآمد تعلیمی مقاصد کے لئے تیار کیا گیا ہے ، لیکن اسے پروڈکشن ماحول میں کام کرنا چاہئے۔ اے وی ایل ٹری گٹ ہب عنوانات - یہ ایک گٹ ہب ٹاپک صفحہ ہے جس میں ٹائپ اسکرپٹ میں اے وی ایل کے درختوں سے متعلق متعدد ذخیروں کی فہرست دی گئی ہے۔ذخیروں میں اے وی ایل کے درختوں کے نفاذ کے ساتھ ساتھ دیگر ڈیٹا ڈھانچے اور الگورتھمز۔ جاوا اسکرپٹ میں ٹری ٹری - لرنرس بکٹ - یہ ایک ٹیوٹوریل ہے جس میں یہ بتایا گیا ہے کہ جاوا اسکرپٹ میں اے وی ایل کے درخت کو کس طرح نافذ کیا جائے ، لیکن اس کوڈ کو ٹائپ اسکرپٹ کے مطابق بنایا جاسکتا ہے۔ٹیوٹوریل اے وی ایل کے درخت کو نافذ کرنے کے لئے ایک مرحلہ وار گائیڈ فراہم کرتا ہے ، جس میں نوڈس بنانا ، نوڈس کو داخل کرنا اور حذف کرنا ، اور درخت کو توازن شامل کرنا شامل ہے۔ٹائپ اسکرپٹ میں۔پیکیجوں میں اے وی ایل کے درختوں کے نفاذ کے ساتھ ساتھ دیگر ڈیٹا ڈھانچے اور الگورتھمز.اول این پی ایم شامل ہیں - یہ ایک این پی ایم پیکیج ہے جو نوڈ اور براؤزر کے ماحول کے لئے اے وی ایل درخت کا تیز رفتار نفاذ فراہم کرتا ہے۔پیکیج میں درختوں میں نوڈس ڈالنے ، حذف کرنے اور تلاش کرنے کے طریقے شامل ہیں۔ ٹائپ اسکرپٹ 25 - اے وی ایل ٹری - یوٹیوب - یہ ایک یوٹیوب ویڈیو ہے جس میں یہ بتایا گیا ہے کہ ٹائپ اسکرپٹ میں اے وی ایل کے درخت کو کیسے نافذ کیا جائے۔ویڈیو AVL درخت کے اعداد و شمار کے ڈھانچے کی تفصیلی وضاحت فراہم کرتی ہے ، جس میں نوڈس کو داخل کرنے اور حذف کرنے کا طریقہ ، اور درخت کو کس طرح توازن قائم کرنا ہے۔جو آپ کی ضروریات کو بہترین طور پر فٹ بیٹھتا ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ٹری پر آرڈر میں درختوں کی سیر کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں بائنری ٹری پر ایک آرڈر میں درخت کے ٹریورسل کو انجام دینے کے ل we ، ہم ایک تکرار نقطہ نظر استعمال کرسکتے ہیں جو بائیں سب ٹری ، پھر جڑ نوڈ ، اور پھر دائیں سب ٹری کا دورہ کرتا ہے۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ کلاس ٹرینوڈ {ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = (ویل === غیر متعینہ؟ 0: ویل) ؛this.left = (بائیں === غیر متعینہ؟ null: بائیں) ؛this.right = (دائیں === غیر متعینہ؟ null: صحیح) ؛}} فنکشن inordertraversal (جڑ: Treenode | null): نمبر [] {کانسٹنگ نتیجہ: نمبر [] = [] ؛Const traverse = (نوڈ: ٹرینوڈ | null) => {if (نوڈ) {traverse (node.left) ؛نتیجہ.پش (نوڈ.وال) ؛traverse (node.right) ؛}} ؛عبور (جڑ) ؛واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ویل پراپرٹی ، اور بالترتیب بائیں اور دائیں بچوں کے نوڈس کے لئے بائیں اور دائیں خصوصیات کے ساتھ۔اس کے بعد ہم ایک انڈرڈر ٹراورسل فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر جڑ نوڈ لیتا ہے اور آرڈر میں ٹراورسل ترتیب میں نوڈ اقدار کی ایک صف کو واپس کرتا ہے۔فنکشن سب سے پہلے نوڈ کی اقدار کو ذخیرہ کرنے کے لئے خالی صف کے نتائج کی ابتدا کرتا ہے ، اور پھر ایک بار بار آنے والے عبور فنکشن کی وضاحت کرتا ہے جو بائیں سب ٹری ، پھر جڑ نوڈ ، اور پھر دائیں سب ٹری کا دورہ کرتا ہے۔ٹرورس فنکشن کو جڑ کے نوڈ کے ساتھ دلیل کے طور پر کہا جاتا ہے ، اور اس کے نتیجے میں نتیجہ سرنی واپس کردی جاتی ہے۔ یہاں انڈرڈر ٹریورسل فنکشن کی ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ جڑ = نیا ٹرینوڈ (1) ؛ روٹ۔ رائٹ = نیا ٹرینوڈ (2) روٹ روٹ.Right.left = نیا ٹرینوڈ (3) ؛ کانسٹنگ نتیجہ = inordertraversal (جڑ) ؛ کنسول.لاگ (نتیجہ) ؛// [1 ، 3 ، 2] اس مثال میں ، ہم 1 کی جڑ نوڈ ویلیو کے ساتھ ایک نیا بائنری درخت بناتے ہیں ، ایک دائیں بچے کا نوڈ جس کی قیمت 2 ہے ، اور ایک قیمت کے ساتھ دائیں بچے کے نوڈ کا بائیں بچے کا نوڈ ہے۔کے .۔ پھر ہم روٹ نوڈ کے ساتھ inordertraversal فنکشن کو دلیل کے طور پر کہتے ہیں اور نتیجہ کو ایک نئے متغیر کے نتائج پر تفویض کرتے ہیں۔آخر میں ، ہم نتائج کی قدر کو کنسول پر لاگ ان کرتے ہیں ، جو [1] [3] [2]"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم موجودہ لائبریری جیسے بلوم فلٹرز 12 استعمال کرسکتے ہیں۔یہ لائبریری بلوم فلٹر کا ایک سادہ اور موثر نفاذ فراہم کرتی ہے ، اسی طرح دیگر امکانی اعداد و شمار کے ڈھانچے جیسے ہائپرلوگلاگ ، گنتی منکی اسکیچ ، ٹاپ-کے ، اور منہش۔ ہر ایک بلوم فلٹرز لائبریری کا ایک مثال استعمال کرنے اور استعمال کرنے کے لئے ہے۔ٹائپ اسکرپٹ میں ایک بلوم فلٹر: ٹائپ اسکرپٹ امپورٹ {بلوم فلٹر} سے 'بلوم فلٹرز' سے ؛ // 10 اور 4 ہیش فنکشن کونسٹ فلٹر = نیا بلوم فلٹر (10 ، 4) کے سائز کے ساتھ بلوم فلٹر بنائیں ؛ // داخل کریں ڈیٹا فلٹر۔ ایڈ (''ایلس ') ؛ فلٹر.اڈ (' باب ') ؛ // کچھ ڈیٹا کنسول.لاگ (فلٹر.ہاس (' باب ')) کے لئے تلاش کرنا ؛// آؤٹ پٹ: trueconsole.log (فلٹر.ہاس ('ڈینیئل')) ؛// آؤٹ پٹ: غلط // غلطی rateconsole.log (filter.rate ()) ؛ // متبادل کے طور پر پرنٹ کریں ، متعدد اشیاء کے لئے بلوم فلٹر کو زیادہ سے زیادہ بنائیں اور مطلوبہ غلطی ریٹیکونسٹ آئٹمز = ['ایلس' ، 'باب'] ؛ const غلطی = 0.04 ؛// 4 ٪ غلطی ریٹیکونسٹ فلٹر 2 = بلوم فلٹر۔ کریٹ (آئٹمز۔ لمبائی ، غلطی) ؛ // یا آئٹمز کے ذخیرے کے لئے بلوم فلٹر زیادہ سے زیادہ بنائیں اور مطلوبہ غلطی ریٹیکونسٹ فلٹر 3 = بلومفلٹر۔مثال کے طور پر ، ہم پہلے بلوم فلٹرز لائبریری سے بلوم فلٹر کلاس درآمد کرتے ہیں۔اس کے بعد ہم 10 اور 4 ہیش افعال کے سائز کے ساتھ ایک نیا بلوم فلٹر بناتے ہیں ، اور فلٹر میں کچھ ڈیٹا داخل کرتے ہیں۔اس کے بعد ہم کچھ ڈیٹا کے لئے تلاش کرتے ہیں اور فلٹر کی غلطی کی شرح پرنٹ کرتے ہیں۔آخر میں ، ہم دو اور بلوم فلٹرز بناتے ہیں ، ایک بہت سی اشیاء کے لئے ایک زیادہ سے زیادہ اور مطلوبہ غلطی کی شرح ، اور دوسرا آئٹمز کے ذخیرے اور مطلوبہ غلطی کی شرح کے لئے زیادہ سے زیادہ۔بٹ سرنی اور ایک سے زیادہ ہیش فنکشن 3۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ کلاس بلومفلٹر {نجی ریڈونلی بٹیرے: بولین [] ؛نجی ریڈونلی ہیشفکشن: ((قیمت: سٹرنگ) => نمبر) [] ؛کنسٹرکٹر (سائز: نمبر ، ہیشفونکشن: ((قدر: سٹرنگ) => نمبر) []) {this.bitarray = نیا سرنی (سائز). فل (غلط) ؛this.hashfunctions = hashfunction ؛} شامل کریں (ویلیو: سٹرنگ) {this.hashfunctions.foreach ((hashfunction) => {const index = hashfunction (value) ٪ this.bitarray.length ؛ this.bitarray [انڈیکس] = سچ ؛}) ؛} ہے (ویلیو: سٹرنگ): بولین {اس کو لوٹائیں۔}} اس مثال میں ، ہم ایک بلوم فلٹر کلاس کی وضاحت کرتے ہیں جو بلوم فلٹر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، جس میں بٹ سرنی کے لئے بٹرای پراپرٹی ، اور ہیش افعال کے لئے ایک ہیش فنسکشن پراپرٹی ہے۔اس کے بعد ہم ایک ADD طریقہ کی وضاحت کرتے ہیں جو ہیش کے افعال کا استعمال کرتے ہوئے بٹ سرنی میں اسی طرح کے بٹس کو ترتیب دے کر بلوم فلٹر میں ایک قدر کا اضافہ کرتا ہے ، اور A کے پاس ایسا طریقہ ہے جو چیک کرتا ہے کہ اگر کوئی قیمت بلوم فلٹر میں ہے تو بٹ میں متعلقہ بٹس کو چیک کرکے اگر کوئی قیمت ہے۔ہیش فنکشن کا استعمال کرتے ہوئے سرنی۔ بلوم فلٹر کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ ہیش فنکشن = [(ویلیو: سٹرنگ) => ویلیونگ۔ لمبائی ، (ویلیو: سٹرنگ) => ویلی> value.charcodeat (value.length - 1) ،] cont const فلٹر = نیا بلومفلٹر (10 ، ہیش فنکشن) ؛ فلٹر.اڈ ('ایلس') ؛ فلٹر.اڈڈ ('باب') ؛ کنسول.لوگ (فلٹر.ہاس('باب')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.ہاس ('ڈینیئل')) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہم ایک نیا بلوم فلٹر آبجیکٹ تیار کرتے ہیں جس کا سائز 10 اور تین ہیش افعال کی ایک صف ہے۔اس کے بعد ہم فلٹر میں کچھ ڈیٹا شامل کرتے ہیں اور کچھ اعداد و شمار کے لئے تلاش کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں دیئے گئے سٹرنگ کے تمام اجازت نامے پیدا کرنے کے ل we ، ہم ایک تکرار نقطہ نظر استعمال کرسکتے ہیں جو ہر کردار کو تار میں ہر دوسرے کردار کے ساتھ تبدیل کرتا ہے۔اس نقطہ نظر کو کس طرح نافذ کرنے کے طریقوں کی کچھ مثالیں یہ ہیں: ایک مددگار فنکشن کا استعمال: ایک نقطہ نظر یہ ہے کہ ایک ہیلپر فنکشن کی وضاحت کی جائے جو موجودہ تار ، شروعاتی اشاریہ ، اور اختتامی انڈیکس کو دلائل کے طور پر لے جاتا ہے ، اور ہر کردار کو ہر دوسرے کے ساتھ تبدیل کرتا ہے۔تار میں کردار.یہاں ایک مثال کے نفاذ: ٹائپ اسکرپٹ فنکشن پرموٹ ہیلپر (ایس ٹی آر: سٹرنگ ، اسٹارٹ: نمبر ، اختتام: نمبر ، نتیجہ: سٹرنگ []) {اگر (اسٹارٹ === اختتام) {نتیجہ۔ پش (ایس ٹی آر) ؛} else {for (i = start ؛ i <= end ؛ i ++) {str = تبادلہ (str ، شروع ، i) ؛permutehelper (str ، start + 1 ، اختتام ، نتیجہ) ؛str = swap (str ، start ، i) ؛}}} فنکشن سویپ (str: string ، i: نمبر ، j: نمبر): سٹرنگ {const arr = str.split ('' ') ؛[arr [i] ، arr [j]] = [arr [j] ، arr [i]] ؛واپسی arr.join ('') ؛} فنکشن پرمٹ (str: سٹرنگ): سٹرنگ [] {کانسٹنگ نتیجہ: سٹرنگ [] = [] ؛Permutehelper (str ، 0 ، str.length - 1 ، نتیجہ) ؛واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک ایسے عمدہ فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر تار لیتا ہے اور تار کے تمام اجازت ناموں کی ایک صف کو واپس کرتا ہے۔فنکشن سب سے پہلے اجازت نامے کو ذخیرہ کرنے کے لئے خالی سرنی کے نتائج کی ابتدا کرتا ہے ، اور پھر اسٹرنگ ، شروعاتی انڈیکس (0) ، اختتامی انڈیکس (لمبائی 1) ، اور نتائج کی صف کو دلائل کے طور پر ایک مددگار فنکشن پرموٹ ہیلپر کو کال کرتا ہے۔پرمویٹ ہیلپر فنکشن ہر کردار کو ہر دوسرے کردار کو تار میں ہر دوسرے کردار کے ساتھ تبدیل کرتا ہے ، اور نتیجے میں ہونے والے اجازت ناموں کو نتیجہ سرنی میں شامل کرتا ہے۔سویپ فنکشن ایک مددگار فنکشن ہے جو ایک تار میں دو حرفوں کو تبدیل کرتا ہے۔ یہاں پرمٹ فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ ایس ٹی آر = 'اے بی سی' ؛ کانسٹنگ رزلٹ = پرمٹ (ایس ٹی آر) ؛ کنسول.لاگ (نتیجہ) ؛// ['ABC' ، 'ACB' ، 'BAC' ، 'BCA' ، 'CAB' ، 'CBA'] اس مثال میں ، ہم 'ABC' کی قیمت کے ساتھ ایک نیا سٹرنگ STR تیار کرتے ہیں ، اور پھر پرمٹ فنکشن کو کال کرتے ہیں۔STR کے ساتھ دلیل کے طور پر اور نتیجہ کو ایک نئے متغیر کے نتائج پر تفویض کریں۔آخر میں ، ہم کنسول پر نتیجہ کی قدر کو لاگ ان کرتے ہیں ، جو ['ABC' ، 'ACB' ، 'BAC' ، 'BCA' ، 'CAB' ، 'CBA'] ہونا چاہئے۔ سرنی.پروٹوٹائپ.ڈریڈوس () () کا استعمال کرتے ہوئے:ایک اور نقطہ نظر یہ ہے کہ تار کے تمام اجازت ناموں کو پیدا کرنے کے لئے سرنی آبجیکٹ کے کم () طریقہ کار کو استعمال کرنا ہے۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ فکشن پرمٹ (ایس ٹی آر: سٹرنگ): سٹرنگ [] {اگر (str.length === 1) {واپسی [str] ؛} else {واپس str.split (''). کم کریں ((ACC: سٹرنگ [] ، چار: سٹرنگ ، i: نمبر) => {const & بقیہ chars = str.slice (0 ، i) + str.slice (i +؛}} اس مثال میں ، ہم ایک ایسے عمدہ فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر تار لیتا ہے اور تار کے تمام اجازت ناموں کی ایک صف کو واپس کرتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا تار کی لمبائی 1 ہے ، اس صورت میں یہ واحد عنصر کے طور پر تار کے ساتھ کسی صف کو واپس کرتا ہے۔بصورت دیگر ، یہ تار کو حروف کی ایک صف میں تقسیم کرتا ہے ، اور تار کے تمام اجازت نامے پیدا کرنے کے لئے کم () طریقہ استعمال کرتا ہے۔کم () کا طریقہ تار میں ہر کردار پر تکرار کرتا ہے ، اور ہر کردار کے ل it ، یہ تکرار کا استعمال کرتے ہوئے باقی کرداروں کی تمام جزوی اجازتیں پیدا کرتا ہے ، اور پھر جزوی اجازت ناموں کو موجودہ کردار کے ساتھ جوڑتا ہے تاکہ مکمل اجازت نامے پیدا کریں۔ یہاں ایک مثال کا استعمال ہے۔پرمٹ فنکشن کا: ٹائپ اسکرپٹکونسٹ str = 'abc' ؛ کانسٹنگ نتیجہ = پرمٹ (ایس ٹی آر) ؛ کنسول.لوگ (نتیجہ) ؛// ['ABC' ، 'ACB' ، 'BAC' ، 'BCA' ، 'CAB' ، 'CBA'] اس مثال میں ، ہم 'ABC' کی قیمت کے ساتھ ایک نیا سٹرنگ STR تیار کرتے ہیں ، اور پھر پرمٹ فنکشن کو کال کرتے ہیں۔STR کے ساتھ دلیل کے طور پر اور نتیجہ کو ایک نئے متغیر کے نتائج پر تفویض کریں۔آخر میں ، ہم کنسول پر نتیجہ کی قدر لاگ ان کرتے ہیں ، جو ['ABC' ، 'ACB' ، 'BAC' ، 'BCA' ، 'CAB' ، 'CBA' ، 'CBA'] ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں سرخ سیاہ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں سرخ سیاہ درخت کے ڈیٹا ڈھانچے کو نافذ کرنے کے لئے بہت سارے وسائل دستیاب ہیں۔یہاں کچھ مثالیں ہیں:@جمع کرنے کے قابل/ریڈ بلیک ٹری-یہ ایک NPM پیکیج ہے جو سرخ رنگ کے درخت کے ڈیٹا ڈھانچے کا ٹائپ اسکرپٹ کے مطابق مطابقت فراہم کرتا ہے۔پیکیج میں درخت میں نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقے شامل ہیں ، نیز دیگر افادیت کے طریقے۔اس پر عمل درآمد میں درخت میں نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقے شامل ہیں ، نیز دیگر افادیت کے طریقے۔ نیلیپلی/آر بی ٹی ایس: ٹائپ اسکرپٹ ریڈ بلیک ٹری-یہ ایک گٹ ہب ریپوزٹری ہے جس میں سرخ سیاہ درخت کے اعداد و شمار کا نفاذ ہوتا ہے۔ٹائپ اسکرپٹ میں ساخت۔اس پر عمل درآمد میں جاوا اسکرپٹ کے بلٹ ان میپ ٹائپ کی طرح انٹرفیس ہے ، لہذا اسے نقشہ کے متبادل کے طور پر استعمال کیا جاسکتا ہے ، لیکن کنسٹرکٹر میں لیس او پی پیرامیٹر کے مطابق ترتیب شدہ تکرار کے ساتھ۔تلاش کا صفحہ جس میں ٹائپ اسکرپٹ میں سرخ سیاہ درختوں سے متعلق متعدد پیکیجوں کی فہرست دی گئی ہے۔پیکیجوں میں سرخ رنگ کے درختوں کے نفاذ کے ساتھ ساتھ دیگر ڈیٹا ڈھانچے اور الگورتھمز۔الگورتھم ٹیوٹر - یہ ایک ایسا ٹیوٹوریل ہے جو سرخ رنگ کے درختوں کے اعداد و شمار کے ڈھانچے کی وضاحت کرتا ہے اور C ++ ، جاوا ، اور ازگر میں نفاذ فراہم کرتا ہے۔اگرچہ نفاذ ٹائپ اسکرپٹ میں نہیں ہیں ، لیکن تصورات اور الگورتھم کو ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔ یہ وسائل ٹائپ اسکرپٹ میں ریڈ بلیک ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے لئے مختلف نقطہ نظر فراہم کرتے ہیں ، لہذا آپ اس میں سے ایک کا انتخاب کرسکتے ہیں جو آپ کی ضروریات کو بہتر بناتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ٹری پر پری آرڈر ٹری ٹریورسل انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں بائنری ٹری پر پری آرڈر ٹری ٹریورسل کو انجام دینے کے ل we ، ہم ایک تکرار نقطہ نظر استعمال کرسکتے ہیں جو جڑ کے نوڈ ، پھر بائیں سب ٹری ، اور پھر دائیں سب ٹری کا دورہ کرتا ہے۔اس نقطہ نظر کو کس طرح نافذ کرنے کے طریقوں کی کچھ مثالیں یہ ہیں: ایک مددگار فنکشن کا استعمال: ایک نقطہ نظر ایک مددگار فنکشن کی وضاحت کرنا ہے جو موجودہ نوڈ اور پری آرڈر ٹراورسل کو دلائل کے طور پر محفوظ کرنے کے لئے ایک صف لیتا ہے ، اور بار بار جڑ نوڈ کا دورہ کرتا ہے ، اور بار بار روٹ نوڈ کا دورہ کرتا ہے ،پھر بائیں سب ٹری ، اور پھر دائیں سب ٹری۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ کلاس ٹرینوڈ {ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = (ویل === غیر متعینہ؟ 0: ویل) ؛this.left = (بائیں === غیر متعینہ؟ null: بائیں) ؛this.right = (دائیں === غیر متعینہ؟ null: صحیح) ؛}} فنکشن پری آرڈر ٹراورسال (جڑ: ٹرینوڈ | null): نمبر [] {کانسٹنگ نتیجہ: نمبر [] = [] ؛Const traverse = (نوڈ: ٹرینوڈ | null ، نتیجہ: نمبر []) => {اگر (نوڈ) {نتیجہ. پش (نوڈ.وال) ؛traverse (node.left ، نتیجہ) ؛ٹراورس (نوڈ۔ رائٹ ، نتیجہ) ؛}} ؛عبور (جڑ ، نتیجہ) ؛واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ویل پراپرٹی ، اور بالترتیب بائیں اور دائیں بچوں کے نوڈس کے لئے بائیں اور دائیں خصوصیات کے ساتھ۔اس کے بعد ہم ایک پری آرڈر ٹراورسل فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر جڑ نوڈ لیتا ہے اور پری آرڈر ٹراورسل ترتیب میں نوڈ اقدار کی ایک صف کو واپس کرتا ہے۔فنکشن سب سے پہلے نوڈ کی اقدار کو ذخیرہ کرنے کے لئے خالی سرنی کے نتائج کی ابتدا کرتا ہے ، اور پھر ایک بار بار چلنے والے ٹراورس فنکشن کی وضاحت کرتا ہے جو جڑ کے نوڈ ، پھر بائیں سب ٹری ، اور پھر دائیں سب ٹری کا دورہ کرتا ہے۔ٹراورس فنکشن کو جڑ کے نوڈ اور نتیجہ سرنی کے ساتھ دلائل کے طور پر بلایا جاتا ہے ، اور اس کے نتیجے میں نتیجہ سرنی واپس کردی جاتی ہے۔ یہاں پری آرڈر ٹراورسل فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ جڑ = نیا ٹرینوڈ (1) ؛ روٹ۔ رائٹ = نیا ٹرینوڈ (2 (2) ؛ root.right.left = نیا ٹرینوڈ (3) const کانسٹر نتیجہ = پری آرڈر ٹراورسال (جڑ) ؛ کنسول.لوگ (نتیجہ) ؛// [1 ، 2 ، 3] اس مثال میں ، ہم 1 کی جڑ نوڈ ویلیو کے ساتھ ایک نیا بائنری ٹری تیار کرتے ہیں ، ایک دائیں بچے کا نوڈ جس کی قیمت 2 ہے ، اور دائیں بچے کے نوڈ کا بائیں بچے کا نوڈ ایک قیمت کے ساتھ ہے۔اس کے بعد ہم پری آرڈر ٹراورسل فنکشن کو جڑ نوڈ کے ساتھ دلیل کے طور پر کہتے ہیں اور نتیجہ کو ایک نئے متغیر کے نتائج پر تفویض کرتے ہیں۔آخر میں ، ہم نتائج کی قدر کو کنسول پر لاگ ان کرتے ہیں ، جو [1 ، [2] [3] ہونا چاہئے۔ اسٹیک کا استعمال کرتے ہوئے: دوسرا نقطہ نظر یہ ہے کہ بائنری درخت کی تکراری پری آرڈر ٹریورسل کو انجام دینے کے لئے اسٹیک کا استعمال کیا جائے۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ فکشن پری آرڈر ٹراورسل (جڑ: ٹرینوڈ | NULL): نمبر [] {کانسٹنگ نتیجہ: نمبر [] = [] ؛کانسٹ اسٹیک: ٹرینوڈ [] = [] ؛اگر (جڑ) {stack.push (جڑ) ؛} جبکہ (stack.length> 0) {const node = stack.pop () !؛نتیجہ.پش (نوڈ.وال) ؛if (node.right) {stack.push (node.right) ؛} if (node.left) {stack.push (node.left) ؛} return واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک پری آرڈر ٹراورسل فنکشن کی وضاحت کرتے ہیں جو روٹ نوڈ کو دلیل کے طور پر لیتا ہے اور پری آرڈر ٹراورسل ترتیب میں نوڈ اقدار کی ایک صف کو واپس کرتا ہے۔فنکشن سب سے پہلے نوڈ کی اقدار کو ذخیرہ کرنے کے لئے خالی سرنی کے نتائج کی ابتدا کرتا ہے ، اور نوڈس کو دیکھنے کے لئے ذخیرہ کرنے کے لئے ایک اسٹیک۔اگر جڑ نوڈ کالعدم نہیں ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔اس کے بعد یہ فنکشن ایک لوپ میں داخل ہوتا ہے جو اسٹیک سے نوڈ کو پاپ کرتا ہے ، اس کی قیمت کو نتیجہ سرنی میں شامل کرتا ہے ، اور اس کے دائیں اور بائیں بچے کے نوڈس کو اسٹیک پر دھکیل دیتا ہے ، اگر وہ موجود ہیں۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ اسٹیک خالی نہ ہو ، اور اس کے نتیجے میں نتیجہ سرنی واپس آجائے۔ یہاں پری آرڈر ٹراورسل فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ روٹ = نیا ٹرینوڈ (1) ؛ روٹ. رائٹ = نیا ٹرینوڈ (2) ؛ روٹ. رائٹ.left= نیا ٹرینوڈ (3) const کانسٹنگ نتیجہ = پری آرڈر ٹریورسل (جڑ) ؛ کنسول.لوگ (نتیجہ) ؛// [1 ، 2 ، 3] اس مثال میں ، ہم 1 کی جڑ نوڈ ویلیو کے ساتھ ایک نیا بائنری ٹری تیار کرتے ہیں ، ایک دائیں بچے کا نوڈ جس کی قیمت 2 ہے ، اور دائیں بچے کے نوڈ کا بائیں بچے کا نوڈ ایک قیمت کے ساتھ ہے۔3. کے. پھر ہم روٹ نوڈ کے ساتھ پیشگی آرڈر ٹریورسل فنکشن کو دلیل کے طور پر کہتے ہیں اور تفویض کرتے ہیں"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم موجودہ لائبریریوں کا استعمال کرسکتے ہیں یا خود ہی نافذ کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کو کس طرح نافذ کرنے کی مثالیں فراہم کرتے ہیں: گٹ ہب عنوانات-ڈس وینٹ سیٹ: یہ ایک گٹ ہب ٹاپک پیج ہے جس میں ٹائپ اسکرپٹ میں ڈسونٹ سیٹ ڈیٹا ڈھانچے سے متعلق متعدد ذخیروں کی فہرست دی گئی ہے۔ذخیروں میں متنازعہ سیٹ ڈیٹا ڈھانچے کے نفاذ کے ساتھ ساتھ دیگر ڈیٹا ڈھانچے اور الگورتھمز۔ ٹائپ اسکرپٹ کو ناگوار سیٹ (یونین اور تلاش الگورتھم) کا نفاذ شامل ہے۔ٹائپ اسکرپٹ میں ساخت۔اس پر عمل درآمد میں سیٹ بنانے ، سیٹ کے والدین کو تلاش کرنے اور سیٹوں کو ضم کرنے کے طریقے شامل ہیں۔ ڈیٹا سیٹ ڈیٹا ڈھانچے - گیکسفورجیکس: یہ ایک ایسا ٹیوٹوریل ہے جو متنازعہ سیٹ ڈیٹا ڈھانچے کی وضاحت کرتا ہے اور ٹائپ اسکرپٹ سمیت متعدد پروگرامنگ زبانوں میں نفاذ فراہم کرتا ہے۔ٹیوٹوریل میں ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کے ذریعہ تعاون یافتہ کارروائیوں کی وضاحتیں شامل ہیں ، جیسے نئے سیٹ شامل کرنا ، سیٹوں کو ضم کرنا ، اور کسی سیٹ کے والدین کو تلاش کرنا۔ٹائپ اسکرپٹ میں ڈیٹا ڈھانچے کو ناپسند کرنے کے لئے۔پیکیجوں میں ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کے نفاذ کے ساتھ ساتھ دیگر ڈیٹا ڈھانچے اور الگورتھم بھی شامل ہیں۔ یہ وسائل ٹائپ اسکرپٹ میں ایک ڈسنٹ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے مختلف نقطہ نظر فراہم کرتے ہیں ، لہذا آپ اس میں سے ایک کا انتخاب کرسکتے ہیں جو آپ کی ضروریات کو بہتر بناتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ٹیکسٹ سٹرنگ میں پیٹرن کے واقعات کی تعداد کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ٹیکسٹ سٹرنگ میں پیٹرن کے واقعات کی تعداد کو گننے کے بہت سارے طریقے ہیں۔یہاں کچھ مثالیں ہیں: میچ () کے طریقہ کار کا استعمال: ایک نقطہ نظر یہ ہے کہ ایک صف میں پیٹرن کے تمام واقعات کو پیدا کرنے کے لئے سٹرنگ مثال کے میچ () کا طریقہ استعمال کیا جائے ، اور پھر اس کی تعداد حاصل کرنے کے لئے صف کے سائز کو گنیں۔واقعاتیہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ فانکشن کاؤنٹوکورینس (متن: سٹرنگ ، پیٹرن: سٹرنگ: سٹرنگ): نمبر {کانسٹ میچز = ٹیکسٹ.مچ (نیا ریج ایکس پی (پیٹرن ، 'جی')) ؛میچ واپس؟میچز۔ لمبائی: 0 ؛} اس مثال کے طور پر ، ہم ایک کاؤنٹوکورینس فنکشن کی وضاحت کرتے ہیں جو ایک متن کی تار اور پیٹرن سٹرنگ کو دلائل کے طور پر لیتا ہے اور متن میں پیٹرن کے واقعات کی تعداد کو لوٹاتا ہے۔فنکشن پہلے REGEXP () کنسٹرکٹر کے ساتھ ایک باقاعدہ اظہار آبجیکٹ تیار کرتا ہے ، جس میں متن میں پیٹرن کے تمام واقعات سے ملنے کے لئے پیٹرن سٹرنگ اور 'G' پرچم کا استعمال کیا جاتا ہے۔اس کے بعد یہ فنکشن باقاعدہ اظہار آبجیکٹ کے ساتھ متن کے تار کے میچ () کے طریقہ کار کو دلیل کے طور پر کہتے ہیں ، جو متن میں پیٹرن کے تمام واقعات کی ایک صف کو لوٹاتا ہے۔آخر میں ، فنکشن سرنی کی لمبائی کو لوٹاتا ہے ، جو متن میں پیٹرن کے واقعات کی تعداد ہے۔ یہاں کاؤنٹوکورینسس فنکشن کی ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ ٹیکسٹ = 'کوئیک براؤن فاکس سست کتے پر چھلانگ لگاتا ہے'۔= 'دی' ؛ کنٹین گنتی = کاؤنٹوکورینس (متن ، نمونہ) ؛ کنسول.لوگ (گنتی) ؛// 2 اس مثال کے طور پر ، ہم 'دی کوئیک براؤن فاکس کے اوپر کوئیک براؤن فاکس چھلانگ' کی قیمت کے ساتھ ایک نیا ٹیکسٹ اسٹرنگ بناتے ہیں ، جس کی قیمت 'دی' کے ساتھ ایک پیٹرن تار ہے ، اور پھر اس کو متن اور نمونہ کے ساتھ کاؤنٹوکورنس فنکشن کو دلائل کے طور پر کال کریں۔اور نتیجہ کو ایک نئی متغیر گنتی کے لئے تفویض کریں۔آخر میں ، ہم کنسول میں گنتی کی قیمت کو لاگ ان کرتے ہیں ، جو ایک لوپ کا استعمال کرنا چاہئے: دوسرا نقطہ نظر یہ ہے کہ متن کے تار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کیا جائے اور پیٹرن کے واقعات کی تعداد کو گننا ہے۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ فانکشن کاؤنٹوکورینس (متن: سٹرنگ ، پیٹرن: سٹرنگ): نمبر {آئیے گنتی = 0 ؛آئیے انڈیکس = 0 ؛جبکہ ((index = text.indexof (پیٹرن ، انڈیکس))! == -1) {گنتی ++ ؛انڈیکس += پیٹرن۔ لمبائی ؛} واپسی کی گنتی ؛} اس مثال کے طور پر ، ہم ایک کاؤنٹوکورینس فنکشن کی وضاحت کرتے ہیں جو متن کے تار اور پیٹرن سٹرنگ کو دلائل کے طور پر لیتا ہے اور متن میں پیٹرن کے واقعات کی تعداد کو لوٹاتا ہے۔فنکشن سب سے پہلے ایک گنتی متغیر کو 0 اور ایک انڈیکس متغیر 0 پر شروع کرتا ہے۔ اس کے بعد فنکشن ایک ایسے لوپ میں داخل ہوتا ہے جو موجودہ انڈیکس سے شروع ہونے والے انڈیکس () کے طریقہ کار کا استعمال کرتے ہوئے ٹیکسٹ سٹرنگ میں پیٹرن کی تلاش کرتا ہے۔اگر پیٹرن مل جاتا ہے تو ، گنتی متغیر میں اضافہ ہوتا ہے اور انڈیکس متغیر کو پیٹرن کے بعد اگلی پوزیشن پر اپ ڈیٹ کیا جاتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ نمونہ نہ مل جائے ، اور اس کے نتیجے میں گنتی متغیر واپس آجائے۔ یہاں کاؤنٹوکورینسس فنکشن کی ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ ٹیکسٹ = 'کوئیک براؤن فاکس سست کتے پر چھلانگ لگاتا ہے' ؛گنتی = کاؤنٹوکورینس (متن ، نمونہ) ؛ کنسول.لوگ (گنتی) ؛// 2 اس مثال کے طور پر ، ہم 'دی کوئیک براؤن فاکس کے اوپر کوئیک براؤن فاکس چھلانگ' کی قیمت کے ساتھ ایک نیا ٹیکسٹ اسٹرنگ بناتے ہیں ، جس کی قیمت 'دی' کے ساتھ ایک پیٹرن تار ہے ، اور پھر اس کو متن اور نمونہ کے ساتھ کاؤنٹوکورنس فنکشن کو دلائل کے طور پر کال کریں۔اور نتیجہ کو ایک نئی متغیر گنتی کے لئے تفویض کریں۔آخر میں ، ہم گنتی کی قیمت کو کنسول پر لاگ ان کریں ، جو 2.1W3DOCS2Techedilight3Programiz4stackabuse5geeksforgeeks ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ریڈکس ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ریڈکس ترتیب والے الگورتھم کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: سرنی میں زیادہ سے زیادہ نمبر تلاش کریں۔ ہر ہندسے کے ذریعے زیادہ سے زیادہ نمبر میں ہندسوں کی تعداد کا تعین کریں۔ ہر ہندسے سے شروع ہوتا ہے۔10 بالٹیاں (0-9) بنائیں اور موجودہ ہندسے کی قیمت کی بنیاد پر بالٹیوں میں نمبروں کو تقسیم کریں۔ٹائپ اسکرپٹ میں ریڈکس کو ترتیب دینے والے الگورتھم کا نفاذ: ٹائپ اسکرپٹ فنکشن ریڈکسسورٹ (اے آر آر: نمبر []): نمبر [] {کانسٹ میکس = ریاضی۔ میکس (... آر آر) ؛کانسٹ میکس ڈیجٹس = ریاضی۔ فلور (ریاضی.لاگ 10 (زیادہ سے زیادہ)) + 1 ؛آئیے نتیجہ = arr.slice () ؛کے لئے (آئیے ہندسے = 0 ؛ ہندسے <میکس ڈیجٹس ؛ ہندسہ ++) {کونسٹ بالٹیاں = سرنی۔کے لئے (آئیے i = 0 ؛ i <نتیجہ۔ لمبائی ؛ i ++) {const num = نتیجہ [i] ؛Const DigitValue = math.floor (num / math.pow (10 ، ہندسہ)) ٪ 10 ؛بالٹیاں [ڈیجیٹ ویلیو] .پش (نمبر) ؛} نتیجہ = [] .کونکاٹ (... بالٹی) ؛} واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک ریڈکسسورٹ فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر نمبروں کی ایک صف لیتا ہے اور ریڈکس ترتیب والے الگورتھم کا استعمال کرتے ہوئے ایک ترتیب شدہ صف لوٹاتا ہے۔فنکشن پہلے صف میں زیادہ سے زیادہ نمبر تلاش کرتا ہے اور زیادہ سے زیادہ تعداد میں ہندسوں کی تعداد کا تعین کرتا ہے۔اس کے بعد فنکشن ان پٹ سرنی کی ایک کاپی پر نتیجہ متغیر کی ابتدا کرتا ہے۔اس کے بعد یہ فنکشن ایک لوپ میں داخل ہوتا ہے جو ہر ہندسے کے ذریعے تکرار کرتا ہے ، کم سے کم اہم ہندسے سے شروع ہوتا ہے۔ہر ہندسے کے ل the ، فنکشن 10 بالٹیاں (0-9) تخلیق کرتا ہے اور موجودہ ہندسے کی قیمت کی بنیاد پر نمبروں کو بالٹیوں میں تقسیم کرتا ہے۔اس کے بعد یہ فنکشن بالٹیوں میں نمبروں کو ترتیب سے جوڑتا ہے ، اور اگلے ہندسے کے لئے عمل کو دہراتا ہے۔آخر میں ، فنکشن ترتیب شدہ سرنی کو لوٹاتا ہے۔ یہاں ریڈکسسورٹ فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ آر آر = [[170 ، 45 ، 75 ، 90 ، 802 ، 24 ، 2 ، 66] ؛ کنسٹ سنٹارڈر = ریڈکسسورٹ (آر اے آر) ؛ کنسول.لوگ(چھانٹیار) ؛// [2 ، 24 ، 45 ، 66 ، 75 ، 90 ، 170 ، 802] اس مثال میں ، ہم اقدار [170 ، 45 ، 75 ، 90 ، 802 ، 24 ، 2 ، 66] کے ساتھ ایک نئی سرنی آر آر تیار کرتے ہیں۔اور پھر RadixSort فنکشن کو ARR کے ساتھ دلیل کے طور پر کال کریں اور نتیجہ کو ایک نئے متغیر ترتیب والے کو تفویض کریں۔آخر میں ، ہم کنسول میں ترتیب دہندگان کی قیمت کو لاگ ان کریں ، جو [2 ، 24 ، 45 ، 66 ، 75 ، 90 ، 170 ، 802] .1doableanny2irelannersbucket3stackoverflow4digitalocean5scholarhat"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: بائنری سرچ ٹری کو ترتیب دیں ، جو چڑھتے ہوئے ترتیب میں نوڈس کا دورہ کریں گے۔ اب تک دیکھنے والے نوڈس کی تعداد کا ٹریک کریں۔جب کے ٹی ایچ نوڈ کا دورہ کیا جاتا ہے تو ، اس کی قیمت واپس کردیں۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ کلاس ٹرینیوڈ {ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = (ویل === غیر متعینہ؟ 0: ویل) ؛this.left = (بائیں === غیر متعینہ؟ null: بائیں) ؛this.right = (دائیں === غیر متعینہ؟ null: صحیح) ؛}} فنکشن Kthsmallest (جڑ: ٹرینوڈ | null ، K: نمبر): نمبر {آئیے گنتی = 0 ؛آئیے نتیجہ = 0 ؛Const traverse = (نوڈ: ٹرینوڈ | null) => {if (نوڈ) {traverse (node.left) ؛گنتی ++ ؛اگر (گنتی === K) {نتیجہ = نوڈ.وال ؛واپسی ؛} ٹراورس (نوڈ. رائٹ) ؛}} ؛عبور (جڑ) ؛واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بائنری سرچ ٹری میں ایک نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ایک ویل پراپرٹی ، اور بالترتیب بائیں اور دائیں بچوں کے نوڈس کے لئے بائیں اور دائیں خصوصیات کے ساتھ۔اس کے بعد ہم ایک Kthsmallest فنکشن کی وضاحت کرتے ہیں جو جڑ نوڈ اور ایک نمبر K کو دلائل کے طور پر لیتا ہے اور درخت میں کے ٹی ایچ ٹی کے سب سے چھوٹے نوڈ کی قیمت لوٹاتا ہے۔فنکشن سب سے پہلے ایک گنتی متغیر کو 0 اور نتیجہ متغیر 0 پر شروع کرتا ہے۔ اس کے بعد فنکشن ایک بار بار چلنے والے ٹراورس فنکشن کی وضاحت کرتا ہے جو درخت کے نوڈس کو آرڈر میں کرتا ہے ، ہر ملاحظہ کرنے والے نوڈ کے لئے گنتی متغیر کو بڑھاتا ہے ، اور جانچ پڑتال کرتا ہے کہ آیا گنتی متغیر ہے یا نہیںK کے برابر ہے۔اگر گنتی متغیر K کے برابر ہے تو ، نتیجہ متغیر موجودہ نوڈ کی قیمت پر سیٹ کیا جاتا ہے ، اور فنکشن واپس آجاتا ہے۔ٹریورس فنکشن کو روٹ نوڈ کے ساتھ دلیل کے طور پر بلایا جاتا ہے ، اور اس کے نتیجے میں نتیجہ متغیر واپس ہوجاتا ہے۔ یہاں کے ٹی ایچ ایس ایم ایلسٹ فنکشن کی ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ جڑ = نیا ٹرینوڈ (3) ؛ روٹ.فیلٹ = نیا ٹرینوڈ (1) ؛ روٹ روٹ. رائٹ = نیا ٹرینوڈ (4) ؛ روٹ. لیفٹ. رائٹ = نیا ٹرینوڈ (2) ؛ کانسٹ K = 1 ؛ کانسٹ Kthsmallestnode = Kthsmallest (جڑ ، کے) ؛ کنسول.لوگ (kthsmallestnode) ؛// اس مثال کے طور پر ، ہم 3 کی جڑ نوڈ ویلیو کے ساتھ ایک نیا بائنری سرچ ٹری تیار کرتے ہیں ، ایک بائیں بچے کا نوڈ 1 کی قیمت ، 4 کی قیمت والا دائیں بچے کا نوڈ ، اور بائیں بچے کا دائیں بچے کا نوڈنوڈ 2 کی قیمت کے ساتھ۔ ہم پھر 1 کی قیمت کے ساتھ ایک نمبر K کی وضاحت کرتے ہیں ، اور Kthsmallest فنکشن کو جڑ نوڈ اور K کے ساتھ دلائل کے طور پر کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر Kthsmallestnode کو تفویض کرتے ہیں۔آخر میں ، ہم Kthsmallestnode کی قدر کو کنسول میں لاگ ان کریں ، جو 1.1Interviewibit2techidelight3stackoverflow4techidelight5TakeUforward ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کو نافذ کرنے کے لئے ایک وسیلہ میکولالیسینکو/طبقہ کا درخت گٹ ہب ریپوزٹری 1 ہے۔یہ ذخیرہ تازہ کاریوں کے ساتھ رن لمبائی انکوڈ شدہ صفوں کو ذخیرہ کرنے کے لئے ایک طبقہ کے درخت کا کم سے کم عمل درآمد فراہم کرتا ہے۔یہاں طبقہ کے درخت پیکیج کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ سیگمنٹ ٹری = ضرورت ('طبقہ-ٹری') ؛ Const arr = [1 ، 2 ، 3 ، 4 ، 5] const کانس ٹری = نیا طبقہ (AR ، B ، (a ، b) => a + b) ؛ کنسول.لوگ (درخت.کیری (0 ، 2)) ؛// 6console.log (درخت.کوری (2 ، 4)) ؛// 12tree.update (2 ، 10) ؛ کنسول.لاگ (درخت.کیری (0 ، 4)) ؛// 22 ان مثال کے طور پر ، ہم سب سے پہلے ضرورت () کا استعمال کرتے ہوئے طبقہ کے درخت پیکیج کو درآمد کرتے ہیں۔اس کے بعد ہم اقدار [1] [2] [3] [4] [5] کی اقدار کے ساتھ ایک نیا سرنی آر آر تیار کرتے ہیں ، اور اے آر آر کے ساتھ ایک نیا سیگمنٹ ٹری مثال تیار کرتے ہیں اور ایک ایسا فنکشن جو دو اقدار کا مجموعہ واپس کرتا ہے۔اس کے بعد ہم درخت آبجیکٹ کے استفسار () کے طریقہ کار کو رینج [0] [2] اور [2] [4] کے ساتھ کال کرتے ہیں ، جو حد میں اقدار کا مجموعہ لوٹاتا ہے۔آخر میں ، ہم انڈیکس 2 سے 10 پر قیمت کو اپ ڈیٹ کرنے کے لئے درخت آبجیکٹ کے اپ ڈیٹ () طریقہ کو کال کرتے ہیں ، اور اس بات کی تصدیق کے لئے دوبارہ استفسار () کے طریقہ کار کو کال کریں کہ اپ ڈیٹ کامیاب ہے۔ ٹائپ اسکرپٹ میں طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کرنے کے لئے دوسرا وسائلLugriz/ٹائپ اسکرپٹ-الگوریتھم گٹ ہب ریپوزٹری 2 ہے۔یہ ذخیرہ ٹائپ اسکرپٹ میں مختلف ڈیٹا ڈھانچے اور الگورتھم کے نفاذ فراہم کرتا ہے ، جس میں ایک طبقہ کا درخت بھی شامل ہے جس میں کم سے کم/زیادہ سے زیادہ/رقم کی حد سے متعلق سوالات کی مثالیں ہیں۔یہاں سیگمنٹ ٹری کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کلاس سیگمنٹٹری {درخت: نمبر [] ؛N: نمبر ؛کنسٹرکٹر (ARR: نمبر []) {this.n = arr.length ؛this.tree = نئی صف (this.n * 2) ؛کے لئے (آئیے i = 0 ؛ i <this.n ؛ i ++) {this.tree [this.n+i] = arr [i] ؛} کے لئے (آئیے i = this.n-1 ؛ i> 0 ؛ i--) {this.tree [i] = this.tree [i * 2] + this.tree [i * 2 + 1] ؛}} استفسار (L: نمبر ، R: نمبر): نمبر {آئیے سم = 0 ؛l += this.n ؛r += this.n ؛جبکہ (l <= r) {اگر (l ٪ 2 === 1) {رقم += this.tree [l] ؛l ++ ؛} if (r ٪ 2 === 0) {رقم += this.tree [r] ؛r-- ؛} l /= 2 ؛r /= 2 ؛} رقم واپس ؛}} constr arr = [1 ، 2 ، 3 ، 4 ، 5] const const درخت = نیا طبقہ ٹری (arr) ؛ کنسول.لوگ (درخت.کیری (0 ، 2)) ؛// 6console.log (درخت.کوری (2 ، 4)) ؛// 12 میں اس مثال کے طور پر ، ہم ایک سیگمنٹ ٹری کلاس کی وضاحت کرتے ہیں جو طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے۔کلاس کا کنسٹرکٹر ایک دلیل کے طور پر ایک سرنی آر آر لیتا ہے اور کلاس کی درختوں کی جائیداد کو اے آر آر کی اقدار کے ساتھ شروع کرتا ہے ، اور پھر بچوں کے نوڈس کے ہر جوڑے کی رقم کا حساب کتاب کرکے طبقہ کے درخت کو بناتا ہے۔کلاس کے استفسار () کا طریقہ دو اشارے L اور R کو دلائل کے طور پر لیتا ہے اور حد [L ، R] میں اقدار کا مجموعہ واپس کرتا ہے۔اس کے بعد ہم اقدار [1] [2] [3] [4] [5] کے ساتھ ایک نیا سرنی آر آر تیار کرتے ہیں ، اور اے آر آر کے ساتھ ایک نیا سیگمنٹ ٹری مثال تیار کرتے ہیں۔آخر میں ، ہم درخت آبجیکٹ کے استفسار () کے طریقہ کار کو رینج [0] [2] اور [2] [4] کے ساتھ کال کرتے ہیں ، جو حد میں اقدار کا مجموعہ واپس کرتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا کوئی گراف ٹائپ اسکرپٹ کا استعمال کرتے ہوئے درخت ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی گراف ٹائپ اسکرپٹ کا استعمال کرتے ہوئے درخت ہے یا نہیں ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: چیک کریں کہ گراف ایکائکلک ہے یا نہیں ، یعنی ، اس میں کوئی سائیکل نہیں ہے۔ چیک کریں اگر گراف منسلک ہے ، یعنی ، کسی کے مابین کوئی راستہ موجود ہے۔گراف میں دو عمودی۔ اگر دونوں شرائط درست ہیں تو ، پھر گراف ایک درخت ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال ہے: ٹائپ اسکرپٹ کلاس گراف {نجی عمودی: نمبر ؛نجی ایڈجسٹ: نقشہ <نمبر ، نمبر []> ؛کنسٹرکٹر (عمودی: نمبر) {this.vertices = عمودی ؛this.adjlist = نیا نقشہ <نمبر ، نمبر []> () ؛کے لئے (آئیے i = 0 ؛ i <عمودی ؛ i ++) {this.adjlist.set (i ، []) ؛}} ایڈجڈ (v: نمبر ، ڈبلیو: نمبر) {this.adjlist.get (v)؟. پش (ڈبلیو) ؛this.adjlist.get (w)؟. پش (v) ؛} iscyclicutil (v: نمبر ، ملاحظہ: بولین [] ، والدین: نمبر): بولین {ملاحظہ کیا [v] = سچ ؛const adj = this.adjlist.get (v) ؛کے لئے (آئیے i = 0 ؛ i <adj! .length ؛ i ++) {const n = adj! [i] ؛اگر (! ملاحظہ کیا گیا [n]) {اگر (this.iscyclicutil (n ، ملاحظہ کیا گیا ، v)) {سچ واپس ؛}} ورنہ اگر (n! == والدین) {سچ واپس ؛}} غلط لوٹائیں ؛} iscyclic (): بولین {Const visoded = new array <wolean> (this.vertices). مکمل (غلط) ؛کے لئے (i = 0 ؛ i <this.vertices ؛ i ++) {اگر (! ملاحظہ کیا [i]) {اگر (this.iscyclicutil (i ، ملاحظہ کیا گیا ، -1)) {سچ واپس ؛}}} غلط واپس ؛} iStree (): بولین {اگر (this.iscyclic ()) {غلط لوٹ ؛} کانسٹ ملاحظہ کریں = نئی سرنی <بولین> (this.vertices). مکمل (غلط) ؛کانسٹ قطار = [] ؛قطار.پش (0) ؛جبکہ (قطار۔ لمبائی> 0) {const v = قطار.شفٹ () !؛دورہ [v] = سچ ؛const adj = this.adjlist.get (v) ؛کے لئے (آئیے i = 0 ؛ i <adj! .length ؛ i ++) {const n = adj! [i] ؛اگر (! ملاحظہ کیا [n]) {ملاحظہ کیا [n] = سچ ؛قطار۔ پش (این) ؛}}} کے لئے (آئیے i = 0 ؛ i <this.vertices ؛ i ++) {اگر (! ملاحظہ کیا [i]) {غلط واپس ؛}} سچ واپس ؛}} اس مثال میں ، ہم ایک گراف کلاس کی وضاحت کرتے ہیں جو غیر ہدایت شدہ گراف کی نمائندگی کرتا ہے۔کلاس میں ایک کنسٹرکٹر ہوتا ہے جو ایک دلیل کے طور پر عمودی کی تعداد لیتا ہے اور گراف کے لئے ملحقہ فہرست کو شروع کرتا ہے۔کلاس کے پاس گراف میں کناروں کو شامل کرنے ، یہ چیک کرنے کے طریقے بھی ہیں کہ آیا گراف چکر ہے یا نہیں ، اور یہ چیک کرنا کہ گراف درخت ہے یا نہیں۔iscyclicutil () کا طریقہ ایک مددگار طریقہ ہے جو گہرائی کی پہلی تلاش کرتا ہے تاکہ یہ معلوم کیا جاسکے کہ گراف میں کوئی سائیکل موجود ہے یا نہیں۔گراف میں ہر غیر منحصر عمودی کے لئے iscyclic () طریقہ iscyclicutil () کو کال کرتا ہے ، اور اگر کوئی سائیکل مل جاتا ہے تو وہ سچ واپس آجاتا ہے۔iStree () کا طریقہ پہلے چیک کرتا ہے کہ اگر گراف چکر ہے ، اور اگر یہ ہے تو غلط لوٹاتا ہے۔اس کے بعد یہ طریقہ یہ چیک کرنے کے لئے چوڑائی کی پہلی تلاش کرتا ہے کہ آیا گراف منسلک ہے ، اور اگر یہ ہے تو یہ سچ ہے۔ گراف کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹ کونسٹ گراف = نیا گراف (5) ؛ گراف.ڈیج (1 ، 0)؛ گراف.اڈیج (0 ، 2) ؛ گراف.اڈیج (0 ، 3) ؛ گراف.ڈیج (3 ، 4) ؛ کانسٹسٹ آئسٹری = گراف.سٹری () ؛ کنسول.لوگ (آئسٹری) ؛// اس مثال کے طور پر ، ہم 5 عمودی کے ساتھ ایک نیا گراف مثال تیار کرتے ہیں ، اور درخت بنانے کے لئے گراف میں کناروں کو شامل کرتے ہیں۔اس کے بعد ہم گراف آبجیکٹ کے iStree () کے طریقہ کار کو کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر istree کو تفویض کرتے ہیں۔آخر میں ، ہم آئسٹری کی قدر کو کنسول میں لاگ ان کرتے ہیں ، جو سچ ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں فبونیکی ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں فبونیکی ہیپ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے بہت سارے وسائل دستیاب ہیں۔یہاں کچھ مثالیں ہیں: GWTW/TS-Fibonacci-HEAP Github repository: یہ Fibonacci ہیپ ڈیٹا ڈھانچے کا ٹائپ اسکرپٹ عمل ہے جو تمام عام ہیپ آپریشنز کی حمایت کرتا ہے ، اختیاری وابستہ اقدار کے ساتھ کیز کی چابیاں ، اور اس میں 100 test ٹیسٹ کوریج ہے۔ذخیرہ میں ایک اختیاری کسٹم موازنہ فنکشن بھی شامل ہے جو کلیدی اور قدر دونوں کو استعمال کرسکتا ہے۔پیکیج میں تمام عام ہیپ آپریشنز شامل ہیں اور اختیاری وابستہ اقدار کے ساتھ ذخیرہ کرنے والی چابیاں کی حمایت کرتی ہے۔ فبونیکی ہیپ پر پروگرامیز آرٹیکل: یہ ایک ایسا مضمون ہے جو فبونیکی ہیپ ڈیٹا ڈھانچے اور اس کی خصوصیات کی وضاحت کرتا ہے۔مضمون میں فبونیکی ہیپ میں موجود درختوں کی خصوصیات کی تفصیل ، ڈھیر کے ذریعہ تعاون یافتہ موثر ہیپ آپریشنز ، اور ٹائپ اسکرپٹ 23 میں فبونیکی ہیپ۔ ڈیٹا ڈھانچے کی اہم خصوصیات۔ویڈیو ٹیوٹوریل جو ٹائپ اسکرپٹ میں فبونیکی ہیپ ڈیٹا ڈھانچے کے نفاذ کی وضاحت کرتا ہے۔ویڈیو میں فبونیکی ہیپ کے بنیادی تصورات ، ڈھیر کے نفاذ ، اور ٹائپ اسکرپٹ 22 میں ہیپ ڈاٹ ڈیٹا ڈھانچے کے ذریعہ تعاون کردہ عام ہیپ آپریشنوں کا احاطہ کیا گیا ہے۔ٹائپ اسکرپٹ میں fibonacci ہیپ ڈیٹا ڈھانچہ۔ویڈیو میں فبونیکی ہیپ کے بنیادی تصورات ، ڈھیر کی خصوصیات ، اور ڈھیر کے ذریعہ تعاون یافتہ موثر ہیپ آپریشنز کا احاطہ کیا گیا ہے۔ یہ وسائل ٹائپ اسکرپٹ میں فبونیکی ہیپ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے مختلف نقطہ نظر فراہم کرتے ہیں ، لہذا آپ اس بہترین کو منتخب کرسکتے ہیں۔آپ کی ضروریات کو پورا کرتا ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ٹری پر پوسٹ آرڈر ٹری ٹریورسل کو انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں بائنری ٹری پر پوسٹ آرڈر کے درخت کے ٹریورسل کو انجام دینے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: بائیں سب ٹری کو بار بار عبور کریں۔ دائیں سب ٹری کو بار بار رجوع کریں۔ جڑ نوڈ کو دیکھیں۔{ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = (ویل === غیر متعینہ؟ 0: ویل) ؛this.left = (بائیں === غیر متعینہ؟ null: بائیں) ؛this.right = (دائیں === غیر متعینہ؟ null: صحیح) ؛}} فنکشن پوسٹ آرڈر ٹراورسال (جڑ: ٹرینوڈ | null): نمبر [] {کانسٹنگ نتیجہ: نمبر [] = [] ؛Const traverse = (نوڈ: ٹرینوڈ | null) => {if (نوڈ) {traverse (node.left) ؛traverse (node.right) ؛نتیجہ.پش (نوڈ.وال) ؛}} ؛عبور (جڑ) ؛واپسی کا نتیجہ ؛} اس مثال کے طور پر ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ویل پراپرٹی ، اور بالترتیب بائیں اور دائیں بچوں کے نوڈس کے لئے بائیں اور دائیں خصوصیات کے ساتھ۔اس کے بعد ہم ایک پوسٹ آرڈر ٹراورسل فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر جڑ نوڈ لیتا ہے اور پوسٹ آرڈر میں نوڈ اقدار کی ایک صف لوٹاتا ہے۔فنکشن سب سے پہلے نوڈ کی اقدار کو ذخیرہ کرنے کے لئے خالی صف کے نتائج کی ابتدا کرتا ہے۔اس کے بعد یہ فنکشن ایک بار بار چلنے والے ٹراورس فنکشن کی وضاحت کرتا ہے جو پوسٹ آرڈر میں درخت کے نوڈس کا دورہ کرتا ہے ، پہلے بائیں سب ٹری کو بار بار گھس کر ، پھر دائیں سب ٹری کو بار بار عبور کرتے ہوئے ، اور آخر میں جڑ کے نوڈ کا دورہ کرتا ہے۔ٹراورس فنکشن کو روٹ نوڈ کے ساتھ دلیل کے طور پر بلایا جاتا ہے ، اور اس کے نتیجے میں نتیجہ سرنی واپس کردی جاتی ہے۔ یہاں پوسٹ آرڈر ٹراورسل فنکشن کی ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ روٹ = نیا ٹرینوڈ (1) ؛ روٹ۔ رائٹ = نیا ٹرینوڈ (2) ؛ روٹ روٹ.Right.left = نیا ٹرینوڈ (3) Cont const postorder = postordertraversal (جڑ) ؛ کنسول.لوگ (پوسٹ آرڈر) ؛// [3 ، 2 ، 1] اس مثال میں ، ہم 1 کی جڑ نوڈ ویلیو کے ساتھ ایک نیا بائنری ٹری تیار کرتے ہیں ، ایک دائیں بچے کا نوڈ جس کی قیمت 2 ہے ، اور دائیں بچے کے نوڈ کا بائیں بچے کا نوڈ ایک قیمت کے ساتھ ہے۔اس کے بعد ہم پوسٹ آرڈر ٹریورسل فنکشن کو روٹ نوڈ کے ساتھ دلیل کے طور پر کہتے ہیں ، اور نتیجہ کو ایک نئے متغیر پوسٹڈر کو تفویض کرتے ہیں۔آخر میں ، ہم پوسٹ آرڈر کی قیمت کو کنسول میں لاگ ان کرتے ہیں ، جو [3] [2] [1] .1educative2codegreper3gitconnected4Enayalgorithms5techeidelight ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ہدایت شدہ ایسائکلک گراف کے لئے ایک ٹوپولوجیکل ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ہدایت شدہ ایسائکلک گراف کے لئے ٹوپولوجیکل ترتیب والے الگورتھم کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: گراف میں موجود تمام نوڈس تلاش کریں جس میں آنے والے کناروں نہیں ہیں ، یعنی نوڈس پر انحصار نہیں ہے۔خالی نہیں ، قطار سے ایک نوڈ کو ہٹا دیں اور اسے ترتیب شدہ فہرست میں شامل کریں۔ ہر نوڈ کے لئے جو ہٹائے گئے نوڈ سے ملحق ہے ، ان کے درمیان کنارے کو ہٹا دیں۔ اگر ملحقہ نوڈ میں آنے والے کنارے نہیں ہیں تو اسے قطار میں شامل کریں۔جب تک قطار خالی نہ ہو تب تک 3-5 اقدامات کو دہرائیں۔ اگر ترتیب شدہ فہرست میں گراف میں موجود تمام نوڈس شامل ہوں تو ، ترتیب شدہ فہرست کو واپس کریں۔بصورت دیگر ، گراف میں ایک سائیکل ہوتا ہے اور ایک ٹوپولوجیکل قسم ممکن نہیں ہوتا ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال عمل ہے: ٹائپ اسکرپٹ کلاس گراف {نجی عمودی: نمبر ؛نجی ایڈجسٹ: نقشہ <نمبر ، نمبر []> ؛کنسٹرکٹر (عمودی: نمبر) {this.vertices = عمودی ؛this.adjlist = نیا نقشہ <نمبر ، نمبر []> () ؛کے لئے (آئیے i = 0 ؛ i <عمودی ؛ i ++) {this.adjlist.set (i ، []) ؛}} ایڈجڈ (v: نمبر ، ڈبلیو: نمبر) {this.adjlist.get (v)؟. پش (ڈبلیو) ؛} ٹوپولوجسٹسورٹ (): نمبر [] |null {const indegree = new array <number> (this.vertices) .fill (0) ؛کے لئے (آئیے i = 0 ؛ i <this.vertices ؛ i ++) {const adj = this.adjlist.get (i) ؛کے لئے (j = 0 ؛ j <adj! .length ؛ j ++) {const n = adj! [j] ؛انڈریگری [n] ++ ؛}} کانسٹ قطار = [] ؛کے لئے (آئیے i = 0 ؛ i <this.vertices ؛ i ++) {اگر (انڈریگری [i] === 0) {قطار.پش (i) ؛}} کانسٹنگ نتیجہ = [] ؛جبکہ (قطار۔ لمبائی> 0) {const v = قطار.شفٹ () !؛نتیجہ۔ پش (v) ؛const adj = this.adjlist.get (v) ؛کے لئے (آئیے i = 0 ؛ i <adj! .length ؛ i ++) {const n = adj! [i] ؛indgree [n]-؛if (indegree [n] === 0) {قطار.پش (n) ؛}}} if (نتیجہ. لمبائی! == this.vertices) {واپس کالعدم ؛} واپسی کا نتیجہ ؛}} اس مثال میں ، ہم ایک گراف کلاس کی وضاحت کرتے ہیں جو ہدایت شدہ گراف کی نمائندگی کرتا ہے۔کلاس میں ایک کنسٹرکٹر ہوتا ہے جو ایک دلیل کے طور پر عمودی کی تعداد لیتا ہے اور گراف کے لئے ملحقہ فہرست کو شروع کرتا ہے۔کلاس کے پاس گراف میں کناروں کو شامل کرنے اور گراف پر ٹوپولوجیکل ترتیب دینے کے طریقے بھی ہیں۔ٹاپولوجسٹورٹ () کا طریقہ پہلے گراف میں ہر ایک ورٹیکس کی ڈگری کا حساب لگاتا ہے ، یعنی ہر ایک کے لئے آنے والے کناروں کی تعداد۔اس کے بعد یہ طریقہ ان تمام عمودیوں کے ساتھ ایک قطار کا آغاز کرتا ہے جس میں 0 کی ڈگری ہوتی ہے۔ اس کا طریقہ کار پھر ایک لوپ میں داخل ہوتا ہے جو قطار سے ایک چوٹی کو ہٹاتا ہے ، اسے ترتیب شدہ فہرست میں شامل کرتا ہے ، اور ورٹیکس اور اس سے ملحقہ عمودی کے درمیان کناروں کو ہٹاتا ہے۔اگر ملحقہ ورٹیکس کے پاس آنے والے کنارے نہیں ہیں تو ، اسے قطار میں شامل کیا جاتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ قطار خالی نہ ہو۔اگر ترتیب شدہ فہرست میں گراف میں موجود تمام عمودی حصے شامل ہیں تو ، طریقہ ترتیب شدہ فہرست لوٹاتا ہے۔بصورت دیگر ، گراف میں ایک سائیکل ہوتا ہے اور ایک ٹوپولوجیکل قسم ممکن نہیں ہوتا ہے ، لہذا یہ طریقہ کار کو واپس کرتا ہے۔ گراف کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ گراف = نیا گراف (6) ؛ گراف.ڈیج (5 ، 2) ؛ گراف۔ایڈجڈ (5 ، 0) ؛ گراف.اڈیج (4 ، 0) ؛ گراف.اڈیج (4 ، 1) ؛ گراف.اڈیج (2 ، 3) ؛ گراف.اڈیج (3 ، 1) ؛ ترتیب ترتیب = گراف.ٹوپولوجیکل ریسورٹ () ؛ کنسول.لوگ (ترتیب شدہ) ؛// [4 ، 5 ، 2 ، 0 ، 3 ، 1] اس مثال میں ، ہم 6 عمودی کے ساتھ ایک نیا گراف مثال تیار کرتے ہیں ، اور ہدایت شدہ ایسائکلک گراف بنانے کے لئے گراف میں کناروں کو شامل کرتے ہیں۔اس کے بعد ہم گراف آبجیکٹ کے ٹوپولوجسٹورٹ () کے طریقہ کار کو کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر کو ترتیب دیا گیا ہے۔آخر میں ، ہم کنسول میں ترتیب دیئے گئے قیمت کو لاگ ان کریں ، جو [1] [2] [3] [4] [5]"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عدد کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ان پٹ سرنی کی طرح لمبائی کے ایک سرنی ڈی پی کی وضاحت کرسکتے ہیں ، جہاں ڈی پی [i] انڈیکس I پر ختم ہونے والے طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی کی نمائندگی کرتا ہے۔اس کے بعد ہم ان پٹ سرنی کے ذریعے تکرار کرسکتے ہیں ، اور ہر انڈیکس I کے ل we ، ہم پچھلے انڈیکس جے کے ذریعہ I سے کم تکرار کرسکتے ہیں ، اور یہ چیک کرسکتے ہیں کہ انڈیکس جے میں قیمت انڈیکس I کی قیمت سے کم ہے یا نہیں۔اگر یہ ہے تو ، ہم DP [i] کو زیادہ سے زیادہ DP [I] اور DP [J] + 1. میں اپ ڈیٹ کرسکتے ہیں۔ آخر میں ، ہم DP سرنی میں زیادہ سے زیادہ قیمت واپس کرسکتے ہیں۔: ٹائپ اسکرپٹ فنکشن سب سے طویل عرصے سے متعلقہ استعمال (نمبر: نمبر []): نمبر {const n = nums.length ؛کانسٹ ڈی پی = نئی سرنی <نمبر> (این). فل (1) ؛آئیے زیادہ سے زیادہ = 1 ؛کے لئے (i = 1 ؛ i <n ؛ i ++) {for (j = 0 ؛ j <i ؛ j ++) {اگر (nums [j] <nums [i]) {dp [i] = math.max (ڈی پی [i] ، dp [j] + 1) ؛}} زیادہ سے زیادہ = math.max (زیادہ سے زیادہ ، DP [i]) ؛} میکس کی واپسی ؛ اس مثال کے طور پر ، ہم ایک طویل عرصے سے متعلقہ کام کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر نمبر نمبروں کی ایک صف لیتا ہے اور نمبروں میں طویل عرصے تک بڑھتے ہوئے بڑھتے ہوئے حصول کی لمبائی کو لوٹاتا ہے۔فنکشن سب سے پہلے اسی لمبائی کے ایک سرنی ڈی پی کی ابتدا کرتا ہے جیسے نمبروں کی طرح ہوتا ہے ، جہاں ڈی پی [i] انڈیکس I پر ختم ہونے والے طویل ترین بڑھتے ہوئے متضاد کی لمبائی کی نمائندگی کرتا ہے ، اور ڈی پی کے ہر عنصر کو 1. شروع کرتا ہے۔ہر انڈیکس I کے ذریعہ نمبر میں ، اور ہر انڈیکس I کے لئے ، پچھلے انڈیکس جے کے ذریعے I سے کم ہوتا ہے ، اور چیک کرتا ہے کہ اگر انڈیکس جے کی قیمت انڈیکس I کی قیمت سے کم ہے تو۔اگر یہ ہے تو ، فنکشن ڈی پی [i] کو زیادہ سے زیادہ ڈی پی [i] اور ڈی پی [جے] + 1. کی تازہ کاری کرتا ہے۔ فنکشن ڈی پی سرنی میں زیادہ سے زیادہ قیمت کے ل a ایک متغیر میکس کو بھی اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن میکس کو لوٹاتا ہے۔ طویل عرصے سے متعلقہ فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹ کونسٹ نمبرز = [10 ، 9 ، 2 ، 5 ، 3 ، 7 ، 101 ، 18] const کانسٹیٹ لیسلنتھ = طویل عرصے سے متعلق) ؛// 4 اس مثال کے طور پر ، ہم اقدار [1] [2] [3] [101] کے ساتھ ایک نیا سرنی نمبر تیار کرتے ہیں ، اور دلیل کے طور پر نمبر کے ساتھ طویل عرصے سے متعلقہ فنکشن کو کال کرتے ہیں ، اور نتیجہ کو ایک نئی متغیر لیسنٹ کو تفویض کرتے ہیں۔آخر میں ، ہم کنسول میں لیسلنتھ کی قیمت کو لاگ ان کرتے ہیں ، جو 4.1dev2algodaily3stackoverflow ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں لاحقہ سرنی ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں لاحقہ سرنی ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ان پٹ سٹرنگ کے تمام لاحقہ کی ایک صف تیار کریں۔ لازمی طور پر لاحقہ کی صف کو ترتیب دیں۔ اشارے کی ایک صف تیار کریں جو ترتیب شدہ لاحقہ سے مطابقت رکھتا ہے۔انڈیکس میں۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے نفاذ: ٹائپ اسکرپٹ فنکشن لاحقہ لاحقہ (ایس ٹی آر: سٹرنگ): نمبر [] {const n = str.length ؛کانسٹ لاحقہ = نئی سرنی <سٹرنگ> (این) ؛کے لئے (i = 0 ؛ i <n ؛ i ++) {لاحقہ [i] = str.slice (i) ؛} لاحقہ ۔سورٹ () ؛کانسٹ انڈیکس = نیا سرنی <نمبر> (این) ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اشارے [i] = n - لاحقہ [i]. لمبائی ؛indicates ریٹرن انڈیکس ؛} اس مثال کے طور پر ، ہم ایک لاحقہ فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر سٹرنگ ایس ٹی آر لیتا ہے اور انڈیکس کی ایک صف کو واپس کرتا ہے جو لغت کے مطابق ترتیب سے ترتیب دیئے گئے لاحقہ سے مطابقت رکھتا ہے۔فنکشن سب سے پہلے ایس ٹی آر کے تمام لاحقہ کے ایک سرنی لاحقہ کا آغاز کرتا ہے ، جس میں ہر انڈیکس I سے تار کے اختتام تک STR کا ٹکراؤ ہوتا ہے۔اس کے بعد فنکشن لازمی طور پر لازمی طور پر لازمی طور پر ترتیب دیتا ہے۔اس کے بعد فنکشن ایس ٹی آر جیسی لمبائی کے ایک صف کے اشاریوں کا آغاز کرتا ہے ، جہاں انڈیکس [i] لاحقہ کے انڈیکس کی نمائندگی کرتا ہے جو ترتیب شدہ لاحقہ سرنی میں انڈیکس I سے شروع ہوتا ہے۔اس کے بعد فنکشن اشاریوں کو واپس کرتا ہے۔ یہاں لاحقہ لاحقہ فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ str = 'کیلے' ؛ کانسٹ لاحقہ = لاحقہ (str) ؛ کنسول.لاگ (لاحقہ) ؛// [5 ، 3 ، 1 ، 0 ، 4 ، 4 ، 2] اس مثال میں ، ہم 'کیلے' کی قدر کے ساتھ ایک نیا سٹرنگ STR تیار کرتے ہیں ، اور STR کے ساتھ لاحقہ لاحقہ کو دلیل کے طور پر کال کرتے ہیں ، اور نتیجہ کو ایک نئے کو تفویض کرتے ہیں۔متغیر لاحقہآخر میں ، ہم لاحقہ کی قیمت کو کنسول پر لاگ ان کرتے ہیں ، جو [1] [2] [3] [4] [5]"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری درخت کا قطر تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری درخت کا قطر تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: بائیں سب ٹری کی اونچائی کو بار بار حساب کریں۔ دائیں سب ٹری کی اونچائی کو بار بار پیش کریں۔دائیں سب ٹری بار بار۔{ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = (ویل === غیر متعینہ؟ 0: ویل) ؛this.left = (بائیں === غیر متعینہ؟ null: بائیں) ؛this.right = (دائیں === غیر متعینہ؟ null: صحیح) ؛}} فنکشن ویاٹروف بائنری ٹری (جڑ: ٹرینوڈ | null): نمبر {اجازت دیں قطر = 0 ؛کانسٹ اونچائی = (نوڈ: ٹرینوڈ | null): نمبر => {اگر (! نوڈ) {واپس 0 ؛} کونسٹ لیفٹ ہائٹ = اونچائی (نوڈ.لفٹ) ؛کانسٹ رائٹ ہائٹ = اونچائی (نوڈ. رائٹ) ؛قطر = math.max (قطر ، بائیں بازو + رائٹ ہائٹ) ؛واپس میتھ۔ میکس (بائیں بازو ، رائٹ ہائٹ) + 1 ؛} ؛اونچائی (جڑ) ؛واپسی قطر ؛} اس مثال میں ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ایک ویل پراپرٹی ، اور بالترتیب بائیں اور دائیں بچوں کے نوڈس کے لئے بائیں اور دائیں خصوصیات کے ساتھ۔اس کے بعد ہم ایک قطر کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر جڑ نوڈ لیتا ہے اور بائنری درخت کا قطر واپس کرتا ہے۔فنکشن پہلے متغیر قطر کو 0 پر شروع کرتا ہے۔ اس کے بعد فنکشن ایک بار بار چلنے والی اونچائی کے فنکشن کی وضاحت کرتا ہے جو درخت میں نوڈ کی اونچائی کا حساب لگاتا ہے ، اور قطر کے متغیر کو اپ ڈیٹ کرتا ہے تاکہ بائیں اور دائیں سبٹریس کی اونچائی کی زیادہ سے زیادہ رقم ہو۔، اور قطر کی موجودہ قیمت۔اونچائی کے فنکشن کو روٹ نوڈ کے ساتھ دلیل کے طور پر کہا جاتا ہے ، اور اس کے نتیجے میں قطر کا متغیر واپس ہوجاتا ہے۔ یہاں قطر کے بائنری ٹری فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ روٹ = نیا ٹرینوڈ (1) ؛ روٹ۔ لیفٹ = نیا ٹرینوڈ (2) ؛ روٹ. رائٹ = نیا ٹرینوڈ (3) ؛ روٹ.لفٹ.لفٹ = نیا ٹرینوڈ (4) روٹ.لفٹ. رائٹ = نیا ٹرینوڈ (5) ؛ کانسٹ قطر = قطر قطر بائنری ٹری (جڑ) ؛ کنسول.لوگ (قطر) ؛// 3 اس مثال کے طور پر ، ہم 1 کی جڑ نوڈ ویلیو کے ساتھ ایک نیا بائنری ٹری تیار کرتے ہیں ، ایک بائیں بچے کا نوڈ 2 کی قیمت کے ساتھ ، 3 کی قیمت والا دائیں بچے کا نوڈ ، بائیں بچے کے نوڈ کا بائیں بچے کے نوڈ کے ساتھ بائیں بچے کے نوڈ4 کی قیمت ، اور بائیں بچے کے نوڈ کا دائیں بچے کا نوڈ 5 کی قیمت کے ساتھ۔ پھر ہم روٹ نوڈ کے ساتھ قطر کے نوڈ کے ساتھ قطر کے نوڈ کو دلیل کے طور پر کہتے ہیں ، اور نتیجہ کو ایک نئے متغیر قطر میں تفویض کرتے ہیں۔آخر میں ، ہم قطر کی قیمت کو کنسول پر لاگ ان کریں ، جو 3.1dev2geeksforgeeks3leetcode4codybonney5stackoverflow ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بی+ ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں بی+ ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے لئے بہت سے وسائل دستیاب ہیں۔یہاں کچھ مثالیں ہیں: کیوورٹی/بی ٹری قسم کی اسکرپٹ گٹ ہب ریپوزٹری: یہ معیاری نقشہ پر مبنی ایک طاقتور API کے ساتھ ایک میموری بی+ درخت کا ٹائپ اسکرپٹ عمل ہے۔اس ذخیرے میں چھوٹے چھوٹے کوڈ سائز کے ساتھ ایک اچھی طرح سے دستاویزی کوڈ بیس شامل ہے۔ جاوا اسکرپٹ میں بی ٹری کی تعمیر کے بارے میں کوڈنگ آرٹیکل کو واضح کریں: یہ ایک ایسا مضمون ہے جس میں یہ بتایا گیا ہے کہ جاوا اسکرپٹ میں بی ٹری کی تعمیر کا طریقہ ہے۔مضمون میں جاوا اسکرپٹ اور ایچ ٹی ایم ایل 5 کینوس کا استعمال کرتے ہوئے متحرک بی ٹری بنانے کے طریقوں کے بارے میں ایک مرحلہ وار گائیڈ شامل ہے۔ بی+ ٹری پر وکیپیڈیا آرٹیکل: یہ ایک ایسا مضمون ہے جو بی+ ٹری ڈیٹا ڈھانچے کی وضاحت کرتا ہے۔مضمون میں B+ درخت کی خصوصیات ، B+ درخت کی ساخت ، اور B+ درخت پر عام کارروائیوں کی وقت کی پیچیدگی کی تفصیلی وضاحت شامل ہے۔ یہ وسائل ٹائپ اسکرپٹ میں B+ درخت کے اعداد و شمار کے ڈھانچے کو نافذ کرنے کے لئے مختلف نقطہ نظر فراہم کرتے ہیں ، لہذا آپاس میں سے ایک کا انتخاب کرسکتے ہیں جو آپ کی ضروریات کو بہترین فٹ بیٹھتا ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیئے گئے اسٹرنگ ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک پیلنڈرووم ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک پالندرووم ہے ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: پوائنٹرز کا استعمال: ہم یہ چیک کرنے کے لئے پوائنٹرز کا استعمال کرسکتے ہیں کہ آیا دیئے گئے اسٹرنگ ایک پیلنڈرووم ہے یا نہیں۔ہم دو پوائنٹرز شروع کرسکتے ہیں ، ایک تار کے آغاز میں اور دوسرا تار کے آخر میں۔اس کے بعد ہم دونوں پوائنٹرز کے کرداروں کا موازنہ کرسکتے ہیں ، اور پوائنٹرز کو ایک دوسرے کی طرف لے جا سکتے ہیں جب تک کہ وہ وسط میں نہ ملیں۔اگر تمام حروف مماثل ہیں تو ، تار ایک پیلنڈرووم ہے۔بصورت دیگر ، یہ کوئی پیلنڈرووم نہیں ہے۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن ispalindrome (str: سٹرنگ): بولین {pttr = 0 ؛آئیے Rev = str.length - 1 ؛جبکہ (ptr <Rev) {if (str [ptr]! == str [Rev]) {غلط واپس ؛} ptr ++ ؛Rev-- ؛true سچائی واپس ؛} اس مثال میں ، ہم ایک ispalindrome فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر اسٹرنگ str لیتا ہے اور اگر str ایک palindrome ہے ، اور غلط ہے تو سچائی واپس کرتا ہے۔فنکشن بالترتیب تار کے آغاز اور اختتام تک دو پوائنٹرز ، پی ٹی آر اور ریوی کا آغاز کرتا ہے۔اس کے بعد یہ فنکشن ایک لوپ میں داخل ہوتا ہے جو دو پوائنٹرز کے کرداروں کا موازنہ کرتا ہے ، اور جب تک وہ وسط میں نہیں ملتے اس وقت تک ایک دوسرے کی طرف اشارہ کرتا ہے۔اگر تمام حروف مماثل ہیں تو ، فنکشن سچ واپس آجاتا ہے۔بصورت دیگر ، یہ جھوٹی لوٹتا ہے۔ یہاں ispalindrome فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ str = 'ریسکار' ؛ کانسٹ ispal = ispalindrome (str) ؛ کنسول.لاگ (ispal) ؛// اس مثال کے طور پر ، ہم 'ریسیکار' کی قیمت کے ساتھ ایک نیا سٹرنگ ایس ٹی آر تیار کرتے ہیں ، اور ایس پی ایل کے ساتھ آئسپلنڈرووم فنکشن کو دلیل کے طور پر کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر ispal پر تفویض کرتے ہیں۔آخر میں ، ہم آئی ایس پی اے ایل کی قیمت کو کنسول میں لاگ ان کرتے ہیں ، جو سچ ہونا چاہئے۔ بلٹ ان افعال کا استعمال کرتے ہوئے: ہم یہ بھی جانچنے کے لئے بلٹ ان افعال کا استعمال کرسکتے ہیں کہ آیا دیئے گئے اسٹرنگ ایک پیلنڈرووم ہے یا نہیں۔ہم اسپلٹ ، ریورس ، اور افعال میں شامل ہونے کا استعمال کرتے ہوئے سٹرنگ کو پلٹ سکتے ہیں ، اور الٹ سٹرنگ کا اصل تار کے ساتھ موازنہ کرسکتے ہیں۔اگر وہ ایک جیسے ہیں تو ، تار ایک پیلنڈرووم ہے۔بصورت دیگر ، یہ کوئی پیلنڈرووم نہیں ہے۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 2 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن ispalindrome (str: string): بولین {کانسٹنٹ الٹ = str.split (''). ریورس (). شامل ہوں ('') ؛واپسی str === الٹ ؛} اس مثال کے طور پر ، ہم ایک ispalindrome فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر اسٹرنگ str لیتا ہے اور اگر str ایک palindrome ہے ، اور غلط ہے تو سچائی واپس کرتا ہے۔فنکشن سب سے پہلے اسپلٹ ، ریورس ، اور کاموں میں شامل ہونے کا استعمال کرتے ہوئے سٹرنگ کو تبدیل کرتا ہے ، اور نتیجہ کو ایک نئے متغیر الٹ پلٹ کو تفویض کرتا ہے۔اس کے بعد اس فنکشن کا موازنہ الٹ کے ساتھ کیا جاتا ہے ، اور اگر وہ ایک جیسے ہیں ، اور غلط ہیں۔ اور دوسری صورت میں غلط ہے۔ اسپلائنڈرووم فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹ کونسٹ str = 'ریسیکار' ؛ کانسٹ ispal = ispalindrome (str) ؛ کنسول.لاگ (ispal (ispal.) ؛// اس مثال کے طور پر ، ہم 'ریسیکار' کی قیمت کے ساتھ ایک نیا سٹرنگ ایس ٹی آر تیار کرتے ہیں ، اور ایس پی ایل کے ساتھ آئسپلنڈرووم فنکشن کو دلیل کے طور پر کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر ispal پر تفویض کرتے ہیں۔آخر میں ، ہم آئی ایس پی اے ایل کی قیمت کو کنسول میں لاگ ان کرتے ہیں ، جو سچ ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک MINHEAP طبقے کی وضاحت کریں جو ایک منٹ کے ڈھیر کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے۔ ایک ترجیحی طبقے کی وضاحت کریں جو MINHEAP کلاس کا استعمال کرتے ہوئے ترجیحی قطار کی نمائندگی کرتا ہے۔اس کی ترجیح کی بنیاد پر منٹ کے ڈھیر میں عنصر داخل کرنے کے لئے ترجیحی طبقاتی طبقے کو محدود کریں۔t> {نجی ڈھیر: t [] ؛نجی موازنہ: (a: t ، b: t) => نمبر ؛کنسٹرکٹر (موازنہ: (a: t ، b: t) => نمبر) {this.heap = [] ؛this.compare = موازنہ ؛} نجی getleftchildindex (انڈیکس: نمبر): نمبر {واپسی 2 * انڈیکس + 1 ؛} نجی getRightChildindex (انڈیکس: نمبر): نمبر {واپسی 2 * انڈیکس + 2 ؛} نجی getParentIndex (انڈیکس: نمبر): نمبر {ریٹرن میتھ.فلور ((انڈیکس - 1) / 2) ؛} نجی سیفٹ اپ (انڈیکس: نمبر) {اگر (انڈیکس === 0) {واپسی ؛} CONT پیرنٹ انڈیکس = this.getParentIndex (انڈیکس) ؛اگر (this.compare (this.heap [parentIndex] ، this.heap [index])> 0) {[this.heap [parentindex] ، this.heap [انڈیکس]] = [this.heap [انڈیکس] ، یہ۔ڈھیر [پیرنٹ انڈیکس]] ؛this.siftup (parentIndex) ؛}} پرائیویٹ سیفٹ ڈاون (انڈیکس: نمبر) {کونٹ لیفٹائڈ انڈیکس = this.getleftchildindex (انڈیکس) ؛کونٹ رائٹچلڈ انڈیکس = this.getRightChildindex (انڈیکس) ؛آئیے MININDEX = انڈیکس ؛اگر (لیفٹائلڈ انڈیکس <this.heap.length && this.com.compare (this.heap [lifechildIndex] ، this.heap [MinIndex]) <0) {MinIndex = lefthildIndex ؛} اگر (رائٹچلڈ انڈیکس <this.heap.length && this.compare (this.heap [RightichildIndex] ، this.heap [MinIndex]) <0) {MinIndex = RightChildIndex ؛} if (minidex! == انڈیکس) {[this.heap [index] ، this.heap [minidex]] = [this.heap [minidex] ، this.heap [انڈیکس]] ؛یہ۔}} داخل کریں (قدر: t) {this.heap.push (ویلیو) ؛this.siftup (this.heap.length - 1) ؛} ایکسٹریکٹ مین (): ٹی |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛} if (this.heap.length === 1) {اس کو واپس کریں۔} const min = this.heap [0] ؛this.heap [0] = this.heap.pop () !؛this.siftdown (0) ؛واپسی منٹ ؛size سائز () حاصل کریں: نمبر {اس کو واپس کریں۔class} کلاس کی ترجیح <t> {نجی MINHEAP: MINHEAP <{قدر: t ، ترجیح: نمبر}> ؛کنسٹرکٹر () {this.minHeap = نیا MINHEAP <{value: t ، ترجیح: نمبر}> ((a ، b) => a.priority - b.priority) ؛} enqueue (value: t ، ترجیح: نمبر) {this.minheap.insert ({قدر ، ترجیح}) ؛} dequeue (): t |غیر وضاحتی {کانسٹ من = this.minheap.extractmin () ؛کم منٹ؟min.value: غیر متعینہ ؛size سائز () حاصل کریں: نمبر {اس کو واپس کریں۔}} اس مثال میں ، ہم ایک مینی ہاپ کلاس کی وضاحت کرتے ہیں جو ایک منٹ کے ڈھیر کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے ، جس میں ڈھیر سے کم سے کم عنصر داخل کرنے اور نکالنے کے طریقے ہوتے ہیں۔اس کے بعد ہم ایک ترجیحی طبقے کی وضاحت کرتے ہیں جو MINHEAP کلاس کا استعمال کرتے ہوئے ترجیحی قطار کی نمائندگی کرتا ہے ، جس میں ان کی ترجیح کی بنیاد پر عناصر کو ختم کرنے اور ان کو ختم کرنے کے طریقوں کے ساتھ۔انکیو کا طریقہ اپنی ترجیح کی بنیاد پر من ڈھیر میں ایک عنصر کو داخل کرتا ہے ، اور ڈیکیو طریقہ کار کو کم سے زیادہ ترجیح کے ساتھ عنصر کو ہٹا دیتا ہے۔ یہاں ترجیحی کیوئیو کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ پی کیو = نئی ترجیح <سٹرنگ> () ())؛ pq.enqueue ('foo' ، 2) ؛ pq.enqueue ('بار' ، 1) ؛ pq.enqueue ('باز' ، 3) ؛ کنسول.لوگ (pq.dequeue ()) ؛// 'بار'کنسول.لوگ (pq.dequeue ()) ؛// 'foo'console.log (pq.dequeue ()) ؛// 'باز' اس مثال کے طور پر ، ہم ایک نئی ترجیحی مثال تیار کرتے ہیں ، اور بالترتیب ترجیحات 2 ، 1 ، اور 3 کے ساتھ تین عناصر کو بالترتیب تیار کرتے ہیں۔اس کے بعد ہم تین بار ڈیکو کے طریقہ کار کو کال کرتے ہیں ، اور لوٹے ہوئے اقدار کو کنسول میں لاگ ان کرتے ہیں ، جو 'بار' ، 'فو' ، اور 'باز' ہونا چاہئے ، اس ترتیب میں۔"
    },
    {
        "Question": "اس بات کا پتہ لگانے کے لئے ایک پروگرام لکھیں کہ آیا بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری سرچ ٹری ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری سرچ ٹری ہے ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: بائنری ٹری کو آرڈر میں منتقل کریں ، اور نوڈس کی اقدار کو ایک صف میں اسٹور کریں۔ چیک کریں کہ اگر سرنی چڑھائی ترتیب میں ترتیب دی گئی ہے تو چیک کریں۔اگر یہ ہے تو ، بائنری ٹری بائنری تلاش کا درخت ہے۔بصورت دیگر ، یہ بائنری تلاش کا درخت نہیں ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال ہے: ٹائپ اسکرپٹ کلاس ٹرینوڈ {ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = (ویل === غیر متعینہ؟ 0: ویل) ؛this.left = (بائیں === غیر متعینہ؟ null: بائیں) ؛this.right = (دائیں === غیر متعینہ؟ null: صحیح) ؛}} فنکشن isbinarysearchtree (جڑ: Treenode | null): بولین {Const values: نمبر [] = [] ؛Inordertraversal = (نوڈ: treenode | null) => {if (! نوڈ) {واپسی ؛} inordertraversal (node.left) ؛ویلیوز.پش (نوڈ.وال) ؛inordertraversal (node.right) ؛} ؛inordertraversal (جڑ) ؛کے لئے (آئیے i = 1 ؛ i <values.length ؛ i ++) {اگر (اقدار [i] <اقدار [i - 1]) {غلط واپس ؛}} سچائی واپس ؛} اس مثال میں ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ایک ویل پراپرٹی ، اور بالترتیب بائیں اور دائیں بچوں کے نوڈس کے لئے بائیں اور دائیں خصوصیات کے ساتھ۔اس کے بعد ہم ایک isbinarysearchtree فنکشن کی وضاحت کرتے ہیں جو جڑ کے نوڈ کو ایک دلیل کے طور پر لیتا ہے اور اگر بائنری کا درخت بائنری تلاش کا درخت ہے ، اور غلط ہے تو سچائی واپس آجاتا ہے۔فنکشن سب سے پہلے بائنری درخت میں نوڈس کی اقدار کو ذخیرہ کرنے کے لئے خالی صف کی اقدار کی ابتدا کرتا ہے۔اس کے بعد یہ فنکشن ایک بار بار چلنے والے inordertraversal فنکشن کی وضاحت کرتا ہے جو بائنری ٹری کو آرڈر میں عبور کرتا ہے ، اور نوڈس کی اقدار کو اقدار کی سرنی میں دھکیل دیتا ہے۔اس کے بعد یہ کام چیک کرتا ہے کہ اگر اقدار کی سرنی کو چڑھائی ترتیب میں ترتیب دیا گیا ہے ، اور اگر یہ ہے تو یہ سچ ہے ، اور دوسری صورت میں غلط ہے۔ اس کی وجہ یہ ہے کہ آئی ایس بائنری سرچ ٹری فنکشن کا ایک مثال ہے: ٹائپ اسکرپٹکونسٹ روٹ = نیا ٹرینوڈ (2) ؛ روٹ. لیفٹ = نیا ٹرینوڈ (نیا ٹرینوڈ (نیا ٹرینوڈ (نیا ٹرینوڈ (2)1) روٹ. رائٹ = نیا ٹرینوڈ (3) ؛ کانسٹ isbst = isbinarysearchtree (جڑ) ؛ کنسول.لوگ (ISBST) ؛// اس مثال کے طور پر ، ہم روٹ نوڈ ویلیو کے ساتھ ایک نیا بائنری درخت بناتے ہیں ، ایک بائیں بچے کا نوڈ 1 کی قیمت کے ساتھ ، اور 3 کی قیمت کے ساتھ دائیں بچے کا نوڈ۔دلیل کے طور پر نوڈ ، اور نتیجہ کو ایک نئے متغیر ISBST کو تفویض کریں۔آخر میں ، ہم آئی ایس بی ایس ٹی کی قیمت کو کنسول پر لاگ ان کریں ، جو سچ ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں شروع سے ہیش ٹیبل کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں شروع سے ہیش ٹیبل کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ہیش ٹیبل کلاس کی وضاحت کریں جو ہیش ٹیبل ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ ایک ہیش فنکشن کی وضاحت کریں جو ایک کلید لیتا ہے اور ہیش ٹیبل میں ایک انڈیکس لوٹاتا ہے۔ہیش ٹیبل میں کلیدی قدر کی جوڑی داخل کرنے کے لئے ہیش ٹیبل کلاس کا۔ہیش ٹیبل سے ویلیو جوڑی۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے نفاذ ، 1 سے موافقت پذیر: ٹائپ اسکرپٹ کلاس ہیش ٹیبل <ٹی> {نجی اقدار: {[کلید: سٹرنگ]: ٹی} ؛نجی سائز: نمبر ؛کنسٹرکٹر (سائز: نمبر) {this.values = {} ؛this.size = سائز ؛} نجی حساب کتاب ہاش (کلید: سٹرنگ): نمبر {آئیے ہیش = 0 ؛کے لئے (آئیے i = 0 ؛ i <key.length ؛ i ++) {ہیش = (ہیش << 5) + ہیش + کلید۔ چیرکوڈیٹ (i) ؛ہیش = ہیش & ہیش ؛// 32 بٹ انٹیجر ہیش = ریاضی.بس (ہیش) میں تبدیل کریں ؛} ہیش ٪ اس کو واپس کریں۔ سائز ؛} سیٹ (کلید: سٹرنگ ، ویلیو: ٹی) {کانسٹ ہیش = this.calculatehash (کلید) ؛this.values [ہیش] = قدر ؛} get (key: string): t |غیر وضاحتی {کانسٹ ہیش = this.calculatehash (کلید) ؛اس کو واپس کریں۔} ہٹائیں (کلید: سٹرنگ) {کانسٹ ہیش = this.calculatehash (کلید) ؛اس کو حذف کریں۔}} اس مثال میں ، ہم ایک ہیش ٹیبل کلاس کی وضاحت کرتے ہیں جو ہیش ٹیبل ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، جس میں کلیدی قدر کے جوڑے داخل کرنے ، بازیافت کرنے اور ہٹانے کے طریقے ہیں۔سیٹ کا طریقہ ہیش ٹیبل میں ایک کلیدی قدر کی جوڑی داخل کرتا ہے ، ہیش ٹیبل میں انڈیکس کا حساب لگانے کے لئے ہیش فنکشن کا استعمال کرتے ہوئے۔GET طریقہ انڈیکس کا حساب لگانے کے لئے ایک ہی ہیش فنکشن کا استعمال کرتے ہوئے ، ہیش ٹیبل سے کسی کلید سے وابستہ قدر کو بازیافت کرتا ہے۔ہٹانے کا طریقہ ہیش ٹیبل سے کلیدی قدر کی جوڑی کو ہٹا دیتا ہے ، اسی ہیش فنکشن کا استعمال کرتے ہوئے انڈیکس کا حساب لگاتا ہے۔ ہیش ٹیبل کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹ کونسٹ HT = نیا ہیش ٹیبل <سٹرنگ> (10) ؛ HT.SET ('فو '،' بار ') ؛ ht.set (' باز '،' qux ') ؛ کنسول.لوگ (ht.get (' foo ')) ؛// 'بار'کنسول.لوگ (ht.get (' باز ')) ؛// 'qux'ht.remove (' foo ') ؛ کنسول.لوگ (ht.get (' foo ')) ؛// اس مثال کے طور پر ، ہم 10 کے سائز کے ساتھ ایک نیا ہیش ٹیبل مثال تیار کرتے ہیں ، اور سیٹ کے طریقہ کار کا استعمال کرتے ہوئے دو کلیدی قیمت والے جوڑے داخل کرتے ہیں۔اس کے بعد ہم کلیدوں کے 'فو' اور 'باز' سے وابستہ اقدار کو بازیافت کرنے کے لئے دو بار گیٹ کے طریقہ کار کو کال کرتے ہیں ، اور لوٹے ہوئے اقدار کو کنسول میں بالترتیب 'بار' اور 'Qux' ہونا چاہئے۔اس کے بعد ہم کلیدی قیمت کے جوڑے کو کلیدی 'فو' کے ساتھ ہٹانے کے لئے ہٹائیں ، اور کلیدی 'فو' سے وابستہ قدر کو بازیافت کرنے کے لئے دوبارہ گیٹ طریقہ کو کال کریں ، جس کی وضاحت نہیں کی جانی چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے ل we ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: صف کو چھانٹنا: ہم سرنی کو نزول ترتیب میں ترتیب دے سکتے ہیں اور کے ٹی ایچ عنصر کو واپس کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن فاؤنڈ کےٹلرجسٹ (نمبر: نمبر: نمبر [] ، کے: نمبر): نمبر |غیر متعینہ {nums.sort ((a ، b) => b - a) ؛ریٹرن نمبر [K - 1] ؛} اس مثال میں ، ہم ایک ایسی فاؤنڈیشنل فنکشن کی وضاحت کرتے ہیں جو نمبر نمبروں اور ایک نمبر K کو دلائل کے طور پر لیتا ہے ، اور نمبروں میں کے ٹی ایچ کے سب سے بڑے عنصر کو لوٹاتا ہے۔فنکشن پہلے ترتیب کے طریقہ کار کا استعمال کرتے ہوئے نزول ترتیب میں نمبروں کی صف کو ترتیب دیتا ہے ، اور پھر انڈیکس K پر عنصر کو لوٹاتا ہے - 1. ڈھونڈنے والے فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ نمبر = [3 ، 2 ، 1 ، 5 ، 6 ، 4] ؛ Const K = 2 ؛ const Kthlargest = findkthlargest (nums ، k) ؛ کنسول.لوگ (kthlargest) ؛// اس مثال کے طور پر ، ہم اقدار [3] [2] [1] [5] [5] [6] [4] ، اور قیمت کے ساتھ ایک نمبر K کے ساتھ ایک نیا سرنی نمبر تیار کرتے ہیں۔NUMS اور K کو بطور دلائل ، اور نتیجہ ایک نئے متغیر Kthlargest کو تفویض کریں۔آخر میں ، ہم کنسول میں Kthlargest کی قیمت کو لاگ ان کرتے ہیں ، جو 5 منٹ کے ڈھیر کا استعمال کرتے ہوئے ہونا چاہئے: ہم غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک من ڈھیر کا استعمال کرسکتے ہیں۔ہم سائز K کا ایک کم سے کم ڈھیر بنا سکتے ہیں ، اور سرے کے پہلے K عناصر کو ڈھیر میں داخل کرسکتے ہیں۔اس کے بعد ہم سرنی کے باقی عناصر پر تکرار کرسکتے ہیں ، اور اگر وہ ڈھیر میں کم سے کم عنصر سے بڑے ہیں تو انہیں ڈھیر میں داخل کرسکتے ہیں۔تمام عناصر پر تکرار کرنے کے بعد ، ڈھیر میں کم سے کم عنصر صف میں KTH کا سب سے بڑا عنصر ہوگا۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 2 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن فاؤنڈ کےٹلرجسٹ (نمبر: نمبر: نمبر [] ، کے: نمبر): نمبر |غیر وضاحتی {کانسٹ منہیپ = نئی سرنی <نمبر> (کے) ؛کے لئے (آئیے i = 0 ؛ i <k ؛ i ++) {منیہپ [i] = nums [i] ؛} کے لئے (آئیے i = k ؛ i <nums.length ؛ i ++) {اگر (nums [i]> minheap [0]) {minHeap [0] = nums [i] ؛آئیے j = 0 ؛جبکہ (2 * j + 1 <k) {کانسٹ لیفٹائڈ انڈیکس = 2 * جے + 1 ؛کونٹ رائٹائڈ انڈیکس = 2 * جے + 2 ؛آئیے MININDEX = J ؛اگر (MINHEAP [lifechildIndex] <MINHEAP [MININDEX]) {MININDEX = لیفٹائڈ انڈیکس ؛} if (رائٹچلڈ انڈیکس <K && MINHEAP [RITELDINDEX] <MINHEAP [MININDEX]) {MININDEX = RITELDINDEX ؛} if (minidex === j) {بریک ؛} [MINHEAP [J] ، MINHEAP [MININDEX]] = [MINHEAP [MININDEX] ، MINHEAP [J]] ؛j = MinIndex ؛}}} MinHEAP واپس کریں [0] ؛} اس مثال میں ، ہم ایک ایسی تلاش کے بارے میں وضاحت کرتے ہیں جو نمبر نمبروں کی ایک صف اور ایک نمبر K کو دلائل کے طور پر لیتا ہے ، اور نمبروں میں کے ٹی ایچ کے سب سے بڑے عنصر کو لوٹاتا ہے۔فنکشن سب سے پہلے سائز K کے ایک نئے سرنی منہیپ کا آغاز کرتا ہے ، اور ڈھیر میں نمبروں کے پہلے K عناصر داخل کرتا ہے۔اس کے بعد فنکشن نمبر کے باقی عناصر پر تکرار کرتا ہے ، اور اگر وہ ڈھیر میں کم سے کم عنصر سے بڑا ہوتا ہے تو انہیں ڈھیر میں داخل کرتا ہے۔تمام عناصر پر تکرار کرنے کے بعد ، ڈھیر میں کم سے کم عنصر سرنی میں کے ٹی ایچ ٹی کا سب سے بڑا عنصر ہوگا۔ یہاں تلاش کے لئے ایک مثال کے استعمال کا استعمال: ٹائپ اسکرپٹکونسٹ نمبر = [3 ، 2 ، 1 ، 5 ، 6 ، 4] ؛K = 2 ؛ const Kthlargest = findkthlargest (nums ، k) ؛ کنسول.لوگ (kthlargest) ؛// اس مثال کے طور پر ، ہم اقدار [3] [2] [1] [5] [5] [6] [4] ، اور قیمت کے ساتھ ایک نمبر K کے ساتھ ایک نیا سرنی نمبر تیار کرتے ہیں۔NUMS اور K کو بطور دلائل ، اور نتیجہ ایک نئے متغیر Kthlargest کو تفویض کریں۔آخر میں ، ہم Kthlargest کی قدر کو کنسول میں لاگ ان کرتے ہیں ، جو 5.1LeetCode2stackoverflow ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں سرکلر بفر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں سرکلر بفر ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک صف کا استعمال کرتے ہوئے: ہم سرکلر بفر ڈیٹا ڈھانچے کو نافذ کرنے کے لئے ایک صف کا استعمال کرسکتے ہیں۔ہم ایک مقررہ سائز کی ایک صف کو شروع کرسکتے ہیں ، اور بفر کے آغاز اور اختتام پر نظر رکھنے کے لئے دو پوائنٹر استعمال کرسکتے ہیں۔اس کے بعد جب ہم سرنی کے اختتام تک پہنچ جاتے ہیں تو ہم اختتامی پوائنٹر کے گرد لپیٹنے کے لئے ماڈیولر ریاضی کا استعمال کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ کلاس سرکلر بفر <ٹی> {نجی بفر: ٹی [] ؛نجی آغاز: نمبر ؛نجی اختتام: نمبر ؛کنسٹرکٹر (سائز: نمبر) {this.buffer = نئی سرنی <t> (سائز) ؛this.start = 0 ؛this.end = 0 ؛} نجی انکریمنٹ پوائنٹر (پوائنٹر: نمبر): نمبر {واپسی (پوائنٹر + 1) ٪ this.buffer.length ؛} نجی isfull (): بولین {اس کو واپس کریں۔ انکرمنٹ پوائنٹ (this.end) === this.start ؛} نجی isempty (): بولین {اس کو واپس کریں۔ اسٹارٹ === this.end ؛} لکھیں (ویلیو: ٹی) {اگر (this.isfull ()) {نئی غلطی پھینک دیں ('بفر بھرا ہوا ہے') ؛} this.buffer [this.end] = قدر ؛this.end = this.incrementPoint (this.end) ؛} پڑھیں (): t {if (this.isempty ()) {نئی غلطی پھینک دیں ('بفر خالی ہے') ؛} const value = this.buffer [this.start] ؛this.start = this.incrementPoint (this.start) ؛واپسی کی قیمت ؛}} اس مثال میں ، ہم ایک سرکلر بفر کلاس کی وضاحت کرتے ہیں جو بفر سے اقدار لکھنے اور پڑھنے کے طریقوں کے ساتھ ، سرکلر بفر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔لکھنے کا طریقہ بفر میں ایک قدر داخل کرتا ہے ، اور پڑھنے کا طریقہ بفر سے ایک قدر ہٹاتا ہے اور لوٹاتا ہے۔کلاس ایک مقررہ سائز کا ایک سرنی بفر استعمال کرتا ہے ، اور بفر کے آغاز اور اختتام کو ٹریک رکھنے کے لئے دو پوائنٹرز شروع اور اختتام پذیر ہوتے ہیں۔جب یہ سرنی کے اختتام پر پہنچ جاتا ہے تو کلاس کے اختتام پوائنٹر کے گرد لپیٹنے کے لئے ماڈیولر ریاضی کا استعمال ہوتا ہے۔ یہاں سرکلر بفر کلاس کا ایک مثال استعمال ہوتا ہے: ٹائپ اسکرپٹ کونسٹ بفر = نیا سرکلر بفر <نمبر> (3) ؛ بفر.رائٹ (1) ؛ بفر۔لکھیں (2) ؛ بفر.رائٹ (3) ؛ کنسول.لوگ (بفر.ریڈ ()) ؛// 1console.log (بفر.ریڈ ()) ؛// 2buffer.write (4) ؛ کنسول.لاگ (بفر.ریڈ ()) ؛// 3console.log (بفر.ریڈ ()) ؛// 4 اس مثال کے طور پر ، ہم 3 کے سائز کے ساتھ ایک نیا سرکلر بفر مثال تیار کرتے ہیں ، اور لکھنے کے طریقہ کار کا استعمال کرتے ہوئے بفر کو چار اقدار لکھتے ہیں۔اس کے بعد ہم بفر سے اقدار کو پڑھنے کے لئے چار بار پڑھنے کے طریقہ کار کو کال کرتے ہیں ، اور لوٹے ہوئے اقدار کو کنسول میں لاگ ان کرتے ہیں ، جو 1 ، 2 ، 3 ، اور 4 ہونا چاہئے ، اس لائبریری کا استعمال کرتے ہوئے: ہم A بھی استعمال کرسکتے ہیں۔لائبریری ٹائپ اسکرپٹ میں سرکلر بفر ڈیٹا ڈھانچے کو نافذ کرنے کے لئے۔این پی ایم پر متعدد لائبریریاں دستیاب ہیں جو سرکلر بفر پر عمل درآمد کرتی ہیں ، جیسے رنگ بفر-ٹی ایس اور سرکلر بفر۔یہاں رنگ-بفر-ٹی ایس لائبریری کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ امپورٹ {رنگ بفر} سے 'رنگ بفر-ٹی ایس' ؛ کانسٹ بفر = نیا رنگ بفر <نمبر> (3) ؛ بفر.پش (1) ؛ بفر.پش (2) ؛ بفر.پش (3) ؛ کنسول.لوگ (بفر.شفٹ ()) ؛// 1console.log (بفر.شفٹ ()) ؛// 2buffer.push (4) ؛ کنسول.لاگ (بفر.شفٹ ()) ؛// 3console.log (بفر.شفٹ ()) ؛// 4 اس مثال کے طور پر ، ہم رنگ بفر-ٹی ایس لائبریری سے رنگ بفر کلاس درآمد کرتے ہیں ، اور 3 کے سائز کے ساتھ ایک نیا رنگ بفر مثال تیار کرتے ہیں۔ پھر ہم پش طریقہ کا استعمال کرتے ہوئے بفر کو چار اقدار لکھتے ہیں ، اور اقدار کو پڑھتے ہیں۔شفٹ کے طریقہ کار کا استعمال کرتے ہوئے بفر۔آخر میں ، ہم واپس شدہ اقدار کو کنسول میں لاگ ان کرتے ہیں ، جو 1 ، 2 ، 3 ، اور 4 ہونا چاہئے ، اس ترتیب میں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر چوڑائی کی پہلی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ امپورٹ {گراف} سے 'گراف ڈیٹا ڈھانچہ' ؛ کانسٹ گراف = نیا گراف () ؛ گراف.اڈیج ('اے' ، 'بی') ؛ گراف.ڈیج ('اے' ، 'سی') ؛ گراف۔ ایڈجڈج۔).addedge ('e' ، 'f') ؛ فنکشن BFS <T> (گراف: گراف <ٹی> ، اسٹارٹ: ٹی): ٹی [] {کنسٹٹ ملاحظہ کریں: t [] = [] ؛کانسٹ قطار: t [] = [شروع] ؛جبکہ (قطار۔ لمبائی> 0) {کونسٹ نوڈ = قطار۔ شفٹ () !؛اگر (! ملاحظہ کیا گیا۔قطار.پش (... گراف.نیگبرس (نوڈ)) ؛}} واپسی کا دورہ ؛} const bfsresult = bfs (گراف ، 'a') ؛ کنسول.لوگ (bfsresult) ؛// ['a' ، 'B' ، 'C' ، 'D' ، 'E' ، 'F'] ٹائپ اسکرپٹ کونسٹ BfSResult = BFS (گراف ، 'A') ؛ کنسول.لوگ (BfSResult) ؛// ['a' ، 'b' ، 'c' ، 'd' ، 'e' ، 'f'] ٹائپ اسکرپٹ انٹرفیس گراف نوڈ <T> {قدر: t ؛پڑوسی: گراف نوڈ <t> [] ؛} فنکشن BFS <T> (شروع: گراف نوڈ <T>): t [] {کنسٹٹ ملاحظہ کریں: t [] = [] ؛کانسٹ قطار: گراف نوڈ <t> [] = [شروع] ؛جبکہ (قطار۔ لمبائی> 0) {کونسٹ نوڈ = قطار۔ شفٹ () !؛اگر (! ملاحظہ کیا گیا۔ انکلیڈس (node.value)) {ملاحظہ کیا گیا۔ پش (نوڈ.والیو) ؛قطار.پش (... نوڈ.نیگبرز) ؛}} واپسی کا دورہ ؛} ٹائپ اسکرپٹ کنسٹ نوڈیا: گراف نوڈ <سٹرنگ> = {قدر: 'اے' ، پڑوسی: []} ؛ کانسٹ نوڈب: گراف نوڈ <سٹرنگ> = {قدر: 'بی' ، پڑوسی: []} ؛ کانسٹ نوڈیک: گراف نوڈ <سٹرنگ> = {ویلیو: 'سی' ، پڑوسی: []} ؛ کانسٹ نوڈڈ: گراف نوڈ <سٹرنگ> = {قدر: 'ڈی' ، پڑوسی: []} ؛ کانسٹ نوڈی: گراف نوڈ <سٹرنگ> = {قدر: 'ای' ، پڑوسی: []} ؛ کانسٹ نوڈف: گراف نوڈ <سٹرنگ> = {ویلیو: 'ایف' ، پڑوسی: []} ؛ نوڈیا.نیگبرس = [نوڈب ، نوڈیک] ؛ نوڈب.نیاببرس = [نوڈ] ؛nodec.neighbors = [نوڈی ، نوڈف] ؛ noded.neighbors = [nodee] ؛ nodee.neighbors = [nodef] ؛ const bfsresult = bfs (nodea) ؛ کنسول.لاگ (bfsresult) ؛// ['a' ، 'b' ، 'c' ، 'd' ، 'e' ، 'f']"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ترتیب شدہ منسلک فہرست میں بائنری سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ترتیب شدہ لنکڈ لسٹ میں بائنری سرچ الگورتھم کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: لنکڈ لسٹ کلاس کی وضاحت کریں جو ایک لنکڈ لسٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ لنکڈ لسٹ کلاس کے داخل کرنے کا طریقہ کار میں لنکڈ لسٹ میں داخل ہونے کے لئے لنکڈ لسٹ کلاس کے داخل کرنے کا طریقہترتیب شدہ آرڈر۔ لنکڈ لسٹ کلاس کے تلاش کے طریقہ کار کو لنکڈ فہرست میں بائنری تلاش کرنے کے لئے۔اگلا: نوڈ <t> |خالی؛کنسٹرکٹر (ویلیو: ٹی) {this.value = value ؛this.next = null ؛class} کلاس لنکڈ لسٹ <t> {نجی ہیڈ: نوڈ <t> |خالی؛کنسٹرکٹر () {this.head = null ؛} داخل کریں (ویلیو: ٹی) {کونسٹ نیو نوڈ = نیا نوڈ (ویلیو) ؛اگر (! this.head || value <this.head.value) {newnode.next = this.head ؛this.head = newnode ؛} دوسری {موجودہ = this.head ؛جبکہ (موجودہ۔ نیکسٹ && ویلیو> = موجودہ۔ نیکسٹ.ولیو) {موجودہ = موجودہ۔ نیکسٹ ؛} newnode.next = موجودہ. نیکسٹ ؛موجودہ۔ نیکسٹ = نیو نوڈ ؛}} تلاش (ویلیو: ٹی): نوڈ <t> |null {let = this.head ؛چلو دائیں = null ؛جبکہ (بائیں! == دائیں) {const mid = this.getMiddle (بائیں ، دائیں) ؛if (mid.value === ویلیو) {واپس وسط ؛} دوسری صورت میں اگر (mid.value <ویلیو) {بائیں = MID.next ؛} دوسری {دائیں = وسط ؛}} واپس کالعدم ؛} نجی getMiddle (بائیں: نوڈ <t> ، دائیں: نوڈ <t> | null): نوڈ <T> {آئیے سست = بائیں ؛تیز = بائیں۔ نیکسٹ ؛جبکہ (تیز! == صحیح) {فاسٹ = فاسٹ! .next ؛اگر (تیز! == صحیح) {سست = سست۔ نیکسٹ !؛فاسٹ = فاسٹ! .next ؛}} سست واپسی ؛}} اس مثال میں ، ہم ایک نوڈ کلاس کی وضاحت کرتے ہیں جو لنکڈ فہرست میں نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ویلیو پراپرٹی ، اور اگلے نوڈ کے حوالہ کے لئے اگلی پراپرٹی ہے۔ہم ایک لنکڈ لسٹ کلاس کی وضاحت کرتے ہیں جو لنکڈ فہرست میں نوڈس ڈالنے اور تلاش کرنے کے طریقوں کے ساتھ ، لنکڈ لسٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔داخل کرنے کا طریقہ ترتیب شدہ ترتیب میں لنکڈ لسٹ میں ایک نوڈ داخل کرتا ہے ، اور تلاش کا طریقہ لنکڈ لسٹ میں بائنری تلاش کرتا ہے۔)) ؛// 5 اس مثال کے طور پر ، ہم ایک نیا لنکڈ لسٹ مثال تیار کرتے ہیں ، اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے لنکڈ لسٹ میں پانچ اقدار داخل کرتے ہیں۔اس کے بعد ہم تلاش کے طریقہ کار کو ویلیو 5 کے ساتھ دلیل کے طور پر کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر نوڈ پر تفویض کرتے ہیں۔آخر میں ، ہم نوڈ کی قیمت لاگ ان کرتے ہیں؟. کنسول کی قیمت ، جو 5.1geeksforgeeks ہونا چاہئے"
    },
    {
        "Question": "اس بات کا تعین کرنے کے لئے ایک پروگرام لکھیں کہ آیا دو بائنری درخت ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک جیسے ہیں یا نہیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک جیسے ہیں ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک ٹرینوڈ کلاس کی وضاحت کریں جو بائنری ٹری میں نوڈ کی نمائندگی کرتا ہے۔ ایک بار بار چلنے والا فنکشن ایک جیسے کہ دو ٹرینوڈ مثالوں کو دلائل کے طور پر لیتا ہے اور اس بات کی نشاندہی کرتا ہے کہ اس کی نشاندہی کرتی ہے یا نہیں۔دونوں درخت ایک جیسے ہیں۔ اس بات کی جانچ پڑتال کرنی چاہئے کہ آیا دونوں نوڈس کی اقدار برابر ہیں ، اور بار بار یہ چیک کریں کہ آیا ان کے بائیں اور دائیں سب ٹری ایک جیسے ہیں۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ کلاس ٹرینیوڈ <t> {قدر: t ؛بائیں: Treenode <T> |خالی؛دائیں: ٹرینوڈ <t> |خالی؛کنسٹرکٹر (ویلیو: ٹی) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن Areidentical <T> (روٹ 1: ٹرینوڈ <t> | null ، روٹ 2: ٹرینوڈ <T> | null): بولین {اگر (روٹ 1 === null && & روٹ 2 ==== null) {سچ واپس ؛} if (جڑ 1 === null || روٹ 2 === null) {غلط لوٹ ؛} ریٹرن (روٹ 1.value === روٹ 2. ویلیو && areidentical (روٹ 1.left ، روٹ 2. لیفٹ) اور & areidentical (روٹ 1. رائٹ ، روٹ 2. رائٹ)) ؛} اس مثال میں ، ہم ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں جو نوڈ کی نمائندگی کرتا ہے۔بائنری ٹری میں ، نوڈ ویلیو کے لئے ایک قدر کی پراپرٹی کے ساتھ ، اور بائیں اور دائیں بچے کے نوڈس کے حوالے سے بائیں اور دائیں خصوصیات کے ساتھ۔ہم ایک ایسے کام کی وضاحت کرتے ہیں جو دو ٹرینوڈ مثالوں کو دلائل کے طور پر لیتا ہے ، اور بولین کی قیمت کو واپس کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا دونوں درخت ایک جیسے ہیں یا نہیں۔فنکشن کی جانچ پڑتال کرتی ہے کہ آیا دونوں نوڈس کی اقدار برابر ہیں ، اور بار بار جانچ پڑتال کرتی ہے کہ اگر ان کے بائیں اور دائیں ذیلی ذیلی ذیلی ایک جیسے ہیں۔ یہاں پر مبنی فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ روٹ 1 = نیا ٹرینوڈ (1) ؛ روٹ 1.left = نیا ٹرینوڈ (نیا ٹرینوڈ (نیا ٹرینوڈ (نیا ٹرینوڈ (1) ؛2) روٹ 1. رائٹ = نیا ٹرینوڈ (3) ؛ کانسٹ روٹ 2 = نیا ٹرینوڈ (1) ؛ روٹ 2. لیفٹ = نیا ٹرینوڈ (2) ؛ روٹ 2. رائٹ = نیا ٹرینوڈ (3) ؛ ایک جیسی = areidentical (روٹ 1 ، روٹ 2) ؛ کنسول.لوگ (ایک جیسی) ؛// اس مثال کے طور پر ، ہم دو بائنری درخت روٹ 1 اور روٹ 2 بناتے ہیں ، اور بائیں اور دائیں خصوصیات کا استعمال کرتے ہوئے ان کے نوڈس تفویض کرتے ہیں۔اس کے بعد ہم روٹ 1 اور روٹ 2 کے ساتھ areidentical فنکشن کو دلائل کے طور پر کہتے ہیں ، اور نتیجہ کو ایک نئے متغیر ایک جیسی کو تفویض کرتے ہیں۔آخر میں ، ہم کنسول کی طرح کی قیمت کو لاگ ان کرتے ہیں ، جو سچ ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: لائبریری کا استعمال: ہم ٹائپ اسکرپٹ میں اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے لائبریری کا استعمال کرسکتے ہیں۔این پی ایم پر متعدد لائبریریاں دستیاب ہیں جو اسکیپ لسٹ ٹی ایس اور ٹی ایس سکپلسٹ جیسے اسکیپ لسٹ پر عمل درآمد فراہم کرتی ہیں۔یہاں ٹی ایس سکپلسٹ لائبریری کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ امپورٹ {اسکیپلسٹ} سے 'TS-Skiplist' ؛ Const Skiplist = new Spiplist <نمبر> () ؛ اسکیپلسٹ.اڈی (1) ؛ اسکیپلسٹ.اڈ (3) ؛ اسکیپلسٹ.اڈڈ۔)// اس مثال کے طور پر ، ہم اسکیپلسٹ کلاس کو TS-Skiplist لائبریری سے درآمد کرتے ہیں ، اور ایک نیا اسکیپلسٹ مثال تیار کرتے ہیں۔اس کے بعد ہم ADD کے طریقہ کار کا استعمال کرتے ہوئے اسکیپ لسٹ میں پانچ اقدار شامل کرتے ہیں ، اور تلاش کے طریقہ کار کا استعمال کرتے ہوئے قیمت 5 کے ساتھ نوڈ تلاش کرتے ہیں۔آخر میں ، ہم نوڈ کی قیمت کو لاگ ان کرتے ہیں؟ کنسول کی قیمت ، کون سا ہونا چاہئے۔یہاں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ کلاس اسکیپلسٹنوڈ <t> {قدر: t ؛اگلا: اسکیپلسٹنوڈ <t> [] |خالی؛کنسٹرکٹر (ویلیو: ٹی ، سطح: نمبر) {this.value = value ؛this.next = نئی سرنی <skiplistnode <T >> (سطح). فل (NULL) ؛class} کلاس اسکیپلسٹ <t> {نجی ہیڈ: اسکیپلسٹنوڈ <t> ؛نجی میکسلیول: نمبر ؛نجی لیولپروب: نمبر ؛کنسٹرکٹر () {this.head = نیا اسکیپلسٹنوڈ <t> (null ، 1) ؛this.maxlevel = 1 ؛this.levelprob = 0.5 ؛} نجی رینڈم لیول (): نمبر {اجازت دیں سطح = 1 ؛جبکہ (math.random () <this.levelprob && سطح <this.maxlevel+1) {سطح ++ ؛} واپسی کی سطح ؛} شامل کریں (ویلیو: ٹی) {کانسٹ لیول = this.randomlevel () ؛Const newnode = نیا اسکیپلسٹنوڈ <T> (قدر ، سطح) ؛آئیے موجودہ = this.head ؛کانسٹ اپڈیٹ: اسکیپلسٹنوڈ <t> [] = نئی سرنی <اسکیپلسٹنوڈ <ٹی >> (this.maxlevel) .fill (null) ؛کے لئے (آئیے i = this.maxlevel-1 ؛ i> = 0 ؛ i--) {جبکہ (موجودہ. نیکسٹ && موجودہ. نیکسٹ۔} اپ ڈیٹ [i] = موجودہ ؛} کے لئے (آئیے i = 0 ؛ i <سطح ؛ i ++) {newnode.next! [i] = اپ ڈیٹ [i]. نیکسٹ! [i] ؛اپ ڈیٹ [i] .next! [i] = newnode ؛} if (سطح> this.maxlevel) {this.maxlevel = سطح ؛}} تلاش کریں (ویلیو: ٹی): اسکیپلسٹنوڈ <t> |null {let موجودہ = this.head ؛کے لئے (آئیے i = this.maxlevel-1 ؛ i> = 0 ؛ i--) {جبکہ (موجودہ. نیکسٹ && موجودہ. نیکسٹ۔}} if (current.next && موجودہ۔ نیکسٹ [0] .Value === ویلیو) {موجودہ. نیکسٹ [0] ؛} واپس کالعدم ؛}} اس مثال میں ، ہم اسکیپلسٹنوڈ کلاس کی وضاحت کرتے ہیں جو اسکیپ لسٹ میں ایک نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ویلیو پراپرٹی ، اور اگلے نوڈس کے حوالہ جات کی ایک صف کے لئے اگلی پراپرٹی ہے۔ہم ایک اسکیپلسٹ کلاس کی وضاحت کرتے ہیں جو اسکیپ لسٹ میں نوڈس کو شامل کرنے اور تلاش کرنے کے طریقوں کے ساتھ ، اسکیپ لسٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ADD کا طریقہ اسکیپ لسٹ میں ایک نوڈ شامل کرتا ہے ، اور تلاش کرنے کا طریقہ اسکیپ لسٹ میں دی گئی قیمت کے ساتھ ایک نوڈ تلاش کرتا ہے۔ اسکیپلسٹ کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ اسکیپلسٹ = نیا اسکیپلسٹ <نمبر> () ؛ اسکیپلسٹ.اڈڈ۔)) ؛// 5 اس مثال کے طور پر ، ہم ایک نیا اسکیپلسٹ مثال تیار کرتے ہیں ، اور ADD کے طریقہ کار کا استعمال کرتے ہوئے اسکیپ لسٹ میں پانچ اقدار شامل کرتے ہیں۔اس کے بعد ہم تلاش کے طریقہ کار کا استعمال کرتے ہوئے قیمت 5 کے ساتھ نوڈ تلاش کرتے ہیں ، اور نتائج کو ایک نئے متغیر نوڈ پر تفویض کرتے ہیں۔آخر میں ، ہم نوڈ کی قیمت لاگ ان کرتے ہیں؟. کنسول کی قیمت ، جو 5.1geeksforgeeks ہونا چاہئے"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر گہرائی سے پہلے تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر گہرائی سے پہلے تلاش کرنے کے ل we ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: گراف لائبریری کا استعمال: ہم ٹائپ اسکرپٹ میں گراف پر گہرائی سے پہلے تلاش کرنے کے لئے گراف لائبریری کا استعمال کرسکتے ہیں۔این پی ایم پر بہت سی لائبریریاں دستیاب ہیں جو گراف پر عمل درآمد فراہم کرتی ہیں ، جیسے گراف ڈیٹا ڈھانچہ اور جے ایس گراف-الگوریتھم۔یہاں گراف ڈیٹا ڈھانچے کی لائبریری کا ایک مثال استعمال ہے: 'گراف ڈیٹا ڈھانچہ' سے ٹائپ اسکرپٹ امپورٹ {گراف} const const گراف = نیا گراف () ؛ گراف.اڈیج ('a' ، 'b') ؛ گراف.ڈیجڈج۔).Addedge ('d' ، 'e') ؛ گراف.ڈیج ('e' ، 'f') ؛ فنکشن DFS <T> (گراف: گراف <ٹی> ، اسٹارٹ: ٹی): ٹی [] {کنسٹ ملاحظہ:t [] = [] ؛فنکشن وزٹ (نوڈ: ٹی) {ملاحظہ کیا گیا۔ پش (نوڈ) ؛گراف.نیگبرس (نوڈ) .فورچ ((پڑوسی) => {اگر (! ملاحظہ کیا گیا۔} ملاحظہ کریں (شروع کریں) ؛واپسی کا دورہ ؛} const dfsresult = dfs (گراف ، 'a') ؛ کنسول.لوگ (dfsresult) ؛// ['a' ، 'b' ، 'd' ، 'e' ، 'f' ، 'c'] اس مثال میں ، ہم گراف ڈیٹا گراف ڈیٹا ڈھانچے کی لائبریری سے درآمد کرتے ہیں ، اور ایک نیا گراف تشکیل دیتے ہیں۔مثال.اس کے بعد ہم ایڈج کے طریقہ کار کا استعمال کرتے ہوئے گراف میں کناروں کو شامل کرتے ہیں۔ہم ایک ڈی ایف ایس فنکشن کی وضاحت کرتے ہیں جو گراف مثال اور ابتدائی نوڈ کو دلائل کے طور پر لیتا ہے ، اور گہرائی سے پہلے ترتیب میں آنے والے نوڈس کی ایک صف لوٹاتا ہے۔فنکشن ایک خالی صف کا آغاز کرتا ہے جو دورے والے نوڈس کو ذخیرہ کرنے کے لئے جاتا ہے ، اور گھوںسلا وزٹ فنکشن کی وضاحت کرتا ہے جو نوڈ کے پڑوسیوں سے بار بار ملتا ہے۔اس کے بعد یہ فنکشن ابتدائی نوڈ کے ساتھ وزٹ فنکشن کو کال کرتا ہے ، اور ملاحظہ کی گئی سرنی کو واپس کرتا ہے۔ یہاں ڈی ایف ایس فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ ڈی ایف ایس آر ایس آر ایس ٹی = ڈی ایف ایس (گراف ، 'اے') ؛ کنسول.لاگ (ڈی ایف ایس آر ایسولٹ) ؛// ['a' ، 'b' ، 'd' ، 'e' ، 'f' ، 'C'] اس مثال میں ، ہم DFS فنکشن کو گراف مثال کے ساتھ اور ابتدائی نوڈ 'A' کے ساتھ دلائل کے طور پر کہتے ہیں۔، اور نتیجہ کو ایک نئے متغیر DFSResult کو تفویض کریں۔آخر میں ، ہم DFSRESTULT کی قدر کو کنسول میں لاگ ان کرتے ہیں ، جو ['a' ، 'b' ، 'd' ، 'e' ، 'f' ، 'c'] ہونا چاہئے۔ شروع سے الگورتھم کو نافذ کرنا: ہم بھی کر سکتے ہیں۔ٹائپ اسکرپٹ میں شروع سے گہرائی سے پہلے تلاش الگورتھم کو نافذ کریں۔یہاں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ انٹرفیس گراف نوڈ <T> {قدر: t ؛پڑوسی: گراف نوڈ <t> [] ؛} فنکشن ڈی ایف ایس <ٹی> (شروع: گراف نوڈ <ٹی>): ٹی [] {کنسٹٹ ملاحظہ: ٹی [] = [] ؛فنکشن ملاحظہ کریں (نوڈ: گراف نوڈ <ٹی>) {ملاحظہ کیا گیا۔ پش (نوڈ.والیو) ؛node.neighbors.foreach ((پڑوسی) => {اگر (! ملاحظہ کیا گیا۔} ملاحظہ کریں (شروع کریں) ؛واپسی کا دورہ ؛} اس مثال کے طور پر ، ہم ایک انٹرفیس گراف نوڈ کی وضاحت کرتے ہیں جو گراف میں ایک نوڈ کی نمائندگی کرتا ہے ، جس میں نوڈ ویلیو کے لئے ویلیو پراپرٹی ، اور پڑوسی نوڈس کی ایک صف کے لئے پڑوسی ممالک کی پراپرٹی ہوتی ہے۔ہم ایک DFS فنکشن کی وضاحت کرتے ہیں جو قسم کے گراف نوڈ <t> کا ابتدائی نوڈ ایک دلیل کے طور پر لیتا ہے ، اور گہرائی سے پہلے ترتیب میں آنے والے نوڈس کی ایک صف لوٹاتا ہے۔فنکشن ایک خالی صف کا آغاز کرتا ہے جو دورے والے نوڈس کو ذخیرہ کرنے کے لئے جاتا ہے ، اور گھوںسلا وزٹ فنکشن کی وضاحت کرتا ہے جو نوڈ کے پڑوسیوں سے بار بار ملتا ہے۔اس کے بعد فنکشن ابتدائی نوڈ کے ساتھ وزٹ فنکشن کو کال کرتا ہے ، اور ملاحظہ کی گئی سرنی کو واپس کرتا ہے۔ ڈی ایف ایس فنکشن کی مثال کے طور پر استعمال: ٹائپ اسکرپٹ کونسٹ نوڈیا: گراف نوڈ <سٹرنگ> = {ویلی: گراف نوڈ <سٹرنگ> = {ویلیو: 'بی' ، پڑوسی: []} ؛ کانسٹ نوڈیک: گراف نوڈ <سٹرنگ> = {ویلیو: 'سی' ، پڑوسی: []} ؛ کانسٹ نوڈ: گراف نوڈ <سٹرنگ> = {قدر.]} ؛ nodea.neighbors = [نوڈیب ، نوڈیک] ؛ نوڈب.نیگبرس = [نوڈڈ] ؛ نوڈیک.نیگبرس = [نوڈی ، نوڈف] ؛ نوڈڈ.نیائبرز = [نوڈی] ؛ نوڈی.نیابرس = [نوڈف] ؛ کانسٹ ڈی ایف ایس آر ایس آر ایس ٹی = [نوڈف] ؛ڈی ایف ایس (نوڈیا) ؛ کنسول.لوگ (ڈی ایف ایس آر ایسٹ) ؛// ['a' ، 'b' ، 'd' ، 'e' ، 'f' ، 'c'] اس مثال میں ، ہم گراف میں نوڈس کی نمائندگی کرنے والے چھ گراف نوڈ واقعات کی وضاحت کرتے ہیں ، اور نوڈس کے درمیان کناروں کو شامل کرتے ہیں۔ان کے پڑوسیوں کی جائیدادیں طے کرنا۔اس کے بعد ہم ابتدائی نوڈ نوڈیا کے ساتھ ڈی ایف ایس فنکشن کو دلیل کے طور پر کال کرتے ہیں ، اور نتیجہ کو ایک نئے متغیر DFSResult کو تفویض کرتے ہیں۔آخر میں ، ہم DFSRESTULT کی قدر کو کنسول میں لاگ ان کرتے ہیں ، جو ['a' ، 'b' ، 'd' ، 'e' ، 'F' ، 'C'] ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں خود توازن بائنری تلاش کے درخت کو نافذ کریں۔",
        "Answer": "'avlbinstree' سے ٹائپ اسکرپٹ امپورٹ avltree ؛ const درخت = نیا avltree <bunts> () ؛ درخت. insert (1) ؛ درخت. insert (3) ؛ درخت. insert (5) ؛ درخت. insert (7) ؛ درخت. insert (9) const const node = tree.find (5) ؛ کنسول.لاگ (نوڈ؟. ویلیو) ؛// 5typescriptClass avltrenode <T> {قدر: t ؛بائیں: avltreenode <T> |خالی؛دائیں: avltreenode <t> |خالی؛اونچائی: نمبر ؛کنسٹرکٹر (ویلیو: ٹی) {this.value = value ؛this.left = null ؛this.right = null ؛this.height = 1 ؛}} کلاس avltree <t> {نجی جڑ: avltreenode <T> |خالی؛کنسٹرکٹر () {this.root = null ؛} پرائیویٹ گیٹ ہائٹ (نوڈ: avltreenode <T> | null): نمبر {واپس نوڈ؟نوڈ.ہائٹ: 0 ؛} نجی گیٹ بیلنس فیکٹر (نوڈ: avltreenode <T> | null): نمبر {واپس نوڈ؟this.getheight (node.left) - this.getheight (نوڈ. رائٹ): 0 ؛} پرائیویٹ روٹیٹ لفٹ (نوڈ: avltreenode <t>): avltreenode <T> {const newrot = node.right !؛node.right = newrot.left ؛newrot.left = نوڈ ؛node.height = math.max (this.getheight (node.left) ، this.getheight (node.right)) + 1 ؛newrot.height = math.max (this.getheight (newrot.left) ، this.getheight (newrot.right)) + 1 ؛واپس نیو روٹ ؛} نجی روٹیرائٹ (نوڈ: avltreenode <T>): avltreenode <T> {const newrot = node.left !؛node.left = newrot.right ؛newrot.right = نوڈ ؛node.height = math.max (this.getheight (node.left) ، this.getheight (node.right)) + 1 ؛newrot.height = math.max (this.getheight (newrot.left) ، this.getheight (newrot.right)) + 1 ؛واپس نیو روٹ ؛} نجی توازن (نوڈ: avltreenode <T>): avltreenode <T> {const qualtycanfactor = this.getBalanceFactor (نوڈ) ؛اگر (بیلنس فیکٹر> 1) {if (this.getBalance فیکٹر (نوڈ. لیفٹ) <0) {node.left = this.rotateleft (node.left!) ؛this اس کو واپس کریں۔ روٹیرائٹ (نوڈ) ؛} ورنہ اگر (بیلنس فیکٹر <-1) {اگر (this.getBalancefactor (node.right)> 0) {node.right = this.rotateright (node.right!) ؛this اس کو واپس کریں۔} واپسی نوڈ ؛} داخل کریں (ویلیو: ٹی) {کونسٹ نیو نوڈ = نیا avltreenode (ویلیو) ؛this.root = this.insertnode (this.root ، newnode) ؛} نجی Insertnode (نوڈ: avltreenode <t> | null ، newnode: avltreenode <t>): avltreenode <T> {اگر (نوڈ === null) {واپس نیو نوڈ ؛} if (newnode.value <node.value) {node.left = this.insertnode (node.left ، newnode) ؛} else {node.right = this.insertnode (node.right ، newnode) ؛} node.height = math.max (this.getheight (node.left) ، this.getheight (node.right)) + 1 ؛اس کو واپس کریں۔ بیلنس (نوڈ) ؛} تلاش کریں (ویلیو: ٹی): avltreenode <t> |null {let موجودہ = this.root ؛جبکہ (موجودہ! == null) {if (value <موجودہ.Value) {موجودہ = کرنٹ. لیفٹ ؛} دوسری صورت میں اگر (ویلیو> کرنٹ۔ ویلیو) {موجودہ = موجودہ۔ رائٹ ؛} دوسری {موجودہ واپسی ؛}} واپس کالعدم ؛typ} ٹائپ اسکرپٹکونسٹ ٹری = نیا avltree <نمبر> () ؛ درخت.سرٹ (1) ؛ درخت.سرٹ (3) ؛ ٹری.نسرٹ (5) ؛ درخت.سرٹ (7) ؛ ٹری.نسرٹ (9) ؛ کانسٹ نوڈ= درخت.فائنڈ (5) ؛ کنسول.لوگ (نوڈ؟ .value) ؛// 5"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی صف پر انضمام کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عدد کی ایک صف پر انضمام کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: انضمام کی تقریب کی وضاحت کریں جو عدد کی ایک صف کو دلیل کے طور پر لیتا ہے اور ایک ترتیب شدہ صف کو واپس کرتا ہے۔ انضمام کی تقریب کو بار بار ان پٹ سرنی کو دو آدھے حصے میں تقسیم کرنا چاہئے ،انضمام کی تقریب کا استعمال کرتے ہوئے ہر آدھے کو ترتیب دیں ، اور انضمام کی تقریب کا استعمال کرتے ہوئے دو ترتیب شدہ حصوں کو ضم کریں۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن انضمام (ARR: نمبر []): نمبر [] {اگر (arr.لمبائی <= 1) {واپسی آر آر ؛} کانٹ مڈل = ریاضی۔ فلور (arr.length / 2) ؛کانسٹ بائیں = arr.slice (0 ، وسط) ؛کونٹ دائیں = arr.slice (درمیانی) ؛انضمام (انضمام (بائیں) ، انضمام (دائیں))} فنکشن انضمام (بائیں: نمبر [] ، دائیں: نمبر []): نمبر [] {کانٹ نتیجہ: نمبر [] = [] ؛آئیے i = 0 ؛آئیے j = 0 ؛جبکہ (میں <بائیں۔i ++ ؛} else {result.push (دائیں [j]) ؛J ++ ؛} retult ریٹرن کا نتیجہ۔ کوکیٹ (بائیں.سلائس (i))۔ کوکیٹ (دائیں.سلائس (j)) ؛} اس مثال میں ، ہم انضمام کی تقریب کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عدد کی ایک صف کو لیتا ہے ، اور ایک ترتیب شدہ صف کو واپس کرتا ہے۔فنکشن چیک کرتا ہے کہ آیا ان پٹ سرنی کی لمبائی 1 سے کم یا اس کے برابر ہے ، اور اگر سچ ہے تو ان پٹ سرنی کو لوٹاتا ہے۔بصورت دیگر ، فنکشن ان پٹ سرنی کے درمیانی اشاریہ کا حساب لگاتا ہے ، اور ان پٹ سرنی کو سلائس کے طریقہ کار کا استعمال کرتے ہوئے دو حصوں میں تقسیم کرتا ہے۔اس کے بعد یہ فنکشن خود کو ان پٹ سرنی کے بائیں اور دائیں حصوں کے ساتھ بار بار کال کرتا ہے ، اور انضمام کی تقریب کا استعمال کرتے ہوئے دونوں ترتیب والے حصوں کو ضم کرتا ہے۔ انضمام کی تقریب دلائل کے طور پر دو ترتیب شدہ صفوں کو لیتی ہے ، اور ضم شدہ ترتیب شدہ صف کو واپس کرتی ہے۔فنکشن انضمام شدہ صف کو اسٹور کرنے کے لئے خالی صف کا نتیجہ شروع کرتا ہے ، اور بالترتیب بائیں اور دائیں صفوں میں پوزیشنوں کو ٹریک کرنے کے لئے دو انڈیکس متغیر I اور J۔اس کے بعد فنکشن بائیں اور دائیں صفوں میں موجودہ پوزیشنوں پر اقدار کا موازنہ کرتا ہے ، اور چھوٹی قیمت کو نتائج کی صف میں دھکیل دیتا ہے۔فنکشن سرنی کے انڈیکس متغیر میں اضافہ کرتا ہے جہاں سے قدر کو دھکیل دیا جاتا تھا ، اور اس عمل کو دہراتا ہے جب تک کہ ایک صفوں میں سے ایک مکمل طور پر نہ آجائے۔اس کے بعد یہ فنکشن بائیں اور دائیں صفوں کے باقی عناصر کو نتیجہ سرنی سے جوڑتا ہے ، اور نتیجہ سرنی کو لوٹاتا ہے۔ یہاں انضمام کی تقریب کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ آر = [5 ، 2 ، 4 ، 6 ، 1 ، 3] ؛const shardarr = مرجورٹ (arr) ؛ کنسول.لوگ (shartedar) ؛// [1 ، 2 ، 3 ، 4 ، 5 ، 6]] اس مثال میں ، ہم انٹیجرز آر اے آر کی ایک صف کی وضاحت کرتے ہیں ، اور استدلال کے طور پر اے آر آر کے ساتھ انضمام کی تقریب کو کال کرتے ہیں۔ہم نتیجہ کو ایک نئے متغیر ترتیب والے کو تفویض کرتے ہیں ، اور چھانٹیار کی قیمت کو کنسول میں لاگ ان کریں ، جو [1] [2] [3] [4] [5] [6] .1 گیتھب ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: لائبریری کا استعمال: ہم ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے لئے لائبریری کا استعمال کرسکتے ہیں۔این پی ایم پر متعدد لائبریریاں دستیاب ہیں جو ٹری پر عمل درآمد فراہم کرتی ہیں ، جیسے ٹری تلاش اور ٹریجس۔یہاں ٹریجس لائبریری کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ امپورٹ {ٹری} سے 'ٹریجس' ؛ Const trie = new trie () ؛ trie.add ('ایپل') ؛ trie.add ('کیلے') ؛ trie.add ('چیری') ؛ const const = trie.find (' پابندی ') ؛ کنسول.لوگ (نتیجہ) ؛// ['کیلے'] اس مثال میں ، ہم ٹری کلاس ٹریجس لائبریری سے درآمد کرتے ہیں ، اور ایک نئی ٹری مثال تیار کرتے ہیں۔اس کے بعد ہم ایڈ کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں تین الفاظ شامل کرتے ہیں ، اور ان تمام الفاظ کو تلاش کرتے ہیں جو تلاش کے طریقہ کار کا استعمال کرتے ہوئے 'پابندی' کے سابقہ سے شروع ہوتے ہیں۔آخر میں ، ہم نتائج کی قدر کو کنسول پر لاگ ان کرتے ہیں ، جو ['کیلے'] ہونا چاہئے۔ شروع سے الگورتھم کو نافذ کرنا: ہم ٹائپ اسکرپٹ میں شروع سے ٹری الگورتھم کو بھی نافذ کرسکتے ہیں۔یہاں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ کلاس ٹرینی کوڈ {بچے: نقشہ <سٹرنگ ، ٹرائینوڈ> ؛isendofword: بولین ؛کنسٹرکٹر () {this.children = نیا نقشہ <سٹرنگ ، ٹرائینوڈ> () ؛this.isendofword = غلط ؛}} کلاس ٹری {نجی جڑ: ٹرینیوڈ ؛کنسٹرکٹر () {this.root = new trienode () ؛} داخل کریں (لفظ: سٹرنگ) {موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛آئیے نوڈ = کرنٹ.کرینین.بیٹ (چار) ؛اگر (! نوڈ) {نوڈ = نیا ٹرائینوڈ () ؛موجودہ.کرینین.سیٹ (چار ، نوڈ) ؛} موجودہ = نوڈ ؛} موجودہ.Isendofword = سچ ؛} تلاش (لفظ: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛کانسٹ نوڈ = کرنٹ.کرینین.بیٹ (چار) ؛اگر (! نوڈ) {جھوٹی لوٹنا ؛} موجودہ = نوڈ ؛current موجودہ. آئسنڈفورڈ کو لوٹائیں ؛} اسٹارٹ ویتھ (سابقہ: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <prefix.length ؛ i ++) {const char = prefix [i] ؛کانسٹ نوڈ = کرنٹ.کرینین.بیٹ (چار) ؛اگر (! نوڈ) {جھوٹی لوٹنا ؛} موجودہ = نوڈ ؛} سچ واپس ؛}} اس مثال میں ، ہم ایک ٹرائینوڈ کلاس کی وضاحت کرتے ہیں جو ٹری میں نوڈ کی نمائندگی کرتا ہے ، بچوں کے نوڈس کے نقشے کے لئے بچوں کی پراپرٹی ، اور بولین ویلیو کے لئے ایک آئسنڈوف ورڈ پراپرٹی کے ساتھ یہ ظاہر ہوتا ہے کہ آیا نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔ہم ایک ٹری کلاس کی وضاحت کرتے ہیں جو ٹری میں الفاظ داخل کرنے ، تلاش کرنے اور ڈھونڈنے کے طریقوں کے ساتھ ، ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔داخل کرنے کا طریقہ ٹری میں ایک لفظ داخل کرتا ہے ، تلاش کا طریقہ ٹری میں ایک لفظ کی تلاش کرتا ہے ، اور اسٹارٹ ویتھ طریقہ میں وہ تمام الفاظ ملتے ہیں جو ٹری میں دیئے گئے کسی سابقہ سے شروع ہوتے ہیں۔ یہاں ٹری کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ ٹرائی =نیا ٹری () tr ٹری.سرٹ ('ایپل') ؛ ٹری.سرٹ ('کیلے') ؛ ٹری.سرٹ ('چیری') ؛ کانسٹنگ رزلٹ = ٹری۔ اسٹارٹ ویتھ ('پابندی') ؛ کنسول.لوگ (نتیجہ)؛// اس مثال کے طور پر ، ہم ایک نئی ٹری مثال تیار کرتے ہیں ، اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں تین الفاظ داخل کرتے ہیں۔اس کے بعد ہم ان تمام الفاظ کو تلاش کرتے ہیں جو اسٹارٹ ویتھ کے طریقہ کار کا استعمال کرتے ہوئے 'پابندی' کے ساتھ شروع ہوتے ہیں ، اور نتائج کو ایک نئے متغیر کے نتائج پر تفویض کرتے ہیں۔آخر میں ، ہم کنسول پر نتیجہ کی قدر لاگ ان کرتے ہیں ، جو سچ ہونا چاہئے۔"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ آیا بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے متوازن ہے یا نہیں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو قطاروں کا استعمال کرتے ہوئے اسٹیک کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں دو قطاروں کا استعمال کرتے ہوئے اسٹیک کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: اسٹیک کلاس کی وضاحت کریں جو اسٹیک عناصر کو ذخیرہ کرنے کے لئے دو قطار مثالوں کا استعمال کرتا ہے۔ اسٹیک کلاس میں ایک پش طریقہ ہونا چاہئے جس میں اسٹیک کے اوپری حصے میں عنصر شامل ہوتا ہے۔، ایک پاپ طریقہ جو اسٹیک کے اوپری عنصر کو ہٹاتا ہے اور لوٹاتا ہے ، اور ایک جھانکنے والا طریقہ جو اسٹیک کے اوپری عنصر کو اسے ہٹائے بغیر لوٹاتا ہے۔ پش کے طریقہ کار کو نافذ کرنے کے ل we ، ہم نئے عنصر کو قطار میں سے ایک میں شامل کرسکتے ہیں ، اورپھر تمام عناصر کو دوسری قطار سے پہلی قطار میں منتقل کریں۔ پاپ کے طریقہ کار کو نافذ کرنے کے ل we ، ہم قطار میں سے کسی ایک کے اوپری عنصر کو ہٹا کر واپس کرسکتے ہیں۔ جھانکنے کے طریقہ کار کو نافذ کرنے کے لئے ، ہم میں سے کسی ایک کا اوپری عنصر واپس کرسکتے ہیں۔اس کو ہٹائے بغیر قطاریں۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے نفاذ ، 1 سے موافقت پذیر: ٹائپ اسکرپٹ کلاس قطار <t> {نجی اسٹوریج: t [] = [] ؛enqueue (آئٹم: t): باطل {this.storage.push (آئٹم) ؛} dequeue (): t |غیر وضاحتی {اس کو واپس کریں۔ اسٹوریج.شفٹ () ؛} سائز (): نمبر {اس کو واپس کریں۔ اسٹوریج۔ لمبائی ؛class} کلاس اسٹیک <t> {نجی قطار 1: قطار <t> = نئی قطار <t> () ؛نجی قطار 2: قطار <t> = نئی قطار <t> () ؛پش (آئٹم: ٹی): باطل {this.queue1.enqueue (آئٹم) ؛جبکہ (this.queue2.size ()> 0) {this.queue1.enqueue (this.queue2.dequeue ()!) ؛} [this.queue1 ، this.queue2] = [this.queue2 ، this.queue1] ؛} پاپ (): ٹی |غیر وضاحتی {اس کو واپس کریں۔} جھانکنے (): t |غیر وضاحتی {اس کو واپس کریں۔ کیوئ 2۔سائز ()> 0؟this.queue2.storage [0]: غیر متعینہ ؛}} اس مثال میں ، ہم ایک قطار کلاس کی وضاحت کرتے ہیں جو قطار سے عناصر کو شامل کرنے اور ہٹانے کے طریقوں کے ساتھ قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے۔ہم ایک اسٹیک کلاس کی وضاحت کرتے ہیں جو اسٹیک کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے ، جس میں اسٹیک میں موجود عناصر کو شامل کرنے ، ہٹانے اور جھانکنے کے طریقوں کے ساتھ۔اسٹیک کلاس اسٹیک عناصر کو ذخیرہ کرنے کے لئے دو قطار مثالوں کا استعمال کرتی ہے۔ اسٹیک کلاس کا پش طریقہ اسٹیک کے اوپری حصے میں ایک نیا عنصر شامل کرتا ہے جس سے اسے قطار 1 میں لگایا جاتا ہے ، اور پھر تمام عناصر کو قطار 2 سے قطار 1 میں منتقل کیا جاتا ہے۔اس کے بعد یہ طریقہ قطار 1 اور قطار 2 کے حوالوں کو تبدیل کرتا ہے۔ اسٹیک کلاس کا پاپ طریقہ قطار 2 سے کسی عنصر کو ختم کرکے اسٹیک کے اوپری عنصر کو ہٹاتا ہے اور واپس کرتا ہے۔ اسٹیک کلاس کا جھانکنے والا طریقہ اسٹیک کے اوپری عنصر کو ہٹائے بغیر واپس کرتا ہے۔یہ قطار 2 کے پہلے عنصر کو واپس کرکے۔ یہاں اسٹیک کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ اسٹیک = نیا اسٹیک <نمبر> () ؛ اسٹیک.پش (1) ؛ اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛کنسول.لاگ (اسٹیک.پیک ()) ؛// 3console.log (stack.pop ()) ؛// 3console.log (stack.pop ()) ؛// 2console.log (stack.pop ()) ؛// 1console.log (stack.pop ()) ؛// اس مثال کے طور پر ، ہم ایک نیا اسٹیک مثال تیار کرتے ہیں ، اور پش کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک میں تین عناصر شامل کرتے ہیں۔اس کے بعد ہم جھانکنے کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے اوپری عنصر پر جھانک کر کنسول پر قیمت لگاتے ہیں ، جو 3 ہونا چاہئے۔بالترتیب 2 ، اور 1۔آخر میں ، ہم کوشش کرتے ہیں کہ پاپ کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک سے کسی اور عنصر کو ختم کریں ، اور کنسول پر قیمت لاگ ان کریں ، جس کی وضاحت نہیں کی جانی چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے ل we ، ہم مختلف نقطہ نظر استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: ایک لالچی الگورتھم کا استعمال: ہم عددیوں کی ایک صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے لالچی الگورتھم کا استعمال کرسکتے ہیں۔ہم ایک ایسے فنکشن کی وضاحت کرسکتے ہیں جو ایک دلیل کے طور پر عدد کی ایک صف لیتا ہے ، اور صف میں ہر نمبر پر تکرار کرتا ہے۔ہر ایک تعداد کے ل we ، ہم موجودہ رقم کو جو بھی بڑا ہو اس کے لئے ترتیب دے سکتے ہیں: موجودہ نمبر کے علاوہ موجودہ رقم ، یا موجودہ نمبر۔ہم زیادہ سے زیادہ رقم بھی طے کرسکتے ہیں جو بھی بڑا ہو: موجودہ رقم یا موجودہ زیادہ سے زیادہ رقم۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن میکسبریری (نمبر: نمبر []): نمبر {کرینٹم = نمبر [0] ؛آئیے maxsum = nums [0] ؛کے لئے (آئیے i = 1 ؛ i <nums.length ؛ i ++) {کرینٹسم = math.max (nums [i] ، کرینٹسم+نمبر [i]) ؛میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛max میکسم واپسی ؛ اس مثال میں ، ہم ایک میکسبرری فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عدد کی ایک صف لیتا ہے ، اور زیادہ سے زیادہ سبری کا مجموعہ واپس کرتا ہے۔فنکشن ان پٹ سرنی کے پہلے عنصر میں کرینٹم اور میکسم متغیرات کی ابتدا کرتا ہے۔اس کے بعد یہ فنکشن ان پٹ سرنی کے باقی عناصر پر تکرار کرتا ہے ، اور کرینسم متغیر کو جو بھی بڑا ہوتا ہے اسے طے کرتا ہے: موجودہ عنصر کے علاوہ کرینٹم متغیر ، یا موجودہ عنصر۔فنکشن میکسم متغیر کو بھی جو بھی بڑا ہو اس کے لئے مقرر کرتا ہے: کرینٹم متغیر یا میکسم متغیر۔اس کے بعد فنکشن میکسم متغیر کو لوٹاتا ہے۔ یہاں میکسبرری فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ نمبر = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] ؛ کانسٹنگ نتیجہ = میکسبرے (نمبرز) ؛ کنسول.لوگ (نتیجہ) ؛// 6 میں اس مثال کے طور پر ، ہم انٹیجر نمبروں کی ایک صف تیار کرتے ہیں ، اور دلیل کے طور پر NUMS کے ساتھ میکسبرری فنکشن کو کال کرتے ہیں۔ہم نتیجہ کو ایک نئے متغیر کے نتائج پر تفویض کرتے ہیں ، اور نتائج کی قیمت کو کنسول پر لاگ ان کریں ، جو 6. کڈانے کے الگورتھم کا استعمال کرتے ہوئے ہونا چاہئے: ہم عددیوں کی ایک صف میں زیادہ سے زیادہ سبریئر کی رقم تلاش کرنے کے لئے کڈانے کے الگورتھم کا بھی استعمال کرسکتے ہیں۔کڈانے کا الگورتھم لالچی الگورتھم سے ملتا جلتا ہے ، لیکن اس میں کرینسم متغیر کو اپ ڈیٹ کرنے کے لئے قدرے مختلف نقطہ نظر کا استعمال کیا جاتا ہے۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 2 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن میکسبری (نمبر: نمبر []): نمبر {آئیے میکسوفر = نمبر [0] ؛آئیے maxiendHere = nums [0] ؛کے لئے (آئیے i = 1 ؛ i <nums.length ؛ i ++) {maxundeHere = math.max (nums [i] ، میکسینڈی ہیر+نمبر [i]) ؛میکسوفر = میتھ.میکس (میکسوفر ، میکسینڈیئر) ؛max میکسفار کو واپس کریں ؛} اس مثال میں ، ہم ایک میکسبری فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عددیوں کی ایک صف لیتا ہے ، اور زیادہ سے زیادہ سبری کا مجموعہ واپس کرتا ہے۔فنکشن ان پٹ سرنی کے پہلے عنصر کے لئے میکس سافر اور میکسینڈی ہائیر متغیرات کی ابتدا کرتا ہے۔اس کے بعد یہ فنکشن ان پٹ سرنی کے باقی عناصر پر تکرار کرتا ہے ، اور میکسینڈی ہائیر متغیر کو جو بھی بڑا ہوتا ہے اسے طے کرتا ہے: موجودہ عنصر یا موجودہ عنصر کے علاوہ میکسینڈیئر متغیر۔فنکشن میکسسفر متغیر کو بھی جو بھی بڑا ہو اس کے لئے بھی طے کرتا ہے: میکس سافر متغیر یا میکسینڈی ہائر متغیر۔اس کے بعد فنکشن میکس سافر متغیر کو لوٹاتا ہے۔ یہاں میکسبرری فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ نمبر = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] ؛ کانسٹنگ نتیجہ = میکسبرے (نمبرز) ؛ کنسول.لوگ (نتیجہ) ؛// 6 میں اس مثال کے طور پر ، ہم انٹیجر نمبروں کی ایک صف تیار کرتے ہیں ، اور دلیل کے طور پر NUMS کے ساتھ میکسبرری فنکشن کو کال کرتے ہیں۔ہم نتیجہ کو ایک نئے متغیر کے نتائج پر تفویض کرتے ہیں ، اور کنسول پر نتیجہ کی قیمت کو لاگ ان کریں ، جو 6.1 کوڈیبن 2 جی ای ای ایکسفورجیکس ہونا چاہئے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ کلاس بائنری ہیپ <t> {نجی ہیپ: ٹی [] ؛نجی موازنہ: (a: t ، b: t) => نمبر ؛کنسٹرکٹر (موازنہ: (a: t ، b: t) => نمبر) {this.heap = [] ؛this.compare = موازنہ ؛} شامل کریں (آئٹم: ٹی): باطل {this.heap.push (آئٹم) ؛this.bubbleup (this.heap.length - 1) ؛} ہٹائیں (): t |غیر متعینہ {Const آخری = this.heap.pop () ؛اگر (this.heap.length> 0) {const آئٹم = this.heap [0] ؛this.heap [0] = آخری !؛this.bbbledown (0) ؛آئٹم واپس ؛} دوسری {آخری واپسی ؛}} نجی بلبلاپ (انڈیکس: نمبر): باطل {کانٹ آئٹم = this.heap [انڈیکس] ؛جبکہ (انڈیکس> 0) {const parentIndex = math.floor ((انڈیکس - 1) / 2) ؛CONT والدین = this.heap [parentIndex] ؛اگر (this.compare (آئٹم ، والدین)> = 0) {بریک ؛} this.heap [انڈیکس] = والدین ؛انڈیکس = پیرنٹ انڈیکس ؛} this.heap [انڈیکس] = آئٹم ؛} نجی بلبلیڈاؤن (انڈیکس: نمبر): باطل {کانٹ آئٹم = this.heap [انڈیکس] ؛کانسٹ لمبائی = this.heap.length ؛جبکہ (سچ) {کانسٹ لیفٹائلڈ انڈیکس = 2 * انڈیکس + 1 ؛کونٹ رائٹچلڈ انڈیکس = 2 * انڈیکس + 2 ؛بائیں بائیں: t |غیر متعینہ ؛چلو دائیں بچے: ٹی |غیر متعینہ ؛آئیے swapindex = انڈیکس ؛اگر (بائیں طرف سے <لمبائی) {بائیں بچے = this.heap [lethidchidindex] ؛اگر (this.compare (بائیں بچے ، آئٹم) <0) {swapIndex = بائیں طرف کاندیکس ؛}} if (RITELDINDEX <لمبائی) {دائیں بچے = this.heap [رائٹچلڈ انڈیکس] ؛اگر ((بائیں بچے === غیر متعینہ && اس ڈاٹ پیئر (رائٹائڈ ، آئٹم) <0) || (بائیں بچے! == غیر متعینہ && اس ڈاٹ کام پیری (دائیں بچے ، بائیں بچے) <0)) {سویپینڈیکس = رائٹچلڈ انڈیکس ؛}} if (swapindex === انڈیکس) {بریک ؛} this.heap [index] = this.heap [swapindex] ؛انڈیکس = سویپ انڈیکس ؛} this.heap [انڈیکس] = آئٹم ؛}} ٹائپ اسکرپٹکونسٹ ہیپ = نیا بائنری ہیپ <نمبر> ((a ، b) => a - b) ؛ ہیپ.اڈ (3) ؛ ہیپ.اڈ (1) ؛ ہیپ.اڈ (4) ؛ ہیپ.اڈ (1)؛ ہیپ.اڈ (5) ؛ کنسول.لوگ (ہیپ.میمو ()) ؛// 1console.log (ہیپ.رموو ()) ؛// 1console.log (ہیپ.رموو ()) ؛// 3console.log (ہیپ.رموو ()) ؛// 4console.log (ہیپ.رموو ()) ؛// 5console.log (ہیپ.رموو ()) ؛// undefinedTypescriptimport {بائنری ہیپ} سے 'ہیپس' ؛ کانسٹ ہیپ = نیا بائنری ہیپ <نمبر> ((ا ، بی"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ فینکشن سب سے طویل پیلنڈرووم (ایس: سٹرنگ): سٹرنگ {کانسٹ این = ایس لمبائی ؛کانسٹ ڈی پی: بولین [] [] = سرنی۔سب سے طویل = '' ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {dp [i] [i] = سچ ؛سب سے طویل = s [i] ؛} کے لئے (آئیے i = n-1 ؛ i> = 0 ؛ i--) {for (j = i+1 ؛ j <n ؛ j ++) {اگر (s [i] === s [j]){if (j - i === 1 || dp [i + 1] [j - 1]) {dp [i] [j] = سچ ؛اگر (j - i + 1> طویل ترین۔ لمبائی) {طویل ترین = s.substring (i ، j + 1) ؛}}}}} طویل ترین لوٹنا ؛} ٹائپ اسکرپٹکونسٹ s = 'باباد' ؛ کانسٹنگ نتیجہ = طویل ترین پلائنڈرووم (ایس) ؛ کنسول.لوگ (نتیجہ) ؛// 'بابٹائپیسکرپٹ فنکشن سب سے طویل ترین پلائنڈرووم (ایس: سٹرنگ): سٹرنگ {طویل ترین =' '؛کے لئے (آئیے i = 0 ؛ i <s.length ؛ i ++) {چھوڑ دیں = i ؛چلو دائیں = i ؛جبکہ (بائیں> = 0 && دائیں <s.length && s [بائیں] === s [دائیں]) {بائیں-- ؛حق ++ ؛} کونٹ پیلنڈرووم = ایس سیبسٹرنگ (بائیں + 1 ، دائیں) ؛if (palindrome.length> طویل ترین۔ لمبائی) {طویل ترین = palindrome ؛} بائیں = i ؛دائیں = i + 1 ؛جبکہ (بائیں> = 0 && دائیں <s.length && s [بائیں] === s [دائیں]) {بائیں-- ؛حق ++ ؛} const Evenpalindrome = s.substring (بائیں + 1 ، دائیں) ؛if (evepalindrome.length> طویل ترین۔ لمبائی) {طویل ترین = Evenpalindrome ؛}} سب سے طویل واپسی ؛} ٹائپ اسکرپٹکونسٹ s = 'باباد' ؛ کانسٹنگ کا نتیجہ = طویل ترین پالندرووم (ایس) ؛ کنسول.لوگ (نتیجہ) ؛// 'باب'"
    },
    {
        "Question": "ملحقہ میٹرکس کو نافذ کریں اور ٹائپ اسکرپٹ میں گراف کی نمائندگی کرنے کے لئے اس کا استعمال کریں۔",
        "Answer": "کسی ملحقہ میٹرکس کو نافذ کرنے اور ٹائپ اسکرپٹ میں گراف کی نمائندگی کرنے کے لئے اس کا استعمال کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کا استعمال کرسکتے ہیں: گراف کے ملحقہ میٹرکس کو ذخیرہ کرنے کے لئے ایک گراف کلاس کی وضاحت کریں۔ گراف کلاس میں عمودی کو شامل کرنے کے طریقے ہونا چاہئے۔اور گراف کے کنارے ، اور ایک ورٹیکس کے پڑوسیوں کو حاصل کرنے کے ل .۔ ایڈورٹیکس کے طریقہ کار کو نافذ کرنے کے ل we ، ہم ملحقہ میٹرکس میں ایک نئی قطار اور کالم شامل کرسکتے ہیں ، اور ان کو 0. ایڈجڈ کے طریقہ کار کو نافذ کرنے کے لئے شروع کرسکتے ہیں ، ہم سیٹ کرسکتے ہیں۔ملحقہ میٹرکس میں اسی عنصر سے متعلق عنصر 1. گیٹ نیبس کے طریقہ کار کو نافذ کرنے کے ل we ، ہم ملحقہ میٹرکس میں متعلقہ ورٹیکس کی قطار پر تکرار کرسکتے ہیں ، اور کالموں کے اشارے واپس کرسکتے ہیں جس کی قیمت 1. اس کی ایک مثال ہے۔ٹائپ اسکرپٹ میں نقطہ نظر ، 1 سے موافقت پذیر: ٹائپ اسکرپٹ کلاس گراف {نجی ملحقہ میٹرکس: نمبر [] [] ؛کنسٹرکٹر (نجی نمبر: نمبر) {this.adjacencymatrix = array.from ({لمبائی: Numvertices} ، () => سرنی.فرم ({لمبائی: نمبر} ، () => 0)) ؛} ایڈورٹیکس (): باطل {this.numvertices ++ ؛this.adjacencymatrix.foreach ((قطار) => قطار.پش (0)) ؛this.adjacencymatrix.push (array.from ({لمبائی: this.numvertices} ، () => 0)) ؛} ایڈج (سے: نمبر ، سے: نمبر): باطل {this.adjacencymatrix [سے] [سے] = 1 ؛this.adjacencymatrix [to] [سے] = 1 ؛} getneighbors (vertex: نمبر): نمبر [] {کنسٹ پڑوسی: نمبر [] = [] ؛کے لئے (i = 0 ؛ i <this.numvertices ؛ i ++) {اگر (this.adjacencymatrix [vertex] [i] === 1) {پڑوسی.پش (i) ؛}} پڑوسیوں کی واپسی ؛}} اس مثال میں ، ہم ایک گراف کلاس کی وضاحت کرتے ہیں جو گراف میں اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے ، جس میں گراف میں عمودی اور کناروں کو شامل کرنے کے طریقے ، اور ایک ورٹیکس کے پڑوسیوں کو حاصل کرنے کے طریقوں کے ساتھ۔کلاس گراف کے ملحقہ میٹرکس کو ذخیرہ کرنے کے لئے دو جہتی صف کا استعمال کرتی ہے۔ایڈورٹیکس کا طریقہ ملحقہ میٹرکس میں ایک نئی قطار اور کالم کا اضافہ کرتا ہے ، اور ان کو 0 پر شروع کرتا ہے۔ ایڈجج کا طریقہ ملحقہ میٹرکس میں اسی عنصر کو 1. پر طے کرتا ہے۔اور کالموں کے اشارے واپس کرتا ہے جس کی قیمت 1. گراف کلاس کا ایک مثال ہے: ٹائپ اسکرپٹکونسٹ گراف = نیا گراف (4) ؛ گراف.ڈیج (0 ، 1) ؛ گراف.ڈیج (0 ، 2) ؛گراف.اڈیج (1 ، 2) ؛ گراف.ڈیج (2 ، 0) ؛ گراف.ڈیج (2 ، 3) ؛ گراف.ڈیج (3 ، 3) ؛ کنسول.لوگ (گراف.جیٹ نیببرس (2)) ؛// [0 ، 1 ، 3] اس مثال میں ، ہم 4 عمودی کے ساتھ ایک نیا گراف مثال تیار کرتے ہیں ، اور ایڈج کے طریقہ کار کا استعمال کرتے ہوئے گراف میں 6 کناروں کو شامل کرتے ہیں۔اس کے بعد ہم گیٹ نیببرس کے طریقہ کار کا استعمال کرتے ہوئے ورٹیکس 2 کے پڑوسیوں کو حاصل کرتے ہیں ، اور کنسول کی قیمت کو لاگ ان کریں ، جو [0] [1] [3] ہونا چاہئے۔ٹائپ اسکرپٹ 1 ہیزمین"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے درخت پر گہرائی سے پہلے تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کلاس ٹرینوڈ {ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = ویل ==== غیر متعینہ؟0: ویل ؛this.left = بائیں === غیر متعینہ؟NULL: بائیں ؛this.right = دائیں === غیر متعینہ؟NULL: ٹھیک ہے ؛}} فنکشن ڈی ایف ایس (نوڈ: ٹرینوڈ | نول ، ملاحظہ کریں: سیٹ <ٹریئنوڈ>): باطل {اگر (نوڈ ==== null) {واپسی ؛} ملاحظہ کریں۔ ایڈ (نوڈ) ؛ڈی ایف ایس (نوڈ.لفٹ ، ملاحظہ کیا گیا) ؛ڈی ایف ایس (نوڈ۔ رائٹ ، ملاحظہ کیا گیا) ؛} کنسٹ روٹ = نیا ٹرینوڈ (1 ، نیا ٹرینوڈ (2 ، نیا ٹرینوڈ (4) ، نیا ٹرینوڈ (5)) ، نیا ٹرینوڈ (3 ، نیو ٹرینوڈ (6) ، نیو ٹرینوڈ (نیو ٹرینوڈ (نیو ٹرینوڈ7))) ؛ کنسٹ ملاحظہ کریں = نیا سیٹ <ٹرینائڈ> () ؛ ڈی ایف ایس (جڑ ، ملاحظہ) ؛ کنسول.لوگ (ملاحظہ کیا گیا) ؛// سیٹ {ٹرینوڈ {ویل: 1 ، بائیں: ٹرینوڈ {ویل: 2 ، بائیں: [ٹرینوڈ] ، دائیں: [ٹرینوڈ]} ، دائیں: ٹرینوڈ {ویل: 3 ، بائیں: [ٹرینوڈ] ، دائیں: [ٹرینوڈ]}} ، ٹرینوڈ {ویل: 2 ، بائیں: ٹرینوڈ {ویل: 4} ، دائیں: ٹرینوڈ {ویل: 5}} ، ٹرینوڈ {ویل: 3 ، بائیں: ٹرینوڈ {ویل: 6} ، دائیں: ٹرینوڈ {ویل: 7}} ، ٹرینوڈ {ویل: 4} ، ٹرینوڈ {ویل: 5} ، ٹرینوڈ {ویل: 6} ، ٹرینوڈ {ویل: 7}} ٹائپ اسکرپٹ کلاس ٹرینیوڈ {ویل: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = ویل ==== غیر متعینہ؟0: ویل ؛this.left = بائیں === غیر متعینہ؟NULL: بائیں ؛this.right = دائیں === غیر متعینہ؟NULL: ٹھیک ہے ؛}} فنکشن ڈی ایف ایس (نوڈ: ٹرینوڈ | null): treenode [] {اگر (نوڈ === null) {واپسی [] ؛} کنسٹ اسٹیک: ٹرینوڈ [] = [نوڈ] ؛کنسٹ وزٹ: ٹرینوڈ [] = [] ؛جبکہ (stac.length> 0) {const موجودہ = stack.pop () !؛ملاحظہ کریں۔ پش (موجودہ) ؛اگر (موجودہ۔ رائٹ! == null) {stack.push (موجودہ. رائٹ) ؛} if (current.left! == null) {stack.push (موجودہ. لیفٹ) ؛}} واپسی کا دورہ ؛} کنسٹ روٹ = نیا ٹرینوڈ (1 ، نیا ٹرینوڈ (2 ، نیا ٹرینوڈ (4) ، نیا ٹرینوڈ (5)) ، نیا ٹرینوڈ (3 ، نیا ٹرینوڈ (6) ، نیا ٹرینوڈ (7))))const کانسٹ ملاحظہ کریں = ڈی ایف ایس (جڑ) ؛ کنسول.لوگ (ملاحظہ کریں) ؛// [ٹرینوڈ {ویل: 1 ، بائیں: ٹرینوڈ {ویل: 2 ، بائیں: [ٹرینوڈ] ، دائیں: [ٹرینوڈ]} ، دائیں: ٹرینوڈ {ویل: 3 ، بائیں: [ٹرینوڈ] ، دائیں: [ٹرینوڈ]}} ، ٹرینوڈ {ویل: 2 ، بائیں: ٹرینوڈ {ویل: 4} ، دائیں: ٹرینوڈ {ویل: 5}} ، ٹرینوڈ {ویل: 4} ، ٹرینوڈ {ویل: 5} ، ٹرینوڈ {ویل: 3 ، بائیں: ٹرینوڈ{ویل: 6} ، دائیں: ٹرینوڈ {ویل: 7}} ، ٹرینوڈ {ویل: 6} ، ٹرینوڈ {ویل: 7}]"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں راہ کمپریشن کے ساتھ ایک ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں پاتھ کمپریشن کے ساتھ ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک ڈس ڈیسنٹ سیٹ کلاس کی وضاحت کریں جو سیٹ میں ہر عنصر کے والدین کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرتا ہے۔ ڈس ڈیسائٹ سیٹ کلاس میں ایک نیا بنانے کے طریقے ہونا چاہئے۔سیٹ کریں ، کسی عنصر کے والدین کو تلاش کریں ، اور دو سیٹوں کو ضم کریں۔ تخلیق کے طریقہ کار کو نافذ کرنے کے ل we ، ہم صف میں ایک نیا عنصر شامل کرسکتے ہیں ، اور اس کے والدین کو خود ہی مرتب کرسکتے ہیں۔ تلاش کے طریقہ کار کو نافذ کرنے کے ل we ، ہم بار بار والدین کو تلاش کرسکتے ہیں۔ایک عنصر ، اور ہر عنصر کے والدین کو جڑ کی راہ میں خود کو اپ ڈیٹ کریں۔ یونین کے طریقہ کار کو نافذ کرنے کے ل we ، ہم دونوں عناصر کے والدین کو تلاش کرسکتے ہیں ، اور ایک عنصر کے والدین کو دوسرے پر رکھ سکتے ہیں۔ٹائپ اسکرپٹ میں اس نقطہ نظر کا نفاذ ، 1 سے موافقت پذیر: ٹائپ اسکرپٹ کلاس ڈسوائٹ سیٹ {نجی والدین: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.pearnt = سرنی.فرم ({لمبائی: سائز} ، (_ ، i) => i) ؛} تخلیق (): باطل {this.parent.push (this.parent.length) ؛} تلاش کریں (x: نمبر): نمبر {if (this.parent [x]! == x) {this.palent [x] = this.find (this.parent [x]) ؛this اس کو واپس کریں۔ والدین [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛یہ۔ والدین}} اس مثال میں ، ہم ایک ناگوار طبقے کی وضاحت کرتے ہیں جو راستے کے کمپریشن کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔کلاس ہر عنصر کے والدین کو سیٹ میں ذخیرہ کرنے کے لئے ایک صف کا استعمال کرتی ہے۔تخلیق کا طریقہ کار سرنی میں ایک نیا عنصر شامل کرتا ہے ، اور اپنے والدین کو خود ہی مقرر کرتا ہے۔تلاش کرنے کا طریقہ کسی عنصر کے والدین کو بار بار تلاش کرتا ہے ، اور جڑ کی راہ میں ہر عنصر کے والدین کو خود ہی اپ ڈیٹ کرتا ہے۔یونین کا طریقہ کار دونوں عناصر کے والدین کو تلاش کرتا ہے ، اور ایک عنصر کے والدین کو دوسرے پر سیٹ کرتا ہے۔ یہاں ڈس ڈیسپیٹ سیٹ کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ DSU = نیا ڈسوائٹ سیٹ (5) ؛ dsu.createset () ؛ dsu.createSet () ؛ dsu.createset () ؛ dsu.union (0 ، 1) d dsu.union (1 ، 2) ؛ کنسول.لوگ (dsu.find (0)) ؛// 2console.log (dsu.find (1)) ؛// 2console.log (dsu.find (2)) ؛// 2console.log (dsu.find (3)) ؛// 3console.log (dsu.find (4)) ؛// 4 اس مثال کے طور پر ، ہم 5 عناصر کے ساتھ ایک نیا ڈس ڈیس سیٹس مثال تیار کرتے ہیں ، اور تخلیق کے طریقہ کار کا استعمال کرتے ہوئے سیٹ میں 3 نئے عناصر شامل کرتے ہیں۔اس کے بعد ہم یونین کے طریقہ کار کا استعمال کرتے ہوئے پہلے 3 عناصر کو ایک ہی سیٹ میں ضم کرتے ہیں۔ہم ہر عنصر پر تلاش کرنے کا طریقہ کہتے ہیں ، اور کنسول پر نتیجہ لاگ ان کریں ، جو پہلے 3 عناصر کے لئے 2 ہونا چاہئے ، اور آخری 2 عناصر کے لئے خود عنصر کا اشاریہ ہونا چاہئے۔com/discoint-set-data-structure-ion-find-algorithm-typescript/1 coursera"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیئے گئے گراف ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دو طرفہ ہے۔",
        "Answer": "ٹائپ اسکرپٹ فنکشن isbipartite (گراف: نمبر [] []): بولین {const n = گراف.لننگ ؛CONSTORS = نئی سرنی (n). فل (0) ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اگر (رنگ [i] === 0) {کانسٹ قطار: نمبر [] = [i] ؛رنگ [i] = 1 ؛جبکہ (قطار۔ لمبائی> 0) {کونسٹ یو = قطار۔ شفٹ () !؛کے لئے (گراف کا کونسٹ وی [u]) {اگر (رنگ [v] === رنگ [u]) {غلط لوٹیں ؛} if (رنگ [v] === 0) {رنگ [v] = -کلورز [u] ؛قطار.پش (V) ؛}}}}} سچ کی واپسی ؛} ٹائپ اسکرپٹکونسٹ گراف = [[1 ، 3] ، [0 ، 2] ، [1 ، 3] ، [0 ، 2] ،] ؛ کنسول.لوگ (isbipartite (گراف)) ؛// trueconst گراف 2 = [[1 ، 2 ، 3] ، [0 ، 2] ، [0 ، 1] ، [0 ، 4] ، [3] ،] ؛ کنسول.لوگ (isbipartite (گراف 2)) ؛// فالس ٹائپ اسکرپٹ فنکشن isbipartite (گراف: نمبر [] [])): بولین {const n = گراف.لننگ ؛CONSTORS = نئی سرنی (n). فل (0) ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اگر (رنگ [i] === 0 &&! dfs (i ، 1 ، رنگ ، گراف)) {غلط واپس ؛}} سچائی واپس ؛} فنکشن ڈی ایف ایس (یو: نمبر ، رنگ: رنگ: رنگ: نمبر [] ، گراف: نمبر [] []): بولین {رنگ [u] = رنگ ؛کے لئے (گراف [u]) کے لئے {اگر (رنگ [v] === رنگ) {غلط واپس ؛} if (رنگ [v] === 0 &&! dfs (v ، -color ، رنگ ، گراف)) {غلط واپس ؛}} سچ واپس کریں ؛} ٹائپ اسکرپٹ کنسٹ گراف = [[1 ، 3] ، [0 ، 2] ، [1 ، 3] ، [0 ، 2] ،] ؛ کنسول.لوگ (isbipartite (گراف)) ؛// trueconst گراف 2 = [[1 ، 2 ، 3] ، [0 ، 2] ،"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک بلوم فلٹر کلاس کی وضاحت کریں جو فلٹر کو ذخیرہ کرنے کے لئے بٹس کی ایک صف کا استعمال کرتا ہے ، اور ان پٹ اقدار ہیش کے لئے ہیش کے افعال کی ایک صف کا استعمال کرتا ہے۔ بلوم فلٹر۔کلاس کے پاس فلٹر میں اقدار کو شامل کرنے ، یہ جانچ پڑتال کرنا چاہئے کہ آیا کوئی قیمت فلٹر میں ہے یا نہیں ، اور فلٹر کی غلط مثبت شرح کا حساب لگانا۔ ADD کے طریقہ کار کو نافذ کرنے کے ل we ، ہم ہر ہیش فنکشن کا استعمال کرتے ہوئے ان پٹ ویلیو ہیش کرسکتے ہیں ، اور سیٹ کریں۔فلٹر میں اسی طرح کے بٹس 1. کے طریقہ کار کو نافذ کرنے کے ل we ، ہم ہر ہیش فنکشن کا استعمال کرتے ہوئے ان پٹ ویلیو ہیش کرسکتے ہیں ، اور یہ چیک کرسکتے ہیں کہ فلٹر میں متعلقہ بٹس سبھی ہیں۔ شرح کے طریقہ کار کو نافذ کرنے کے ل we ، ہم فارمولا استعمال کرسکتے ہیں (ہم فارمولہ استعمال کرسکتے ہیں (1 - e^( - kn/m))^K ، جہاں فلٹر میں عناصر کی تعداد ہے ، M بٹس میں فلٹر کا سائز ہے ، اور K ہیش فنکشن کی تعداد ہے۔ اس کی مثال کے طور پر عمل درآمدٹائپ اسکرپٹ میں نقطہ نظر ، 1 سے موافق: ٹائپ اسکرپٹ کلاس بلوم فلٹر {نجی فلٹر: بولین [] ؛کنسٹرکٹر (نجی سائز: نمبر ، نجی ہیشفکشن: ((قدر: سٹرنگ) => نمبر) []) {this.filter = نیا سرنی (سائز). فل (غلط) ؛} شامل کریں (ویلیو: سٹرنگ): باطل {کے لئے (اس کی کانسٹی ہیشفکشن) کے لئے۔this.filter [انڈیکس] = سچ ؛}} ہے (ویلیو: سٹرنگ): بولین {کے لئے (اس کی کونٹ ہشفکشن) {کانٹ انڈیکس = ہیش فنکشن (قدر) ٪ ٪ this.size ؛اگر (! this.filter [index]) {غلط واپس ؛}} سچ واپس ؛} شرح (): نمبر {const n = this.filter.filter ((بٹ) => بٹ). لمبائی ؛const m = this.size ؛const k = this.hashfunctions.length ؛واپس میتھ.پو (1 - math.exp (-k * n / m) ، k) ؛}} اس مثال میں ، ہم ایک بلوم فلٹر کلاس کی وضاحت کرتے ہیں جو ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔کلاس فلٹر کو ذخیرہ کرنے کے لئے بٹس کی ایک صف کا استعمال کرتی ہے ، اور ان پٹ اقدار کو ہیش کرنے کے لئے ہیش کے افعال کی ایک صف کا استعمال کرتی ہے۔شامل کرنے کا طریقہ ہر ہیش فنکشن کا استعمال کرتے ہوئے ان پٹ ویلیو ہیش کرتا ہے ، اور فلٹر میں اسی طرح کے بٹس کو 1 پر سیٹ کرتا ہے۔ ہر ہیش فنکشن کا استعمال کرتے ہوئے ان پٹ ویلیو ہیش کرتا ہے ، اور اگر فلٹر میں متعلقہ بٹس سب 1. شرح ہیں تو چیک کرتا ہے۔طریقہ فارمولا (1 - E^( - KN/M))^K کا استعمال کرتے ہوئے فلٹر کی غلط مثبت شرح کا حساب لگاتا ہے ، جہاں فل فلٹر میں عناصر کی تعداد ہے ، میٹر بٹس میں فلٹر کا سائز ہے ، اور Kہیش فنکشن کی تعداد ہے۔ بلوم فلٹر کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ ہیش فنکشن = [(ویلیو: سٹرنگ) => ویلیو.چار کوڈیٹ (0) ، (ویلیو: سٹرنگ) => ویلیو ۔چار کوڈیٹ (1) ، (قیمت (قیمت).) ؛ بلومفیلٹر.اڈڈ (\"AASDF\") ؛ بلومفلٹر.اڈ (\"ٹیسٹ 123\") ؛ بلومفیلٹر.اڈڈ (\"ٹیسٹ 1234\") ؛ بلومفیلٹر.اڈڈ (\"1234\") ؛ بلومفیلٹر.اڈی (\"پاس ورڈ\") ؛ کنسول.لاگ) ؛ کنسول.لوگ) ؛(بلومفلٹر۔ ہاس (\"ہیلو\")) ؛// trueconsole.log (bloomfilter.has (\"دنیا\")) ؛// trueconsole.log (bloomfilter.has (\"foo\")) ؛// falseconsole.log (bloomfilter.rate ()) ؛// 0.000232779760413644 اس مثال کے طور پر ، ہم 1000 بٹس اور 3 ہیش افعال کے سائز کے ساتھ ایک نیا بلوم فلٹر مثال تیار کرتے ہیں۔ہم ADD کے طریقہ کار کا استعمال کرتے ہوئے فلٹر میں 8 اقدار شامل کرتے ہیں ، اور چیک کریں کہ آیا 3 اقدار فلٹر میں ہیں جس کا طریقہ استعمال کرتے ہیں۔ہم شرح کے طریقہ کار کا استعمال کرتے ہوئے فلٹر کی غلط مثبت شرح کا بھی حساب لگاتے ہیں ، اور نتائج کو کنسول پر لاگ ان کریں۔ ریفرنسز: 2https: //stackoverflow.com/questions/48727174/bloom-filters-and-its-multiple-hash-functions1https"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف پر ٹوپولوجیکل ترتیب دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ میں K-D درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری درخت میں دو نوڈس کے سب سے کم عام اجداد کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک سپلی ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے نیٹ ورک کے بہاؤ میں زیادہ سے زیادہ بہاؤ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے نیٹ ورک کے بہاؤ میں زیادہ سے زیادہ بہاؤ تلاش کرنے کے ل we ، ہم فورڈ فلکرسن الگورتھم کا استعمال کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں الگورتھم کا ایک مثال عمل ہے ، جس میں 1: ٹائپ اسکرپٹ کلاس ایج {کنسٹرکٹر (عوامی: نمبر ، عوام سے: نمبر ، عوامی صلاحیت: نمبر: نمبر) {}} کلاس فلوونیٹ ورک {نجی کناروں: کنارے [] = [] ؛نجی اڈج: نمبر [] [] = [] ؛کنسٹرکٹر (نجی N: نمبر) {for (i = 0 ؛ i <n ؛ i ++) {this.adj.push ([]) ؛}} ایڈج (سے: نمبر ، سے: نمبر ، صلاحیت: نمبر): باطل {کانٹ ایج = نیا کنارے (سے ، سے ، صلاحیت) ؛this.edges.push (کنارے) ؛this.adj [from] .push (this.edges.length - 1) ؛this.adj [to] .push (this.edges.length - 1) ؛} میکس فلو (ماخذ: نمبر ، سنک: نمبر): نمبر {کانسٹ فلو: نمبر [] = نیا سرنی (this.edges.length). مکمل (0) ؛آئیے زیادہ سے زیادہ = 0 ؛جبکہ (سچ) {cont والدین: نمبر [] = نیا سرنی (this.n) .fill (-1) ؛کانسٹ قطار: نمبر [] = [ماخذ] ؛جبکہ (قطار۔ لمبائی> 0 && والدین [سنک] === -1) {کونسٹ نوڈ = قطار۔ شفٹ () !؛کے لئے (اس کا کانسٹ ایج انڈیکس۔ اے ڈی جے [نوڈ]) {کونٹ ایج = this.edges [ایج انڈیکس] ؛if (والدین [ایج.ٹو] === -1 && ایج. کیپاسٹی> بہاؤ [ایج انڈیکس]) {والدین [ایج ڈاٹ ٹو] = ایج انڈیکس ؛قطار.پش (ایج ڈاٹ ٹی او) ؛}}} اگر (والدین [سنک] === -1) {بریک ؛path راستہ بہاؤ = انفینٹی ؛کے لئے (آئیے نوڈ = سنک ؛ نوڈ! == ماخذ ؛ نوڈ = this.edges [والدین [نوڈ]]۔پاتھ فلو = میتھ.مین (پاتھ فلو ، یہ۔ ایڈیجز [ایج انڈیکس]. کیپسٹی - بہاؤ [ایج انڈیکس]) ؛} کے لئے (آئیے نوڈ = ڈوبنے دیں ؛ نوڈ! == ماخذ ؛ نوڈ = this.edges [والدین [نوڈ]]۔بہاؤ [ایج انڈیکس] += پاتھ فلو ؛بہاؤ [ایج انڈیکس ^ 1] -= راستہ ؛} میکس فلو += پاتھ فلو ؛} میکس فلو کی واپسی ؛example اس مثال میں ، ہم ایک ایسے کنارے کی کلاس کی وضاحت کرتے ہیں جو ایک بہاؤ کے نیٹ ورک میں ایک کنارے کی نمائندگی کرتا ہے ، جس میں پراپرٹی سے ایک جائیداد ہے جو ماخذ نوڈ کے اشاریہ کو محفوظ کرتی ہے ، A پراپرٹی جو منزل کے نوڈ کے اشاریہ کو اسٹور کرتی ہے ، اور ایک صلاحیت کی پراپرٹی ہے کہکنارے کی گنجائش کو اسٹور کرتا ہے۔ہم ایک فلوٹیٹ ورک کلاس کی بھی وضاحت کرتے ہیں جو ایک فلو نیٹ ورک کی نمائندگی کرتا ہے ، جس میں نیٹ ورک میں کناروں کو شامل کرنے اور فورڈ فلرسن الگورتھم کا استعمال کرتے ہوئے نیٹ ورک میں زیادہ سے زیادہ بہاؤ کی کمپیوٹنگ کے طریقے ہیں۔فلوٹیٹ ورک کلاس نیٹ ورک میں کناروں کی نمائندگی کرنے کے لئے ملحقہ فہرست کا استعمال کرتی ہے ، اور ہر کنارے سے بہاؤ کو ذخیرہ کرنے کے لئے ایک بہاؤ کی صف کا استعمال کرتی ہے۔میکس فلو کا طریقہ فورڈ فلکرسن الگورتھم کا استعمال کرتے ہوئے سورس نوڈ اور ایک سنک نوڈ کے مابین نیٹ ورک میں زیادہ سے زیادہ بہاؤ کی گنتی کرتا ہے۔یہ طریقہ صفر کے بہاؤ کو شروع کرتا ہے ، اور بار بار وسیلہ نوڈ سے لے کر سنک نوڈ تک چوڑائی کے پہلے تلاش کا استعمال کرتے ہوئے ایک بڑھانے والا راستہ تلاش کرتا ہے ، اور راستے کے ساتھ بہاؤ کو اپ ڈیٹ کرتا ہے۔طریقہ ختم ہوجاتا ہے جب مزید بڑھانے والے راستے نہیں مل سکتے ہیں۔ یہاں فلوونٹ ورک کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ نیٹ ورک = نیا فلوونٹ ورک (6) ؛ نیٹ ورک.اڈیج (0 ، 1 ، 16) ؛ نیٹ ورک۔ ایڈجڈ (0 ، 2 ، 13) ؛ نیٹ ورک.اڈیج (1 ، 2 ، 10) ؛ نیٹ ورک.اڈیج (1 ، 3 ، 12) ؛ نیٹ ورک.اڈیج (2 ، 1 ، 4) ؛ نیٹ ورک.اڈیج (2 ، 4 ، 14) ؛ نیٹ ورک.اڈیجڈ (2 ، 4 ، 14)3 ، 2 ، 9) ؛ نیٹ ورک.اڈیڈج (3 ، 5 ، 20) ؛ نیٹ ورک.اڈیج (4 ، 3 ، 7) ؛ نیٹ ورک.اڈیج (4 ، 5 ، 4) ؛ کنسول.لوگ (نیٹ ورک.میکس فلو (0 ،5)) ؛// 23 میں اس مثال میں ، ہم 6 نوڈس اور 10 کناروں کے ساتھ ایک نیا فلوٹیٹ ورک مثال تیار کرتے ہیں ، اور ایڈجڈ کے طریقہ کار کا استعمال کرتے ہوئے نیٹ ورک میں کناروں کو شامل کرتے ہیں۔اس کے بعد ہم میکس فلو کے طریقہ کار کا استعمال کرتے ہوئے 0 نوڈ اور 5 نوڈ کے درمیان نیٹ ورک میں زیادہ سے زیادہ بہاؤ کی گنتی کرتے ہیں ، اور نتائج کو کنسول پر لاگ ان کریں۔زیادہ سے زیادہ فلو 1 گیتھب"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں مستقل ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں مستقل ڈیٹا ڈھانچے کو عملی جامہ پہنانے کے ل we ، ہم موجودہ لائبریری کا استعمال کرسکتے ہیں یا اپنا عمل درآمد کرسکتے ہیں۔یہاں کچھ اختیارات ہیں: ایک موجودہ لائبریری کا استعمال: Github1 پر مستقل ڈیٹا ڈھانچے کے لئے ایک موجودہ ٹائپ اسکرپٹ لائبریری موجود ہے۔یہ لائبریری مستقل اعداد و شمار کے ڈھانچے کا ایک مجموعہ فراہم کرتی ہے ، جس میں فہرستیں ، نقشے اور سیٹ شامل ہیں ، جو ایک دوسرے کے مابین مکمل طور پر ناقابل تسخیر اور موثر انداز میں عناصر کا اشتراک کرتے ہیں۔مثال کے طور پر ، مستقل فہرست میں اضافے سے صرف ایک نیا نوڈ پیدا ہوتا ہے جو پرانی فہرست کا حوالہ دیتا ہے۔اس لائبریری کو استعمال کرنے کے ل we ، ہم اسے NPM جیسے پیکیج مینیجر کا استعمال کرتے ہوئے انسٹال کرسکتے ہیں اور اسے اپنے ٹائپ اسکرپٹ کوڈ میں درآمد کرسکتے ہیں۔ اپنے اپنے کو نافذ کرتے ہوئے: ہم ٹائپ اسکرپٹ میں اپنے مستقل ڈیٹا ڈھانچے کو بھی نافذ کرسکتے ہیں۔ایک مستقل ڈیٹا ڈھانچہ ایک ڈیٹا ڈھانچہ ہے جو ہمیشہ ترمیم کرنے پر اپنے سابقہ ورژن کو ہمیشہ محفوظ رکھتا ہے ، تاکہ پچھلے ورژن کو اب بھی رسائی اور استعمال کیا جاسکے۔مستقل ڈیٹا ڈھانچے کو عملی جامہ پہنانے کا ایک طریقہ یہ ہے کہ کاپی آن تحریری الفاظ کا استعمال کیا جائے ، جہاں ڈیٹا ڈھانچے میں کوئی بھی تازہ کاری ڈیٹا ڈھانچے کی ایک نئی کاپی تیار کرتی ہے جو پچھلے ورژن کے ساتھ زیادہ سے زیادہ ڈیٹا شیئر کرتی ہے۔مثال کے طور پر ، اگر ہمارے پاس مستقل فہرست ہے اور ہم اس میں کسی عنصر کو شامل کرنا چاہتے ہیں تو ، ہم ایک نئی فہرست تشکیل دے سکتے ہیں جو پرانی فہرست اور نئے عنصر کا حوالہ دیتا ہے۔یہاں ٹائپ اسکرپٹ میں مستقل فہرست کا ایک مثال عمل ہے ، 2 سے موافقت پذیر: ٹائپ اسکرپٹ کلاس پرسنٹ لسٹ <ٹی> {تعمیر کنندہ (نجی ہیڈ: ٹی | نول ، نجی دم: پرسنٹ لسٹ <ٹی> | نول) {} پریپینڈ (ویلیو: ٹی): مستقل لسٹ <t> {نئی مستقل لسٹ (قیمت ، یہ) واپس کریں ؛} get (انڈیکس: نمبر): t |null {if (index === 0) {اس کو واپس کریں۔ ہیڈ ؛} دوسری صورت میں اگر (this.tail === null) {واپسی NULL ؛} دوسری {اس کو واپس کریں۔}} سیٹ (اشاریہ: نمبر ، قیمت: ٹی): پرسنٹ لسٹ <ٹی> {اگر (انڈیکس === 0) {نئی پرسینسٹ لسٹ (ویلیو ، یہ.ٹیل) واپس لوٹائیں۔} ورنہ اگر (this.tail === null) {اسے واپس کریں ؛} دوسری {نئی پرسنٹ لسٹ لوٹائیں (this.head ، this.tail.set (انڈیکس - 1 ، قدر)) ؛}}} اس مثال کے طور پر ، ہم ایک مستقل لسٹ کلاس کی وضاحت کرتے ہیں جو مستقل فہرست کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے ، جس میں ایک ہیڈ پراپرٹی ہے جو پہلے عنصر کی قیمت کو محفوظ کرتی ہے ، اور ایک دم کی پراپرٹی جو باقی فہرست کے حوالے سے ذخیرہ کرتی ہے۔پریپینڈ کا طریقہ ایک نئی فہرست تیار کرتا ہے جو موجودہ فہرست میں ایک نیا عنصر تیار کرتا ہے۔GET طریقہ فہرست میں دیئے گئے انڈیکس میں قیمت لوٹاتا ہے ، یا اگر انڈیکس حد سے باہر ہے تو NULL۔سیٹ کا طریقہ کار ایک نئی فہرست تیار کرتا ہے جو فہرست میں دیئے گئے انڈیکس میں قدر کو ایک نئی قیمت پر طے کرتا ہے۔ یہاں پرسنٹ لسٹ کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ لسٹ 1 = نئی پرسنٹ لسٹ (1 ، نیا پرسنٹ لسٹ (2 ، نیا مستقل لسٹ (3 ، 3 ، 3 ،null)))) ؛ کانسٹ لسٹ 2 = لسٹ 1. پریپریٹ (0) ؛ کنسول.لوگ (لسٹ 1.get (2)) ؛// 3console.log (list2.get (2)) ؛// 3Const list3 = list2.set (1 ، -1) ؛ کنسول.لاگ (فہرست 2.get (1)) ؛// 2console.log (list3.get (1)) ؛// -1 اس مثال میں ، ہم 3 عناصر کے ساتھ ایک نیا مستقل لسٹ مثال تیار کرتے ہیں ، اور پریپینڈ کے طریقہ کار کا استعمال کرتے ہوئے فہرست میں ایک نیا عنصر تیار کرتے ہیں۔اس کے بعد ہم گیٹ کے طریقہ کار کا استعمال کرتے ہوئے اصل فہرست میں دیئے گئے انڈیکس اور نئی فہرست میں قدر حاصل کرتے ہیں ، اور نتائج کو کنسول پر لاگ ان کریں۔ہم سیٹ کے طریقہ کار کا استعمال کرتے ہوئے نئی فہرست میں دیئے گئے انڈیکس پر بھی قیمت مرتب کرتے ہیں ، اور نتائج کو کنسول پر لاگ ان کریں۔NPM-Package/مستقل-TS2HTTPS: //dev.to/japiirainen/immutable-data-structures in-typescript-530i1github2dev3snyk"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دو ڈوروں کے مابین مختصر ترین مشترکہ بالادستی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دو ڈوروں کے مابین مختصر ترین مشترکہ بالادستی تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔سب سے کم عام سپرسیئنس سب سے کم تار ہے جس میں دونوں ڈوروں پر مشتمل ہوتا ہے۔ہم متحرک پروگرامنگ کا استعمال کرتے ہوئے مختصر ترین مشترکہ بالادستی کی لمبائی تلاش کرسکتے ہیں ، اور پھر بیک ٹریکنگ کا استعمال کرتے ہوئے سپرسیئینس کی تعمیر کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کا ایک مثال عمل ہے ، جس میں 1 سے موافقت پذیر ہے: ٹائپ اسکرپٹ فنکشن شارسٹ کامنس اپرسیونسی (str1: string ، str2: سٹرنگ): سٹرنگ {const m = str1.length ؛const n = str2.length ؛کانسٹ ڈی پی: نمبر [] [] = نیا سرنی (ایم + 1)کے لئے (آئیے i = 1 ؛ i <= m ؛ i ++) {for (j = 1 ؛ j <= n ؛ j ++) {اگر (str1 [i - 1] === str2 [j - 1]) {dp[i] [j] = dp [i - 1] [j - 1] + 1 ؛} else {dp [i] [j] = math.max (dp [i - 1] [j] ، dp [i] [j - 1]) ؛}}} آئیے i = m ؛j = n ؛کانسک سپریشن: سٹرنگ [] = [] ؛جبکہ (i> 0 && j> 0) {اگر (str1 [i - 1] === str2 [j - 1]) {supersequence.unshift (str1 [i - 1]) ؛میں--؛J-- ؛} ورنہ اگر (dp [i - 1] [j]> dp [i] [j - 1]) {supersequence.unshift (str1 [i - 1]) ؛میں--؛} else {supersequence.unshift (str2 [j - 1]) ؛J-- ؛}} جبکہ (i> 0) {supersequence.unshift (str1 [i - 1]) ؛میں--؛} جبکہ (j> 0) {supersequence.unshift (str2 [j - 1]) ؛J-- ؛sup سپرسی ایکوینسی۔ join ('') ؛} اس مثال کے طور پر ، ہم ایک مختصر ترین کامنس اپریسیونیو فنکشن کی وضاحت کرتے ہیں جو دو ڈور str1 اور str2 کو دلائل کے طور پر لیتا ہے ، اور دونوں ڈوروں کی مختصر ترین عمومی استحکام کو واپس کرتا ہے۔فنکشن کم ترین مشترکہ سپرسیئینس کی لمبائی تلاش کرنے کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے ، اور سپرسیئینس کی تعمیر کے لئے بیک ٹریکنگ کا استعمال کرتا ہے۔ڈی پی سرنی str1 اور str2 کے سابقہ کے سب سے طویل مشترکہ حصے کی لمبائی کو اسٹور کرتی ہے۔فنکشن ڈی پی سرنی کو صفر پر شروع کرتا ہے ، اور ایس ٹی آر 1 اور ایس ٹی آر 2 کے کرداروں پر تکرار کرتا ہے ، اور اس کی بنیاد پر ڈی پی سرنی کو اپ ڈیٹ کرتا ہے چاہے حروف سے مماثل ہوں یا نہیں۔اس کے بعد یہ فنکشن ڈی پی سرنی کے نچلے دائیں کونے سے بیک ٹریکنگ کرکے سپرسیئینس کی تشکیل کرتا ہے ، اور اس کی بنیاد پر حروف کو شامل کرتے ہیں اس کی بنیاد پر کہ آیا وہ سب سے طویل عام مشترکہ حصول کا حصہ ہیں یا نہیں۔.// geekeconsole.log (شارسٹ کامنس اپریسیئنسی ('aggtab' ، 'gxtxayb')) ؛// Aggxtxaybin اس مثال کے طور پر ، ہمیں شارسٹ کامنس اپریسیئنسی فنکشن کا استعمال کرتے ہوئے دو جوڑے کے ڈوروں کی مختصر ترین مشترکہ حدود ملتی ہے ، اور نتائج کو کنسول پر لاگ ان کریں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں لاحقہ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ فینکشن سب سے طویل ترین پلائنڈرمکسوبسنس (ایس: سٹرنگ): سٹرنگ {کانسٹ این = ایس لمبائی ؛کانسٹ ڈی پی: نمبر [] [] = نیا سرنی (این)کے لئے (آئیے i = n-1 ؛ i> = 0 ؛ i--) {dp [i] [i] = 1 ؛کے لئے (j = i + 1 ؛ j <n ؛ j ++) {اگر (s [i] === s [j]) {dp [i] [j] = dp [i + 1] [j - 1]+ 2 ؛} else {dp [i] [j] = math.max (dp [i + 1] [j] ، dp [i] [j - 1]) ؛}}} دو = 0 ؛آئیے j = n - 1 ؛CONST کے متضاد: سٹرنگ [] = [] ؛جبکہ (i <j) {if (s [i] === s [j]) {متناسب.پش (s [i]) ؛i ++ ؛J-- ؛} ورنہ اگر (dp [i+1] [j]> dp [i] [j - 1]) {i ++ ؛} else {j-- ؛}} if (i === j) {concence.push (s [i]) ؛} returne.join ('') ؛} ٹائپ اسکرپٹ کنسول.لوگ (سب سے طویل ترین پلائنڈرمکسوبسینس ('بی بی بی')) ؛//"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں درجہ بندی اور راستے کے کمپریشن کے ذریعہ یونین کے ساتھ ایک ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں درجہ بندی اور راستے کے کمپریشن کے ذریعہ یونین کے ساتھ ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک سیٹ کلاس کی وضاحت کریں جو ڈیٹا پراپرٹی کے ساتھ ڈس ڈیسینٹ سیٹ ڈیٹا ڈھانچے میں ایک سیٹ کی نمائندگی کرتا ہے جو ڈیٹا سے وابستہ ڈیٹا کو اسٹور کرتا ہے۔سیٹ کے ساتھ ، ایک رینک پراپرٹی جو سیٹ کے عہدے کو محفوظ کرتی ہے ، اور والدین کی پراپرٹی جو والدین کے سیٹ کے حوالے سے ذخیرہ کرتی ہے۔ ایک ناگوار طبقے کی نمائندگی کرتا ہے جو ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، جس میں سیٹ کی پراپرٹی ہے جو ایک صف کو محفوظ کرتی ہے۔مثال کے طور پر سیٹ کریں۔ ایک میک سیٹ طریقہ کار جو دیئے گئے اعداد و شمار کے ساتھ ایک نیا سیٹ تیار کرتا ہے ، اور اسے سیٹوں میں شامل کرتا ہے۔وہ طریقہ جو رینک کے ذریعہ دو سیٹوں کو ضم کرتا ہے ، چھوٹے درخت کو بڑے درخت کی جڑ سے جوڑتا ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے نفاذ ، 1 سے موافقت پذیر: ٹائپ اسکرپٹ کلاس سیٹ <t> {تعمیر کنندہ (عوامی اعداد و شمار: عوامی درجہ: نمبر: نمبر: نمبر: نمبر: نمبر: نمبر: نمبر: نمبر= 0 ، عوامی والدین: سیٹ <t> |null = null) {}} کلاس discointset <t> {سیٹ: سیٹ <t> [] = [] ؛میک سیٹ (ڈیٹا: ٹی): سیٹ <t> {کانسٹ سیٹ = نیا سیٹ (ڈیٹا) ؛set.palent = سیٹ ؛this.sets.push (سیٹ) ؛واپسی سیٹ ؛} تلاش کریں (سیٹ: سیٹ <ٹی>): سیٹ <ٹی> {اگر (سیٹ.فینٹ! == سیٹ) {سیٹ.فینٹ = this.find (سیٹ.فینٹ) ؛} واپسی سیٹ۔ پیرینٹ ؛} یونین (سیٹ 1: سیٹ <ٹی> ، سیٹ 2: سیٹ <ٹی>): سیٹ <ٹی> {کونٹ روٹ 1 = this.find (سیٹ 1) ؛کونٹ روٹ 2 = this.find (سیٹ 2) ؛اگر (جڑ 1 === روٹ 2) {روٹ 1 ؛} if (root1.rank <root2.rank) {روٹ 1. پیرنٹ = روٹ 2 ؛روٹ 2 ؛} دوسری صورت میں اگر (روٹ 1.rank> روٹ 2. رینک) {روٹ 2. پیرنٹ = روٹ 1 ؛روٹ 1 ؛} else {root2.Pearnt = روٹ 1 ؛روٹ 1. رینک ++ ؛روٹ 1 ؛}}} اس مثال میں ، ہم ایک سیٹ کلاس کی وضاحت کرتے ہیں جو ڈس ڈیسپینٹ سیٹ ڈیٹا ڈھانچے میں ایک سیٹ کی نمائندگی کرتا ہے ، جس میں ڈیٹا پراپرٹی ہے جو سیٹ سے وابستہ ڈیٹا کو محفوظ کرتی ہے ، ایک رینک پراپرٹی جو سیٹ کے درجہ بندی کو محفوظ کرتی ہے ، اور ایکوالدین کی پراپرٹی جو والدین کے سیٹ کا حوالہ دیتی ہے۔ہم ایک ناگوار طبقے کی بھی وضاحت کرتے ہیں جو ایک سیٹ پراپرٹی کے ساتھ ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے جو سیٹ مثالوں کی ایک صف کو محفوظ کرتا ہے۔میک سیٹ کا طریقہ دیئے گئے ڈیٹا کے ساتھ ایک نیا سیٹ تیار کرتا ہے ، اور اسے سیٹ سرنی میں شامل کرتا ہے۔تلاش کا طریقہ درخت کو چپٹا کرنے کے لئے راستے کے کمپریشن کا استعمال کرتے ہوئے ، دیئے گئے سیٹ کا والدین کا سیٹ تلاش کرتا ہے۔یونین کا طریقہ کار کے ذریعہ دو سیٹوں کو ضم کرتا ہے ، چھوٹے درخت کو بڑے درخت کی جڑ سے جوڑتا ہے۔ یہاں ڈس ڈیسپیٹ سیٹ کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ DS = نیا ڈسوائٹ سیٹ <نمبر> () ؛ کانسٹ سیٹ 1 = ڈی ایس میکسیٹ (1)؛ Const سیٹ 2 = ds.makeset (2) ؛ Const سیٹ 3 = ds.makeset (3) ؛ ds.union (سیٹ 1 ، سیٹ 2) ؛ ds.union (سیٹ 2 ، سیٹ 3) ؛ کنسول.لوگ (ds.find (سیٹ 1)۔ڈیٹا) ؛// 1console.log (ds.find (سیٹ 2). ڈیٹا) ؛// 1console.log (ds.find (set3). ڈیٹا) ؛// 1 میں اس مثال کے طور پر ، ہم ایک نیا ڈس ڈیسپیٹ سیٹ مثال تیار کرتے ہیں ، اور میک سیٹ طریقہ کار کا استعمال کرتے ہوئے ڈیٹا 1 ، 2 ، اور 3 کے ساتھ تین سیٹ بناتے ہیں۔اس کے بعد ہم یونین کے طریقہ کار کا استعمال کرتے ہوئے سیٹوں کو ضم کرتے ہیں ، اور تلاش کے طریقہ کار کا استعمال کرتے ہوئے ہر سیٹ کا بنیادی سیٹ تلاش کرتے ہیں ، نتائج کو کنسول پر لاگ ان کرتے ہیں۔www.algotree.org/algorithms/disjoint_set/1https://www.geeksforgeeks.org/union-by-rank-and-compression-nion-alge-lgorithm/1geeksforgeyks2youtube3algotree"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے 2D جگہ میں پوائنٹس کے ایک سیٹ میں پوائنٹس کی قریب ترین جوڑی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ انٹرفیس پوائنٹ {x: نمبر ؛Y: نمبر ؛} فنکشن کلوز اسٹیر (پوائنٹس: پوائنٹ []): نمبر {کونٹڈ پوائنٹس = پوائنٹس.سیلیس (). ترتیب ((a ، b) => a.x - b.x) ؛Const {فاصلہ} = قریب ترین پیری ہیلپر (ترتیب شدہ پوائنٹس) ؛واپسی کا فاصلہ ؛} فنکشن قریب ترین پیری ہیلپر (پوائنٹس: پوائنٹ []): {فاصلہ: نمبر ؛جوڑی: [نقطہ ، نقطہ]} {if (points.length <= 3) {واپس برٹفورکیسلوسسٹ پیری (پوائنٹس) ؛} const MID = math.floor (points.length / 2) ؛کانسٹ بائیں = پوائنٹس۔ سلیئس (0 ، وسط) ؛کونٹ رائٹ = پوائنٹس۔ سلیئس (وسط) ؛کانسٹ {فاصلہ: بائیں بازو ، جوڑی: بائیں بازو} = قریب ترین پائر ہیلپر (بائیں) ؛کانسٹ {فاصلہ: حق ، جوڑی: رائٹ پیئر} = قریب ترین پیری ہیلپر (دائیں) ؛منڈسٹینس = math.min (بائیں بازو ، دائیں طرف) ؛کانسٹ اسٹرپ = پوائنٹس ۔فلٹر ((p) => ریاضی۔ اے بی ایس (p.x - پوائنٹس [درمیانی] .x) <ذہن سازی) ؛کانسٹ {فاصلہ: اسٹرپ ڈسٹینس ، جوڑی: اسٹرپیر} = قریب ترین پیریپ (پٹی ، ذہن سازی) ؛اگر (سٹرپ ڈسٹنس <ذہن سازی) {واپسی {فاصلہ: پٹی ڈسٹنس ، جوڑی: اسٹرپیر} ؛} ورنہ اگر (بائیں بازو <حق) {واپسی {فاصلہ: بائیں بازو ، جوڑی: بائیں بازو} ؛} else {واپسی {فاصلہ: حق ، جوڑی: رائٹ پیئر} ؛}} فنکشن بروٹفورسکلوسسٹ پیری (پوائنٹس: پوائنٹ []): {فاصلہ: نمبر ؛جوڑی: [نقطہ ، نقطہ]} {midestance = لامحدودیت ؛آئیے منپیر: [نقطہ ، نقطہ] = [پوائنٹس [0] ، پوائنٹس [1]] ؛کے لئے (i = 0 ؛ i <points.length - 1 ؛ i ++) {for (j = i+1 ؛ j <points.length ؛ j ++) {const d = فاصلہ (پوائنٹس [i] ، پوائنٹس [j]) ؛if (d <midistance) {midestance = d ؛منپیر = [پوائنٹس [i] ، پوائنٹس [j]] ؛}}} ریٹرن {فاصلہ: ذہن سازی ، جوڑی: منپیر} ؛} فنکشن قریب ترین پیریپ (پٹی: نقطہ [] ، ذہن سازی: نمبر): {فاصلہ: نمبر ؛جوڑی: [نقطہ ، نقطہ]} {mindistancesquared = midestance ** 2 ؛آئیے منپیر: [نقطہ ، نقطہ] = [پٹی [0] ، پٹی [1]] ؛آئیے i = 0 ؛آئیے j = 1 ؛جبکہ (i <strip.length - 1) {جبکہ (j <strip.length && & (پٹی [j] .y - پٹی [i] .y) ** 2 <ministancesquared) {const d = فاصلہ (پٹی [i]، پٹی [j]) ؛اگر (d <mindistancesquared) {mindistancesquared = d ؛منپیر = [پٹی [i] ، پٹی [j]] ؛} J ++ ؛} i ++ ؛} واپسی {فاصلہ: math.sqrt (mindistancesquared) ، جوڑی: منپیر} ؛} فنکشن کا فاصلہ (p1: نقطہ ، p2: نقطہ): نمبر {واپسی (p1.x - p2.x) ** 2 + (p1.y- p2.y) ** 2 ؛} ٹائپ اسکرپٹ کنسٹ پوائنٹس: پوائنٹ [] = [{x: 0 ، Y: 0} ، {x: 1 ، y: 2} ، {x: 3 ، Y: 1} ، {x: 4 ، y: 4} ، {x: 5 ، y: 3} ، {x: 6 ، y: 1} ، {x: 7 ، y: 2} ،"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بی ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ کلاس بٹرینوڈ {چابیاں: نمبر [] ؛بچے: btreenode [] ؛پتی: بولین ؛کنسٹرکٹر (چابیاں: نمبر [] ، بچے: Btreenode [] ، پتی: بولین) {this.keys = keys ؛this.children = بچے ؛this.leaf = leaf ؛class} کلاس btree {جڑ: btreenode |خالی؛ڈگری: نمبر ؛کنسٹرکٹر (ڈگری: نمبر) {this.root = null ؛this.degree = ڈگری ؛} تلاش (کلید: نمبر): btreenode |null {let node = this.root ؛جبکہ (نوڈ! == null) {دو = 0 ؛جبکہ (i <node.keys.length && & key> node.keys [i]) {i ++ ؛} if (i <node.keys.length && & & key === نوڈ.کیس [i]) {واپس نوڈ ؛} نوڈ = نوڈ.چیلین [i] ؛} واپس کالعدم ؛} داخل کریں (کلید: نمبر): باطل {اگر (this.root === null) {this.root = نیا Btreenode ([key] ، [] ، سچ) ؛واپسی ؛} دو نوڈ = this.root ؛if (node.keys.length === 2 * this.degree - 1) {const newrot = new btreenode ([] ، [نوڈ] ، غلط) ؛this.root = newrot ؛this.splichild (newrot ، 0 ، نوڈ) ؛this.insertnonfull (newrot ، key) ؛} else {this.insertnonfull (نوڈ ، کلید) ؛}} حذف کریں (کلید: نمبر): باطل {اگر (this.root === null) {واپسی ؛} this.deletekey (this.root ، key) ؛اگر (this.root.keys.length === 0) {this.root = this.root.children [0] ؛}} نجی Insertnonfull (نوڈ: Btreenode ، key: نمبر): باطل {آئیے i = node.keys.length - 1 ؛if (node.leaf) {جبکہ (i> = 0 && & & key <node.keys [i]) {node.keys [i + 1] = node.keys [i] ؛میں--؛} node.keys [i + 1] = کلید ؛} دوسری {جبکہ (i> = 0 && & & key <node.keys [i]) {i-- ؛} i ++ ؛if (node.children [i] .keys.length === 2 * this.degree - 1) {this.splichild (نوڈ ، I ، نوڈ.کرنین [i]) ؛if (key> node.keys [i]) {i ++ ؛}} this.insertnonfull (node.children [i] ، کلید) ؛}} پرائیویٹ سپلچیلڈ (والدین: بٹرینوڈ ، I: نمبر ، بچہ: Btreenode): باطل {Const newchid = new Btreenode (child.keys.slice (this.degree) ، child.children.slice (this.degree) ، بچہ۔پتی) ؛child.keys.length = this.degree - 1 ؛child.children.length = this.degree ؛والدین.کرینین.سپلیس (i + 1 ، 0 ، نیو چائلڈ) ؛parent.keys.splice (i ، 0 ، child.keys.pop ()!) ؛} نجی ڈیلیٹکی (نوڈ: Btreenode ، کلید: نمبر): باطل {آئیے i = 0 ؛جبکہ (i <node.keys.length && & key> node.keys [i]) {i ++ ؛} if (i <node.keys.length && & & key === node.keys [i]) {if (node.leaf) {node.keys.splice (i ، 1) ؛} else {const pred = this.getPredelle (node.children [i]) ؛node.keys [i] = pres.keys.pop () !؛this.deletekey (node.children [i] ، pred.keys [pres.keys.length - 1]) ؛}} else {if (node.leaf) {واپسی ؛} const child = node.children [i] ؛if (child.keys.length === this.degree - 1) {if (i> 0 && node.children [i - 1] .keys.length> = this.degree) {this.bromprev (نوڈ ، i)؛} ورنہ اگر (i <node.keys.length && node.children [i + 1] .keys.length> = this.degree) {this.bowrowfromnext (نوڈ ، i) ؛} ورنہ اگر (i> 0) {this.merge (نوڈ ، i - 1) ؛چائلڈ = نوڈ.کرن [i - 1] ؛} else {this.merge (نوڈ ، i) ؛چائلڈ = نوڈ۔ بچوں [i] ؛.} this.deletekey (بچہ ، کلید) ؛}} نجی getPredresser (نوڈ: Btreenode): Btreenode {if (node.leaf) {واپسی نوڈ ؛this اس کو واپس کریں۔} نجی قرضے سے متعلق (نوڈ: Btreenode ، I: نمبر): باطل {const child = node.children [i] ؛کونٹ بہن بھائی = نوڈ۔ بچوں [i - 1] ؛child.keys.unshift (node.keys [i - 1]) ؛if (! child.leaf) {child.children.unshift (sibling.children.pop ()!) ؛} node.keys [i - 1] = sibling.keys.pop () !؛} نجی قرضے سے دوچار (نوڈ: بٹرینوڈ ، I: نمبر): باطل {const child = node.children [i] ؛کونسٹ بہن بھائی = نوڈ.چیلین [i + 1] ؛child.keys.push (node.keys [i]) ؛if (! child.leaf) {child.children.push (sibling.children.shift ()!) ؛} node.keys [i] = sibling.keys.shift () !؛} نجی انضمام (نوڈ: Btreenode ، I: نمبر): باطل {const child = node.children [i] ؛کونسٹ بہن بھائی = نوڈ.چیلین [i + 1] ؛child.keys.push (node.keys [i]) ؛child.keys = child.keys.concat (sibling.keys) ؛if (! child.leaf) {child.children = child.children.concat (sibling.children) ؛} نوڈ.کرنین.سپلیس (i + 1 ، 1) ؛node.keys.splice (i ، 1) ؛}}"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر کرسکل کے کم سے کم پھیلے ہوئے درخت الگورتھم کو انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ٹریپ ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تار کی صفوں میں سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تاروں کی ایک صف کے درمیان سب سے طویل مشترکہ سابقہ تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک متغیر کے سابقہ کو خالی تار میں شروع کریں۔ سرے میں پہلے تار کے کرداروں کا جائزہ لیں۔ ہر کردار کے لئے ، باقی پر تکرار کریں۔صف میں ڈوروں میں سے ، ہر تار میں ایک ہی پوزیشن پر کردار کا موازنہ کرتے ہوئے۔ اگر تمام حروف سے ملتے ہیں تو ، کردار کو سابقہ متغیر میں شامل کریں۔اگر نہیں تو ، پریفکس متغیر کو واپس کریں۔ اگر تکرار واپس کیے بغیر مکمل ہوجائے تو ، پریفکس متغیر کو واپس کریں۔ یہاں کچھ ایسے وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: کوڈی بونی ویب سائٹ لیٹ کوڈ کو ٹائپ اسکرپٹ کا حل فراہم کرتی ہے \"\"سوال۔حل مذکورہ بالا نقطہ نظر کا استعمال کرتا ہے ، جو صف میں پہلے تار کے کرداروں پر تکرار کرتا ہے اور باقی ڈوروں میں کرداروں سے ان کا موازنہ کرتا ہے۔ لیٹ کوڈ ویب سائٹ \"سب سے طویل عام ماقبل\" مسئلے کا آسان ٹائپ اسکرپٹ حل فراہم کرتی ہے۔اس حل میں مذکورہ بالا نقطہ نظر کا استعمال کیا گیا ہے ، جو صف میں پہلے تار کے کرداروں پر تکرار کرتے ہیں اور باقی ڈوروں میں ان کے کرداروں سے ان کا موازنہ کرتے ہیں۔ ڈنکن میک آرڈل ویب سائٹ لیٹ کوڈ \"سب سے طویل مشترکہ سابقہ\" مسئلہ کا جاوا اسکرپٹ حل فراہم کرتی ہے۔حل مذکورہ بالا نقطہ نظر کا استعمال کرتا ہے ، جو صف میں پہلے تار کے کرداروں پر تکرار کرتا ہے اور ان کے باقی ڈوروں میں کرداروں سے موازنہ کرتا ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ فنکشن طویل ترین کامومن پریفکس (ایس ٹی آر ایس: سٹرنگ []): سٹرنگ {اگر (str.length === 0) {واپسی \"\" ؛} لیٹ پریفکس = \"\" ؛کے لئے (آئیے i = 0 ؛ i <strs [0] .length ؛ i ++) {const char = strs [0] [i] ؛کے لئے (j = 1 ؛ j <strs.length ؛ j ++) {اگر (i> = strs [j] .length || strs [j] [i]! == چار) {واپسی کا سابقہ ؛}} پریفکس += چار ؛} واپسی کا سابقہ ؛} اس مثال کے طور پر ، ہم ایک طویل عرصے سے کام کرنے والے فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر تاروں کی ایک صف لیتا ہے اور تار کے درمیان سب سے طویل عام سابقہ واپس کرتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا سرنی خالی ہے ، اور اگر یہ ہے تو خالی تار واپس کرتا ہے۔اس کے بعد فنکشن ایک خالی تار کے لئے ایک سابقہ متغیر کی ابتدا کرتا ہے ، اور صف میں پہلے تار کے کرداروں پر تکرار کرتا ہے۔ہر کردار کے ل the ، فنکشن صف میں باقی ڈوروں پر تکرار کرتا ہے ، ہر تار میں ایک ہی پوزیشن پر کردار کا موازنہ کرتا ہے۔اگر تمام حروف مماثل ہیں تو ، فنکشن کردار کو سابقہ متغیر میں شامل کرتا ہے۔اگر نہیں تو ، فنکشن سابقہ متغیر کو لوٹاتا ہے۔اگر تکرار واپس کیے بغیر مکمل ہوجاتی ہے تو ، فنکشن سابقہ متغیر کو واپس کرتا ہے۔ یہاں طویل عرصے سے کام کرنے والی پریفکس فنکشن کا ایک مثال استعمال ہوتا ہے: ٹائپ اسکرپٹکونسٹ ایس ٹی آر ایس = [\"پھول\" ، \"فلو\" ، \"فلائٹ\"] ؛ کونٹ پریفکس = طویل عرصے سے کامن پری فکس (ایس ٹی آر) ؛ کنسول۔لاگ (سابقہ) ؛// \"FL\" اس مثال کے طور پر ، ہم تار کی ایک صف تیار کرتے ہیں اور طویل عرصے سے کام کا استعمال کرتے ہوئے تاروں میں سب سے طویل عام سابقہ تلاش کرتے ہیں ، جس کا نتیجہ کنسول میں لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "رسی ڈیٹا کا ڈھانچہ بہت بڑے تغیر پزیر تاروں کو ذخیرہ کرنے اور جوڑنے کے ل data ایک موثر ڈیٹا ڈھانچہ ہے۔اس سے میموری کی بحالی اور ڈیٹا کاپی کم ہوتی ہے۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کو کس طرح نافذ کرنے کی مثالیں فراہم کرتے ہیں: گٹ ہب پر جزو/رسی کا ذخیرہ ٹائپ اسکرپٹ میں رسی ڈیٹا ڈھانچے کا نفاذ فراہم کرتا ہے۔اس عمل میں ایک رسی کلاس شامل ہے جو رسی کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے ، جس میں ڈور کو داخل کرنے ، حذف کرنے اور سلائس کرنے کے طریقوں کے ساتھ۔ لنک ڈوٹنیٹ/ٹی ایس اسٹرنگ اوپریشنز گٹ ہب پر ذخیرہ ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کا نفاذ فراہم کرتا ہے۔اس عمل میں ایک رسی کلاس شامل ہے جو رسی کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے ، جس میں ڈور کو داخل کرنے ، حذف کرنے اور سلائس کرنے کے طریقوں کے ساتھ۔ کیوینکلونگ ڈاٹ کام میڈیم پر مضمون رسی ڈیٹا ڈھانچے کی وضاحت فراہم کرتا ہے اور ٹائپ اسکرپٹ میں اس کو کیسے نافذ کیا جاسکتا ہے۔مضمون میں رسی کے اعداد و شمار کے ڈھانچے کا ٹائپ اسکرپٹ کا نفاذ شامل ہے ، جس میں داخل کرنے ، حذف کرنے ، اور سلائسنگ کے تاروں کے طریقوں کے ساتھ۔ این پی ایم پر رسی کی ترتیب کا پیکیج ٹائپ اسکرپٹ میں رسی کے اعداد و شمار کے ڈھانچے کا نفاذ فراہم کرتا ہے۔اس پر عمل درآمد میں ایک رس op ی کی کلاس شامل ہے جو رسی کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے ، جس میں داخل کرنے ، حذف کرنے ، اور سلائسنگ کے طریقوں کے ساتھ۔ ہر ایک مثال کے طور پر ٹائپ اسکرپٹ میں رسی کے اعداد و شمار کے ڈھانچے کا نفاذ ، جس میں گٹھب پر جزو/رسی کے ذخیرے سے ڈھال لیا جاتا ہے: ٹائپ اسکرپٹ کلاس رسی {بائیں: رسی |تار ؛دائیں: رسی |تار ؛لمبائی: نمبر ؛کنسٹرکٹر (بائیں: رسی | سٹرنگ ، دائیں: رسی | سٹرنگ) {this.left = بائیں ؛this.right = دائیں ؛this.length = (بائیں مثال کے طور پر رسی؟ بائیں۔ لمبائی: بائیں. لمبائی) + (دائیں مثال کے رسی؟ دائیں. لمبائی: دائیں۔ لمبائی) ؛} جامد تخلیق (str: سٹرنگ): رسی {نئی رسی (str.slice (0 ، str.length / 2) ، str.slice (str.length / 2)) ؛} چارٹ (انڈیکس: نمبر): سٹرنگ {اگر (انڈیکس <0 || انڈیکس> = اس لمبائی) {نئی غلطی پھینک دیں (\"رینج سے باہر انڈیکس\") ؛} if (this.left instance آف رسی) {اگر (index <this.left.length) {واپس کریں۔this اس کو واپس کریں۔this اس کو واپس کریں۔st اسٹرنگ (شروع: نمبر ، اختتام: نمبر): سٹرنگ {if (شروع <0 || end> this.length || start> اختتام) {نئی غلطی پھینک دیں (\"حد سے باہر انڈیکس\") ؛} if (start === 0 && end === this.length) {اس کو واپس کریں۔ ٹوسٹرنگ () ؛} if (this.left instance of رسی) {if (end <= this.left.length) {اس کو واپس کریں۔} if (start> = this.left.length) {اس کو واپس کریں۔this اس کو واپس کریں۔this اس کو واپس کریں۔} ٹاسٹرنگ (): سٹرنگ {اگر (this.left مثال کے طور پر رسی) {اس کو واپس کریں۔this اس کو واپس کریں۔} the اس مثال میں ، ہم ایک رسی کلاس کی وضاحت کرتے ہیں جو بائیں ، دائیں اور لمبائی کی خصوصیات کے ساتھ رسی کے ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔عمل درآمد میں ایک تخلیق کا طریقہ شامل ہے جو تار سے ایک نئی رسی پیدا کرتا ہے ، اور چیراٹ ، سٹرنگ ، اور ٹاسٹرنگ کے طریقوں سے جو رسی کے مندرجات تک رسائی کی اجازت دیتا ہے۔چارٹ کا طریقہ رسی میں دیئے گئے انڈیکس میں کردار کو لوٹاتا ہے ، سٹرنگ کا طریقہ رسی کی ایک سٹرنگ لوٹاتا ہے ، اور ٹاسٹرنگ کا طریقہ رسی کو تار کے طور پر لوٹاتا ہے۔ رسی کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ رسی = رسی۔(\"ہیلو ورلڈ\") ؛ کنسول.لوگ (rope.substring (0 ، 5)) ؛// \"ہیلو\" کنسول.لاگ (rope.substring (6 ، 11)) ؛// \"دنیا\" کنسول.لوگ (rope.charat (1)) ؛// \"E\" کنسول.لاگ (rope.tostring ()) ؛// \"ہیلو ورلڈ\" اس مثال میں ، ہم ایک تار سے ایک نئی رسی تیار کرتے ہیں اور اس کے مشمولات تک رسائی کے ل the ، کنسول پر نتائج کو لاگ ان کرتے ہوئے ، سٹرنگ ، چارٹ اور ٹاسٹرنگ کے طریقوں کا استعمال کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر بیل مین فورڈ مختصر ترین راستہ الگورتھم انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کلاس گراف {نوڈلسٹ: نمبر [] ؛ایج میپ: نقشہ <نمبر ، نقشہ <نمبر ، نمبر >> ؛کنسٹرکٹر (نوڈلسٹ: نمبر [] ، ایج میپ: نقشہ <نمبر ، نقشہ <نمبر ، نمبر >>) {this.nodelist = nodelist ؛this.edgemap = Edgemap ؛} بیل مین فورڈ (ماخذ: نمبر): [نمبر [] ، نمبر []] {کنٹ ڈسٹ = نیا سرنی (this.nodelist.length). فل (انفینٹی) ؛Const prep = نئی سرنی (this.nodelist.length) .fill (null) ؛ڈسٹ [ماخذ] = 0 ؛کے لئے (آئیے i = 0 ؛ i <this.nodelist.length - 1 ؛ i ++) {کے لئے (const [u ، کناروں]] کے لئے۔()) {اگر (ڈسٹ [یو] + وزن <ڈسٹ [وی]) {ڈسٹرکٹ [وی] = ڈسٹ [یو] + وزن ؛prev [v] = u ؛}}}} کے لئے (const [u ، کناروں] کے this.edgemap.entries ()) {کے لئے (کناز [v ، وزن]] کناروں کی۔]) {نئی غلطی پھینک دیں (\"منفی وزن کا سائیکل پتہ چلا\") ؛}}} واپسی [ڈسٹ ، پریو] ؛}} ٹائپ اسکرپٹ کنسٹ نوڈلسٹ = [0 ، 1 ، 2 ، 3] const کانسٹ ایج میپ = نیا نقشہ ([[0 ، نیا نقشہ ([[1 ، 4] ، [2 ، 3]]]] ، [1 ، نیا نقشہ (۔.// [0 ، 4 ، 2 ، 6] کنسول.لاگ (پچھلا) ؛// [null ، 0 ، 2 ، 1]"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں وقفہ کے درخت کے اعداد و شمار کے ڈھانچے کو نافذ کریں۔",
        "Answer": "وقفے کے درخت کے اعداد و شمار کے ڈھانچے کے متعدد ٹائپ اسکرپٹ پر عمل درآمد دستیاب ہیں ، جن میں شامل ہیں: این پی ایم پر نوڈ انٹروول ٹری پیکیج ایک وقفہ درخت کے اعداد و شمار کے ڈھانچے کو بڑھاوا دیا ہوا اے وی ایل درخت کے طور پر نافذ کرتا ہے جہاں ہر نوڈ ریکارڈوں اور ان کے تلاش کے وقفوں کی فہرست کو برقرار رکھتا ہے۔. این پی ایم پر @فلیٹن-جے ایس/وقفہ ٹری پیکیج کورمین ایٹ ال کے مطابق وقفہ بائنری سرچ ٹری کا نفاذ فراہم کرتا ہے۔ گیتھب پر ڈیوڈیساسیکل/وقفہ-ٹری ریپوزٹری ایک غیر منقولہ طور پر اجرت والے وقفے کے درخت کا نفاذ فراہم کرتا ہے جس میں ایک غیر ضروری ہے۔فنکشنل انٹرفیس۔ گٹ ہب پر وہم/غیر منقولہ-انٹروول ٹری ریپوزٹری جاوا اسکرپٹ/ٹائپ اسکرپٹ کے لئے ناقابل تسخیر وقفہ درخت کا نفاذ فراہم کرتا ہے۔ گیکسفورجیکس ویب سائٹ وقفہ درخت کے اعداد و شمار کے ڈھانچے کی وضاحت اور C ++ نفاذ کی وضاحت فراہم کرتی ہے۔ٹائپ اسکرپٹ میں وقفہ کے درخت کے اعداد و شمار کا ڈھانچہ ، NPM پر نوڈ انٹروول ٹری پیکیج سے موافقت پذیر: ٹائپ اسکرپٹ کلاس وقفہ {کم: نمبر ؛اعلی: نمبر ؛کنسٹرکٹر (کم: نمبر ، اعلی: نمبر) {this.low = کم ؛this.high = اعلی ؛}} کلاس نوڈ {وقفہ: وقفہ ؛زیادہ سے زیادہ: نمبر ؛بائیں: نوڈ |خالی؛دائیں: نوڈ |خالی؛ریکارڈ: کوئی بھی [] ؛کنسٹرکٹر (وقفہ: وقفہ) {this.interval = وقفہ ؛this.max = وقفہ۔ ہائی ؛this.left = null ؛this.right = null ؛this.records = [] ؛class} کلاس انٹرولٹری {جڑ: نوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (وقفہ: وقفہ ، ریکارڈ: کوئی بھی): باطل {کانسٹ نوڈ = نیا نوڈ (وقفہ) ؛node.records.push (ریکارڈ) ؛اگر (this.root === null) {this.root = نوڈ ؛واپسی ؛current موجودہ = this.root ؛جبکہ (سچ) {موجودہ۔ میکس = ریاضی۔ میکس (موجودہ.میکس ، وقفہ۔ ہائی) ؛اگر (وقفہ۔بریک ؛} موجودہ = کرنٹ. لیفٹ ؛} else {if (current.right === null) {موجودہ. رائٹ = نوڈ ؛بریک ؛} موجودہ = موجودہ۔ رائٹ ؛}}} تلاش (وقفہ: وقفہ): کوئی بھی [] {کانسٹنگ نتیجہ: کوئی بھی [] = [] ؛آئیے موجودہ = this.root ؛جبکہ (موجودہ! == null && وقفہ <= موجودہ۔ interval.high) {if (current.left! == null && موجودہ. left.max> = وقفہ.Low) {موجودہ = کرنٹ. لیفٹ ؛} دوسری صورت میں اگر (موجودہ۔ interval.high> = وقفہ۔ low && موجودہ۔ interval.low <= وقفہ۔ ہائی) {نتیجہ۔ پش (... موجودہ۔ ریکارڈز) ؛موجودہ = موجودہ۔ رائٹ ؛} دوسری {موجودہ = موجودہ۔ رائٹ ؛}} واپسی کا نتیجہ ؛}} اس مثال میں ، ہم ایک وقفہ طبقے کی وضاحت کرتے ہیں جو ایک وقفہ کی نمائندگی کرتا ہے ، جس میں کم اور اعلی خصوصیات ہیں۔ہم ایک نوڈ کلاس کی بھی وضاحت کرتے ہیں جو وقفہ ، زیادہ سے زیادہ ، بائیں ، دائیں ، اور ریکارڈ کی خصوصیات کے ساتھ وقفہ کے درخت میں نوڈ کی نمائندگی کرتا ہے۔عمل درآمد میں ایک وقفہ طبقہ شامل ہے جو وقفہ ، داخل کرنے اور تلاش کے طریقوں کے ساتھ وقفہ درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے۔داخل کرنے کا طریقہ وقفہ اور وقفہ کے درخت میں ایک وقفہ داخل کرتا ہے ، جبکہ تلاش کا طریقہ وقفوں کی تلاش کرتا ہے جو کسی وقفے سے اوورلپ ہوتا ہے اور ان کے ریکارڈ کو لوٹاتا ہے۔ یہاں انٹرل ٹری کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ ٹری = نیا وقفہ () ؛ درخت.INSERT (نیا وقفہ (0 ، 5) ، \"ریکارڈ 1\") ؛ ٹری.نسرٹ (نیا وقفہ (2 ، 7) ، \"ریکارڈ 2\") ؛ ٹری.نسرٹ (نیا وقفہ (4 ، 9) ، \"ریکارڈ 3\") ؛کانسٹنگ نتیجہ = درخت۔ سرچ (نیا وقفہ (3 ، 6)) ؛ کنسول.لاگ (نتیجہ) ؛// [\"ریکارڈ 1\" ، \"ریکارڈ 2\" ، \"ریکارڈ 3\"] اس مثال میں ، ہم ایک نیا انٹرل ٹری آبجیکٹ تیار کرتے ہیں اور درخت میں وابستہ ریکارڈوں کے ساتھ تین وقفے داخل کرتے ہیں۔اس کے بعد ہم ان وقفوں کی تلاش کرتے ہیں جو کسی وقفے کے ساتھ اوورلیپ ہوتے ہیں اور اپنے ریکارڈ کو کنسول پر لاگ ان کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں ایک متضاد سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں ایک متناسب سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم کڈانے کے الگورتھم کا استعمال کرسکتے ہیں۔یہاں اقدامات یہ ہیں: دو متغیرات میکسوفر اور میکسینینڈ ہائیر کو انٹیجرز کی صف میں 0. کا آغاز کریں۔ ہر عدد کے لئے ، موجودہ انٹیجر کی زیادہ سے زیادہ یا موجودہ عدد کا مجموعہ اور میکسینڈی ہائیر۔میکسوفر یا میکسینڈ ہیری میں سے زیادہ سے زیادہ۔ تکرار مکمل ہونے کے بعد ، میکسوفر کی واپسی کے بعد۔ یہاں کچھ ایسے وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: کوڈی بونی ویب سائٹ لیٹ کوڈ \"زیادہ سے زیادہ سبری\" سوال کا ٹائپ اسکرپٹ حل فراہم کرتی ہے۔اس حل میں کڈنے کے الگورتھم کا استعمال ایک متضاد سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے کیا گیا ہے۔ ایگ ہیڈ ڈاٹ ویب سائٹ کڈانے کے الگورتھم کا ایک ٹائپ اسکرپٹ پر عمل درآمد فراہم کرتی ہے تاکہ ایک متضاد سبری کا زیادہ سے زیادہ مجموعہ تلاش کیا جاسکے۔ گیکسفورجیکس کی ویب سائٹ کڈین کی ویب سائٹ کو ایک جاو اسکرپٹ کا نفاذ فراہم کرتا ہے جو ایک جاو اسکرپٹ کا نفاذ فراہم کرتا ہے۔کسی متضاد سبارے کی زیادہ سے زیادہ رقم تلاش کرنے کے ل type ، ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ فنکشن میکسبرے (نمبر: نمبر []): نمبر {آئیے میکسوفر = 0 ؛آئیے maxundhehere = 0 ؛کے لئے (نمونوں کے نمبر) {maxiendHere = math.max (num ، maxiendHere + num) ؛میکسوفر = میتھ.میکس (میکسوفر ، میکسینڈیئر) ؛max میکسفار کو واپس کریں ؛} اس مثال میں ، ہم ایک میکسبری فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عددی کی ایک صف لیتا ہے اور ایک متضاد سبری کی زیادہ سے زیادہ رقم واپس کرتا ہے۔فنکشن دو متغیرات میکسوفر اور 0 سے زیادہ سے زیادہ شروع کرتا ہے ، اور عدد کی صف میں تکرار کرتا ہے۔ہر انٹیجر کے ل the ، فنکشن اپ ڈیٹ کرتا ہے جس میں میکسینگ کو موجودہ انٹیجر یا موجودہ انٹیجر اور میکسینڈیئر کی رقم میں سے زیادہ سے زیادہ ہونا چاہئے ، اور میکس سافر کو زیادہ سے زیادہ میکس سافر یا میکسینڈی ہائیر میں سے زیادہ کی اپ ڈیٹ کرتا ہے۔تکرار کے مکمل ہونے کے بعد ، فنکشن میکسوفر کو لوٹاتا ہے۔ میکسبرری فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ نمبر = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] ؛ کانسٹ میکسسم = میکسبرے(نمبر) ؛ کنسول.لوگ (میکسم) ؛// 6 میں اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور میکسبرری فنکشن کا استعمال کرتے ہوئے ایک متضاد سبری کی زیادہ سے زیادہ رقم تلاش کرتے ہیں ، جس کا نتیجہ کنسول میں لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ترتیب دیئے گئے سرنی پر فبونیکی سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں ترتیب دیئے گئے سرنی پر فبونیکی سرچ الگورتھم کو نافذ کرنے کے ل we ، ہم تلاش کے نتائج میں بیان کردہ اقدامات پر عمل کرسکتے ہیں۔یہاں الگورتھم کا ایک جائزہ ہے: سب سے چھوٹی فبونیکی نمبر تلاش کریں جو دیئے گئے سرنی کی لمبائی سے زیادہ یا اس کے برابر ہے۔ہم (M-2) 'Th fibonacci نمبر کو بطور انڈیکس استعمال کرتے ہیں (اگر یہ ایک درست انڈیکس ہے) .let (M-2)' Th fibonacci نمبر I ہو ، ہم Arr [i] کا موازنہ x سے کرتے ہیں ، اگر x ایک جیسے ہے تو، ہم لوٹتے ہیں i.ورنہ اگر ایکس زیادہ ہے تو ، ہم سبری کے لئے دوبارہ حاصل کرتے ہیں ، ورنہ ہم سبری سے پہلے دوبارہ حاصل کرتے ہیں۔ I.REEPEAT اقدامات 2-3 جب تک عنصر نہیں مل جاتا ہے یا سبیرے کا سائز ہوتا ہے۔ 1. یہاں کچھ وسائل ہیں جو حل کرنے کی مثالیں فراہم کرتے ہیں۔یہ مسئلہ: گیکسفورجیکس کی ویب سائٹ فبونیکی سرچ الگورتھم اور ایک سی ++ پر عمل درآمد کی ایک تفصیلی وضاحت فراہم کرتی ہے۔ ڈیلفٹ اسٹیک ویب سائٹ فیبوناکی سرچ الگورتھم کا ٹائپ اسکرپٹ پر عمل درآمد فراہم کرتی ہے۔ ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال: ٹائپ اسکرپٹ فنکشن فبونیکسی سرچ:[] ، x: نمبر): نمبر {آئیے fibm2 = 0 ؛آئیے fibm1 = 1 ؛آئیے fibm = fibm2 + fibm1 ؛آئیے آفسیٹ = -1 ؛جبکہ (fibm <arr.length) {fibm2 = fibm1 ؛fibm1 = fibm ؛fibm = fibm2 + fibm1 ؛} جبکہ (fibm> 1) {const i = math.min (آفسیٹ + fibm2 ، arr.length - 1) ؛if (arr [i] <x) {fibm = fibm1 ؛fibm1 = fibm2 ؛fibm2 = fibm - fibm1 ؛آفسیٹ = i ؛} ورنہ اگر (arr [i]> x) {fibm = fibm2 ؛fibm1 = fibm1 - fibm2 ؛fibm2 = fibm - fibm1 ؛} else {واپسی i ؛}} if (fibm1 && arr [آفسیٹ + 1] === x) {آفسیٹ + 1 ؛} واپسی -1 ؛} اس مثال کے طور پر ، ہم ایک فبوناسیسرچ فنکشن کی وضاحت کرتے ہیں جو عدد کی ایک صف اور ایک ہدف عدد کو دلائل کے طور پر لیتا ہے اور صف میں ہدف عدد کا انڈیکس واپس کرتا ہے ، یا اگر یہ نہیں پایا جاتا ہے تو -1۔فنکشن متغیر FIBM2 ، FIBM1 ، FIBM ، اور بالترتیب 0 ، 1 ، 1 ، اور -1 پر آفسیٹ کرتا ہے۔اس کے بعد یہ سب سے چھوٹی فبونیکی نمبر تلاش کرنے کے لئے فبونیکی تسلسل پر تکرار کرتا ہے جو صف کی لمبائی سے زیادہ یا اس کے برابر ہوتا ہے۔اس کے بعد ، یہ سرنی میں تقسیم پوائنٹس کا تعین کرنے اور مناسب سبری پر بائنری تلاش کرنے کے لئے فبونیکی نمبروں کا استعمال کرتے ہوئے سرے پر تلاش کرتا ہے۔فنکشن سرنی میں ٹارگٹ انٹیجر کا اشاریہ لوٹاتا ہے ، یا -1 اگر یہ نہیں پایا جاتا ہے۔ یہاں فبونیکسیسرچ فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ آر = [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8، 9] const const x = 8 ؛ const index = fibonaccisearch (arr ، x) ؛ کنسول.لاگ (انڈیکس) ؛// 7 اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف اور ایک ہدف عدد تشکیل دیتے ہیں ، اور فیبونیکسیسرچ فنکشن کا استعمال کرتے ہوئے سرے میں ٹارگٹ انٹیجر کا انڈیکس تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ آیا بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک مکمل بائنری درخت ہے۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا بائنری ٹری دی گئی بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک مکمل بائنری درخت ہے ، ہم تلاش کے نتائج میں بیان کردہ اقدامات پر عمل کرسکتے ہیں۔یہاں الگورتھم کا ایک جائزہ ہے: اگر جڑ کا نوڈ کالعدم ہے ، تو بائنری ٹری ایک مکمل بائنری درخت ہے۔ اگر جڑ کے نوڈ میں کوئی اولاد نہیں ہے ، تو بائنری ٹری ایک مکمل بائنری درخت ہے۔ اگر جڑ کے نوڈ میں صرف ایک ہے۔بچہ ، پھر بائنری ٹری ایک مکمل بائنری درخت نہیں ہے۔ اگر جڑ کے نوڈ کے دو بچے ہیں ، تو پھر بار بار یہ چیک کریں کہ آیا بائیں اور دائیں سب ٹریوں میں بھی مکمل بائنری درخت ہیں۔ اگر بائیں اور دائیں دونوں ذیلی ذیلی دونوں مکمل بائنری درخت ہیں ، تو پھربائنری ٹری ایک مکمل بائنری ٹری ہے۔ یہاں کچھ ایسے وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: ہیکیریارتھ ویب سائٹ اس بات کی تفصیلی وضاحت فراہم کرتی ہے کہ آیا بائنری ٹری ایک مکمل بائنری درخت ہے یا نہیں اور سی عمل درآمد کی جانچ کیسے کریں۔گیکسفورجیکس ویب سائٹ اس بات کی تفصیلی وضاحت فراہم کرتی ہے کہ آیا بائنری ٹری ایک مکمل بائنری درخت ہے یا نہیں اور سی ++ پر عمل درآمد کیا ہے۔بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (ویل؟: نمبر ، بائیں؟: ٹرینوڈ | null ، دائیں؟: ٹرینوڈ | null) {this.val = ویل ==== غیر متعینہ؟0: ویل ؛this.left = بائیں === غیر متعینہ؟NULL: بائیں ؛this.right = دائیں === غیر متعینہ؟NULL: ٹھیک ہے ؛}} فنکشن isfullbinarytree (جڑ: Treenode | null): بولین {اگر (! جڑ) {سچ واپس ؛} if (! root.left &&! root.right) {سچ واپس ؛} if (! root.left ||! روٹ. رائٹ) {جھوٹی لوٹ ؛} isfullbinarytree (root.left) && اور isfullbinarytree (روٹ. رائٹ)}} اس مثال میں ، ہم بائنری درخت میں نوڈ کی نمائندگی کرنے کے لئے ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں ، اور ایک فلبائنری ٹری فنکشن جو ایک دلیل کے طور پر ٹرینوڈ آبجیکٹ لیتا ہے اور واپس کرتا ہے۔بولین کی قیمت اس بات کی نشاندہی کرتی ہے کہ آیا بائنری درخت ایک مکمل بائنری درخت ہے یا نہیں۔فنکشن چیک کرتا ہے کہ آیا روٹ نوڈ کالعدم ہے یا اس کی کوئی اولاد نہیں ہے ، اور ان معاملات میں سچائی لوٹتی ہے۔اگر روٹ نوڈ کا صرف ایک بچہ ہے تو ، فنکشن غلط لوٹتا ہے۔اگر روٹ نوڈ کے دو بچے ہیں تو ، فنکشن بار بار جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں سبٹریز بھی مکمل بائنری درخت ہیں۔اگر بائیں اور دائیں دونوں ذیلی ذخیرے مکمل بائنری درخت ہیں تو ، فنکشن درست لوٹتا ہے ، بصورت دیگر یہ جھوٹی لوٹتا ہے۔ یہاں آئیسفل بائنری ٹری فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ روٹ = نیا ٹرینوڈ (1 ، نیا ٹرینوڈ (2 ، نیا ٹرینوڈ (4) ،) ،نیا ٹرینوڈ (5)) ، نیا ٹرینوڈ (3 ، نیا ٹرینوڈ (6) ، نیا ٹرینوڈ (7))) ؛ کانسٹ isfull = isfullbinarytree (جڑ) ؛ کنسول.لوگ (isfull) ؛// اس مثال کے طور پر ، ہم ایک بائنری ٹری تیار کرتے ہیں اور چیک کرتے ہیں کہ آیا یہ ایک مکمل بائنری ٹری ہے جس کا استعمال ISfullbinarytree فنکشن کا استعمال کرتے ہوئے کیا جاتا ہے ، جس کا نتیجہ کنسول میں لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں سائز اور راستے کے کمپریشن کے ذریعہ یونین کے ساتھ ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں سائز اور پاتھ کمپریشن کے لحاظ سے یونین کے ساتھ ایک ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کو نافذ کرنے کے ل we ، ہم مندرجہ ذیل اقدامات استعمال کرسکتے ہیں: ایک ڈس ڈیس سیٹ کلاس کی وضاحت کریں جو سیٹ میں ہر عنصر کے والدین اور درجہ بندی کو محفوظ کرتا ہے۔ایک واحد عنصر پر مشتمل سیٹ کریں۔ ایک تلاش کا طریقہ جس میں کسی دیئے گئے عنصر پر مشتمل سیٹ کے نمائندے کو تلاش کیا جاتا ہے ، تلاش کو بہتر بنانے کے لئے راستہ کمپریشن کا استعمال کرتے ہوئے۔ ایک یونین کا طریقہ کار جو ان کے عہدے کے ذریعہ دو سیٹوں کو ضم کرتا ہے ، انضمام کو بہتر بنانے کے لئے سائز کے لحاظ سے یونین کا استعمال کرتے ہیں۔.یہ کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: گیکسفورجیکس ویب سائٹ ناپسندیدہ سیٹ ڈیٹا ڈھانچے اور سی ++ پر عمل درآمد کی ایک تفصیلی وضاحت فراہم کرتی ہے۔ ویکیپیڈیا ویب سائٹ ڈسونٹ سیٹ ڈیٹا ڈھانچے اور اس کے آپریشنز کی تفصیلی وضاحت فراہم کرتی ہے۔.یہ ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ کلاس ڈس ڈیسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.rank = نئی صف (سائز) ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} میکیٹ (x: نمبر): باطل {this.palent [x] = x ؛this.rank [x] = 0 ؛} تلاش کریں (x: نمبر): نمبر {if (this.parent [x]! == x) {this.palent [x] = this.find (this.parent [x]) ؛this اس کو واپس کریں۔ والدین [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (جڑ ایکس === روٹ) {واپسی ؛} if (this.rank [rootx] <this.rank [روٹ]) {this.Pearnt [روٹ ایکس] = روٹ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}} اس مثال میں ، ہم ایک ناگوار طبقے کی وضاحت کرتے ہیں جو سائز اور پاتھ کمپریشن کے ذریعہ یونین کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔کلاس میں والدین اور درجہ بندی کی خصوصیات ہیں جو بالترتیب ہر عنصر کے والدین اور درجہ بندی کو محفوظ کرتی ہیں۔اس عمل میں ایک میکیٹ طریقہ شامل ہوتا ہے جو ایک نیا سیٹ تیار کرتا ہے جس میں ایک ہی عنصر ہوتا ہے ، ایک ایسا تلاش کا طریقہ جس میں سیٹ کا نمائندہ مل جاتا ہے جس میں ایک دیئے گئے عنصر پر مشتمل ہوتا ہے جس میں راہ کمپریشن کا استعمال ہوتا ہے ، اور ایک یونین کا طریقہ جو سائز کے لحاظ سے یونین کا استعمال کرتے ہوئے اپنے رینک کے ذریعہ دو سیٹوں کو ضم کرتا ہے۔یہاں ڈس ڈیسیٹ سیٹ کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ DSU = نیا ڈسیوئنٹ سیٹ (5) ؛ dsu.makeset (0) ؛ dsu.makeset (1) ؛ dsu.makeset (2) ؛ dsu.makeset (3) ؛ dsu.makeset (4) dsu.union (0 ، 1) d dsu.union (1 ، 2) d dsu.union (3 ، 4) ؛ کنسول.لوگ (dsu.find (2)) ؛// 0 console.log (dsu.find (4)) ؛// 3console.log (dsu.find (5)) ؛// 5 اس مثال کے طور پر ، ہم 5 عناصر کے ساتھ ایک نیا ڈس ڈیسوسٹ سیٹ آبجیکٹ تیار کرتے ہیں ، ہر ایک عنصر پر مشتمل 5 سیٹ بناتے ہیں ، اور یونین کے طریقہ کار کا استعمال کرتے ہوئے کچھ سیٹوں کو ضم کرتے ہیں۔اس کے بعد ہمیں تلاش کے طریقہ کار کا استعمال کرتے ہوئے کچھ عناصر کا نمائندہ ملتا ہے ، نتائج کو کنسول پر لاگ ان کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے متحرک پروگرامنگ کے ساتھ سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں متحرک پروگرامنگ کے ساتھ سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: سائز N X N کا ایک 2D سرنی ڈی پی بنائیں ، جہاں N ان پٹ سٹرنگ کی لمبائی ہے۔ ڈی پی کے اخترن عناصر کو سچ میں بنائیں ، چونکہ سنگل ایک سنگلکریکٹر ہمیشہ ایک palindrome ہوتا ہے۔ DP کے اوپری مثلث پر مبنی۔ تکرار رشتہ کا استعمال کرتے ہوئے اقدار کو بھرتا ہے [i] [j] = dp [i+1] [j-1] && s [i] === s[j]. اب تک دیکھا جانے والا سب سے طویل پیلنڈرمک اسٹرنگ کا کیپ ٹریک ، اور جب بھی لمبا لمبا پائے جاتے ہیں اس کی تازہ کاری کریں۔ سب سے طویل پیلنڈرومک سبسٹرنگ۔ یہاں کچھ ایسے وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: گیکسفورجیکس کی ویب سائٹ فراہم کرتی ہے۔متحرک پروگرامنگ اور سی ++ نفاذ کا استعمال کرتے ہوئے سب سے طویل پیلنڈرومک اسٹرنگ کو کس طرح تلاش کیا جائے اس کی ایک تفصیلی وضاحت۔ لیٹ کوڈ ویب سائٹ متحرک پروگرامنگ اور دو پوائنٹرز کا استعمال کرتے ہوئے \"سب سے طویل پیلنڈرومک اسٹرنگک\" مسئلہ کا حل فراہم کرتی ہے۔متحرک پروگرامنگ کا استعمال کرتے ہوئے \"سب سے طویل پیلنڈروومک اسٹرنگ\" مسئلہ۔ ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ فکشن طویل عرصے تک پالندرووم (ایس: سٹرنگ): سٹرنگ {کانسٹنٹ این = ایس لمبائی ؛کانسٹ ڈی پی: بولین [] [] = سرنی.فرم ({لمبائی: n} ، () => نیا سرنی (n). فل (غلط)) ؛آئیے زیادہ سے زیادہ = 1 ؛آئیے شروع کریں = 0 ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {dp [i] [i] = سچ ؛} کے لئے (آئیے i = 0 ؛ i <n - 1 ؛ i ++) {اگر (s [i] === s [i + 1]) {dp [i] [i + 1] = سچ ؛شروع = i ؛زیادہ سے زیادہ = 2 ؛}} کے لئے (آئیے k = 3 ؛ k <= n ؛ k ++) {for (i = 0 ؛ i <n - k+1 ؛ i ++) {const j = i+k - 1 ؛اگر (dp [i + 1] [j - 1] && s [i] === s [j]) {dp [i] [j] = سچ ؛if (k> میکس لمبائی) {start = i ؛maxlength = k ؛s. s.slice (شروع کریں ، شروع کریں ، اسٹارٹ + میکس لمبائی)}}}}} اس مثال میں ، ہم ایک طویل ترین پالندوم فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر تار لیتا ہے اور تار کے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے کی وضاحت کرتے ہیں۔فنکشن سائز N X N کا 2D سرنی DP تشکیل دیتا ہے ، جہاں N ان پٹ سٹرنگ کی لمبائی ہے ، اور DP کے اخترن عناصر کو سچ میں شروع کرتا ہے۔اس کے بعد یہ ڈی پی کے اوپری مثلث پر تکرار کرتا ہے ، جس میں تکرار کے رشتے کا استعمال کرتے ہوئے اقدار کو پُر کیا جاتا ہے [i] [j] = dp [i+1] [j-1] && s [i] === s [j]۔فنکشن اب تک دیکھا جانے والا سب سے طویل پیلنڈرومک اسٹرنگ کا سراغ لگاتا ہے ، اور جب بھی کوئی لمبا پتہ چلتا ہے تو اسے اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن سب سے طویل پیلنڈرومک اسٹرنگ لوٹتا ہے۔ یہاں طویل ترین پالنڈوم فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ ایس = \"باباد\" ؛ کانسٹنٹ طویل ترین = طویل ترینپالینڈوم (ایس) ؛ کنسول.لوگ (سب سے طویل) ؛// \"باب\" اس مثال کے طور پر ، ہم ایک تار تیار کرتے ہیں اور طویل ترین پالنڈرووم فنکشن کا استعمال کرتے ہوئے سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں کواڈٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یہاں ٹائپ اسکرپٹ میں کواڈٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے ، جو گٹ ہب پر N8Rzz/کواڈ ٹری ریپوزٹری سے موافقت پذیر ہے: ٹائپ اسکرپٹ کلاس نقطہ {x: نمبر ؛Y: نمبر ؛کنسٹرکٹر (x: نمبر ، Y: نمبر) {this.x = x ؛this.y = y ؛}} کلاس مستطیل {x: نمبر ؛Y: نمبر ؛چوڑائی: نمبر ؛اونچائی: نمبر ؛کنسٹرکٹر (x: نمبر ، Y: نمبر ، چوڑائی: نمبر ، اونچائی: نمبر) {this.x = x ؛this.y = y ؛this.width = چوڑائی ؛this.height = اونچائی ؛} پر مشتمل ہے (نقطہ: نقطہ): بولین {ریٹرن (پوائنٹ. x> = this.x && پوائنٹ۔y + this.height) ؛} چوراہے (رینج: مستطیل): بولین {واپسی!|| رینج۔}} کلاس کواڈٹری {حد: مستطیل ؛صلاحیت: نمبر ؛پوائنٹس: پوائنٹ [] ؛تقسیم: بولین ؛NW: کواڈٹری |خالی؛NE: کواڈٹری |خالی؛ایس ڈبلیو: کواڈٹری |خالی؛SE: کواڈٹری |خالی؛کنسٹرکٹر (حد: مستطیل ، صلاحیت: نمبر) {this.boundary = حد ؛this.capacity = صلاحیت ؛this.Points = [] ؛this.dived = غلط ؛this.nw = null ؛this.ne = null ؛this.sw = null ؛this.se = null ؛} سب ڈیوڈ (): باطل {const x = this.boundary.x ؛const y = this.boundary.y ؛Const w = this.boundary.width / 2 ؛const h = this.boundary.height / 2 ؛const nwboundary = نیا مستطیل (x ، y ، w ، h) ؛Const nboundary = نیا مستطیل (x + W ، Y ، W ، H) ؛Const swboundary = نیا مستطیل (x ، y + h ، w ، h) ؛const seboundary = نیا مستطیل (x + w ، y + h ، w ، h) ؛this.nw = نیا کواڈٹری (nwboundary ، this.capacity) ؛this.ne = نیا کواڈٹری (نیباؤنڈری ، یہ.کاسٹی) ؛this.sw = نیا کواڈٹری (swboundary ، this.capacity) ؛this.se = نیا کواڈٹری (seboundary ، this.capacity) ؛this.dived = true ؛} داخل کریں (نقطہ: نقطہ): بولین {اگر (! this.boundary.contains (نقطہ)) {غلط واپس ؛} if (this.points.length <this.capacity) {this.points.push (نقطہ) ؛واپس سچ ؛} if (! this.dived) {this.subdivide () ؛} if (this.nw؟ .insert (نقطہ)) {سچ واپس ؛} if (this.ne ؟.insert(point)) {سچ واپس ؛} if (this.sw؟ .insert (نقطہ)) {سچ واپس ؛} if (this.se؟.insert(point)) {سچ واپس ؛} جھوٹی لوٹ ؛} استفسار (حد: مستطیل ، پایا: نقطہ []): نقطہ [] {اگر (! this.boundary.intersects (حد)) {واپسی ملی۔} for کے لئے (اس نقطہ کا نقطہ نظر) {اگر (رینج.کونٹینز (پوائنٹ)) {found.push (نقطہ) ؛}} if (this.dived) {this.nw؟ .query (حد ، پایا) ؛this.ne ؟.query(range ، ملا) ؛this.sw؟ .query (رینج ، پایا) ؛this.se؟.query(range ، ملا) ؛} واپسی ملی ؛}} اس مثال میں ، ہم ایک نقطہ طبقے کی وضاحت کرتے ہیں جو 2 ڈی اسپیس میں ایک نقطہ کی نمائندگی کرتا ہے ، ایک مستطیل طبقے جو 2D جگہ میں آئتاکار خطے کی نمائندگی کرتا ہے ، اور ایک کواڈٹری کلاس جو کواڈٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس پر عمل درآمد میں ایک ذیلی تقسیم کا طریقہ شامل ہے جو کواڈٹری کو چار کواڈرینٹ میں تقسیم کرتا ہے ، ایک داخل کرنے کا طریقہ جو کواڈٹری میں ایک نقطہ داخل کرتا ہے ، اور ایک استفسار کا طریقہ جو آئتاکار خطے میں موجود تمام پوائنٹس کو واپس کرتا ہے۔کواڈٹری کلاس میں پراپرٹیز کی حد ، صلاحیت ، پوائنٹس ، منقسم ، اور NW ، NE ، SW ، اور SE بھی ہے جو کواڈٹری کی حدود ، ہر نوڈ کی زیادہ سے زیادہ صلاحیت ، کواڈٹری میں محفوظ کردہ پوائنٹس ، ایک جھنڈا اس بات کی نشاندہی کرتا ہے کہ آیا ہےکواڈٹری کو تقسیم کیا گیا ہے ، اور بالترتیب کواڈٹری کے چار کواڈرینٹ ، کواڈٹری کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ باؤنڈری = نیا مستطیل (0 ، 0 ، 400 ، 400) ؛ کانسٹ کیو ٹی = نیا کواڈٹری (حد ، 4) ؛کے لئے (آئیے i = 0 ؛ i <100 ؛ i ++) {const x = math.floor (math.random () * 400) ؛const y = math.floor (math.random () * 400) ؛Qt.insert (نیا نقطہ (x ، y)) ؛} constance رینج = نیا مستطیل (100 ، 100 ، 200 ، 200) ؛ کانسٹ فاؤنڈ = qt.query (رینج ، []) ؛ کنسول.لوگ (ملا) in inاس مثال کے طور پر ، ہم (0 ، 0 ، 400 ، 400) کی حد کے ساتھ ایک نیا کواڈٹری آبجیکٹ تیار کرتے ہیں اور زیادہ سے زیادہ 4 پوائنٹس فی نوڈ کی گنجائش۔اس کے بعد ہم کواڈٹری میں 100 بے ترتیب پوائنٹس داخل کرتے ہیں اور (100 ، 100 ، 200 ، 200) کے آئتاکار خطے کے اندر موجود تمام نکات کے لئے استفسار کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصہ تک بڑھتی ہوئی تعداد کو تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: سائز N کی ایک سرنی ڈی پی بنائیں ، جہاں ان ان پٹ سرنی کی لمبائی ہے ، جس کی ابتداء ان پٹ کے اوپر 1. اہم ہے۔انڈیکس 1 سے N-1 تک سرنی ، اور ہر انڈیکس I کے لئے ، انڈیکس 0 سے I-1 تک ان پٹ سرنی پر تکرار کریں ، اور اگر ARR [I]> ARR [J] ، DP [I] کو ریاضی.میکس میں اپ ڈیٹ کریں (ڈی پی [آئی] ، ڈی پی [جے] + 1)۔ ڈی پی سرنی میں زیادہ سے زیادہ قیمت لگائیں ، جو طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی کی نمائندگی کرتا ہے۔ ڈی پی سرنی کو دائیں سے بائیں ، اور ہر انڈیکس کے لئے ڈی پی [i] زیادہ سے زیادہ قیمت کے برابر ، اس سے متعلقہ عنصر ARR [i] کو نتیجہ سرنی میں شامل کریں۔ اس کے بعد بڑھتے ہوئے ترتیب میں سب سے طویل عرصہ تک بڑھتی ہوئی کامیابی حاصل کرنے کے لئے نتیجہ سرنی کو دیکھیں۔ یہاں کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں:لیٹ کوڈ ویب سائٹ متحرک پروگرامنگ اور دو پوائنٹرز کا استعمال کرتے ہوئے \"طویل عرصے سے بڑھتی ہوئی متنازعہ\" مسئلے کا حل فراہم کرتی ہے۔ ٹیک ڈیلائٹ ویب سائٹ متحرک پروگرامنگ اور ٹائپ اسکرپٹ کے نفاذ کا استعمال کرتے ہوئے طویل عرصے تک بڑھتی ہوئی بعد کی تلاش کے بارے میں ایک تفصیلی وضاحت فراہم کرتی ہے۔ٹائپ اسکرپٹ میں نقطہ نظر: ٹائپ اسکرپٹ فنکشن طویل ترین انکریزنگسوبسنس (ARR: نمبر []): نمبر [] {const n = arr.length ؛کانسٹ ڈی پی = نئی سرنی (این). فل (1) ؛کے لئے (i = 1 ؛ i <n ؛ i ++) {for (j = 0 ؛ j <i ؛ j ++) {if (arr [i]> arr [j]) {dp [i] = math.max (ڈی پی [i] ، dp [j] + 1) ؛}}} کانسٹ میکسلنتھ = ریاضی۔ میکس (... ڈی پی) ؛کانسٹنگ نتیجہ = [] ؛کے لئے (i = n-1 ؛ i> = 0 && میکس لمبائی> 0 ؛ i--) {اگر (dp [i] === میکس لمبائی) {نتیجہ. پش (arr [i]) ؛زیادہ سے زیادہ طوالت--؛} returned ریٹرن کا نتیجہ.فنکشن سائز N کا ایک سرنی ڈی پی بناتا ہے ، جہاں ان پٹ سرنی کی لمبائی ہوتی ہے ، جس کی ابتدا 1 ہوتی ہے۔ اس کے بعد انڈیکس 1 سے N-1 تک ان پٹ سرنی کے اوپر تکرار ہوتا ہے ، اور ہر انڈیکس I کے لئے ، ان پٹ سرنی کے اوپر تکرار ہوتا ہے۔انڈیکس 0 سے I-1 تک ، اور اگر err [i]> arr [j] ، ڈی پی [i] کو ریاضی.میکس (ڈی پی [i] ، ڈی پی [جے] + 1) میں اپ ڈیٹ کرتا ہے۔اس کے بعد اس فنکشن کو ڈی پی سرنی میں زیادہ سے زیادہ قیمت مل جاتی ہے ، جو طویل عرصے تک بڑھتے ہوئے بڑھتے ہوئے حصے کی لمبائی کی نمائندگی کرتی ہے۔اس کے بعد یہ ڈی پی سرنی کو دائیں سے بائیں سے عبور کرتا ہے ، اور ہر انڈیکس I کے ساتھ DP [i] زیادہ سے زیادہ قیمت کے برابر ہوتا ہے ، اس سے متعلقہ عنصر ARR [i] کو نتیجہ سرنی میں شامل کرتا ہے۔آخر میں ، فنکشن بڑھتے ہوئے ترتیب میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو حاصل کرنے کے ل result نتیجہ سرے کو تبدیل کرتا ہے۔ یہاں طویل عرصے سے متعلقہ کام کی ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ آر آر = [10 ، 9 ، 2 ، 5 ، 3 ، 7 ، 101 ، 18]= طویل عرصے سے متعلقہ (ARR) ؛ کنسول.لوگ (سب سے طویل) ؛// [2 ، 3 ، 7 ، 18] اس مثال میں ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرتے ہیں جس کا استعمال طویل عرصے تک انکریسنگسوبسنس فنکشن کا استعمال کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں وزن میں متوازن درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "وزن میں متوازن درخت بائنری تلاش کے درخت ہیں جو نوڈس میں سب ٹریوں کے سائز کو محفوظ کرتے ہیں۔ایک نوڈ میں کلید ، قدر (اختیاری) ، بائیں ، دائیں اور سائز جیسے فیلڈز ہوتے ہیں۔درختوں میں ترمیم کرنے والے آپریشنوں کو یہ یقینی بنانا ہوگا کہ ہر نوڈ کے بائیں اور دائیں سبٹریز کا وزن ایک دوسرے کے کسی عنصر کے اندر رہتا ہے ، اے وی ایل کے درختوں میں استعمال ہونے والے ایک ہی توازن کو استعمال کرتے ہوئے: گردش اور ڈبل گردش۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں وزن سے متوازن درختوں کو کس طرح نافذ کرنے کی مثال فراہم کرتے ہیں: گٹ ہب ٹاپکس پیج وزن میں متوازن درختوں سے متعلق ذخیروں کی ایک فہرست فراہم کرتا ہے ، جس میں کچھ ٹائپ اسکرپٹ کے نفاذ بھی شامل ہیں۔ ویکیپیڈیا کا صفحہ وزن میں توازن کی ایک تفصیلی وضاحت فراہم کرتا ہے۔درخت اور ان کی کاروائیاں۔ GWTW/TS-Splay-tree tree respository پر گٹھب پر ایک ٹائپ اسکرپٹ پر عمل درآمد فراہم کرتا ہے۔درخت اور ڈھیر کی خصوصیات"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ تین عدد کی مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں تین انٹیجرز کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ان پٹ سرنی کو غیر تدریجی ترتیب میں ترتیب دیں۔دو عناصر اور آخری عنصر۔ دو مصنوعات میں سے زیادہ سے زیادہ کا آغاز کریں۔ یہاں کچھ ایسے وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: لیٹ کوڈ ویب سائٹ چھانٹنے کا استعمال کرتے ہوئے \"تین نمبروں کی زیادہ سے زیادہ مصنوعات\" کے مسئلے کا حل فراہم کرتی ہے اور Aٹائپ اسکرپٹ کا نفاذ۔ بعد کی ویب سائٹ اس کی تفصیلی وضاحت فراہم کرتی ہے کہ کس طرح بروٹ فورس ، چھانٹ رہا ہے ، اور ڈھیر ڈیٹا ڈھانچے کے نقطہ نظر کا استعمال کرتے ہوئے ایک صف میں تین نمبروں کی زیادہ سے زیادہ مصنوعات کو تلاش کیا جاسکتا ہے ، اس کے ساتھ ساتھ ٹائپ اسکرپٹ پر عمل درآمد بھی ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال عمل ہے۔: ٹائپ اسکرپٹ فینکشن زیادہ سے زیادہ پروڈکٹیو فیتھیرینمبرس (نمبر: نمبر []): نمبر {nums.sort ((a ، b) => a - b) ؛const n = nums.length ؛کونسٹ پروڈکٹ 1 = نمبر [n - 1] * نمبر [n - 2] * نمبر [n - 3] ؛Const product2 = nums [0] * نمبر [1] * نمبر [n - 1] ؛واپس میتھ۔ میکس (پروڈکٹ 1 ، پروڈکٹ 2) ؛} اس مثال میں ، ہم ایک زیادہ سے زیادہ پروڈکٹ آف تھیرنمبرس فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عدد کی ایک صف لیتا ہے اور صف میں تین عدد کی زیادہ سے زیادہ مصنوعات کو واپس کرتا ہے۔فنکشن ترتیب کے طریقہ کار کا استعمال کرتے ہوئے غیر انکار ترتیب میں ان پٹ سرنی کو ترتیب دیتا ہے۔اس کے بعد یہ صف کے آخری تین عناصر کی پیداوار اور پہلے دو عناصر اور آخری عنصر کی پیداوار کی گنتی کرتا ہے ، اور ریاضی کا استعمال کرتے ہوئے دونوں مصنوعات کی زیادہ سے زیادہ واپس کرتا ہے۔ میکس طریقہ۔ یہاں زیادہ سے زیادہ پروڈکٹ آف تھراینمبرس فنکشن کا ایک مثال استعمال ہے:ٹائپ اسکرپٹکونسٹ نمبر = [1 ، 2 ، 3 ، 4 ، 5] ؛ کانسٹ میکس پروڈکٹ = زیادہ سے زیادہ پروڈکٹیو فیتھیرینمبرس (نمبر) ؛ کنسول.لاگ (میکس پروڈکٹ) ؛// 60in اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور زیادہ سے زیادہ پروڈکٹیو فاتھرینمبرس فنکشن کا استعمال کرتے ہوئے صف میں تین عدد کی زیادہ سے زیادہ مصنوعات تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں وان ایمڈے بوس ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر فلائیڈ وارشل مختصر ترین راستہ الگورتھم انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر فلائیڈ وارشل مختصر ترین راستہ الگورتھم انجام دینے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: سائز N X N کی دو جہتی صف کو شروع کریں ، جہاں N گراف میں عمودی کی تعداد ہے ، اور ڈسٹ سیٹ [i][j] ورٹیکس I سے لے کر ورٹیکس جے تک کنارے کے وزن تک ، یا اگر کوئی کنارے نہیں ہے۔ گراف میں ہر ایک ورٹیکس K کے لئے ، عمودی I اور J کے تمام جوڑے پر تکرار کریں ، اور اگر I سے I سے J تک کا فاصلہ ہے۔K کے ذریعے I سے J سے موجودہ فاصلے سے کم ہے ، ڈسٹ ڈسٹ [i] [j] کو نئے فاصلے پر اپ ڈیٹ کریں۔ تمام عمودی K پر تکرار کرتے ہوئے ، ڈسٹرکٹ سرنی میں گراف میں موجود عمودی کے جوڑے کے درمیان مختصر ترین راستہ فاصلہ ہوگا۔.یہ کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: گیکسفورجیکس ویب سائٹ ٹائپ اسکرپٹ کا استعمال کرتے ہوئے مسئلہ \"کسی بھی دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے\" کا حل فراہم کرتی ہے۔فلائیڈ وارشل الگورتھم اور ٹائپ اسکرپٹ میں اس کا نفاذ۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے نفاذ: ٹائپ اسکرپٹ فنکشن فلائیڈورشال (گراف: نمبر [] []): نمبر [] [] {کانسٹ این = گراف.لننگ ؛Const dist = [... گراف] ؛کے لئے (k = 0 ؛ k <n ؛ k ++) {for (i = 0 ؛ i <n ؛ i ++) {for (j = 0 ؛ j <n ؛ j ++) {اگر (ڈسٹ [i] [k] + ڈسٹ [K] [j] <ڈسٹ [i] [j]) {ڈسٹرکٹ [i] [j] = ڈسٹ [i] [k] + ڈسٹ [k] [j] ؛}}}} ریٹرن ڈسٹ ؛}} اس مثال میں ، ہم ایک فلائیڈورشل فنکشن کی وضاحت کرتے ہیں جو ایک دو جہتی سرنی گراف لیتا ہے جو کسی گراف کے ملحقہ میٹرکس کو دلیل کے طور پر نمائندگی کرتا ہے اور سب کے مابین مختصر ترین راستے کی نمائندگی کرنے والے دو جہتی صف ڈسٹرکٹ کو واپس کرتا ہے۔گراف میں عمودی جوڑے۔فنکشن گراف سرنی کی ایک کاپی بننے کے لئے ڈسٹ سرنی کو شروع کرتا ہے ، اور پھر گراف میں موجود تمام عمودی K پر تکرار کرتا ہے ، جیسا کہ اوپر بیان کیا گیا ہے۔آخر میں ، فنکشن ڈسٹ سرنی کو لوٹاتا ہے۔ یہاں فلائیڈورشل فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ گراف = [[0 ، 5 ، انفینٹی ، 10] ، [انفینٹی ، 0 ، 3 ، انفینٹی] ، [انفینٹی ، انفینٹی ، 0 ، 1] ، [انفینٹی ، انفینٹی ، انفینٹی ، 0] ،] ؛ کنسٹ ڈسٹ = فلوڈورشال (گراف) ؛ کنسول.لاگ (ڈسٹرکٹ) ؛ // آؤٹ پٹ: [// [0 ، 5 ، 8 ، 9] ، // [انفینٹی، 0 ، 3 ، 4] ، // [انفینٹی ، انفینٹی ، 0 ، 1] ، // [انفینٹی ، انفینٹی ، انفینٹی ، 0] ، //] اس مثال میں ، ہم چاروں کے ساتھ گراف کی نمائندگی کرنے والا ایک ملحقہ میٹرکس گراف تیار کرتے ہیں۔عمودی اور چار کناروں کو ، اور فلوڈورشل فنکشن کا استعمال کرتے ہوئے گراف میں عمودی کے تمام جوڑے کے درمیان مختصر ترین راستہ تلاش کریں ، جس کا نتیجہ کنسول میں لاگ ان کریں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں رابن کارپ یا نوتھ مورس پریٹ جیسے سٹرنگ مماثل الگورتھم کو نافذ کریں۔",
        "Answer": "بہت سارے سٹرنگ مماثل الگورتھم ہیں جن کو ٹائپ اسکرپٹ میں نافذ کیا جاسکتا ہے ، جس میں رابن کارپ اور نوتھ مورس پریٹ شامل ہیں۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں سٹرنگ مماثل الگورتھم کو کس طرح نافذ کرنے کی مثال فراہم کرتے ہیں: گٹ ہب ٹاپکس پیج سٹرنگ مماثل الگورتھم سے متعلق ذخیروں کی ایک فہرست فراہم کرتا ہے ، جس میں کچھ ٹائپ اسکرپٹ کے نفاذ بھی شامل ہیں۔ ٹیوٹوریلس پوائنٹ کی ویب سائٹ تلاش () کے طریقہ کار پر ایک ٹیوٹوریل فراہم کرتی ہے۔ٹائپ اسکرپٹ میں ، جو باقاعدہ اظہار اور سٹرنگ کے مابین میچ کی تلاش کے لئے استعمال کیا جاسکتا ہے۔ گیکسفورجیکس ویب سائٹ ٹائپ اسکرپٹ میں تلاش () کے طریقہ کار پر ایک ٹیوٹوریل فراہم کرتی ہے ، جو باقاعدہ اظہار اور a کے مابین میچ کی تلاش کے لئے استعمال کی جاسکتی ہے۔سٹرنگ۔ ٹائپ اسکرپٹ میں رابن-کارپ الگورتھم کا ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ فینکشن رابنکارپ (متن: سٹرنگ ، پیٹرن: سٹرنگ: سٹرنگ): نمبر [] {کانسٹنگ نتیجہ: نمبر [] = [] ؛const n = text.length ؛کانسٹ ایم = پیٹرن۔ لمبائی ؛کانسٹ پرائم = 101 ؛کانسٹ پیٹرن ہاش = ہیش (پیٹرن ، پرائم) ؛آئیے ٹیکسٹھاش = ہیش (ٹیکسٹ.سلائس (0 ، ایم) ، پرائم) ؛کے لئے (آئیے i = 0 ؛ i <= n - m ؛ i ++) {اگر (پیٹرن ہش === ٹیکس ٹھاش && پیٹرن === text.slice (i ، i+m)) {نتیجہ. پش (i) ؛} if (i <n - m) {Texthash = recalculatehash (متن ، i ، i + m ، Texthash ، prime) ؛}} واپسی کا نتیجہ} فنکشن ہیش (str: سٹرنگ ، پرائم: نمبر): نمبر {آئیے ہیش = 0 ؛کے لئے (i = 0 ؛ i <str.length ؛ i ++) {ہیش+= str.charcodeat (i) * math.pow (پرائم ، i) ؛} ہیش}} فنکشن recalculatehash (str: سٹرنگ ، اولڈ انڈیکس: نمبر ، نیو انڈیکس: نمبر ، اولڈ ہش: نمبر ، پرائم: نمبر): نمبر {آئیے نیو ہش = اولڈ ہش - str.charcodeat (اولڈ انڈیکس) ؛نیو ہش /= پرائم ؛نیو ہش += str.charcodeat (newIndex) * math.pow (پرائم ، نیو انڈیکس - اولڈ انڈیکس - 1) ؛نیو ہاش واپس کریں ؛ اس مثال میں ، ہم ایک رابنکارپ فنکشن کی وضاحت کرتے ہیں جو دو ڈوروں کے متن اور نمونہ کو دلائل کے طور پر لیتا ہے اور انڈیکس کی ایک صف کو واپس کرتا ہے جہاں متن میں نمونہ ہوتا ہے۔فنکشن سٹرنگ مماثلت کو انجام دینے کے لئے رابن کارپ الگورتھم کا استعمال کرتا ہے۔ہیش فنکشن ایک پرائم نمبر کا استعمال کرتے ہوئے کسی تار کی ہیش ویلیو کا حساب لگاتا ہے ، اور ریکالکولیٹ ہاش فنکشن کسی شفٹ کے بعد کسی تار کی ہیش کی قیمت کو دوبارہ گنتی کرتا ہے۔رابنکارپ فنکشن متن میں لمبائی ایم کے ہر ممکنہ ذیلی ذخیروں پر تکرار کرتا ہے ، ان کی ہیش اقدار کا حساب لگاتا ہے اور ان کا موازنہ پیٹرن کی ہیش ویلیو سے کرتا ہے۔اگر کوئی میچ ہوتا ہے تو ، رزلٹ سرنی میں اسٹرنگ کا انڈیکس شامل کیا جاتا ہے۔فنکشن نتیجہ سرنی کو لوٹاتا ہے۔ یہاں رابنکارپ فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ ٹیکسٹ = \"ابابداباکداببکاباب\" ؛ کانسٹر پیٹرن = \"ابابکاباب\" ؛ کانسٹ انڈیکس = رابنکارپ (متن ، نمونہ) ؛ کنسول.لوگ (اشارے) ؛// [10] اس مثال میں ، ہم دو ڈور ٹیکسٹ اور پیٹرن تیار کرتے ہیں ، اور وہ اشارے تلاش کرتے ہیں جہاں ریبنکارپ فنکشن کا استعمال کرتے ہوئے متن میں نمونہ ہوتا ہے ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے 1s اور 0s کے میٹرکس میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے 1s اور 0s کے میٹرکس میں جزیروں کی تعداد تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: میٹرکس کے تمام خلیوں پر تکرار کریں ، اور اگر کسی سیل میں 1 پر مشتمل ہے تو ، نشان زد کرنے کے لئے گہرائی سے پہلے تلاش (DFS) انجام دیں۔ایک ہی جزیرے کے تمام خلیات جیسے ملاحظہ کریں۔ ڈی ایف ایس کی کارکردگی کی تعداد کا حساب لگائیں ، جو میٹرکس میں جزیروں کی تعداد کے برابر ہے۔ یہاں کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: گیکسفورجیکس ویب سائٹ فراہم کرتی ہے۔ٹائپ اسکرپٹ کا استعمال کرتے ہوئے \"ڈی ایف ایس کا استعمال کرتے ہوئے جزیروں کی تعداد تلاش کریں\" کا ایک حلٹائپ اسکرپٹ میں یہ نقطہ نظر: ٹائپ اسکرپٹ فنکشن Numislands (گرڈ: نمبر [] [])): نمبر {const m = grid.length ؛کانسٹ این = گرڈ [0]. لمبائی ؛کنسٹ ملاحظہ: بولین [] [] = [] ؛کے لئے (آئیے i = 0 ؛ i <m ؛ i ++) {ملاحظہ کریں۔ پش (نیا سرنی (n). فل (غلط)) ؛counting آئیے گنتی = 0 ؛کے لئے (آئیے i = 0 ؛ i <m ؛ i ++) {for (j = 0 ؛ j <n ؛ j ++) {اگر (گرڈ [i] [j] === 1 &&! ملاحظہ کیا [i] [j]) {DFS (گرڈ ، ملاحظہ کیا ، i ، j) ؛گنتی ++ ؛}}} واپسی کی گنتی ؛} فنکشن ڈی ایف ایس (گرڈ: نمبر [] [] ، ملاحظہ: بولین [] [] ، i: نمبر ، جے: نمبر): باطل {کانٹ ایم = گرڈ۔ لمبائی ؛کانسٹ این = گرڈ [0]. لمبائی ؛اگر (i <0 || i> = m || j <0 || j> = n || گرڈ [i] [j] === 0 || ملاحظہ کیا گیا [i] [j]) {واپسی ؛} ملاحظہ کیا [i] [j] = سچ ؛ڈی ایف ایس (گرڈ ، ملاحظہ کیا ، i - 1 ، j) ؛ڈی ایف ایس (گرڈ ، ملاحظہ کیا ، i + 1 ، j) ؛ڈی ایف ایس (گرڈ ، ملاحظہ کیا ، i ، J - 1) ؛ڈی ایف ایس (گرڈ ، ملاحظہ کیا گیا ، I ، J + 1) ؛} اس مثال میں ، ہم ایک نمیس لینڈز فنکشن کی وضاحت کرتے ہیں جو ایک دو جہتی سرنی گرڈ لیتا ہے جس میں 1s اور 0s کے میٹرکس کو ایک دلیل کے طور پر نمائندگی کیا جاتا ہے اور میٹرکس میں جزیروں کی تعداد واپس کردی جاتی ہے۔اس فنکشن نے میٹرکس میں آنے والے خلیوں کا سراغ لگانے کے لئے دو جہتی صف کا دورہ کیا ہے۔اس کے بعد میٹرکس میں موجود تمام خلیوں پر تکرار کرتا ہے ، اور اگر کسی سیل میں 1 ہوتا ہے اور اس کا دورہ نہیں ہوتا ہے تو ، یہ ایک ہی جزیرے کے تمام خلیوں کو نشان زد کرنے کے لئے ایک ڈی ایف ایس انجام دیتا ہے۔فنکشن ڈی ایف ایس کے انجام دینے کی تعداد کی گنتی کرتا ہے ، جو میٹرکس میں جزیروں کی تعداد کے برابر ہے۔فنکشن گنتی کو لوٹاتا ہے۔ Namislands فنکشن کا ایک مثال استعمال: ٹائپ اسکرپٹ کنسٹ گرڈ = [[[1 ، 1 ، 0 ، 0 ، 0] ، [0 ، 1 ، 0 ، 0 ، 1] ، [1 ، 0 ، 0 ،1 ، 1] ، [0 ، 0 ، 0 ، 0 ، 0] ، [1 ، 0 ، 1 ، 0 ، 0] ،] ؛ const num = numislands (گرڈ) ؛ کنسول.لوگ (نمبر) ؛// 5 اس مثال کے طور پر ، ہم 1s اور 0s کا میٹرکس بناتے ہیں اور نمیس لینڈز فنکشن کا استعمال کرتے ہوئے میٹرکس میں جزیروں کی تعداد تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں فینوک ٹری (بائنری انڈیکسڈ ٹری) ڈیٹا ڈھانچہ کو لاگو کریں۔",
        "Answer": "ٹائپ اسکرپٹ فینوک ٹری میں فینوک ٹری (بائنری انڈیکسڈ ٹری) ڈیٹا ڈھانچہ ، جسے بائنری انڈیکسڈ ٹری (BIT) بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو اقدار کے جدول کے ماقبل کے حساب کتاب اور ہیرا پھیری کے لئے موثر طریقے مہیا کرتا ہے۔یہ O (لاگ این) ٹائم پیچیدگی میں مؤثر طریقے سے حساب کتاب کرنے کی اجازت دیتا ہے ، جہاں N ٹیبل کا سائز ہے۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں فینوک ٹری کو نافذ کرنے کے طریقہ کی مثالیں فراہم کرتے ہیں: مائیکروسافٹ/فاسٹ بائنری انڈیکسڈ ٹری جے ایس گٹ ہب پر ذخیرہ بائنری انڈیکسڈ ٹری ڈیٹا ڈھانچے کا ایک ٹائپ اسکرپٹ پر عمل درآمد فراہم کرتا ہے جس میں تیزی سے ابتداء ہوتی ہے۔ٹائپ اسکرپٹ میں فینوک ٹری اور اس کے نفاذ کی ایک تفصیلی وضاحت۔کنسٹرکٹر (سائز: نمبر) {this.tree = نیا سرنی (سائز + 1). فل (0) ؛} اپ ڈیٹ (انڈیکس: نمبر ، قیمت: نمبر): باطل {جبکہ (انڈیکس <this.tree.length) {this.tree [انڈیکس] += ویلیو ؛انڈیکس += انڈیکس & -index ؛}} استفسار (اشاریہ: نمبر): نمبر {اجازت دیں = 0 ؛جبکہ (انڈیکس> 0) {رقم += this.tree [انڈیکس] ؛انڈیکس -= انڈیکس & -index ؛} رقم واپس ؛}} اس مثال میں ، ہم ایک فین وِک ٹری کلاس کی وضاحت کرتے ہیں جو فینوک ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس عمل میں ایک درخت کی صف شامل ہے جو اقدار کے جدول کے سابقہ رقم کو محفوظ کرتی ہے۔کلاس میں اپ ڈیٹ اور استفسار جیسے طریقے شامل ہیں جو بالترتیب سابقہ رقم کو اپ ڈیٹ کرنے اور ان سے استفسار کرنے کی اجازت دیتے ہیں۔تازہ کاری کا طریقہ انڈیکس میں عنصر اور درخت میں اس کے تمام آباؤ اجداد کی قیمت شامل کرکے سابقہ رقم کو اپ ڈیٹ کرتا ہے۔استفسار کا طریقہ درخت میں 1 سے انڈیکس میں عناصر کا مجموعہ لوٹاتا ہے۔ یہاں فین وِک ٹری کلاس کا ایک مثال استعمال: ٹائپ اسکرپٹکونسٹ ٹری = نیا فین وِکیٹری (5) ؛ درخت.پڈیٹ (1 ، 2) ؛ درخت۔ اپ ڈیٹ (2 ، 2 ، 2 ، 2 ،3) tree درخت. اپ ڈیٹ (3 ، -1) ؛ کنسول.لوگ (درخت.کیری (3)) ؛// 4 میں اس مثال کے طور پر ، ہم 5 کے سائز کے ساتھ ایک فین وِک ٹری آبجیکٹ تیار کرتے ہیں اور اپ ڈیٹ کے طریقہ کار کا استعمال کرتے ہوئے اس کے سابقہ رقم کو اپ ڈیٹ کرتے ہیں۔اس کے بعد ہم استفسار کے طریقہ کار کا استعمال کرتے ہوئے 1 سے 3 تک کے سابقہ رقم سے استفسار کرتے ہیں ، نتائج کو کنسول پر لاگ ان کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تار کی صفوں میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تاروں کی ایک صف میں سب سے طویل مشترکہ لاحقہ تلاش کرنے کے ل we ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: تاروں کی صف میں سب سے کم تار تلاش کریں۔ آخر سے شروع سے کم ترین تار کے کرداروں اور ہر کردار کے لئے اس کا جائزہ لیں۔، چیک کریں کہ آیا یہ صف میں موجود تمام ڈوروں کا لاحقہ ہے۔ اگر کردار تمام ڈوروں کا لاحقہ ہے تو ، اسے نتیجہ کے تار میں شامل کریں۔ نتیجہ کی تار کو دوبارہ شروع کریں۔ یہاں کچھ وسائل ہیں جو حل کرنے کی مثالیں فراہم کرتے ہیں۔یہ مسئلہ: اسٹیک اوور فلو ویب سائٹ \"جاوا اسکرپٹ میں سب سے طویل عام سابقہ\" کے مسئلے کا حل فراہم کرتی ہے ، جسے سب سے طویل عام لاحقہ تلاش کرنے کے لئے ڈھال لیا جاسکتا ہے۔ گیکسفورجیکس کی ویب سائٹ \"تاروں کی صف میں سب سے طویل عام مشترکہ تقسیم\" کا حل فراہم کرتی ہے۔مسئلہ ، جو طویل عرصے سے عام لاحقہ تلاش کرنے کے ل ad ڈھال لیا جاسکتا ہے۔ یہاں ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے نفاذ: ٹائپ اسکرپٹ فکشن لاجسٹ کاممنسفکس (ایس ٹی آر ایس: سٹرنگ []): سٹرنگ {اگر (str.length === 0) {واپسی \"\" ؛let مختصر ترین = strs [0] ؛کے لئے (i = 1 ؛ i <str.length ؛ i ++) {اگر (strs [i]. لمبائی <مختصر ترین. لمبائی) {مختصر ترین = strs [i] ؛}} آئیے نتیجہ = \"\" ؛کے لئے (i = مختصر ترین. لمبائی-1 ؛ i> = 0 ؛ i--) {const لاحقہ = مختصر ترین. slice (i) ؛آئیے issuffix = سچ ؛کے لئے (j = 0 ؛ j <strs.length ؛ j ++) {اگر (! strs [j] .edswith (لاحقہ)) {isuffix = غلط ؛بریک ؛}} if (issuffix) {نتیجہ = لاحقہ + نتیجہ ؛} دوسری {بریک ؛}} واپسی کا نتیجہ ؛} اس مثال میں ، ہم ایک طویل عرصے سے کامنسفکس فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر ڈور اسٹرس کی ایک صف لیتا ہے اور تار کے درمیان سب سے طویل عام لاحقہ لوٹاتا ہے۔فنکشن کو پہلے صف میں سب سے کم تار مل جاتا ہے۔اس کے بعد یہ اختتام سے شروع تک مختصر ترین تار کے کرداروں پر تکرار کرتا ہے ، یہ چیک کرتے ہیں کہ آیا ہر کردار صف میں موجود تمام تار کا لاحقہ ہے یا نہیں۔اگر کردار تمام ڈوروں کا لاحقہ ہے تو ، اس کو نتیجہ کے تار میں شامل کیا جاتا ہے۔اگر نہیں تو ، لوپ ٹوٹ جاتا ہے اور فنکشن نتیجہ کی تار لوٹاتا ہے۔ یہاں طویل عرصے سے کامنسفکس فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ ایس ٹی آر ایس = [\"پھول\" ، \"فلو\" ، \"فلائٹ\"] ؛ کنسٹ لاحقہ = طویل ترین کام (ایس ٹی آر) ؛ کنسول.log (لاحقہ) ؛// \"OW\" اس مثال میں ، ہم تار کی ایک صف تیار کرتے ہیں اور طویل عرصے سے کام کا استعمال کرتے ہوئے تاروں میں سب سے طویل عام لاحقہ تلاش کرتے ہیں ، جس کا نتیجہ کنسول میں لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بی*ٹری ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "بی*ٹری ایک خود متوازن درختوں کا ڈیٹا ڈھانچہ ہے جو بی ٹری سے ملتا جلتا ہے لیکن کچھ اضافی خصوصیات کے ساتھ۔یہ عام طور پر ڈیٹا بیس اور فائل سسٹم میں استعمال ہوتا ہے تاکہ بڑی مقدار میں ڈیٹا کو موثر انداز میں اسٹور کیا جاسکے۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں B*ٹری کو نافذ کرنے کی مثالیں فراہم کرتے ہیں: آن لائن دستیاب ٹائپ اسکرپٹ میں B*ٹری کے نفاذ کی کوئی براہ راست مثالیں نہیں ہیں۔تاہم ، کچھ وسائل موجود ہیں جو ٹائپ اسکرپٹ میں درختوں کے دیگر اعداد و شمار کے ڈھانچے کو نافذ کرنے کی مثالیں فراہم کرتے ہیں ، جیسے بائنری سرچ ٹری (بی ایس ٹی) اور ٹریپ۔ ٹائپ اسکرپٹ میں ڈیٹا ڈھانچے - بائنری سرچ ٹری آرٹیکل بذریعہ ریکارڈو بورجز بائنری سرچ ٹری کی ٹائپ اسکرپٹ پر عمل درآمد فراہم کرتا ہے۔، جو بی*-ٹری کو نافذ کرنے کے لئے ایک نقطہ آغاز کے طور پر استعمال کیا جاسکتا ہے۔ ٹیکنیکل فیڈر کے ذریعہ ٹائپ اسکرپٹ آرٹیکل میں ٹریپ ڈیٹا ڈھانچہ کو نافذ کرنا ٹریپ کا ٹائپ اسکرپٹ کا نفاذ فراہم کرتا ہے ، جو ایک خود توازن بائنری سرچ ٹری ہے جسے شروع کرنے کے طور پر استعمال کیا جاسکتا ہے۔بی*-ٹری کو نافذ کرنے کے لئے پوائنٹ۔لیفٹ نوڈ: نوڈ |خالی؛رائٹ نوڈ: نوڈ |خالی؛کنسٹرکٹر (ڈیٹا: نمبر) {this.data = ڈیٹا ؛this.leftnode = null ؛this.rightnode = null ؛}} کلاس بائنری سرچ ٹری {جڑ: نوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (ڈیٹا: نمبر): نوڈ {// خالی درخت ، پہلا نوڈ (روٹ نوڈ) داخل کریں اگر (! this.root) {this.root = نیا نوڈ (ڈیٹا) ؛اس کو واپس کریں۔} // جڑ نوڈ سے شروع کریں موجودہ = this.root ؛جبکہ (سچ ہے) {اگر (ڈیٹا> کرنٹ.ڈیٹا) {// دائیں سب ٹری میں خالی پوزیشن کے لئے تلاش کریں اگر (موجودہ۔ رائٹ نوڈ) {موجودہ = موجودہ۔ رائٹ نوڈ ؛} دوسری {// داخل کریں نوڈ کرنٹ۔ رائٹ نوڈ = نیا نوڈ (ڈیٹا) ؛موجودہ واپسی۔ رائٹ نوڈ ؛}} else {// بائیں subtree میں خالی پوزیشن کے لئے تلاش کریں اگر (موجودہ.leftnode) {موجودہ = کرنٹ.لفٹ نوڈ ؛} else {// داخل کریں نوڈ کرنٹ۔ لیفٹ نوڈ = نیا نوڈ (ڈیٹا) ؛موجودہ۔ لیفٹ نوڈ ؛}}}} تلاش (ڈیٹا: نمبر): نوڈ |null {// خالی درخت اگر (! this.root) {واپس NULL ؛} // روٹ نوڈ سے شروع کریں موجودہ = this.root ؛جبکہ (موجودہ ڈاٹ ڈیٹا! == ڈیٹا) {اگر (ڈیٹا> کرنٹ.ڈیٹا) {// موجودہ عنصر سے زیادہ ڈیٹا اگر (! موجودہ۔ رائٹ نوڈ) {// آپ کسی پتے کے نوڈ پر موجود ہیں تو ، کہیں بھی واپس نہیں جانا ہے ؛} // دائیں سب ٹری موجودہ = موجودہ۔ رائٹ نوڈ پر جائیں۔} else {// موجودہ عنصر سے کم ڈیٹا اگر (! موجودہ.leftnode) {// آپ پتی نوڈ پر ہیں ، کہیں واپس نہیں جانا ہے۔} // بائیں subtree موجودہ = موجودہ. لیفٹ نوڈ پر جائیں ؛}} موجودہ واپسی ؛} پری آرڈر ٹراورسال (نوڈ: نوڈ): باطل {اگر (نوڈ) {کنسول.لاگ (نوڈ ڈاٹ ڈیٹا) ؛this.preordertraversal (node.leftnode) ؛this.preordertraversal (node.rightnode) ؛}}} اس مثال میں ، ہم ایک نوڈ کلاس کی وضاحت کرتے ہیں جو بائنری سرچ ٹری میں نوڈ کی نمائندگی کرتا ہے ، اور بائنری سرچ ٹری کلاس جو بائنری سرچ ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس عمل میں داخل ، تلاش ، اور پری آرڈر ٹریورسل جیسے طریقے شامل ہیں جو بالترتیب درخت کو داخل کرنے ، تلاش کرنے اور ان کو عبور کرنے کی اجازت دیتے ہیں۔ یہاں بائنری سرچ ٹری کلاس کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کونسٹ بی ایس ٹی = نیا بائنری سرچ ٹری () BST.INSERT (5) ؛bst.insert (3) ؛ bst.insert (7) ؛ bst.insert (1) ؛ bst.insert (4) ؛ bst.insert (6) ؛ bst.insert (8) ؛ کانسٹ نوڈ = bst.search (4) ؛ کنسول.لاگ (نوڈ؟. ڈیٹا) ؛// 4bst.preordertraversal (bst.root) ؛// 5 3 1 4 7 6 8in اس مثال کے طور پر ، ہم ایک بائنری سرچ ٹری آبجیکٹ تیار کرتے ہیں اور داخل کرنے کا طریقہ استعمال کرکے درخت میں کچھ نوڈس داخل کرتے ہیں۔اس کے بعد ہم تلاش کے طریقہ کار کا استعمال کرتے ہوئے ڈیٹا 4 کے ساتھ نوڈ تلاش کرتے ہیں اور اس کے ڈیٹا کو کنسول میں لاگ ان کرتے ہیں۔آخر میں ، ہم پری آرڈر ٹراورسل طریقہ کا استعمال کرتے ہوئے پری آرڈر میں درخت کو عبور کرتے ہیں اور ہر نوڈ کے ڈیٹا کو کنسول میں لاگ ان کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر جانسن کا مختصر ترین راستہ الگورتھم انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "ٹائپ اسکرپٹ میں اسکیپ کواڈ لسٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "بدقسمتی سے ، مجھے ٹائپ اسکرپٹ میں اسکیپ کواڈ لسٹ ڈیٹا ڈھانچے کو نافذ کرنے کے لئے کوئی متعلقہ تلاش کے نتائج نہیں مل سکے۔تاہم ، میں اسکیپ کواڈ لسٹ کیا ہے اور یہ کس طرح کام کرتا ہے اس کا ایک جائزہ فراہم کرسکتا ہوں۔ ایک اسکیپ کواڈ لسٹ ایک ڈیٹا ڈھانچہ ہے جو اسکیپ لسٹ کی طرح ہے ، لیکن منسلک فہرستوں کو استعمال کرنے کے بجائے ، اس میں اعداد و شمار کو ذخیرہ کرنے اور بازیافت کرنے کے لئے کواڈٹریس کا استعمال کیا گیا ہے۔ایک کواڈٹری ایک درخت کے اعداد و شمار کا ڈھانچہ ہے جس میں ہر داخلی نوڈ کے بالکل چار بچے ہوتے ہیں ، جو کوآرڈینیٹ سسٹم کے چار کواڈرینٹ کے مطابق ہوتے ہیں۔ہر پتی نوڈ طیارے کے ایک چھوٹے سے مربع خطے کی نمائندگی کرتا ہے ، اور جڑ نوڈ پورے طیارے کی نمائندگی کرتا ہے۔اسکیپ کواڈ لسٹ کواڈٹری نوڈس کا ایک مجموعہ ہے جو ایک فہرست بنانے کے لئے ایک دوسرے کے ساتھ منسلک ہوتا ہے۔ اسکیپ کواڈ لسٹ ڈیٹا کو ذخیرہ کرنے اور بازیافت کرنے کے لئے استعمال ہوتی ہے جو دو جہتی جگہ میں پوائنٹس سے وابستہ ہے۔ہر نقطہ کواڈٹری کے ایک پتی نوڈ میں محفوظ کیا جاتا ہے ، اور کواڈٹری کو مؤثر طریقے سے ان نکات کی تلاش کے لئے استعمال کیا جاتا ہے جو کسی دیئے گئے نقطہ کے قریب ہیں۔اسکیپ کواڈ لسٹ کا استعمال کواڈٹری کے بڑے خطوں کو چھوڑ کر اس تلاش کو تیز کرنے کے لئے استعمال کیا جاتا ہے جس کا امکان نہیں ہے کہ کسی بھی پوائنٹس پر مشتمل ہو۔نوڈس اور اسکیپ کواڈ لسٹ نوڈس ، اور کواڈٹری میں پوائنٹس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقے نافذ کریں۔اسکیپ کواڈ لسٹ بنانے کے ل You آپ کو کواڈٹری نوڈس کو ایک ساتھ جوڑنے کے طریقوں کو نافذ کرنے کی بھی ضرورت ہوگی ، اور اسکیپ کواڈ لسٹ کو عبور کرنے کے ل that جو ایک دیئے گئے نقطہ کے قریب ہیں۔ جب میں اسکیپ کواڈ لسٹ میں اسکیپ کواڈ لسٹ کا ایک مخصوص عمل درآمد نہیں کرسکتا تھا۔ٹائپ اسکرپٹ ، میں امید کرتا ہوں کہ اسکیپ کواڈ لسٹ کیا ہے اور یہ کس طرح کام کرتا ہے اس کا جائزہ مددگار ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عددی عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عددی عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ کا استعمال زیادہ سے زیادہ رقم کو ٹریک رکھنے کے لئے استعمال کرسکتے ہیں جو صف میں ہر عنصر کو شامل کرکے یا خارج کرکے حاصل کیا جاسکتا ہے۔یہاں کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: کوڈ ریویو اسٹیک ایکسچینج ویب سائٹ \"غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم\" کے مسئلے کا حل فراہم کرتی ہے ، جسے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔ گیکسفورجیکس ویب سائٹ اس کا حل فراہم کرتی ہے۔\"زیادہ سے زیادہ رقم اس طرح کہ کوئی دو عناصر ملحقہ نہیں ہیں\" مسئلہ ، جسے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔ اسٹیک اوور فلو ویب سائٹ \"ایک صف کے غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم\" کے مسئلے کا حل فراہم کرتی ہے ، جسے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔.یہ ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ فکشن میکسومنوناڈجینٹ (اے آر آر: نمبر []): نمبر {اگر (arr.length === 0) {واپس 0 ؛} const n = arr.length ؛کانسٹ ڈی پی = نئی سرنی (این). فل (0) ؛dp [0] = arr [0] ؛ڈی پی [1] = میتھ.میکس (آر آر [0] ، آر آر [1]) ؛کے لئے (آئیے i = 2 ؛ i <n ؛ i ++) {dp [i] = math.max (dp [i - 1] ، dp [i - 2]+arr [i]) ؛d ڈی پی کو واپس کریں [این - 1] ؛} اس مثال میں ، ہم ایک میکسومنوناڈجینٹ فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عددی ارا کی ایک صف لیتا ہے اور صف میں غیر ملکی عناصر کی زیادہ سے زیادہ رقم واپس کرتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا سرنی خالی ہے اور 0 لوٹتی ہے اگر یہ ہے۔اس کے بعد یہ ان پٹ سرنی کے پہلے دو عناصر کے ساتھ متحرک پروگرامنگ سرنی ڈی پی کی ابتدا کرتا ہے۔اس کے بعد ان پٹ سرنی کے باقی عناصر پر تکرار کرتا ہے ، زیادہ سے زیادہ رقم کا حساب لگاتا ہے جو صف میں ہر عنصر کو شامل کرنے یا خارج کرکے حاصل کیا جاسکتا ہے۔فنکشن ڈی پی سرنی کے آخری عنصر کو لوٹاتا ہے ، جو ان پٹ سرنی میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم کی نمائندگی کرتا ہے۔ یہاں میکسومنونا ایڈجینٹ فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ آر آر = [2 ، 4 ، 6 ، 2 ، 5] ؛کانسٹ میکسم = میکسومنوناڈجینٹ (اے آر آر) ؛ کنسول.لاگ (میکسم) ؛// 13 میں اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور میکسومنونا ایڈجینٹ فنکشن کا استعمال کرتے ہوئے صف میں غیر ملکی عناصر کی زیادہ سے زیادہ رقم تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں اسکیو ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹ میں اسکیو ہیپ ڈیٹا ڈھانچہ ایک ہیپ ڈیٹا ڈھانچہ ہے جسے بائنری ٹری کے طور پر نافذ کیا جاتا ہے۔یہ بائنری ڈھیر کی طرح ہے ، لیکن اس میں کوئی ساختی رکاوٹیں نہیں ہیں ، لہذا اس بات کی کوئی گارنٹی نہیں ہے کہ درخت کی اونچائی لوگرتھمک ہے۔بائنری ہیپس سے زیادہ تیزی سے ضم ہونے کی صلاحیت کی وجہ سے اسکیو ڈھیر فائدہ مند ہیں۔اسکیو کے ڈھیروں میں مرکزی آپریشن انضمام ہے ، اور دیگر آپریشنز جیسے داخل ، ایکسٹریکٹ مین () ، وغیرہ کو صرف انضمام کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ یہاں کچھ ایسے وسائل ہیں جو ٹائپ اسکرپٹ میں سکیو کے ڈھیر کو نافذ کرنے کی مثالیں فراہم کرتے ہیں: یو ایم بی سی کی ویب سائٹ ایک پروجیکٹ فراہم کرتی ہے کہ وہ ایک پروجیکٹ فراہم کرتا ہے۔ٹائپ اسکرپٹ میں اسکو ہیپ ، ایک اعلی درجے کے ڈھیر ڈیٹا ڈھانچے کے نفاذ کی ضرورت ہے۔اس منصوبے کا مقصد بائنری درختوں کی تعمیر اور استعمال کرنے اور فنکشن پوائنٹرز اور تکرار کا استعمال سیکھنا سیکھنا ہے۔ گیکسفورجیکس ویب سائٹ اسکیو ہیپ اور ٹائپ اسکرپٹ میں اس کے نفاذ کی تفصیلی وضاحت فراہم کرتی ہے۔اعداد و شمار کے ڈھانچے ، بشمول اسکو ہیپ۔ ہر ایک مثال کے طور پر ٹائپ اسکرپٹ میں اسکیو ہیپ پر عمل درآمد: ٹائپ اسکرپٹ کلاس اسکی وہپ نوڈ {قدر: نمبر ؛بائیں: سکی وہپ نوڈ |خالی؛دائیں: سکی وہپ نوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛} انضمام (دیگر: سکی وہپ نوڈ | null): skewheapnode {اگر (! دوسرے) {اس کو واپس کریں ؛} if (this.value> دیگر.اولیو) {[this.left ، this.right] = [this.right ، this.left] ؛} this.right = this.right؟ .merge (دوسرے) ||دوسرے ؛[this.left ، this.right] = [this.right ، this.left] ؛اس کو واپس کریں ؛}} کلاس سکی وہپ {جڑ: skewheapnode |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (ویلیو: نمبر): باطل {کونسٹ نوڈ = نیا سکی وہپ نوڈ (قدر) ؛this.root = this.root؟ .merge (نوڈ) ||نوڈ ؛} ایکسٹریکٹ مین (): نمبر |null {if (! this.root) {واپس NULL ؛} const value = this.root.value ؛this.root = this.root.left؟ .merge (this.root.right) ||خالی؛واپسی کی قیمت ؛}} اس مثال میں ، ہم ایک اسکی وہپ نوڈ کلاس کی وضاحت کرتے ہیں جو اسکو کے ڈھیر میں نوڈ کی نمائندگی کرتا ہے ، اور اسکی وہپ کلاس جو اسکیو ہیپ کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے۔اس پر عمل درآمد میں انضمام ، داخل کرنے اور ایکسٹریکٹ مین جیسے طریقے شامل ہیں جو بالترتیب ڈھیر سے کم سے کم عنصر کو ضم کرنے ، داخل کرنے اور نکالنے کی اجازت دیتے ہیں۔ اسکی وہپ طبقے کا ایک مثال استعمال: ٹائپ اسکرپٹکنسٹ ہیپ = نیا سکی وہپ () Hep.insert hap.insert ہے۔)hap.extractmin ()) ؛// 1console.log (ہیپ.ایکسٹرک مین ()) ؛// 3console.log (ہیپ.ایکسٹرک مین ()) ؛// 4in اس مثال کے طور پر ، ہم اسکی وہپ آبجیکٹ تیار کرتے ہیں اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ڈھیر میں کچھ نوڈس داخل کرتے ہیں۔اس کے بعد ہم ایکسٹریکٹ مین کے طریقہ کار کا استعمال کرتے ہوئے ڈھیر سے کم سے کم عنصر نکالتے ہیں اور کنسول میں قدر لاگ ان کرتے ہیں۔ہم اس عمل کو مزید دو بار دہراتے ہیں ، کم سے کم اقدار کو کنسول پر لاگ ان کریں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل بٹونک سبری کی لمبائی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجروں کی ایک صف میں سب سے طویل بٹونک سبری کی لمبائی تلاش کرنا ایک دیئے گئے تسلسل کا سب سے ذیلی حصے تلاش کرنا ہے جس میں سبری کے عناصر کو پہلے بڑھتے ہوئے ترتیب میں ترتیب دیا جاتا ہے ، پھر کم ہوتے ہوئے ترتیب میں ، اور سبیرے اس طرح ہے۔جہاں تک ممکن ہو۔سختی سے چڑھنے یا اترتے ہوئے سبریوں کو بھی قبول کیا جاتا ہے۔دوسرے لفظوں میں ، ہمیں سب سے طویل عرصہ میں جو سب سے پہلے بڑھتا ہے اور پھر کم ہوتا ہے اس کی لمبائی تلاش کرنے کی ضرورت ہے۔ یہاں کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: ٹیکی لذت ویب سائٹ سب سے طویل بٹونک سبری کے مسئلے کی تفصیلی وضاحت فراہم کرتی ہے اورٹائپ اسکرپٹ میں اس کا نفاذ۔ گیکسفورجیکس ویب سائٹ \"زیادہ سے زیادہ لمبائی بٹونک سبریے\" کے مسئلے کا حل فراہم کرتی ہے ، جسے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔ لیٹ کوڈ ویب سائٹ اس بات پر بحث فراہم کرتی ہے کہ کس طرح ایک صف میں سب سے بڑے بٹونک سبری کو تلاش کیا جاسکتا ہے ، جس کو اپنایا جاسکتا ہے۔ٹائپ اسکرپٹ کے لئے۔ ٹائپ اسکرپٹ میں اس نقطہ نظر کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ فنکشن طویل ترین بیبٹونکسوبری (اے آر آر: نمبر []): نمبر {const n = arr.length ؛کانسٹ انک = نئی سرنی (این). فل (1) ؛Const dec = نئی سرنی (n). فل (1) ؛کے لئے (آئیے i = 1 ؛ i <n ؛ i ++) {if (arr [i]> arr [i - 1]) {inc [i] = inc [i - 1]+1 ؛}} کے لئے (آئیے i = n-2 ؛ i> = 0 ؛ i--) {if (arr [i]> arr [i + 1]) {دسمبر [i] = دسمبر [i + 1] + 1 ؛}} آئیے زیادہ سے زیادہ = 0 ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {if (inc [i] + دسمبر [i] - 1> زیادہ سے زیادہ) {زیادہ سے زیادہ = inc [i] + دسمبر [i] - 1 ؛}} میکس ریٹرن میکس ؛} اس مثال کے طور پر ، ہم ایک طویل عرصے سے ایک طویل ترین فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر انٹیجر آر آر کی ایک صف لیتا ہے اور صف میں لمبے لمبے بٹونک سبری کی لمبائی کو واپس کرتا ہے۔فنکشن سب سے پہلے ہر عنصر کی قیمت 1 کی قیمت 1 کے ساتھ دو صفوں کی شروعات کرتا ہے۔اس کے بعد یہ ان پٹ سرنی کے عناصر پر تکرار کرتا ہے ، اور ہر عنصر پر ختم ہونے والے سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی کے ساتھ انک سرنی کو اپ ڈیٹ کرتا ہے۔اس کے بعد ان پٹ سرنی کے عناصر کو الٹ ترتیب میں تکرار کرتا ہے ، اور ہر عنصر سے شروع ہونے والے سب سے طویل عرصے تک کم ہونے والے سبری کی لمبائی کے ساتھ ڈی ای سی کی صف کو اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن ان پٹ سرنی کے عناصر پر تکرار کرتا ہے ، جس میں ہر ایک عنصر کو شامل کرنے والے لمبے لمبے بٹونک سبری کی لمبائی کا حساب لگایا جاتا ہے ، اور زیادہ سے زیادہ لمبائی لوٹاتا ہے۔ یہاں طویل عرصے سے چلنے والی تقریب کا ایک مثال ہے: ٹائپ اسکرپٹکونسٹ آر = [4 ، 5 ، 9، 5 ، 6 ، 10 ، 11 ، 9 ، 6 ، 4 ، 5] const کانسٹنٹ لمیٹڈسوبری = طویل ترین بوٹنکسبرے (اے آر آر) ؛ کنسول.لوگ (سب سے طویل ترین) ؛// 7 اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور طویل عرصے سے بٹونک سبری کی لمبائی تلاش کرتے ہیں جس کا استعمال کرتے ہوئے طویل عرصے سے بٹونکس بورے فنکشن کا استعمال کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں کارٹیسین درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹا کارٹیسین ٹری میں کارٹیسین ٹری ڈیٹا ڈھانچہ ایک بائنری درخت کے اعداد و شمار کا ڈھانچہ ہے جو عناصر کی دی گئی صف سے تعمیر کیا جاسکتا ہے۔کارٹیسین کے درخت میں درج ذیل خصوصیات ہیں: درخت کی جڑ عنصر ہے جس کی صف میں زیادہ سے زیادہ قیمت ہوتی ہے۔ جڑ کا بائیں سب ٹری زیادہ سے زیادہ عنصر کے بائیں طرف عناصر کا کارٹیسین درخت ہے۔جڑ زیادہ سے زیادہ عنصر کے دائیں طرف عناصر کا کارٹیسین درخت ہے۔ یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں کارٹیسین ٹری کو کس طرح نافذ کرنے کی مثالیں فراہم کرتے ہیں: گیکسفورجیکس ویب سائٹ کارٹیسین درخت اور ٹائپ اسکرپٹ میں اس کے نفاذ کی تفصیلی وضاحت فراہم کرتی ہے۔ویب سائٹ کارٹیسین درخت کی ایک تفصیلی وضاحت اور ٹائپ اسکرپٹ میں اس کے نفاذ کی تفصیلی وضاحت فراہم کرتی ہے۔ روہن پال کے ذریعہ گٹ ہب ریپوزٹری کارٹیسین درخت کی ایک ٹائپ اسکرپٹ پر عمل درآمد فراہم کرتا ہے۔ یہاں ٹائپ اسکرپٹ میں کارٹیسین درخت کی ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ کلاس کارٹیسین اسٹرینوڈ {قدر: نمبر ؛بائیں: کارٹیسینٹرینوڈ |خالی؛دائیں: کارٹیسینٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن بلڈ کارٹیسین ٹری (ARR: نمبر []): کارٹیسینٹرینوڈ |null {if (arr.length === 0) {واپس NULL ؛} کانسٹ میکس انڈیکس = arr.reduce ((میکس انڈیکس ، ویلیو ، انڈیکس) => (ویلیو> آر آر [میکس انڈیکس]؟ انڈیکس: میکس انڈیکس) ، 0) ؛کانسٹ نوڈ = نیا کارٹیسینٹرینوڈ (ARR [MAXINDEX]) ؛node.left = buildcartesiantree (arr.slice (0 ، میکس انڈیکس)) ؛node.right = buildcartesiantree (arr.slice (میکس انڈیکس + 1)) ؛واپسی نوڈ ؛} اس مثال کے طور پر ، ہم کارٹیسین اسٹرینوڈ کلاس کی وضاحت کرتے ہیں جو کارٹیسین کے درخت میں نوڈ کی نمائندگی کرتا ہے ، اور ایک بلڈ کارٹیسین ٹری فنکشن جو ایک دلیل کے طور پر عددی ارا کی ایک صف لیتا ہے اور کارٹیسین درخت کی جڑ نوڈ کو لوٹاتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا سرنی خالی ہے اور اگر یہ ہے تو واپس آجاتا ہے۔اس کے بعد یہ صف میں زیادہ سے زیادہ عنصر کا اشاریہ تلاش کرتا ہے اور اس قدر کے ساتھ ایک نیا کارٹیسینٹرینوڈ آبجیکٹ تیار کرتا ہے۔اس کے بعد یہ بالترتیب زیادہ سے زیادہ عنصر کے بائیں اور دائیں طرف عناصر کا استعمال کرتے ہوئے جڑ کے نوڈ کے بائیں اور دائیں ذیلی ذیلی حصے کو بار بار بناتا ہے۔ یہاں بلڈ کارٹیسین ٹری فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹکونسٹ آر آر = [5 ، 10 ، 40 ، 30 ، 28] ؛ const روٹ = بلڈ کارٹیسین ٹری (اے آر آر) ؛ کنسول.لوگ (جڑ.اولیو) ؛// 40console.log (جڑ.لفٹ؟ .value) ؛// 10console.log (روٹ. رائٹ؟ .value) ؛// 30console.log (root.hright؟ .left؟ .value) ؛// 28console.log (جڑ.لفٹ؟. لیفٹ؟. ویلیو) ؛// 5 اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور بلڈ کارٹیسین ٹری فنکشن کا استعمال کرتے ہوئے سرے سے کارٹیسین کا درخت بناتے ہیں۔اس کے بعد ہم روٹ نوڈ اور اس کے بچوں کی اقدار کو کنسول میں لاگ ان کریں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف میں دو نوڈس کے مابین ہر ممکن راہیں تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف (ڈی اے جی) میں دو نوڈس کے درمیان ہر ممکنہ راستے تلاش کرنے کے ل we ، ہم ماخذ نوڈ سے منزل نوڈ تک ہر ممکنہ راستوں کو تلاش کرنے کے لئے گہرائی سے پہلے تلاش (DFS) ٹراورسل کا استعمال کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس مسئلے کو حل کرنے کے طریقہ کی مثالیں فراہم کرتے ہیں: لیٹ کوڈ ویب سائٹ \"ماخذ سے تمام راستے کو نشانہ بنانے کے لئے تمام راستوں\" کے مسئلے کا حل فراہم کرتی ہے ، جسے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔اس مسئلے کے لئے نوڈ 0 سے نوڈ N - 1 تک ہر ممکنہ راستے تلاش کرنے کی ضرورت ہوتی ہے جس میں 0 سے N - 1 تک لیبل لگا ہوا ن نوڈس کے ایک ڈی اے جی میں ہوتا ہے۔ڈی ایف ایس ٹراورسال کا استعمال کرتے ہوئے منزل کا نوڈ۔ گیکسفورجیکس ویب سائٹ \"کسی دیئے گئے ماخذ سے تمام راستوں کو کسی منزل مقصود کے لئے پرنٹ کریں\" کے مسئلے کا حل فراہم کرتی ہے ، جسے ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔نمبر [] [] ، ایس آر سی: نمبر ، مقصود: نمبر): نمبر [] [] {کنٹ راہیں: نمبر [] [] [] = [] ؛کنسٹ ملاحظہ کریں: بولین [] = نئی سرنی (گراف.لنتھ). فل (غلط) ؛کانسٹ راہ: نمبر [] = [] ؛فنکشن ڈی ایف ایس (نوڈ: نمبر) {ملاحظہ کیا [نوڈ] = سچ ؛Path.push (نوڈ) ؛if (نوڈ === تقدیر) {paths.push ([... راستہ]) ؛} دوسری {کے لئے (گراف کے پڑوسی [نوڈ]) {اگر (! ملاحظہ کیا [پڑوسی]) {DFS (پڑوسی) ؛}}} ملاحظہ کیا [نوڈ] = غلط ؛path.pop () ؛} ڈی ایف ایس (ایس آر سی) ؛واپسی کے راستے ؛} اس مثال کے طور پر ، ہم ایک فائنڈال پاتھ فنکشن کی وضاحت کرتے ہیں جو ایک ڈی اے جی لیتا ہے جس میں ملحقہ میٹرکس گراف ، ایک ماخذ نوڈ ایس آر سی ، اور منزل مقصود نوڈ ڈسٹ کو دلائل کے طور پر پیش کیا جاتا ہے اور ایس آر سی سے ڈسٹ تک ہر ممکنہ راستوں کی ایک صف کو واپس کرتا ہے۔فنکشن سب سے پہلے راستوں کو ذخیرہ کرنے کے لئے خالی سرنی والے راستوں کی ابتدا کرتا ہے ، ایک بولین سرنی کا دورہ کیا گیا نوڈس کا ٹریک رکھنے کے لئے ، اور موجودہ راستے کو ذخیرہ کرنے کے لئے ایک راستہ سرنی کا راستہ۔اس کے بعد یہ ڈی ایف ایس فنکشن کی وضاحت کرتا ہے جو گراف پر ڈی ایف ایس ٹریورسل انجام دیتا ہے ، اور ہر ملاحظہ شدہ نوڈ کو راستے کی صف میں شامل کرتا ہے۔اگر منزل کا نوڈ پہنچ جاتا ہے تو ، موجودہ راستہ راستوں کی صف میں شامل کیا جاتا ہے۔بصورت دیگر ، فنکشن موجودہ نوڈ کے ہر ناگوار پڑوسی پر ڈی ایف ایس کو بار بار کال کرتا ہے۔آخر میں ، فنکشن دورے اور راستے کی صفوں کو دوبارہ ترتیب دیتا ہے اور راستے کو واپس کرتا ہے۔فائنڈال پاتھ (گراف ، 0 ، 3) ؛ کنسول.لاگ (راستے) ؛// [[0 ، 1 ، 3] ، [0 ، 2 ، 3]] اس مثال میں ، ہم ایک ڈیگ تیار کرتے ہیں جس کی نمائندگی ایک ملحقہ میٹرکس کے طور پر کی جاتی ہے اور نوڈ 0 سے نوڈ 3 تک نوڈ 0 تک ہر ممکن راستے تلاش کرتے ہیں ، جس میں فائنڈالپاتھ کے فنکشن کا استعمال کرتے ہوئے ، لاگ ان ہوتا ہے۔کنسول کا نتیجہ"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری انڈیکسڈ ٹری ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "بائنری انڈیکسڈ ٹری ڈیٹا ڈھانچہ ٹائپ اسکرپٹ کے بدلے میں ، مجھے ٹائپ اسکرپٹ میں بائنری انڈیکسڈ ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے لئے کوئی متعلقہ تلاش کے نتائج نہیں مل پائے۔تاہم ، میں اس بات کا جائزہ فراہم کرسکتا ہوں کہ بائنری انڈیکسڈ ٹری کیا ہے اور یہ کس طرح کام کرتی ہے۔ بائنری انڈیکسڈ ٹری ، جسے بائنری انڈیکسڈ ٹری یا فینوک درخت بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو موثر اپ ڈیٹس اور سابقہ سے متعلق معلومات کے سوالات کی اجازت دیتا ہے۔ایک صفیہ بائنری درخت کی مختلف حالت ہے جو عناصر کی مجموعی رقم کو ایک صف میں محفوظ کرتی ہے۔درخت کو صف میں ہر انڈیکس کی بائنری نمائندگی لے کر اور درخت کو عبور کرنے کے لئے استعمال کرکے تعمیر کیا گیا ہے۔درخت کا ہر نوڈ اشاریہ کی متعلقہ رینج میں عناصر کا مجموعہ رکھتا ہے۔ ٹائپ اسکرپٹ میں بائنری انڈیکسڈ ٹری کو نافذ کرنے کے ل you ، آپ کو درخت میں نوڈس کے لئے کلاسوں کی وضاحت کرنے کی ضرورت ہوگی اور پریفکس کو اپ ڈیٹ کرنے اور ان سے استفسار کرنے کے طریقوں کو نافذ کرنے کی ضرورت ہوگی۔صفآپ کو کسی صف سے درخت کی تعمیر اور درخت کو عبور کرنے کے لئے بھی طریقوں کو نافذ کرنے کی ضرورت ہوگی۔بائنری انڈیکسڈ ٹری ہے اور یہ کس طرح کام کرتی ہے وہ مددگار ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت والے گراف پر چو-لیو/ایڈمنڈس الگورتھم انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "چیو لیو/ایڈمنڈس الگورتھم کو ڈائریکٹ گراف پر ٹائپ اسکرپٹ کا استعمال کرتے ہوئے چو-لیو/ایڈمنڈس الگورتھم کا استعمال کرتے ہوئے ہدایت شدہ گراف کے کم سے کم پھیلے ہوئے درخت (ایم ایس ٹی) کو تلاش کرنے کے لئے ایک موثر الگورتھم ہے۔الگورتھم پہلے گراف کے مضبوطی سے منسلک اجزاء کو ڈھونڈ کر کام کرتا ہے ، پھر ہر جزو کو ایک ہی نوڈ میں معاہدہ کرتا ہے ، اور آخر کار اس کے نتیجے میں گراف کا MST ڈھونڈتا ہے۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت والے گراف پر چو-لیو/ایڈمنڈس الگورتھم کو انجام دینے کی مثال فراہم کرتے ہیں: اسٹیک اوور فلو ویب سائٹ ڈائریکٹ گرافس پر کم سے کم پھیلا ہوا درخت تلاش کرنے کے لئے چو-لیو/ایڈمنڈس الگورتھم کے نفاذ پر گفتگو کرتی ہے۔ازگر کا استعمال کرتے ہوئے۔اس بحث کو ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔ سی ایس ڈی این ویب سائٹ ہدایت کردہ کم سے کم پھیلنے والے درخت کو تلاش کرنے کے لئے چو-لیو/ایڈمنڈس الگورتھم کی تفصیلی وضاحت فراہم کرتی ہے۔ فیراسبوللا کے ذریعہ گیتھب ریپوزٹری CHU-LIU/ایڈمنڈس الگوریتھم کا ایک ازگر عمل درآمد فراہم کرتا ہے۔ہدایت والے وزن والے گراف میں کم سے کم پھیلا ہوا اربوسینس۔ یہاں ٹائپ اسکرپٹ میں چو-لیو/ایڈمنڈس الگورتھم کا ایک مثال عمل: ٹائپ اسکرپٹ انٹرفیس ایج {منجانب: نمبر ؛to: نمبر ؛وزن: نمبر ؛} فنکشن FindMinimumsspanningtree (کناروں: کنارے [] ، جڑ: نمبر): ایج [] {const n = کناروں کی لمبائی ؛CONT والدین: نمبر [] = نئی سرنی (n). فل (-1) ؛کانسٹ میکس ویٹ: نمبر [] = نئی سرنی (این) .فل (-انفینیٹی) ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {کے لئے (کناروں کا مقابلہ) {const u = ایج.فرم ؛کانسٹ v = ایج.ٹو ؛کانسٹ ڈبلیو = ایج۔ ویٹ ؛اگر (میکس ویٹ [u] + w> میکس ویٹ [v]) {میکس ویٹ [v] = میکس ویٹ [u] + w ؛والدین [v] = u ؛const}} const درخت: کنارے [] = [] ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اگر (i === روٹ) {جاری رکھیں ؛} ٹری.پش ({منجانب: والدین [i] ، to: i ، وزن: ایجز.فائنڈ ((ایج) => ایج.فرم === والدین [i] && ایج.ٹو === i)؟ وزن؟|| 0}) ؛} واپسی کا درخت ؛} اس مثال میں ، ہم ایک فائنم لیمینومننگ ٹری فنکشن کی وضاحت کرتے ہیں جو کناروں کے کناروں کی ایک صف اور جڑ نوڈ کی جڑ کو دلائل کے طور پر لیتا ہے اور کناروں کی ایک صف کو واپس کرتا ہے جو گراف کے کم سے کم پھیلے ہوئے درخت کی تشکیل کرتا ہے۔اس فنکشن میں پہلے درخت میں ہر نوڈ کے والدین نوڈ اور زیادہ سے زیادہ وزن پر نظر رکھنے کے لئے دو صفوں کے والدین اور میکس ویٹ کا آغاز ہوتا ہے۔اس کے بعد یہ گراف کے کناروں پر تکرار کرتا ہے ، جو جڑ نوڈ سے ہر نوڈ تک زیادہ سے زیادہ وزن کے راستے پر مبنی والدین اور میکس ویٹ صفوں کو اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن گراف کے نوڈس پر تکرار کرکے اور درختوں کی صف میں اسی کناروں کو شامل کرکے کم سے کم پھیلا ہوا درخت بناتا ہے۔: 1 ، وزن: 4} ، {: 0 ، سے: 2 ، وزن: 3} ، {: 1 ، سے: 2 ، وزن: 1} ، {سے: 1 ، سے: 3 ، وزن: 2} ،{سے: 2 ، سے: 3 ، وزن: 5} ، {: 2 ، سے: 4 ، وزن: 4} ، {: 3 ، سے: 4 ، وزن: 1} ،] ؛ const mst = findMinimumsspanningtre (کنارے، 0) ؛ کنسول.لوگ (ایم ایس ٹی) ؛// [{سے: 0 ، سے: 1 ، وزن: 4} ، {: 1 ، سے: 2 ، وزن: 1} ، {سے: 1 ، سے: 3 ، وزن: 2} ، {منجانب: 3 ،to: 4 ، وزن: 1}] اس مثال میں ، ہم ہدایت نامہ کی نمائندگی کرنے والے کناروں کی ایک صف تیار کرتے ہیں اور فائنڈ مینیومس اسپیننگ ٹری فنکشن کا استعمال کرتے ہوئے گراف کا کم سے کم پھیلنے والا درخت تلاش کرتے ہیں ، جس کا نتیجہ کنسول میں لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں فیوژن ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "بدقسمتی سے ، مجھے ٹائپ اسکرپٹ میں فیوژن ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے لئے تلاش کے متعلق کوئی متعلقہ نتائج نہیں مل سکے۔تاہم ، میں فیوژن ٹری کیا ہے اور یہ کس طرح کام کرتا ہے اس کا ایک جائزہ فراہم کرسکتا ہوں۔ ایک فیوژن ٹری ایک درخت کا ڈیٹا ڈھانچہ ہے جو ایک ترتیب شدہ صف میں موثر تلاش اور عناصر کی داخلہ کی اجازت دیتا ہے۔یہ بائنری سرچ ٹری کی مختلف حالت ہے جو سرنی کے عناصر کو درجہ بندی کے ڈھانچے میں محفوظ کرتی ہے۔درخت کو بار بار سرنی کو سبریوں میں تقسیم کرکے اور درخت کے ایک نوڈ میں ہر سبری کے درمیانی عنصر کو ذخیرہ کرکے تعمیر کیا گیا ہے۔درخت کا ہر نوڈ اپنے بائیں اور دائیں بچے کے نوڈس کی طرف ایک پوائنٹر رکھتا ہے ، جو بالترتیب میڈین عنصر کے بائیں اور دائیں طرف سبریوں کی نمائندگی کرتا ہے۔ ٹائپ اسکرپٹ میں فیوژن ٹری کو نافذ کرنے کے ل you ، آپ کو نوڈس کے لئے کلاسوں کی وضاحت کرنے کی ضرورت ہوگی۔درخت میں عناصر کی تلاش اور داخل کرنے کے لئے درخت اور اس پر عمل درآمد کرتے ہیں۔آپ کو ایک ترتیب شدہ صف سے درخت کی تعمیر اور عناصر کو تلاش کرنے اور داخل کرنے کے لئے درخت کو عناصر سے گزرنے کے طریقوں کو بھی نافذ کرنے کی ضرورت ہوگی۔ جب میں ٹائپ اسکرپٹ میں فیوژن ٹری کا مخصوص نفاذ فراہم نہیں کرسکتا ہوں ، مجھے امید ہے کہ اس جائزہ کا ایک جائزہہے اور یہ کس طرح کام کرتا ہے وہ مددگار ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں طبقہ کے درخت کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ میں طبقہ کے درخت کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصہ تک بڑھتی ہوئی کامیابی کا پتہ لگانا یہ ہے کہ کسی دیئے گئے تسلسل کے سب سے لمبے لمبے حصے کی لمبائی تلاش کرنا ہے کہ اس طرح کے تمام عناصر کو بڑھتے ہوئے ترتیب میں ترتیب دیا جاتا ہے۔یہاں کچھ وسائل ہیں جو ٹائپ اسکرپٹ میں طبقہ کے درخت کا استعمال کرتے ہوئے اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: کوڈفورسس ویب سائٹ ایل آئی ایس کے مسئلے سمیت متحرک پروگرامنگ کے مسائل کو حل کرنے کے لئے طبقہ کے درختوں کے استعمال پر ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل ایک سادہ $ O (n^2) $ متحرک پروگرامنگ حل اور ایک $ O (n \\ لاگ این) $ حل فراہم کرتا ہے۔طبقہ کا درخت۔ گیکسفورجیکس ویب سائٹ ایک طبقہ کے درخت کا استعمال کرتے ہوئے طویل ترین بڑھتی ہوئی تقویت کی لمبائی تلاش کرنے کے لئے ایک سبق فراہم کرتی ہے۔ٹیوٹوریل اس مسئلے کو حل کرنے کے ل four چار مختلف نقطہ نظر فراہم کرتا ہے ، جس میں ایک طبقہ کے درخت کا استعمال بھی شامل ہے۔، درخت: نمبر [] ، نوڈ: نمبر ، شروع: نمبر ، اختتام: نمبر): باطل {اگر (شروع ==== اختتام) {درخت [نوڈ] = آر آر [شروع] ؛} else {const Mid = math.floor ((شروع + اختتام) / 2) ؛بلڈسمنٹ ٹری (آر ، ، درخت ، 2 * نوڈ + 1 ، اسٹارٹ ، وسط) ؛بلڈسمنٹ ٹری (آر ، درخت ، 2 * نوڈ + 2 ، وسط + 1 ، اختتام) ؛درخت [نوڈ] = ریاضی۔ میکس (درخت [2 * نوڈ + 1] ، درخت [2 * نوڈ + 2]) ؛}} فنکشن کوئری سیگمنٹ ٹری (درخت: نمبر [] ، نوڈ: نمبر ، نمبر ، نمبر ، اختتام: نمبر ، بائیں: نمبر ، دائیں: نمبر): نمبر {اگر (بائیں> اختتام || دائیں <آغاز) {واپسی -انفینٹی ؛} if (بائیں <= start && دائیں> = اختتام) {واپسی کا درخت [نوڈ] ؛} const MID = math.floor ((start + end) / 2) ؛کانسٹ لیفٹ میکس = کوئری سیگمنٹ ٹری (درخت ، 2 * نوڈ + 1 ، اسٹارٹ ، وسط ، بائیں ، دائیں) ؛کونٹ رائٹ میکس = استفسارات ٹری (درخت ، 2 * نوڈ + 2 ، وسط + 1 ، اختتام ، بائیں ، دائیں) ؛واپس میتھ۔ میکس (بائیں میکس ، رائٹ میکس) ؛} فنکشن Findlongestincreasingsbsune (Arr: نمبر []): نمبر {const n = arr.length ؛کانسٹ ٹری: نمبر [] = نئی صف (4 * این)کانسٹ ڈی پی: نمبر [] = نئی سرنی (این). فل (1) ؛بلڈسمنٹ ٹری (ڈی پی ، درخت ، 0 ، 0 ، این - 1) ؛کے لئے (آئیے i = 1 ؛ i <n ؛ i ++) {const زیادہ سے زیادہ = استفسارات ٹری (درخت ، 0 ، 0 ، n - 1 ، 0 ، arr [i] - 1) ؛ڈی پی [i] = زیادہ سے زیادہ + 1 ؛بلڈسمنٹ ٹری (ڈی پی ، درخت ، 0 ، 0 ، این - 1) ؛} واپس میتھ ڈاٹ میکس (... ڈی پی) ؛} اس مثال کے طور پر ، ہم ایک بلڈسمنٹ ٹری فنکشن کی وضاحت کرتے ہیں جو عدد کے درخت کی نمائندگی کرنے والی ایک صف ، درخت کے نوڈ میں ایک نوڈ ، اور آغاز اور اختتام کی ایک صف لیتا ہے۔طبقہ کے اشارے دلائل کے طور پر شروع اور اختتام پذیر ہوتے ہیں اور طبقہ کے درخت کی تعمیر کرتے ہیں۔ہم ایک کوئری سیگمنٹ ٹری فنکشن کی بھی وضاحت کرتے ہیں جو بلڈسمنٹ ٹری کی طرح ہی دلائل لیتا ہے اور طبقہ میں زیادہ سے زیادہ قیمت لوٹاتا ہے۔آخر میں ، ہم ایک فائنڈ لانگسٹینکریزنگس بیوشن فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر عددی ARR کی ایک صف لیتا ہے اور صف میں طویل عرصے تک بڑھتے ہوئے بڑھتے ہوئے حصے کی لمبائی کو واپس کرتا ہے۔اس فنکشن میں سب سے پہلے طبقہ کے درخت کو ذخیرہ کرنے کے لئے دو صفوں کے درخت اور ڈی پی کی ابتدا ہوتی ہے اور بالترتیب ہر انڈیکس پر ختم ہونے والے طویل ترین بڑھتے ہوئے حصول کی لمبائی۔اس کے بعد موجودہ عنصر تک طبقہ کے درخت میں زیادہ سے زیادہ قیمت کا استعمال کرتے ہوئے ڈی پی سرنی کو اپ ڈیٹ کرتے ہوئے ، ان پٹ سرنی کے عناصر پر تکرار کرتا ہے۔آخر میں ، فنکشن ڈی پی سرنی میں زیادہ سے زیادہ قیمت لوٹاتا ہے۔ یہاں فائنڈ لانگسٹینکریزنگسوبسنس فنکشن کا ایک مثال استعمال ہے: ٹائپ اسکرپٹ کنسٹ آر آر = [10 ، 22 ، 9 ، 33 ، 21 ، 50 ، 41 ، 60] contint کانسٹیٹڈ سب سے طویل عرصے تک = تلاش کریں؛ کنسول.لوگ (سب سے طویل عرصہ تک) ؛// 5 اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور فائنڈ لانگسٹین کریزنگسوبسنس فنکشن کا استعمال کرتے ہوئے صف میں طویل عرصے تک بڑھتے ہوئے حصول کی لمبائی تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں مستقل طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹا مستقل طبقہ کے درخت میں مستقل طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کو نافذ کرنا ایک ڈیٹا ڈھانچہ ہے جو عناصر کی ترتیب کو موثر استفسار اور اپ ڈیٹ کرنے کی اجازت دیتا ہے۔یہ ایک طبقہ کے درخت کی مختلف حالت ہے جو درخت کے متعدد ورژن محفوظ کرتا ہے ، ہر ایک ترتیب کی مختلف حالت کی نمائندگی کرتا ہے۔درخت کو بار بار تسلسل کو ذیلی ترتیب میں تقسیم کرکے اور درخت کے نوڈ میں ہر ذیلی ترتیب کی مجموعی معلومات کو ذخیرہ کرکے تعمیر کیا گیا ہے۔درخت میں ہر نوڈ اپنے بائیں اور دائیں بچے کے نوڈس کی طرف اشارہ کرتا ہے ، جو موجودہ ذیلی ترتیب کے وسط نقطہ کے بائیں اور دائیں کے ذیلی ترتیب کی نمائندگی کرتا ہے۔ یہاں کچھ ایسے وسائل ہیں جو مستقل طور پر عمل درآمد کرنے کی مثالیں فراہم کرتے ہیں۔ٹائپ اسکرپٹ میں طبقہ کا درخت: گیکسفورجیکس ویب سائٹ مستقل طبقہ کے درختوں اور C ++ میں ان کے نفاذ کا تعارف فراہم کرتی ہے۔اس پر عمل درآمد کو ٹائپ اسکرپٹ کے مطابق ڈھال لیا جاسکتا ہے۔ اسکیلر ویب سائٹ مستقل طبقہ کے درختوں اور سی ++ میں ان کے نفاذ پر ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں ایک مثال کا مسئلہ اور اس کا حل مستقل طبقہ کے درخت کا استعمال کرتے ہوئے شامل ہے۔ یو ایس اے سی او گائیڈ کی ویب سائٹ مستقل طور پر طبقہ کے درختوں سمیت مستقل ڈیٹا ڈھانچے پر ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں مستقل طبقہ کے درخت کا استعمال کرتے ہوئے ایک مثال کا مسئلہ اور اس کا حل شامل ہے۔ یہاں ٹائپ اسکرپٹ میں مستقل طبقہ کے درخت کی ایک مثال عمل ہے: ٹائپ اسکرپٹ انٹرفیس نوڈ {رقم: نمبر ؛بائیں؟: نوڈ ؛ٹھیک ہے؟: نوڈ ؛} فنکشن بلڈ سیگمنٹ ٹری (آر آر: نمبر [] ، شروع: نمبر ، اختتام: نمبر): نوڈ {اگر (اسٹارٹ === اختتام) {واپسی {رقم: آر آر [آر اے آر [اسٹارٹ]} ؛} const MID = math.floor ((start + end) / 2) ؛کانسٹ بائیں = بلڈسمنٹ ٹری (آر آر ، اسٹارٹ ، وسط) ؛کونٹ رائٹ = بلڈسمنٹ ٹری (ار ، وسط + 1 ، اختتام) ؛واپسی {رقم: بائیں.سم + دائیں.ایم ، بائیں ، دائیں} ؛} فنکشن کوئری سیگمنٹ ٹری (نوڈ: نوڈ ، اسٹارٹ: نمبر ، اختتام: نمبر ، بائیں: نمبر ، دائیں: نمبر): نمبر {اگر (بائیں> اختتام || دائیں <شروع) {واپس 0 ؛} if (بائیں <= start && دائیں> = اختتام) {واپس نوڈ.سم ؛} const MID = math.floor ((start + end) / 2) ؛کانسٹ لیفٹسم = کوئری سیگمنٹ ٹری (نوڈ.لفٹ! ، شروع ، وسط ، بائیں ، دائیں) ؛کنسٹ رائٹسم = کوئری سیگمنٹ ٹری (نوڈ. رائٹ! ، وسط + 1 ، اختتام ، بائیں ، دائیں) ؛لوٹ لیفٹسم + رائٹسم ؛} فنکشن اپڈیٹیسمنٹ ٹری (نوڈ ، نوڈ ، اسٹارٹ: نمبر ، اختتام: نمبر ، انڈیکس: نمبر: قیمت: نمبر): نوڈ {اگر (اسٹارٹ === اختتام) {واپسی {رقم: ویلیو} ؛} const MID = math.floor ((start + end) / 2) ؛اگر (انڈیکس <= وسط) {کانسٹ بائیں = اپڈیٹیسمنٹ ٹری (نوڈ.لفٹ! ، شروع ، وسط ، انڈیکس ، ویلیو) ؛واپسی {رقم: بائیں.سم + نوڈ۔ رائٹ! .سم ، بائیں ، دائیں: نوڈ. رائٹ} ؛} else {const right = updateSememgttree (node.right! ، وسط + 1 ، اختتام ، انڈیکس ، ویلیو) ؛واپسی {رقم: نوڈ.لفٹ!}} فنکشن بلڈپرسسٹسمنٹ ٹری (ARR: نمبر []): نوڈ [] {const n = arr.length ؛کنسٹ جڑیں: نوڈ [] = [] ؛جڑیں [0] = بلڈ سیگمنٹ ٹری (ARR ، 0 ، N - 1) ؛کے لئے (i = 1 ؛ i <n ؛ i ++) {جڑیں [i] = اپڈیٹیسمنٹ ٹری (جڑیں [i - 1] ، 0 ، n - 1 ، i - 1 ، arr [i]) ؛returns روٹ روٹس ؛} اس مثال میں ، ہم ایک بلڈسمنٹ ٹری فنکشن کی وضاحت کرتے ہیں جو انٹیجرز آر اے آر کی ایک صف لیتا ہے ، طبقہ کے آغاز اور اختتام کے آغاز اور اختتامی اشارے ، اور طبقہ کے درخت کا نوڈ لوٹاتا ہے۔ہم ایک کوئری سیگمنٹ ٹری فنکشن کی بھی وضاحت کرتے ہیں جو طبقہ کے درخت نوڈ کا نوڈ ، طبقہ کے آغاز اور اختتام کے آغاز اور اختتامی اشارے ، اور استفسار کے بائیں اور دائیں اشارے بائیں اور دائیں لیتا ہے ، اور اس میں عناصر کا مجموعہ واپس کرتا ہے۔استفسار کی حد۔آخر میں ، ہم ایک اپڈیٹ ایسگمنٹ ٹری فنکشن کی وضاحت کرتے ہیں جو طبقہ کے درخت نوڈ کا نوڈ ، طبقہ کے آغاز اور اختتام کے آغاز اور اختتامی اشارے ، انڈیکس کو اپ ڈیٹ کرنے کے عنصر کا انڈیکس ، اور عنصر کی قیمت کی نئی قیمت لیتا ہے ، اور واپس کرتا ہے۔طبقہ کے درخت کا تازہ ترین نوڈ۔ ہم ایک بلڈپرسسٹیسمنٹ ٹری فنکشن کی بھی وضاحت کرتے ہیں جو ایک دلیل کے طور پر انٹیجرز کی ایک صف لیتا ہے اور مستقل طبقہ کے درخت کی نمائندگی کرنے والے نوڈس کی ایک صف کو واپس کرتا ہے۔فنکشن پہلے درخت کے ہر ورژن کی جڑوں کو ذخیرہ کرنے کے لئے ایک صف کی جڑیں شروع کرتا ہے۔اس کے بعد یہ بلڈسمنٹ ٹری فنکشن کا استعمال کرتے ہوئے درخت کا ابتدائی ورژن تیار کرتا ہے اور اپڈیٹ ایسگمنٹ ٹری فنکشن کا استعمال کرتے ہوئے درخت کے بعد کے ہر ورژن کو اپ ڈیٹ کرتا ہے۔کانسٹ روٹس = بلڈپرسسٹسمنٹ ٹری (آر آر) ؛ کنسول.لاگ (کوئری سیگمنٹ ٹری (جڑیں [0] ، 0 ، ارل لمبائی - 1 ، 0 ، 4)) ؛// 25console.log (کوئری سیگمنٹ ٹری (جڑیں [1] ، 0 ، ارل لمبائی - 1 ، 0 ، 3)) ؛// 16console.log (کوئری سیگمنٹ ٹری (جڑیں [2] ، 0 ، ارل لمبائی - 1 ، 1 ، 4)) ؛// اس مثال کے طور پر ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور بلڈپرسسٹیسمنٹ ٹری فنکشن کا استعمال کرتے ہوئے صف سے مستقل طبقہ کا درخت بناتے ہیں۔اس کے بعد ہم درخت کے مختلف ورژنوں کا استعمال کرتے ہوئے سرنی کی مختلف حدود میں عناصر کی رقم سے استفسار کرتے ہیں ، نتائج کو کنسول پر لاگ ان کرتے ہیں۔"
    },
    {
        "Question": "کرداروں کو دہرانے کے بغیر سب سے طویل عروج تلاش کرنے کے لئے جاوا اسکرپٹ فنکشن لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں کرداروں کو دہرانے کے بغیر سب سے طویل عروج تلاش کرنا ، کرداروں کو دہرانے کے بغیر سب سے طویل عروج تلاش کرنے کا مسئلہ کمپیوٹر سائنس میں ایک عام مسئلہ ہے۔یہاں کچھ وسائل ہیں جو جاوا اسکرپٹ میں اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: دیو. ٹو ویب سائٹ جاوا اسکرپٹ میں کرداروں کو دہرائے بغیر طویل عرصے تک سبسٹرنگ کی لمبائی تلاش کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل دو پوائنٹرز کا استعمال کرتے ہوئے ایک آسان حل فراہم کرتا ہے۔ الٹکیڈیمی کی ویب سائٹ جاوا اسکرپٹ میں کرداروں کو دہرائے بغیر بغیر طویل ترین سبسٹرنگ کو تلاش کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل ہیش میپ کا استعمال کرتے ہوئے ایک حل فراہم کرتا ہے۔ گیکسفورجیکس کی ویب سائٹ جاوا اسکرپٹ میں کرداروں کو دہرائے بغیر طویل عرصے تک سبسٹرنگ کی لمبائی کو کس طرح تلاش کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل دو حل فراہم کرتا ہے ، ایک وقت کی پیچیدگی O (n^3) اور دوسرا وقت کی پیچیدگی کے ساتھ O (n)بائیں = 0 ؛چلو دائیں = 0 ؛آئیے زیادہ سے زیادہ = 0 ؛کانس چارسیٹ = نیا سیٹ () ؛جبکہ (دائیں <s.length) {if (! charse.has (s [دائیں])) {چارسیٹ.اڈ (s [دائیں]) ؛حق ++ ؛زیادہ سے زیادہ = ریاضی۔ میکس (زیادہ سے زیادہ ، چارسیٹ۔ سائز) ؛} else {charset.delete (s [بائیں]) ؛بائیں ++ ؛}} واپسی زیادہ سے زیادہ ؛} اس مثال میں ، ہم ایک لمبائی کی لمبائی کے طور پر ایک لمبائی کی لمبائی کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر سٹرنگ لیتا ہے اور تار میں کرداروں کو دہرانے کے بغیر سب سے لمبے لمبے لمبائی کی لمبائی کو لوٹاتا ہے۔فنکشن سب سے پہلے تار کے آغاز کے لئے بائیں اور دائیں اور زیادہ سے زیادہ لمبائی سے زیادہ 0 تک دو پوائنٹرز کی ابتدا کرتا ہے۔ یہ حروف کو موجودہ اسٹرنگ میں ذخیرہ کرنے کے لئے ایک چارسیٹ بھی شروع کرتا ہے۔اس کے بعد فنکشن تار میں حروف کے اوپر تکرار کرتا ہے ، ہر کردار کو چارسیٹ میں شامل کرتا ہے اگر وہ پہلے سے ہی سیٹ میں نہیں ہے اور زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرتا ہے اگر سیٹ کا سائز موجودہ میکس سے زیادہ ہے۔اگر ایک دہرانے والا کردار مل جاتا ہے تو ، فنکشن چارسیٹ سے بائیں بازو کے کردار کو ہٹاتا ہے اور بائیں پوائنٹر میں اضافہ کرتا ہے۔آخر میں ، فنکشن زیادہ سے زیادہ لمبائی کو لوٹاتا ہے۔ یہاں لمبائی کی لمبائی کے استعمال کی ایک مثال کے استعمال کا استعمال: جاوا اسکرپٹ کونسٹ ایس = \"اے بی سی اے بی سی بی بی\" ؛ کانسٹنٹ طویل ترین ساسٹرنگ = لمبائی سے چلنے والی چیزوں کی لمبائی کی جگہ// 3 میں اس مثال کے طور پر ، ہم ایک تار تیار کرتے ہیں اور لمبائی میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبائی"
    },
    {
        "Question": "کسی ایسے فنکشن کو نافذ کریں جو عددیوں کی ایک صف کو قبول کرے اور ان دو نمبروں کو واپس کرے جو ایک مخصوص ہدف کی رقم میں اضافہ کرتے ہیں۔",
        "Answer": "جاوا اسکرپٹو میں ایک مخصوص ہدف کی رقم میں اضافہ کرنے والے دو نمبروں کی تلاش میں دو نمبر تلاش کریں جو عددی کی ایک مخصوص صف میں ایک مخصوص ہدف کی رقم میں اضافہ کرتے ہیں ، بہت سارے نقطہ نظر موجود ہیں جو لئے جاسکتے ہیں۔یہاں کچھ وسائل ہیں جو جاوا اسکرپٹ میں اس مسئلے کو حل کرنے کی مثالیں فراہم کرتے ہیں: W3Resource ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ ایک مخصوص صف سے عناصر کی جوڑی کو کیسے تلاش کیا جائے جس کی رقم جاوا اسکرپٹ میں ایک مخصوص ہدف نمبر کے برابر ہے۔ٹیوٹوریل ہیش میپ کا استعمال کرتے ہوئے ایک حل فراہم کرتا ہے۔ دیو ڈاٹ ویب سائٹ جاوا اسکرپٹ میں دو رقم کے مسئلے کو کیسے حل کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل دو حل مہیا کرتا ہے ، ایک نیسٹڈ لوپ کا استعمال کرتے ہوئے اور دوسرا ہیش میپ کا استعمال کرتے ہوئے۔ لیول اپ کوڈنگ ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ جاوا اسکرپٹ میں دو رقم کے مسئلے کو کیسے حل کیا جائے۔ٹیوٹوریل تین حل مہیا کرتا ہے ، ایک بروٹ فورس الگورتھم کا استعمال کرتے ہوئے ، دوسرا بائنری تلاش کا استعمال کرتے ہوئے ، اور تیسرا ہیش میپ کا استعمال کرتے ہوئے۔ ہیش نقشہ کا استعمال کرتے ہوئے جاوا اسکرپٹ میں ایک مخصوص ہدف کی رقم میں اضافہ کرنے والی دو نمبروں کی تلاش کی ایک مثال ہے۔جاوا اسکرپٹ فینکشن ٹووسم (نمبر ، ہدف) {کونٹ نقشہ = نیا نقشہ () ؛کے لئے (آئیے i = 0 ؛ i <nums.length ؛ i ++) {کانسٹ تکمیل = ہدف - نمبر [i] ؛if (map.has (تکمیل)) {واپسی [map.get (تکمیل) ، i] ؛} map.set (nums [i] ، i) ؛} واپسی [] ؛} اس مثال کے طور پر ، ہم ایک ٹووسم فنکشن کی وضاحت کرتے ہیں جو عددی نمبروں کی ایک صف اور ایک ہدف کے ہدف کو دلائل کے طور پر لیتا ہے اور دو عدد کی ایک صف کو واپس کرتا ہے جو ہدف کی رقم میں اضافہ کرتا ہے۔فنکشن سب سے پہلے سرے میں عدد کے اشاریوں کو ذخیرہ کرنے کے لئے ہیش کے نقشے کا نقشہ شروع کرتا ہے۔اس کے بعد سرے میں عدد کے بارے میں تکرار کرتا ہے ، ہدف کی رقم کے سلسلے میں موجودہ عدد کی تکمیل کا حساب لگاتا ہے اور جانچ پڑتال کرتا ہے کہ آیا اس کی تکمیل پہلے ہی ہیش کے نقشے میں ہے۔اگر تکمیل ہیش کے نقشے میں ہے تو ، فنکشن ان دو عدد کے اشارے لوٹاتا ہے جو ہدف کی رقم میں اضافہ کرتے ہیں۔اگر تکمیل ہیش کے نقشے میں نہیں ہے تو ، فنکشن موجودہ انٹیجر اور اس کے انڈیکس کو ہیش کے نقشے میں شامل کرتا ہے۔آخر میں ، فنکشن ایک خالی صف لوٹاتا ہے اگر سرے میں کوئی دو عدد ہدف کے مجموعی میں شامل نہیں ہوتا ہے۔ یہاں ٹووسم فنکشن کا ایک مثال استعمال ہے: جاوا اسکرپٹکونسٹ نمبر = [2 ، 7 ، 11 ، 15] ؛ کنسٹ ٹارگٹ = 9 ؛ کانسٹنٹنتیجہ = twosum (nums ، ہدف) ؛ کنسول.لاگ (نتیجہ) ؛// [0 ، 1] اس مثال میں ، ہم انٹیجرز کی ایک صف اور ایک ہدف کا مجموعہ بناتے ہیں اور صف میں دو عدد کے اشارے تلاش کرتے ہیں جو ٹوسم فنکشن کا استعمال کرتے ہوئے ہدف کی رقم میں اضافہ کرتے ہیں ، جس کا نتیجہ کنسول میں لاگ ان ہوتا ہے۔نمبر"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو کارڈوں کے ڈیک کی نمائندگی کرے۔ڈیک کو تبدیل کرنے اور کارڈ ڈرا کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے بہت سارے طریقے ہیں جو کارڈز کی ایک ڈیک کی نمائندگی کرتے ہیں اور ڈیک کو تبدیل کرنے اور کارڈ ڈرا کرنے کے طریقوں کو نافذ کرتے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: اینڈینن/جاوا اسکرپٹ ایبیکٹس کارڈ-ڈیک گٹ ہب ریپوزٹری کارڈ کلاس ، ڈیک کلاس ، اور پلیئر کلاس والے کارڈوں کے ڈیک کا مکمل نفاذ فراہم کرتا ہے۔عمل درآمد کارڈوں کی ایک مکمل ڈیک تشکیل دیتا ہے اور اسے براؤزر کے کنسول کا استعمال کرتے ہوئے دکھاتا ہے۔ WSVencent.com ویب سائٹ جاوا اسکرپٹ کے ساتھ کسی آبجیکٹ پر مبنی انداز میں تاش کھیلنے کے ڈیک کو کس طرح نافذ کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں اضافی فعالیت کے طریقوں کے ساتھ ایک ڈیک کلاس شامل ہے جیسے شفل آپریشن ، ری سیٹ آپریشن ، اور ایک ڈیل آپریشن جو بے ترتیب کارڈ واپس کرے گا اور اسے ڈیک سے ہٹائے گا۔ڈیک کلاس جو جاوا اسکرپٹ میں کارڈوں کے ڈیک کی نمائندگی کرتی ہے۔کلاس 52 کارڈز کا ڈیک بناتی ہے ، صارفین کو ڈیک کو تبدیل کرنے ، ایک ہی کارڈ سے نمٹنے ، اور ڈیک کو دوبارہ ترتیب دینے کی اجازت دیتی ہے۔ دیوڈوجو ویب سائٹ جاوا اسکرپٹ میں کارڈوں کا ڈیک بنانے کے طریقہ کار پر ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں ایک کارڈ آبجیکٹ اور ڈیک آبجیکٹ شامل ہے ، اور یہ ظاہر کرتا ہے کہ کارڈ کے ڈیک کو کس طرح تبدیل کرنا ہے۔ ایک ڈیک کلاس کی ایک مثال کے نفاذ جو جاوا اسکرپٹ میں کارڈوں کے ڈیک کی نمائندگی کرتی ہے: جاوا اسکرپٹ کلاس ڈیک {کنسٹرکٹر () {this.cards = [[)] ؛کانس سوٹ = [\"دل\" ، \"اسپیڈز\" ، \"کلب\" ، \"ہیرے\"]] ؛کانسٹ ویلیوز = [\"اککا\" ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، 10 ، \"جیک\" ، \"ملکہ\" ، \"کنگ\" ،] ؛کے لئے (سوٹ میں سوٹ دیں) {کے لئے (قدروں میں قدر کریں) {this.cards.push (`$ {اقدار [قدر]} of $ {سوٹ [سوٹ]}`) ؛}}} شفل () {کے لئے (i = this.cards.length-1 ؛ i> 0 ؛ i--) {const j = math.floor (math.random () * (i + 1)) ؛[this.cards [i] ، this.cards [j]] = [this.cards [j] ، this.cards [i]] ؛}} ڈرا () {اس ڈاٹ کام کو واپس کریں ۔پوپ () ؛}} اس مثال میں ، ہم ایک ڈیک کلاس کی وضاحت کرتے ہیں جو کارڈز کی ایک ڈیک کی نمائندگی کرتا ہے۔کلاس میں ایک کنسٹرکٹر ہے جو کارڈز کو ڈیک میں اسٹور کرنے کے لئے ایک سرنی کارڈ شروع کرتا ہے۔اس کے بعد کارڈز کے سوٹ اور اقدار پر تکرار کرکے اور کارڈ کے سرے میں ہر کارڈ کو شامل کرکے کارڈوں کا ایک مکمل ڈیک تیار کرتا ہے۔کلاس میں ایک شفل طریقہ بھی ہے جو فشر-یٹس شفل الگورتھم کا استعمال کرتے ہوئے ڈیک میں موجود کارڈز کو تبدیل کرتا ہے اور ایک ڈرا کا طریقہ جو ڈیک سے ٹاپ کارڈ کو ہٹاتا ہے اور واپس کرتا ہے۔ یہاں ڈیک کلاس کا ایک مثال استعمال ہے: جاوا اسکرپٹکونسٹ ڈیک = نیا ڈیک = نیا ڈیک() ؛ کنسول.لوگ (ڈیک ڈاٹ کارڈز) ؛// [\"دلوں کا اککا\" ، \"دلوں کے 2\" ، \"3 دلوں\" ، ...] ڈیک.شفل () ؛ کنسول.لوگ (ڈیک ڈاٹ کارڈز) ؛// کارڈسنسول.لاگ (ڈیک.راو ()) کی شفلڈ سرنی ؛// ڈیککن اس مثال سے ٹاپ کارڈ ، ہم ایک نیا ڈیک آبجیکٹ بناتے ہیں اور ڈیک میں کارڈز کو کنسول میں لاگ ان کرتے ہیں۔اس کے بعد ہم ڈیک کو تبدیل کرتے ہیں اور کنسول میں شفل کارڈز کو لاگ ان کرتے ہیں۔آخر میں ، ہم ڈیک سے ٹاپ کارڈ کھینچتے ہیں اور اسے کنسول میں لاگ ان کرتے ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے سٹرنگ ایک پیلنڈرووم ہے (وہی فارورڈز اور پیچھے کی طرف پڑھتا ہے)۔",
        "Answer": "یہ چیک کرنا کہ آیا جاوا اسکرپٹا پیلنڈرووم میں ایک تار ایک پیلنڈرووم ہے یا نہیں ایک تار ہے جو ایک ہی آگے اور پیچھے کی طرف پڑھتا ہے۔یہ چیک کرنے کے بہت سارے طریقے ہیں کہ آیا دی دیئے گئے تار جاوا اسکرپٹ میں ایک پیلنڈرووم ہے۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: لینکس اشارہ ویب سائٹ اس بات پر ٹیوٹوریل فراہم کرتی ہے کہ جاوا اسکرپٹ میں سٹرنگ ایک پیلنڈرووم ہے یا نہیں۔ٹیوٹوریل دو طریقے مہیا کرتا ہے ، ایک جاوا اسکرپٹ کے پہلے سے طے شدہ طریقوں کا استعمال کرتے ہوئے اور دوسرا صارف کی وضاحت شدہ طریقہ کا استعمال کرتے ہوئے۔ آئی ٹی نیکسٹ ویب سائٹ جاوا اسکرپٹ میں پیلنڈروم کی جانچ پڑتال کے 11 طریقوں پر ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں ہر حل کی کارکردگی کا امتحان شامل ہوتا ہے۔ پروگرامیز ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ یہ چیک کیسے کریں کہ آیا سٹرنگ ایک پیلنڈرووم ہے یا جاوا اسکرپٹ میں نہیں۔ٹیوٹوریل دو طریقے مہیا کرتا ہے ، ایک لوپ کا استعمال کرتے ہوئے اور دوسرا اسپلٹ () ، ریورس () ، اور () طریقوں کا استعمال کرتے ہوئے۔.واپسی str === الٹ سیسٹر ؛} اس مثال میں ، ہم ایک ispalindrome فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر اسٹرنگ str لیتا ہے اور بولین کی قیمت کو واپس کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ تار ایک palindrome ہے یا نہیں۔فنکشن سب سے پہلے جاوا اسکرپٹ کے اسپلٹ () ، ریورس () ، اور جوائن () کے طریقوں کا استعمال کرتے ہوئے اسٹرنگ کو تبدیل کرتا ہے اور متغیر الٹ اسٹسٹر میں الٹ سٹرنگ کو اسٹور کرتا ہے۔اس کے بعد یہ اصلی تار کا موازنہ الٹ سٹرنگ کے ساتھ کرتا ہے اور اگر وہ برابر ہوتے ہیں تو اس کی نشاندہی کرتی ہے کہ اس بات کی نشاندہی کرتی ہے کہ تار ایک پالندرووم ہے ، اور غلط ہے۔ہیلو \"؛ کنسول.لوگ (ispalindrome (str1)) ؛// trueconsole.log (ispalindrome (str2)) ؛// اس مثال کے طور پر ، ہم دو ڈور بناتے ہیں اور چیک کرتے ہیں کہ آیا وہ ispalindrome فنکشن کا استعمال کرتے ہوئے پیلنڈرووم ہیں ، نتائج کو کنسول پر لاگ ان کریں۔ نوٹ کریں کہ یہ چیک کرنے کے لئے اور بھی طریقے موجود ہیں کہ آیا جاوا اسکرپٹ میں کوئی تار ایک پیلنڈرووم ہے ، جیسے A کے لئے A کا استعمال کرنا A کے لئے استعمال کرنا ہے یا نہیں۔لوپ یا باقاعدہ اظہار۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ایک تکرار والی تقریب کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں تکرار کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کے حقیقت کا حساب لگانا کسی دیئے گئے نمبر کی حقیقت یہ ہے کہ اس تعداد سے کم یا اس کے برابر تمام مثبت عدد کی پیداوار ہے۔مثال کے طور پر ، 5 کا حقیقت 5 x 4 x 3 x 2 x 1 ، یا 120 ہے۔ جاوا اسکرپٹ میں تکرار کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے بہت سارے طریقے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثال فراہم کرتے ہیں کہ یہ کیسے کریں: اسٹیک اوور فلو ویب سائٹ جاوا اسکرپٹ میں تکرار کا استعمال کرتے ہوئے دیئے گئے نمبر کے حقیقت کا حساب لگانے کے بارے میں ایک بحث فراہم کرتی ہے۔اس بحث میں ایک تکرار کرنے والی تقریب کا استعمال کرتے ہوئے ایک حل شامل ہے۔ پروگرامیز ویب سائٹ جاوا اسکرپٹ میں تکرار کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کی ایک مثال پیش کرتی ہے۔مثال کے طور پر ایک فنکشن شامل ہے جو ایک دلیل کے طور پر ایک نمبر لیتا ہے اور اس کی تکرار کا استعمال کرتے ہوئے اس کی حقیقت کو واپس کرتا ہے۔ گولینکسکلوڈ ویب سائٹ جاوا اسکرپٹ میں تکرار کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں اس کی وضاحت شامل ہے کہ تکرار کس طرح کام کرتا ہے اور ایک فنکشن جو تکرار کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کی حقیقت کا حساب لگاتا ہے۔ جاوا اسکرپٹ میں دیئے گئے نمبر کی حقیقت کا حساب لگانے کے لئے ایک بار بار بار چلنے والی تقریب کا نفاذ: جاوا اسکرپٹ فنکشن فیکٹوریئل (این) {اگر (اگر ((n) {اگر ((n) {اگر (n === 0) {واپسی 1 ؛} else {واپسی n * فیکٹوریئل (n - 1) ؛}} اس مثال میں ، ہم ایک ایسے حقیقت پسندانہ فنکشن کی وضاحت کرتے ہیں جو ایک نمبر N کو دلیل کے طور پر لیتا ہے اور تکرار کا استعمال کرتے ہوئے اس کی حقیقت کو واپس کرتا ہے۔فنکشن سب سے پہلے چیک کرتا ہے کہ آیا نمبر 0 ہے ، اس معاملے میں یہ 1 واپس آجاتا ہے ، چونکہ 0 کی حقیقت کی وضاحت 1 کے طور پر کی گئی ہے۔ اگر نمبر 0 نہیں ہے تو ، فنکشن نمبر کی مصنوعات اور نمبر مائنس 1 کی حقیقت پسندی کو واپس کرتا ہے۔، جس کا حساب کتاب کیا جاتا ہے۔ یہاں حقیقت پسندانہ فنکشن کی ایک مثال استعمال ہے: جاوا اسکرپٹکونسٹ n = 5 ؛ کنسول.لوگ (فیکٹوریئل (این)) ؛// 120in اس مثال کے طور پر ، ہم فیکٹوریئل فنکشن کا استعمال کرتے ہوئے کسی دیئے گئے نمبر کے حقیقت کا حساب لگاتے ہیں ، نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔ نوٹ جو تکرار کرنے والے افعال بڑے ان پٹ کے لئے تکراری افعال سے کم موثر ہوسکتے ہیں ، کیونکہ انہیں فنکشن کو ذخیرہ کرنے کے لئے زیادہ میموری کی ضرورت ہوتی ہے۔اسٹیک کو کال کریں۔لہذا ، جب تکرار یا تکراری نقطہ نظر کے درمیان انتخاب کرتے ہو تو حل کی کارکردگی کی خصوصیات پر غور کرنا ضروری ہے۔"
    },
    {
        "Question": "ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ پیدا کرنا جاوا اسکرپٹ میں ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرنے کے متعدد طریقے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثال فراہم کرتے ہیں کہ یہ کیسے کریں: اسٹیک اوور فلو ویب سائٹ جاوا اسکرپٹ میں ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرنے کے بارے میں ایک بحث فراہم کرتی ہے۔بحث میں لوپ اور ریاضی کے لئے A کا استعمال کرتے ہوئے ایک حل شامل ہے۔ٹیوٹوریل میں ایک فنکشن شامل ہے جو ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرتا ہے۔ گیکسفورجیکس ویب سائٹ جاوا اسکرپٹ میں ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں دو نقطہ نظر شامل ہیں ، ایک حرف ، جس میں حروف تہجی ، اعداد ، اور خصوصی حروف پر مشتمل ہے ، اور دوسرا ریاضی کا استعمال کرتے ہوئے۔جاوا اسکرپٹ میں ایک مخصوص لمبائی اور پیچیدگی کے ساتھ پاس ورڈ: جاوا اسکرپٹ فنکشن جنریٹ پاس ورڈ (لمبائی ، پیچیدگی) {پاس ورڈ = \"\" ؛کانسٹ لوئر کیس = \"abcdefghijklmnopqrstuvwxyz\" ؛کونسٹ اپر کیس = \"abcdefghijklmnopqrstuvwxyz\" ؛کانسٹ نمبر = \"0123456789\" ؛const علامت = \"!آئیے حروف = لوئر کیس ؛اگر (پیچیدگی === \"میڈیم\") {حروف += اپر کیس ؛} ورنہ اگر (پیچیدگی === \"مضبوط\") {حروف + = بڑے + نمبر + علامتیں ؛} کے لئے (آئیے i = 0 ؛ i <لمبائی ؛ i ++) {پاس ورڈ+= حروف۔ چیرات (ریاضی.فلور (ریاضی.راینڈوم () * حرف۔ لمبائی)) ؛} پاس ورڈ ؛} اس مثال میں ، ہم ایک جنریٹ پاس ورڈ فنکشن کی وضاحت کرتے ہیں جو دو دلائل ، لمبائی اور پیچیدگی لیتا ہے ، اور مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ لوٹاتا ہے۔فنکشن سب سے پہلے تیار کردہ پاس ورڈ کو اسٹور کرنے کے لئے خالی سٹرنگ پاس ورڈ کی ابتدا کرتا ہے۔اس کے بعد یہ چار ڈور لوئر کیس ، بڑے ، اعداد اور علامتوں کی وضاحت کرتا ہے جو ان کرداروں کی نمائندگی کرتے ہیں جو پاس ورڈ میں استعمال ہوسکتے ہیں۔اس کے بعد یہ فنکشن مخصوص پیچیدگی کی بنیاد پر اضافی ڈوروں کے ساتھ چھوٹے چھوٹے تار کو جوڑتا ہے۔اگر پیچیدگی \"میڈیم\" ہے تو ، فنکشن حروف کے تار میں بڑے پیمانے پر تار کو شامل کرتا ہے۔اگر پیچیدگی \"مضبوط\" ہے تو ، فنکشن حروف کے تار میں بڑے ، اعداد ، اور علامتوں کے تاروں کو شامل کرتا ہے۔اس کے بعد فنکشن مخصوص لمبائی پر تکرار کرتا ہے اور چارٹ () طریقہ اور ریاضی () طریقہ کا استعمال کرتے ہوئے حروف کے تار سے پاس ورڈ سٹرنگ میں بے ترتیب کردار کو شامل کرتا ہے۔ جنریٹ پاس ورڈ فنکشن کا ایک مثال استعمال: جاوا اسکرپٹکونسٹ پاس ورڈ = جنریٹ پاس ورڈ (8، \"مضبوط\") ؛ کنسول.لاگ (پاس ورڈ) ؛// \"3x#j7 $ 9@\" اس مثال میں ، ہم 8 کی لمبائی اور جنریٹ پاس ورڈ فنکشن کا استعمال کرتے ہوئے \"مضبوط\" کی پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔ نوٹ کریں کہ پیدا کرنے کے لئے اور بھی طریقے موجود ہیں۔جاوا اسکرپٹ میں بے ترتیب پاس ورڈ ، جیسے پیش گوئی لائبریری یا باقاعدہ اظہار کا استعمال۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی بھی گہرائی کے گھریلو سرے کو چپٹا کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ فلیٹنگ میں کسی بھی گہرائی کی ایک گھونسلے والی صف کو چپٹا کرنے کا مطلب ہے کہ کثیر جہتی صف کو ایک جہتی صف میں تبدیل کرکے کسی صف کی جہت کو کم کرنا۔جاوا اسکرپٹ میں کسی بھی گہرائی کی گھریلو سرنی کو چپٹا کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: لینکس اشارہ ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ کس طرح گھوںسلا جاوا اسکرپٹ سرنی کو چپٹا کیا جائے۔ٹیوٹوریل میں \"گہرائی\" کی اصطلاح کی وضاحت شامل ہے اور اس کی ایک مثال پیش کی گئی ہے کہ فلیٹ () طریقہ کار کا استعمال کرتے ہوئے گھوںسلا سرنی کو کیسے چپٹا کیا جائے۔ دیو.او ویب سائٹ جاوا اسکرپٹ میں گھوںسلا سرنی کو چپٹا کرنے کے طریقہ کار پر ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں دو طریقے شامل ہیں ، ایک فلیٹ () طریقہ استعمال کرتے ہوئے اور دوسرا تکرار کا استعمال کرتے ہوئے اور () کو کم کریں۔ کوڈ برسٹ ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ کس طرح گھوںسلا جاوا اسکرپٹ سرنی کو چپٹا کیا جائے۔ٹیوٹوریل میں فلیٹ () کے طریقہ کار کی وضاحت شامل ہے اور اس کی مثالیں فراہم کرتی ہیں کہ اسے کسی سرے کو چپٹا کرنے کے لئے کس طرح استعمال کیا جائے۔ فلیٹ () کے طریقہ کار کا استعمال کرتے ہوئے جاوا اسکرپٹ میں کسی بھی گہرائی کی گھوںسلی صف کو چپٹا کرنے کے لئے کسی فنکشن کا نفاذ: جاوا اسکرپٹ فینکشن فلیٹینری(arr) {واپسی arr.flat (انفینٹی) ؛} اس مثال میں ، ہم ایک فلیٹناری فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر ایک سرنی آر آر لیتا ہے اور فلیٹ () کے طریقہ کار کا استعمال کرتے ہوئے چپٹی ہوئی صف کو واپس کرتا ہے۔فلیٹ () کا طریقہ مخصوص گہرائی کی سطح تک ایک صف کو چپٹا کرتا ہے ، اور انفینٹی ویلیو کو کسی گہرائی کی سطح پر سرے کو چپٹا کرنے کے لئے استعمال کیا جاتا ہے۔ فلیٹناریری فنکشن کی ایک مثال کے استعمال: جاوا اسکرپٹکونسٹ نیسٹڈری = [1 ، [2 ، [3 ، [3.// [1 ، 2 ، 3 ، 4 ، 5]] اس مثال میں ، ہم ایک گھوںسلی سرنی بناتے ہیں اور فلیٹناری فنکشن کا استعمال کرتے ہوئے اسے چپٹا کرتے ہیں ، اور نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔ نوٹ کریں کہ جاوا اسکرپٹ میں ایک گھونسلے والی صف کو چپٹا کرنے کے اور بھی طریقے ہیں۔، جیسے تکرار کا استعمال اور کم کریں ()۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں سب سے بڑی اور سب سے چھوٹی تعداد تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں غیر ترتیب شدہ صف میں سب سے بڑی اور سب سے چھوٹی تعداد کا پتہ لگانا جاوا اسکرپٹ میں عددیوں کی ایک غیر ترتیب شدہ صف میں سب سے بڑی اور سب سے چھوٹی تعداد تلاش کریں ، ہم صف کے لئے ایک لوپ کے لئے استعمال کرسکتے ہیں اور زیادہ سے زیادہ اور کم سے کم اقدار کا سراغ لگاسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: ٹیوٹوریلس پوائنٹ ویب سائٹ جاوا اسکرپٹ میں عددیوں کی غیر ترتیب شدہ صف میں سب سے بڑی اور سب سے چھوٹی تعداد تلاش کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں اس مسئلے کی وضاحت شامل ہے اور لوپ کے لئے A کا استعمال کرتے ہوئے ایک حل فراہم کرتا ہے۔ گیکسفورجیکس کی ویب سائٹ جاوا اسکرپٹ کا استعمال کرتے ہوئے کسی صف کے کم سے کم/زیادہ سے زیادہ عنصر کو تلاش کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں دو نقطہ نظر شامل ہیں ، ایک ریاضی کا استعمال کرتے ہوئے۔لوپ کے لئے: جاوا اسکرپٹ فانکشن فائنڈ میکسمین (ARR) {آئیے زیادہ سے زیادہ = arr [0] ؛آئیے منٹ = آر آر [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {if (arr [i]> زیادہ سے زیادہ) {زیادہ سے زیادہ = arr [i] ؛} ورنہ اگر (arr [i] <منٹ) {منٹ = arr [i] ؛}} واپسی {منٹ ، زیادہ سے زیادہ} ؛} اس مثال کے طور پر ، ہم ایک فائنڈ میکسمین فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر ایک سرنی آر آر لیتا ہے اور کسی ایسی چیز کو واپس کرتا ہے جس میں کم سے کم اور زیادہ سے زیادہ تعداد ہوتی ہے۔فنکشن سب سے پہلے سرے کے پہلے عنصر میں زیادہ سے زیادہ اور من متغیر کو شروع کرتا ہے۔اس کے بعد یہ لوپ کے لئے A کا استعمال کرتے ہوئے سرے پر تکرار کرتا ہے اور زیادہ سے زیادہ اور کم متغیرات کو اپ ڈیٹ کرتا ہے اگر کوئی بڑا یا چھوٹا عنصر مل جاتا ہے۔ یہاں فائنڈ میکسمین فنکشن کی ایک مثال استعمال ہے: جاوا اسکرپٹ کونسٹ آر آر = [112 ، 24 ، 31 ، 44 ، 101 ، 203، 33 ، 56] ؛ کنسول.لوگ (فائنڈ میکسمین (اے آر آر)) ؛// {منٹ: 24 ، زیادہ سے زیادہ: 203} اس مثال میں ، ہم انٹیجرز کی ایک صف تیار کرتے ہیں اور فائنڈ میکسمین فنکشن کا استعمال کرتے ہوئے صف میں سب سے بڑی اور چھوٹی تعداد تلاش کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔جاوا اسکرپٹ میں غیر ترتیب شدہ صف میں سب سے بڑی اور سب سے چھوٹی تعداد تلاش کریں ، جیسے ریاضی کا استعمال کریں۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی صف سے نقل کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں اور انوکھی اقدار کے ساتھ ایک نئی صف واپس کریں۔",
        "Answer": "جاوا اسکرپٹ میں منفرد اقدار کے ساتھ ایک سرنی سے نقلیں ہٹانے اور ایک نئی صف واپس کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ عام طریقے ہیں: ایک سیٹ کا استعمال: ایک سیٹ انوکھی اقدار کا مجموعہ ہے۔کسی سیٹ کا استعمال کرتے ہوئے کسی صف سے نقلیں ہٹانے کے لئے ، پہلے صف کو کسی سیٹ میں تبدیل کریں ، پھر سیٹ کو واپس کسی صف میں تبدیل کریں۔یہاں ایک مثال ہے: جاوا اسکرپٹ فکشن کو ہٹادیا (ARR) {واپسی [... نیا سیٹ (آر آر)] ؛} اس مثال کے طور پر ، ہم ایک ہٹانے والے فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر ایک سرنی آر آر لیتا ہے اور انوکھی اقدار کے ساتھ ایک نئی صف لوٹاتا ہے۔فنکشن سب سے پہلے اسپریڈ آپریٹر ... اور نیا سیٹ () کنسٹرکٹر کا استعمال کرتے ہوئے سرے کو ایک سیٹ میں تبدیل کرتا ہے۔سیٹ واضح طور پر ڈپلیکیٹ عناصر کو ہٹا دیتا ہے۔اس کے بعد یہ فنکشن اسپریڈ آپریٹر کا استعمال کرتے ہوئے سیٹ کو واپس ایک صف میں تبدیل کرتا ہے۔ فلٹر () کے طریقہ کار کا استعمال کرتے ہوئے: فلٹر () کا طریقہ کار عناصر کی ایک نئی صف تیار کرتا ہے جو ہماری فراہم کردہ حالت کو منتقل کرتا ہے۔ہم اپنی حالت کو صرف ایڈجسٹ کرکے صف سے ڈپلیکیٹ اقدار کو ہٹا سکتے ہیں۔یہاں ایک مثال ہے: جاوا اسکرپٹ فکشن کو ہٹا دیا گیاایک دلیل اور انوکھی اقدار کے ساتھ ایک نئی صف لوٹاتا ہے۔فنکشن فلٹر () کا طریقہ استعمال کرتا ہے تاکہ عناصر کی ایک نئی صف تیار کی جاسکے جو ہمارے فراہم کردہ حالت کو منتقل کرتے ہیں۔حالت چیک کرتی ہے کہ آیا موجودہ عنصر کا انڈیکس صف میں عنصر کے پہلے واقعے کے انڈیکس کے برابر ہے۔اگر حالت درست ہے تو ، عنصر کو نئی صف میں شامل کیا گیا ہے۔ کم () طریقہ کار کا استعمال کرتے ہوئے: کم () طریقہ کار ایک سرنی کے ہر عنصر پر ایک فنکشن کا اطلاق کرتا ہے اور صف کو ایک ہی قدر میں کم کرتا ہے۔ہم منفرد اقدار کے ساتھ ایک نئی صف بنانے کے لئے کم () طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: جاوا اسکرپٹ فنکشن کو ہٹا دیا گیااس مثال کے طور پر ، ہم ایک ہٹانے والے فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر سرنی آر آر لیتا ہے اور انوکھی اقدار کے ساتھ ایک نئی صف لوٹاتا ہے۔فنکشن سرنی کے ہر عنصر پر کسی فنکشن کو لاگو کرنے اور صف کو ایک ہی قدر میں کم کرنے کے لئے کم () طریقہ استعمال کرتا ہے۔فنکشن چیک کرتا ہے کہ آیا موجودہ عنصر پہلے ہی نئی صف میں شامل ہے۔اگر عنصر شامل نہیں ہے تو ، فنکشن شامل کردہ عنصر کے ساتھ ایک نئی صف لوٹاتا ہے۔اگر عنصر پہلے ہی شامل ہے تو ، فنکشن اصل سرنی کو لوٹاتا ہے۔ یہاں ہٹانے والی کمپنیوں کی ایک مثال استعمال ہے: جاوا اسکرپٹکونسٹ آر آر = [1 ، 2 ، 3 ، 2 ، 4 ، 3 ، 5] ؛ کنسول.لوگ (ہٹانے والی (آر آر))) ؛// [1 ، 2 ، 3 ، 4 ، 5]] اس مثال میں ، ہم ڈپلیکیٹ اقدار کے ساتھ ایک صف تیار کرتے ہیں اور ہٹانے والی کمپنیوں کے فنکشن کا استعمال کرتے ہوئے ڈپلیکیٹ کو ہٹا دیتے ہیں ، نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔ نوٹ کریں کہ نقل کو دور کرنے کے لئے اور بھی طریقے موجود ہیںجاوا اسکرپٹ میں ایک صف ، جیسے انڈیکس () اور پش () طریقوں کا استعمال کرنا یا پیش گوئی () طریقہ استعمال کرنا۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "اعشاریہ کی تعداد کو بائنری نمائندگی میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹو میں بائنری نمائندگی میں اعشاریہ کی تعداد کو تبدیل کرتے ہوئے ایک اعشاریہ نمبر کو جاوا اسکرپٹ میں بائنری نمائندگی میں تبدیل کرتے ہوئے ، ہم 2 کے ریڈیکس پیرامیٹر کے ساتھ ٹاسٹرنگ () کا طریقہ استعمال کرسکتے ہیں۔ یہاں کچھ ایسے وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں: سبسے۔IO ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ جاوا اسکرپٹ میں اعشاریہ نمبر کو بائنری میں کیسے تبدیل کیا جائے۔ٹیوٹوریل میں اس کی وضاحت شامل ہے کہ اعشاریہ نمبر اور بائنری نمبر کیا ہیں ، اور اس کی ایک مثال فراہم کرتی ہے کہ کس طرح ٹاسٹرنگ () کے طریقہ کار کو بائنری میں تبدیل کرنے کے لئے کس طرح استعمال کیا جائے۔ پروگرام کی ویب سائٹ ایک مثال پیش کرتی ہے کہ کس طرح اعشاریہ نمبر کو تبدیل کیا جائے۔جاوا اسکرپٹ میں بائنری کرنا۔مثال کے طور پر ایک فنکشن شامل ہے جو ایک ان پٹ کے طور پر اعشاریہ نمبر لیتا ہے اور اس کی بائنری نمائندگی واپس کرتا ہے۔ ماسٹرنگ جے ایس ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ جاوا اسکرپٹ میں اعشاریہ کو بائنری میں کیسے تبدیل کیا جائے۔ٹیوٹوریل میں بائنری نمبر کیا ہے اس کی وضاحت بھی شامل ہے ، اور اس کی ایک مثال فراہم کرتی ہے کہ کس طرح ایک اعشاریہ نمبر کو بائنری میں تبدیل کرنے کے لئے ٹاسٹرنگ () طریقہ استعمال کیا جائے۔ یہاں جاوا اسکرپٹ میں اعشاریہ کی نمائندگی میں اعشاریہ کو بائنری نمائندگی میں تبدیل کرنے کے لئے کسی فنکشن کا نفاذ: جاوا اسکرپٹ فنکشن اعشاریہ (اعشاریہ) {واپسی اعشاریہ۔ ٹوسٹرنگ (2) ؛} اس مثال میں ، ہم ایک اعشاریہ اعشاریہ کی وضاحت کرتے ہیں جو ایک اعشاریہ اعشاریہ اعشاریہ کے طور پر اعشاریہ کی نمائندگی کرتا ہے اور اس کی بائنری نمائندگی کو ٹاسٹرنگ () کے طریقہ کار کا استعمال کرتے ہوئے واپس کرتا ہے جس میں ریڈکس پیرامیٹر کے ساتھ ایک ریڈکس پیرامیٹر کا استعمال کیا جاتا ہے۔2. یہاں اعشاریہ کے اعشاریہ فنکشن کا ایک مثال استعمال: جاوا اسکرپٹکونسٹ اعشاریہ = 10 ؛ کانسٹ بائنری = اعشاریہ (اعشاریہ) ؛ کنسول.لوگ (بائنری) ؛// \"1010\" اس مثال میں ، ہم اعشاریہ کی تعداد کو بائنری میں تبدیل کرتے ہیں ، اس کے نتیجے کو کنسول پر لاگ ان کرتے ہیں۔ نوٹ کریں کہ جیو اسکرپٹ میں اعشاریہ کی تعداد کو بائنری میں تبدیل کرنے کے اور بھی طریقے ہیں ، جیسے بٹ وائز آپریٹرز کو استعمال کرنا۔دستی طور پر بائنری نمائندگی کا حساب لگانا۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی دیئے گئے جملے میں الفاظ کی ترتیب کو پلٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے جملے میں الفاظ کی ترتیب کو تبدیل کرتے ہوئے جاوا اسکرپٹ میں دیئے گئے جملے میں الفاظ کی ترتیب کو الٹ دیتے ہیں ، ہم اس جملے کو الفاظ کی صف میں تقسیم کرسکتے ہیں ، صف کی ترتیب کو الٹ سکتے ہیں ، اور پھر صف کو تار میں شامل کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: اسٹیک اوور فلو ویب سائٹ جاوا اسکرپٹ میں الفاظ کی ترتیب کو کس طرح پلٹانے کے بارے میں ایک بحث فراہم کرتی ہے۔اس بحث میں اسپلٹ () اور () طریقوں کا استعمال کرتے ہوئے ایک حل شامل ہے۔ ٹیوٹوریلس پوائنٹ ویب سائٹ جاوا اسکرپٹ میں کسی جملے کے تمام الفاظ کو الٹ کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں اس بات کی ایک مثال شامل ہے کہ کس طرح اسپلٹ () ، ریورس () ، اور اس میں شامل ہونے کے طریقوں کو استعمال کریں۔ٹیوٹوریل میں اس کی ایک مثال شامل ہے کہ کس طرح تار کو الفاظ کی صف میں تقسیم کیا جائے ، صف کے ترتیب کو الٹا کریں ، اور سرے کو دوبارہ تار میں شامل کریں۔ ایک مقررہ جملے میں الفاظ کی ترتیب کو الٹ کرنے کے لئے کسی فنکشن کا ایک مثال عمل کرنا ہے۔جاوا اسکرپٹ میں: جاوا اسکرپٹ فنکشن الٹ (جملہ) {کونسٹ الفاظ = جملہ۔ اسپلٹ (\"\") ؛کانسٹ الٹ ورڈز = الفاظ۔ ریورس () ؛const الٹاواپسی الٹ سنسینٹینس ؛} اس مثال کے طور پر ، ہم ایک الٹ تقریب کی وضاحت کرتے ہیں جو جملے کی سزا کو دلیل کے طور پر لیتا ہے اور الفاظ کے الٹ کے حکم کے ساتھ ایک نیا جملہ واپس کرتا ہے۔فنکشن سب سے پہلے اس جملے کو اسپیس ڈیمیٹر کے ساتھ اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتا ہے۔اس کے بعد یہ الٹ () طریقہ کار کا استعمال کرتے ہوئے صف کے ترتیب کو تبدیل کرتا ہے اور اس کے نتیجے کو ایک نئے سرنی الٹ ورڈز میں اسٹور کرتا ہے۔آخر میں ، فنکشن اسپیس ڈیمیمٹر کے ساتھ جوائن () کے طریقہ کار کا استعمال کرتے ہوئے ایک تار میں صف میں شامل ہوتا ہے اور اس کا نتیجہ لوٹاتا ہے۔ یہاں الٹ جانے والی تقریب کا ایک مثال استعمال ہے: جاوا اسکرپٹکونسٹ جملہ = \"سست براؤن فاکس سست کتے پر چھلانگ لگا دیتا ہے۔\"const const الٹا// \"کتا۔ اوور اوور چھلانگ فاکس براؤن کو فوری\" اس مثال کے طور پر ، ہم الٹ سنسنی فنکشن کا استعمال کرتے ہوئے کسی دیئے گئے جملے میں الفاظ کی ترتیب کو الٹ دیتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔ نوٹ کریں کہ آرڈر کو الٹا کرنے کے اور بھی طریقے ہیں۔جاوا اسکرپٹ میں دیئے گئے جملے میں الفاظ کی ، جیسے لوپ کے لئے یا باقاعدہ اظہار کے لئے استعمال کرنا۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی دیئے گئے عدد میں تمام ہندسوں کی رقم کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے عدد میں دیئے گئے عددی میں ہندسوں کے جوڑے کا حساب لگاتے ہوئے جاوا اسکرپٹ میں دیئے گئے عدد میں ہندسوں کی رقم کا حساب لگائیں ، ہم انٹیجر کو تار میں تبدیل کرسکتے ہیں ، تار کو ہندسوں کی صف میں تقسیم کرسکتے ہیں ، اور پھر لوپ کا استعمال کرتے ہوئے ہندسوں کا خلاصہ کرتے ہیں۔کم () طریقہ۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: W3Resource ویب سائٹ جاوا اسکرپٹ میں دیئے گئے عددی میں ہندسوں کی رقم کا حساب لگانے کی ایک مثال پیش کرتی ہے۔مثال کے طور پر ایک فنکشن شامل ہے جو ایک دلیل کے طور پر ایک عدد لیتا ہے اور اپنے ہندسوں کا مجموعہ لوٹاتا ہے۔ اسٹیک اوور فلو ویب سائٹ جاوا اسکرپٹ میں کسی بڑی تعداد کے تمام ہندسوں کا خلاصہ کس طرح بیان کرتی ہے۔اس بحث میں ہندسوں کا خلاصہ کرنے کے لئے ماڈیولو آپریٹر اور کم () طریقہ کار کو کس طرح استعمال کیا جائے اس کی مثالیں شامل ہیں۔ بوبیڈز ویب سائٹ جاوا اسکرپٹ کا استعمال کرتے ہوئے کسی نمبر میں تمام ہندسوں کا خلاصہ کیسے بنائے گی۔مثال کے طور پر ایک فنکشن شامل ہے جو ایک دلیل کے طور پر ایک نمبر لیتا ہے اور کم () طریقہ کار کا استعمال کرتے ہوئے اپنے ہندسوں کا مجموعہ واپس کرتا ہے۔ جاوا اسکرپٹ میں دیئے گئے عدد میں ہندسوں کی رقم کا حساب لگانے کے لئے کسی فنکشن کا ایک مثال عمل () کم کریں ()طریقہ: جاوا اسکرپٹ فنکشن سموف ڈائیگٹس (نمبر) {واپسی سٹرنگ (نمبر). اسپلٹ (\"\")ایک دلیل کے طور پر ایک انٹیجر نمبر لیتا ہے اور کم () طریقہ کار کا استعمال کرتے ہوئے اپنے ہندسوں کا مجموعہ واپس کرتا ہے۔فنکشن سب سے پہلے سٹرنگ () کنسٹرکٹر کا استعمال کرتے ہوئے انٹیجر کو اسٹرنگ میں تبدیل کرتا ہے۔اس کے بعد اس تقسیم () کے طریقہ کار کا استعمال کرتے ہوئے تار کو ہندسوں کی صف میں تقسیم کرتا ہے۔آخر میں ، فنکشن سرنی میں ہندسوں کے خلاصے کے لئے کم () طریقہ استعمال کرتا ہے۔ یہاں سوموف ڈائیگٹس فنکشن کا ایک مثال استعمال: جاوا اسکرپٹکنسٹ نمبر = 12345 ؛ کانسٹ سم = سموفڈیجٹس (نمبر) ؛ کنسول.لاگ (رقم) ؛// 15 میں اس مثال کے طور پر ، ہم کسی دیئے گئے عدد میں ہندسوں کی رقم کا حساب کتاب کرتے ہیں جس کا استعمال سوموف ڈائیگٹس فنکشن کا استعمال کرتے ہیں ، نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔ نوٹ کریں کہ جاوا اسکرپٹ میں دیئے گئے عدد میں ہندسوں کی رقم کا حساب لگانے کے اور بھی طریقے ہیں ، جیسے استعمال کرناایک لوپ یا ماڈیولو آپریٹر۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "\"ایک جاوا اسکرپٹ کلاس بنائیں جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ دھکے ، پاپ اور جھانکنے کے ل methods طریقوں کو نافذ کریں۔\"",
        "Answer": "جاوا اسکرپٹ اسٹیک کلاسو کو نافذ کرنا جاوا اسکرپٹ کلاس کو نافذ کرتا ہے جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، ہم عناصر کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرسکتے ہیں اور عناصر کو آگے بڑھانے ، پاپ اور جھانکنے کے طریقوں کو نافذ کرسکتے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں: جاوا اسکرپٹ ٹیوٹوریل ویب سائٹ ایک ٹیوٹوریل فراہم کرتی ہے کہ جاوا اسکرپٹ اسٹیک کو کسی صف کا استعمال کرتے ہوئے کیسے نافذ کیا جائے اور یہ واضح کرتا ہے کہ اسٹیک آپریشنز انجام دینے کے لئے پش () اور پاپ () کے طریقوں کو کس طرح استعمال کیا جائے۔ویب سائٹ ونیلا جاوا اسکرپٹ اور ES6 میں اسٹیک کو کس طرح نافذ کرنے کی ایک مثال پیش کرتی ہے۔مثال کے طور پر پش ، پاپ ، اور پیک طریقوں کے ساتھ اسٹیک فنکشن کا مکمل نفاذ شامل ہے۔ پروگرامیز ویب سائٹ جاوا اسکرپٹ میں اسٹیک ڈیٹا ڈھانچے کو کس طرح نافذ کرنے کی ایک مثال پیش کرتی ہے۔مثال کے طور پر ایک اسٹیک کلاس شامل ہے جس میں طریقوں کے ساتھ طریقوں کے ساتھ شامل ہیں ، حذف کرنے ، دیکھنے ، چیک کرنے اور صاف کرنے والے عناصر۔ یہاں جاوا اسکرپٹ کلاس کا ایک مثال عمل ہے جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتا ہے: جاوا اسکرپٹ کلاس اسٹیک {کنسٹرکٹر () {this.items = [] ؛} پش (عنصر) {this.items.push (عنصر) ؛} پاپ () this this.items.pop () واپس کریں ؛} جھانکنے () this اس کو واپس کریں۔ آئٹمز [this.items.length - 1] ؛}} اس مثال میں ، ہم ایک اسٹیک کلاس کی وضاحت کرتے ہیں جس میں عناصر کو ذخیرہ کرنے کے لئے ایک صف کی اشیاء موجود ہیں۔کلاس کے تین طریقے ہیں: پش (عنصر): سرنی کے پش () طریقہ کا استعمال کرتے ہوئے اسٹیک کے اوپری حصے میں ایک عنصر شامل کرتا ہے۔سرنی.پیک (): سرنی کے آخری عنصر تک رسائی حاصل کرکے اسٹیک کے اوپری عنصر کو واپس کرتا ہے۔ یہاں اسٹیک کلاس کا ایک مثال استعمال ہے: جاوا اسکرپٹکونسٹ اسٹیک = نیا اسٹیک () اسٹیک.پش (1) ؛اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛ کنسول.لاگ (اسٹیک.پیک ()) ؛// 3console.log (stack.pop ()) ؛// 3console.log (stack.peek ()) ؛// 2 میں یہ مثال ، ہم ایک نیا اسٹیک آبجیکٹ تیار کرتے ہیں اور تین عناصر کو اسٹیک پر دھکیل دیتے ہیں۔اس کے بعد ہم اسٹیک کے اوپری عنصر ، پاپ () کے طریقہ کار کو اسٹیک کے اوپری عنصر کو ہٹانے اور واپس کرنے کے لئے ، اور اسٹیک کے نئے ٹاپ عنصر کو دیکھنے کے لئے ایک بار پھر جھانکنے کے طریقہ کار کو دیکھنے کے لئے پیک () طریقہ استعمال کرتے ہیں۔نوٹ کریں کہ جاوا اسکرپٹ میں اسٹیک ڈیٹا ڈھانچے کو نافذ کرنے کے اور بھی طریقے ہیں ، جیسے لنکڈ لسٹ یا کسی شے کا استعمال کرنا۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا کوئی دیئے گئے نمبر پرائم ہیں یا نہیں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے نمبر پرائم کی جانچ پڑتال کے ل we ، ہم مثبت نمبروں کے ذریعے لوپ کے لئے A کا استعمال کرسکتے ہیں تاکہ یہ معلوم کیا جاسکے کہ صارف کے ذریعہ داخل کردہ نمبر مثبت نمبروں (2 صارف سے داخل نمبر پر 2) کے ذریعہ تقسیم کیا جاسکتا ہے یا نہیں۔اگر نمبر 1 اور خود کے علاوہ کسی بھی تعداد کے ذریعہ تقسیم ہے تو ، یہ ایک اہم نمبر نہیں ہے۔اگر نمبر 1 اور خود کے علاوہ کسی اور نمبر کے ذریعہ تقسیم نہیں ہے تو ، یہ ایک اہم نمبر ہے۔یہاں کچھ وسائل ہیں جو اس کی مثال فراہم کرتے ہیں کہ یہ کیسے کریں: پروگرامیز ویب سائٹ اس بات کی ایک مثال پیش کرتی ہے کہ جاوا اسکرپٹ میں کوئی نمبر پرائم ہے یا نہیں اس کی جانچ کیسے کی جائے۔مثال کے طور پر ایک فنکشن شامل ہے جو ان پٹ کے طور پر ایک نمبر لیتا ہے اور چیک کرتا ہے کہ آیا یہ وزیر اعظم ہے یا نہیں۔ گیکسفورجیکس ویب سائٹ اس بات کی ایک مثال پیش کرتی ہے کہ آیا کوئی نمبر پرائم ہے یا جاوا اسکرپٹ کا استعمال نہیں کررہا ہے۔مثال میں ایک فنکشن شامل ہوتا ہے جو ان پٹ کے طور پر ایک نمبر لیتا ہے اور چیک کرتا ہے کہ آیا یہ پرائم ہے یا نہیں۔ یہاں کسی فنکشن کی مثال کے طور پر یہ معلوم ہوتا ہے کہ جاوا اسکرپٹ میں دیئے گئے نمبر پرائم ہے یا نہیں: جاوا اسکرپٹ فینکشن ISPRIME (NUM) {اگر (نمبر <=1) {جھوٹا لوٹ ؛} for کے لئے (آئیے i = 2 ؛ i <num ؛ i ++) {اگر (num ٪ i === 0) {غلط واپس ؛true} سچ کی واپسی ؛} اس مثال میں ، ہم ایک آئی ایس پرائم فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر ایک نمبر نمبر لیتا ہے اور اگر نمبر اہم ہے ، اور دوسری صورت میں غلط ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا نمبر 1 سے کم یا اس کے برابر ہے ، جو ایک اہم نمبر نہیں ہے۔اس کے بعد یہ لوپ کے لئے A کا استعمال 2 سے نمبر تک تمام مثبت نمبروں کے ذریعے تکرار کرنے کے لئے کرتا ہے۔اگر یہ تعداد 1 اور خود کے علاوہ کسی اور تعداد کے ذریعہ تقسیم نہیں ہے تو ، یہ ایک اہم نمبر ہے اور فنکشن سچ واپس آجاتا ہے۔ یہاں آئسپریم فنکشن کا ایک مثال استعمال ہے: جاوا اسکرپٹ کنسول.لوگ (isprime (7))// trueconsole.log (isprime (12)) ؛// اس مثال کے طور پر ، ہم یہ چیک کرتے ہیں کہ آیا آئی ایس پرائم فنکشن کا استعمال کرتے ہوئے ایک دیئے گئے نمبر پرائم ہیں ، نتیجہ کو کنسول پر لاگ ان کریں۔ نوٹ کریں کہ یہ چیک کرنے کے اور بھی طریقے موجود ہیں کہ آیا جاوا اسکرپٹ میں دیئے گئے نمبر پرائم ہیں ، جیسے مربع روٹ کا استعمال کرنالوپ میں تکرار کی تعداد کو کم کرنے کے لئے تعداد۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی خاص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں ایک مخصوص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے ل we ، ہم ترتیب () طریقہ استعمال کرسکتے ہیں اور موازنہ کی تقریب فراہم کرسکتے ہیں جو اشیاء کی ترتیب کا تعین کرتا ہے۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: ماسٹرنگ جے ایس ویب سائٹ جاوا اسکرپٹ میں ایک مخصوص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے طریقہ کار کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں مختلف خصوصیات کے ذریعہ اشیاء کی ایک صف کو ترتیب دینے کے لئے ترتیب () کے طریقہ کار اور موازنہ فنکشن کی ایک مثال شامل ہے۔ جاوا اسکرپٹ ٹیوٹوریل ویب سائٹ ایک خاص پراپرٹی ویلیو میں مخصوص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔جاوا اسکرپٹ۔ٹیوٹوریل میں مختلف خصوصیات کے ذریعہ ملازمین کی اشیاء کی ایک صف کو ترتیب دینے کے لئے ترتیب () کے طریقہ کار اور ایک موازنہ فنکشن کی ایک مثال شامل ہے۔ پروگرامیز ویب سائٹ اس بات کی ایک مثال پیش کرتی ہے کہ کس طرح مخصوص پراپرٹی ویلیو میں مخصوص پراپرٹی کی قیمت پر مبنی اشیاء کی ایک صف کو ترتیب دیا جائے۔جاوا اسکرپٹ۔مثال میں ایک فنکشن شامل ہوتا ہے جو اشیاء کی ایک صف اور جائیداد کا نام ان پٹ کے طور پر لیتا ہے اور مخصوص پراپرٹی کے ذریعہ ترتیب دیئے گئے اشیاء کی ایک نئی صف لوٹاتا ہے۔ یہاں ایک مخصوص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے لئے کسی فنکشن کا نفاذ ہے۔جاوا اسکرپٹ: جاوا اسکرپٹ فنکشن ترتیب بائی پروپرٹی (اے آر آر ، پروپ) {ریٹرن آر آر ایسورٹ ((ا ، بی) => (اے [پروپ]> بی [پروپ])؟ 1: ((بی [پروپ]> اے [پروپ])؟ -1: 0)) ؛} اس مثال کے طور پر ، ہم ایک ترتیب بائی پروپرٹی فنکشن کی وضاحت کرتے ہیں جو ایک سرنی آر آر اور پراپرٹی کا نام پروپ کے طور پر لیتا ہے اور مخصوص پراپرٹی کے ذریعہ ترتیب دیئے گئے اشیاء کی ایک نئی صف کو واپس کرتا ہے۔فنکشن ایک موازنہ فنکشن کے ساتھ ترتیب () کا طریقہ استعمال کرتا ہے جو ہر شے میں مخصوص پراپرٹی کی اقدار کا موازنہ کرتا ہے۔موازنہ کا فنکشن 1 لوٹتا ہے اگر A میں پراپرٹی کی قیمت B میں پراپرٹی کی قیمت سے زیادہ ہو ، -1 اگر A میں پراپرٹی کی قیمت B میں پراپرٹی کی قیمت سے کم ہے ، اور 0 اگر اقدار کی قیمت ہے۔برابر ہیں۔ ترتیب بائی پروپرٹی فنکشن کا ایک مثال استعمال: جاوا اسکرپٹ کنسٹ ملازمین = [{نام: 'جان' ، عمر: 27 ، تنخواہ: 50000} ، {نام: 'انا' ، عمر: 25 ، تنخواہ: 60000} ، {نام: 'صہیون' ، عمر: 30 ، تنخواہ: 40000}] const const sortedemployees = shortbyproperty (ملازمین ، 'تنخواہ') ؛ کنسول.لاگ (ترتیب دیں) ؛ اس مثال میں ، ہم ترتیب بائی پروپرٹی کا استعمال کرتے ہوئے تنخواہ کے ذریعہ ملازمین کی اشیاء کی ایک صف کو ترتیب دیتے ہیں۔فنکشن ، نتیجہ کو کنسول پر لاگ ان کریں۔ نوٹ کریں کہ جاوا اسکرپٹ میں مخصوص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے اور بھی طریقے ہیں ، جیسے لوڈش لائبریری سے لوکل کامپیر () طریقہ یا _.sortby () طریقہ استعمال کرنا۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "\"کسی صف سے غلط اقدار (غلط ، کالعدم ، 0 ،\" \"\" \"، غیر متعینہ ، نان) کو دور کرنے کے لئے کسی فنکشن کو نافذ کریں۔\"",
        "Answer": "جاوا اسکرپٹ میں کسی صف سے غلطی کی اقدار کو ہٹانا جاوا اسکرپٹ میں ایک صف سے جعلی اقدار (غلط ، کالعدم ، 0 ، \"\" ، غیر متعینہ ، نان) کو ہٹانے کے لئے ، ہم فلٹر () کا طریقہ استعمال کرسکتے ہیں اور ایک ایسا فنکشن مہیا کرسکتے ہیں جو سچائی اقدار کے لئے سچ ہو اورغلط اقدار کے لئے غلط۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: جاوا اسکرپٹ سادہ انگریزی ویب سائٹ جاوا اسکرپٹ میں ایک صف سے غلط اقدار کو کیسے ختم کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں فلٹر () کے طریقہ کار ، کم () کے طریقہ کار ، اور لوپ کے لئے ایک سرنی سے غلطی والی اقدار کو دور کرنے کے تین مختلف طریقے شامل ہیں۔ ٹیوٹوریلس پوائنٹ ویب سائٹ جاوا اسکرپٹ میں کسی صف سے غلطی کی اقدار کو کیسے دور کرے گی۔مثال کے طور پر ایک فنکشن شامل ہے جو ان پٹ کے طور پر ایک صف لیتا ہے اور صرف سچائی اقدار کے ساتھ ایک نئی صف لوٹاتا ہے۔ سامانتھمنگ ڈاٹ کام کی ویب سائٹ جاوا اسکرپٹ میں ایک صف سے تمام غلط اقدار کو کیسے ہٹانے کے بارے میں ایک تصویری ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں جعلی اقدار کی وضاحت شامل ہے ، کس طرح قیمت کو بولین میں تبدیل کرنا ہے !!آپریٹر ، اور فلٹر () کے طریقہ کار کو کسی سرے سے غلط اقدار کو دور کرنے کے لئے کس طرح استعمال کریں۔ فلٹر () کے طریقہ کار کا استعمال کرتے ہوئے جاوا اسکرپٹ میں کسی صف سے جھوٹی اقدار کو دور کرنے کے لئے کسی فنکشن کی ایک مثال عمل: جاوا اسکرپٹ فینکشن کو ختم کرنے والی فالسیلیوز (ARR) {واپسی ARR.فلٹر (بولین) ؛} اس مثال کے طور پر ، ہم ایک ریماسفالسی ویلیوز فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر ایک سرنی آر آر لیتا ہے اور فلٹر () کے طریقہ کار کو فلٹر فنکشن کے طور پر فلٹر () کے طریقہ کار کا استعمال کرتے ہوئے صرف سچائی اقدار کے ساتھ ایک نئی صف لوٹاتا ہے۔بولین کنسٹرکٹر غلط اقدار کے ل false غلط اور سچائی اقدار کے ل true سچائی کرتا ہے۔ یہاں ریماسفالسی ویلیوز فنکشن کا ایک مثال استعمال ہے: جاوا اسکرپٹ کنسٹ آر = [0 ، 1 ، غلط ، 2 ، \"\" ، 3 ، کالعدم ، غیر متعینہ ، نان] ؛ فلٹر ڈیر =ریمو فالسی ویلیوز (اے آر آر) ؛ کنسول.لوگ (فلٹرڈر) ؛// [1 ، 2 ، 3] اس مثال میں ، ہم ریماسٹ فالسی ویلیوز فنکشن کا استعمال کرتے ہوئے کسی سرے سے غلط اقدار کو ہٹا دیتے ہیں ، نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔ نوٹ کریں کہ جاوا اسکرپٹ میں کسی صف سے غلط اقدار کو دور کرنے کے اور بھی طریقے ہیں ، جیسے کہکم () طریقہ یا لوپ کے لئے A کا استعمال کرتے ہوئے۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں آر جی بی فارمیٹ میں آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرنا جاوا اسکرپٹ میں آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرتا ہے ، ہم 0 اور 255 کے درمیان تین بے ترتیب عدد پیدا کرنے کے لئے ریاضی کا استعمال کرسکتے ہیں۔ایک رنگاس کے بعد ہم انہیں کوما اور قوسین کے ساتھ تار میں جوڑ سکتے ہیں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: سلنگ اکیڈمی کی ویب سائٹ جاوا اسکرپٹ میں بے ترتیب رنگ کیسے پیدا کرنے کے بارے میں ایک ٹیوٹوریل فراہم کرتی ہے۔ٹیوٹوریل میں ایک مثال شامل ہے کہ بے ترتیب آرجیبی رنگوں کو پیدا کرنے کے لئے ریاضی کا استعمال کیا جائے۔اس بحث میں اس کی ایک مثال شامل ہے کہ کس طرح 0 سے 255 کی حد میں تین بے ترتیب نمبر پیدا کریں اور انہیں \"آر جی بی (این 1 ، این 2 ، این 3)\" فارمیٹ میں اسٹرنگ میں داخل کریں۔ کوڈ ٹٹسپلس ویب سائٹ کوڈ کے طریقہ کار پر ٹیوٹوریل فراہم کرتی ہے۔جاوا اسکرپٹ میں ایک بے ترتیب رنگ جنریٹر۔ٹیوٹوریل میں اس کی ایک مثال شامل ہے کہ جاوا اسکرپٹ میں آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرنے کے لئے آر جی بی ، ہیکساڈیسیمل ، اور ایچ ایس ایل نوٹیشن میں بے ترتیب رنگ کیسے پیدا کیا جائے۔math.random () * 256) ؛// 0-255 کے درمیان بے ترتیب g = math.floor (math.random () * 256) ؛// 0-255 کے درمیان بے ترتیب B = math.floor (math.random () * 256) ؛// 0-255 کے درمیان بے ترتیب `RGB ($ {r} ، $ {g} ، $ {B})` ؛}}} اس مثال میں ، ہم ایک بے ترتیب آر جی بی کلور فنکشن کی وضاحت کرتے ہیں جو بے ترتیب آرجیبی رنگ پیدا کرتا ہے۔فنکشن 0 اور 255 کے درمیان تین بے ترتیب عدد پیدا کرنے کے لئے ریاضی کا استعمال () فنکشن کا استعمال کرتا ہے جو رنگ میں سرخ ، سبز اور نیلے رنگ کی مقدار کی نمائندگی کرتا ہے۔اس کے بعد یہ انھیں کوما اور قوسین کے ساتھ ایک تار میں جوڑتا ہے۔ یہاں بے ترتیب آر جی بی کلور فنکشن کا ایک مثال استعمال: جاوا اسکرپٹکونسٹ رنگ = رینڈم آر جی بی کلور () ؛ کنسول.لوگ (رنگ) ؛// \"آر جی بی (123 ، 45 ، 67)\" \"اس مثال میں ، ہم رینڈم آر جی بی کلر فنکشن کا استعمال کرتے ہوئے آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرتے ہیں ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔ نوٹ کریں کہ آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرنے کے اور بھی طریقے موجود ہیں۔جاوا اسکرپٹ میں ، جیسے نمبروں کو ہیکساڈیسیمل اشارے میں تبدیل کرنے کے لئے ٹاسٹرنگ (16) کے طریقہ کار کا استعمال کرنا یا پیڈ اسٹارٹ () کے طریقہ کار کا استعمال اس بات کو یقینی بنانے کے لئے کہ تار کی لمبائی کم از کم 6 ہے۔ طریقہ کا انتخاب مسئلہ کی مخصوص ضروریات پر منحصر ہے اورحل کی کارکردگی کی خصوصیات"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار کسی اور تار کا اناگرام ہے۔",
        "Answer": "یہ چیک کرنا کہ کیا دی دی گئی تار جاوا اسکرپٹ میں کسی اور تار کا اناگرام ہے یا یہ چیک کریں کہ آیا دی دیئے گئے تار جاوا اسکرپٹ میں کسی اور تار کا انگور ہے ، ہم مختلف طریقوں کو استعمال کرسکتے ہیں جیسے تاروں کو چھانٹنا اور ان کا موازنہ کرنا ، ہیش ٹیبل کا استعمال کرتے ہوئے تعدد کو گننے کے لئے ہیش ٹیبل کا استعمال کرتے ہوئےحرف ، یا اسپلٹ () ، ترتیب () کو ترتیب دینے اور () کے طریقوں کو استعمال کرتے ہوئے تاروں کو معمول پر لانے اور ان کا موازنہ کرنے کے طریقوں کا استعمال کریں۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: گیکسفورجیکس ویب سائٹ اس بات کی ایک مثال پیش کرتی ہے کہ آیا دی دیئے گئے تار جاوا اسکرپٹ میں کسی اور تار کا اناگرام ہے یا نہیں۔مثال کے طور پر دو افعال شامل ہیں جو تاروں کو معمول پر لانے اور ان کا موازنہ کرنے کے لئے اسپلٹ () ، ترتیب () اور اس میں شامل () طریقوں کا استعمال کرتے ہیں۔ کوئیک ریف.می ویب سائٹ اس بات کی ایک مثال فراہم کرتی ہے کہ آیا جاوا اسکرپٹ میں دو ڈورز اے اینگرام ہیں یا نہیں۔ون لائن کوڈ کا ٹکڑا جو ٹولور کیس () ، اسپلٹ () ، ترتیب () ، اور شامل () طریقوں کا استعمال کرتا ہے۔ W3reSource ویب سائٹ اس بات کی ایک مثال فراہم کرتی ہے کہ آیا دی دیئے گئے تار میں جاوا اسکرپٹ میں دیئے گئے اسٹرنگ کا استعمال کرتے ہوئے کسی اور تار کا اناگرام ہے یا نہیں۔ٹولور کیس () ، تبدیل کریں () ، اسپلٹ () ، ترتیب () ، اور () طریقوں کو تبدیل کریں۔ یہاں کسی فنکشن کی مثال کے طور پر یہ جانچ پڑتال کی جاسکتی ہے کہ آیا دیئے گئے تار میں جاوا اسکرپٹ میں کسی اور تار کا اناگرام ہے جو اسپلٹ () کا استعمال کرتے ہیں ، ترتیب دیتے ہیں۔() ، اور اس میں شامل ہوں () طریقوں: جاوا اسکرپٹ فنکشن اسانگگرام (str1 ، str2) {constrize = str => str.tolowercace (). تبدیل کریں (/[^a-z0-9]/gi ، '') .split (')') .Sort (). شامل ہوں (' ') ؛واپس معمول بنائیں (str1) === معمول بنائیں (str2) ؛} اس مثال میں ، ہم ایک اسانگگرام فنکشن کی وضاحت کرتے ہیں جو دو ڈور str1 اور str2 کو دلائل کے طور پر لیتا ہے اور اگر وہ ایک دوسرے کے اناگرام ہیں ، اور غلط ہیں تو وہ سچ ہیں۔فنکشن سب سے پہلے ایک معمول کے فنکشن کی وضاحت کرتا ہے جو تمام غیر الفانومرک کرداروں کو تار سے ہٹاتا ہے ، اسے چھوٹے سے کیس میں تبدیل کرتا ہے ، اسے کرداروں کی ایک صف میں تقسیم کرتا ہے ، صف کو ترتیب دیتا ہے ، اور اسے دوبارہ تار میں شامل کرتا ہے۔اس کے بعد یہ فنکشن دونوں تار کو معمول پر لانے اور ان کا موازنہ کرنے کے لئے معمول کے فنکشن کا استعمال کرتا ہے۔ یہاں اسانگگرام فنکشن کا ایک مثال استعمال ہے: جاوا اسکرپٹ کنسول۔ لوگ (اسانگگرام ('آئس مین' ، 'سنیما')) ؛// trueconsole.log (isanagram ('ہیلو' ، 'دنیا')) ؛// اس مثال کے طور پر ، ہم یہ چیک کرتے ہیں کہ آیا اسناگرام فنکشن کا استعمال کرتے ہوئے کسی اور سٹرنگ کا ایک انگور ہے ، جس کا نتیجہ کنسول پر لاگ ان ہوتا ہے۔ نوٹ کریں کہ یہ چیک کرنے کے اور بھی طریقے موجود ہیں کہ آیا دی دیئے گئے تار جاوا اسکرپٹ میں کسی اور تار کا اناگرام ہے یا نہیں۔، جیسے حروف کی تعدد کو گننے کے لئے ہیش ٹیبل کا استعمال کرنا یا تاروں کو چھانٹنا اور ان کا موازنہ کرنا۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں ہر کردار کی موجودگی کو گننے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے تار میں ہر کردار کی موجودگی کی گنتی کرنا جاوا اسکرپٹ میں دیئے گئے تار میں ہر کردار کی موجودگی کو گنتی ہے ، ہم مختلف نقطہ نظر کو استعمال کرسکتے ہیں جیسے لوپ کے لئے ایک لوپ کا استعمال کرتے ہوئے تار کے اوپر تکرار کرتے ہیں اور ہر کردار کی تعدد کو گنتے ہیں ، اور ہر کردار کی تعدد گنتے ہیں ،ہر کردار کی فریکوئنسی کو ذخیرہ کرنے کے لئے ایک ہیش ٹیبل ، یا اسٹرنگ کو حروف کی ایک صف میں تقسیم کرنے اور ہر کردار کی تعدد کو گننے کے لئے کم () طریقہ استعمال کرنے کے لئے اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے۔یہاں کچھ وسائل ہیں جو اس کی مثالیں فراہم کرتے ہیں کہ یہ کیسے کریں: پروگرامیز ویب سائٹ جاوا اسکرپٹ میں دیئے گئے تار میں ہر کردار کی موجودگی کو کس طرح گننا ہے اس کی ایک مثال پیش کرتی ہے۔مثال کے طور پر ایک فنکشن شامل ہے جو ایک ان پٹ کے طور پر تار لیتا ہے اور لوپ کے لئے A کا استعمال کرتے ہوئے ہر کردار کی فریکوئنسی گنتا ہے۔ اسٹیک اوور فلو ویب سائٹ جاوا اسکرپٹ کا استعمال کرتے ہوئے اسٹرنگ میں حروف کی فریکوئنسی کو کس طرح گننے کے بارے میں ایک بحث فراہم کرتی ہے۔اس بحث میں ہر کردار کی تعدد کو ذخیرہ کرنے کے لئے ہیش ٹیبل یا کسی صف کو استعمال کرنے کی مثالیں شامل ہیں۔ W3DOCS ویب سائٹ جاوا اسکرپٹ کا استعمال کرتے ہوئے تار میں تار کی موجودگی کو کس طرح گننے کی ایک مثال پیش کرتی ہے۔مثال میں ایک فنکشن شامل ہوتا ہے جو ان پٹ کے طور پر ایک تار اور ایک سٹرنگ لیتا ہے اور اس کی تعداد کو گنتی کرتی ہے جس میں سٹرنگ سٹرنگ میں میچ () کے طریقہ کار کا استعمال کرتے ہوئے ظاہر ہوتا ہے۔ ہر کردار کی موجودگی کو کسی دیئے گئے میں گننے کے لئے کسی فنکشن کی ایک مثال کے طور پر عمل درآمد ہوتا ہے۔ہیش ٹیبل کا استعمال کرتے ہوئے جاوا اسکرپٹ میں سٹرنگ: جاوا اسکرپٹ فنکشن کاؤنٹ چیریکٹر (ایس ٹی آر) {کونسٹ فریک = {} ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛فریک [چار] = فریک [چار]؟فریک [چار] + 1: 1 ؛fre فریک کو واپس کریں ؛ اس مثال میں ، ہم ایک کاؤنٹ چکروں کے فنکشن کی وضاحت کرتے ہیں جو ایک دلیل کے طور پر اسٹرنگ ایس ٹی آر لیتا ہے اور کسی ایسی شے کو لوٹاتا ہے جس میں تار میں ہر کردار کی فریکوئینسی ہوتی ہے۔فنکشن ہر کردار کی فریکوئنسی کو ذخیرہ کرنے کے لئے ایک خالی آبجیکٹ فریک کی ابتدا کرتا ہے۔اس کے بعد یہ لوپ کے لئے ایک تار کے اوپر تکرار کرنے کے لئے استعمال کرتا ہے اور ہیش ٹیبل کا استعمال کرتے ہوئے ہر کردار کی تعدد گنتا ہے۔اگر کردار پہلے ہی ہیش ٹیبل میں ہے تو ، اس کی تعدد 1 سے بڑھ جاتی ہے۔ اگر کردار ہیش ٹیبل میں نہیں ہے تو ، اس میں اس کی تعدد کے ساتھ شامل ہوتا ہے۔'ہیلو ورلڈ') ؛ کنسول.لوگ (فریک) ؛// {H: 1 ، E: 1 ، L: 3 ، O: 2 ، '': 1 ، W: 1 ، R: 1 ، 1 ، D: 1} اس مثال میں ، ہم ہر کردار کی موجودگی کو ایک دیئے گئے میں گنتے ہیںکاؤنٹی چکروں کے فنکشن کا استعمال کرتے ہوئے اسٹرنگ ، کنسول پر نتیجہ لاگ ان کریں۔ نوٹ کریں کہ جاوا اسکرپٹ میں دیئے گئے تار میں ہر کردار کی موجودگی کو گننے کے لئے اور بھی طریقے موجود ہیں ، جیسے ہر کردار کی تعدد کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرنا یا اسپلٹ کا استعمال (اسپلٹ کا استعمال کرنا () ہر کردار کی تعدد کو گننے کے لئے تار کو حرفوں کی ایک صف میں تقسیم کرنے اور کم () طریقہ استعمال کرنے کا طریقہ۔طریقہ کا انتخاب مسئلے کی مخصوص ضروریات اور حل کی کارکردگی کی خصوصیات پر منحصر ہے۔"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو بائنری سرچ ٹری کی نمائندگی کرتا ہے۔ نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "جاوا اسکرپٹ جاواس اسکرپٹ کلاس نوڈ میں بائنری سرچ ٹری کو نافذ کرنا {کنسٹرکٹر (قدر) {this.value = value ؛this.left = null ؛this.right = null ؛}} کلاس بائنری سرچ ٹری {کنسٹرکٹر () {this.root = null ؛} داخل کریں (قیمت) {کونسٹ نوڈ = نیا نوڈ (قدر) ؛اگر (! this.root) {this.root = نوڈ ؛اس کو واپس کریں ؛current موجودہ = this.root ؛جبکہ (سچ) {اگر (قدر === موجودہ۔ قیمت) غیر واضح شدہ واپس ؛if (value <موجودہ.Value) {if (! موجودہ. لیفٹ) {موجودہ. لیفٹ = نوڈ ؛اس کو واپس کریں ؛} موجودہ = کرنٹ. لیفٹ ؛} else {if (! موجودہ. رائٹ) {موجودہ. رائٹ = نوڈ ؛اس کو واپس کریں ؛} موجودہ = موجودہ۔ رائٹ ؛}}} تلاش کریں (قدر) {اگر (! this.root) غلط لوٹیں ؛آئیے موجودہ = this.root ؛ملنے دو = غلط ؛جبکہ (موجودہ &&! ملا) {اگر (قدر <موجودہ۔ ویلیو) {موجودہ = موجودہ۔ لیفٹ ؛} دوسری صورت میں اگر (ویلیو> کرنٹ۔ ویلیو) {موجودہ = موجودہ۔ رائٹ ؛} else {found = سچ ؛}} if (! found) غلط لوٹ ؛موجودہ واپسی ؛} ہٹائیں (قیمت) {کونسٹ ہٹنے والا = (نوڈ ، ویلیو) => {اگر (! نوڈ) {واپس کال کریں ؛} if (value === node.value) {if (! node.left &&! node.right) {واپس واپس ؛} if (! node.left) {واپسی نوڈ. رائٹ ؛} if (! node.right) {واپسی node.left ؛temp tempnode = node.right ؛جبکہ (tempnode.left) {tempnode = temp"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دی گئی تعداد ایک بہترین نمبر ہے (اس کے تقسیم کاروں کا مجموعہ اس نمبر کے برابر ہے)۔",
        "Answer": "یہاں یہ چیک کرنے کے لئے ایک ازگر فنکشن ہے کہ آیا دیئے گئے نمبر ایک بہترین نمبر ہے یا نہیں۔ایک کامل تعداد ایک مثبت عدد ہے جو اس کے مناسب مثبت تفریقوں کے جوہر کے برابر ہے ، یعنی ، اس کے مثبت تفریقوں کا مجموعہ جس میں خود کو چھوڑ کر 1۔پیتھنڈف آئسپر فیکٹ نمبر (این): کم رینج (1 ، این این کے لئے رقم = 0): اگر n ٪ i == 0: SUM += I واپس واپس == اوپر کی تقریب میں ایک انٹیجر ان پٹ لیتا ہے اور متغیر رقم کو 0 پر شروع کرتا ہے۔ اس کے بعد لوپ کے لئے A کا استعمال 1 سے N- تک تمام نمبروں پر تکریٹ کرنے کے لئے کرتا ہے۔1 اور چیک کرتا ہے کہ اگر N موجودہ نمبر کے ذریعہ تقسیم ہے۔اگر یہ ہے تو ، موجودہ نمبر کو SUM متغیر میں شامل کیا جاتا ہے۔آخر میں ، اگر تقسیم کرنے والوں کا مجموعہ ان پٹ نمبر N کے برابر ہے تو یہ کام درست ہوجاتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ یہ ایک بہترین نمبر ہے۔بصورت دیگر ، یہ غلط 123 لوٹتا ہے۔} ایک کامل نمبر ہے \") اور: پرنٹ (f\" {n} ایک کامل نمبر نہیں ہے \") یہ پروگرام پہلے صارف سے ایک عدد ان پٹ لیتا ہے اور پھر اسپر فیکٹ نمبر () فنکشن کو فون کرتا ہے کہ آیا ان پٹ نمبر کامل ہے یا نہیںنمبر یا نہیں۔اس کے بعد یہ ایک پیغام پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا نمبر ایک بہترین نمبر ہے یا نہیں۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں اسٹرنگ کے واقعات کی تعداد کو گننے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "کسی دیئے گئے تار میں کسی اسٹرنگ کی موجودگی کی تعداد کو گننے کے لئے جاوا اسکرپٹ کا فنکشن یہ ہے۔اس کو حاصل کرنے کے بہت سارے طریقے ہیں ، لیکن ایک عام نقطہ نظر یہ ہے کہ اسٹرنگ میں سٹرنگ کی تلاش کے ل the انڈیکس () کے طریقہ کار کو استعمال کریں اور اس کی تعداد کو گنیں۔آئیے انڈیکس = str.indexof (سبسٹر) ؛جبکہ (انڈیکس! == -1) {گنتی ++ ؛انڈیکس = str.indexof (سبسٹر ، انڈیکس + 1) ؛} واپسی کی گنتی ؛} مذکورہ فنکشن میں دو تار ان پٹ لیتے ہیں: STR تلاش کرنے کے لئے تار ہے ، اور سبسٹر تلاش کرنے کے لئے سٹرنگ ہے۔یہ ایک متغیر گنتی کو 0 پر شروع کرتا ہے اور انڈیکسف () کے طریقہ کار کا استعمال کرتے ہوئے اسٹرنگ میں سٹرنگ کی بار بار تلاش کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ سٹرنگ اب نہیں مل پائے ، اس مقام پر فنکشن واقعات 1234 کی آخری گنتی لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ اے میں کسی ذخیرے کی تعداد کو گننے کے لئے کاؤنٹوکورینس () فنکشن کو کس طرح استعمال کیا جائے۔دیئے گئے تار: جاوا اسکرپٹلیٹ str = \"کوئیک براؤن فاکس سست کتے کے اوپر چھلانگ لگاتا ہے\" ؛ سبسٹر = \"دی\" آئیے کاؤنٹ = کاؤنٹوکورنس (ایس ٹی آر ، سبسٹر) ؛ کنسول.لوگ (`\" $ {سبسٹر} \"ظاہر ہوتا ہے $ {گنتی\"\" {{str} \"`) میں اوقات ؛ یہ پروگرام سب سے پہلے تلاش کرنے کے لئے سٹرنگ ایس ٹی آر اور ایک سٹرنگ سبسٹر کی ابتدا کرتا ہے۔اس کے بعد اس نے کاؤنٹوکورینس () فنکشن کو فون کیا ہے تاکہ سٹرنگ میں سٹرنگ ظاہر ہونے کی تعداد کو گننے کے ل. اور اس کے نتیجے کو متغیر گنتی میں اسٹور کیا جاتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں سٹرنگ میں اسٹرنگ کے واقعات کی تعداد کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "عدد کی ایک دی گئی صف میں سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے۔اس مسئلے کو حل کرنے کے لئے سب سے موثر الگورتھم میں سے ایک کڈانے کا الگورتھم 1234. جاوا اسکرپٹ فنکشن میکسسوبارسم (اے آر آر) ہے {آئیے میکسوفر = آر آر [0] ؛آئیے maxundHere = arr [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {maxinderHere = math.max (arr [i] ، maxinderhere+arr [i]) ؛میکسوفر = میتھ.میکس (میکسوفر ، میکسینڈیئر) ؛max میکسفار کو واپس کریں ؛ مذکورہ بالا فنکشن ان پٹ کے طور پر عدد کی ایک صف آر آر لیتا ہے اور صف میں سبری کی زیادہ سے زیادہ رقم واپس کرتا ہے۔یہ صف کے پہلے عنصر میں دو متغیرات ، میکسوفر اور میکسینڈیئر کی ابتدا کرتا ہے۔اس کے بعد یہ سرنی کے باقی عناصر پر تکرار کرنے کے لئے لوپ کے لئے A کا استعمال کرتا ہے اور موجودہ عنصر کی زیادہ سے زیادہ اور موجودہ عنصر کی رقم اور پچھلے میکسینڈ ہائر میں میکسینڈیئر متغیر کو اپ ڈیٹ کرتا ہے۔یہ میکس سافر متغیر کو موجودہ میکسوفر کی زیادہ سے زیادہ اور تازہ کاری شدہ میکسینڈی ہائیر میں بھی اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن میکس سافر متغیر کو لوٹاتا ہے ، جس میں اری 1234 میں سبری کی زیادہ سے زیادہ رقم موجود ہوتی ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ میکسسوبراسم () فنکشن کو کس طرح استعمال کیا جائے۔انٹیجرز: جاوا اسکرپٹ لیٹ آر = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، 1 ، -5 ، 4] ؛ آئیے میکسم = میکسبرسم (اے آر آر) ؛ کنسول.لوگ (`ایک سبری کی زیادہ سے زیادہ رقم $ میں ${arr} ہے $ {میکسم} `) ؛ یہ پروگرام سب سے پہلے عددیوں کی ایک صف کی شروعات کرتا ہے۔اس کے بعد یہ سرے میں سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے میکسبرارسم () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر میکسم میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں سرے میں سب سے زیادہ کی رقم کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "دیئے گئے بائنری نمبر کو اعشاریہ میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "دیئے گئے بائنری نمبر کو اعشاریہ میں تبدیل کرنے کے لئے یہاں جاوا اسکرپٹ فنکشن ہے۔اس کو حاصل کرنے کے بہت سارے طریقے ہیں ، لیکن ایک عام نقطہ نظر یہ ہے کہ وہ مقاماتی اشارے کے طریقہ کار کو استعمال کریں ، جہاں بائنری نمبر کا ہر ہندسہ 2 کی مناسب طاقت سے کئی گنا بڑھ جاتا ہے اور نتائج کا خلاصہ کیا جاتا ہے۔0 ؛بیس = 1 ؛جبکہ (بائنری> 0) {آئیے لسٹ ڈائیگٹ = بائنری ٪ 10 ؛بائنری = ریاضی۔ فلور (بائنری / 10) ؛اعشاریہ += لسٹ ڈیجیٹ * بیس ؛بیس *= 2 ؛dec اعشاریہ واپسی ؛ مذکورہ بالا فنکشن بائنری نمبر بائنری کو ان پٹ کے طور پر لیتا ہے اور بائنری نمبر کے اعشاریہ برابر کے برابر لوٹاتا ہے۔یہ بالترتیب 0 اور 1 میں دو متغیرات ، اعشاریہ اور اڈے کی ابتدا کرتا ہے۔اس کے بعد ماڈیولو آپریٹر کا استعمال کرتے ہوئے بائنری نمبر کے آخری ہندسے کو بار بار نکالنے کے لئے تھوڑی دیر کا استعمال ہوتا ہے اور بائنری نمبر میں اس کی پوزیشن کی بنیاد پر اسے 2 کی مناسب طاقت کے ذریعہ ضرب لگاتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ بائنری نمبر 0 تک کم نہ ہوجائے ، جس مقام پر فنکشن حتمی اعشاریہ ویلیو 1234 کو واپس کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ بائنری ٹوڈسیمل () فنکشن کو بائنری نمبر کو اعشاریہ میں تبدیل کرنے کے لئے کس طرح استعمال کیا جائے: جاوا اسکرپٹ بائنری =1101 ؛ اعشاریہ = بائنری ٹوڈیسیمل (بائنری) ؛ کنسول.لوگ (`$ {بائنری} کے اعشاریہ مساوی $ {اعشاریہ}` ہے) ؛ یہ پروگرام سب سے پہلے بائنری نمبر بائنری کو شروع کرتا ہے۔اس کے بعد یہ بائنری ٹوڈیسیمل () فنکشن کو بائنری نمبر کو اعشاریہ میں تبدیل کرنے کے لئے کہتے ہیں اور اس کے نتیجے کو متغیر اعشاریہ میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جو بائنری نمبر کے اعشاریہ مساوی کی نشاندہی کرتا ہے۔"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو ایک سیٹ ڈیٹا ڈھانچے کی نمائندگی کرے۔ شامل کرنے ، ہٹانے اور چیک کرنے کے طریقوں کو نافذ کریں کہ آیا کوئی عنصر موجود ہے یا نہیں۔\"",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے لئے جو ایک سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، ہم جاوا اسکرپٹ 1234 میں بلٹ ان سیٹ آبجیکٹ کا استعمال کرسکتے ہیں۔سیٹ آبجیکٹ ہمیں انوکھی اقدار کا ایک مجموعہ بنانے کی اجازت دیتا ہے ، جہاں ہر قیمت صرف ایک بار ہوسکتی ہے۔ہم سیٹ میں عناصر کو شامل کرنے کے لئے ADD () کا طریقہ استعمال کرسکتے ہیں ، سیٹ سے عناصر کو ہٹانے کے لئے حذف () کا طریقہ ، اور یہ جانچنے کے لئے () طریقہ () کا طریقہ ہے کہ آیا کوئی عنصر سیٹ 1234 میں موجود ہے یا نہیں۔جاوا اسکرپٹ میں کلاس: جاوا اسکرپٹ کلاس سیٹ {کنسٹرکٹر () {this.items = نیا سیٹ () ؛} شامل کریں (عنصر) {this.items.add (عنصر) ؛} حذف (عنصر) {this.items.delete (عنصر) ؛} ہے (عنصر) {اس کو واپس کریں۔}} مذکورہ کلاس تین طریقوں کے ساتھ ایک سیٹ کلاس کی وضاحت کرتی ہے: شامل کریں () ، حذف کریں () ، اور () ()۔کنسٹرکٹر () کا طریقہ سیٹ کے عناصر کو ذخیرہ کرنے کے لئے ایک نیا سیٹ آبجیکٹ شروع کرتا ہے۔ADD () کا طریقہ سیٹ میں ایک عنصر کو شامل کرتا ہے ، حذف () کا طریقہ سیٹ سے کسی عنصر کو ہٹاتا ہے ، اور اگر () سیٹ میں کوئی عنصر موجود ہوتا ہے تو () کا طریقہ چیک کرتا ہے۔یہ طریقے اپنے آپریشنز 1234 کو انجام دینے کے لئے بلٹ ان سیٹ آبجیکٹ کے متعلقہ طریقوں کا استعمال کرتے ہیں۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ سیٹ کلاس کو کس طرح سیٹ بنانے کے لئے استعمال کیا جائے ، اس میں عناصر کو شامل کریں ، اور چیک کریں کہ آیااس میں ایک عنصر موجود ہے: جاوا اسکرپٹ لیٹ مائی سیٹ = نیا سیٹ () ؛ myset.add (1) ؛ myset.add (2) ؛ myset.add (3) ؛ کنسول.لوگ (myset.has (2)) ؛// truemyset.delete (2) ؛ کنسول.لوگ (myset.has (2)) ؛// فالسیتیس پروگرام پہلے ایک نیا سیٹ آبجیکٹ مائی سیٹ تیار کرتا ہے۔اس کے بعد یہ ADD () کے طریقہ کار کا استعمال کرتے ہوئے سیٹ میں تین عناصر شامل کرتا ہے اور اگر عنصر 2 سیٹ میں موجود ہے () کے طریقہ کار کا استعمال کرتے ہوئے سیٹ میں موجود ہے۔اس کے بعد یہ عنصر 2 کو حذف () کے طریقہ کار کا استعمال کرتے ہوئے سیٹ سے ہٹاتا ہے اور اگر عنصر 2 سیٹ میں موجود ہے تو دوبارہ چیک کریں۔آخر میں ، یہ کنسول پر () کے طریقہ کار کے نتائج پرنٹ کرتا ہے ۔1 کوڈڈامن 2 جی آئی ٹی کنیکیٹڈ 3 فلاویوکوپیس 4 ایموزیلہ"
    },
    {
        "Question": "کسی صف کے اختتام تک پہنچنے کے لئے درکار چھلانگ کی کم سے کم تعداد تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں کسی صف کے اختتام تک پہنچنے کے لئے درکار چھلانگ کی کم سے کم تعداد تلاش کرنے کے ل we ، ہم لالچی نقطہ نظر 12 استعمال کرسکتے ہیں۔یہاں ایک سرنی کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگوں کی تلاش کے ل a کسی فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فانکشن منجپس (اے آر آر) {آئیے n = arr.length ؛اگر (n <= 1) {واپس 0 ؛} if (arr [0] === 0) {واپسی -1 ؛max میکسریچ = آر آر [0] ؛آئیے قدم = arr [0] ؛آئیے چھلانگ = 1 ؛کے لئے (آئیے i = 1 ؛ i <n ؛ i ++) {اگر (i === n - 1) {واپس چھلانگ ؛} میکسریچ = ریاضی۔ میکس (میکسریچ ، آئی + آر آر [i]) ؛مرحلہ-- ؛اگر (مرحلہ === 0) {جمپ ++ ؛اگر (i> = میکسریچ) {واپسی -1 ؛} مرحلہ = میکسریچ - i ؛}} ریٹرن -1 ؛} مذکورہ بالا فنکشن ان پٹ کے طور پر غیر منفی عدد کی ایک سرنی آر آر لیتا ہے اور صف کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگ کی کم سے کم تعداد واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا سرنی کی لمبائی 1 سے کم یا اس کے برابر ہے ، اس صورت میں یہ واپس آجاتی ہے۔ یہ بھی چیک کرتا ہے کہ آیا سرنی کا پہلا عنصر 0 ہے ، اس صورت میں یہ واپس آجاتا ہے۔اس کے بعد یہ تین متغیرات ، میکسریچ ، قدم اور چھلانگ کو سرنی کے پہلے عنصر پر شروع کرتا ہے۔یہ صف کے باقی عناصر پر تکرار کرنے کے لئے لوپ کے لئے A کا استعمال کرتا ہے اور میکسریچ متغیر کو موجودہ میکسریچ کی زیادہ سے زیادہ اور موجودہ انڈیکس کی رقم اور اس انڈیکس کی قیمت کو اپ ڈیٹ کرتا ہے۔یہ لوپ کے ہر تکرار کے لئے مرحلہ متغیر کو بھی کم کرتا ہے۔اگر مرحلہ متغیر 0 بن جاتا ہے تو ، یہ چھلانگ متغیر میں اضافہ کرتا ہے اور چیک کرتا ہے کہ اگر موجودہ انڈیکس میکسریچ متغیر سے زیادہ یا اس کے برابر ہے ، اس صورت میں یہ -1 واپس آجاتا ہے۔بصورت دیگر ، یہ میکسریچ متغیر اور موجودہ انڈیکس کے مابین فرق کو اپ ڈیٹ کرتا ہے۔آخر میں ، فنکشن -1 لوٹتا ہے -1 اگر سرنی کا اختتام قابل رسائ نہیں ہے ، یا حتمی جمپ ویلیو اگر یہ قابل رسا ہے۔ایک صف کے اختتام تک پہنچنے کی ضرورت ہے: جاوا اسکرپٹ لیٹ آر = [1 ، 3 ، 5 ، 8 ، 9 ، 2 ، 6 ، 7 ، 6 ، 8 ، 9] ؛ منجومپس نیڈ = منجپس (اے آر آر) ؛ کنسول.لاگ (``$ {arr} کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگ کی ضرورت $ {minjumpsneeded `` ہے) ؛ یہ پروگرام پہلے غیر منفی عدد کی ایک صف کی شروعات کرتا ہے۔اس کے بعد یہ سرنی کے اختتام تک پہنچنے کے لئے درکار چھلانگ کی کم سے کم تعداد تلاش کرنے کے لئے منجپس () فنکشن کو کال کرتا ہے اور اس کے نتیجے میں متغیر منجپسنیڈڈ میں ہوتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں اشارہ کیا جاتا ہے کہ سرنی کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگ کی ضرورت ہے۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار ایک درست قوسین کی ترتیب ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دی دی گئی تار جاوا اسکرپٹ میں ایک درست قوسین کی ترتیب ہے ، ہم افتتاحی قوسین کو ٹریک رکھنے کے لئے اسٹیک ڈیٹا ڈھانچے کا استعمال کرسکتے ہیں اور جانچ پڑتال کرسکتے ہیں کہ آیا ہر اختتامی قوسین حالیہ افتتاحی قوسین 123 سے میل کھاتا ہے۔یہاں ایک فنکشن کا ایک مثال عمل ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک درست قوسین کی ترتیب ہے: جاوا اسکرپٹ فکشن isvalidparentheses (s) {چلو اسٹیک = [] ؛کے لئے (آئیے i = 0 ؛ i <s.length ؛ i ++) {if (s [i] === '(' || s [i] === '{' || s [i] === '[') {stack.push (s [i]) ؛} else {if (stac.length === 0) {غلط لوٹ ؛} let = stack.pop () ؛ if ((s [i] === ')' && آخری! == '(') || (s [i] === '}' && آخری! == '{') || (s [i] === ']' & & آخری! == '['))) {غلط لوٹائیں ؛}}} ریٹرن اسٹیک۔ لمبائی === 0 ؛} مذکورہ بالا فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر سٹرنگ ایک درست قوسین کی ترتیب ہے ، یا غلط ہے۔یہ ایک خالی اسٹیک کی ابتدا کرتا ہے اور تار میں ہر کردار پر تکرار کے ل l لوپ کے لئے استعمال کرتا ہے۔ اگر موجودہ کردار افتتاحی قوسین ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔ اگر موجودہ کردار بند ہونے والی قوسین ہے تو ، فنکشن چیک کرتا ہے اگر اسٹیک اسٹیکخالی ہے ، اس معاملے میں یہ غلط لوٹتا ہے۔ پھر یہ اسٹیک سے حالیہ سب سے حالیہ قوسین کو پاپ کرتا ہے اور چیک کرتا ہے کہ اگر یہ موجودہ بند ہونے والی قوسین سے مماثل ہے۔ اگر یہ مماثل نہیں ہے تو ، فنکشن غلط لوٹتا ہے۔اسٹیک خالی ہے ، جس سے یہ ظاہر ہوتا ہے کہ تمام افتتاحی قوسین کو بند کرنے والے قوسین 123 کے ساتھ مماثل کیا گیا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ آئی ایس ویلیڈ پیرنٹیسیس () فنکشن کو کس طرح استعمال کیا جائے یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک درست قوسین کی ترتیب ہے: جاوا اسکرپٹ ایس = \"())[] {} \"؛ آئیے isvalid = isvalidparentheses (s) ؛ کنسول.لوگ (` \"$ {s}\" کیا $ {isvalid ہے؟'A': 'نہیں'} درست قوسین کی ترتیب`) ؛ یہ پروگرام پہلے ایک تار کی شروعات کرتا ہے جس میں قوسین کی ترتیب پر مشتمل ہوتا ہے۔اس کے بعد یہ یہ چیک کرنے کے لئے isvalidperentheses () فنکشن کو کال کرتا ہے کہ آیا تار ایک درست قوسین کی ترتیب ہے اور اس کے نتیجے کو متغیر isvalid میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا تار ایک درست قوسین کی ترتیب ہے یا نہیں۔"
    },
    {
        "Question": "میمورائزیشن کا استعمال کرتے ہوئے N-TH Fibonacci نمبر کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں میموائزیشن کا استعمال کرتے ہوئے N-TH Fibonacci نمبر کا حساب لگانے کے لئے ، ہم ایک ایسی تکنیک استعمال کرسکتے ہیں جو پچھلے حساب کتاب کے نتائج کو کیشے میں ذخیرہ کرتا ہے تاکہ بے کار حساب کتاب 12345 سے بچ سکے۔یادداشت کا استعمال کرتے ہوئے N-TH Fibonacci نمبر کا حساب لگانے کے لئے ایک فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فینکشن Fibonacci (N ، Cache = {}) {اگر (n میں کیشے میں) {واپسی کیش [n] ؛} if (n <2) {واپسی n ؛} کیشے [n] = fibonacci (n - 1 ، کیشے) + fibonacci (n - 2 ، کیشے) ؛واپسی کیشے [n] ؛} مذکورہ فنکشن پچھلے حساب کے نتائج کو ذخیرہ کرنے کے لئے ان پٹ اور اختیاری کیشے آبجیکٹ کے طور پر ایک مثبت عددی n لیتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا N کا نتیجہ پہلے ہی کیشے میں ہے ، ایسی صورت میں یہ کیشڈ نتیجہ لوٹاتا ہے۔اس کے بعد یہ چیک کرتا ہے کہ اگر n 2 سے کم ہے ، تو اس صورت میں یہ واپس آجاتا ہے۔بصورت دیگر ، یہ N-1 اور N-2 کے لئے Fibonacci () فنکشن کو بار بار کال کرکے N کے نتائج کا حساب لگاتا ہے ، اور کیشے آبجیکٹ کو ایک دلیل کے طور پر منظور کرتا ہے۔اس کے بعد یہ نتیجہ کیشے آبجیکٹ میں محفوظ کرتا ہے اور آئی ٹی 12345 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ میموائزیشن کا استعمال کرتے ہوئے N-Th fibonacci نمبر کا حساب لگانے کے لئے Fibonacci () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ n = 10 ؛ Fib = fibonacci (letn) ؛ کنسول.لوگ (`{{n} -th fibonacci نمبر $ {fib}` ہے) ؛ یہ پروگرام پہلے ایک مثبت عددی n شروع کرتا ہے۔اس کے بعد یہ میموئزیشن کا استعمال کرتے ہوئے N-TH Fibonacci نمبر کا حساب لگانے کے لئے Fibonacci () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر FIB میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں N-TH Fibonacci نمبر .1mtsknn2stackoverflow3SitePoint4educative5oreilly کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "تار کے ایک سیٹ میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں تاروں کے ایک سیٹ میں سب سے طویل عام لاحقہ تلاش کرنے کے ل we ، ہم سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے اسی طرح کا نقطہ نظر استعمال کرسکتے ہیں ، لیکن ہمیں پہلے 12 کے ڈور کو پلٹانے کی ضرورت ہے۔تاروں کے ایک سیٹ میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے کسی فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن سب سے طویل عرصے سے کامنسفکس (ڈور) {الٹ اسٹرنگز = اسٹرنگز۔ میپ (str => str.split (''). ریورس ()۔ شامل ہوں ()۔')) ؛آئیے پریفکس = طویل عرصے سے کاممون پریفکس (الٹ سٹرنگس) ؛واپس پریفکس.سپلٹ ('')۔ ریورس ()۔ شامل ہوں ('') ؛} فنکشن طویل ترین کامومن پریفکس (ڈور) {اگر (تارنگ۔ لمبائی === 0) {واپسی '' ؛pref لیٹ پریفکس = ڈور [0] ؛کے لئے (آئیے i = 1 ؛ i <strings.length ؛ i ++) {جبکہ (ڈور [i] .indexof (سابقہ)! == 0) {پریفکس = پریفکس.سوبسٹرنگ (0 ، سابقہ۔ لمبائی - 1) ؛اگر (سابقہ === '') {واپس '' ؛}}} ریٹرن پریفکس ؛} مذکورہ کوڈ دو افعال کی وضاحت کرتا ہے: سب سے طویل عرصے سے کامنسفکس () اور سب سے طویل کامومن پریفکس ()۔سب سے طویل عرصے سے کامنسفکس () فنکشن ان پٹ کے طور پر تار کے تاروں کی ایک صف لیتا ہے اور ڈور میں سب سے طویل عام لاحقہ لوٹاتا ہے۔یہ سب سے پہلے سرے میں ہر تار کو الٹ دیتا ہے اور اس کے نتیجے میں ایک نئی سرنی الٹ اسٹرنگز میں اسٹور کرتا ہے۔اس کے بعد یہ سب سے طویل عرصے سے عام لاحقہ حاصل کرنے کے ل long الٹ ترین تاروں کے ساتھ طویل عرصے سے کام کرنے والے () کے فنکشن کو الٹ تاروں کے ساتھ کہتے ہیں ، اور سب سے طویل مشترکہ لاحقہ حاصل کرنے کے لئے نتیجہ کو تبدیل کرتا ہے۔سب سے طویل عرصے سے کام کرنے والا فنکشن ان پٹ کے طور پر تاروں کے تاروں کی ایک صف لیتا ہے اور تار کے درمیان سب سے طویل عام ماقبل کو لوٹاتا ہے۔یہ سرنی میں پہلی تار کے لئے سابقہ متغیر کی ابتدا کرتا ہے اور باقی ڈوروں پر تکرار کرنے کے لئے لوپ کے لئے A کا استعمال کرتا ہے۔اس کے بعد یہ بار بار آخری کردار کو سابقہ متغیر سے ہٹاتا ہے جب تک کہ یہ موجودہ تار کا ایک سابقہ نہ ہو۔اگر سابقہ متغیر خالی ہوجاتا ہے تو ، فنکشن خالی تار لوٹاتا ہے۔آخر میں ، فنکشن سابقہ متغیر کو لوٹاتا ہے ، جس میں اسٹرنگز 12 کے درمیان سب سے طویل عام سابقہ ہوتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ تار کے ایک سیٹ میں سب سے طویل مشترکہ لاحقہ تلاش کرنے کے لئے طویل عرصے سے کامنسفکس () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ اسٹرنگز =۔یہ پروگرام سب سے پہلے ڈور کے ایک صف کے تاروں کی ابتدا کرتا ہے۔اس کے بعد اس نے تار کے درمیان سب سے طویل عام لاحقہ تلاش کرنے کے لئے طویل ترین کامنسفکس () فنکشن کو فون کیا ہے اور اس کے نتیجے میں متغیر لاحقہ کو اسٹور کیا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں تار کے درمیان سب سے طویل عام لاحقہ کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "دو ڈوروں کے درمیان ہیمنگ فاصلے کا حساب لگانے کے لئے ایک فنکشن کو نافذ کریں (ان پوزیشنوں کی تعداد جس میں متعلقہ حرف مختلف ہیں)۔",
        "Answer": "جاوا اسکرپٹ میں دو ڈوروں کے درمیان ہیمنگ فاصلے کا حساب لگانے کے ل we ، ہم دونوں ڈوروں کے متعلقہ کرداروں کا موازنہ کرسکتے ہیں اور ان پوزیشنوں کی تعداد گن سکتے ہیں جن میں وہ مختلف 12345 سے مختلف ہیں۔یہاں دو ڈوروں کے مابین ہیمنگ فاصلے کا حساب لگانے کے لئے کسی فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن ہیمنگ ڈسٹنس (str1 ، str2) {اگر (str1.length! == str2.length) {واپسی -1 ؛} دو فاصلہ = 0 ؛کے لئے (i = 0 ؛ i <str1.length ؛ i ++) {اگر (str1 [i]! == str2 [i]) {فاصلہ ++ ؛}} واپسی کا فاصلہ ؛} مندرجہ بالا فنکشن ان پٹ کے طور پر دو ڈور str1 اور str2 لیتا ہے اور دونوں ڈوروں کے درمیان ہیمنگ کا فاصلہ لوٹاتا ہے۔یہ پہلے چیک کرتا ہے کہ آیا دونوں ڈوروں کی لمبائی ایک ہی ہے ، اس صورت میں یہ -1 واپس آجاتا ہے۔اس کے بعد یہ متغیر فاصلے کو 0 سے شروع کرتا ہے اور لوپ کے ل a استعمال کرتا ہے جس میں تاروں میں ہر کردار پر تکرار ہوتا ہے۔اگر دونوں ڈوروں کے متعلقہ حرف مختلف ہیں تو ، فنکشن فاصلے کے متغیر میں اضافہ کرتا ہے۔آخر میں ، فنکشن فاصلے کے متغیر کو لوٹاتا ہے ، جس میں دو اسٹرنگس 12345 کے مابین ہیمنگ فاصلہ ہوتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ دو ڈوروں کے مابین ہیمنگ ڈسٹنس () فنکشن کو کس طرح ہیمنگ ڈسٹنس () کا استعمال کیا جائے: جاوا اسکرپٹ ایس ٹی آر 1 = 'ہیلو'str str2 = 'ورلڈ' آئیے فاصلہ = ہیمنگ ڈسٹنس (str1 ، str2) console کنسول.لاگ (`\" $ {str1} \"اور\" $ {str2} \"کے درمیان ہتھوڑا کا فاصلہ $ {فاصلہ}` ہے) ؛ یہ پروگرام ہے۔پہلے دو ڈور str1 اور str2 کی ابتدا کرتا ہے۔اس کے بعد یہ ہیمنگ ڈسٹنس () کے فنکشن کو کہتے ہیں تاکہ دونوں ڈوروں کے مابین ہیمنگ فاصلے کا حساب لگائیں اور اس کے نتیجے کو متغیر فاصلے پر اسٹور کیا جائے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں دو ڈوروں کے درمیان ہیمنگ فاصلے کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ کلاس بنائیں جو خود کار طریقے سے فعالیت کے ل tr ٹری ڈیٹا ڈھانچے کی نمائندگی کرے۔الفاظ داخل کرنے اور سابقہ تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے ل that جو خود کار طریقے سے فعالیت کے لئے ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، ہم ٹری ڈیٹا ڈھانچے کو استعمال کرسکتے ہیں۔ایک ٹری ایک درخت کی طرح ڈیٹا کا ڈھانچہ ہے جو تاروں کا ایک مجموعہ محفوظ کرتا ہے اور موثر پریفکس تلاش اور آٹومپلیٹ فعالیت 12345 کی اجازت دیتا ہے۔جاوا اسکرپٹ میں ٹری کلاس کا ایک مثال عمل ہے: جاوا اسکرپٹ کلاس ٹرینیوڈ {کنسٹرکٹر () {this.children = نیا نقشہ () ؛this.isendofword = غلط ؛}} کلاس ٹری {کنسٹرکٹر () {this.root = نیا ٹرائینوڈ () ؛} داخل کریں (لفظ) {آئیے نوڈ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.ایلتھ ؛ i ++) {آئیے چار = ورڈ [i] ؛if (! node.children.has (چار)) {node.children.set (چار ، نیا ٹرینوڈ ()) ؛} نوڈ = نوڈ.کرنین.جیٹ (چار) ؛} node.isendofword = سچ ؛} سرچ پریفکس (سابقہ) {آئیے نوڈ = this.root ؛کے لئے (آئیے i = 0 ؛ i <prefix.length ؛ i ++) {آئیے چار = سابقہ [i] ؛if (! node.children.has (چار)) {واپسی [] ؛} نوڈ = نوڈ.کرنین.جیٹ (چار) ؛this اس کو واپس کریں ۔_فینڈال ورڈز (نوڈ ، سابقہ) ؛} _findallwords (نوڈ ، سابقہ) {آئیے الفاظ = [] ؛if (node.isendofword) {words.push (سابقہ) ؛} کے لئے ([چار ، چائلڈ نوڈ] نوڈ.کرنین) {چلیں چلیں = یہ۔words.push (... بچوں کے الفاظ) ؛} واپس الفاظ ؛}} مذکورہ کوڈ دو کلاسوں کی وضاحت کرتا ہے: ٹرائنوڈ اور ٹری۔ٹرائینوڈ کلاس ٹری میں ایک نوڈ کی نمائندگی کرتی ہے اور اس میں بچوں کی جائیداد ہوتی ہے جو ہر کردار کو اپنے بچے نوڈ اور آئسینڈوف ورڈ پراپرٹی پر نقشہ بناتی ہے جو اس بات کی نشاندہی کرتی ہے کہ آیا نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے یا نہیں۔ٹری کلاس ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے اور اس کی جڑ کی جائیداد ہے جو ٹری کے جڑ نوڈ کی نمائندگی کرتی ہے۔اس کے دو طریقے بھی ہیں: داخل کریں () اور سرچ پریفکس ()۔داخل () کا طریقہ ان پٹ کے طور پر ایک تار کا لفظ لیتا ہے اور اسے تار میں ہر کردار پر تکرار کرکے اور ہر کردار کے لئے ایک نیا نوڈ تیار کرکے ٹرائی میں داخل کرتا ہے جو پہلے سے موجود نہیں ہے۔اس نے حتمی نوڈ کی آئسینڈوفورڈ پراپرٹی کو سچ پر سیٹ کیا ہے تاکہ یہ اشارہ کیا جاسکے کہ یہ لفظ مکمل طور پر ٹرائی میں داخل کیا گیا ہے۔سرچ پریفیکس () کا طریقہ ان پٹ کے طور پر سٹرنگ کا سابقہ لیتا ہے اور دیئے گئے سابقہ سے شروع ہونے والے ٹری میں موجود تمام الفاظ کی ایک صف لوٹاتا ہے۔یہ ہر ایک کردار کو ماقبل میں تکرار کرکے اور ٹری کو عبور کرتے ہوئے نوڈ کو تلاش کرنے کے لئے جو سابقہ میں آخری کردار کی نمائندگی کرتا ہے۔اس کے بعد اس نے _findallwords () کے طریقہ کار کو بار بار ان تمام الفاظ تلاش کرنے کے لئے کال کیا ہے جو آخری نوڈ سے ٹرائی کو عبور کرکے اور ہر لفظ کو صف میں شامل کرکے سابقہ الفاظ کو بار بار تلاش کرتے ہیں۔_findallwords () کا طریقہ ایک نوڈ نوڈ اور اسٹرنگ کا سابقہ ان پٹ کے طور پر لیتا ہے اور ٹری میں موجود تمام الفاظ کی ایک صف کو واپس کرتا ہے جو تریی کو بار بار عبور کرتے ہوئے اور ہر لفظ کو ایک آرنی 12345 میں شامل کرکے شروع کیا جاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹکوڈ یہ ظاہر کرتا ہے کہ الفاظ داخل کرنے اور سابقہ کی تلاش کے لئے ٹری کلاس کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ ٹری = نیا ٹری () ؛ ٹری.سرٹ ('ہیلو') ؛ ٹری.سرٹ ('ورلڈ') ؛ ٹری.نسرٹ ('ارے')؛ trie.insert ('he') ؛ الفاظ = trie.searchPrefix ('وہ') ؛ کنسول.لوگ (`الفاظ جو\" وہ \"سے شروع ہوتے ہیں: $ {الفاظ}`) ؛ یہ پروگرام پہلے ایک نیا ٹری آبجیکٹ شروع کرتا ہےٹریاس کے بعد یہ داخل () کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں چار الفاظ داخل کرتا ہے۔آخر میں ، یہ ٹری میں موجود تمام الفاظ تلاش کرنے کے لئے 'وہ' کے سابقہ کے ساتھ سرچ پرفیکس () کے طریقہ کار کو کہتے ہیں جو سابقہ سے شروع ہوتے ہیں اور اس کے نتیجے کو متغیر الفاظ میں اسٹور کرتے ہیں۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جو ان الفاظ کی نشاندہی کرتا ہے جو پریفکس کے ساتھ شروع ہوتا ہے۔"
    },
    {
        "Question": "کسی دیئے گئے صف میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے سرے میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل several ، بہت سارے نقطہ نظر ہیں۔ایک نقطہ نظر یہ ہے کہ زیادہ سے زیادہ پروڈکٹ 12 حاصل کرنے کے لئے سرے کو نزول ترتیب میں ترتیب دیں اور پھر ترتیب شدہ صف کے پہلے دو عناصر کو ضرب دیں۔ایک اور نقطہ نظر یہ ہے کہ صف کے زیادہ سے زیادہ اور دوسرے زیادہ سے زیادہ عناصر کو ٹریک رکھیں اور پھر زیادہ سے زیادہ پروڈکٹ 32 حاصل کرنے کے ل them انہیں ضرب دیں۔یہاں دوسرے نقطہ نظر کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن میکس پروڈکٹ (اے آر آر) {آئیے میکس 1 = -infinity ؛آئیے میکس 2 = -infinity ؛آئیے منٹ 1 = انفینٹی ؛منٹ 2 = انفینٹی ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {let num = arr [i] ؛اگر (num> میکس 1) {میکس 2 = میکس 1 ؛میکس 1 = نمبر ؛} ورنہ اگر (num> زیادہ سے زیادہ 2) {میکس 2 = نمبر ؛} if (num <Min1) {Min2 = Min1 ؛منٹ 1 = نمبر ؛} ورنہ اگر (num <منٹ 2) {منٹ 2 = نمبر ؛}} ریٹرن میتھ۔ میکس (میکس 1 * میکس 2 ، منٹ 1 * منٹ 2) ؛ مذکورہ بالا فنکشن ان پٹ کے طور پر عدد کی ایک صف آر آر لیتا ہے اور صف میں دو انٹیجرز کی زیادہ سے زیادہ مصنوعات کو واپس کرتا ہے۔یہ چار متغیرات ، میکس 1 ، میکس 2 ، MIN1 ، اور MIN2 کو زیادہ سے زیادہ اور کم سے کم ممکنہ اقدار سے شروع کرتا ہے۔اس کے بعد یہ صف میں ہر عنصر پر تکرار کرتا ہے اور اس کے مطابق متغیرات کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ دو سب سے بڑے مثبت عدد یا دو سب سے چھوٹے منفی انٹیجرز 32 کی زیادہ سے زیادہ مصنوعات کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ کسی مخصوص صف میں دو عدد کی زیادہ سے زیادہ مصنوعات کو تلاش کرنے کے لئے میکس پروڈکٹ () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ۔arr = [-10 ، -3 ، 5 ، 6 ، -2] ؛ آئیے میکس پروڈکٹ = میکس پروڈکٹ (اے آر آر) ؛ کنسول.لوگ ({{{arr} میں دو عدد کی زیادہ سے زیادہ مصنوعات $ {میکس پروڈکٹ} `ہے) ؛ یہ ہےپروگرام سب سے پہلے انٹیجرز کی ایک صف آر آر آر کی ابتدا کرتا ہے۔اس کے بعد یہ میکس پروڈکٹ () فنکشن کو کہتے ہیں تاکہ صف میں دو عدد کی زیادہ سے زیادہ مصنوع تلاش کریں اور اس کے نتیجے کو متغیر میکس پروڈکٹ میں اسٹور کیا جائے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں سرے میں دو عدد کی زیادہ سے زیادہ مصنوعات کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "کسی دیئے گئے اعشاریہ نمبر کو 2 اور 36 کے درمیان کسی بھی اڈے میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں کسی بھی اعشاریہ نمبر کو 2 اور 36 کے درمیان کسی بھی اڈے میں تبدیل کرنے کے ل we ، ہم نمبر آبجیکٹ 12 کے بلٹ ان ٹاسٹرنگ () طریقہ کار کو استعمال کرسکتے ہیں۔ٹاسٹرنگ () کا طریقہ ایک اعشاریہ نمبر کو مخصوص اڈے (ریڈکس) میں تبدیل کرتا ہے۔یہاں کسی اعشاریہ کو 2 اور 36 کے درمیان کسی بھی اڈے میں تبدیل کرنے کے لئے کسی فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فکشن ڈیسمالٹوبیس (نمبر ، بیس) {اگر (بیس <2 || بیس> 36) {واپسی '' ؛} ریٹرن نمبر۔ ٹوسٹرنگ (بیس) ؛} مذکورہ بالا فنکشن ان پٹ کے طور پر ایک اعشاریہ نمبر نمبر اور بیس بیس لیتا ہے اور مخصوص اڈے میں نمبر کی سٹرنگ نمائندگی واپس کرتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا اڈہ 2 اور 36 کے درمیان ہے ، جس میں شامل ہے ، اس صورت میں یہ خالی تار واپس کرتا ہے۔اس کے بعد یہ اعشاریہ نمبر کو مخصوص اڈے میں تبدیل کرنے کے لئے نمبر آبجیکٹ کے ٹاسٹرنگ () کا طریقہ استعمال کرتا ہے اور نتائج کو سٹرنگ 12 کے طور پر واپس کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ اعشاریہ نمبر کو تبدیل کرنے کے لئے ڈیسیمالٹوبیس () فنکشن کو کس طرح استعمال کیا جائے۔2 اور 36 کے درمیان کسی بھی اڈے پر: جاوا اسکرپٹ لیٹ نمبر = 123 ؛ بیس = 16 آئیے نتیجہ = ڈیسمالٹوبیس (نمبر ، بیس) on کنسول.لاگ (`اعشاریہ نمبر $ {نمبر} بیس میں $ {بیس {ہے $ {نتیجہ ہے} `) ؛ یہ پروگرام پہلے اعشاریہ نمبر نمبر اور بیس بیس کی ابتدا کرتا ہے۔اس کے بعد یہ اعشاریہ کی تعداد کو مخصوص اڈے میں تبدیل کرنے کے لئے اعشاریہ کی تقریب کو کال کرتا ہے اور اس کے نتیجے کو متغیر نتیجہ میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں مخصوص بنیاد میں اعشاریہ کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ اعشاریہ کی تعداد کو کسی بھی اڈے میں تبدیل کرنے کے لئے دوسرے الگورتھم موجود ہیں ، جیسے بار بار ڈویژن کا طریقہ اور ہورنر کا طریقہ 34۔تاہم ، ٹاسٹرنگ () کا طریقہ جاوا اسکرپٹ میں تبادلوں کو انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "کسی مخصوص رینج میں تمام نمبروں کے جوڑے کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں دی گئی رینج میں تمام نمبروں کے جوڑے کا حساب لگانے کے ل we ، ہم رینج میں ہر نمبر پر تکرار کرنے کے لئے لوپ کے لئے A استعمال کرسکتے ہیں اور اسے چلانے والے ٹوٹل 123 میں شامل کرسکتے ہیں۔یہاں ایک مخصوص رینج میں تمام نمبروں کے جوڑے کا حساب لگانے کے لئے کسی فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن سومریج (اسٹارٹ ، اینڈ) {اجازت دیں = 0 ؛کے لئے (آئیے i = start ؛ i <= end ؛ i ++) {رقم+= i ؛} واپسی کی رقم ؛} مذکورہ بالا فنکشن ان پٹ کے طور پر دو عدد شروع اور اختتام پر لے جاتا ہے اور شروع سے اختتام تک حد میں تمام نمبروں کا مجموعہ واپس کرتا ہے۔یہ ایک متغیر رقم کو 0 پر شروع کرتا ہے اور لوپ کے لئے A کا استعمال ہر نمبر پر تکرار کرنے کے لئے کرتا ہے اور اسے SUM متغیر میں شامل کرتا ہے۔آخر میں ، یہ SUM متغیر کو لوٹاتا ہے ، جس میں حد 123 میں تمام تعداد کا مجموعہ ہوتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ ایک مخصوص رینج میں تمام نمبروں کی رقم کا حساب لگانے کے لئے سومریج () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ اسٹارٹ =1 ؛ آخری = 10 ؛ آئیے SUM = sumrange (start ، end) ؛ کنسول.لوگ (range رینج میں تمام نمبروں کا مجموعہ $ {اسٹارٹ} سے $ {اختتام} ہے $ {رقم} `) ؛ یہ پروگرام پہلے اس پروگرامدو عدد شروع اور اختتام کو شروع کرتا ہے۔اس کے بعد یہ سومریج () فنکشن کو کال کرتا ہے تاکہ تمام نمبروں کی رقم کا حساب لگائیں اور اس کے نتیجے میں متغیر رقم میں اسٹور کیا جائے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں رینج میں موجود تمام نمبروں کی رقم کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ کسی مخصوص رینج میں تمام تعداد کے جوڑے کا حساب لگانے کے لئے دیگر الگورتھم موجود ہیں ، جیسے ریاضی کی سیریز 4 کے مجموعہ کے لئے فارمولا استعمال کرنا۔تاہم ، جاوا اسکرپٹ میں حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دی دی گئی تار جاوا اسکرپٹ میں ایک درست IPv4 پتہ ہے ، ہم چار اعشاریہ ایڈریس 1234 میں سے ہر ایک میں اجازت نمبر کی حد سے ملنے کے لئے باقاعدہ اظہار استعمال کرسکتے ہیں۔یہاں ایک فنکشن کا ایک مثال عمل ہے جس کی جانچ پڑتال کے لئے کہ آیا دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے: جاوا اسکرپٹ فنکشن isvalidipv4Address (str) {const regexexp = /^(([0-9] | [1-9] [0-9] | 1[0-9] {2} | 2 [0-4] [0-9] | 25 [0-5]) \\.) {3} ([0-9] | [1-9] [1-9] [0-9]] | 1 [0-9] {2} | 2 [0-4] [0-9] | 25 [0-5]) $/GI ؛REGEXEXP.TEST (STR)}} مذکورہ فنکشن ان پٹ کے طور پر سٹرنگ ایس ٹی آر لیتا ہے اور ایک بولین ویلیو لوٹاتا ہے جس سے یہ ظاہر ہوتا ہے کہ سٹرنگ ایک درست IPv4 ایڈریس ہے یا نہیں۔یہ چار اعشاریہ ایڈریس سیکشنز میں سے ہر ایک میں اجازت نمبر کی حد سے ملنے کے لئے باقاعدہ اظہار کا استعمال کرتا ہے۔باقاعدہ اظہار نقطوں کے ذریعہ الگ ہونے والے چار اعشاریہ ایڈریس حصوں سے میل کھاتا ہے ، جہاں ہر حصے 0 اور 255 کے درمیان ایک نمبر ہوسکتا ہے۔ باقاعدہ اظہار آبجیکٹ کا ٹیسٹ () طریقہ یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا ان پٹ سٹرنگ باقاعدہ اظہار کے نمونہ سے مماثل ہے یا نہیں۔اگر ان پٹ سٹرنگ پیٹرن سے مماثل ہے اور غلط ہے تو یہ فنکشن سچ ہے۔'؛ isvalid = isvalidipv4Address (str) ؛ کنسول.لوگ (string تار \"$ {str}\" ایک درست IPv4 ایڈریس ہے: $ {isvalid} `) ؛ یہ پروگرام پہلے ایک سٹرنگ ایس ٹی آر کی ابتدا کرتا ہے جو ایک IPv4 ایڈریس کی نمائندگی کرتا ہے۔اس کے بعد یہ یہ چیک کرنے کے لئے isvalidipv4Address () فنکشن کو کال کرتا ہے کہ آیا سٹرنگ ایک درست IPv4 ایڈریس ہے اور اس کے نتیجے کو متغیر isvalid میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں یہ اشارہ کیا گیا ہے کہ آیا سٹرنگ ایک درست IPv4 ایڈریس ہے۔ نوٹ کریں کہ یہ چیک کرنے کے لئے دوسرے الگورتھم موجود ہیں کہ آیا کوئی سٹرنگ ایک درست IPv4 ایڈریس ہے ، جیسے Node.js5 میں نیٹ ماڈیول کا استعمال کرنا۔تاہم ، باقاعدگی سے اظہار نقطہ نظر جاوا اسکرپٹ میں چیک انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "متعدد خصوصیات اور ترتیب کے احکامات کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "متعدد خصوصیات پر مبنی اشیاء کی ایک صف کو ترتیب دینے اور جاوا اسکرپٹ میں آرڈر کو ترتیب دینے کے ل several ، بہت سارے نقطہ نظر ہیں۔ایک نقطہ نظر یہ ہے کہ سرنی آبجیکٹ کے ترتیب () طریقہ کو استعمال کریں اور موازنہ کی تقریب فراہم کریں جو آبجیکٹ 123456 کی مطلوبہ خصوصیات کا موازنہ کرے۔ایک اور نقطہ نظر لائبریری یا افادیت کا فنکشن استعمال کرنا ہے جو زیادہ اعلی درجے کی چھانٹنے والی فعالیت فراہم کرتا ہے ، جیسے لوڈش لائبریری 12۔یہاں پہلے نقطہ نظر کا ایک مثال عمل ہے: جاوا اسکرپٹ فانکشن ترتیب (ARR ، پروپس) {واپسی arr.sort ((a ، b) => {for (i = 0 ؛ i <props.length ؛ i ++) {اجازت دیں پروپ = پروپس[i] .name ؛ آئیے آرڈر = پروپس [i] .order || 'asc' ؛ آئیے نتیجہ = a [app] <b [prop]؟ -1: a [prop]> b [prop]؟ 1: 0؛ if (نتیجہ! == 0) {واپسی آرڈر === 'ڈیسک'؟ -ریسولٹ: نتیجہ ؛}} ریٹرن 0 ؛}) ؛} مذکورہ فنکشن میں اشیاء کی ایک صف اور پراپرٹی کے ناموں کی ایک صف کی سہولیات لی جاتی ہیں اورآرڈرز کو ان پٹ کے طور پر ترتیب دیں اور مخصوص خصوصیات کے ذریعہ ترتیب دیئے گئے اشیاء کی ایک نئی صف کو لوٹائیں اور ترتیب کے احکامات کو ترتیب دیں۔یہ اشیاء کی صف کو ترتیب دینے کے لئے سرنی آبجیکٹ کے ترتیب () کا طریقہ استعمال کرتا ہے۔موازنہ فنکشن مخصوص خصوصیات اور ترتیب کے احکامات کی بنیاد پر ہر شے کا موازنہ کرتا ہے۔یہ پروپس سرنی میں ہر پراپرٹی پر تکرار کرتا ہے اور دونوں اشیاء کی متعلقہ املاک کی اقدار کا موازنہ کرتا ہے۔اگر پراپرٹی کی اقدار برابر نہیں ہیں تو ، فنکشن ترتیب کے آرڈر کی بنیاد پر موازنہ کے نتائج کو لوٹاتا ہے۔اگر پراپرٹی کی اقدار برابر ہیں تو ، فنکشن اگلی پراپرٹی تک جاری رہتا ہے۔آخر میں ، فنکشن 0 لوٹتا ہے اگر تمام خصوصیات برابر ہیں ، جس سے یہ ظاہر ہوتا ہے کہ دونوں اشیاء برابر ہیں 123456۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ ایک سے زیادہ خصوصیات اور ترتیب کے آرڈرز پر مبنی اشیاء کی ایک صف کو ترتیب دینے کے لئے ترتیب سے متعلق () فنکشن کو کس طرح استعمال کیا جائے:جاوا اسکرپٹ لیٹ = [{نام: 'مائک' ، عمر: 20} ، {نام: 'پیٹر' ، عمر: 30} ، {نام: 'ڈورس' ، عمر: 18} ،] ؛ آئیے پروپس = [{نام: 'عمر '، آرڈر:' ڈیسک '} ، {نام:' نام '، آرڈر:' ASC '} ،] ؛ چھینٹےڈر = ترتیب سے متعلقہ (آر ، پروپس) ؛ کنسول.لوگ (`ترتیب شدہ سرنی: $ {json.stringify (shartedarr)} `) ؛ یہ پروگرام سب سے پہلے اشیاء کی ایک صف ARR شروع کرتا ہے۔اس کے بعد یہ جائیداد کے ناموں اور ترتیب کے احکامات کی ایک صفوں کی شروعات کرتا ہے۔یہ مخصوص خصوصیات کی بنیاد پر اشیاء کی صف کو ترتیب دینے اور آرڈر کو ترتیب دینے اور متغیر ترتیب وار میں اس کے نتیجے کو اسٹور کرنے کے لئے ترتیب () فنکشن کو کال کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں اشیاء کی ترتیب دی گئی صف کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ متعدد خصوصیات اور ترتیب کے احکامات پر مبنی اشیاء کی ایک صف کو ترتیب دینے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے لوڈش لائبریری 12 کے _.orderby () فنکشن کا استعمال۔تاہم ، ترتیب () طریقہ نقطہ نظر جاوا اسکرپٹ میں ترتیب دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو سرکلر منسلک فہرست کی نمائندگی کرتی ہے۔ نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "جاوا اسکرپٹ کلاس برائے سرکلر لنکڈ لسٹو ایک جاوا اسکرپٹ کلاس بنائیں جو ایک سرکلر منسلک فہرست کی نمائندگی کرتا ہے ، ہم ایک نوڈ کلاس کی وضاحت کرسکتے ہیں جو فہرست میں ایک نوڈ کی نمائندگی کرتا ہے اور ایک سرکلر لنکڈ لسٹ کلاس جو فہرست کی نمائندگی کرتا ہے۔سرکلر لنکڈ لسٹ کلاس کے پاس لسٹ 1234 میں نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقے ہونا چاہئے۔ یہاں نوڈ اور سرکلر لنکڈ لسٹ کلاسوں کا ایک مثال عمل ہے: جاوا اسکرپٹ کلاس نوڈ {کنسٹرکٹر (قدر) {this.value = ویلیو ؛this.next = null ؛}} کلاس سرکلر لنکڈ لسٹ {کنسٹرکٹر () {this.head = null ؛this.tail = null ؛this.length = 0 ؛} داخل کریں (قدر) {آئیے نوڈ = نیا نوڈ (قدر) ؛اگر (this.head === null) {this.head = نوڈ ؛this.tail = نوڈ ؛node.next = this.head ؛} else {node.next = this.head ؛this.tail.next = نوڈ ؛this.tail = نوڈ ؛} this.length ++ ؛} حذف (قدر) {اگر (this.head === null) {واپسی ؛} موجودہ = this.head ؛آئیے پچھلا = null ؛جبکہ (موجودہ۔ ویلیو! == ویلیو) {اگر (موجودہ۔ نیکسٹ === یہ۔ ہیڈ) {واپسی ؛} پچھلا = موجودہ ؛موجودہ = موجودہ۔ نیکسٹ ؛} if (موجودہ === this.head) {this.head = this.head.next ؛this.tail.next = this.head ؛} ورنہ اگر (موجودہ === this.tail) {this.tail = پچھلا ؛this.tail.next = this.head ؛} else {پچھلی. نیکسٹ = موجودہ. نیکسٹ ؛} this.length-- ؛} تلاش (قدر) {موجودہ = this.head ؛جبکہ (موجودہ! == null) {if (موجودہ.Value === ویلیو) {موجودہ واپسی ؛} if (موجودہ. نیکسٹ === this.head) {واپسی NULL ؛} موجودہ = موجودہ۔ نیکسٹ ؛} واپس کالعدم ؛}} نوڈ کلاس سرکلر لنکڈ فہرست میں ایک نوڈ کی نمائندگی کرتی ہے اور اس میں ایک ویلیو پراپرٹی ہے جو نوڈ کی قیمت اور اگلی پراپرٹی کو محفوظ کرتی ہے جو فہرست میں اگلے نوڈ کی طرف اشارہ کرتی ہے۔سرکلر لنکڈ لسٹ کلاس خود ہی اس فہرست کی نمائندگی کرتی ہے اور اس میں ایک سر پراپرٹی ہے جو فہرست میں پہلے نوڈ کی طرف اشارہ کرتی ہے ، ایک دم کی پراپرٹی جو فہرست میں آخری نوڈ کی طرف اشارہ کرتی ہے ، اور ایک لمبائی کی پراپرٹی جو فہرست میں نوڈس کی تعداد کو محفوظ کرتی ہے۔اس میں تین طریقے بھی ہیں: داخل کریں () ، حذف کریں () ، اور تلاش ()۔داخل () کا طریقہ ان پٹ کی حیثیت سے ایک قدر لیتا ہے اور فہرست کے آخر میں قیمت کے ساتھ ایک نیا نوڈ داخل کرتا ہے۔حذف () کا طریقہ ان پٹ کی حیثیت سے ایک قدر لیتا ہے اور فہرست سے قدر کے ساتھ پہلا نوڈ کو حذف کرتا ہے۔تلاش () کا طریقہ ان پٹ کی حیثیت سے ایک قدر لیتا ہے اور پہلے نوڈ کی قیمت کے ساتھ فہرست تلاش کرتا ہے ، نوڈ کو واپس کرتا ہے اگر پایا جاتا ہے یا اگر کوئی دوسری صورت میں کالعدم ہوتا ہے تو۔اور سرکلر منسلک فہرست میں نوڈس کی تلاش کریں: جاوا اسکرپٹ لسٹ = نیا سرکلر لنکڈ لسٹ () ؛ لسٹ۔ INSERT (1) ؛ لسٹ۔ INSERT (2) ؛ لسٹ۔ INSERT (3) ؛ کنسول.لوگ (فہرست) ؛// سرکلر لنکڈ لسٹ {سر: نوڈ {قدر: 1 ، اگلا: [نوڈ]} ، دم: نوڈ {قدر: 3 ، اگلا: [نوڈ]} ، لمبائی: 3} فہرست۔ ڈیلیٹ (2) ؛ کنسول.لوگ (فہرست) ؛// سرکلر لنکڈ لسٹ {سر: نوڈ {قدر: 1 ، اگلا: [نوڈ]} ، دم: نوڈ {قدر: 3 ، اگلا: [نوڈ]} ، لمبائی: 2} آئیے نوڈ = فہرست۔ تلاش (3) ؛ کنسول۔لاگ (نوڈ) ؛// نوڈ {ویلیو: 3 ، اگلا: نوڈ {قدر: 1 ، اگلا: [نوڈ]}} یہ پروگرام پہلے ایک نئی سرکلر لنکڈ لسٹ آبجیکٹ کی فہرست شروع کرتا ہے۔اس کے بعد یہ داخل () طریقہ استعمال کرکے فہرست میں اقدار 1 ، 2 ، اور 3 کے ساتھ تین نوڈس داخل کرتا ہے۔یہ فہرست آبجیکٹ کو کنسول پر پرنٹ کرتا ہے۔اس کے بعد یہ نوڈ کو حذف () کے طریقہ کار کا استعمال کرتے ہوئے فہرست سے ویلیو 2 کے ساتھ حذف کردیتا ہے اور کنسول پر تازہ ترین فہرست آبجیکٹ کو پرنٹ کرتا ہے۔آخر میں ، یہ تلاش () کے طریقہ کار کا استعمال کرتے ہوئے ویلیو 3 کے ساتھ نوڈ کی فہرست تلاش کرتا ہے اور نوڈ آبجیکٹ کو کنسول پر پرنٹ کرتا ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں سرکلر سے منسلک فہرست کو نافذ کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے ڈبللی لنکڈ کا استعمال کرنافہرست یا لائبریری جیسی لائبریری جیسے JS-Data- ڈھانچے 234۔تاہم ، مذکورہ بالا نفاذ جاوا اسکرپٹ میں سرکلر منسلک فہرست کو نافذ کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں عددیوں کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے ل we ، ہم سرنی 12 میں ہر انڈیکس پر ختم ہونے والے طویل ترین بڑھتے ہوئے سبیرے کی لمبائی کی گنتی کے لئے متحرک پروگرامنگ نقطہ نظر کا استعمال کرسکتے ہیں۔اس کے بعد ہم سب سے زیادہ بڑھتے ہوئے سبری کی لمبائی حاصل کرنے کے ل all تمام گنتی لمبائی میں زیادہ سے زیادہ لمبائی تلاش کرسکتے ہیں۔عددیوں کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے لئے ایک فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فینکشن طویل ترین انکریزنگسنگ بورے (ARR) {let n = arr.length ؛لمبائی = نئی سرنی (n) .فل (1) ؛کے لئے (آئیے i = 1 ؛ i <n ؛ i ++) {if (arr [i]> arr [i - 1]) {لمبائی [i] = لمبائی [i - 1]+1 ؛}} ریٹرن میتھ.میکس (... لمبائی) ؛} مذکورہ فنکشن ان پٹ کے طور پر عدد کی ایک صف آر آر لیتا ہے اور صف میں طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی کو لوٹاتا ہے۔یہ ان پٹ سرنی کی طرح لمبائی کی ایک صف کی لمبائی کا آغاز کرتا ہے اور اسے 1s سے بھرتا ہے تاکہ صف میں ہر انڈیکس پر ختم ہونے والے طویل ترین بڑھتے ہوئے سبری کی لمبائی کی نمائندگی کی جاسکے۔اس کے بعد یہ صف میں ہر انڈیکس کے اوپر تکرار کرنے کے لئے A کا استعمال کرتا ہے اور اگر موجودہ عنصر پچھلے عنصر سے زیادہ ہے تو لمبائی صف میں اسی لمبائی کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ لمبائی میں تمام لمبائی کی لمبائی کے درمیان زیادہ سے زیادہ لمبائی واپس کرتا ہے۔5 ، 6 ، 3 ، 5 ، 7 ، 8 ، 9 ، 1 ، 1 ، 2] leming لمبائی = لمبائی کے بارے میں سیکریسنگسو بری (اے آر آر) ؛ کنسول.لوگ ({{{arr} میں سب سے طویل عرصہ میں بڑھتی ہوئی سبری کی لمبائی $ {لمبائی} `ہے۔)) ؛ یہ پروگرام پہلے عدد کی ایک صف آر آر آر کی شروعات کرتا ہے۔اس کے بعد یہ صف میں طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی تلاش کرنے کے ل long طویل ترین انکریزنگسنگ () فنکشن کہتے ہیں اور اس کے نتیجے کو متغیر لمبائی میں محفوظ کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں سرے میں سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ انٹیجرز کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے بائنری تلاش یا لوڈش لائبریری 13 کا استعمال کرنا۔تاہم ، متحرک پروگرامنگ نقطہ نظر جاوا اسکرپٹ میں حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "کسی دیئے گئے تار سے ڈپلیکیٹ حروف کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے تار سے ڈپلیکیٹ حروف کو ہٹانے کے ل several ، بہت سارے نقطہ نظر ہیں۔ایک نقطہ نظر یہ ہے کہ تار میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کیا جائے اور ان کرداروں کا سراغ لگانے کے لئے کسی شے کا استعمال کریں جو پہلے ہی دیکھا گیا ہے۔ایک اور نقطہ نظر یہ ہے کہ سٹرنگ میں منفرد حروف کو ذخیرہ کرنے کے لئے سیٹ آبجیکٹ کا استعمال کریں اور پھر سیٹ کو واپس سٹرنگ 13 میں تبدیل کریں۔یہاں پہلے نقطہ نظر کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن کو ہٹا دیا گیا (STR) {چلو = {} ؛آئیے نتیجہ = '' ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {آئیے چار = str [i] ؛اگر (! دیکھا [چار]) {دیکھا [چار] = سچ ؛نتیجہ += چار ؛}} ریٹرن کا نتیجہ ؛} مذکورہ فنکشن ان پٹ کے طور پر سٹرنگ ایس ٹی آر لیتا ہے اور تمام ڈپلیکیٹ حروف کو ہٹانے کے ساتھ ایک نیا تار واپس کرتا ہے۔یہ ایک خالی شے کی ابتدا کرتا ہے جو ان کرداروں کو ٹریک رکھنے کے لئے دیکھا جاتا ہے جو پہلے ہی دیکھا جا چکے ہیں اور منفرد کرداروں کو ذخیرہ کرنے کے لئے خالی تار کا نتیجہ ہے۔اس کے بعد یہ ان پٹ سٹرنگ میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور چیک کرتا ہے کہ اگر کردار پہلے ہی دیکھا گیا ہے۔اگر کردار نہیں دیکھا گیا ہے تو ، اس نے اسے دیکھا ہوا شے اور نتائج کی تار میں شامل کیا ہے۔آخر میں ، یہ نتیجہ کی تار لوٹاتا ہے ، جس میں ان پٹ سٹرنگ 12 میں تمام انوکھے کردار ہوتے ہیں۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ کسی دیئے گئے تار سے ڈپلیکیٹ حروف کو ہٹانے کے لئے ہٹانے والے افراد () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ str = 'ہیلو ورلڈ'؛ آئیے نتیجہ = ہٹائے گئے (str) ؛ کنسول.لوگ (`تار\" $ {str} \"کو ہٹا دیا گیا ہے\" result \"{{نتیجہ}\" `) ؛ یہ پروگرام پہلے ڈپلیکیٹ حروف کے ساتھ سٹرنگ ایس ٹی آر کو شروع کرتا ہے۔اس کے بعد یہ ڈپلیکیٹ حروف کو اسٹرنگ سے ہٹانے کے لئے ہٹانے والی () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر کے نتیجے میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں اصل تار کو ہٹا دیا گیا ہے جس میں ہٹا دیا گیا ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں دیئے گئے تار سے ڈپلیکیٹ حروف کو ہٹانے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے باقاعدہ اظہار یا لوڈش لائبریری 143 کا استعمال کرنا۔تاہم ، مذکورہ بالا عملدرآمد جاوا اسکرپٹ میں ڈپلیکیٹ حروف کو ہٹانے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کو اس کے متعلقہ رومن ہندسوں کی نمائندگی میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ فنکشن کسی نمبر کو اس کے متعلقہ رومن ہندسوں کی نمائندگی میں تبدیل کرنے کے لئے کسی دیئے گئے نمبر کو جاوا اسکرپٹ میں اس کے متعلقہ رومن ہندسے کی نمائندگی میں تبدیل کرنے کے لئے ، ہم ایک ایسے فنکشن کا استعمال کرسکتے ہیں جو عدد کو رومن ہندسوں میں تبدیل کرنے کے لئے الگورتھم کو نافذ کرتا ہے۔عددیوں کو رومن ہندسوں میں تبدیل کرنے کے لئے بہت سے الگورتھم ہیں ، لیکن ایک عام الگورتھم یہ ہے کہ رومن ہندسوں کی علامتوں اور ان کی متعلقہ اعشاریہ اقدار کی ایک تلاش کی جدول کا استعمال کریں اور عددی سے سب سے بڑی ممکنہ علامت کی قدر کو گھٹا دیں جب تک کہ عددی صفر 123456 نہیں ہوجائے۔کسی نمبر کو اس کے متعلقہ رومن ہندسوں کی نمائندگی میں تبدیل کرنے کے لئے کسی فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن انٹیجرٹورومن (نمبر) {اگر (ٹائپوف نمبر! == 'نمبر') {غلط واپس ؛digs آئیے ہندسوں = سٹرنگ (+num) .split ('' ') ؛کلید = ['' ، 'سی' ، 'سی سی' ، 'سی سی سی' ، 'سی ڈی' ، 'ڈی' ، 'ڈی سی' ، 'ڈی سی سی' ، 'ڈی سی سی' ، 'سی ایم' ، '' ، '' ، 'ایکس' ،'xx' ، 'xxx' ، 'xl' ، 'l' ، 'lx' ، 'lxx' ، 'lxxx' ، 'xc' ، '' ، 'i' ، 'ii' ، 'iii' ، 'iv'، 'v' ، 'vi' ، 'vii' ، 'viii' ، 'ix' ،] ؛آئیے رومانم = '' ؛i = 3 ؛جبکہ (i--) {رومانم = (کلید [ + ہندسے.پپ () + i * 10] || '') + رومانم ؛} واپسی سرنی ( + ہندسوں.جوئن ('') + 1) .جین ('ایم') + رومانم ؛} مذکورہ فنکشن ان پٹ کے طور پر ایک عددی نمبر لیتا ہے اور ایک تار واپس کرتا ہے جو عددی کے برابر رومن ہندسے کی نمائندگی کرتا ہے۔یہ پہلے چیک کرتا ہے کہ آیا ان پٹ ایک نمبر ہے اور اگر ایسا نہیں ہے تو غلط لوٹاتا ہے۔اس کے بعد یہ ایک سرنی ہندسوں کی ابتدا کرتا ہے جس میں ان پٹ نمبر کے ہندسوں کو تار کے طور پر شامل ہوتا ہے ، ایک نظر والی ٹیبل کی کلید جو ہر اعشاریہ کی ہر قیمت کو اس کے متعلقہ رومن ہندسے کی علامت پر نقش کرتی ہے ، رومن ہندسے کی نمائندگی کو ذخیرہ کرنے کے لئے ایک خالی تار رومنم ، اور ایک متغیر I کو دوبارہ تکریٹ کرنا ہے۔ہندسوں سے زیادہیہ ان پٹ نمبر کے ہندسوں پر تکرار کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے اور کلیدی صف سے متعلقہ رومن ہندسوں کی علامتوں کو ہم آہنگ کرکے رومن ہندسے کی نمائندگی کی گنتی کرتا ہے۔آخر میں ، یہ رومن ہندسے کی نمائندگی 123456 لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ کسی نمبر کو اس کے متعلقہ رومن ہندسے کی نمائندگی میں تبدیل کرنے کے لئے انٹیگرٹورومن () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ نمبر = 27 ؛ رومانم = انٹیجرومن (نمبر) ؛ کنسول ؛.log (`{{Num} کی رومن ہندسوں کی نمائندگی $ {رومانوم}` ہے) ؛ یہ پروگرام پہلے ایک عددی نمبر کی ابتدا کرتا ہے۔اس کے بعد یہ انٹیجر مین () کے فنکشن کو انٹیجر کو اس کے متعلقہ رومن ہندسوں کی نمائندگی میں تبدیل کرنے کے لئے کہتے ہیں اور اس کے نتیجے کو متغیر رومانم میں محفوظ کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں انٹیجر کی رومن ہندسوں کی نمائندگی کی نشاندہی کی جاتی ہے۔ نوٹ کہ جاوا اسکرپٹ میں کسی نمبر کو اس کے متعلقہ رومن ہندسوں کی نمائندگی میں تبدیل کرنے کے لئے دیگر الگورتھم اور لائبریریاں موجود ہیں ، جیسے سوئچ اسٹیٹمنٹ یا ہندسے کی لائبریری 15۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں تبادلوں کو انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے اسٹرنگ صرف حرفیومیرک کرداروں پر غور کرنے اور کیس کو نظرانداز کرنے پر غور کرنے کے لئے ایک درست پلنڈرووم ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے تار صرف حروف کے حروف پر غور کرنے اور کیسیٹو کو نظرانداز کرنے پر ایک درست پیلنڈرووم ہے اگر کوئی دیئے گئے تار صرف ایک درست پلنڈرووم ہے جس پر صرف حرفی حرفی کرداروں پر غور کیا جاتا ہے اور جاوا اسکرپٹ میں کیس کو نظرانداز کیا جاتا ہے تو ، ہم ایک ایسے فنکشن کا استعمال کرسکتے ہیں جو پہلے تمام غیر الفینومیرک کرداروں کو ہٹاتا ہے۔اور تار کو لوئر کیس میں تبدیل کرتا ہے۔اس کے بعد ہم سٹرنگ کے پہلے اور آخری حروف کا موازنہ کرسکتے ہیں ، اور حروف کا موازنہ تار کے وسط کی طرف کرسکتے ہیں جب تک کہ ہم وسط تک نہ پہنچیں یا ایسے کرداروں کا ایک جوڑا تلاش کریں جو برابر 12345 نہیں ہیں۔اس فنکشن کا ایک مثال نفاذ ہے: جاوا اسکرپٹ فنکشن ispalindrome (str) {str = str.tolowercace (). تبدیل کریں (/[^a-z0-9]/g ، '') ؛بائیں = 0 ؛آئیے دائیں = str.length - 1 ؛جبکہ (بائیں <دائیں) {اگر (str [بائیں]! == str [دائیں]) {غلط لوٹ ؛} بائیں ++ ؛ٹھیک ہے-؛true سچائی واپس ؛} مندرجہ بالا فنکشن ان پٹ کے طور پر سٹرنگ ایس ٹی آر لیتا ہے اور بولین کی قیمت کو لوٹاتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا اسٹرنگ ایک درست پیلنڈرووم ہے جس پر صرف حرفی حرفی کرداروں پر غور کیا جاتا ہے اور کیس کو نظرانداز کیا جاتا ہے۔یہ سب سے پہلے تار کو لوئر کیس میں تبدیل کرتا ہے اور باقاعدہ اظہار کا استعمال کرتے ہوئے تمام غیر الفانومرک کرداروں کو ہٹاتا ہے۔اس کے بعد اس کے بعد دو پوائنٹرز بالترتیب بالترتیب ، بائیں اور دائیں طرف کے آغاز اور اختتام تک شروع کرتے ہیں۔یہ بائیں اور دائیں پوائنٹرز کے کرداروں کا موازنہ کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے اور اس وقت تک جاری رہتا ہے جب تک کہ اشارے تار کے وسط میں نہیں ملتے یا ایسے کرداروں کا جوڑا تلاش کرتے ہیں جو برابر نہیں ہوتے ہیں۔اگر کرداروں کا ایک جوڑا برابر نہیں ہے تو ، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، یہ درست 12345 لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ آئی ایس پی ایل انڈوم () فنکشن کو یہ معلوم کرنے کے لئے کس طرح استعمال کیا جائے کہ آیا دیئے گئے اسٹرنگ صرف حرفی حرفوں پر غور کرنے اور کیس کو نظرانداز کرنے پر ایک درست پلنڈرووم ہے: جاوا اسکرپٹ ایس ٹی آر = 'ایک آدمی ، ایک منصوبہ ،ایک نہر: پاناما '؛ آئیے ispal = ispalindrome (str) ؛ کنسول.لاگ (string تار \"$ {str}\" ایک درست palindrome ہے: $ {ispal} `) ؛ یہ پروگرام پہلے ایک سٹرنگ اسٹیر کو شروع کرتا ہے جس میں ایک درست ہوتا ہے۔پالندرووم۔اس کے بعد یہ یہ چیک کرنے کے لئے ispalindrome () فنکشن کو کال کرتا ہے کہ آیا اسٹرنگ ایک درست palindrome ہے جس پر صرف حرفی حرفی حروف پر غور کیا جاتا ہے اور کیس کو نظرانداز کیا جاتا ہے اور اس کے نتیجے کو متغیر ispal میں محفوظ کیا جاتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں یہ اشارہ کیا گیا ہے کہ آیا تار ایک درست پیلیندرووم ہے۔ نوٹ کہ یہاں دوسرے الگورتھم اور لائبریری موجود ہیں کہ آیا یہ چیک کرنے کے لئے کہ کوئی دیئے گئے تار ایک درست پیلنڈرووم ہے جس میں صرف حرفی کرداروں پر غور کیا جاتا ہے اور جاوا اسکرپٹ میں کیس کو نظرانداز کرنا ، جیسے اسٹیک یا استعمال کرنا۔لوڈش لائبریری 634۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں چیک کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "تاروں کے ایک سیٹ میں سب سے طویل عام سٹرنگ تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "سٹرنگ اسٹو کے ایک سیٹ کے درمیان سب سے طویل عام سٹرنگ تلاش کرنے کے لئے جاوا اسکرپٹ میں تاروں کے ایک سیٹ کے درمیان سب سے طویل عام مشترکہ تلاش تلاش کرنے کے ل we ، ہم سیٹ میں سبسٹرانگز کے سب سے طویل عام لاحقہ کی لمبائی کی لمبائی کی گنتی کے لئے متحرک پروگرامنگ نقطہ نظر کا استعمال کرسکتے ہیں۔اسٹرنگز 12اس کے بعد ہم تمام گنتی لمبائی کے درمیان زیادہ سے زیادہ لمبائی تلاش کرسکتے ہیں اور ان پٹ اسٹرنگ میں سے کسی ایک سے اسی طرح کے ذخیرے نکال سکتے ہیں۔اس فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن سب سے طویل عرصے سے کامنسوبسٹرنگ (ایس ٹی آر ایس) {آئیے n = strs.length ؛آئیے زیادہ سے زیادہ = 0 ؛آئیے لاحقہ = نئی صف (n) ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {لاحقہ [i] = نیا سرنی (strs [i]. لمبائی) ؛کے لئے (j = 0 ؛ j <strs [i] .length ؛ j ++) {لاحقہ [i] [j] = 0 ؛}} کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {for (آئیے j = i+1 ؛ j <n ؛ j ++) {for (آئیے k = 0 ؛ k <strs [i]. لمبائی ؛ k ++){for (let l = 0 ؛ l <strs [j] .length ؛ l ++) {اگر (strs [i] [k] === strs [j] [l]) {اگر (k === 0 ||l === 0) {لاحقہ [i] [k] = 1 ؛} else {لاحقہ [i] [k] = لاحقہ [i] [k - 1] + 1 ؛} if (لاحقہ [i] [k]> زیادہ سے زیادہ لمبائی) {آئیے اسٹارٹ = k - لاحقہ [i] [k] + 1 ؛آخری = K + 1 ؛آئیے سبسٹرنگ = strs [i] .Substring (شروع ، اختتام) ؛اگر (strs [j]. indexof (string)! == -1) {زیادہ سے زیادہ = لاحقہ [i] [k] ؛}}} دوسری {لاحقہ [i] [K] = 0 ؛}}}}} ریٹرن ایس ٹی آر [0] .Substring (شروع کریں ، اسٹارٹ + میکس لمبائی) ؛} مذکورہ بالا فنکشن ان پٹ کے طور پر تاروں کی ایک صفوں کو لے جاتا ہے اور تار کے درمیان سب سے طویل عام کام کو واپس کرتا ہے۔یہ ان پٹ سرنی کی طرح ایک ہی لمبائی کے ایک سرنی لاحقہ کا آغاز کرتا ہے اور ان پٹ سرنی میں سبسٹرنگز کے ہر ممکنہ جوڑے کے سب سے طویل عام لاحقہ کی لمبائی کی نمائندگی کرنے کے لئے اسے زیرو سے بھرتا ہے۔اس کے بعد یہ ان پٹ سرنی میں سبسٹرانگ کے ہر ممکنہ جوڑے پر تکرار کرنے کے لئے چار گھریلو لوپ کا استعمال کرتا ہے اور سب سے طویل عام لاحقہ کی لمبائی کی گنتی کرتا ہے۔اگر سب سے طویل عام لاحقہ کی لمبائی موجودہ زیادہ سے زیادہ لمبائی سے زیادہ ہے تو ، یہ ان پٹ ڈوروں میں سے کسی ایک سے اسی طرح کے سٹرنگ کو نکالتا ہے اور اگر یہ ان پٹ کے تمام ڈوروں میں ہوتا ہے تو چیک کرتا ہے۔اگر ایسا ہوتا ہے تو ، یہ زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرتا ہے۔آخر میں ، یہ سب سے طویل عام سبسٹرنگ 12 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ تار کے ایک سیٹ میں سب سے طویل مشترکہ تزئین کی تلاش کے ل the طویل عرصے سے کامنسبسٹرنگ () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ ایس ٹی آر ایس = ['اے بی اے بی سی اے' ، 'بی اے بی سی اے' ، 'بی اے بی سی اے' ، 'ABCBA '] ؛ طویل عرصے سے سبسبسٹرنگ = طویل ترین کامنسوبسٹرنگ (STRS) ؛ کنسول.لوگ (`{strs strs} کے درمیان سب سے طویل مشترکہ ذخیرہ\" $ {longestubstring} \"` ہے) ؛ یہ پروگرام سب سے پہلے تاروں کی ایک صفوں کو شروع کرتا ہے۔اس کے بعد اس نے تار کے درمیان طویل ترین مشترکہ سبسٹرنگ تلاش کرنے کے لئے طویل ترین کامنسبسٹرنگ () فنکشن کو فون کیا ہے اور اس کے نتیجے میں متغیر سب سے طویل عرصہ تک اس کا نتیجہ ذخیرہ کیا جاتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں ڈوروں کے درمیان سب سے طویل عام سٹرنگ کی نشاندہی ہوتی ہے۔ نوٹ یہ ہے کہ جاوا اسکرپٹ میں تاروں کے ایک سیٹ کے درمیان سب سے طویل مشترکہ سبسٹرنگ تلاش کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے لاحقہ درخت یا لودش لائبریری 134 کا استعمال۔تاہم ، متحرک پروگرامنگ نقطہ نظر جاوا اسکرپٹ میں حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو گراف ڈیٹا ڈھانچے کی نمائندگی کرے۔دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے اور ٹوپولوجیکل چھانٹنے کے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس برائے گراف ڈیٹا سٹرکچرٹو ایک جاوا اسکرپٹ کلاس بنائیں جو گراف ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، ہم ایک گراف کلاس کی وضاحت کرسکتے ہیں جس میں عمودی اور کناروں کو شامل کرنے ، ٹوپولوجیکل چھانٹنے کو انجام دینے ، اور دو نوڈس کے مابین مختصر ترین راستہ تلاش کرنے کے طریقے موجود ہیں۔گراف کلاس کی نمائندگی کرنے کے لئے گراف کلاس کا استعمال کرتے ہوئے گراف کلاس کو نافذ کیا جاسکتا ہے۔ گراف کلاس کے ایک مثال کے نفاذ: جاوا اسکرپٹ کلاس گراف {کنسٹرکٹر () {this.vertices = نیا نقشہ () ؛} ایڈورٹیکس (ورٹیکس) {if (! this.vertices.has (vertex)) {this.vertices.set (vertex ، []) ؛}} addedge (vertex1 ، vertex2 ، وزن = 1) {if (! this.vertices.has (vertex1)) {this.addvertex (vertex1) ؛} if (! this.vertices.has (vertex2)) {this.addvertex (vertex2) ؛} this.vertices.get (vertex1) .Push ({vertex: vertex2 ، وزن: وزن}) ؛} ٹوپولوجسٹسورٹ () {ملاحظہ کریں = نیا نقشہ () ؛آئیے اسٹیک = [] ؛کے لئے (this.vertices.keys ()) {ملاحظہ کریں۔ سیٹ (ورٹیکس ، غلط) ؛} کے لئے (this.vertices.keys ()) {اگر (! ملاحظہ کیا گیا۔ گیٹ (ورٹیکس)) {this.topologicalsortutil (vertex ، ملاحظہ کیا گیا ، اسٹیک) ؛}} ریٹرن اسٹیک۔ ریورس () ؛} ٹوپولوجسٹورٹیل (ورٹیکس ، ملاحظہ کیا ، اسٹیک) {ملاحظہ کیا گیا۔ سیٹ (ورٹیکس ، سچ) ؛کے لئے (اس کے پڑوسی کو۔}} stack.push (vertex) ؛sight شارسٹپاتھ (ماخذ ، منزل) {دوری = نیا نقشہ () ؛آئیے ملاحظہ کریں = نیا نقشہ () ؛چلو قطار = [] ؛کے لئے (this.vertices.keys ()) {دوری. سیٹ (ورٹیکس ، انفینٹی) کے لئےملاحظہ کیا گیا۔ سیٹ (ورٹیکس ، غلط) ؛} فاصلوں. سیٹ (ماخذ ، 0) ؛قطار.پش (ماخذ) ؛جبکہ (قطار۔ لمبائی> 0) {موجودہ = قطار۔ شفٹ () ؛وزٹ کیا گیا۔ سیٹ (موجودہ ، سچ) ؛کے لئے (اس کے پڑوسی کو۔اگر (فاصلہ <فاصلوں.جیٹ (پڑوسی.ورٹیکس)) {دوری۔ سیٹ (پڑوسی.ورٹیکس ، فاصلہ) ؛} if (! ملاحظہ کریں۔ گیٹ (پڑوسی.ورٹیکس)) {قطار.پش (پڑوسی.ورٹیکس) ؛}}} فاصلوں کی واپسی. گیٹ (منزل) ؛Grap گراف کلاس گراف ڈیٹا ڈھانچے کی نمائندگی کرتا ہے اور اس میں عمودی اور کناروں کو شامل کرنے ، ٹوپولوجیکل چھنٹائی کرنے اور دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے طریقے ہیں۔ایڈورٹیکس () کا طریقہ ان پٹ کے طور پر ایک چوٹی کو لے جاتا ہے اور اگر یہ پہلے سے موجود نہیں ہے تو اسے گراف میں شامل کرتا ہے۔ایڈج () کا طریقہ ان پٹ کے طور پر دو عمودی اور اختیاری وزن لیتا ہے اور ان کے مابین ایک کنارے کا اضافہ کرتا ہے۔ٹوپولوجیکلسورٹ () کا طریقہ گراف کی ایک ٹوپولوجیکل قسم کا انجام دیتا ہے اور ترتیب شدہ عمودی کو ایک صف میں لوٹاتا ہے۔شارسٹپاتھ () کا طریقہ ان پٹ کے طور پر دو عمودی لیتا ہے اور ڈیجکسٹرا کے الگورتھم 123 کا استعمال کرتے ہوئے ان کے درمیان مختصر ترین راستہ لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ گراف کلاس کو کس طرح گراف بنانے کے لئے استعمال کیا جائے ، ٹوپولوجیکل چھانٹ رہا ہے ، اور اس کے درمیان مختصر ترین راستہ تلاش کیا جائے۔دو نوڈس: جاوا اسکرپٹ لیٹ گراف = نیا گراف () ؛ گراف.ڈیج ('a' ، 'b' ، 2) ؛ گراف.ڈیج ('a' ، 'c' ، 3) ؛ گراف.ڈیج ('b' ، 'd '، 4) ؛ گراف.اڈیج (' c '،' d '، 1) ؛ گراف.ڈیج (' d '،' e '، 5) ؛ ترتیب دیں ترتیب دیں = گراف.ٹوپولوجیکل سارٹ () ؛ کنسول.لوگ (`ٹوپولوجیکل طور پر ترتیب دیئے گئے عمودی $ {shortedvertices} `) ہیں short شارٹسٹ پاتھ = گراف.شورٹسٹ پاتھ ('اے' ، 'ای') ؛ کنسول.لوگ (a اور ای کے درمیان مختصر ترین راستہ $ {شارسٹپٹ}`) ہے۔ یہ پروگرام ہے۔پہلے ایک نیا گراف آبجیکٹ گراف شروع کرتا ہے۔اس کے بعد ایڈج () کے طریقہ کار کا استعمال کرتے ہوئے گراف میں عمودی اور کناروں کو شامل کرتا ہے۔یہ ٹوپولوجیکلسورٹ () کے طریقہ کار کا استعمال کرتے ہوئے گراف کی ایک ٹوپولوجیکل قسم کا کام انجام دیتا ہے اور متغیر ترتیب وار سیٹوں میں ترتیب شدہ عمودی کو اسٹور کرتا ہے۔آخر میں ، یہ مختصر ترین راستہ () کے طریقہ کار کا استعمال کرتے ہوئے دو عمودیوں کے درمیان مختصر ترین راستہ تلاش کرتا ہے اور اس کے نتیجے کو متغیر مختصر ترین راستہ میں اسٹور کرتا ہے۔یہ پیغامات پرنٹ کرتا ہے جس میں ٹوپولوجیکل طور پر ترتیب دیئے گئے عمودی اور دو عمودیوں کے درمیان مختصر ترین راستہ کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ ٹوپولوجیکل چھانٹ رہا ہے اور جاوا اسکرپٹ میں ایک گراف میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے بیل مین فورڈ الگورتھم کا استعمال کرنا۔یا JS-Google-Algorithms لائبریری 145۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "بائنری درخت میں بائیں بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ پروگرام جو بائنری ٹریٹو میں تمام بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے جاوا اسکرپٹ میں بائنری درخت میں بائیں پتیوں کا مجموعہ تلاش کرتا ہے ، ہم درخت کو عبور کرنے کے لئے ایک تکرار نقطہ نظر استعمال کرسکتے ہیں اور تمام بائیں پتیوں کی اقدار کو شامل کرسکتے ہیں۔بائیں پتی ایک پتی نوڈ ہے جو اس کے والدین نوڈ 12345 کا بائیں بچہ ہے۔یہاں پروگرام کا ایک مثال عمل ہے: جاوا اسکرپٹ فانکشن سمفلیفٹ لیف (جڑ) {اگر (! جڑ) {واپس 0 ؛} اجازت دیں = 0 ؛if (roght.left && &! root.left.left &&! root.left.right) {رقم += روٹ. لیفٹ.وال ؛} رقم + = sumofleftleaves (roght.left) + sumofleftleaves (جڑ. رائٹ) ؛واپسی کی رقم ؛} مذکورہ بالا فنکشن بائنری درخت کی جڑ نوڈ کو ان پٹ کے طور پر لیتا ہے اور درخت میں بائیں بائیں پتیوں کا مجموعہ لوٹاتا ہے۔یہ پہلے جانچ پڑتال کرتا ہے کہ آیا جڑ نوڈ کالعدم ہے اور 0 لوٹتا ہے اگر یہ ہے۔اس کے بعد یہ متغیر رقم کو 0 میں شروع کرتا ہے اور چیک کرتا ہے کہ کیا جڑ نوڈ کا بائیں بچہ بائیں پتی ہے۔اگر یہ ہے تو ، اس کی قیمت رقم میں شامل کرتی ہے۔اس کے بعد یہ روٹ نوڈ کے بائیں اور دائیں بچوں پر سوموفلفٹ لیف () فنکشن کو بار بار کال کرتا ہے اور ان کی واپسی کی اقدار کو رقم میں شامل کرتا ہے۔آخر میں ، یہ SUM12345 واپس کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ بائنری درخت میں بائیں بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے سوموفلیفٹلیوس () فنکشن کو کس طرح استعمال کیا جائے: جاواکرپٹ کلاس ٹریڈی {کنسٹرکٹر (وال ، بائیں = NULL) {this.val = ویل ؛this.left = بائیں ؛this.right = دائیں ؛}} آئیے جڑ = نیا ٹرینوڈ (3) ؛ روٹ. لیفٹ = نیا ٹرینوڈ (9) ؛ روٹ. رائٹ = نیا ٹرینوڈ (20) ؛ روٹ۔ رائٹ.یلفٹ = نیا ٹرینوڈ (15) ؛ روٹ. رائٹ. رائٹ = نیاٹرینوڈ (7) smos پیش کریں = سموفلیفٹ لیف (جڑ) ؛ کنسول.لوگ (bi بائنری ٹری میں بائیں بائیں پتیوں کا مجموعہ $ {رقم} `ہے) ؛ یہ پروگرام پہلے بائنری میں نوڈ کی نمائندگی کرنے کے لئے ٹرینوڈ کلاس کی وضاحت کرتا ہے۔درختاس کے بعد یہ بائنری درخت کو روٹ نوڈ اور اس کے بچوں کے ساتھ ٹرینوڈ کلاس کا استعمال کرتے ہوئے شروع کرتا ہے۔یہ بائنری درخت میں بائیں بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے سوموفلیفٹ لیف () فنکشن کہتے ہیں اور اس کے نتیجے کو متغیر رقم میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں بائنری کے درخت میں بائیں بائیں پتیوں کی رقم کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں بائنری درخت میں بائیں بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے تکراری نقطہ نظر یا بائنری نائنری-ٹری لائبریری 16۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "عددی کی ایک مخصوص صف میں کم از کم K عناصر کے ساتھ سبری کی سب سے بڑی رقم تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "انٹیگرسٹو کی ایک دی گئی صف میں کم سے کم K عناصر کے ساتھ ایک سبری کی سب سے بڑی رقم تلاش کرنے کے لئے کام تلاش کرنے کے لئے جاوا اسکرپٹ میں انٹیجرز کی ایک دی گئی صف میں کم از کم کے عناصر کے ساتھ ایک سبری کی سب سے بڑی رقم تلاش کریں ، ہم حساب کے لئے سلائیڈنگ ونڈو نقطہ نظر کا استعمال کرسکتے ہیں۔سائز K کے تمام مضافات کا مجموعہ اور زیادہ سے زیادہ SUM1234 لوٹائیں۔اس فنکشن کا ایک مثال نفاذ ہے: جاوا اسکرپٹ فانکشن سب سے بڑا سبسمسبری (آر ، کے) {اجازت دیں = 0 ؛کے لئے (آئیے i = 0 ؛ i <k ؛ i ++) {رقم+= arr [i] ؛max میکسم = رقم ؛کے لئے (آئیے i = k ؛ i <arr.length ؛ i ++) {رقم+= arr [i] - arr [i - k] ؛میکسم = ریاضی۔ میکس (میکسم ، رقم) ؛max میکسم واپسی ؛ مذکورہ بالا فنکشن ان پٹ کے طور پر انٹیجرز اور ایک نمبر K کی ایک سرنی آر آر لیتا ہے اور صف میں کم از کم کے عناصر کے ساتھ سبری کی سب سے بڑی رقم واپس کرتا ہے۔یہ پہلے سرنی کے پہلے K عناصر کے مجموعہ کی گنتی کرتا ہے اور متغیر میکسم کو رقم میں شروع کرتا ہے۔اس کے بعد یہ صف کے باقی عناصر پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور موجودہ عنصر کو شامل کرکے اور عنصر کے پوزیشنوں کو بائیں طرف گھٹاتے ہوئے موجودہ سبری کے جوڑے کی گنتی کرتا ہے۔یہ میکسم متغیر کو اپ ڈیٹ کرتا ہے اگر موجودہ رقم اب تک دیکھنے میں آنے والی زیادہ سے زیادہ رقم سے زیادہ ہے۔آخر میں ، یہ میکسم 1234 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ کس طرح سب سے بڑے سومسسبری () فنکشن کو استعمال کرنے کے لئے کس طرح ایک سبری کی سب سے بڑی رقم تلاش کرنے کے لئے کم سے کم کے عناصر کے ساتھ عدد کی ایک دی گئی صف میں: جاوا اسکرپٹ آر آر = [1 ، 4.$ {arr} میں $ {میکسم} `ہے) ؛ یہ پروگرام پہلے عددی اور ایک نمبر K کی ایک سرنی آر آر کی شروعات کرتا ہے۔اس کے بعد یہ سب سے بڑے سومسسبری () فنکشن کو کہتے ہیں تاکہ سرے میں کم سے کم K عناصر کے ساتھ سبری کی سب سے بڑی رقم تلاش کی جاسکے اور اس کے نتیجے کو متغیر میکسم میں اسٹور کیا جائے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں سرے میں کم سے کم K عناصر کے ساتھ سبری کی سب سے بڑی رقم کی نشاندہی کی جاتی ہے۔ نوٹ کریں کہ دیگر الگورتھم اور لائبریری موجود ہیں جس میں ایک سبری کی سب سے بڑی رقم تلاش کرنے کے لئے کم از کم کے عناصر کے ساتھ انٹیجرز کی ایک دی گئی صف میں موجود ہیں۔جاوا اسکرپٹ ، جیسے متحرک پروگرامنگ یا لوڈش لائبریری 156 کا استعمال۔تاہم ، سلائیڈنگ ونڈو نقطہ نظر جاوا اسکرپٹ میں حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "دیئے گئے رومن ہندسے کو اس کے اسی اعشاریہ نمبر میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "کسی دیئے گئے رومن ہندسے کو اس سے متعلقہ اعشاریہ میں تبدیل کرنے کے لئے کام کریں ، کسی دیئے گئے رومن ہندسے کو جاوا اسکرپٹ میں اس کے اسی اعشاریہ نمبر میں تبدیل کرنے کے لئے ، ہم ایک فنکشن استعمال کرسکتے ہیں جو رومن ہندسے کے اوپر بائیں سے دائیں تک پہنچ جاتا ہے اور ہر علامت کی قیمت کو چلانے میں شامل کرتا ہے۔کلاگر کسی علامت کی پچھلی علامت کے مقابلے میں ایک چھوٹی سی قیمت ہوتی ہے تو ، ہم اس حقیقت کا محاسبہ کرنے کے لئے رننگ کل سے پچھلے علامت کی دوگنی قیمت کو منہا کرتے ہیں کہ پچھلی علامت کو دو بار 1234 شامل کیا گیا تھا۔اس فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فانکشن رومانٹوڈیسیمل (رومن) {آئیے اقدار = {'i': 1 ، 'v': 5 ، 'x': 10 ، 'l': 50 ، 'c': 100 ، 'd': 500 ،' M ': 1000} ؛آئیے اعشاریہ = 0 ؛چلو = 0 ؛کے لئے (آئیے i = 0 ؛ i <رومن.لنتھ ؛ i ++) {موجودہ = اقدار [رومن [i]] ؛if (موجودہ> prev) {اعشاریہ += موجودہ - 2 * prep ؛} دوسری {اعشاریہ += موجودہ ؛} prep = موجودہ ؛dec اعشاریہ واپسی ؛ مذکورہ بالا فنکشن ان پٹ کے طور پر رومن ہندسے کی نمائندگی کرنے والے رومن رومن لیتا ہے اور اس سے متعلقہ اعشاریہ نمبر لوٹاتا ہے۔یہ پہلے کسی ایسی شے کی اقدار کی ابتدا کرتا ہے جو ہر رومن علامت کو اپنی اعشاریہ قدر پر نقشہ بناتا ہے۔اس کے بعد یہ متغیر اعشاریہ کو 0 اور متغیر سے پہلے کی علامت کی قیمت پر نظر رکھنے کے لئے 0 سے متغیر کی ابتدا کرتا ہے۔یہ رومن ہندسے کے اوپر بائیں سے دائیں تک تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور ہر علامت کی قدر کو اعشاریہ متغیر میں شامل کرتا ہے۔اگر کسی علامت کی پچھلی علامت کے مقابلے میں چھوٹی قیمت ہوتی ہے تو ، یہ اعشاریہ متغیر سے پچھلے علامت کی دوگنی قیمت کو گھٹا دیتا ہے۔آخر میں ، یہ موجودہ علامت کی قیمت میں پیشگی متغیر کو اپ ڈیٹ کرتا ہے اور جب تک تمام علامتوں پر کارروائی نہ ہونے تک لوپ جاری رکھے گی۔یہ اعشاریہ متغیر 1234 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ رومن ہندسے کو رومن ہندسے کو اس کے متعلقہ اعشاریہ میں تبدیل کرنے کے لئے کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ رومن = 'xxvi' ؛ اعشاریہ = رومانٹوسیمل (رومن) ؛ کنسول۔لاگ (`رومن ہندسے $ {رومن} اعشاریہ میں $ {اعشاریہ} کے برابر ہے) ؛ یہ پروگرام سب سے پہلے رومن ہندسے کی نمائندگی کرنے والے اسٹرنگ رومن کا آغاز کرتا ہے۔اس کے بعد یہ رومن ہندسے کو اس کے متعلقہ اعشاریہ () کو اپنے متعلقہ اعشاریہ نمبر میں تبدیل کرنے کے لئے کال کرتا ہے اور اس کے نتیجے کو متغیر اعشاریہ میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں رومن ہندسے اور اس سے متعلقہ اعشاریہ نمبر کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں رومن ہندسے کو اس کے متعلقہ اعشاریہ میں تبدیل کرنے کے لئے دیگر الگورتھم اور لائبریریاں موجود ہیں ، جیسے باقاعدہ اظہار یا ہندسے کی لائبریری 156 استعمال کرنا۔تاہم ، مذکورہ بالا عمل میں جاوا اسکرپٹ میں تبادلوں کو انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار متوازن قوسین کے ساتھ ریاضی کا اظہار ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ اگر دیئے گئے تار میں ایک دیئے گئے تار متوازن قوسین کے ساتھ ایک ریاضی کا اظہار ہے تو چیک کریں کہ کیا دی دی گئی تار جاوا اسکرپٹ میں متوازن قوسین کے ساتھ ایک دیئے گئے تار کا ایک ریاضی کا اظہار ہے ، ہم ایک فنکشن استعمال کرسکتے ہیں جو بائیں سے دائیں سے تار کے اوپر کی تکرار کرتا ہے اور ٹریک رکھنے کے لئے اسٹیک کا استعمال کرتا ہے۔افتتاحی اور اختتامی قوسین کی۔اگر افتتاحی قوسین کا سامنا کرنا پڑتا ہے تو ، اسے اسٹیک پر دھکیل دیا جاتا ہے۔اگر کسی اختتامی قوسین کا سامنا کرنا پڑتا ہے تو ، اس کا موازنہ اسٹیک کے اوپری عنصر سے کیا جاتا ہے۔اگر وہ میچ کرتے ہیں تو ، اوپر عنصر اسٹیک سے پاپ ہوتا ہے۔اگر وہ مماثل نہیں ہیں یا اسٹیک میں کوئی عناصر نہیں ہیں تو ، اظہار کو غیر متوازن سمجھا جاتا ہے۔تکرار کے بعد ، اگر اسٹیک خالی ہے تو ، اظہار کو متوازن 12345 سمجھا جاتا ہے۔اس فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن isbalanced (اظہار) {آئیے اسٹیک = [] ؛کے لئے (آئیے i = 0 ؛ i <اظہار. لمبائی ؛ i ++) {اگر (اظہار [i] === '(' || اظہار [i] === '{' || اظہار [i] === '.{stack.pop () ؛} دوسری صورت میں (اظہار [i] === '}' && اسٹیک۔ لمبائی> 0 && اسٹیک [اسٹیک۔ لمبائی - 1] === '{') {stack.pop () ؛} دوسری صورت میں (اظہار [i] === ']' && اسٹیک۔ لمبائی> 0 && اسٹیک [اسٹیک۔ لمبائی - 1] === '[') {stack.pop () ؛} else {{لوٹ جھوٹی ؛}}} ریٹرن اسٹیک۔ لمبائی === 0 ؛} مذکورہ بالا فنکشن ایک سٹرنگ اظہار لیتا ہے جس میں ریاضی کے اظہار کی نمائندگی کی جاتی ہے اور ان پٹ کے طور پر یہ سچ ثابت ہوتا ہے اگر اظہار میں متوازن قوسین اور غلط ہے۔اور قوسین کو بند کرنا۔ اس کے بعد یہ تار سے دائیں سے دائیں تک تار کے اوپر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور اسٹیک پر قوسین کھولتا ہے اور اسٹیک سے بند ہونے والی قوسین کو پاپ کرتا ہے اگر وہ اسٹیک کے اوپری عنصر سے میل کھاتا ہے۔اگر اختتامی قوسین اسٹیک کے اوپری عنصر سے مماثل نہیں ہے یا اسٹیک میں کوئی عناصر نہیں ہیں تو ، فنکشن غلط لوٹاتا ہے۔تکرار کے بعد ، اگر اسٹیک خالی ہے تو ، فنکشن درست 12345 لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ آئی ایس بیلنسڈ () فنکشن کو یہ معلوم کرنے کے لئے کس طرح استعمال کیا جائے کہ آیا دیئے گئے تار متوازن قوسین کے ساتھ ریاضی کا اظہار ہے: جاوا اسکرپٹ اظہار = '2* (3 + 5) - 4 / (2 + 1) '؛ متوازن = isbalanced (اظہار) ؛ کنسول.لوگ (`اظہار\" $ {اظہار} \"کیا $ {متوازن ہے؟' متوازن ':' غیر متوازن '}`) ؛ یہ پروگرام پہلے ایک تار کے اظہار کی ابتدا کرتا ہے جو ریاضی کے اظہار کی نمائندگی کرتا ہے۔اس کے بعد یہ یہ معلوم کرنے کے لئے isbalanced () فنکشن کو کال کرتا ہے کہ آیا اظہار رائے متوازن قوسین ہے اور اس کے نتیجے میں متغیر متوازن ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا اس اظہار میں متوازن قوسین ہیں یا نہیں۔ یہ نوٹ کریں کہ یہاں دیگر الگورتھم اور لائبریری موجود ہیں کہ آیا یہ چیک کرنے کے لئے کہ کوئی دیئے گئے تار جاوا اسکرپٹ میں متوازن قوسین کے ساتھ ایک ریاضی کا اظہار ہے ، جیسے باقاعدگی سے اظہار یا جے ایس ای پی لائبریری 16۔تاہم ، مذکورہ بالا نفاذ جاوا اسکرپٹ میں چیک انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "الفاظ کی ترتیب کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں اور کسی جملے میں ہر کردار کے معاملے کو متبادل بنائیں۔",
        "Answer": "الفاظ کی ترتیب کو الٹ کرنے اور ہر کردار کے معاملے کو کسی دیئے گئے سزا کے معاملے میں الفاظ کی ترتیب کو تبدیل کرنے کے لئے کام کریں اور جاوا اسکرپٹ میں دیئے گئے جملے میں ہر کردار کے معاملے کو تبدیل کریں ، ہم دو الگ الگ افعال استعمال کرسکتے ہیں۔پہلا فنکشن جملے میں الفاظ کی ترتیب کو پلٹ دے گا ، جبکہ دوسرا فنکشن جملے میں ہر کردار کے معاملے کو متبادل بنائے گا۔اس کے بعد ہم مطلوبہ نتیجہ 123 کو حاصل کرنے کے لئے دونوں افعال کو یکجا کرسکتے ہیں۔ یہاں دو افعال پر عمل درآمد کی ایک مثال ہے: جاوا اسکرپٹ فنکشن ریورسورڈس (جملہ) {آئیے الفاظ = جملہ۔ اسپلٹ ('') ؛الٹ ورڈز = [] ؛کے لئے (آئیے i = words.length-1 ؛ i> = 0 ؛ i--) {الٹ ورڈز.پش (الفاظ [i]) ؛} واپس الٹ ورڈز۔ join ('') ؛} فنکشن الٹرنیٹیکیس (جملہ) {آئیے نتیجہ = '' ؛کے لئے (آئیے i = 0 ؛ i <جملہ۔ لمبائی ؛ i ++) {اگر (i ٪ 2 === 0) {نتیجہ+= جملہ [i] .touppercase () ؛} else {نتیجہ += جملہ [i] .tolowerCase () ؛}} واپسی کا نتیجہ ؛} فنکشن ریورس اینڈالٹرنیٹ (جملہ) {الٹ الٹ = ریورسورڈز (جملہ) ؛آئیے متبادل = الٹرنیٹیکیس (الٹ) ؛واپسی میں ردوبدل ؛} ریورسورڈز () فنکشن ایک سٹرنگ جملہ لیتا ہے جس میں کسی جملے کی نمائندگی ہوتی ہے اور ان پٹ کے طور پر ایک نیا تار واپس کرتا ہے۔یہ سب سے پہلے اسپلٹ () کے طریقہ کار کو استعمال کرتے ہوئے الفاظ کی ایک صف میں جملے کو تقسیم کرتا ہے۔اس کے بعد یہ ایک خالی سرنی الٹ ورڈز کا آغاز کرتا ہے اور الٹ ترتیب میں الفاظ پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور انہیں الٹ ورڈز سرنی پر دھکیل دیتا ہے۔آخر میں ، یہ الٹ ورڈز سرنی میں شامل ہوتا ہے جس میں شمولیت () کے طریقہ کار کا استعمال کرتے ہوئے ایک نئے سٹرنگ میں شامل ہوتا ہے اور اس کا نتیجہ لوٹاتا ہے۔ الٹرنیٹیکیس () فنکشن ان پٹ کی حیثیت سے ایک جملے کی نمائندگی کرنے والے ایک تار کا جملہ لیتا ہے اور ہر کردار کے ساتھ ایک نیا تار واپس کرتا ہے جس میں بڑے اور چھوٹے کے درمیان ردوبدل ہوتا ہے۔یہ خالی تار کے نتائج کی ابتدا کرتا ہے اور جملے میں ہر کردار پر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔اگر کردار کا اشاریہ بھی ہے تو ، یہ ٹپر کیس () کے طریقہ کار کا استعمال کرتے ہوئے کردار کو بڑے میں تبدیل کرتا ہے اور اسے نتیجہ کے تار میں شامل کرتا ہے۔بصورت دیگر ، یہ ٹولور کیس () کے طریقہ کار کا استعمال کرتے ہوئے کردار کو چھوٹے میں تبدیل کرتا ہے اور اسے نتیجہ کے تار میں شامل کرتا ہے۔آخر میں ، یہ نتیجہ کی تار لوٹاتا ہے۔ ریورس اینڈالٹرنیٹ () فنکشن ایک سٹرنگ جملہ لیتا ہے جس میں کسی جملے کی نمائندگی ہوتی ہے اور ان پٹ کے طور پر ایک نیا تار واپس کرتا ہے اور ریورس ترتیب میں الفاظ اور ہر کردار کو بڑے اور چھوٹے کے درمیان ردوبدل کرتا ہے۔یہ سب سے پہلے جملے میں الفاظ کی ترتیب کو الٹ کرنے کے لئے ریورسورڈز () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر الٹ میں ڈال دیتا ہے۔اس کے بعد یہ الٹ سٹرنگ میں ہر کردار کے معاملے کو متبادل بنانے کے لئے الٹراٹیکیس () فنکشن کو کال کرتا ہے اور اس کے نتیجے کو متغیر متبادل میں اسٹور کرتا ہے۔آخر میں ، یہ متبادل تار لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ الفاظ کی ترتیب کو الٹ کرنے کے لئے ریورس اینڈالٹرنیٹ () فنکشن کو کس طرح استعمال کیا جائے اور ہر کردار کے معاملے کو دیئے گئے جملے میں تبدیل کریں: جاوا اسکرپٹ جملہ = 'فوری براؤن فاکسکاہل کتے پر چھلانگ '' الٹ ڈنڈینٹلیٹ = ریورس اینڈالٹرنیٹ (جملہ) ؛ کنسول.لوگ (`سزا\" $ {جملہ} \"بن جاتا ہے\" $ {الٹ ڈیلٹینیٹڈ} \"`) ؛ یہ پروگرام پہلے کسی جملے کی نمائندگی کرنے والے تار کے جملے کو شروع کرتا ہے۔اس کے بعد یہ الفاظ کی ترتیب کو الٹ کرنے اور جملے میں ہر کردار کے معاملے کو تبدیل کرنے کے لئے ریورس اینڈالٹرنیٹ () کے فنکشن کو کہتے ہیں اور اس کے نتیجے میں متغیر الٹ پھٹے ہوئے نتائج کو محفوظ کرتے ہیں۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں اصل جملے اور اس کے نتیجے میں ہونے والے جملے کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں دیئے گئے جملے میں ہر کردار کے معاملے کو تبدیل کرنے کے لئے اور بھی الگورتھم اور لائبریری موجود ہیں ، جیسے باقاعدہ اظہار یا اس کا استعمال کرنا۔لوڈش لائبریری 145۔تاہم ، مذکورہ بالا عمل میں جاوا اسکرپٹ میں مطلوبہ نتیجہ حاصل کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو ہیش ٹیبل ڈیٹا ڈھانچے کی نمائندگی کرے۔کلیدی قدر کے جوڑے داخل کرنے اور بازیافت کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس ایک ہیش ٹیبل ڈیٹا ڈھانچے کے لئے کلیدی قدر کے جوڑے ہیش ٹیبل کو داخل کرنے اور بازیافت کرنے کے طریقوں کے ساتھ ایک ڈیٹا ڈھانچہ ہے جو کلیدی قدر کے جوڑے کو موثر داخل کرنے ، حذف کرنے اور بازیافت کرنے کی اجازت دیتا ہے۔جاوا اسکرپٹ میں ، ہم ایک سرنی اور ہیش فنکشن کا استعمال کرتے ہوئے ہیش ٹیبل کو نافذ کرسکتے ہیں جو ارای 123456 میں اشاریوں کی چابیاں نقشہ بناتا ہے۔ یہاں کلیدی قیمت کے جوڑے داخل کرنے اور بازیافت کرنے کے طریقوں کے ساتھ ہیش ٹیبل ڈیٹا ڈھانچے کے لئے جاوا اسکرپٹ کلاس کا ایک مثال عمل ہے۔جاوا اسکرپٹ کلاس ہیش ٹیبل {کنسٹرکٹر (سائز = 50) {this.buckets = نیا سرنی (سائز) ؛this.size = سائز ؛} ہیش (کلید) {ریٹرن key.tostring (). لمبائی ٪ this.size ؛} سیٹ (کلید ، قدر) {آئیے انڈیکس = this.hash (KEY) ؛اگر (! this.buckets [انڈیکس]) {this.buckets [انڈیکس] = [] ؛} کے لئے (آئیے i = 0 ؛ i <this.buckets [انڈیکس]. لمبائی ؛ i ++) {اگر (this.buckets [index] [i] [0] === key) {this.buckets [انڈیکس] [i] [1] = قدر ؛واپسی ؛}} this.buckets [انڈیکس]. پش ([کلیدی ، قدر]) ؛} get (key) {آئیے انڈیکس = this.hash (key) ؛اگر (! this.buckets [اشاریہ]) {واپس کالعدم ؛} کے لئے (آئیے i = 0 ؛ i <this.buckets [انڈیکس]. لمبائی ؛ i ++) {if (this.buckets [index] [i] [0] === key) {اس کو واپس کریں۔ بوکیٹس [انڈیکس] [i] [1] ؛}} واپس کالعدم ؛}} ہیش ٹیبل کلاس ایک اختیاری سائز کا پیرامیٹر لیتا ہے جو ہیش ٹیبل کے سائز کی وضاحت کرتا ہے۔یہ ہیش ٹیبل کے سائز پر نظر رکھنے کے لئے سائز کے سائز کی ایک سرنی بالٹیوں اور سائز کی پراپرٹی کا آغاز کرتا ہے۔یہ ایک ہیش () طریقہ کی بھی وضاحت کرتا ہے جو ایک کلید لیتا ہے اور بالٹی سرنی میں ایک انڈیکس لوٹاتا ہے۔ سیٹ () کا طریقہ ایک کلید اور ایک قدر لیتا ہے اور ہیش ٹیبل میں داخل کرتا ہے۔یہ پہلے ہیش () طریقہ کار کا استعمال کرتے ہوئے کلید کے انڈیکس کی گنتی کرتا ہے۔اگر کمپیوٹڈ انڈیکس میں بالٹی خالی ہے تو ، یہ اسے خالی صف کے طور پر شروع کرتی ہے۔اس کے بعد یہ چیک کرتا ہے کہ آیا کلید پہلے سے ہی بالٹی میں موجود ہے اور اگر اس کی قیمت کو اپ ڈیٹ کرتا ہے تو۔بصورت دیگر ، یہ کلیدی قدر کی جوڑی کو بالٹی میں شامل کرتا ہے۔ get () کا طریقہ ایک کلید لیتا ہے اور ہیش ٹیبل میں اپنی اسی قدر کو واپس کرتا ہے۔یہ پہلے ہیش () طریقہ کار کا استعمال کرتے ہوئے کلید کے انڈیکس کی گنتی کرتا ہے۔اگر کمپیوٹڈ انڈیکس میں بالٹی خالی ہے تو ، یہ کالعدم واپس آجاتا ہے۔اس کے بعد بالٹی میں کلیدی قدر کے جوڑے پر تکرار کرتا ہے اور پہلی کلید کی قیمت واپس کردیتا ہے جو ان پٹ کلید سے مماثل ہے۔اگر اس طرح کی کوئی کلید نہیں ملتی ہے تو ، یہ کالعدم ہے۔؛// 1console.log (ٹیبل.بیٹ ('کیلے')) ؛// 2console.log (table.get ('چیری')) ؛// 3console.log (ٹیبل.بیٹ ('ڈورین')) ؛// nullthis پروگرام پہلے ایک نیا ہیش ٹیبل آبجیکٹ تشکیل دیتا ہے اور سیٹ () کے طریقہ کار کا استعمال کرتے ہوئے اس میں تین کلیدی قدر کے جوڑے داخل کرتا ہے۔اس کے بعد یہ گیٹ () کے طریقہ کار کا استعمال کرتے ہوئے چابیاں 'ایپل' ، 'کیلے' ، 'چیری' ، اور 'ڈورین' کی اقدار کو بازیافت کرتا ہے اور انہیں کنسول پر پرنٹ کرتا ہے۔ نوٹ کریں کہ ہیش ٹیبل کو نافذ کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں۔جاوا اسکرپٹ میں ڈیٹا کا ڈھانچہ ، جیسے تصادم 123456 کو سنبھالنے کے لئے علیحدہ زنجیروں یا اوپن ایڈریسنگ کا استعمال۔تاہم ، مذکورہ بالا نفاذ جاوا اسکرپٹ میں کلیدی قدر کے جوڑے ڈالنے اور بازیافت کرنے کے طریقوں کے ساتھ ہیش ٹیبل کو نافذ کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "تار کے ایک سیٹ میں سب سے طویل عام مشترکہ حصول تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ پروگرام جس میں سٹرنگسٹو کے ایک سیٹ کے درمیان سب سے طویل عام مشترکہ حصول تلاش کرنے کے لئے جاوا اسکرپٹ میں تاروں کے ایک سیٹ میں سب سے طویل عام مشترکہ حصول تلاش کیا جاتا ہے ، ہم متحرک پروگرامنگ کا استعمال ہر جوڑے کے جوڑے کے سب سے لمبے عام مشترکہ حصول کی لمبائی کی گنتی کے لئے کرسکتے ہیں۔اس کے بعد ہم سب سے طویل عام مشترکہ 1234 کی تشکیل نو کے لئے حساب شدہ لمبائی کا استعمال کرسکتے ہیں۔ یہاں فنکشن کی ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن طویل ترین کامنسوبسینس (ڈور) {let n = strings.length ؛آئیے لمبائی = نئی سرنی (n)کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {for (j = i ؛ j <n ؛ j ++) {اگر (i ==== j) {لمبائی [i] [j] = تار [i]۔لمبائی ؛} else {let m = strings [i]. لمبائی ؛آئیے n = تار [j]. لمبائی ؛آئیے lcs = نئی سرنی (m + 1)کے لئے (آئیے x = 1 ؛ x <= m ؛ x ++) {for (آئیے y = 1 ؛ y <= n ؛ y ++) {اگر (تار [i] [x - 1] === اسٹرنگز [j] [y]- 1]) {lcs [x] [y] = lcs [x - 1] [y - 1] + 1 ؛} else {lcs [x] [y] = math.max (lcs [x - 1] [y] ، lcs [x] [y - 1]) ؛}}} لمبائی [i] [j] = lcs [m] [n] ؛}}} آئیے نتیجہ = '' ؛i = n - 1 ؛آئیے j = n - 1 ؛جبکہ (i> = 0 && j> = 0) {اگر (i === j) {نتیجہ = تار [i] .Substring (0 ، لمبائی [i] [j]) + نتیجہ ؛میں--؛J-- ؛} ورنہ اگر (لمبائی [i] [j] === لمبائی [i] [j-1]) {j-- ؛} ورنہ اگر (لمبائی [i] [j] === لمبائی [i-1] [j]) {i-- ؛} دوسری {نتیجہ = تارمیں--؛J-- ؛}} واپسی کا نتیجہ ؛ lenge سب سے طویل عرصے سے کامنسوبسنس () فنکشن ان پٹ کے طور پر تاروں کی ایک تار تار لیتا ہے اور ان میں سب سے طویل عام مشترکہ حصول کو لوٹاتا ہے۔یہ سب سے پہلے ہر جوڑے کے تاروں کے سب سے لمبے عام مشترکہ حصے کی لمبائی کو ذخیرہ کرنے کے لئے سائز N x n کی ایک صف کی لمبائی کا آغاز کرتا ہے۔اس کے بعد یہ متحرک پروگرامنگ کا استعمال کرتے ہوئے ہر جوڑے کی لمبائی کی لمبائی کی لمبائی کی گنتی کے لئے ایک گھونسلے والے لوپ کا استعمال کرتا ہے۔اگر دونوں ڈور ایک جیسے ہیں تو ، سب سے طویل عام مشترکہ کی لمبائی صرف تار کی لمبائی ہے۔بصورت دیگر ، یہ طویل عرصے سے عام مشترکہ مسئلے کے لئے متحرک پروگرامنگ الگورتھم کا استعمال کرتے ہوئے طویل عرصے تک عام مشترکہ حصول کی لمبائی کی گنتی کے لئے دو جہتی سرنی ایل سی کا استعمال کرتا ہے۔اس کے بعد یہ لمبائی کی لمبائی میں حساب شدہ لمبائی کو ذخیرہ کرتا ہے۔ طویل عرصے تک عام مشترکہ حصوں کی لمبائی کی کمپیوٹنگ کے بعد ، فنکشن لمبائی کی صفوں کو طویل عرصے تک عام مشترکہ حصول کی تشکیل نو کے لئے استعمال کرتا ہے۔یہ خالی تار کے نتیجے میں اور دو اشاریہ I اور J سے N - 1 کا آغاز کرتا ہے۔اگر دونوں اشاریے برابر ہیں تو ، یہ انڈیکس I میں تار کے اسٹرنگ کو شامل کرتا ہے جس کی لمبائی لمبائی کے برابر ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے جس کی لمبائی ہوتی ہے اور دونوں اشاریوں میں کمی ہوتی ہے۔بصورت دیگر ، یہ جانچ پڑتال کرتا ہے کہ اگر انڈیکس I اور J - 1 میں دونوں تار کے سب سے لمبے عام مشترکہ حصے کی لمبائی انڈیکس I - 1 اور J میں دو تار کے سب سے طویل عام حصول کی لمبائی سے زیادہ یا اس کے برابر ہے۔اگر یہ ہے تو ، یہ j میں کمی کرتا ہے۔بصورت دیگر ، اس میں کمی آئی۔آخر میں ، اگر انڈیکس I اور J میں دو تار کی لمبائی کی لمبائی انڈیکس I - 1 اور J - 1 میں دو تار کی لمبائی سے زیادہ ہے تو ، اس میں تار کی سٹرنگ شامل ہوتی ہے۔انڈیکس I میں لمبائی کے ساتھ لمبائی کے برابر عام مشترکہ متنازعہ مائنس انڈیکس I - 1 اور J - 1 میں دو تار کی لمبائی کی لمبائی کی لمبائی I - 1 اور J - 1 کے نتیجے میں سٹرنگ اور دونوں اشاریہ جات میں کمی۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹکوڈ یہ ظاہر کرتا ہے کہ تار کے ایک سیٹ کے درمیان سب سے طویل عام مشترکہ حصول تلاش کرنے کے لئے طویل عرصے سے کامنسوبسینس () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لات({{{ڈوروں کے درمیان سب سے طویل عام مشترکہ} ہے {{lcs} `) ؛ یہ پروگرام سب سے پہلے ڈوروں کی صفوں کے تاروں کو شروع کرتا ہے۔اس کے بعد اس نے تار کے درمیان سب سے طویل عام مشترکہ حصول تلاش کرنے کے لئے سب سے طویل عرصے سے کامنسوبسنس () فنکشن کہا ہے اور اس کے نتیجے میں متغیر ایل سی میں نتیجہ اخذ کیا جاتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں ان پٹ ڈور اور اس کے نتیجے میں اشارہ ہوتا ہے"
    },
    {
        "Question": "کسی دیئے گئے اعشاریہ نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "ایک دیئے گئے اعشاریہ نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے کام جاوا اسکرپٹ میں ایک دیئے گئے اعشاریہ نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے ، ہم ایک ایسے فنکشن کا استعمال کرسکتے ہیں جو تکراری طور پر اعشاریہ نمبر سے سب سے بڑی ممکنہ رومن ہندسے کی قیمت کو گھٹا دیتا ہے اور اسی طرح کے رومن ہندسے کو نتیجہ کے تار میں شامل کرتا ہے جب تکاعشاریہ تعداد صفر ہے۔ہم رومن ہندسوں کی علامتوں اور ان کے متعلقہ اعشاریہ اقدار 123 کو ذخیرہ کرنے کے لئے ایک صف کا استعمال کرسکتے ہیں۔ یہاں فنکشن کی ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن اعشاریہ اعشاریہ (اعشاریہ) {چلیں رومانسمبولز = ['ایم' ، 'سی ایم' ، 'سی ایم' ، 'ڈی' ، 'سی ڈی'، 'c' ، 'xc' ، 'l' ، 'xl' ، 'x' ، 'ix' ، 'v' ، 'iv' ، 'i'] ؛چلیں رومانوالیس = [1000 ، 900 ، 500 ، 400 ، 100 ، 90 ، 50 ، 40 ، 10 ، 9 ، 5 ، 4 ، 1] ؛آئیے نتیجہ = '' ؛کے لئے (آئیے i = 0 ؛ i <رومانوالیوز۔ لمبائی ؛ i ++) {جبکہ (اعشاریہ> = رومانوالیوز [i]) {نتیجہ+= رومانسمبولس [i] ؛اعشاریہ -= رومانوالیوز [i] ؛} return واپسی کا نتیجہ ؛ dec ڈیسملٹورومن () فنکشن ان پٹ کے طور پر اعشاریہ اعشاریہ اعشاریہ اعصابی طور پر لے جاتا ہے اور اس سے متعلقہ رومن ہندسے کو تار کے طور پر لوٹاتا ہے۔اس نے پہلے رومن ہندسوں کی علامتوں اور ان کی متعلقہ اعشاریہ اقدار کو ذخیرہ کرنے کے لئے دو صفوں رومانسمبولز اور رومانوالیوز کا آغاز کیا ہے۔اس کے بعد اس کے نتیجے میں رومن ہندسے کو ذخیرہ کرنے کے لئے خالی تار کا نتیجہ شروع ہوتا ہے۔یہ ایک لوپ کا استعمال رومیولیس سرنی پر سب سے بڑے سے چھوٹے سے تکرار کرنے کے لئے کرتا ہے اور اعشاریہ نمبر سے سب سے بڑی ممکنہ رومن ہندسے کی قیمت کو گھٹا دیتا ہے اور اس سے متعلقہ رومن ہندسے کو نتیجہ کے تار میں شامل کرتا ہے جب تک کہ اعشاریہ کی تعداد صفر نہ ہو۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈاعشاریہ کی تعداد کو رومن ہندسوں میں تبدیل کرنے کے لئے اعشاریہ کے فنکشن کو کس طرح استعمال کرنے کا مظاہرہ کرتا ہے: جاوا اسکرپٹ لیٹ اعشاریہ = 1234 ؛ رومن = اعشاریہ (اعشاریہ) ؛ کنسول.لوگ (`اعشاریہ نمبر $ {اعشاریہ {رومن میں $ {رومن} ہے}ہندسوں) ؛ یہ پروگرام سب سے پہلے اعشاریہ اعشاریہ اعشاریہ کا آغاز کرتا ہے۔اس کے بعد یہ اعشاریہ کی تعداد کو رومن ہندسوں میں تبدیل کرنے کے لئے اعشاریہ () فنکشن کہتے ہیں اور اس کے نتیجے کو متغیر رومن میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں اصل اعشاریہ نمبر اور اس سے متعلقہ رومن ہندسے کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں اعشاریہ کی تعداد کو رومن ہندسوں میں تبدیل کرنے کے لئے دیگر الگورتھم اور لائبریریاں موجود ہیں ، جیسے تکرار یا عددی. جے ایس لائبریری 145 کا استعمال۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں تبادلوں کو انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "کسی بھی حد میں یہاں تک کہ تمام نمبروں کی رقم کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "کسی دیئے گئے رینجٹو میں یہاں تک کہ تمام نمبروں کے جوڑے کا حساب لگانے کے لئے کام جاوا اسکرپٹ میں دیئے گئے رینج میں تمام نمبروں کے مجموعہ کا حساب لگائیں ، ہم حد سے زیادہ تکرار کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں اور یہاں تک کہ تمام تعداد کو شامل کرسکتے ہیں۔ہم ماڈیولس آپریٹر کو یہ چیک کرنے کے لئے استعمال کرسکتے ہیں کہ آیا کوئی نمبر بھی 12 ہے۔ یہاں فنکشن کی ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن سموفینومبرسینرینج (اسٹارٹ ، اختتام) {اجازت دیں SOM = 0 ؛کے لئے (i = start ؛ i <= end ؛ i ++) {اگر (i ٪ 2 === 0) {رقم+= i ؛}} واپسی کا مجموعہ ؛ so سموفیویننومبرینرینج () فنکشن ان پٹ کے طور پر دو عدد شروع اور اختتام پر لے جاتا ہے اور شروع سے اختتام تک حد میں تمام نمبروں کی رقم کو واپس کرتا ہے۔یہ ایک متغیر رقم کو صفر پر شروع کرتا ہے اور شروع سے اختتام تک حد سے زیادہ تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔اگر موجودہ تعداد بھی ہے تو ، اس نے اسے متغیر میں شامل کیا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ ایک مخصوص رینج میں تمام اعداد کی رقم کا حساب کتاب کرنے کے لئے سوموف ایونومبرینرینج () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ اسٹارٹ = 1 ؛اختتام = 10 ؛ آئیے SUM = sumofevenumbersinrange (start ، end) ؛ کنسول.لوگ (`رینج میں یہاں تک کہ تمام تعداد کا مجموعہ $ {start} to $ {اختتام} ہے $ {sum}`) ؛ یہ پروگرام پہلے دو کی ابتدا کرتا ہےانٹیجرز شروع اور اختتام پر۔اس کے بعد یہ sumofevenumbersinrange () فنکشن کو فون کرتا ہے تاکہ شروع سے اختتام تک کی حد میں تمام تعداد کے جوڑے کا حساب لگایا جاسکے اور اس کے نتیجے میں متغیر رقم میں اسٹور کیا جائے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں ان پٹ رینج اور اس کے نتیجے میں ہونے والی رقم کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں دیئے گئے رینج میں یہاں تک کہ تمام نمبروں کی رقم کا حساب لگانے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے ریاضی سیریز یا لوڈش لائبریری 123 کا استعمال۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں زیادہ تر K عناصر کے ساتھ سب سے زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "انٹیگرسٹو کی ایک مخصوص صف میں زیادہ تر K عناصر کے ساتھ ایک سبری کا زیادہ سے زیادہ رقم تلاش کرنے کے لئے فنکشن جاوا اسکرپٹ میں ایک دیئے گئے عدد کی ایک دی گئی صف میں زیادہ تر کے عناصر کے ساتھ ایک سبری کا زیادہ سے زیادہ مجموعہ تلاش کریں ، ہم سلائیڈنگ ونڈو تکنیک کا استعمال کرسکتے ہیں۔ہم سرنی کے آغاز تک دو پوائنٹرز کو شروع کرسکتے ہیں ، شروع اور اختتام کرسکتے ہیں اور اختتام پوائنٹر کو دائیں طرف منتقل کرنے کے لئے ایک لوپ کا استعمال کرسکتے ہیں جب تک کہ ونڈو کا سائز K سے زیادہ نہ ہو۔اس کے بعد ہم اسٹارٹ پوائنٹر کو دائیں طرف منتقل کرسکتے ہیں جب تک کہ ونڈو کا سائز K سے کم یا اس کے برابر نہ ہو۔ہم اب تک دیکھنے میں آنے والی زیادہ سے زیادہ رقم پر نظر رکھ سکتے ہیں اور جب بھی ایک نئی زیادہ سے زیادہ 12 پائے جاتے ہیں تو اس کی تازہ کاری کر سکتے ہیں۔ یہاں فنکشن کی ایک مثال عمل ہے: جاوا اسکرپٹ فینکشن میکسسومسوبری ویتھکلیمنٹس (اے آر آر ، کے) {شروع کریں = 0 ؛آخری = 0 ؛چلو = 0 ؛آئیے maxsum = -infinity ؛جبکہ (اختتام <arr.length) {sum += arr [اختتام] ؛اگر (اختتام - اسٹارٹ + 1> K) {رقم - = arr [start] ؛شروع ++ ؛} if (end - start + 1 === K) {میکسم = ریاضی.میکس (میکسم ، رقم) ؛} اختتام ++ ؛max میکسم واپس کریں ؛ max میکسسموسبرری ویتھ کلیئیمنٹس () فنکشن ان پٹ کے طور پر انٹیجرز اور ایک نمبر K کی ایک سرنی آر آر لیتا ہے اور زیادہ تر کے عناصر کے ساتھ اے آر آر کے کسی بھی ذیلی حصے کی زیادہ سے زیادہ رقم واپس کرتا ہے۔یہ سرنی کے آغاز تک دو پوائنٹرز ، اسٹارٹ اور اینڈ کا آغاز کرتا ہے اور ایک متغیر رقم صفر سے ہوتا ہے۔یہ اب تک دیکھنے میں آنے والی زیادہ سے زیادہ رقم کو ٹریک رکھنے کے لئے ایک متغیر میکسم کو منفی انفینٹی کے لئے بھی شروع کرتا ہے۔جب تک ونڈو کا سائز K سے زیادہ نہ ہو تب تک اختتام پوائنٹر کو دائیں طرف منتقل کرنے کے لئے یہ ایک لوپ کا استعمال کرتا ہے۔اس کے بعد جب تک کھڑکی کا سائز K سے کم یا اس کے برابر نہ ہو تب تک یہ اسٹارٹ پوائنٹر کو دائیں طرف منتقل کرتا ہے۔یہ اب تک دیکھنے میں آنے والی زیادہ سے زیادہ رقم پر نظر رکھتا ہے اور جب بھی کوئی نئی زیادہ سے زیادہ پائی جاتی ہے تو اسے اپ ڈیٹ کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ زیادہ تر کے عناصر میں زیادہ سے زیادہ کے عناصر کے ساتھ ایک سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے میکسسموسوبری ویتھکلیمنٹس () فنکشن کو کس طرح استعمال کیا جائے۔عدد کی ایک دی گئی صف: جاوا اسکرپٹ لیٹ آر = [4 ، 2 ، 3 ، 5 ، 1 ، 2] K K = 3 چلو max میکسسم = میکسسموسوبری ویتھکلیمنٹس (ار ، کے) ؛ کنسول.لوگ (`سب سے زیادہ سے زیادہ رقم ایک سب رے کے ساتھزیادہ تر $ {K} عناصر میں $ {arr} میں $ {میکسم} `ہے) ؛ یہ پروگرام پہلے انٹیجرز اور ایک نمبر K کی ایک سرنی آر آر کی شروعات کرتا ہے۔اس کے بعد اس نے ARR میں زیادہ تر K عناصر کے ساتھ ایک سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے میکسسمسبری ویتھکلیمنٹس () فنکشن کو فون کیا ہے اور اس کے نتیجے کو متغیر میکسم میں اسٹور کیا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں ان پٹ سرنی اور اس کے نتیجے میں زیادہ سے زیادہ رقم کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں ایک دیئے گئے عدد کی ایک صف میں زیادہ تر کے عناصر کے ساتھ ایک سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے متحرک استعمال کرنا۔پروگرامنگ یا لوڈش لائبریری 134۔تاہم ، مذکورہ بالا عمل درآمد جاوا اسکرپٹ میں سلائیڈنگ ونڈو تکنیک کا استعمال کرتے ہوئے حساب کتاب کرنے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "الفاظ کی ترتیب کو الٹ کرنے اور کسی جملے میں ہر کردار کے معاملے کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "الفاظ کی ترتیب کو الٹ کرنے اور ہر کردار کے معاملے کو کسی دیئے گئے سزا کے معاملے کو الٹ کرنے کے لئے کام کرنے کے لئے الفاظ کی ترتیب کو الٹ دیں اور جاوا اسکرپٹ میں دیئے گئے جملے میں ہر کردار کے معاملے کو الٹ دیں ، ہم اسپلٹ () ، ریورس () ، شامل ہوسکتے ہیں۔() ، اور نقشہ () الفاظ کی ترتیب کو الٹ کرنے کے طریقے اور اسپلٹ () ، ریورس () ، جوائن () ، اور ٹولور کیس ()/ٹپرکیس () ہر کردار 12 کے معاملے کو پلٹانے کے طریقے۔ اس کی مثال کے طور پر عمل درآمدفنکشن: جاوا اسکرپٹ فنکشن ریورس وورڈسینڈ کیس (جملہ) {الفاظ = جملہ۔ split ('' ') ؛الٹ ورڈز = الفاظ۔ ریورس () ؛الٹ سنٹیننس = الٹ ورڈز۔ join ('') ؛آئیے الٹ کیس = الٹ سنسٹینس۔ اسپلٹ ('')۔ نقشہ ((چار) => {اگر (چار === چار.ٹولور کیس ()) {واپس چار.ٹوپپر کیس () ؛} دوسری {ریٹرن چار.ٹولور کیس () ؛}}}). شامل ہوں ('') ؛واپسی الٹ کیس ؛} ریورسورورڈسینڈ کیس () فنکشن ان پٹ کے طور پر ایک تار کا جملہ لیتا ہے اور ایک نیا تار واپس کرتا ہے جس میں الفاظ کا حکم الٹ ہوتا ہے اور ہر کردار کا معاملہ الٹ جاتا ہے۔یہ سب سے پہلے ان پٹ جملہ کو اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتا ہے اور ریورس () طریقہ کار کا استعمال کرتے ہوئے الفاظ کے ترتیب کو تبدیل کرتا ہے۔اس کے بعد یہ الٹ الفاظ میں شامل ہوجاتا ہے جس میں شمولیت () کے طریقہ کار کا استعمال کرتے ہوئے ایک تار میں شامل ہوتا ہے۔اس کے بعد یہ الٹ جملے کو اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے حروف کی ایک صف میں تقسیم کرتا ہے اور نقشہ () کے طریقہ کار اور ٹولور کیس ()/ٹپر کیس () طریقوں کا استعمال کرتے ہوئے ہر کردار کو اپنے مخالف کیس میں نقشہ دیتا ہے۔آخر میں ، یہ نقشہ دار حروف کو جوائن () کے طریقہ کار کا استعمال کرتے ہوئے ایک تار میں شامل کرتا ہے۔جملہ: جاوا اسکرپٹ لیٹ جملہ = 'تیز براؤن فاکس سست کتے کے اوپر چھلانگ لگا دیتا ہے۔'اس کے بعد یہ الفاظ کی ترتیب کو الٹ کرنے اور ہر کردار کے معاملے کو جملے میں الٹ کرنے کے لئے ریورسورڈسینڈ کیس () کے فنکشن کو کہتے ہیں اور اس کے نتیجے میں متغیر الٹ میں ہوتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں ان پٹ جملہ اور اس کے نتیجے میں الٹ جملے کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ الفاظ کی ترتیب کو الٹ کرنے اور جاوا اسکرپٹ میں دیئے گئے جملے میں ہر کردار کے معاملے کو پلٹانے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے باقاعدگی سے تاثرات استعمال کرنا یالوڈش لائبریری 132۔تاہم ، مذکورہ بالا عمل درآمد اسپلٹ () ، ریورس () ، جوائن () ، اور نقشہ () کے طریقوں کو جاوا اسکرپٹ میں استعمال کرتے ہوئے گنتی انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو لاحقہ درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہو۔سبسٹرنگز کو تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "سبسٹرانگسا لاحقہ درخت تلاش کرنے کے طریقوں کے ساتھ لاحقہ درخت کے اعداد و شمار کے ڈھانچے کے لئے جاوا اسکرپٹ کلاس کسی دیئے گئے متن کے تمام لاحقہ کے لئے ایک کمپریسڈ ٹرائی ہے ، اور پیٹرن 1 کی تلاش میں انتہائی کارآمد ہے۔جاوا اسکرپٹ میں ، ہم مختلف الگورتھم اور لائبریری 231456 کا استعمال کرتے ہوئے ایک لاحقہ درخت کے ڈیٹا ڈھانچے کو نافذ کرسکتے ہیں۔یہاں ایک لاحقہ درخت کے اعداد و شمار کے ڈھانچے کے لئے جاوا اسکرپٹ کلاس کا ایک مثال عمل ہے جس میں سبسٹرنگز تلاش کرنے کے طریقوں کے ساتھ: جاوا اسکرپٹ کلاس لاحقہ لاحقہ {کنسٹرکٹر (متن) {this.root = {} ؛this.endsymbol = '*' ؛this.populatesuffixtree (متن) ؛} پاپولیٹیسفکسٹری (متن) {کے لئے (i = 0 ؛ i <text.length ؛ i ++) {this.insertsubstringstartingat (i ، text) ؛}} intersubstringstartingat (startidx ، متن) {آئیے نوڈ = this.root ؛کے لئے (آئیے i = startidx ؛ i <text.length ؛ i ++) {چلیں چار = متن [i] ؛اگر (! (نوڈ میں چار)) {نوڈ [چار] = {} ؛} نوڈ = نوڈ [چار] ؛} نوڈ [this.endsymbol] = سچ ؛susssubstring (string) {let node = this.root ؛کے لئے (آئیے i = 0 ؛ i <string.length ؛ i ++) {چلیں چار = سٹرنگ [i] ؛اگر (! (نوڈ میں چار)) {غلط لوٹیں ؛} نوڈ = نوڈ [چار] ؛this اس کو نوڈ میں endsymbol واپس کریں ؛}} لاحقہ کلاس ان پٹ کے طور پر سٹرنگ ٹیکسٹ لیتا ہے اور پاپولیٹیسفکسٹری () کے طریقہ کار کا استعمال کرتے ہوئے لاحقہ درخت کے ڈیٹا ڈھانچے کو شروع کرتا ہے۔اس میں لاحقہ درخت میں دیئے گئے انڈیکس سے شروع ہونے والے ایک سٹرنگ داخل کرنے کے لئے ایک INSERTSUSBSTRINGSTARTINGAT () کے طریقہ کار کی بھی وضاحت کی گئی ہے اور یہ چیک کرنے کے لئے کہ آیا لاحقہ درخت میں دیئے گئے سٹرنگ موجود ہے یا نہیں۔Insertsubstringstartingat () کا طریقہ دیئے گئے انڈیکس سے شروع ہونے والے اسٹرنگ کے کرداروں پر تکرار کرتا ہے اور انہیں لاحقہ درخت میں داخل کرتا ہے۔اگر ہر کردار لاحقہ درخت میں موجود ہے تو دیئے گئے اسٹرنگ اور چیک کے کرداروں پر مشتمل ہے۔اگر آخری علامت آخری نوڈ میں موجود ہے تو ، سٹرنگ لاحقہ درخت میں موجود ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ کسی دیئے گئے متن میں ذیلی ذخیروں کی تلاش کے ل s لاحقہ لاحقہ کلاس کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ ٹیکسٹ = 'کیلے' ؛آئیے لاحقہ = نیا لاحقہ (متن) ؛ کنسول.لوگ (`{{متن} کے لئے لاحقہ درخت ہے:` ، لاحقہ) ؛ کنسول.لوگ (`لاحقہ درخت میں 'عنا' ہوتا ہے:` ، لاحقیت۔') ؛ کنسول.لوگ (`لاحقہ درخت میں' انا 'پر مشتمل ہوتا ہے:` ، لاحقہ')) ؛ یہ پروگرام سب سے پہلے تار کے متن کی ابتدا کرتا ہے۔اس کے بعد یہ ٹیکسٹ سٹرنگ کا استعمال کرتے ہوئے ایک نیا لاحقہ آبجیکٹ تیار کرتا ہے اور اسے متغیر لاحقہ میں اسٹور کرتا ہے۔اس کے بعد کنسول پر لاحقہ لاحقہ آبجیکٹ کو پرنٹ کرتا ہے۔آخر میں ، یہ اس بات کی جانچ پڑتال کے لئے کنٹسبسٹرنگ () کا طریقہ استعمال کرتا ہے کہ آیا سبسٹرانگز 'انا' ، 'انا' ، اور 'ایپل' لاحقہ درخت میں موجود ہیں اور نتائج کو کنسول پر پرنٹ کرتے ہیں۔ نوٹ کریں کہ اس پر عمل درآمد کے لئے دیگر الگورتھم اور لائبریری موجود ہیں۔جاوا اسکرپٹ میں ایک لاحقہ درخت کے اعداد و شمار کا ڈھانچہ ، جیسے یوکونن کے الگورتھم یا لاحقہ ٹری لائبریری 231456 کا استعمال۔تاہم ، مذکورہ بالا عمل درآمد ایک لاحقہ درخت کے اعداد و شمار کے ڈھانچے کو نافذ کرنے کا ایک آسان اور موثر طریقہ ہے جس میں جاوا اسکرپٹ میں سبسٹرنگز تلاش کرنے کے طریقوں کے ساتھ۔"
    },
    {
        "Question": "دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ پروگرام جاوا اسکرپٹ میں دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے سب سے طویل پیلنڈرومک اسٹریٹنگ تلاش کرنے کے لئے ، ہم مختلف الگورتھم اور تکنیک جیسے بروٹ فورس ، متحرک پروگرامنگ ، اور ماناچر کے الگورتھم 12 کا استعمال کرسکتے ہیں۔متحرک پروگرامنگ کا استعمال کرتے ہوئے دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے جاوا اسکرپٹ فنکشن کا ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن سب سے طویل عرصے سے پالندرمکسوبسٹرنگ (STR) {nt n = str.length ؛آئیے ٹیبل = نیا سرنی (n). فل (). نقشہ (() => نیا سرنی (n). فل (غلط)) ؛آئیے زیادہ سے زیادہ = 1 ؛آئیے شروع کریں = 0 ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {ٹیبل [i] [i] = سچ ؛} کے لئے (آئیے i = 0 ؛ i <n - 1 ؛ i ++) {اگر (str [i] ==== str [i + 1]) {ٹیبل [i] [i + 1] = سچ ؛شروع = i ؛زیادہ سے زیادہ = 2 ؛}} کے لئے (آئیے k = 3 ؛ k <= n ؛ k ++) {for (i = 0 ؛ i <n - k+1 ؛ i ++) {j = i+k - 1 ؛اگر (ٹیبل [i + 1] [j - 1] && str [i] === str [j]) {ٹیبل [i] [j] = سچ ؛if (k> میکس لمبائی) {start = i ؛maxlength = k ؛st}}} واپس str.substring (شروع کریں ، اسٹارٹ + میکس لمبائی) ؛ lenget سب سے طویل پلائنڈرمکسبسٹرنگ () فنکشن ان پٹ کے طور پر ایک تار سٹر لگاتا ہے اور ایس ٹی آر میں سب سے طویل پیلنڈرومک سبسٹرنگ لوٹاتا ہے۔یہ ذخیرہ کرنے کے لئے دو جہتی سرنی ٹیبل کی ابتدا کرتا ہے چاہے ایک سٹرنگ ایک پالندرووم ہے یا نہیں۔یہ ایس ٹی آر اور چیک کے ہر ممکنہ ذیلی ذخیروں پر تکرار کرنے کے لئے ایک گھونسلے والے لوپ کا استعمال کرتا ہے اگر ہر سٹرنگ متحرک پروگرامنگ کا استعمال کرتے ہوئے ایک پیلنڈرووم ہے۔اگر ایک سٹرنگ ایک پیلنڈرووم ہے اور اس کی لمبائی موجودہ زیادہ سے زیادہ لمبائی سے زیادہ ہے تو ، یہ زیادہ سے زیادہ لمبائی کو اپ ڈیٹ کرتی ہے اور متغیرات کو شروع کرتی ہے۔آخر میں ، یہ سب سے طویل پیلنڈرومک سبسٹرنگ لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ سے یہ ظاہر ہوتا ہے کہ ایک دیئے گئے تار میں سب سے طویل پیلنڈرومک سبسٹرنگ تلاش کرنے کے لئے طویل عرصے تک پالائنڈرومکسبسٹرینگ () فنکشن کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ لیٹ str = 'بیباڈ' let طویل ترینپالینڈرمیکسوبسٹر = طویل ترین پرائنڈرمیکسوبسٹر = لانگ ٹینڈرومیکسبسٹر = طویل ترینپالینڈپالینڈروڈروڈروڈٹر = طویل ترینپالینڈپالینڈرکسبسٹر کو دیں؛ کنسول.لوگ ($ {{str} میں سب سے طویل پیلنڈرومک اسٹرنگ $ {longerestpalindromicsubstr} `ہے) ؛ یہ پروگرام سب سے پہلے سٹرنگ ایس ٹی آر کو شروع کرتا ہے۔اس کے بعد یہ ایس ٹی آر میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے ل the سب سے طویل پالائنڈرومکسبسٹرنگ () فنکشن کہتے ہیں اور اس کے نتیجے کو متغیر طویل ترین پالندومکسبسٹر میں اسٹور کرتا ہے۔آخر میں ، یہ ایک پیغام پرنٹ کرتا ہے جس میں ان پٹ سٹرنگ اور اس کے نتیجے میں سب سے طویل پیلنڈرومک سسٹرنگ کی نشاندہی ہوتی ہے۔ نوٹ کریں کہ جاوا اسکرپٹ میں دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے دیگر الگورتھم اور لائبریری موجود ہیں ، جیسے بروٹ فورس یا ماناچر کے الگورتھم 12 کا استعمال کرنا۔تاہم ، مذکورہ بالا نفاذ جاوا اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے کمپیوٹیشن کو انجام دینے کا ایک آسان اور موثر طریقہ ہے۔"
    },
    {
        "Question": "عدد کے دھارے کے وسط کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "انٹیگرسٹو کے ایک دھارے کے درمیانی حصے کو تلاش کرنے کے لئے کام جاوا اسکرپٹ میں عددیوں کے ایک دھارے کو تلاش کریں ، ہم مختلف الگورتھم اور تکنیک جیسے متحرک پروگرامنگ ، ڈھیروں ، اور ترجیحی قطار 123456 استعمال کرسکتے ہیں۔یہاں ایک ڈیٹا ڈھانچے کے لئے جاوا اسکرپٹ کلاس کا ایک مثال عمل ہے جو انٹیجرز کی متحرک طور پر بڑھتی ہوئی فہرست کو محفوظ کرتا ہے اور دو ہیپس کا استعمال کرتے ہوئے O (1) وقت میں ان کے میڈین تک رسائی فراہم کرتا ہے: جاوا اسکرپٹ کلاس میڈین فائنڈر {کنسٹرکٹر () {this.minheap = new minheap (new minheap (new minheap ()) ؛this.maxheap = new maxheap () ؛} ایڈنم (نمبر) {اگر (this.maxheap.isempty () || num <this.maxheap.peek ()) {this.maxheap.insert (num) ؛} else {this.minheap.insert (num) ؛} if (this.maxheap.size ()> this.minheap.size () + 1) {this.minheap.insert (this.maxheap.remove ()) ؛} ورنہ اگر (this.minheap.size ()> this.maxheap.size ()) {this.maxheap.insert (this.minheap.remove ()) ؛}} findmedian () {if (this.maxheap.size () === this.minheap.size ()) {واپسی (this.maxheap.peek () + this.minheap.peek ()) / 2 ؛} دوسری {اس کو واپس کریں۔ میکس ہیپ.پیک () ؛}}} کلاس منیہپ {کنسٹرکٹر () {this.heap = [] ؛} سائز () {اس کو واپس کریں۔} isempty () {اس کو واپس کردیں۔ لمبائی === 0 ؛} داخل کریں (نمبر) {this.heap.push (num) ؛this.bubbleup (this.heap.length - 1) ؛} ہٹائیں () min منٹ = this.heap [0] ؛آئیے آخری = this.heap.pop () ؛اگر (! this.isempty ()) {this.heap [0] = آخری ؛this.bbbledown (0) ؛} واپسی منٹ ؛} جھانکنے () {اس کو واپس کریں۔ ہیپ [0] ؛} بلبلاپ (IDX) {PARENTIDX = math.floor ((idx - 1) / 2) ؛جبکہ (idx> 0 && this.heap [idx] <this.heap [parentidx]) {[this.heap [idx] ، this.heap [parentidx]] = [this.heap [parentidx] ، this.heap [idx]] ؛idx = parentidx ؛پیرنٹڈیکس = ریاضی۔ فلور ((IDX - 1) / 2) ؛}} بلبلیڈاؤن (IDX) {letthildidx = idx * 2 + 1 ؛آئیے دائیں بچے کی idx = idx * 2 + 2 ؛آئیے minchildidx = idx ؛اگر (بائیں بچے کے idx <this.heap.length && this.heap [بائیں بچے کے idx] <this.heap [min نہند x]) {min نہند id x = بائیں بچے کے idx ؛} if (rightichididx <this.heap.length && this.heap [retightichididx] <this.heap [minchildIdx]) {mindishidx = دائیں بچے کے idx ؛} if (minchididx! == idx) {[this.heap [idx] ، this.heap [minchididx]] = [this.heap [mincoodidx] ، this.heap [idx]] ؛this.bbbledown (minchididx) ؛}}} کلاس میکس ہیپ {کنسٹرکٹر () {this.heap = [] ؛} سائز () {اس کو واپس کریں۔} isempty () {اس کو واپس کردیں۔ لمبائی === 0 ؛} داخل کریں (نمبر) {this.heap.push (num) ؛this.bubbleup (this.heap.length - 1) ؛} ہٹائیں () {آئیے زیادہ سے زیادہ = this.heap [0] ؛آئیے آخری = this.heap.pop () ؛اگر (! this.isempty ()) {this.heap [0] = آخری ؛this.bbbledown (0) ؛} زیادہ سے زیادہ واپسی ؛} جھانکنے () {اس کو واپس کریں۔ ہیپ [0] ؛} بلبلاپ (IDX) {PARENTIDX = math.floor ((idx - 1) / 2) ؛جبکہ (idx> 0 && this.heap [idx]> this.heap [parentidx]) {[this.heap [idx] ، this.heap [parentidx]] = [this.heap [parentidx] ، this.heap [idx]] ؛idx = parentidx ؛پیرنٹڈیکس = ریاضی۔ فلور ((IDX - 1) / 2) ؛}} بلبلیڈاؤن (IDX) {letthildidx = idx * 2 + 1 ؛آئیے دائیں بچے کی idx = idx * 2 + 2 ؛آئیے maxchildIdx = idx ؛اگر (بائیں طرف سے <this.heap.length && this.heap [ligechildidx]> this.heap [maxchildIdx]) {maxchildIdx = بائیں بچے کے idx ؛} if (rightichididx <this.heap.length && this.heap [rightichildIdx]> this.heap [maxchildIdx]) {maxchildIdx = دائیں بچے کی idx ؛} if (maxchildIdx! == idx) {[this.heap [idx] ، this.heap [maxchildIdx]] = [this.heap [maxchildIdx] ، this.heap [idx]] ؛this.bbbledown (maxchildidx) ؛}} med میڈین فائنڈر کلاس کوئی ان پٹ نہیں لیتا ہے اور دو ڈھیر ، ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر شروع کرتا ہے۔اس میں اب تک دکھائے جانے والے عدد کے درمیانی حصے کو تلاش کرنے کے لئے ڈیٹا ڈھانچے میں ایک نیا عدد اور ایک فائنڈ میڈین () طریقہ شامل کرنے کے لئے ایک ایڈنم () طریقہ کی بھی وضاحت کی گئی ہے۔ایڈنم () کا طریقہ کار کو مناسب ڈھیر میں داخل کرتا ہے اور میڈین کو برقرار رکھنے کے لئے ڈھیروں کو متوازن کرتا ہے۔فائنڈ میڈین () کا طریقہ اب تک نظر آنے والے عدد کے وسط کو لوٹاتا ہے۔مینیپ اور میکسیپ کلاسز ہیلپر کلاسز ہیں جو من ہیپ اور میکس ہیپ ڈیٹا ڈھانچے کو نافذ کرتی ہیں۔ مثال کے طور پر ، مندرجہ ذیل جاوا اسکرپٹ کوڈ یہ ظاہر کرتا ہے کہ میڈین فائنڈر کلاس کو کس طرح انٹیجرز کے دھارے کا میڈین تلاش کرنے کے لئے استعمال کیا جائے: جاوا اسکرپٹ میڈین فائنڈر = نیا میڈین فائنڈر () نیا میڈین فائنڈر ()؛ میڈین فائنڈر.اڈڈنم (1) ؛ میڈین فائنڈر.اڈڈنم (2) med میڈین 1 = میڈین فائنڈر.فند میڈیم () ؛ کنسول.لوگ (`[1 ، 2] کا میڈین $ {median1}`) ؛ میڈین فائنڈر.اڈنم (3)) ded میڈین 2 = میڈین فائنڈر.فند میڈیم () ؛ کنسول.لوگ (`میڈین"
    },
    {
        "Question": "انٹیجرز کے دیئے گئے تسلسل میں گمشدہ نمبر تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "انٹیجرز کے ایک دیئے گئے سلسلے میں گمشدہ نمبر کو تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام یہ ہے: جاوا اسکرپٹ فینکشن فائنڈ میسنگ نمبر (اے آر آر) {// تسلسل کانسٹنٹ کے جوڑے کا حساب کریں۔// ترتیب کے مجموعہ کا حساب لگائیں اگر کوئی نمبر نہیں غائب تھا const n = arr.length + 1 ؛Const Constedsum = (n * (n + 1)) / 2 ؛// دونوں رقم کے درمیان فرق گمشدہ تعداد کی واپسی کی توقع ہے - SUM -} یہ پروگرام ان پٹ کے طور پر عددیوں کی ایک صف لیتا ہے اور ترتیب کے مجموعہ کا حساب لگاتا ہے۔اس کے بعد یہ ترتیب کے مجموعہ کا حساب لگاتا ہے اگر پہلے N قدرتی نمبروں کے مجموعہ کے لئے فارمولا کا استعمال کرتے ہوئے کوئی نمبر غائب نہیں تھا۔دونوں رقم کے درمیان فرق گمشدہ نمبر ہے ، جو فنکشن 12 کے ذریعہ واپس کیا جاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کو ترتیب میں گمشدہ نمبر مل جاتا ہے [1] [2] [3] [5] [6] [7]:جاوا اسکرپٹکونسٹ آر آر = [1 ، 2 ، 3 ، 5 ، 6 ، 7] ؛ کانسٹ لاپتہ نمبر = تلاش کرنے والی تعداد (آر آر) ؛ کنسول.لوگ (`گمشدہ نمبر $ {گمشدہ نمبر}` ہے) ؛ اس سے گمشدہ تعداد 4 ہے۔نوٹ کریں کہ یہ پروگرام فرض کرتا ہے کہ ترتیب عدد کا ایک مسلسل تسلسل ہے جس میں ایک نمبر غائب ہے۔اگر ترتیب مسلسل نہیں ہے یا اس میں ایک سے زیادہ تعداد موجود ہے تو ، یہ پروگرام کام نہیں کرے گا۔"
    },
    {
        "Question": "کسی بھی نمبر کو کسی سرے سے ہٹانے اور ایک نئی صف واپس کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یہاں تک کہ تمام نمبروں کو ایک صف سے ہٹانے اور ایک نئی صف کو واپس کرنے کے ل we ، ہم جاوا اسکرپٹ میں فلٹر () کا طریقہ استعمال کرسکتے ہیں۔فلٹر () کا طریقہ ان تمام عناصر کے ساتھ ایک نئی صف تیار کرتا ہے جو فراہم کردہ فنکشن کے ذریعہ نافذ ٹیسٹ پاس کرتے ہیں۔اس معاملے میں ، فنکشن چیک کرے گا کہ آیا عنصر عجیب ہے یا یہاں تک کہ اور صرف عجیب عناصر کے ساتھ ایک نئی صف لوٹائے گا۔یہاں ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن کو ہٹانے کے لئے ایوان نمبرز (اے آر آر) {ریٹرن ارا. فلٹر (نمبر => نمبر ٪ 2! == 0) ؛} اس فنکشن کو ان پٹ کے طور پر نمبروں کی ایک صف لی جاتی ہے اور صرف عجیب تعداد کے ساتھ ایک نئی صف لوٹتی ہے۔فلٹر () کا طریقہ چیک کرتا ہے کہ آیا سرنی میں ہر عنصر ماڈیولس آپریٹر ٪ کا استعمال کرکے یہ چیک کرنے کے لئے عجیب ہے کہ اگر 2 کے ذریعہ تقسیم ہونے پر باقی باقی 0 نہیں ہے تو اگر باقی 0 نہیں ہے تو ، عنصر عجیب ہے اور اسے نئے میں شامل کیا گیا ہے۔سرنیاگر بقیہ 0 ہے تو ، عنصر یکساں ہے اور اسے نئے سرنی 123 میں شامل نہیں کیا گیا ہے۔= [2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8] const کنٹ اوڈنمبرس = ہٹانے والے ایونمبر (آر آر) ؛ کنسول.لوگ (اوڈنمبرس) ؛ اس سے پیداوار ہوگی [3] [5] [7]کہ ان پٹ سرنی میں صرف نمبر ہوتے ہیں۔اگر ان پٹ سرنی میں غیر عددی اقدار پر مشتمل ہے تو ، یہ فنکشن کام نہیں کرے گا۔"
    },
    {
        "Question": "کسی دیئے گئے تار کو چھوٹا کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں اور ایک ایلپسس (...) شامل کریں اگر یہ ایک مخصوص لمبائی سے زیادہ ہے۔",
        "Answer": "کسی دیئے گئے تار کو چھوٹا کرنے اور بیضویت کو شامل کرنے کے ل if اگر یہ ایک مخصوص لمبائی سے زیادہ ہے تو ، ہم جاوا اسکرپٹ میں سلائس () کا طریقہ استعمال کرسکتے ہیں۔سلائس () کا طریقہ ایک تار کے ایک حصے کو نکالتا ہے اور ایک نیا تار واپس کرتا ہے۔ہم اس طریقہ کو مخصوص لمبائی تک اصل تار کے ایک ذخیرے کو نکالنے کے ل use استعمال کرسکتے ہیں اور اگر اصل تار مخصوص لمبائی سے لمبا ہو تو اسٹرنگ کے اختتام پر بیضوی شکل کو شامل کرسکتے ہیں۔یہاں ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن ٹرنکیٹسٹرینگ (ایس ٹی آر ، میکس لینتھ) {if (str.length> میکس لمبائی) {واپس str.slice (0 ، میکسلنتھ) + '...' ؛} else {واپسی str ؛}} یہ فنکشن ان پٹ کے طور پر ایک تار اور زیادہ سے زیادہ لمبائی لیتا ہے اور اگر اصلی تار زیادہ سے زیادہ لمبائی سے زیادہ ہو تو بیضوی کے ساتھ ایک چھوٹی سی تار لوٹاتا ہے۔سلائس () کا طریقہ کار میکس لینتھ پیرامیٹر کا استعمال کرتے ہوئے زیادہ سے زیادہ لمبائی تک اصل سٹرنگ کی ایک ذخیرہ نکالتا ہے۔اگر اصل تار زیادہ سے زیادہ لمبائی سے لمبا ہے تو ، بیضویوں کو سٹرنگ کے اختتام تک شامل کیا جاتا ہے۔اگر اصل تار زیادہ سے زیادہ لمبائی سے کم یا اس کے برابر ہے تو ، اصل تار 1234 کو واپس کردیا گیا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ \"یہ ایک لمبی تار ہے جس کو 20 حروف کی زیادہ سے زیادہ لمبائی تک چھوٹنے کی ضرورت ہے\"str = 'یہ ایک لمبی تار ہے جس کو چھوٹا کرنے کی ضرورت ہے' ؛ const maxlength = 20 ؛ Const truncatedstring = truncatestring (str ، maxlength) ؛ کنسول.لوگ (truncatedString) ؛ یہ آؤٹ پٹ \"یہ ایک لمبی str ہے ...\". نوٹ کریں کہ یہ فنکشن فرض کرتا ہے کہ ان پٹ سٹرنگ ایک درست تار ہے۔اگر ان پٹ سٹرنگ تار نہیں ہے یا خالی ہے تو ، یہ فنکشن کام نہیں کرے گا۔"
    },
    {
        "Question": "فبونیکی تسلسل کا حساب کتاب کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "فیبونیکی تسلسل کا حساب کتاب کرنے کے لئے یہاں ایک جاوا اسکرپٹ فنکشن ہے جو ایک مخصوص شرائط تک ہے: جاوا اسکرپٹ فنکشن فبونکسیسیسیس (نمبرٹرمز) {کانٹیشن ترتیب = [0 ، 1] ؛کے لئے (آئیے i = 2 ؛ i <numterms ؛ i ++) {const nextterm = تسلسل [i - 1]+تسلسل [i - 2] ؛تسلسل.پش (اگلا ٹرم) ؛} ریٹرن تسلسل ؛} یہ فنکشن ان پٹ کے طور پر متعدد شرائط لیتا ہے اور اس شرائط کی تعداد تک فبونیکی تسلسل پر مشتمل ایک صف لوٹاتا ہے۔فنکشن پہلی دو شرائط ، 0 اور 1 کے ساتھ ترتیب کی ابتدا کرتا ہے ، اور پھر لوپ کے لئے A کا استعمال اگلی شرائط کو ترتیب میں حساب کتاب کرنے کے لئے پچھلے دو شرائط کو شامل کرکے کرتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ شرائط کی مطلوبہ تعداد تک نہ پہنچ جائے ، اور اس کے نتیجے میں ترتیب 123456 واپس کردی جاتی ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ 10 شرائط تک فیبونیکی تسلسل کا حساب لگاتا ہے: جاوا اسکرپٹکونسٹ نمبرٹرم = 10 ؛ کانسٹنٹ تسلسل = فبوناسیسیسیوینس (نمبر) ؛ کنسول.لاگ ؛(ترتیب) ؛ اس سے پیداوار ہوگی [0] [1] [1] [2] [3] [5] [8] [13] [21] [34]. نوٹ کریں کہ یہ فنکشن فرض کرتا ہے کہ ان پٹ ایک درست تعداد ہے2 سے زیادہ یا اس کے برابر 2 اگر ان پٹ کوئی نمبر نہیں ہے یا 2 سے کم ہے تو ، یہ فنکشن کام نہیں کرے گا۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے اسٹرنگ ایک درست ای میل ایڈریس ہے۔",
        "Answer": "یہ چیک کرنے کے بہت سارے طریقے ہیں کہ آیا دی دی گئی تار جاوا اسکرپٹ میں ایک درست ای میل ایڈریس ہے۔ایک طریقہ یہ ہے کہ ای میل ایڈریس پیٹرن سے ملنے کے لئے باقاعدہ اظہارات کا استعمال کریں۔یہاں ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن isvalidemail (ای میل) {const regex = /^ xelays@ed+onless@eless@elatess@elandss@elastss@elatess@elatess@elatess@elatess@elstandsstax@elsters@@rendss@elsters@@.REGEX.TEST (ای میل)}} یہ فنکشن ان پٹ کے طور پر ایک ای میل ایڈریس لیتا ہے اور اگر ای میل ایڈریس درست اور غلط ہے تو وہ سچ ہے۔باقاعدگی سے اظہار /@@@latess@eldess@ed+ss@eless@ed +ss@ed++$ / ای میل ایڈریس پیٹرن سے میل کھاتا ہے ، جس میں@علامت سے پہلے ایک یا زیادہ حرفوں پر مشتمل ہوتا ہے ، اس کے بعد@@ علامت اور کے درمیان ایک یا زیادہ حروف کے ذریعہ۔علامت ، اس کے بعد ایک یا زیادہ حروف کے بعد۔علامتٹیسٹ () کا طریقہ یہ چیک کرتا ہے کہ اگر ان پٹ ای میل ایڈریس باقاعدہ اظہار سے مماثل ہے اور بولین ویلیو 1234 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کی جانچ پڑتال کرتی ہے اگر \"مثال@example.com\" ایک درست ای میل ایڈریس ہے: جاواسکرپٹکونسٹ ای میل = 'مثال@مثال کے طور پر ڈاٹ کام '؛ const isvalid = isvalidemail (ای میل) ؛ کنسول.لوگ (isvalid) ؛ یہ سچ ثابت ہوگا۔ نوٹ کریں کہ یہ فنکشن فرض کرتا ہے کہ ان پٹ ایک درست تار ہے۔اگر ان پٹ تار نہیں ہے یا خالی ہے تو ، یہ فنکشن کام نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ ای میل ایڈریس پیٹرن سے ملنے کے لئے باقاعدہ اظہار کا استعمال کیا جاسکتا ہے ، وہ ای میل پتے کی توثیق کرنے کا فول پروف طریقہ نہیں ہیں۔سرور سائیڈ پر ای میل ایڈریس کو بھی چیک کرنے کی سفارش کی جاتی ہے تاکہ یہ یقینی بنایا جاسکے کہ یہ درست ہے اور بدنیتی 1234.1 ماسٹرنگ جے ایس 2 اسٹیک اوور فلو 3 اے بی ایس ٹی اے پی آئی 4 اسٹیکابیس"
    },
    {
        "Question": "\"ایک جاوا اسکرپٹ کلاس بنائیں جو قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہو۔",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے ل that جو قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے اور عناصر کو تلاش کرنے کے طریقوں کو نافذ کرتا ہے اور اس کے طریقوں کو نافذ کرتا ہے ، ہم مندرجہ ذیل نفاذ کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس قطار {کنسٹرکٹر () {this.items = [] ؛} enqueue (آئٹم) {this.items.push (آئٹم) ؛} dequeue () {if (this.isempty ()) {واپس کالعدم ؛} دوسری {اس کو واپس کریں۔ آئٹمز.شفٹ () ؛}} جھانکنے () {اگر (this.isempty ()) {واپس کالعدم ؛} دوسری {اس کو واپس کریں۔ آئٹمز [0] ؛}} isempty () {اس کو واپس کریں۔}} یہ کلاس قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے اور اس کے پاس قطار خالی ہے یا نہیں اس کی جانچ پڑتال کرنے کے طریقے رکھتے ہیں۔کنسٹرکٹر () کا طریقہ قطار عناصر کو ذخیرہ کرنے کے لئے خالی صف کی ابتدا کرتا ہے۔انکیو (آئٹم) کا طریقہ سرنی کے پش () طریقہ کار کا استعمال کرکے قطار کے آخر میں ایک عنصر کو شامل کرتا ہے۔ڈیکیو () کا طریقہ صف کے سامنے سے کسی عنصر کو قطار کے سامنے سے ہٹا دیتا ہے۔جھانکنے والا () طریقہ قطار میں ترمیم کیے بغیر قطار کے سامنے عنصر کو لوٹاتا ہے۔isempty () کا طریقہ چیک کرتا ہے کہ اگر قطار Array123456 کی لمبائی کی جانچ کر کے قطار خالی ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک نئی قطار بناتا ہے ، اس میں عناصر کو شامل کرتا ہے ، اس سے عنصر کو ہٹا دیتا ہے ، اور سامنے والے عنصر پر جھانکیں: جاوا اسکرپٹ کونسٹ قطار= نئی قطار () ؛ قطار۔ enqueue (1) ؛ قطار۔ enqueue (2) ؛ قطار۔ enqueue (3) ؛ کنسول.لوگ (قطار.ڈیکیو ()) ؛ کنسول.لوگ (قطار.پیک ()) ؛ یہآؤٹ پٹ 1 اور 2. نوٹ کریں گے کہ یہ نفاذ یہ فرض کرتا ہے کہ ان پٹ درست ہے اور یہ کہ صف کو ایک صف کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا قطار کو مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نافذ کیا گیا ہے تو ، اس عمل سے کام نہیں ہوگا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ عمل درآمد ایک بنیادی قطار کے اعداد و شمار کا ڈھانچہ مہیا کرتا ہے تو ، قطار میں زیادہ اعلی درجے کے نفاذ موجود ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "دو صفوں کا چوراہا تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں دو صفوں کے چوراہے کو تلاش کرنے کے بہت سے طریقے ہیں۔ایک طریقہ یہ ہے کہ فلٹر () کے طریقہ کار کو ایک صف سے زیادہ تکرار کرنے کے لئے استعمال کیا جائے اور یہ چیک کریں کہ آیا ہر عنصر انڈیکس () یا شامل () طریقہ استعمال کرکے دوسرے سرنی میں موجود ہے یا نہیں۔یہاں ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن چوراہا (ARR1 ، ARR2) {CONST ROSSERT = ARR1.Filter (X => arr2.indexof (x)! == -1) ؛واپسی کا نتیجہ ؛} یہ فنکشن ان پٹ کے طور پر دو صفوں میں لیتا ہے اور ایک صف کو واپس کرتا ہے جس میں عناصر موجود ہیں جو دونوں صفوں میں موجود ہیں۔فلٹر () کا طریقہ پہلی سرنی اور جانچ پڑتال کرتا ہے اگر ہر عنصر انڈیکسف () یا شامل () طریقہ کا استعمال کرتے ہوئے دوسری صف میں موجود ہے۔اگر عنصر دوسری صف میں موجود ہے تو ، اس کے نتیجے میں صف میں شامل ہے۔نتیجے میں ہونے والی صف میں دو صفوں کے درمیان مشترکہ عناصر شامل ہیں۔[1 ، 2 ، 3 ، 4] Const Constr arr2 = [3 ، 4 ، 5] const کانسٹر نتیجہ = چوراہا (arr1 ، arr2) ؛ کنسول.لاگ (نتیجہ) ؛ اس کی پیداوار ہوگی [3] [4]۔ نوٹ کریں کہ نوٹ کریں۔یہ عمل درآمد فرض کرتا ہے کہ ان پٹ درست ہے اور یہ کہ صفوں کو ایک صف کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے صفوں کو نافذ کیا جاتا ہے تو ، یہ عمل درآمد نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ عمل درآمد دو صفوں کا بنیادی چوراہا فراہم کرتا ہے تو ، اس سے زیادہ جدید چوراہے کے نفاذ موجود ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "\"ان کی لمبائی کی بنیاد پر تار کی صف کو ترتیب دینے کے لئے کسی فنکشن کو نافذ کریں ، مختصر سے طویل تر تک۔\"",
        "Answer": "ان کی لمبائی کی بنیاد پر تاروں کی ایک صف کو ترتیب دینے کے ل ، ، مختصر ترین سے طویل تر تک ، ہم جاوا اسکرپٹ میں ترتیب () کا طریقہ استعمال کرسکتے ہیں۔ترتیب () طریقہ کار جگہ پر ایک صف کے عناصر کو ترتیب دیتا ہے اور ترتیب شدہ صف کو لوٹاتا ہے۔ہم چھانٹنے کے آرڈر کی وضاحت کرنے کے لئے موازنہ کی تقریب کو ترتیب () کے طریقہ کار سے منتقل کرسکتے ہیں۔یہاں ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن ترتیب بائی لیوینتھ (اے آر آر) {آرا.سورٹ ((a ، b) => a.length - b.length) ؛ریٹرن آر آر ؛} یہ فنکشن ان پٹ کے طور پر تاروں کی ایک صف لیتا ہے اور لمبائی کے لحاظ سے ترتیب دیئے گئے تار کے ساتھ ایک نئی صف لوٹاتا ہے ، جس میں مختصر ترین سے طویل تر تک ہوتا ہے۔ترتیب () کا طریقہ موازنہ فنکشن (A ، B) => a.length - B.Lengthing کا استعمال کرتے ہوئے ہر تار کی لمبائی کا موازنہ کرکے صف کو ترتیب دیتا ہے۔یہ فنکشن منفی قدر کو لوٹاتا ہے اگر A B سے چھوٹا ہو ، ایک مثبت قیمت اگر A B سے لمبی ہے ، اور 0 اگر A اور B برابر لمبائی کا ہو۔نتیجے میں ہونے والی صف میں لمبائی 123456 کے ذریعہ ترتیب دیئے گئے تار پر مشتمل ہے۔، 'ورلڈ' ، 'کیسے' ، 'ہیں' ، 'آپ'] ؛ ترتیب وارڈر = ترتیب بائی لیوینتھ (اے آر آر) ؛ کنسول.لوگ (ترتیبار) ؛ اس سے پیداوار ہوگی [\"کیسے\" ، \"آپ\" ، \"آپ\" ، \"ہیں\"ہیلو \"،\" دنیا \"]اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ عمل درآمد کام نہیں کرے گا۔اضافی طور پر ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ عمل درآمد لمبائی کے لحاظ سے تاروں کی ایک صف کی بنیادی چھانٹ رہا ہے ، لیکن اس سے زیادہ جدید چھانٹنے کے نفاذ موجود ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "اس کے رداس کے ذریعہ کسی دائرے کے علاقے اور فریم کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں اس کے رداس کو دیئے جانے والے دائرے کے علاقے اور طواف کا حساب لگانے کے لئے ، ہم مندرجہ ذیل فارمولوں کا استعمال کرسکتے ہیں: دائرے کا رقبہ = π * r^2 دائرہ کا دائرہاس کے رداس کو دیکھتے ہوئے دائرے کا رقبہ اور طواف: جاوا اسکرپٹ فانکشن کیلکولیٹ سرکل (رداس) {const pi = math.pi ؛کانسٹ ایریا = پی آئی * رداس * رداس ؛const فریم = 2 * pi * رداس ؛واپسی {ایریا ، فریم} ؛} یہ فنکشن دائرے کے دائرے کو ان پٹ کے طور پر لے جاتا ہے اور دائرے کے علاقے اور فریم پر مشتمل کسی شے کو لوٹاتا ہے۔فنکشن سب سے پہلے ایک مستقل PI کا اعلان کرتا ہے جو π کی قدر کی نمائندگی کرتا ہے۔اس کے بعد یہ فارمولا π * r^2 اور فارمولا 2 * π * r کا استعمال کرتے ہوئے دائرے کے طواف کا استعمال کرتے ہوئے دائرے کے علاقے کا حساب لگاتا ہے۔فنکشن سرکل 1234 کے علاقے اور طواف پر مشتمل کسی شے کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ 5 کے رداس کے ساتھ دائرے کے علاقے اور طواف کا حساب لگاتا ہے: جاوا اسکرپٹکونسٹ رداس = 5 ؛ کانسٹ {ایریا ، فریم} = کیلکولیٹ سرکل (رداس)؛ کنسول.لوگ (`دائرے کا رقبہ $ {رقبہ}` `) ہے ؛ کنسول.لوگ (` دائرے کا طواف $ {طواف} `` ہے) ؛ یہ آؤٹ پٹ ہوگا: دائرے کا رقبہ 78.5398163397483 ہے فریم۔دائرے میں سے 31.41592653589793 نوٹ ہے کہ یہ نفاذ یہ فرض کرتا ہے کہ ان پٹ درست ہے اور یہ کہ رداس ایک نمبر ہے۔اگر ان پٹ درست نہیں ہے یا رداس ایک نمبر نہیں ہے تو ، یہ عمل درآمد کام نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ کسی دائرے کے علاقے اور فریم کا بنیادی حساب فراہم کرتا ہے تو ، حلقہ کے زیادہ اعلی حساب کتابیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "کسی دیئے گئے تار کو عنوان کیس میں تبدیل کرنے کے لئے ایک فنکشن لکھیں (ہر لفظ کا پہلا خط سرمایہ کاری)۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے تار کو ٹائٹل کیس (ہر لفظ کا پہلا خط) میں تبدیل کرنے کے لئے ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔ایک طریقہ یہ ہے کہ تار کو الفاظ کی ایک صف میں تقسیم کیا جائے ، ہر لفظ کے پہلے خط کو فائدہ پہنچائے ، اور پھر الفاظ کو دوبارہ تار میں شامل کریں۔یہاں ایک مثال عمل ہے: جاوا اسکرپٹ فنکشن ٹوٹیٹلیکیس (ایس ٹی آر) {کونسٹ ورڈز = str.tolowercase (). اسپلٹ ('') ؛کے لئے (آئیے i = 0 ؛ i <words.length ؛ i ++) {الفاظ [i] = الفاظ [i] .charat (0) .touppercase ()+الفاظ [i] .Slice (1) ؛} الفاظ واپس کریں۔فنکشن سب سے پہلے ان پٹ سٹرنگ کو لوئر کیس میں تبدیل کرتا ہے اور اسے اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتا ہے۔اس کے بعد یہ لوپ کے لئے A کا استعمال سرنی میں ہر لفظ پر تکرار کرنے کے لئے کرتا ہے اور ہر لفظ کے پہلے خط کو چارٹ () اور ٹپرکیس () طریقوں کا استعمال کرتے ہوئے فائدہ پہنچاتا ہے۔پہلے خط کے بعد باقی لفظ نکالنے کے لئے سلائس () کا طریقہ استعمال کیا جاتا ہے۔آخر میں ، فنکشن الفاظ کو شامل کرتے ہیں () طریقہ 123456 کا استعمال کرتے ہوئے سٹرنگ میں واپس آتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ \"کوئیک براؤن فاکس کو سست کتے کے اوپر چھلانگ لگاتا ہے\" کو ٹائٹل کیس میں تبدیل کرتا ہے: جاوا اسکرپٹکونسٹ str = 'کوئیک براؤن فاکسسست کتے پر چھلانگیں '' const const titlecasestr = totitlecase (str) ؛ کنسول.لاگ (ٹائٹلیکاسیسٹر) ؛ یہ \"تیز براؤن فاکس کو سست کتے پر چھلانگ لگائے گا\"۔ نوٹ کریں کہ یہ عمل درآمد درست ہے اور یہ کہ ان پٹ درست ہے اور یہ کہسٹرنگ کا استعمال کرتے ہوئے سٹرنگ کا اطلاق ہوتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ عمل درآمد کام نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ عمل درآمد کسی تار کی بنیادی تبدیلی کو ٹائٹل کیس میں فراہم کرتا ہے ، تو ٹائٹل کیس پر عمل درآمد زیادہ ہوتا ہے جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتا ہے۔"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کو ایک نئی ترتیب شدہ صف میں ضم کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں دو ترتیب شدہ صفوں کو ایک نئی ترتیب شدہ صف میں ضم کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔ایک طریقہ یہ ہے کہ تھوڑی دیر کا استعمال کریں تاکہ دونوں صفوں پر تکرار کریں اور ہر انڈیکس میں عناصر کا موازنہ کریں۔اس کے بعد ہم چھوٹے عنصر کو ایک نئی صف میں شامل کرسکتے ہیں اور صف کے انڈیکس میں اضافہ کرسکتے ہیں جس میں چھوٹا عنصر موجود تھا۔یہاں ایک مثال کے نفاذ ہے: جاوا اسکرپٹ فانکشن انضمام ڈریڈریز (ARR1 ، ARR2) {CONST Murgedarray = [] ؛آئیے i = 0 ؛آئیے j = 0 ؛جبکہ (i <arr1.length && j <arr2.length) {if (arr1 [i] <arr2 [j]) {wergedarray.push (arr1 [i]) ؛i ++ ؛} else {wargedarray.push (arr2 [j]) ؛J ++ ؛}} جبکہ (i <arr1.length) {wargedarray.push (arr1 [i]) ؛i ++ ؛} جبکہ (j <arr2.length) {wergedarray.push (arr2 [j]) ؛J ++ ؛} انضمام کی واپسی ؛} یہ فنکشن ان پٹ کے طور پر دو ترتیب شدہ صفوں کو لیتا ہے اور دونوں صفوں سے تمام عناصر پر مشتمل ایک نئی ترتیب شدہ صف لوٹاتا ہے۔فنکشن ہر ایک میں موجودہ انڈیکس کا ٹریک رکھنے کے لئے انضمام شدہ عناصر اور دو انڈیکس متغیر I اور J کو ذخیرہ کرنے کے لئے ایک خالی سرنی انضمام کی ابتدا کرتا ہے۔اس کے بعد فنکشن تھوڑی دیر کا استعمال کرتے ہیں تاکہ دونوں صفوں پر تکرار کریں اور ہر انڈیکس میں عناصر کا موازنہ کریں۔اگر ARR1 میں عنصر ARR2 میں عنصر سے چھوٹا ہے تو ، اس کو انضمام میں شامل کیا جاتا ہے اور میں اس میں اضافہ ہوتا ہے۔اگر ARR2 میں عنصر ARR1 میں عنصر سے چھوٹا ہے تو ، اس کو انضمام میں شامل کیا جاتا ہے اور جے میں اضافہ ہوتا ہے۔اگر دونوں عناصر برابر ہیں تو ، کسی کو بھی انضمام میں شامل کیا جاسکتا ہے اور میں اور جے دونوں میں اضافہ ہوتا ہے۔ایک بار جب ایک صفوں کو مکمل طور پر ختم کردیا گیا تو ، دوسری صف سے باقی عناصر کو انضمام میں شامل کیا جاتا ہے۔آخر میں ، فنکشن انضمام erray123 کو واپس کرتا ہے۔، 6 ، 8] Const Const arr2 = [4 ، 6 ، 8 ، 9 ، 11] ؛ Const wergedarray = مرجسورٹریڈری (arr1 ، arr2) ؛ کنسول.لوگ (مرجیرے) ؛ اس کی پیداوار ہوگی [1] [4] [2][2] [3] [5] [5] .مجھے اس پر عمل درآمد یہ فرض کرتا ہے کہ ان پٹ درست ہے اور یہ کہ ارایوں کو چڑھائی ترتیب میں ترتیب دیا گیا ہے۔اگر ان پٹ درست نہیں ہے یا صفوں کو ترتیب نہیں دیا گیا ہے تو ، یہ عمل درآمد کام نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ عمل درآمد دو ترتیب شدہ صفوں کا بنیادی ضم فراہم کرتا ہے تو ، انضمام کے زیادہ سے زیادہ عمل درآمد ہوتے ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو ایک منسلک فہرست کے ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے ل that جو نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے ل a ایک منسلک فہرست کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے اور نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کرتا ہے ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس لنکڈ لسٹ {کنسٹرکٹر () {this.head = null ؛this.size = 0 ؛} داخل کریں (قیمت) {کونسٹ نوڈ = نیا نوڈ (قدر) ؛اگر (! this.head) {this.head = نوڈ ؛} دوسری {موجودہ = this.head ؛جبکہ (موجودہ۔ نیکسٹ) {موجودہ = موجودہ۔ نیکسٹ ؛} موجودہ۔ نیکسٹ = نوڈ ؛} this.size ++ ؛} حذف کریں (قدر) {اگر (! this.head) {واپسی NULL ؛} if (this.head.value === ویلیو) {this.head = this.head.next ؛this.size-- ؛واپسی کی قیمت ؛} موجودہ = this.head ؛جبکہ (موجودہ. نیکسٹ) {if (موجودہ.Next.value === ویلیو) {موجودہ.Next = موجودہ.Next.next ؛this.size-- ؛واپسی کی قیمت ؛} موجودہ = موجودہ۔ نیکسٹ ؛} واپس کالعدم ؛} تلاش (قدر) {موجودہ = this.head ؛جبکہ (موجودہ) {اگر (موجودہ.Value === ویلیو) {سچ واپس ؛} موجودہ = موجودہ۔ نیکسٹ ؛} جھوٹی لوٹ ؛}} کلاس نوڈ {کنسٹرکٹر (قدر) {this.value = value ؛this.next = null ؛}} یہ کلاس ایک منسلک فہرست کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے اور اس میں نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقے ہیں۔کنسٹرکٹر () کا طریقہ لنکڈ فہرست کے سر کو NULL اور سائز 0 پر شروع کرتا ہے۔ داخل کریں (ویلیو) کا طریقہ منسلک فہرست کے اختتام پر دی گئی قیمت کے ساتھ ایک نیا نوڈ داخل کرتا ہے۔حذف (ویلیو) کا طریقہ لنکڈ فہرست سے دی گئی قیمت کے ساتھ پہلا نوڈ کو حذف کرتا ہے۔تلاش (ویلیو) کا طریقہ دی گئی قیمت کے ساتھ نوڈ کے لئے منسلک فہرست کو تلاش کرتا ہے اور اگر یہ پایا جاتا ہے اور غلط ہے تو سچائی واپس آجاتا ہے۔نوڈ کلاس لنکڈ فہرست میں ایک نوڈ کی نمائندگی کرتا ہے اور اس میں ایک ویلیو پراپرٹی اور اگلی پراپرٹی ہوتی ہے جو لسٹ 1234 میں اگلے نوڈ کی طرف اشارہ کرتی ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک نئی منسلک فہرست تیار کرتا ہے ، جس میں اقدار 1 ، 2 ، اور نوڈس کو داخل کرتا ہے۔3 ، نوڈ کو ویلیو 2 کے ساتھ حذف کرتا ہے ، اور اقدار 1 اور 4 کے ساتھ نوڈس کی تلاش کرتا ہے: جاوا اسکرپٹکونسٹ لنکڈ لسٹ = نیا لنکڈ لسٹ () ؛ لنکڈ لسٹ.نسرٹ (1) ؛ لنکڈ لسٹ۔ INSERT (2) ؛ لنکڈ لسٹ۔ INSERT (3) ؛ لنک لسٹ۔حذف کریں (2) ؛ کنسول.لوگ (لنکڈ لسٹ.سارچ (1)) ؛ کنسول.لوگ (لنکڈ لسٹ.سارچ (4)) ؛ یہ صحیح اور غلط آؤٹ پٹ کرے گا۔ نوٹ کریں کہ یہ عمل درآمد درست ہے اور اس سے منسلک ہےفہرست کلاسوں کا استعمال کرتے ہوئے نافذ کی جاتی ہے۔اگر ان پٹ درست نہیں ہے یا لنکڈ لسٹ کو مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نافذ کیا گیا ہے تو ، یہ عمل درآمد کام نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ عمل درآمد داخل ، حذف ، اور تلاش کے طریقوں کے ساتھ ایک بنیادی منسلک فہرست کے اعداد و شمار کا ڈھانچہ مہیا کرتا ہے تو ، اس میں مزید اعلی درجے کی فہرست کے نفاذ موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "کسی صف میں اکثر اوقات عنصر تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں ایک صف میں اکثر اوقات عنصر تلاش کرنے کے بہت سے طریقے ہیں۔یہاں کچھ ممکنہ نفاذات ہیں: ہر عنصر کی تعدد کو گننے کے لئے کم () اور کسی شے کا استعمال کرتے ہوئے: جاوا اسکرپٹ فینکشن سب سے زیادہ حد (ARR) {const contes = arr.reduce ((acc ، curr) => {اگر (ACC میں کرر) {acc [curr] ++ ؛} else {acc [curr] = 1 ؛} واپسی acc ؛} ، {}) ؛آئیے زیادہ سے زیادہ = 0 ؛چلیں سب سے زیادہ ؛(آبجیکٹ کے لئے [key ، value] کے لئے.سب سے زیادہ = کلید ؛}} سب سے زیادہ واپسی ؛} یہ فنکشن ان پٹ کے طور پر ایک صف لیتا ہے اور صف میں سب سے زیادہ کثرت سے عنصر کو لوٹاتا ہے۔فنکشن گنتی کو ذخیرہ کرنے کے لئے کسی شے کا استعمال کرکے صف میں ہر عنصر کی تعدد کو گننے کے لئے کم () طریقہ استعمال کرتا ہے۔نتیجے میں آنے والی شے میں صف میں ہر عنصر کی گنتی ہوتی ہے۔اس کے بعد فنکشن اس چیز پر اعادہ کرتا ہے تاکہ عنصر کو اعلی ترین گنتی کے ساتھ تلاش کیا جاسکے اور آئی ٹی 1 کو لوٹائے۔] [5] [2] [6] [2]: جاوا اسکرپٹ کنسٹ آر آر = [1 ، 2 ، 3 ، 2 ، 4 ، 2 ، 5 ، 2 ، 6 ، 2] const کانسٹ فری ایبلمنٹ = انتہائی حد سے زیادہ (آر اے آر) ؛ کنسول.لوگ(سب سے زیادہ frequentelement) ؛ اس سے ہر عنصر کی تعدد کو گننے کے ل lo لوپ اور کسی شے کے لئے 2. کا استعمال کرتے ہوئے: جاوا اسکرپٹ فینکشن سب سے زیادہ frecrequent (arr) {const contuse = {} ؛آئیے زیادہ سے زیادہ = 0 ؛چلیں سب سے زیادہ ؛کے لئے (آر اے آر کے عنصر) {اگر (گنتی میں عنصر) {گنتی [عنصر] ++ ؛} دوسری {گنتی [عنصر] = 1 ؛} if (گنتی [عنصر]> زیادہ سے زیادہ حساب) {میکسکاؤنٹ = گنتی [عنصر] ؛سب سے زیادہ = عنصر ؛}} سب سے زیادہ واپسی ؛} یہ فنکشن ان پٹ کے طور پر ایک صف لیتا ہے اور صف میں سب سے زیادہ کثرت سے عنصر کو لوٹاتا ہے۔فنکشن لوپ کے لئے A کا استعمال کرتا ہے تاکہ وہ گنتی کو ذخیرہ کرنے کے لئے کسی شے کا استعمال کرکے صف میں ہر عنصر کی تعدد کو گن سکے۔نتیجے میں آنے والی شے میں صف میں ہر عنصر کی گنتی ہوتی ہے۔اس کے بعد فنکشن اس چیز پر تکرار کرتا ہے تاکہ عنصر کو اعلی ترین گنتی کے ساتھ تلاش کیا جاسکے اور آئی ٹی 2 کو لوٹائے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ سرے میں سب سے زیادہ کثرت سے عنصر تلاش کرتا ہے [1] [2] [3] [2] [2] [4] [2]] [5] [2] [6] [2]: جاوا اسکرپٹ کنسٹ آر آر = [1 ، 2 ، 3 ، 2 ، 4 ، 2 ، 5 ، 2 ، 6 ، 2] const کانسٹ فری ایبلمنٹ = انتہائی حد سے زیادہ (آر اے آر) ؛ کنسول.لوگ(سب سے زیادہ تقویت کا اظہار) ؛ اس کی پیداوار ہوگی۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ صف کا استعمال کرتے ہوئے سرنی کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ کسی صف میں اکثر اوقات عنصر تلاش کرنے کے لئے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ جدید نفاذات موجود ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیا ہوا نمبر ایک بہترین مربع ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد جاوا اسکرپٹ میں ایک بہترین مربع ہے ، اس کے حصول کے لئے بہت سارے طریقے ہیں۔یہاں کچھ ممکنہ نفاذ ہیں: ریاضی.سق آر ٹی () کا استعمال کرتے ہوئے اور یہ چیک کرنا کہ نتیجہ کوئی عدد ہے: جاوا اسکرپٹ فکشن آئسپر فیکٹ سکیئر (نمبر) {کونسٹ ایس کیو آر ٹی = میتھ.س کیو آر ٹی (نمبر) ؛واپسی SQRT === ریاضی۔ فلور (SQRT) ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اگر نمبر ایک کامل مربع اور غلط ہے تو وہ سچ ہے۔اس فنکشن میں ریاضی کے مربع جڑ کا حساب لگانے کے لئے ریاضی۔ ایس کیو آر ٹی () کا طریقہ استعمال کیا گیا ہے اور چیک کرتا ہے کہ اگر نتیجہ اس کا موازنہ ریاضی کے نتائج سے موازنہ کرکے ایک عدد ہے۔اگر دونوں اقدار برابر ہیں تو ، نمبر ایک کامل مربع ہے اور فنکشن درست لوٹتا ہے۔بصورت دیگر ، نمبر ایک کامل مربع نہیں ہے اور فنکشن غلط 12 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کی جانچ پڑتال کی گئی ہے اگر نمبر 16 ایک کامل مربع ہے: جاوا اسکرپٹکونسٹ نمبر = 16 ؛ کانسٹ آئسپریکٹ = آئسپر فیکٹ اسکوائر (نمبر) ؛ کنسول.لوگ (آئسپر فیکٹ)؛ یہ سچ ثابت ہوگا۔ یہ چیک کرنے کے لئے ایک لوپ کا استعمال کرتے ہوئے کہ آیا ہر عدد کا مربع ان پٹ نمبر کے برابر ہے: جاوا اسکرپٹ فینکشن isperfectsquare (num) {for (i = 1 ؛ i * i <= num ؛ i ++) {اگر (i* i === num) {سچ واپس ؛}} جھوٹی لوٹائیں ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اگر یہ نمبر ایک کامل مربع اور غلط ہے تو وہ سچ واپس آجاتا ہے۔فنکشن لوپ کے لئے ایک استعمال کرتا ہے تاکہ یہ چیک کیا جاسکے کہ آیا ہر عدد کا مربع نمبر کے مربع جڑ تک ان پٹ نمبر کے برابر ہے یا نہیں۔اگر کسی انٹیجر کا مربع ان پٹ نمبر کے برابر ہے تو ، نمبر ایک بہترین مربع ہے اور فنکشن درست لوٹتا ہے۔بصورت دیگر ، فنکشن غلط لوٹاتا ہے۔یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ نمبر ایک نمبر کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نمبر نافذ کیا جاتا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ یہ چیک کرنے کے بنیادی طریقے مہیا کرتے ہیں کہ آیا کوئی نمبر ایک کامل مربع ہے ، تو زیادہ اعلی درجے کے نفاذات ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "بے ترتیب UUID (عالمی سطح پر انوکھا شناخت کنندہ) پیدا کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں بے ترتیب UUID (عالمی سطح پر منفرد شناخت کنندہ) پیدا کرنے کے لئے ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔یہاں کچھ ممکنہ نفاذ ہیں: کریپٹو.رینڈوومیوئڈ () طریقہ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فینکشن جنریٹیوئڈ () {واپس کریپٹو.رینڈوومیوئڈ () ؛}} یہ فنکشن کریپٹو.رینڈومیوئڈ () طریقہ کا استعمال کرتے ہوئے بے ترتیب UUID تیار کرتا ہے۔یہ طریقہ براؤزرز میں اور نوڈ جے جے میں عالمی کرپٹو آبجیکٹ پر دستیاب ہے۔یہ کریپٹوگرافیکل محفوظ بے ترتیب نمبر جنریٹر کا استعمال کرتے ہوئے ایک ورژن 4 UUID تیار کرتا ہے۔فنکشن آسانی سے پیدا شدہ UUID12 کو واپس کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک بے ترتیب UUID تیار کرتا ہے: جاوا اسکرپٹ کونسٹ UUID = جنریٹیوئڈ () ؛ کنسول.لوگ (UUID) ؛ یہ بے ترتیب UUID کی پیداوار کرے گا ، جیسے \"D1C7D0C4-2D7C-4F0A-4F0A-9C4D-3a8b5e3e7f8d \". UUID لائبریری کا استعمال کرتے ہوئے: جاوا اسکرپٹکونسٹ {V4: uuidv4} = ضرورت ('uuid') ؛ فنکشن جنریٹیوئڈ () {واپسی uuidv4 () ؛}} یہ فنکشن UUID لائبریری کا استعمال کرتے ہوئے بے ترتیب UUID پیدا کرتا ہے۔یہ لائبریری ورژن 1 ، 3 ، 4 ، اور 5 UUIDS پیدا کرسکتی ہے۔فنکشن ورژن 4 UUID تیار کرنے کے لئے V4 () کا طریقہ استعمال کرتا ہے ، جو بے ترتیب UUID ہے۔فنکشن آسانی سے پیدا شدہ UUID3 کو لوٹاتا ہے۔-3a8b5e3e7f8d \".مجھے یہ نہیں کہ یہ نفاذ فرض کریں کہ ان پٹ درست ہے اور ضروری لائبریریوں کو انسٹال کیا گیا ہے۔اگر ان پٹ درست نہیں ہے یا ضروری لائبریریوں کو انسٹال نہیں کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ بے ترتیب UUID پیدا کرنے کے بنیادی طریقے مہیا کرتے ہیں تو ، UID کے زیادہ اعلی درجے کے نفاذ موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے اسٹرنگ غیر الفینومیرک کرداروں کو نظرانداز کرنے والی ایک درست پیلنڈرووم ہے۔",
        "Answer": "جاوا اسکرپٹ میں غیر الفانومرک کرداروں کو نظرانداز کرنے والے ایک درست پیلنڈرووم کی جانچ پڑتال کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔ایک طریقہ یہ ہے کہ تمام غیر الفانومرک کرداروں کو تار سے ہٹا دیں اور نتیجے میں ہونے والے تار کا موازنہ اس کے الٹ سے کریں۔یہاں کچھ ممکنہ نفاذات ہیں: غیر الفانومرک حروف کو دور کرنے کے لئے باقاعدہ اظہار کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن ispalindrome (str) {const alphanumericstr = str.tolowercic (). تبدیل کریں (/[^a-z0-9]/g ، '')؛Const relusedstr = alphanumericstr.split (''). ریورس (). شامل ہوں ('' ') ؛واپس الفانومرکسٹر === الٹ سیسٹر ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر تار ایک درست پلنڈرووم ہے جو غیر الفانومرک کرداروں کو نظرانداز کرتا ہے اور دوسری صورت میں غلط ہے۔فنکشن سب سے پہلے ان پٹ سٹرنگ کو لوئر کیس میں تبدیل کرتا ہے اور باقاعدہ اظہار کا استعمال کرتے ہوئے تمام غیر الفانومرک کرداروں کو ہٹاتا ہے۔اس کے نتیجے میں اسٹرنگ کو پھر الٹ کیا جاتا ہے اور اس کا موازنہ اصل تار کے ساتھ کیا جاتا ہے۔اگر دونوں ڈور برابر ہیں تو ، ان پٹ سٹرنگ ایک درست پیلنڈرووم ہے اور فنکشن درست لوٹتا ہے۔بصورت دیگر ، فنکشن غلط 12 کو لوٹاتا ہے۔کینال: پاناما '؛ کانسٹ ispal = ispalindrome (str) ؛ کنسول.لوگ (ispal) ؛ یہ حقیقت کو ختم کرے گا۔ غیر الفینومیرک حرفوں کو دور کرنے کے لئے .match () طریقہ کا استعمال کرتے ہوئے: جاواسکرپٹ فنکشن ispalindrome (str) const const الفانومرکسٹر = str.ٹولور کیس (). میچ (/[A-Z0-9]/g) .join ('') ؛Const relusedstr = alphanumericstr.split (''). ریورس (). شامل ہوں ('' ') ؛واپس الفانومرکسٹر === الٹ سیسٹر ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر تار ایک درست پلنڈرووم ہے جو غیر الفانومرک کرداروں کو نظرانداز کرتا ہے اور دوسری صورت میں غلط ہے۔فنکشن سب سے پہلے ان پٹ سٹرنگ کو لوئر کیس میں تبدیل کرتا ہے اور باقاعدگی سے اظہار کے ساتھ. میٹ () طریقہ کا استعمال کرتے ہوئے تمام غیر الفانومیرک حروف کو ہٹاتا ہے۔اس کے نتیجے میں ہونے والی صف کو پھر ایک تار میں شامل کیا جاتا ہے ، الٹ کیا جاتا ہے ، اور اصل تار کے مقابلے میں۔اگر دونوں ڈور برابر ہیں تو ، ان پٹ سٹرنگ ایک درست پیلنڈرووم ہے اور فنکشن درست لوٹتا ہے۔بصورت دیگر ، فنکشن غلط لوٹاتا ہے۔کینال: پاناما '؛ کانسٹ ispal = ispalindrome (str) ؛ کنسول.لاگ (ispal) ؛ یہ سچ ثابت ہوگا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور اس تار کو اسٹرنگ کا استعمال کرتے ہوئے نافذ کیا گیا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ یہ چیک کرنے کے بنیادی طریقے مہیا کرتے ہیں کہ آیا اسٹرنگ غیر الفانومیرک کرداروں کو نظرانداز کرنے کے لئے ایک درست پیلنڈرووم ہے ، تو اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "ترتیب دیئے گئے صف کی اوسط قیمت تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں ایک ترتیب شدہ صف کی اوسط قیمت تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔ایک طریقہ یہ ہے کہ سرنی کا وسط نقطہ تلاش کریں اور اس کی بنیاد پر میڈین کا حساب لگائیں کہ آیا صف کی لمبائی عجیب ہے یا اس سے بھی۔یہاں کچھ ممکنہ نفاذ ہیں: ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے اور میڈین کا حساب لگانا: جاوا اسکرپٹ فنکشن میڈین (اے آر آر) {کونٹ سنٹارر = آر آر ایسٹ ((a ، b) => a - b) ؛مڈپوائنٹ = ریاضی.فلور (shartedarr.length / 2) ؛if (shartedarr.length ٪ 2 === 0) {واپسی (shartedar [MidPoint - 1] + shartedarr [مڈپوائنٹ]) / 2 ؛} else {واپس shartedarr [مڈپوائنٹ] ؛}} یہ فنکشن ان پٹ کے طور پر ایک ترتیب شدہ صف لیتا ہے اور صف کی اوسط قیمت کو لوٹاتا ہے۔فنکشن پہلے موازنہ کی تقریب کے ساتھ ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے ان پٹ سرنی کو ترتیب دیتا ہے تاکہ یہ یقینی بنایا جاسکے کہ سرنی چڑھائی ترتیب میں ترتیب دی گئی ہے۔اس کے بعد اس فنکشن کو صف کی لمبائی کو 2 سے تقسیم کرکے اور ریاضی.فور () کا استعمال کرتے ہوئے نیچے گول کے ذریعہ سرے کا وسط نقطہ پایا جاتا ہے۔اگر صف کی لمبائی بھی ہے تو ، فنکشن میڈین کو دو درمیانی اقدار کی اوسط کے حساب سے حساب کرتا ہے۔اگر سرنی کی لمبائی عجیب ہے تو ، فنکشن آسانی سے درمیانی قیمت 12 کو لوٹاتا ہے۔[1 ، 2 ، 3 ، 4 ، 5] const کانسٹیٹ میڈین ویلیو = میڈین (اے آر آر) ؛ کنسول.لوگ (میڈین ویلیو) ؛ یہ آؤٹ پٹ 3. سلائس () کا طریقہ استعمال کرے گا اور میڈین کا حساب کتاب: جاوا اسکرپٹ فانکشن میڈین (اے آر آر) {کانسٹنٹshartedarr = arr.slice (). ترتیب دیں ((a ، b) => a - b) ؛مڈپوائنٹ = ریاضی.فلور (shartedarr.length / 2) ؛if (shartedarr.length ٪ 2 === 0) {واپسی (shartedar [MidPoint - 1] + shartedarr [مڈپوائنٹ]) / 2 ؛} else {واپس shartedarr [مڈپوائنٹ] ؛}} یہ فنکشن ان پٹ کے طور پر ایک ترتیب شدہ صف لیتا ہے اور صف کی اوسط قیمت کو لوٹاتا ہے۔فنکشن پہلے اصل صف میں ترمیم کرنے سے بچنے کے لئے سلائس () کے طریقہ کار کا استعمال کرتے ہوئے ان پٹ سرنی کی ایک کاپی بناتا ہے۔اس کے بعد فنکشن کاپی شدہ سرنی کو ایک موازنہ فنکشن کے ساتھ ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے ترتیب دیتا ہے تاکہ یہ یقینی بنایا جاسکے کہ سرنی چڑھائی ترتیب میں ترتیب دی گئی ہے۔اس کے بعد اس فنکشن کو صف کی لمبائی کو 2 سے تقسیم کرکے اور ریاضی.فور () کا استعمال کرتے ہوئے نیچے گول کے ذریعہ سرے کا وسط نقطہ پایا جاتا ہے۔اگر صف کی لمبائی بھی ہے تو ، فنکشن میڈین کو دو درمیانی اقدار کی اوسط کے حساب سے حساب کرتا ہے۔اگر صف کی لمبائی عجیب ہے تو ، فنکشن آسانی سے درمیانی قیمت کو واپس کرتا ہے۔[1 ، 2 ، 3 ، 4 ، 5] const کانسٹین ویلیو = میڈین (اے آر آر) ؛ کنسول.لاگ (میڈین ویلیو) ؛ اس کی پیداوار 3 ہوگی۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور یہ کہ سرنی چڑھائی میں ترتیب دی گئی ہے۔ترتیب.اگر ان پٹ درست نہیں ہے یا سرنی کو ترتیب نہیں دیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ نفاذ کسی ترتیب شدہ صف کی درمیانی قیمت کو تلاش کرنے کے لئے بنیادی طریقے مہیا کرتے ہیں ، لیکن اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو میٹرکس (2D سرنی) کی نمائندگی کرے۔میٹرک کو منتقل کرنے اور ضرب لگانے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے ل that جو میٹرکس (2 ڈی سرنی) کی نمائندگی کرتا ہے اور میٹرکس کو منتقل کرنے اور ضرب لگانے کے طریقوں کو نافذ کرتا ہے ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس میٹرکس {کنسٹرکٹر (قطار) {this.rows = قطاریں ؛this.colums = this.getColums () ؛} getColums () {const کالم = [] ؛کے لئے (آئیے i = 0 ؛ i <this.rows [0] .length ؛ i ++) {const کالم = [] ؛کے لئے (j = 0 ؛ j <this.rows.length ؛ j ++) {کالم.پش (this.rows [j] [i]) ؛} کالم.پش (کالم) ؛} کالم واپسی ؛} transpose () {const transposedrows = this.columns ؛Const transposedmatrix = نیا میٹرکس (ٹرانسپوزڈروز) ؛ٹرانسپوزڈ میٹرکس کی واپسی ؛} ضرب (دوسرے) {اگر (this.colums.length! == دیگر.روز.لنتھ) {نئی غلطی پھینک دیں ('اس میٹرکس کے کالموں کی تعداد دیئے گئے میٹرکس کی قطاروں کی تعداد کے برابر نہیں ہے۔')؛} const newrows = [] ؛کے لئے (آئیے i = 0 ؛ i <this.rows.length ؛ i ++) {const newrow = [] ؛کے لئے (j = 0 ؛ j <دیگر. colums.length ؛ j ++) {const dotProduct = this.rows [i] .reduce ((acc ، curr ، index) => acc+curr * دیگر. کالمز [j] [انڈیکس] ، 0) ؛newrow.push (ڈاٹ پروڈکٹ) ؛} newrows.push (newrow) ؛product کنٹ پروڈکٹ میٹرکس = نیا میٹرکس (نیو روز) ؛واپس پروڈکٹ میٹرکس ؛}} یہ کلاس میٹرکس (2 ڈی سرنی) کی نمائندگی کرتی ہے اور اس میں میٹرک کو منتقل کرنے اور ضرب لگانے کے طریقے ہیں۔کنسٹرکٹر (قطاریں) کا طریقہ دی گئی قطاروں کے ساتھ میٹرکس کی ابتدا کرتا ہے۔گیٹ کالمز () کا طریقہ میٹرکس کے کالموں کی ایک صف لوٹاتا ہے۔ٹرانسپوز () کا طریقہ ایک نیا میٹرکس لوٹاتا ہے جو اصل میٹرکس کا ٹرانسپوز ہے۔ضرب (دوسرا) طریقہ کار ایک اور میٹرکس کے ذریعہ اصل میٹرکس کو ضرب دیتا ہے اور اس کے نتیجے میں میٹرکس لوٹاتا ہے۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا اصل میٹرکس کے کالموں کی تعداد دوسرے میٹرکس کی قطار کی تعداد کے برابر ہے۔اگر وہ برابر نہیں ہیں تو ، فنکشن ایک غلطی پھینک دیتا ہے۔اس کے بعد فنکشن دوسرے میٹرکس کے ہر کالم کے ساتھ اصل میٹرکس کی ہر صف کی ڈاٹ پروڈکٹ کا حساب لگاتا ہے اور نتائج کو ایک نئے میٹرکس 123 میں اسٹور کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ دو میٹرک تیار کرتا ہے ، پہلے میٹرکس کو منتقل کرتا ہے ، دو میٹرکس کو ضرب دیتا ہے ،اور نتائج کو لاگ ان کریں: جاوا اسکرپٹ کنسٹ میٹرکس 1 = نیا میٹرکس ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) ؛ کانسٹ میٹرکس 2 = نیا میٹرکس ([[7 ، 8] ، [9 ، 10] ، [11 ، 12]]) ؛ const transposedmatrix1 = matrix1.transpose () const const productmatrix = matrix1.multiply (matrix2) ؛ کنسول.لاگ (ٹرانسپوزڈ میٹرکس 1.rows) ؛ کنسول.لاگ (پروڈکٹ میٹرکس.روز) ؛ یہ پیداوار کرے گا [[1] []] ، [2] [5] ، [3] []]] اور [[58] [] 64] ، [139 ، 154]]۔ نوٹ کریں کہ اس عمل سے یہ فرض کیا گیا ہے کہ ان پٹ درست ہے اور میٹرک ہیںصفوں کا استعمال کرتے ہوئے نافذ کیا گیا۔اگر ان پٹ درست نہیں ہے یا میٹرکس کو مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاتا ہے تو ، یہ عمل درآمد نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ عمل درآمد ٹرانسپوز اور ضرب طریقوں کے ساتھ ایک بنیادی میٹرکس کلاس مہیا کرتا ہے تو ، اس سے زیادہ جدید میٹرکس پر عمل درآمد ہوتا ہے جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتا ہے۔"
    },
    {
        "Question": "تار کے ایک سیٹ میں سب سے طویل عام پریفکس تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں تاروں کے ایک سیٹ کے درمیان سب سے طویل مشترکہ سابقہ تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ڈور کے ہر کردار کا موازنہ کرنے کے ل a ایک لوپ کا استعمال: جاوا اسکرپٹ فنکشن طویل ترین کامومن پریفکس (ایس ٹی آر ایس) {اگر (str.length === 0) {واپسی '' ؛pref لیٹ پریفکس = '' ؛کے لئے (آئیے i = 0 ؛ i <strs [0] .length ؛ i ++) {const char = strs [0] [i] ؛کے لئے (j = 1 ؛ j <strs.length ؛ j ++) {اگر (i> = strs [j] .length || strs [j] [i]! == چار) {واپسی کا سابقہ ؛}} پریفکس += چار ؛} واپسی کا سابقہ ؛} یہ فنکشن ان پٹ کے طور پر تاروں کی ایک صف لیتا ہے اور تار کے درمیان سب سے طویل عام سابقہ واپس کرتا ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا ان پٹ سرنی خالی ہے اور اگر خالی تار واپس کرتا ہے تو۔اس کے بعد فنکشن ایک خالی سٹرنگ کا سابقہ شروع کرتا ہے اور لوپ کے لئے A کا استعمال کرتے ہوئے صف میں پہلے تار کے ہر کردار پر تکرار کرتا ہے۔ہر کردار کے ل the ، فنکشن اس کا موازنہ لوپ کے لئے دوسرے کا استعمال کرتے ہوئے صف میں موجود ہر دوسرے ڈور کے اسی کردار سے کرتا ہے۔اگر کردار مماثل نہیں ہے یا انڈیکس دوسرے سٹرنگ کی لمبائی سے زیادہ یا اس کے برابر ہے تو ، فنکشن موجودہ سابقہ کو لوٹاتا ہے۔بصورت دیگر ، فنکشن کردار کو سابقہ میں شامل کرتا ہے۔اگر لوپ واپس کیے بغیر مکمل ہوجاتے ہیں تو ، فنکشن حتمی سابقہ 123 کو لوٹاتا ہے۔\"فلو\" ، \"فلائٹ\"] ؛ کانسٹ طویل ترین پریفکس = طویل عرصے سے کاممون پریفکس (ایس ٹی آر ایس) ؛ کنسول.لوگ (طویل ترین پریفکس) ؛ اس سے \"ایف ایل\" کی پیداوار ہوگی۔ تاروں کے ہر کردار کا موازنہ کرنے کے لئے کم () کے طریقہ کار کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن لانگسٹ کامپین پریفکس (ایس ٹی آر){اگر (strs.length === 0) {واپسی '' ؛strs ret.reduce ((سابقہ ، str) => {i = 0 ؛ جبکہ (i <prefix.length && i <str.length && prefix [i] === str [i]) {i ++ ؛} واپسیپریفکس ڈاٹ سلائس (0 ، i) ؛}) ؛} یہ فنکشن ان پٹ کے طور پر تاروں کی ایک صف لیتا ہے اور تار کے درمیان سب سے طویل عام سابقہ واپس کرتا ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا ان پٹ سرنی خالی ہے اور اگر خالی تار واپس کرتا ہے تو۔اس کے بعد فنکشن کم () کے طریقہ کار کو سرنی میں ہر تار پر تکرار کرنے کے لئے استعمال کرتا ہے اور اسے موجودہ سابقہ سے موازنہ کرتا ہے۔ہر تار کے ل the ، فنکشن ایک انڈیکس I کو 0 سے شروع کرتا ہے اور تھوڑی دیر لوپ کا استعمال کرتے ہوئے پریفکس کے ہر کردار اور سٹرنگ کے اوپر تکرار کرتا ہے۔اگر پریفکس کے انڈیکس I میں کردار اور سٹرنگ میچ اور میں دونوں پریفکس اور سٹرنگ دونوں کی لمبائی سے کم ہے تو ، فنکشن میں اضافہ i.بصورت دیگر ، فنکشن کا سابقہ انڈیکس I تک واپس کرتا ہے۔اس کے بعد کم () طریقہ لوپ 43 کے اگلے تکرار کے لئے تازہ ترین سابقہ کو منتقل کرتا ہے۔\"پھول\" ، \"فلو\" ، \"فلائٹ\"] ؛ کانسٹنٹ طویل عرصے سے متعلق = طویل ترین کامومن پریفکس (ایس ٹی آر ایس) ؛ کنسول.لاگ (طویل عرصے سے پریفکس) ؛ یہ \"ایف ایل\" آؤٹ پٹ کرے گا۔ نوٹ کریں کہ یہ عمل درآمد درست ہے اور یہ تاریں ہیں اور یہ تاریں ہیںتاروں کا استعمال کرتے ہوئے نافذ کیا گیا۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے ڈوروں کو نافذ کیا جاتا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ تاروں کے ایک سیٹ میں سب سے طویل عام پریفکس کو تلاش کرنے کے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر دو کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد جاوا اسکرپٹ میں دو کی طاقت ہے ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: سیٹ بٹس کی تعداد کو گننے کے لئے بٹ وائز آپریٹرز کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن آئس پاوروفٹ وو (نمبر) {ریٹرن (نمبر! == 0) && ((نمبر اور (نمبر - 1)) === 0) ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اگر یہ نمبر دو کی طاقت ہے اور غلط ہے تو وہ سچ ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا ان پٹ نمبر 0 کے برابر نہیں ہے۔ اگر یہ ہے تو ، فنکشن غلط لوٹاتا ہے۔بصورت دیگر ، فنکشن یہ چیک کرنے کے لئے بٹ وائز آپریٹرز کا استعمال کرتا ہے کہ آیا نمبر میں صرف ایک سیٹ بٹ ہے۔خاص طور پر ، فنکشن چیک کرتا ہے کہ آیا بٹ وائز اور نمبر اور مائنس ایک کے برابر ہے۔بصورت دیگر ، فنکشن غلط 12 کو لوٹاتا ہے۔نمبر کو دو سے تقسیم کرنے کے لئے ایک لوپ: جاوا اسکرپٹ فنکشن ispoweroftwo (num) {اگر (num <= 0) {غلط واپس ؛} جبکہ (num> 1) {اگر (نمبر ٪ 2! == 0) {غلط واپس ؛} نمبر /= 2 ؛true سچائی واپس ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اگر یہ نمبر دو کی طاقت ہے اور غلط ہے تو وہ سچ ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا ان پٹ نمبر 0 سے کم یا اس کے برابر ہے۔ اگر یہ ہے تو ، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، فنکشن اس نمبر کو 2 سے تقسیم کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے جب تک کہ نمبر 1 سے کم یا اس کے برابر نہ ہو۔ ہر تکرار کے لئے ، فنکشن چیک کرتا ہے کہ اگر 2 کے ذریعہ تقسیم شدہ نمبر 0 کے برابر نہیں ہے تو اگر یہ ہے۔نہیں ، تعداد دو کی طاقت نہیں ہے اور فنکشن غلط لوٹتا ہے۔بصورت دیگر ، فنکشن نمبر کو 2 سے تقسیم کرتا ہے۔ اگر لوپ واپس کیے بغیر مکمل ہوجاتا ہے تو ، نمبر دو کی طاقت ہے اور فنکشن درست 34 کو لوٹاتا ہے۔16 ؛ کانسٹ آئس پاور = آئس پاوروفٹو (نمبر) ؛ کنسول.لوگ (آئس پاور) ؛ یہ سچ ثابت ہوگا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور اس نمبر کو ایک نمبر کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نمبر نافذ کیا جاتا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ یہ چیک کرنے کے بنیادی طریقے مہیا کرتے ہیں کہ آیا کوئی نمبر دو کی طاقت ہے تو ، اس سے زیادہ نفاذات ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "دیئے گئے تار سے تمام HTML ٹیگز کو ہٹانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے اسٹرنگ سے تمام HTML ٹیگز کو ہٹانے کے ل this ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔تلاش کے نتائج کی بنیاد پر کچھ ممکنہ نفاذ یہ ہیں: باقاعدگی سے اظہار کے ساتھ تبدیل () طریقہ استعمال کرنا: جاوا اسکرپٹ فانکشن کو ہٹانے والی ہیٹ ایم ایل ٹی اے جی ایس (ایس ٹی آر) {ریٹرن str.replace (/<[^>]*>/g ، '') ؛} ؛یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تمام HTML ٹیگس کو ہٹانے کے ساتھ سٹرنگ کو واپس کرتا ہے۔فنکشن ایک باقاعدہ اظہار کے ساتھ تبدیل () طریقہ استعمال کرتا ہے جو زاویہ بریکٹ (<اور>) کے مابین کسی بھی متن سے مماثل ہوتا ہے اور اسے خالی تار کے ساتھ تبدیل کرتا ہے۔جی پرچم کو اسٹرنگ 12 میں پیٹرن کے تمام واقعات کو تبدیل کرنے کے لئے استعمال کیا جاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ سٹرنگ <p> ہیلو ، <strong> دنیا سے تمام HTML ٹیگز کو ہٹا دیتا ہے! </strong> </p>= '<p> ہیلو ، <strong> دنیا! </strong> </p>' ؛ کانسٹ سٹرپڈسٹر = ریمو ہٹیمل ٹیگس (ایس ٹی آر) ؛ کنسول.لوگ (سٹرپڈسٹر) ؛ یہ \"ہیلو ، ورلڈ!\" کی پیداوار کرے گا۔ ڈوم پارسر کا استعمال کرتے ہوئےانٹرفیس: جاوا اسکرپٹ فکشن کو ہٹانے والی ایچ ٹی ایم ایل ٹیگس (ایس ٹی آر) {Const پارسر = نیا ڈوم پارسر () ؛کانسٹ ڈوک = پارسر۔ پارس فریمسٹرنگ (str ، 'متن/html') ؛doc.body.textContent ||'' ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تمام HTML ٹیگس کو ہٹانے کے ساتھ تار کو لوٹاتا ہے۔فنکشن پہلے ایک نیا ڈوم پارسر آبجیکٹ تشکیل دیتا ہے اور اسے HTML کے بطور ان پٹ سٹرنگ کی تجزیہ کرنے کے لئے استعمال کرتا ہے۔اس کے نتیجے میں دستاویزی آبجیکٹ کو جسمانی عنصر کی ٹیکسٹ کوونٹنٹ پراپرٹی تک رسائی کے لئے استعمال کیا جاتا ہے ، جس میں ایچ ٹی ایم ایل دستاویز کا ٹیکسٹ مواد ہوتا ہے۔اگر ٹیکسٹ کونٹینٹ پراپرٹی کالعدم ہے یا غیر وضاحتی ہے تو ، فنکشن خالی سٹرنگ 34 کو لوٹاتا ہے۔= '<p> ہیلو ، <strong> ورلڈ! </strong> </p>' ؛ کانسٹ سٹرپڈسٹر = ریمو ہٹیمل ٹیگس (ایس ٹی آر) ؛ کنسول.لوگ (سٹرپڈسٹر) ؛ یہ \"ہیلو ، دنیا!\" ہوگی۔ نوٹ کریں کہ یہ نوٹ کریں۔عمل درآمد یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ تار کو تار کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ نفاذ کسی دیئے گئے تار سے تمام HTML ٹیگوں کو ہٹانے کے بنیادی طریقے مہیا کرتے ہیں ، لیکن اس سے زیادہ نفاذات موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں عددیوں کی ایک دی گئی صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے ، بہت سارے نقطہ نظر ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ہر سبری کے جوڑے کا حساب لگانے کے لئے نیسٹڈ لوپ کا استعمال: جاوا اسکرپٹ فینکشن گیٹ میکسسوبسم (اے آر آر) {آئیے میکسم = 0 ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {آئیے سمفکسڈ اسٹارٹ = 0 ؛کے لئے (j = i ؛ j <arr.length ؛ j ++) {sumfixedstart+= arr [j] ؛میکسم = ریاضی۔ میکس (میکسم ، سمفکسڈ اسٹارٹ) ؛}} میکسم ریٹرن}} یہ فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور زیادہ سے زیادہ سبری کا مجموعہ واپس کرتا ہے۔فنکشن ہر سبری کے جوڑے کا حساب لگانے کے لئے نیسڈ لوپ کا استعمال کرتا ہے اور میکسم متغیر کو اپ ڈیٹ کرتا ہے اگر موجودہ رقم پچھلی زیادہ سے زیادہ سے زیادہ ہے۔بیرونی لوپ سبری کے ہر ابتدائی انڈیکس پر تکرار کرتا ہے ، اور اندرونی لوپ سبری کے ہر اختتامی انڈیکس پر تکرار کرتا ہے۔فنکشن حتمی میکسم 12 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ میں سرے کا زیادہ سے زیادہ سبری کا مجموعہ [1 ، -2 ، 3 ، 4 ، -9 ، 6]: جاوا اسکرپٹ کونسٹ آر آر = [1 ، -2 ، 3 ، 4 ،-9 ، 6] const const maxsubsum = getMaxsubsum (arr) ؛ کنسول.لاگ (میکسبسم) ؛ اس کی پیداوار 7. کڈانے کے الگورتھم کا استعمال زیادہ سے زیادہ سبریے کے حساب سے ہوگا: جاوا اسکرپٹ فینکشن getMaxbsum (arr) {اجازت دیں میکسم = arr [0] ؛آئیے کرینٹسم = آر آر [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {کرینٹسم = math.max (arr [i] ، کرینٹسم+arr [i]) ؛میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛} میکسم کی واپسی ؛} یہ فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور زیادہ سے زیادہ سبری کا مجموعہ واپس کرتا ہے۔اس فنکشن میں کڈانے کے الگورتھم کا استعمال کیا گیا ہے ، جو ایک متحرک پروگرامنگ نقطہ نظر ہے جو سرنی کے ہر انڈیکس پر ختم ہونے والے زیادہ سے زیادہ سبراے رقم کا حساب لگاتا ہے۔فنکشن میکسم اور کرینسم کو سرنی کے پہلے عنصر میں شروع کرتا ہے اور اس کے بعد کے ہر عنصر پر تکرار کرتا ہے۔ہر عنصر کے ل the ، فنکشن اس عنصر پر ختم ہونے والے زیادہ سے زیادہ سبری کے مجموعی کا حساب لگاتا ہے جس میں عنصر کی زیادہ سے زیادہ اور عنصر کی رقم اور پچھلے عنصر پر ختم ہونے والی زیادہ سے زیادہ سبری کا مجموعہ ختم ہوتا ہے۔فنکشن میکسم کو اپ ڈیٹ کرتا ہے اگر موجودہ زیادہ سے زیادہ سبری کا مجموعہ پچھلی زیادہ سے زیادہ سے زیادہ ہے۔فنکشن حتمی میکسم 34 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ میں سرے کا زیادہ سے زیادہ سبراے مجموعہ [1 ، -2 ، 3 ، 4 ، -9 ، 6]: جاوا اسکرپٹکونسٹ آر آر = [1 ، -2 ، 3 ، 4 ، ،-9 ، 6] const const Maxsubsum = getMaxsubsum (ARR) ؛ کنسول.لاگ (میکسبسم) ؛ اس کی پیداوار 7. ہوگی۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور یہ کہ سرنی کو عددیوں کی ایک صف کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ نفاذ عددیوں کی ایک مخصوص صف میں زیادہ سے زیادہ سبراے رقم تلاش کرنے کے لئے بنیادی طریقے مہیا کرتے ہیں ، لیکن اس سے زیادہ نفاذات موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "الفاظ کی ترتیب اور کسی دیئے گئے جملے میں ہر کردار کے معاملے کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے جملے میں الفاظ کی ترتیب اور ہر کردار کے معاملے کو الٹ کرنے کے ل we ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: جاوا اسکرپٹ فینکشن ریورسورڈ کیس (جملہ) {کونسٹ الفاظ = جملے.سپلٹ ('') ؛کانسٹ الٹ ورڈز = [] ؛کے لئے (آئیے i = 0 ؛ i <words.length ؛ i ++) {const ورڈ = الفاظ [i] ؛الٹ ورڈ = '' ؛کے لئے (دو j = ورڈ.ایلتھ-1 ؛ j> = 0 ؛ j--) {const Char = ورڈ [j] ؛اگر (چار === چار.ٹوپپر کیس ()) {الٹ ورڈ += چار.ٹولور کیس () ؛} else {الٹ ورڈ += چار.ٹوپر کیس () ؛}} الٹ ورڈز۔ پش (الٹ ورڈ) ؛return واپس الٹ ورڈز۔فنکشن سب سے پہلے ان پٹ جملہ کو اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتا ہے۔اس کے بعد فنکشن لوپ کے لئے A کا استعمال کرتے ہوئے صف میں ہر لفظ پر اعادہ کرتا ہے اور لوپ کے لئے دوسرے کا استعمال کرتے ہوئے لفظ میں ہر کردار کے معاملے کو الٹ دیتا ہے۔فنکشن چیک کرتا ہے کہ آیا ہر کردار ٹپر کیس () اور ٹولور کیس () کے طریقوں کا استعمال کرتے ہوئے بڑے پیمانے پر ہے اور الٹ کردار کو الٹ ورڈ متغیر میں شامل کرتا ہے۔اس کے بعد فنکشن الٹ لفظوں کو الٹ ورڈز سرنی میں دھکیل دیتا ہے۔آخر میں ، فنکشن الٹ () طریقہ کار کا استعمال کرتے ہوئے صف میں الفاظ کے ترتیب کو تبدیل کرتا ہے اور جوائن () طریقہ 12 کا استعمال کرتے ہوئے الفاظ کو ایک تار میں شامل کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ الفاظ کی ترتیب اور ہر ایک کے معاملے کو تبدیل کرتا ہے\"ہیلو ، ورلڈ!\" کے جملے میں کردارفرض کریں کہ ان پٹ درست ہے اور یہ کہ سٹرنگ کا استعمال کرتے ہوئے جملے کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے جملے کو نافذ کیا گیا ہے تو ، یہ عمل درآمد کام نہیں کرے گا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ عمل درآمد کسی جملے میں الفاظ کی ترتیب اور ہر کردار کے معاملے کو الٹ کرنے کا ایک بنیادی طریقہ فراہم کرتا ہے تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ کلاس بنائیں جو بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔کم سے کم عنصر کو داخل کرنے اور نکالنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس بنانے کے لئے جو بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے اور کم سے کم عنصر کو داخل کرنے اور نکالنے کے طریقوں کو نافذ کرتا ہے ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس بائنری ہیپ {کنسٹرکٹر () {this.heap = [] ؛} داخل کریں (قدر) {this.heap.push (ویلیو) ؛this.bubbleup (this.heap.length - 1) ؛} ایکسٹریکٹ مین () {const min = this.heap [0] ؛آخری = this.heap.pop () ؛اگر (this.heap.length> 0) {this.heap [0] = آخری ؛this.bbbledown (0) ؛} واپسی منٹ ؛} بلبلاپ (انڈیکس) {کونسٹ ویلیو = this.heap [انڈیکس] ؛جبکہ (انڈیکس> 0) {const parentIndex = math.floor ((انڈیکس - 1) / 2) ؛const parentvalue = this.heap [parentIndex] ؛اگر (ویلیو> = والدین ویلیو) {بریک ؛} this.heap [پیرنٹ انڈیکس] = قدر ؛this.heap [انڈیکس] = والدین ویلیو ؛انڈیکس = پیرنٹ انڈیکس ؛bub} بلبلیڈاؤن (انڈیکس) {کونسٹ ویلیو = this.heap [انڈیکس] ؛کانسٹ لمبائی = this.heap.length ؛جبکہ (سچ) {کانسٹ لیفٹائلڈ انڈیکس = 2 * انڈیکس + 1 ؛کونٹ رائٹچلڈ انڈیکس = 2 * انڈیکس + 2 ؛بائیں بازو کی قیمت ، دائیں بچے کی قیمت ؛آئیے swapindex = null ؛اگر (بائیں بازو کی لمبائی <لمبائی) {لیفٹائڈ ویلیو = this.Heap [بائیں طرف کاندیکس] ؛اگر (بائیں طرف سے <ویلیو) {SwapIndex = لیفٹائلڈ انڈیکس ؛}} if (RITELDINDEX <لمبائی) {رائٹ چائلڈ ویلیو = this.heap [دائیں طرفہ انڈیکس] ؛if ((swapindex === null && رائٹ چائلڈ ویلیو <ویلیو)}} if (swapindex === null) {بریک ؛} this.heap [index] = this.heap [swapindex] ؛this.heap [swapindex] = قدر ؛انڈیکس = سویپ انڈیکس ؛}}} یہ کلاس بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتی ہے اور اس میں کم سے کم عنصر داخل کرنے اور نکالنے کے طریقے ہیں۔کنسٹرکٹر () کا طریقہ خالی ڈھیر شروع کرتا ہے۔داخل (ویلیو) کا طریقہ ڈھیر میں ایک قدر داخل کرتا ہے اور ہیپ پراپرٹی کو برقرار رکھنے کے ل it اسے بلبل کرتا ہے۔ایکسٹریکٹ مین () کا طریقہ ڈھیر سے کم سے کم قیمت کو ہٹاتا ہے اور واپس کرتا ہے اور ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے آخری قیمت کو بلبل کرتا ہے۔بلبلاپ (انڈیکس) کا طریقہ ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے دیئے گئے انڈیکس میں ایک قدر بلبل کرتا ہے۔بلبلڈاؤن (انڈیکس) کا طریقہ ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے دیئے گئے انڈیکس میں کسی قدر کو کم کرتا ہے۔بلبلڈاؤن (انڈیکس) کا طریقہ دیئے گئے انڈیکس کی قیمت کو اپنے بائیں اور دائیں بچوں کے ساتھ موازنہ کرتا ہے اور اگر ضروری ہو تو اسے چھوٹے بچے کے ساتھ تبدیل کرتا ہے۔اس کے بعد فنکشن اس عمل کو نئے انڈیکس کے ساتھ دہراتا ہے جب تک کہ قیمت صحیح پوزیشن 12 میں نہ ہو۔ مثال کے طور پر ، مندرجہ ذیل کوڈ بائنری ہیپ بناتا ہے ، کچھ اقدار داخل کرتا ہے ، کم سے کم قیمت نکالتا ہے ، اور نتائج کو لاگ ان کرتا ہے: جاوا اسکرپٹکونسٹ ہیپ = نیا بائنری ہیپ (نیا بائنری ہیپ (نیا بائنری ہیپ (نیا بائنری ہیپ (نیا) ؛ ہیپ.سرٹ (5) ؛ ہیپ.سرٹ (3) ؛ ہیپ.سرٹ (7) ؛ ہیپ.سرٹ (1) ؛ ہیپ.سرٹ (9) ؛ کانسٹ من = ہیپ.ایکسٹرک مین () ؛ کنسول.لاگ (کنسول.لاگ (کم سے کم) ؛ یہ آؤٹ پٹ 1. نوٹ کرے گا کہ یہ عمل درآمد یہ فرض کرے گا کہ ان پٹ درست ہے اور بائنری ہیپ کو سرنی کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا بائنری ہیپ کو مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نافذ کیا جاتا ہے تو ، اس عمل سے کام نہیں ہوگا۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ عمل درآمد اور نچوڑ کے طریقوں کے ساتھ ایک بنیادی بائنری ہیپ کلاس مہیا کرتا ہے ، لیکن بائنری ہیپ کے زیادہ سے زیادہ عمل درآمد ہوتے ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "دیئے گئے تار میں پہلا غیر بار بار ہونے والا کردار تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے تار میں پہلا غیر بار بار نہ ہونے والا کردار تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ہر کردار کی موجودگی کو گننے کے ل a ایک لوپ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن فرسٹننریپیٹنگچار (ایس ٹی آر) {کونٹ گنتی = {} ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛شمار [چار] = شمار [چار]؟شمار [چار] + 1: 1 ؛} کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛اگر (گنتی [چار] === 1) {واپسی چار ؛}} واپسی NULL ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تار میں پہلا غیر بار بار ہونے والا کردار لوٹاتا ہے۔فنکشن سب سے پہلے تار میں ہر کردار کی موجودگی کو گننے کے لئے ایک خالی شے کی گنتی کرتا ہے۔اس کے بعد فنکشن لوپ کے لئے A کا استعمال کرتے ہوئے تار میں ہر کردار پر تکرار کرتا ہے اور گنتی آبجیکٹ میں کردار کی گنتی میں اضافہ کرتا ہے۔اس کے بعد فنکشن ایک بار پھر تار میں ہر کردار پر تکرار کرتا ہے اور پہلے کردار کو 1 کی گنتی کے ساتھ لوٹاتا ہے۔\"ہیلو\": جاوا اسکرپٹکونسٹ str = \"ہیلو\" ؛ کانسٹ فرسٹننریپیٹنگ = فرسٹننریپیٹنگچار (ایس ٹی آر) ؛ کنسول.لاگ (فرسٹننریپیٹنگ) ؛ اس سے \"ایچ\" کا استعمال ہوگا۔کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛اگر (str.indexof (چار) === str.lastindexof (چار)) {واپس چار ؛}} واپسی NULL ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تار میں پہلا غیر بار بار ہونے والا کردار لوٹاتا ہے۔فنکشن لوپ کے ل a ہر کردار کو تار میں تکرار کرنے کے لئے استعمال کرتا ہے اور چیک کرتا ہے کہ اگر کردار کا انڈیکس کردار کے آخری انڈیکس کے برابر ہے۔اگر یہ ہے تو ، کردار صرف ایک بار تار میں ظاہر ہوتا ہے اور فنکشن اسے لوٹاتا ہے۔اگر اس طرح کا کوئی کردار نہیں ملا ہے تو ، فنکشن NULL34 لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کو \"ہیلو\": جاوا اسکرپٹ کونسٹ str = \"ہیلو\" میں پہلا غیر بار بار ہونے والا کردار مل جاتا ہے۔(فرسٹنن ریپیٹنگ) ؛ یہ \"ایچ\" کو آؤٹ پٹ کرے گا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ تار کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ نفاذ کسی دیئے گئے تار میں پہلا غیر بار بار ہونے والے کردار کو تلاش کرنے کے بنیادی طریقے مہیا کرتے ہیں ، لیکن اس سے زیادہ اعلی درجے کے نفاذ موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتے ہیں۔"
    },
    {
        "Question": "موجودہ عنصر کے علاوہ کسی صف میں تمام عناصر کی مصنوعات کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں موجودہ عنصر کے علاوہ کسی صف میں تمام عناصر کی مصنوعات کا حساب لگانے کے لئے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: موجودہ عنصر کے علاوہ تمام عناصر کی مصنوعات کا حساب لگانے کے لئے دو لوپ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فانکشن پروڈکٹ ایکسپیکسیپٹی سیلف (اے آر آر) {کونٹ این = آر آر ایل لمبائی ؛کانسٹ آؤٹ پٹ = نئی سرنی (این) ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {مصنوعات = 1 ؛کے لئے (j = 0 ؛ j <n ؛ j ++) {اگر (i! == j) {پروڈکٹ *= arr [j] ؛}} آؤٹ پٹ [i] = پروڈکٹ ؛} واپسی آؤٹ پٹ ؛} یہ فنکشن ان پٹ کے طور پر ایک صف لیتا ہے اور اسی سائز کی ایک صف کو واپس کرتا ہے جہاں ہر عنصر ان پٹ سرنی میں موجود تمام عناصر کی پیداوار ہے سوائے اسی عنصر کے۔فنکشن موجودہ عنصر کے علاوہ تمام عناصر کی مصنوعات کا حساب لگانے کے لئے دو لوپ کا استعمال کرتا ہے۔بیرونی لوپ ان پٹ سرنی میں ہر عنصر پر تکرار کرتا ہے ، اور اندرونی لوپ ان پٹ سرنی میں ہر عنصر پر دوبارہ تکرار کرتا ہے۔ہر تکرار کے ل the ، فنکشن موجودہ عنصر کے ذریعہ موجودہ مصنوعات کو ضرب دیتا ہے اگر موجودہ انڈیکس بیرونی لوپ انڈیکس کے برابر نہیں ہے۔اس کے بعد فنکشن حتمی مصنوع کو آؤٹ پٹ اری 12 میں محفوظ کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ سرنی میں موجود تمام عناصر کی مصنوعات کا حساب لگاتا ہے [1] [2] [3] سوائے موجودہ عنصر کے: جاوا اسکرپٹکونسٹ ARR = [1 ، 2 ، 3] ؛ کنسٹ آؤٹ پٹ = پروڈکٹ ایکسپیکٹس سیلف (اے آر آر) ؛ کنسول.لاگ (آؤٹ پٹ) ؛ یہ آؤٹ پٹ [6] [3] [2] ہوگا۔ موجودہ عنصر کے علاوہ تمام عناصر کی مصنوعات کا حساب لگانے کے لئے سابقہ اور لاحقہ ضرب کا استعمال: جاوا اسکرپٹ فینکشن پروڈکٹ ایکسپیسسیپٹی سیلف (arr) {const n = arr.length ؛کانسٹ آؤٹ پٹ = نئی سرنی (این) ؛آئیے سابقہ = 1 ؛آئیے لاحقہ = 1 ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {آؤٹ پٹ [i] = سابقہ ؛سابقہ *= arr [i] ؛} کے لئے (آئیے i = n-1 ؛ i> = 0 ؛ i--) {آؤٹ پٹ [i] *= لاحقہ ؛لاحقہ *= arr [i] ؛} واپسی آؤٹ پٹ ؛} یہ فنکشن ان پٹ کے طور پر ایک صف لیتا ہے اور اسی سائز کی ایک صف کو واپس کرتا ہے جہاں ہر عنصر ان پٹ سرنی میں موجود تمام عناصر کی پیداوار ہے سوائے اسی عنصر کے۔فنکشن موجودہ عنصر کے علاوہ تمام عناصر کی مصنوعات کا حساب لگانے کے لئے سابقہ اور لاحقہ ضرب کا استعمال کرتا ہے۔فنکشن سب سے پہلے آؤٹ پٹ سرنی کو تمام 1s میں شروع کرتا ہے اور سابقہ اور لاحقہ کو 1 سے شروع کرتا ہے۔ اس کے بعد فنکشن ان پٹ سرنی میں ہر عنصر کے اوپر لوپ کا استعمال کرتے ہوئے دوبارہ پیش کرتا ہے اور موجودہ عنصر کو موجودہ پریفکس میں اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن موجودہ عنصر کے ذریعہ ضرب لگا کر سابقہ کو اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن ان پٹ سرنی میں ہر عنصر کو دوبارہ ریورس آرڈر میں لوپ کا استعمال کرتے ہوئے دوبارہ تکرار کرتا ہے اور موجودہ لاحقہ کے ذریعہ اس کو ضرب دے کر آؤٹ پٹ سرنی میں موجودہ عنصر کو اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن موجودہ عنصر کے ذریعہ اس کو ضرب دے کر لاحقہ کو اپ ڈیٹ کرتا ہے۔فنکشن آؤٹ پٹ اری 34 کو لوٹاتا ہے۔پروڈکٹ ایکسپیکسیپ سیلف (اے آر آر) ؛ کنسول.لوگ (آؤٹ پٹ) ؛ یہ آؤٹ پٹ کرے گا [6] [3] [2]. نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ انٹیجرز کی ایک صف کا استعمال کرتے ہوئے سرنی کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔اضافی طور پر ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ نفاذ موجودہ عنصر کے علاوہ کسی صف میں تمام عناصر کی پیداوار کا حساب لگانے کے بنیادی طریقے مہیا کرتے ہیں ، لیکن اس سے زیادہ نفاذات موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "\"دیئے گئے تار کو اونٹ کیس میں تبدیل کرنے کے لئے جاوا اسکرپٹ کا فنکشن بنائیں (اس کے بعد کے ہر لفظ کے لئے لوئر کیس فرسٹ لیٹر ، اپر کیس)۔\"",
        "Answer": "جاوا اسکرپٹ میں کسی دیئے گئے تار کو اونٹ کیس (لوئر کیسز فرسٹ لیٹر ، ہر بعد کے لفظ کے لئے اپر کیس) میں تبدیل کرنے کے لئے ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہاں ہیں: اسپلٹ () ، نقشہ () ، اور جوائن () طریقوں کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن ٹوکیملیس (ایس ٹی آر) {واپسی str.split (''). میپ ((لفظ ، اشاریہ)=> انڈیکس === 0؟ ورڈ.ٹولور کیس (): ورڈ.چارات (0) .touppercase () + ورڈ.سیلیس (1) .tolowercase ()) .جین ('') ؛} یہ فنکشن ایک تار لیتا ہے جیسےان پٹ اور اونٹ کے معاملے میں تار واپس کرتا ہے۔فنکشن سب سے پہلے ان پٹ سٹرنگ کو اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتا ہے۔اس کے بعد فنکشن نقشہ () کا طریقہ استعمال کرتا ہے تاکہ وہ صف میں ہر لفظ پر تکرار کرسکے اور ہر لفظ کے پہلے خط کو چارٹ () اور ٹپر کیس () طریقوں کا استعمال کرتے ہوئے بڑے میں تبدیل کرتا ہے۔فنکشن ہر لفظ کے بعد کے تمام خطوط کو سلائس () اور ٹولور کیس () طریقوں کا استعمال کرتے ہوئے چھوٹے کے لئے بھی تبدیل کرتا ہے۔اس کے بعد فنکشن میں شامل () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کو ایک تار میں شامل کیا جاتا ہے۔سٹرنگ میں پہلا لفظ لوئر کیس 12 میں تبدیل ہوتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ اسٹرنگ کو \"ہیلو ورلڈ\" کو اونٹ کیس میں تبدیل کرتا ہے: جاوا اسکرپٹکونسٹ ایس ٹی آر = \"ہیلو ورلڈ\" cont const comelcasestr = tocamelcase (str) ؛ کنسول.لاگ (کیمیلکیسٹر)؛ یہ \"ہیلوورلڈ\" کو آؤٹ پٹ کرے گا۔ ایک باقاعدہ اظہار اور تبدیلی () طریقہ استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن ٹوکیملیس (str) {ریٹرن str.replace (/[-_ \\ s]+(.)؟/g ، (_ ، c)=> c؟ c.touppercase (): '') ؛} یہ فنکشن ان پٹ کے طور پر تار لیتا ہے اور اونٹ کے معاملے میں تار کو لوٹاتا ہے۔فنکشن کسی بھی ہائفنز ، انڈر سکورز ، یا تار میں خالی جگہوں سے ملنے کے لئے باقاعدہ اظہار کا استعمال کرتا ہے اور ان کی جگہ خالی تار کی جگہ لے لیتا ہے۔اس کے بعد فنکشن ہر بعد کے لفظ کے پہلے خط کو بڑے میں تبدیل کرنے کے لئے کال بیک فنکشن کے ساتھ تبدیل () طریقہ استعمال کرتا ہے۔کال بیک فنکشن دو دلائل لیتا ہے: مماثل سبسٹرنگ اور پہلا کیپنگ گروپ (جو اس کے بعد کے لفظ کا پہلا خط ہے)۔اگر گرفتاری گروپ کی تعریف کی گئی ہے تو ، فنکشن کیپچرنگ گروپ کے بڑے ورژن کو لوٹاتا ہے۔بصورت دیگر ، فنکشن ایک خالی سٹرنگ 34 کو لوٹاتا ہے۔\"ہیلوورلڈ\" کو آؤٹ پٹ کریں گے۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ تار کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ کسی دیئے گئے تار کو اونٹ کے معاملے میں تبدیل کرنے کے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے نمبر ایک پالندرووم ہے۔",
        "Answer": "جاوا اسکرپٹ میں دیئے گئے نمبر ایک پیلنڈرووم ہے یا نہیں ، اس بات کو حاصل کرنے کے بہت سارے طریقے ہیں۔تلاش کے نتائج کی بنیاد پر کچھ ممکنہ نفاذ یہ ہیں: نمبر کے ہندسوں کا موازنہ کرنے کے لئے ایک لوپ کا استعمال: جاوا اسکرپٹ فنکشن ispalindrome (num) {const str = num.tostring () ؛const n = str.length ؛کے لئے (آئیے i = 0 ؛ i <n / 2 ؛ i ++) {اگر (str [i]! == str [n - 1 - i]) {غلط لوٹ ؛true} سچ کی واپسی ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اگر یہ نمبر پیلنڈرووم ہے اور غلط ہے تو وہ سچ ہے۔فنکشن پہلے ان پٹ نمبر کو ٹاسٹرنگ () طریقہ کار کا استعمال کرتے ہوئے اسٹرنگ میں تبدیل کرتا ہے۔اس کے بعد فنکشن تار کے بائیں اور دائیں اطراف سے نمبر کے ہندسوں کا موازنہ کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔اگر ہندسوں کا کوئی جوڑا مماثل نہیں ہے تو ، فنکشن غلط لوٹتا ہے۔اگر ہندسوں کے تمام جوڑے ملتے ہیں تو ، فنکشن درست 12.سچ (ریورس () طریقہ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن ispalindrome (num) {const str = num.tostring () ؛Const relusedstr = str.split (''). ریورس (). شامل ہوں ('') ؛واپسی str === الٹ سیسٹر ؛ this یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اگر یہ نمبر پیلنڈرووم ہے اور غلط ہے تو وہ سچ ہے۔فنکشن پہلے ان پٹ نمبر کو ٹاسٹرنگ () طریقہ کار کا استعمال کرتے ہوئے اسٹرنگ میں تبدیل کرتا ہے۔اس کے بعد فنکشن اسپلٹ () ، ریورس () ، اور جوائن () طریقوں کا استعمال کرتے ہوئے سٹرنگ کو تبدیل کرتا ہے۔اس کے بعد فنکشن اصل تار کا موازنہ الٹ سٹرنگ کے ساتھ کرتا ہے اور اگر وہ مساوی اور غلط ہیں تو 34.کنسول.لاگ (ispal) ؛ یہ سچ ثابت ہوگا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ نمبر کسی نمبر کے استعمال سے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نمبر نافذ کیا جاتا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ یہ چیک کرنے کے بنیادی طریقے مہیا کرتے ہیں کہ آیا کوئی دی گئی تعداد ایک پیلینڈرووم ہے ، تو اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں عددیوں کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی تعداد کو تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: طویل عرصے تک بڑھتے ہوئے متضاد کی لمبائی کو تلاش کرنے کے لئے متحرک پروگرامنگ کا استعمال: جاوا اسکرپٹ فنکشن طویل عرصے سے متعلقہ تعی .ن (ARR) {const n = arr.length ؛کانسٹ ڈی پی = نئی سرنی (این). فل (1) ؛آئیے میکسلن = 1 ؛کے لئے (i = 1 ؛ i <n ؛ i ++) {for (j = 0 ؛ j <i ؛ j ++) {if (arr [i]> arr [j]) {dp [i] = math.max (ڈی پی [i] ، dp [j] + 1) ؛میکسلن = ریاضی۔ میکس (میکسلن ، ڈی پی [i]) ؛}}} میکسلن کی واپسی}} یہ فنکشن ان پٹ کے طور پر ایک صف لیتا ہے اور صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کی لمبائی کو لوٹاتا ہے۔فنکشن طویل عرصے تک بڑھتے ہوئے حصول کی لمبائی کو تلاش کرنے کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے۔فنکشن سب سے پہلے اسی سائز کے ایک سرنی ڈی پی کو شروع کرتا ہے جس طرح ان پٹ سرنی تمام 1s پر ہوتا ہے۔اس کے بعد فنکشن ان پٹ سرنی میں عناصر کے ہر جوڑے پر تکرار کے لئے دو لوپ کا استعمال کرتا ہے۔عناصر کے ہر جوڑے کے ل the ، فنکشن چیک کرتا ہے کہ آیا دوسرا عنصر پہلے عنصر سے زیادہ ہے۔اگر یہ ہے تو ، فنکشن دوسرے عنصر کے انڈیکس میں ڈی پی سرنی میں قیمت کو اپنی موجودہ قیمت کی زیادہ سے زیادہ اور پہلے عنصر کے انڈیکس میں ڈی پی سرنی کی قیمت کو اپ ڈیٹ کرتا ہے۔ فنکشن میکسلن کو بھی اپ ڈیٹ کرتا ہے۔اس کی موجودہ قیمت کی زیادہ سے زیادہ اور دوسرے عنصر کے اشاریہ پر ڈی پی سرنی کی قدر میں متغیر۔اس کے بعد فنکشن میکسلن متغیر 123 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ میں صف میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کی لمبائی [4] [2] [1]: جاوا اسکرپٹکونسٹ آر آر = [3 ، 10 ، 2 ، 1 ، 20] ؛کانسٹ لین = لانگ اسٹین کریزنگس بی آر ایس سیوینس (اے آر آر) ؛ کنسول.لوگ (لین) ؛ اس کی پیداوار 3. بائنری تلاش کا استعمال کرتے ہوئے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے: جاوا اسکرپٹ فنکشن طویل ترین انکریسنگسوبسینس (اے آر آر) {کانسٹ این = آر آر ایلتھ ؛کینٹ ٹیلس = نئی سرنی (این) ؛لین = 0 ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {بائیں = 0 ؛چلو دائیں = لین ؛جبکہ (بائیں <دائیں) {const MID = math.floor ((بائیں + دائیں) / 2) ؛اگر (دم [درمیانی] <arr [i]) {بائیں = وسط + 1 ؛} دوسری {دائیں = وسط ؛}} دم [بائیں] = arr [i] ؛اگر (بائیں === لین) {لین ++ ؛}} ریٹرن لین ؛} یہ فنکشن ان پٹ کے طور پر ایک صف لیتا ہے اور صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کی لمبائی کو لوٹاتا ہے۔فنکشن طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے بائنری تلاش کا استعمال کرتا ہے۔فنکشن سب سے پہلے سائز N کی ایک سرنی دم کو تمام 0s میں شروع کرتا ہے اور متغیر لین کو 0 پر شروع کرتا ہے۔ پھر فنکشن ان پٹ سرنی میں ہر عنصر پر لوپ کا استعمال کرتے ہوئے تکرار کرتا ہے اور بائنری سرچ استعمال کرتا ہے تاکہ میں میں پہلے عنصر کا انڈیکس تلاش کیا جاسکے۔دم کی صف جو موجودہ عنصر سے زیادہ یا اس کے برابر ہے۔اس کے بعد فنکشن پائے جانے والے عنصر کے اشاریہ پر دم کی صف میں قیمت کو موجودہ عنصر میں اپ ڈیٹ کرتا ہے۔اگر پائے جانے والے عنصر کا انڈیکس لین کے برابر ہے تو ، فنکشن میں اضافہ ہوتا ہے۔اس کے بعد فنکشن LEN56 لوٹتا ہے۔= طویل عرصے سے متعلقہ تعبیر (اے آر آر) ؛ کنسول.لوگ (لین) ؛ اس کی پیداوار 3 ہوگی۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور یہ کہ سرنی کو عددیوں کی ایک صف کا استعمال کرتے ہوئے نافذ کیا گیا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ عدد کی ایک مخصوص صف میں طویل ترین بڑھتی ہوئی کامیابی کو تلاش کرنے کے لئے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو گراف ڈیٹا ڈھانچے کی نمائندگی کرے۔چوڑائی کے لئے پہلے اور گہرائی سے پہلے ٹراورسل کے طریقوں کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ کلاس برائے گراف ڈیٹا سٹرکچرٹو ایک جاوا اسکرپٹ کلاس بنائیں جو گراف ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس گراف {کنسٹرکٹر () {this.vertices = [] ؛this.edges = {} ؛} ایڈورٹیکس (ورٹیکس) {this.vertices.push (ورٹیکس) ؛this.edges [vertex] = [] ؛} ایڈجڈ (ورٹیکس 1 ، ورٹیکس 2) {this.edges [vertex1] .push (vertex2) ؛this.edges [vertex2] .push (vertex1) ؛} بریڈھفیرسٹ ٹراورسال (اسٹارٹورٹیکس) {کانسٹ قطار = [شروع کرنے والے جہاز] ؛کنسٹ ملاحظہ کریں = {} ؛ملاحظہ کیا [شروع کرنے والا] = سچ ؛کانسٹنگ نتیجہ = [] ؛جبکہ (قطار۔ لمبائی) {موجودہ موجودہورٹیکس = قطار۔ شفٹ () ؛نتیجہ۔ پش (کرنٹورٹیکس) ؛this.edges [کرنٹورٹیکس] .foreach ((پڑوسی) => {اگر (! ملاحظہ کیا [پڑوسی]) {ملاحظہ کیا [پڑوسی] = سچ ؛ قطار۔ پش (پڑوسی) ؛}}) ؛} واپسی کا نتیجہ ؛} ڈیپتھفیرسٹ ٹراورسال (اسٹارٹورٹیکس) {کنسٹٹ ملاحظہ = {} ؛کانسٹنگ نتیجہ = [] ؛کانسٹ ڈی ایف ایس = (ورٹیکس) => {ملاحظہ کیا [ورٹیکس] = سچ ؛نتیجہ۔ پش (ورٹیکس) ؛this.edges [vertex] .foreach ((پڑوسی) => {اگر (! ملاحظہ کیا [پڑوسی]) {dfs (پڑوسی) ؛}}) ؛} ؛ڈی ایف ایس (اسٹارٹورٹیکس) ؛واپسی کا نتیجہ ؛}} یہ کلاس گراف ڈیٹا کے ڈھانچے کی نمائندگی کرتی ہے جس میں عمودی اور کناروں کو شامل کرنے کے طریقوں کے ساتھ ، اور چوڑائی کا پہلا اور گہرائی کا پہلا ٹراورسل انجام دیا جاتا ہے۔کلاس میں ایک کنسٹرکٹر ہے جو عمودی کی خالی صف اور کناروں کی خالی چیز کو شروع کرتا ہے۔ایڈورٹیکس () کا طریقہ کار گراف میں عمودی سرنی پر دھکیل کر اور چابی کے طور پر ورٹیکس کے ساتھ کناروں کے آبجیکٹ میں خالی صف شامل کرکے ایک عمودی کو شامل کرتا ہے۔ایڈج () کا طریقہ دو حصوں کے مابین ایک غیر ہدایت شدہ کنارے کو کناروں کے آبجیکٹ میں دوسرے کے سرے پر دھکیل کر ایک غیر ہدایت شدہ کنارے کا اضافہ کرتا ہے۔بریڈتھفیرسٹ ٹراورسال () کا طریقہ کار ایک قطار کا استعمال کرکے کسی دیئے گئے ورٹیکس کو تلاش کرنے کے لئے ایک قطار کا استعمال کرتے ہوئے اور دورے والے عمودیوں سے باخبر رہنے کے ل a ایک ملاحظہ کرنے والی شے کا استعمال کرتے ہوئے چوڑائی کا پہلا ٹراورسل انجام دیتا ہے۔اس طریقہ کار سے ملاحظہ کی گئی ترتیب کی ایک صف لوٹتی ہے جس کے وہ دورے ہوئے تھے۔ڈیپتھفیرسٹ ٹراورسال () طریقہ کار گراف میں موجود تمام عمودیوں کو دیکھنے کے لئے تکرار کا استعمال کرکے کسی دیئے گئے ورٹیکس سے شروع ہونے والی گہرائی کا پہلا ٹراورسل انجام دیتا ہے۔طریقہ کار میں ملاحظہ کی گئی ترتیب کی ایک صف کو لوٹاتا ہے جس کا ان کا دورہ کیا گیا تھا۔.addvertex ('a') ؛ گراف.اڈورٹیکس ('بی') ؛ گراف.اڈورٹیکس ('سی') ؛ گراف.اڈورٹیکس ('ڈی') ؛ گراف.اڈیج ('اے' ، 'بی') ؛ گراف۔ایڈج ('بی' ، 'سی') ؛ گراف.اڈیج ('سی' ، 'ڈی') ؛ گراف.ڈیجڈج ('ڈی' ، 'اے') ؛ کونٹ بی ایف ایس آر ایسولٹ = گراف۔ بریڈ فیرسٹ ٹراورسال ('اے') ؛ کنسول.log (bfsresult) ؛// ['a' ، 'b' ، 'd' ، 'c'] const dfsresult = گراف.ڈیپٹفیرسٹ ٹراورسال ('a') ؛ کنسول.لاگ (dfsresult) ؛// ['a' ، 'b' ، 'c' ، 'd'] اس کی پیداوار ['a' ، 'b' ، 'd' ، 'c'] کے لئے چوڑائی سے پہلے ٹراورسل اور ['a' ،گہرائی سے پہلے ٹراورسال کے لئے 'بی' ، 'سی' ، 'ڈی'] نوٹ کریں کہ یہ نفاذ گراف ڈیٹا ڈھانچہ بنانے اور وسعت کے پہلے اور گہرائی سے پہلے کی حد تک انجام دینے کا ایک بنیادی طریقہ فراہم کرتا ہے۔اس میں مزید اعلی درجے کی نفاذیں ہیں جو استعمال کے مخصوص معاملات کے ل more زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ میں غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے ل this ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ترتیب () کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن Kthlarustelement (arr ، k) {arr.sort ((a ، b) => b - a) ؛واپسی ARR [K - 1] ؛} اس فنکشن میں ان پٹ کے طور پر ایک صف اور ایک نمبر K لیتا ہے اور صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو لوٹاتا ہے۔فنکشن پہلے موازنہ فنکشن کے ساتھ ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے نزول ترتیب میں ان پٹ سرنی کو ترتیب دیتا ہے۔اس کے بعد فنکشن ترتیب شدہ اری 12 میں کے ٹی ایچ ایل عنصر کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ میں صف میں تیسرا سب سے بڑا عنصر ملتا ہے [3] [2] [1] [5] [6] [6]: جاوا اسکرپٹکونسٹ آر آر = [3.) {const swap = (arr ، i ، j) => {[arr [i] ، arr [j]] = [arr [j] ، arr [i]] ؛} ؛const پارٹیشن = (arr ، بائیں ، دائیں) => {const pivot = arr [دائیں] ؛i = بائیں ؛کے لئے (j = بائیں ؛ j <دائیں ؛ j ++) {if (arr [j] <pivot) {تبادلہ (arr ، i ، j) ؛i ++ ؛}} تبادلہ (arr ، i ، دائیں) ؛واپسی i ؛} ؛منتخب کریں = (آر آر ، بائیں ، دائیں ، کے) => {اگر (بائیں === دائیں) {واپس آر ہی [بائیں] ؛} const pivotindex = تقسیم (ARR ، بائیں ، دائیں) ؛if (k === pivotindex) {واپسی arr [k] ؛} دوسری صورت میں اگر (k <pivotindex) {واپس منتخب کریں (Arr ، بائیں ، Pivotindex - 1 ، k) ؛} دوسری {واپسی منتخب کریں (ARR ، PIVOTINDEX + 1 ، دائیں ، K) ؛}} ؛واپسی کا انتخاب کریں (ARR ، 0 ، Arr.length - 1 ، Arr.length - K) ؛} اس فنکشن میں ایک سرنی اور ایک نمبر K لیتا ہے اور ان پٹ کے طور پر KTH کا سب سے بڑا عنصر واپس کرتا ہے۔فنکشن کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے کوئیک سلیکٹ الگورتھم کا استعمال کرتا ہے۔فنکشن پہلے صف میں دو عناصر کو تبدیل کرنے کے لئے تبادلہ () فنکشن کی وضاحت کرتا ہے۔اس کے بعد فنکشن محور عنصر کے ارد گرد صف کو تقسیم کرنے کے لئے ایک پارٹیشن () فنکشن کی وضاحت کرتا ہے۔اس کے بعد فنکشن پارٹیشن () فنکشن کا استعمال کرتے ہوئے سرے میں کے ٹی ایچ کے سب سے بڑے عنصر کو بار بار منتخب کرنے کے لئے ایک سلیکٹ () فنکشن کی وضاحت کرتا ہے۔اس کے بعد فنکشن آرنی 34 میں کے ٹی ایچ کے سب سے چھوٹے انڈیکس کے ساتھ منتخب () پر کال کرکے کے ٹی ایچ کے سب سے بڑے عنصر کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کو صف میں تیسرا سب سے بڑا عنصر مل جاتا ہے [3] [2] [1] [1] [5] [6] []]: جاوا اسکرپٹ کنسٹ آر آر = [3 ، 2 ، 1 ، 5 ، 6 ، 4] const کانسٹر کے = 3 ؛ کنٹلارسٹ = kthlarustelement (arr ، k) ؛ کنسول.لاگ (kthlargest) ؛ یہ پیداوار 4. نوٹ کریں گے۔یہ کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ سرنی کو عدد کی ایک صف کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ اگرچہ یہ نفاذ غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے بنیادی طریقے مہیا کرتے ہیں ، لیکن اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "الفاظ کی ترتیب کو الٹ کرنے اور ہر کردار کے معاملے کو کسی مقررہ جملے میں رکھنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "الفاظ کی ترتیب کو الٹا کرنے اور جاوا اسکرپٹ میں دیئے گئے جملے میں ہر کردار کے معاملے کو برقرار رکھنے کے ل this ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہاں ہیں: اسپلٹ () ، ریورس () ، اور شامل () طریقوں کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن ریورس ورڈز (جملہ) {واپس جملہ۔ورڈ) => ورڈ.سپلٹ (''). ریورس (). شامل ہوں (''))ہر کردار کو محفوظ کیا گیا ہے۔فنکشن سب سے پہلے ان پٹ جملہ کو اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتا ہے۔اس کے بعد فنکشن ریورس () طریقہ کار کا استعمال کرتے ہوئے صف میں الفاظ کے ترتیب کو تبدیل کرتا ہے۔اس کے بعد فنکشن نقشہ () کا طریقہ استعمال کرتا ہے تاکہ وہ صف میں ہر لفظ پر تکرار کرے اور اسپلٹ () ، ریورس () ، اور شامل () طریقوں کا استعمال کرتے ہوئے لفظ میں حروف کی ترتیب کو الٹا کردے۔اس کے بعد فنکشن میں شامل () کے طریقہ کار کا استعمال کرتے ہوئے الفاظ کو ایک تار میں شامل کیا جاتا ہے۔فنکشن الٹ جملے 12 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ الفاظ کی ترتیب کو تبدیل کرتا ہے اور ہر کردار کے معاملے کو \"ہیلو ورلڈ\" کے جملے میں رکھتا ہے: جاوا اسکرپٹکونسٹ جملہ = \"ہیلو ورلڈ\" ؛ کانسٹ الٹ الٹینسیٹنس = ریورسورڈس (جملے) ؛ کنسول.log (الٹ سیسنٹنس) ؛ یہ \"ڈلرو اولیہ\" کو آؤٹ پٹ کرے گا۔ الفاظ کی ترتیب اور ایک اور لوپ کو ہر لفظ میں حرفوں کی ترتیب کو پلٹانے کے لئے ایک لوپ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن ریورسورڈس (جملہ) {الٹ سنٹینس = '' ؛الٹ ورڈ = '' ؛کے لئے (آئیے i = جملہ۔ لمبائی-1 ؛ i> = 0 ؛ i--) {اگر (جملہ [i] === '') {الٹ سنٹیننس + = الٹ ورڈ + '' ؛الٹ ورڈ = '' ؛} دوسری {الٹ ورڈ = جملہ [i] + الٹ ورڈ ؛}} الٹ سنٹینس += الٹ ورڈ ؛واپس الٹ سنٹینس۔ اسپلٹ (''). میپ ((لفظ) => ورڈ.سپلٹ ('')الفاظ کے آرڈر کے ساتھ جملے کو لوٹاتا ہے اور ہر کردار کے محفوظ ہونے کے معاملے کو محفوظ کیا جاتا ہے۔فنکشن سب سے پہلے خالی تار کے الٹ سنسنی اور خالی سٹرنگ الٹ ورڈ ورڈ کی وضاحت کرتا ہے۔اس کے بعد فنکشن ان پٹ جملے میں ہر کردار کو دائیں سے بائیں تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔اگر موجودہ کردار ایک جگہ ہے تو ، فنکشن الٹ جملے میں الٹ کلام کو شامل کرتا ہے اور الٹ کلام کو خالی تار میں دوبارہ سیٹ کرتا ہے۔بصورت دیگر ، فنکشن الٹ کلام کے آغاز میں موجودہ کردار کو شامل کرتا ہے۔اس کے بعد فنکشن الٹ جملے میں آخری الٹ کلام شامل کرتا ہے۔اس کے بعد فنکشن اسپلٹ () ، نقشہ () ، اور اس میں شامل () طریقوں کا استعمال کرتا ہے تاکہ الٹ جملے میں ہر لفظ میں حروف کی ترتیب کو پلٹ سکے۔اس کے بعد فنکشن الٹ جملے 34 کو لوٹاتا ہے۔کنسول.لاگ (الٹ سنسنیشن) ؛ اس سے \"ڈلرو اولیہ\" آؤٹ پٹ ہوگا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ جملے کو اسٹرنگ کا استعمال کرتے ہوئے نافذ کیا گیا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے جملہ نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ الفاظ کی ترتیب کو پلٹانے اور ہر کردار کے معاملے کو کسی مقررہ جملے میں رکھنے کے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ کا فنکشن بنائیں کہ آیا دیئے گئے اسٹرنگ ایک درست یو آر ایل ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دی دی گئی تار جاوا اسکرپٹ میں ایک درست یو آر ایل ہے ، اس کو حاصل کرنے کے بہت سے طریقے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: یو آر ایل کنسٹرکٹر کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن isvalidurl (url) {کوشش کریں {نیا URL (URL) ؛واپس سچ ؛} کیچ (غلطی) {جھوٹی لوٹ ؛}} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر سٹرنگ ایک درست URL اور غلط ہے تو سچائی واپس آجاتا ہے۔فنکشن ان پٹ سٹرنگ کے ساتھ ایک نیا یو آر ایل آبجیکٹ بنانے کے لئے یو آر ایل کنسٹرکٹر کا استعمال کرتا ہے۔اگر ان پٹ سٹرنگ ایک درست یو آر ایل نہیں ہے تو ، یو آر ایل کنسٹرکٹر ایک غلطی پھینک دے گا ، جسے فنکشن پکڑتا ہے اور غلط لوٹاتا ہے۔بصورت دیگر ، فنکشن درست لوٹتا ہے۔= isvalidurl (url) ؛ کنسول.لوگ (isvalid) ؛ یہ سچ ثابت ہوگا۔ باقاعدہ اظہار کا استعمال کرتے ہوئے: جاوا اسکرپٹ فکشن isvalidurl (url) {const pattern =/^ (ftp | http | https): \\/\\/[^ \"]+$/؛ ریٹرن پیٹرن۔ ٹیسٹ (یو آر ایل) ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر سٹرنگ ایک درست یو آر ایل اور غلط ہے تو اس کو درست کرتا ہے۔اگر تار ftp: // ، http: // ، یا https: // کے ساتھ شروع ہوتا ہے اور اس میں کوئی جگہ یا قیمت نہیں ہوتی ہے۔ اگر ان پٹ سٹرنگ پیٹرن سے مماثل ہے اور غلط ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈاگر سٹرنگ \"https://www.google.com\" ایک درست url ہے: جاوا اسکرپٹ کونسٹ url = \"https://www.google.com\" ؛ const isvalid = isvalidurl (url) ؛ کنسول.لوگ (isvalid) ؛اس سے یہ بات درست ہوگی۔ نوٹ کریں کہ یہ نفاذ یہ چیک کرنے کے بنیادی طریقے مہیا کرتے ہیں کہ آیا دی دیئے گئے تار جاوا اسکرپٹ میں ایک درست یو آر ایل ہے یا نہیں ، لیکن اس سے زیادہ نفاذ موجود ہیں جو استعمال کے مخصوص معاملات کے ل more زیادہ موزوں ہوسکتے ہیں۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ ان پر عمل درآمد سے تمام ممکنہ درست یو آر ایل فارمیٹس کا احاطہ نہیں کیا جاسکتا ہے اور وہ بدنیتی پر مبنی ان پٹ کے خلاف فول پروف نہیں ہوسکتے ہیں۔"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کے وسط کو تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو ترتیب دیئے گئے ارای اسٹو کے میڈین کو تلاش کرنے کے لئے کام جاوا اسکرپٹ میں دو ترتیب شدہ صفوں کے میڈین کو تلاش کریں ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج کی بنیاد پر کچھ ممکنہ نفاذ یہ ہیں: ترتیب () طریقہ استعمال کرنا: جاوا اسکرپٹ فینکشن فائنڈ میڈیمورٹری (Nums1 ، nums2) {Cont wersed = nums1.concat (nums2) .Sort (a ، b) => a - b)؛const n = ضم شدہ۔ لمبائی ؛اگر (n ٪ 2 === 0) {واپسی (ضم شدہ [n / 2 - 1] + ضم شدہ [n / 2]) / 2 ؛} دوسری {واپسی ضم شدہ [(n - 1) / 2] ؛}} یہ فنکشن ان پٹ کے طور پر دو ترتیب شدہ صفوں کو لیتا ہے اور انضمام شدہ ترتیب شدہ صف کے وسط کو واپس کرتا ہے۔فنکشن سب سے پہلے کونکیٹ () کے طریقہ کار کا استعمال کرتے ہوئے دو ان پٹ صفوں کو ہم آہنگ کرتا ہے اور موازنہ فنکشن کے ساتھ ترتیب () کے طریقہ کار کا استعمال کرتے ہوئے چڑھنے والے ترتیب میں نتیجے میں ہونے والی صف کو ترتیب دیتا ہے۔اس کے بعد فنکشن انضمام شدہ صف کی لمبائی کا حساب لگاتا ہے اور اگر یہ بھی عجیب ہے تو چیک کرتا ہے۔اگر یہ بھی ہے تو ، فنکشن ضم شدہ صف میں دو درمیانی عناصر کی اوسط لوٹاتا ہے۔اگر یہ عجیب ہے تو ، فنکشن درمیانی عنصر کو ضم شدہ سرنی 12 میں لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ میں دو ترتیب دیئے گئے صفوں کا درمیانی [3] [1] [4] اور [5] [2] [6]:جاواسکرپٹکونسٹ نمبر 1 = [1 ، 2 ، 3] const Const nums2 = [4 ، 5 ، 6] const const میڈین = فائنڈ میڈیمورٹریڈریز (nums1 ، nums2) ؛ کنسول.لاگ (میڈین) ؛ یہ بائنری تلاش کا استعمال کرتے ہوئے 3.5.findmediansortedarrays (nums1 ، nums2) {const n1 = nums1.length ؛Const n2 = nums2.length ؛اگر (n1> n2) {findmediansortedarrays (nums2 ، nums1) واپس کریں ؛let lo = 0 ؛آئیے ہائے = n1 ؛جبکہ (LO <= HI) {CONST پارٹیشن ایکس = (لو + ہائے) >> 1 ؛const پارٹیشن = ((n1 + n2 + 1) >> 1) - پارٹیشنکس ؛کانسٹ میکسلفٹیکس = پارٹیشن ایکس === 0؟-infinity: nums1 [پارٹیشنیکس - 1] ؛کانسٹ مائنرائٹیکس = پارٹیشن ایکس === این 1؟انفینٹی: نمبر 1 [پارٹیشنیکس] ؛کانسٹ میکسلیفٹی = پارٹیشن === 0؟-انفینیٹی: نمبر 2 [پارٹیشن - 1] ؛کانسٹ مائنریٹی = پارٹیشن === این 2؟انفینٹی: نمبر 2 [پارٹیشن] ؛if (maxleftx <= minrighty && میکسلیفٹی <= minrightx) {اگر ((n1 + n2) ٪ 2 === 0) {واپسی (math.max (maxleftx ، maxlefty) + math.min (minrightx ، minreight)) / 2؛} else {واپس math.max (میکسلیفٹیکس ، میکسلیفٹی) ؛}} دوسری صورت میں اگر (میکسلفٹیکس> مائنرائٹی) {ہائے = پارٹیشن ایکس - 1 ؛} else {lo = partitionx + 1 ؛}}} یہ فنکشن ان پٹ کے طور پر دو ترتیب شدہ صفوں کو لیتا ہے اور انضمام شدہ ترتیب شدہ صف کے وسط کو لوٹاتا ہے۔فنکشن انضمام شدہ ترتیب شدہ صفوں کے وسط کو تلاش کرنے کے لئے بائنری تلاش کا استعمال کرتا ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا پہلی ان پٹ سرنی کی لمبائی دوسرے ان پٹ سرنی کی لمبائی سے زیادہ ہے۔اگر یہ ہے تو ، فنکشن ان پٹ صفوں کو تبدیل کرتا ہے۔اس کے بعد فنکشن بالترتیب دو پوائنٹرز ایل او اور ہائے 0 اور N1 تک شروع کرتا ہے ، جہاں N1 پہلی ان پٹ سرنی کی لمبائی ہے۔اس کے بعد فنکشن پہلی ان پٹ سرنی پر بائنری تلاش کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔لوپ کے ہر تکرار کے ل the ، فنکشن بائنری سرچ الگورتھم کا استعمال کرتے ہوئے پارٹیشن پوائنٹس پارٹیشن ایکس اور پارٹیشن کا حساب لگاتا ہے۔اس کے بعد فنکشن دونوں پارٹیشنوں کے لئے زیادہ سے زیادہ بائیں اور کم سے کم دائیں عناصر کا حساب لگاتا ہے۔اگر پہلی پارٹیشن میں زیادہ سے زیادہ بائیں عنصر دوسرے پارٹیشن میں کم سے کم دائیں عنصر سے کم یا اس کے برابر ہے اور دوسری پارٹیشن میں زیادہ سے زیادہ بائیں عنصر پہلے پارٹیشن میں کم سے کم دائیں عنصر سے کم یا اس کے برابر ہے تو ، فنکشن میں ہے۔ضم شدہ ترتیب شدہ صف کا میڈین ملا۔اگر انضمام شدہ ترتیب شدہ صف کی لمبائی بھی ہو تو ، فنکشن زیادہ سے زیادہ بائیں اور کم سے کم دائیں عناصر کی اوسط کو لوٹاتا ہے۔اگر ضم شدہ ترتیب شدہ صف کی لمبائی عجیب ہے تو ، فنکشن زیادہ سے زیادہ بائیں عنصر کو لوٹاتا ہے۔بصورت دیگر ، فنکشن زیادہ سے زیادہ بائیں عناصر اور کم سے کم دائیں عناصر کی موازنہ کی بنیاد پر پوائنٹرز کو لو اور ہائے کو اپ ڈیٹ کرتا ہے۔"
    },
    {
        "Question": "کسی دیئے گئے تار سے تمام وائٹ اسپیس حروف کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "سٹرنگ سے تمام وائٹ اسپیس حروف کو ہٹانے کے لئے کام کریں ، جاوا اسکرپٹ میں دیئے گئے تار سے تمام وائٹ اسپیس حروف کو ہٹائیں ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہاں ہیں: باقاعدگی سے اظہار کے ساتھ تبدیل () کے طریقہ کار کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن کو ہٹانے والی جگہ (str) {واپسی str.replacچونکہ ان پٹ اور تمام وائٹ اسپیس حروف کو ہٹا کر ایک نیا تار واپس کرتا ہے۔فنکشن ایک باقاعدہ اظہار کے ساتھ تبدیل () طریقہ استعمال کرتا ہے جو کسی بھی وائٹ اسپیس کردار اور عالمی پرچم جی سے مماثل ہوتا ہے تاکہ سفید رنگ کے حروف کی تمام مثالوں کو خالی تار کے ساتھ تبدیل کیا جاسکے۔اس کے بعد فنکشن نئی سٹرنگ 12 کو لوٹاتا ہے۔\"ہیلوورلڈ\" کو آؤٹ پٹ کریں گے۔ اسپلٹ () اور جوائن () طریقوں کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن کو ہٹانے والی جگہ (str) {ریٹرن str.split ('') .join ('') ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور ایک نیا لوٹاتا ہے اور ایک نیا لوٹاتا ہےتمام وائٹ اسپیس حروف کے ساتھ اسٹرنگ کو ہٹا دیا گیا۔فنکشن سب سے پہلے ان پٹ سٹرنگ کو تقسیم کرنے والے کی حیثیت سے خلائی کردار کے ساتھ اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے سبسٹرنگز کی ایک صف میں تقسیم کرتا ہے۔اس کے بعد فنکشن سبسٹرنگز کو ایک خالی تار کے ساتھ جوائن () کے طریقہ کار کا استعمال کرتے ہوئے سٹرنگ میں شامل کرتا ہے۔اس کے بعد فنکشن نئے سٹرنگ 1 کو لوٹاتا ہے۔\"ہیلوورلڈ\" کو آؤٹ پٹ کریں گے۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور سٹرنگ ڈیٹا کی قسم کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ جاوا اسکرپٹ میں دیئے گئے اسٹرنگ سے تمام وائٹ اسپیس کرداروں کو ہٹانے کے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو ترجیحی قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرے۔ترجیح کی بنیاد پر عناصر کو ختم کرنے اور ان کی تزئین و آرائش کے طریقوں کو نافذ کریں۔",
        "Answer": "ترجیحی قطار کے اعداد و شمار کے لئے جاوا اسکرپٹ کلاس ڈھانچہ ایک جاوا اسکرپٹ کلاس بنائیں جو ترجیحی قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے ، ہم مندرجہ ذیل نفاذ کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس کی ترجیحی کیوئو {کنسٹرکٹر () {this.items = [] ؛} enqueue (عنصر ، ترجیح) {const qelement = {عنصر ، ترجیح} ؛آئیے = غلط ہوں ؛کے لئے (آئیے i = 0 ؛ i <this.items.length ؛ i ++) {اگر (this.items [i] .priority> qeelement.priority) {this.items.splice (i ، 0 ، Qelement) ؛پر مشتمل = سچ ؛بریک ؛}} اگر (! پر مشتمل ہے) {this.items.push (qelement) ؛}} dequeue () {if (this.isempty ()) {واپس \"انڈر فلو\" ؛this اس کو واپس کریں۔ آئٹم.شفٹ () ؛} فرنٹ () {اگر (this.isempty ()) {واپس \"قطار میں کوئی عناصر نہیں\" ؛this اس کو واپس کریں۔ آئٹمز [0] ؛} عقبی () {اگر (this.isempty ()) {واپس \"قطار میں کوئی عناصر نہیں\" ؛this اس کو واپس کریں۔ آئٹمز [this.items.length - 1] ؛} isempty () {اس کو لوٹائیں۔ آئٹمز۔ لمبائی === 0 ؛} پرنٹ کیوئ () {let str = \"\" ؛کے لئے (آئیے i = 0 ؛ i <this.items.length ؛ i ++) {str += this.items [i] .element +\"\" ؛} واپس آرہا ؛}} یہ کلاس ترجیحی قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے جس کے طریقوں کے ساتھ ترجیحات کی بنیاد پر عناصر کو تقویت بخشنے اور ان کی تزئین و آرائش کے طریقوں کے ساتھ۔کلاس میں ایک کنسٹرکٹر ہے جو اشیاء کی خالی صف کو شروع کرتا ہے۔انکیو () کا طریقہ اپنی ترجیح کے مطابق قطار میں ایک عنصر کو شامل کرتا ہے۔طریقہ کار عنصر اور ترجیح کے ساتھ خصوصیات کے طور پر ایک نیا آبجیکٹ Qelement تیار کرتا ہے۔اس کے بعد یہ طریقہ قطار میں موجود اشیاء پر تکرار کرتا ہے اور ترجیح کی بنیاد پر نئے عنصر کو صحیح پوزیشن میں داخل کرتا ہے۔ڈی کیو () کا طریقہ قطار سے اعلی ترجیح کے ساتھ عنصر کو ہٹاتا ہے اور واپس کرتا ہے۔سامنے () کا طریقہ کار کو قطار میں اعلی ترجیح کے ساتھ لوٹاتا ہے بغیر اسے ہٹائے۔عقبی () طریقہ کار کو قطار میں کم سے کم ترجیح کے ساتھ لوٹاتا ہے بغیر اسے ہٹائے۔اگر قطار خالی اور غلط ہے تو اگر اس کی جگہ خالی اور غلط ہے۔پرنٹ کیوئ () طریقہ قطار کی ایک تار کی نمائندگی لوٹاتا ہے۔\"، 2) P PQ.enqueue (\" B \"، 1) P PQ.enqueue (\" C \"، 3) ؛ کنسول.لوگ (pq.printqueue ()) ؛// \"b a c\" کنسول.لوگ (pq.dequeue (). عنصر) ؛// \"B\" کنسول.لاگ (pq.dequeue (). عنصر) ؛// \"A\" کنسول.لاگ (pq.dequeue (). عنصر) ؛// \"C\" یہ قطار کی تار کی نمائندگی کے لئے \"B A C\" ، پہلے غیر منقولہ عنصر کے لئے \"B\" ، دوسرے dequeed عنصر کے لئے \"A\" ، اور تیسرے dequeed عنصر کے لئے \"C\" ہوگی۔ نوٹ کریں کہ یہ بات نہیں ہے۔عمل درآمد ترجیحی قطار کے اعداد و شمار کے ڈھانچے اور ترجیح پر مبنی عناصر کو ترجیح دینے اور انکیو اور ڈی کیو عناصر بنانے کا ایک بنیادی طریقہ فراہم کرتا ہے۔مزید اعلی درجے کے نفاذات ہیں جو استعمال کے مخصوص معاملات کے ل more زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "\"ایک دی گئی صف میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں ، جہاں چھوٹا عنصر بڑے عنصر سے پہلے ظاہر ہوتا ہے۔\"",
        "Answer": "جاوا اسکرپٹ پروگرام ایک دیئے گئے ارایوٹو میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے ایک دیئے گئے صف میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کریں ، جہاں چھوٹا عنصر بڑے عنصر سے پہلے ظاہر ہوتا ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ایک لوپ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن میکس ڈفینفینس (اے آر آر) {آئیے میکسڈف = -1 ؛آئیے minelement = arr [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {const const diff = arr [i] - minelement ؛اگر (فرق> میکسڈف) {میکسڈف = فرق ؛} if (arr [i] <minelement) {minelement = arr [i] ؛}} میکس ڈف}}} یہ فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور صف میں دو عناصر کے درمیان زیادہ سے زیادہ فرق لوٹاتا ہے ، جہاں چھوٹا عنصر بڑے عنصر سے پہلے ظاہر ہوتا ہے۔اس فنکشن میں بالترتیب دو متغیر میکسڈف اور مائنلمنٹ -1 اور صف میں پہلا عنصر شروع ہوتا ہے۔اس کے بعد فنکشن سرنی کے اوپر تکرار کرتا ہے اور موجودہ عنصر اور اب تک دیکھنے والے کم سے کم عنصر کے مابین فرق کا حساب لگاتا ہے۔اگر فرق اب تک دیکھنے میں زیادہ سے زیادہ فرق سے زیادہ ہے تو ، فنکشن زیادہ سے زیادہ فرق کو اپ ڈیٹ کرتا ہے۔اگر موجودہ عنصر اب تک دیکھنے والے کم سے کم عنصر سے کم ہے تو ، فنکشن کم سے کم عنصر کو اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن زیادہ سے زیادہ فرق 123 کو لوٹاتا ہے۔2 ، 3 ، 10 ، 2 ، 4 ، 8 ، 1] ؛ کانسٹ میکسڈف = میکس ڈفینس (اے آر آر) ؛ کنسول.لاگ (میکسڈف) ؛ یہ آؤٹ پٹ 8. کم () کا استعمال کرتے ہوئے ()) طریقہ: جاوا اسکرپٹ فینکشن میکس ڈفینفینس (آر آر) {واپسی آر اے آر.reduce ((میکسڈف ، کرنٹ ، انڈیکس ، سرنی) => {const minelement = math.min (... array.slice (0 ، انڈیکس)) ؛ کانسٹ ڈف = کرنٹ - مائنلمنٹ ؛ ریٹرن ڈفیف> میکس ڈف: میکسڈف: میکسڈف: میکسڈف: میکسڈف؛} ، -1) ؛} یہ فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور صف میں دو عناصر کے مابین زیادہ سے زیادہ فرق لوٹاتا ہے ، جہاں چھوٹا عنصر بڑے عنصر سے پہلے ظاہر ہوتا ہے۔فنکشن سرنی کے اوپر تکرار کرنے اور زیادہ سے زیادہ فرق کا حساب لگانے کے لئے کم () طریقہ استعمال کرتا ہے۔صف میں ہر عنصر کے ل the ، فنکشن ریاضی کے مطابق () طریقہ اور سلائس () کے طریقہ کار کا استعمال کرتے ہوئے اب تک دیکھنے والے کم سے کم عنصر کا حساب لگاتا ہے۔اس کے بعد فنکشن موجودہ عنصر اور اب تک دیکھنے والے کم سے کم عنصر کے مابین فرق کا حساب لگاتا ہے۔اگر فرق اب تک دیکھنے میں زیادہ سے زیادہ فرق سے زیادہ ہے تو ، فنکشن فرق کو لوٹاتا ہے۔بصورت دیگر ، فنکشن اب تک دیکھا جانے والا زیادہ سے زیادہ فرق لوٹاتا ہے۔فنکشن زیادہ سے زیادہ فرق کو -114 تک شروع کرتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ میں صف میں دو عناصر کے درمیان زیادہ سے زیادہ فرق پایا جاتا ہے [2]= [2 ، 3 ، 3 ، 10 ، 2 ، 4 ، 8 ، 1] ؛ کانسٹ میکسڈف = میکس ڈفینس (اے آر آر) ؛ کنسول.لوگ (میکسڈف) ؛ یہ آؤٹ پٹ 8. نوٹ کریں گے کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور یہ کہسرنی کو عدد کی ایک صف کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ جاوا اسکرپٹ میں دیئے گئے سرے میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں پہلا گمشدہ مثبت عدد تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "جاوا اسکرپٹ میں غیر ترتیب شدہ صف میں پہلا گمشدہ مثبت عدد تلاش کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ایک لوپ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن فرسٹمیسنگ پیوسٹیو (اے آر آر) {آئیے i = 0 ؛جبکہ (i <arr.length) {if (arr [i]> 0 && arr [i] <= arr.length && arr [arr [i] - 1]! == arr [i]) {const temp = arr[arr [i] - 1] ؛arr [arr [i] - 1] = arr [i] ؛arr [i] = عارضی ؛} else {i ++ ؛}} کے لئے (j = 0 ؛ j <arr.length ؛ j ++) {if (arr [j]! == j + 1) {واپسی j + 1 ؛}} واپسی arr.length + 1 ؛} یہ فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور صف میں سب سے چھوٹا لاپتہ مثبت عدد واپس کرتا ہے۔فنکشن سرنی کے اوپر تکرار کرنے کے لئے ایک لوپ کا استعمال کرتا ہے اور عناصر کو اپنی صحیح پوزیشنوں پر تبدیل کرتا ہے۔فنکشن پہلے جانچ پڑتال کرتا ہے کہ آیا موجودہ عنصر مثبت اور صف کی لمبائی سے کم یا اس کے برابر ہے اور اگر عنصر پہلے سے ہی اس کی صحیح پوزیشن میں نہیں ہے۔اگر عنصر اپنی صحیح پوزیشن میں نہیں ہے تو ، فنکشن عنصر کو عنصر کے ساتھ اپنی صحیح پوزیشن پر تبدیل کرتا ہے۔اس کے بعد فنکشن اگلے عنصر تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن ایک بار پھر صف کے اوپر تکرار کرتا ہے اور پہلا عنصر واپس کرتا ہے جو اس کی صحیح پوزیشن میں نہیں ہے۔اگر تمام عناصر اپنی صحیح پوزیشنوں پر ہیں تو ، فنکشن سرنی کے علاوہ ون 12 کی لمبائی لوٹاتا ہے۔arr = [-1 ، 2 ، 3 ، 0 ، 5] ؛ کانسٹ گمشدہ = فرسٹ میسنگ مثبت (arr) ؛ کنسول.لاگ (گمشدہ) ؛ یہ آؤٹ پٹ 1. سیٹ آبجیکٹ کا استعمال کرے گا: جاوا اسکرپٹ فینکشن فرسٹ ایمیسنگ مثبت (اے آر آر) {کانسٹ سیٹ = نیاسیٹ (آر آر) ؛آئیے i = 1 ؛جبکہ (set.has (i)) {i ++ ؛} واپسی I ؛} یہ فنکشن ان پٹ کے طور پر عددیوں کی ایک صف لیتا ہے اور صف میں سب سے چھوٹا گمشدہ مثبت عددی واپس کرتا ہے۔فنکشن صف میں منفرد عناصر کا ایک سیٹ بنانے کے لئے سیٹ آبجیکٹ کا استعمال کرتا ہے۔اس کے بعد فنکشن ایک متغیر I سے 1 سے شروع کرتا ہے اور سیٹ پر تکرار کرتا ہے جب تک کہ اسے پہلا گمشدہ مثبت عدد نہ مل جائے۔فنکشن پہلا گمشدہ مثبت انٹیجر 45 لوٹتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کو صف میں پہلا گمشدہ مثبت عدد [-1] [1] [2] [3]: جاوا اسکرپٹکونسٹ آر آر = [-1 ، 2 ، 3 ، 0، 5] const کانسٹ لاپتہ = فرسٹ میسنگ مثبت (اے آر آر) ؛ کنسول.لوگ (لاپتہ) ؛ یہ آؤٹ پٹ کرے گا۔ 1. نوٹ کریں کہ یہ نفاذ یہ فرض کرے گا کہ ان پٹ درست ہے اور یہ کہ انٹیجرز کی ایک صف کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے۔اگر ان پٹ درست نہیں ہے یا کسی مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے سرنی کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ جاوا اسکرپٹ میں غیر ترتیب شدہ صف میں پہلے گمشدہ مثبت عدد کو تلاش کرنے کے لئے بنیادی طریقے فراہم کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "کسی دیئے گئے نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے کام جاوا اسکرپٹ میں کسی دیئے گئے نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہاں ہیں: سوئچ کے بیان کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن کنورٹورومن (NUM) {Const Romannumlist = [\"M\" ، \"CM\" ، \"D\" ، \"CD\" ، \"C\" ، \"XC\"، \"l\" ، \"xl\" ، \"x\" ، \"ix\" ، \"v\" ، \"iv\" ، \"i\"] ؛Const decimalnumlist = [1000،900،500،400،100،90،50،40،10،9،5،4،1] ؛آئیے رومانم = \"\" ؛کے لئے (آئیے i = 0 ؛ i <decimalnumlist.length ؛ i ++) {جبکہ (num> = decimalnumlist [i]) {رومانم+= رومانوم لسٹ [i] ؛num -= decimalnumlist [i] ؛}} ریٹرن رومنم ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اس نمبر کی رومن ہندسوں کی نمائندگی واپس کرتا ہے۔اس فنکشن میں دو صفوں کا آغاز کیا گیا ہے جس میں رومنم لسٹ اور اعشاریہ کی فہرست ہے جس میں رومن ہندسے کی علامتیں اور ان کی متعلقہ اعشاریہ اقدار ہیں۔اس کے بعد فنکشن خالی تار رومنم کی ابتدا کرتا ہے۔اس کے بعد فنکشن اعشاریہ کی صفوں کے اوپر تکرار کرتا ہے اور چیک کرتا ہے کہ آیا ان پٹ نمبر موجودہ اعشاریہ قیمت سے زیادہ یا اس کے برابر ہے۔اگر یہ ہے تو ، فنکشن رومانم کے اسی علامت کی علامت کو رومانم تار میں شامل کرتا ہے اور ان پٹ نمبر سے اعشاریہ قدر کو گھٹا دیتا ہے۔اس کے بعد فنکشن اگلی اعشاریہ قدر تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن رومانم سٹرنگ 12 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ نمبر 36 کو رومن ہندسوں میں تبدیل کرتا ہے: جاوا اسکرپٹکونسٹ نمبر = 36 Cont const رومانم = کنورٹورومن (NUM) ؛ کنسول.لوگ (رومانم) ؛ یہ \"xxxvi) پیداوار کرے گا۔\". کسی شے کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن کنورٹورٹورومن (نمبر) {کانسٹ رومانوم لسٹ = {ایم: 1000 ، سینٹی میٹر: 900 ، ڈی: 500 ، سی ڈی: 400 ، سی: 100 ، ایکس سی: 90 ، ایل: 50 ، ایکس ایل: 40 ، ایکس:10 ، ix: 9 ، v: 5 ، iv: 4 ، i: 1} ؛آئیے رومانم = \"\" ؛کے لئے (رومانوم لسٹ میں کلید) {جبکہ (num> = رومانوم لسٹ [کلید]) {رومانم += کلید ؛num -= رومانوم لسٹ [کلید] ؛}} ریٹرن رومنم ؛} یہ فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اس نمبر کی رومن ہندسوں کی نمائندگی واپس کرتا ہے۔فنکشن ایک ایسی شے رومانوم لسٹ کا آغاز کرتا ہے جس میں رومن ہندسوں کی علامتوں کی چابیاں اور ان کی متعلقہ اعشاریہ اقدار کو اقدار کے طور پر شامل کیا جاتا ہے۔اس کے بعد فنکشن خالی تار رومنم کی ابتدا کرتا ہے۔اس کے بعد فنکشن رومنوم لسٹ آبجیکٹ میں چابیاں پر تکرار کرتا ہے اور چیک کرتا ہے کہ اگر ان پٹ نمبر موجودہ اعشاریہ قیمت سے زیادہ یا اس کے برابر ہے۔اگر یہ ہے تو ، فنکشن رومانم کے اسی علامت کی علامت کو رومانم تار میں شامل کرتا ہے اور ان پٹ نمبر سے اعشاریہ قدر کو گھٹا دیتا ہے۔اس کے بعد فنکشن اگلی کلید تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن رومانم سٹرنگ 2 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ نمبر 36 کو رومن ہندسوں میں تبدیل کرتا ہے: جاوا اسکرپٹکونسٹ نمبر = 36 Cont const رومانم = کنورٹورومن (نمبر) ؛ کنسول.لوگ (رومانم) ؛ یہ \"xxxvi) آؤٹ پٹ کرے گا۔\".مجھے یہ کہ ان پر عمل درآمد یہ فرض کریں کہ ان پٹ درست ہے اور نمبر ڈیٹا کی قسم کا استعمال کرتے ہوئے اس نمبر کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے نمبر نافذ کیا جاتا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ جاوا اسکرپٹ میں کسی دیئے گئے نمبر کو رومن ہندسوں میں تبدیل کرنے کے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا کسی دیئے ہوئے تار میں صرف انوکھے حرف ہوتے ہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ کسی دیئے گئے تار میں صرف انوکھا کریکٹرسٹو چیک ہوتا ہے کہ آیا کسی دیئے ہوئے تار میں جاوا اسکرپٹ میں صرف انوکھے حرف ہوتے ہیں ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج کی بنیاد پر کچھ ممکنہ نفاذ یہ ہیں: ایک سیٹ کا استعمال کرتے ہوئے: جاوا اسکرپٹ فکشن ہاسونیکچرس (ایس ٹی آر) {کنسٹ چارسیٹ = نیا سیٹ (ایس ٹی آر) ؛واپس چارسیٹ۔فنکشن ان پٹ سٹرنگ سے ایک سیٹ آبجیکٹ چارسیٹ بناتا ہے ، جو خود بخود نقل کو ہٹاتا ہے۔اس کے بعد فنکشن چیک کرتا ہے کہ آیا سیٹ آبجیکٹ کا سائز ان پٹ سٹرنگ کی لمبائی کے برابر ہے۔اگر وہ برابر ہیں تو ، فنکشن درست لوٹتا ہے۔بصورت دیگر ، فنکشن غلط 12 کو لوٹاتا ہے۔جھوٹے۔i] === str [j]) {جھوٹا لوٹ ؛true}} سچ کی واپسی ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اگر سٹرنگ میں صرف انوکھے کردار اور جھوٹے ہوتے ہیں تو وہ سچ ہوتا ہے۔فنکشن تار میں حروف کے ہر جوڑے کا موازنہ کرنے کے لئے دو گھونسلے والے لوپ کا استعمال کرتا ہے۔اگر فنکشن میں حروف کا ایک جوڑا مل جاتا ہے جو برابر ہوتا ہے تو ، یہ غلط لوٹاتا ہے۔بصورت دیگر ، فنکشن درست 13. مثال کے طور پر ، مندرجہ ذیل کوڈ کی جانچ پڑتال کرتی ہے اگر \"ہیلو\" کے تار میں صرف انوکھے حرف ہوتے ہیں: جاوا اسکرپٹ کونسٹ str = \"ہیلو\" ؛ کانسٹنگ ہاسونیک = ہاسونیکچرس (ایس ٹی آر) ؛ کنسول.لوگ (ہاسونک) ؛ یہ آؤٹ پٹ ہوگی۔غلط۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور سٹرنگ ڈیٹا ٹائپ کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ یہ چیک کرنے کے بنیادی طریقے مہیا کرتے ہیں کہ آیا کسی دیئے گئے تار میں جاوا اسکرپٹ میں صرف انوکھے حرف ہوتے ہیں ، تو اس سے زیادہ اعلی درجے کی نفاذیں موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "کسی دیئے گئے سٹرنگ کے تمام اجازت ناموں کو تیار کرنے کے ل Jav جاوا اسکرپٹ میں دیئے گئے تار کے تمام اجازت نامے پیدا کرنے کے ل we ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: تکرار کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن پرمٹ (ایس ٹی آر) {اگر (str.length <2) {واپسی [str] ؛cont const contrutations = [] ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛باقی بقیہ چیرز = str.slice (0 ، i) + str.slice (i + 1) ؛جزوی طور پر جزو = پرمٹ (بقیہ چاروں) ؛کے لئے (j = 0 ؛ j <جزوی طور پر۔ لمبائی ؛ j ++) {permutations.push (چار+جزوی طور پر [j]) ؛}} واپسی پرمٹیشن ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تار کے ہر ممکنہ اجازت ناموں کی ایک صف کو واپس کرتا ہے۔فنکشن ہر ممکنہ اجازت نامے پیدا کرنے کے لئے تکرار کا استعمال کرتا ہے۔فنکشن پہلے چیک کرتا ہے کہ آیا ان پٹ سٹرنگ کی لمبائی دو سے کم ہے۔اگر یہ ہے تو ، فنکشن ان پٹ سٹرنگ پر مشتمل ایک صف لوٹاتا ہے۔بصورت دیگر ، فنکشن خالی صف کی اجازت دیتا ہے۔اس کے بعد فنکشن ان پٹ سٹرنگ میں حروف پر تکرار کرتا ہے اور بحالی کا استعمال کرتے ہوئے باقی کرداروں کی ہر ممکن ترتیب پیدا کرتا ہے۔اس کے بعد یہ فنکشن ہر جزوی ترتیب کے ساتھ ہر کردار کو جوڑتا ہے اور اس کے نتیجے میں اجازت نامہ کی صف میں شامل کرتا ہے۔اس کے بعد فنکشن اگلے کردار تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن اجازت نامہ آرائی 123 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ \"اے بی سی\" کے تار کے تمام ممکنہ اجازت نامے تیار کرتا ہے: جاوا اسکرپٹ کونسٹ ایس ٹی آر = \"اے بی سی\" ؛ کونٹ پرمٹیشن = پیرمیٹ (ایس ٹی آر) ؛ کنسول.لاگ (پرمٹیشن) ؛اس سے [\"ABC\" ، \"ACB\" ، \"BAC\" ، \"BCA\" ، \"CAB\" ، \"CBA\"] کی پیداوار ہوگی۔کانسٹ اسٹیک = [... str] ؛جبکہ (stack.length) {const Char = stack.pop () ؛const usedchars = permutations.reduce ((acc ، perm) => acc.concat (perm.split (\"\")) ، []) ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {اگر (! usedChars.includes (str [i])) {permutations.push.push (char+str [i]) ؛}} return واپسی کی اجازت ؛} یہ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور تار کے ہر ممکنہ اجازت ناموں کی ایک صف کو واپس کرتا ہے۔فنکشن ہر ممکنہ اجازت نامے پیدا کرنے کے لئے ایک لوپ کا استعمال کرتا ہے۔فنکشن سب سے پہلے ایک خالی سرنی اجازت نامے اور ان پٹ سٹرنگ میں موجود تمام حرفوں پر مشتمل ایک اسٹیک کی ابتدا کرتا ہے۔اس کے بعد یہ فنکشن اسٹیک سے ایک کردار کو پاپ کرتا ہے اور باقی کرداروں کی ہر ممکن اجازت تیار کرتا ہے جو پچھلے اجازت ناموں میں استعمال نہیں ہوئے ہیں۔اس کے بعد فنکشن کردار کو ہر ممکنہ باقی کردار کے ساتھ جوڑتا ہے اور اس کے نتیجے میں اجازت نامہ کی صف میں شامل کرتا ہے۔اس کے بعد فنکشن اسٹیک میں اگلے کردار تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن اجازت نامے کو واپس کرتا ہے۔اس سے [\"ABC\" ، \"ACB\" ، \"BAC\" ، \"BCA\" ، \"CAB\" ، \"CBA\"] آؤٹ پٹ ہوگا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور سٹرنگ ڈیٹا کی قسم کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا جاتا ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ نفاذ کام نہیں کریں گے۔مزید برآں ، یہ نوٹ کرنا ضروری ہے کہ جب یہ نفاذ جاوا اسکرپٹ میں دیئے گئے اسٹرنگ کے تمام اجازت نامے تیار کرنے کے بنیادی طریقے مہیا کرتے ہیں تو ، اس سے زیادہ جدید نفاذات موجود ہیں جو مخصوص استعمال کے معاملات کے لئے زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "\"ایک جاوا اسکرپٹ کلاس بنائیں جو ٹری ڈیٹا ڈھانچے کی نمائندگی کرے۔ الفاظ داخل کرنے ، تلاش کرنے اور حذف کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "جاوا اسکرپٹ کلاس برائے ٹری ڈیٹا سٹرکچرٹو ایک جاوا اسکرپٹ کلاس بنائیں جو ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے ، ہم مندرجہ ذیل عمل کو استعمال کرسکتے ہیں: جاوا اسکرپٹ کلاس ٹرینوڈ {کنسٹرکٹر () {this.children = {} ؛this.end = غلط ؛} سیٹ () {this.end = سچ ؛} isend () {اس کو واپس کریں۔}} کلاس ٹری {کنسٹرکٹر () {this.root = نیا ٹرائینوڈ () ؛} داخل کریں (لفظ) {آئیے نوڈ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {اگر (! نوڈ.چولرین [لفظ [i]]) {نوڈ.کرینین [لفظ [i]] = نیا ٹرائینوڈ () ؛} نوڈ = نوڈ.کرن [لفظ [i]] ؛} node.setend () ؛} تلاش (لفظ) {آئیے نوڈ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {اگر (! نوڈ.چالڈین [لفظ [i]]) {غلط واپس ؛} نوڈ = نوڈ.کرن [لفظ [i]] ؛} نوڈ.ایسینڈ () واپس کریں ؛} اسٹارٹ ویتھ (سابقہ) {آئیے نوڈ = this.root ؛کے لئے (آئیے i = 0 ؛ i <prefix.length ؛ i ++) {اگر (! node.children [سابقہ [i]]) {غلط واپس ؛} نوڈ = نوڈ.کرینین [سابقہ [i]] ؛} سچ واپس ؛} حذف کریں (لفظ) {کونسٹ ڈیلیٹ ہیلپر = (نوڈ ، ورڈ ، انڈیکس) => {if (index === word.length) {if (! node.isend ()) {غلط واپس ؛} نوڈ.سیٹینڈ (غلط) ؛واپسی آبجیکٹ.کیز (نوڈ.کرز). لمبائی === 0 ؛const کنٹ چار = ورڈ [انڈیکس] ؛if (! node.children [چار]) {جھوٹی لوٹ ؛} کونٹ ڈیلیٹینوڈ = ڈیلیٹ ہیلپر (نوڈ.کرز [چار] ، ورڈ ، انڈیکس + 1) ؛if (lasedeletenode) {نوڈ. بچوں کو حذف کریں [چار] ؛واپسی آبجیکٹ.کیز (نوڈ.کرز). لمبائی === 0 ؛} جھوٹی لوٹ ؛} ؛ڈیلیٹ ہیلپر (یہ.روٹ ، لفظ ، 0) ؛}} یہ کلاس ایک ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے جس میں الفاظ داخل کرنے ، تلاش کرنے اور حذف کرنے کے طریقوں کے ساتھ ہیں۔کلاس میں دو گھریلو کلاسیں ٹرائنوڈ اور ٹری ہیں۔ٹرائینوڈ کلاس ٹری میں ایک نوڈ کی نمائندگی کرتی ہے اور اس میں دو پراپرٹیز بچے اور اختتام ہوتے ہیں۔بچوں کی جائیداد ایک ایسی چیز ہے جو بچوں کے نوڈس کے کرداروں کا نقشہ بناتی ہے۔آخری پراپرٹی ایک بولین ہے جو اس بات کی نشاندہی کرتی ہے کہ آیا نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔ٹری کلاس ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے اور اس میں ایک کنسٹرکٹر ہوتا ہے جو روٹ نوڈ کو شروع کرتا ہے۔کلاس میں چار طریقے داخل ، تلاش ، اسٹارٹ ویتھ ، اور حذف کرتے ہیں۔داخل کرنے کا طریقہ لفظ کے کرداروں پر تکرار کرکے اور ضرورت کے مطابق بچوں کے نوڈس بنا کر ایک لفظ کو ٹرائی میں داخل کرتا ہے۔تلاش کا طریقہ کار میں کسی لفظ کی تلاش کرتا ہے جس میں لفظ میں موجود کرداروں پر تکرار کرکے اور یہ جانچ پڑتال کی جاتی ہے کہ آیا اس سے متعلقہ بچے کے نوڈس موجود ہیں یا نہیں۔اسٹارٹ ویتھ کا طریقہ چیک کرتا ہے کہ اگر ٹرائی میں کوئی الفاظ کسی دیئے گئے سابقہ کے ساتھ شروع ہوتے ہیں تو اس سے پہلے کے سابقہ کرداروں پر تکرار کرتے ہوئے اور جانچ پڑتال کرتے ہیں کہ آیا اس سے متعلقہ بچے کے نوڈس موجود ہیں یا نہیں۔حذف کرنے کا طریقہ ٹری سے ایک لفظ کو حذف کرتا ہے جس سے تری کو تقویت بخش کر اور نوڈس کو ضروری 1234 کے طور پر حذف کیا جاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ ایک سہ رخی پیدا کرتا ہے ، الفاظ داخل کرتا ہے ، الفاظ کی تلاش کرتا ہے ، سابقہ کی جانچ پڑتال کرتا ہے ، اور الفاظ کو حذف کرتا ہے() ؛ trie.insert (\"ایپل\") ؛ trie.insert (\"کیلے\") ؛ کنسول.لوگ (trie.search (\"ایپل\")) ؛// trueconsole.log (trie.search (\"کیلے\")) ؛// trueconsole.log (trie.search (\"اورنج\")) ؛// falseconsole.log (trie.startswith (\"app\")) ؛// trueconsole.log (trie.startswith (\"پابندی\")) ؛// trueconsole.log (trie.startswith (\"ora\")) ؛// falsetrie.delete (\"ایپل\") ؛ کنسول.لاگ (trie.search (\"ایپل\")) ؛// فالسیتیس پہلے دو کنسول کے لئے درست ثابت ہوگا۔ لاگ () بیانات ، تیسرے کنسول کے لئے غلط۔) بیان۔ نوٹ کریں کہ یہ عمل درآمد ٹری ڈیٹا ڈھانچہ بنانے اور الفاظ کو داخل کرنے ، تلاش کرنے اور حذف کرنے کا ایک بنیادی طریقہ فراہم کرتا ہے۔اس میں مزید اعلی درجے کی نفاذیں ہیں جو مخصوص استعمال کے معاملات کے ل more زیادہ موزوں ہوسکتی ہیں۔"
    },
    {
        "Question": "زیادہ تر K الگ الگ کرداروں کے ساتھ سب سے طویل تر سٹرنگ تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "جاوا اسکرپٹ پروگرام جس میں زیادہ تر کے الگ الگ الگ الگ الگ الگ الگ الگ الگ الگ الگ الگ الگ کرداروں میں جاوا اسکرپٹ میں دیئے گئے تار میں سب سے طویل عروج تلاش کیا جاتا ہے ، ہم کئی نقطہ نظر استعمال کرسکتے ہیں۔تلاش کے نتائج پر مبنی کچھ ممکنہ نفاذ یہ ہیں: ایک سلائڈنگ ونڈو کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن سب سے طویل عرصے سے سوسٹرنگکڈسٹنٹ (ایس ٹی آر ، کے) {اگر (k === 0) {واپسی \"\" ؛} آئیے شروع کریں = 0 ؛آخری = 0 ؛آئیے میکسبسٹرنگ = \"\" ؛CONST چاراکاؤنٹ = {} ؛جبکہ (اختتام <str.length) {const endchar = str [end] ؛چارکول [اینڈچار] = چارکول [اینڈچار]؟چارہ [اینڈچار] + 1: 1 ؛جبکہ (آبجیکٹ.کیز (چیرکاؤنٹ). لمبائی> K) {کانسٹ اسٹارٹچار = str [start] ؛چارہ [اسٹارٹچار]-؛اگر (چیراکاؤنٹ [اسٹارٹچار] === 0) char چارکاؤنٹ کو حذف کریں [اسٹارٹچار] ؛} اسٹارٹ ++ ؛} if (end - start + 1> maxsubstring.length) {MaxSubstring = str.slice (شروع ، اختتام + 1) ؛} اختتام ++ ؛} میکسبسٹرنگ کی واپسی}} یہ فنکشن ایک تار اور ایک انٹیجر K کو ان پٹ کے طور پر لیتا ہے اور اس تار کی سب سے طویل ترین سبسٹرنگ لوٹاتا ہے جس میں زیادہ تر K الگ الگ حرف ہوتے ہیں۔فنکشن ایک سلائڈنگ ونڈو کا استعمال کرتے ہوئے تار کے اوپر تکرار کرنے اور ونڈو میں ہر کردار کے واقعات کی تعداد کو کسی آبجیکٹ کے چارکاؤنٹ کا استعمال کرتے ہوئے ٹریک کرتا ہے۔فنکشن بالترتیب 0 ، 0 ، اور ایک خالی تار پر تین متغیرات شروع ، اختتام اور میکسبسٹرنگ کا آغاز کرتا ہے۔اس کے بعد فنکشن تار کے اوپر تکرار کرتا ہے اور ہر کردار کو چارکاؤنٹ آبجیکٹ میں شامل کرتا ہے۔اگر ونڈو میں الگ الگ حروف کی تعداد K سے زیادہ ہے تو ، فنکشن اس وقت تک ونڈو کے آغاز سے حروف کو ہٹاتا ہے جب تک کہ الگ الگ حروف کی تعداد K سے کم یا اس کے برابر نہ ہو۔اگر موجودہ سٹرنگ کی لمبائی میکسبسٹرنگ کی لمبائی سے زیادہ ہے تو ، فنکشن میکسبسٹرنگ کو اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن اگلے کردار تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن میکسبسٹرنگ 12 کو لوٹاتا ہے۔ مثال کے طور پر ، مندرجہ ذیل کوڈ کو \"ECEBA\" کے تار میں زیادہ سے زیادہ 2 الگ الگ حروف کے ساتھ سب سے طویل عروج مل جاتا ہے: جاوا اسکرپٹ کونسٹ str = \"eceba\" ؛ Const K = 2 ؛ Const longesubstring = longerestsubstringkdistincstr ، k) ؛ کنسول.لوگ (طویل ترین سوسٹرنگ) ؛ یہ \"ای سی ای\" کو آؤٹ پٹ کرے گا۔ ہیش ٹیبل کا استعمال کرتے ہوئے: جاوا اسکرپٹ فنکشن سب سے طویل عرصے سے سوسٹرنگکڈسٹنٹ (str ، k) {اگر (k === 0) {واپسی \"\" ؛} آئیے شروع کریں = 0 ؛آخری = 0 ؛آئیے میکسبسٹرنگ = \"\" ؛CONST چاراکاؤنٹ = {} ؛آئیے الگ الگ = 0 ؛جبکہ (اختتام <str.length) {const endchar = str [end] ؛اگر (! چارکاؤنٹ [اینڈچار]) {چارکاؤنٹ [اینڈچار] = 0 ؛الگ الگ ++ ؛} چارہ [اینڈچار] ++ ؛جبکہ (الگ الگ اکاؤنٹ> K) {کانسٹ اسٹارٹچار = str [start] ؛چارہ [اسٹارٹچار]-؛اگر (چیراکاؤنٹ [اسٹارٹچار] === 0) {الگ گنتی-- ؛} اسٹارٹ ++ ؛} if (end - start + 1> maxsubstring.length) {MaxSubstring = str.slice (شروع ، اختتام + 1) ؛} اختتام ++ ؛} میکسبسٹرنگ کی واپسی}} یہ فنکشن ایک تار اور ایک انٹیجر K کو ان پٹ کے طور پر لیتا ہے اور اس تار کی سب سے طویل ترین سبسٹرنگ لوٹاتا ہے جس میں زیادہ تر K الگ الگ حرف ہوتے ہیں۔فنکشن ونڈو میں ہر کردار کے واقعات کی تعداد پر نظر رکھنے کے لئے ہیش ٹیبل کا استعمال کرتا ہے۔فنکشن چار متغیرات کی ابتدا کرتا ہے ، بالترتیب 0 ، 0 ، ایک خالی تار ، اور 0 ، بالترتیب 0 ، 0 ، اور 0 سے الگ ہوتا ہے۔اس کے بعد فنکشن تار کے اوپر تکرار کرتا ہے اور ہر کردار کو چارپاؤنٹ آبجیکٹ میں شامل کرتا ہے اور اگر کردار پہلے سے ہی اس چیز میں نہیں ہے تو الگ الگ اکاؤنٹ میں اضافہ کرتا ہے۔اگر ونڈو میں الگ الگ حروف کی تعداد K سے زیادہ ہے تو ، فنکشن اس وقت تک ونڈو کے آغاز سے حروف کو ہٹاتا ہے جب تک کہ الگ الگ حروف کی تعداد K سے کم یا اس کے برابر نہ ہو۔اگر موجودہ سٹرنگ کی لمبائی میکسبسٹرنگ کی لمبائی سے زیادہ ہے تو ، فنکشن میکسبسٹرنگ کو اپ ڈیٹ کرتا ہے۔اس کے بعد فنکشن اگلے کردار تک جاری رہتا ہے۔لوپ کے بعد ، فنکشن میکسبسٹرنگ 3 کو لوٹاتا ہے۔str ، k) ؛ کنسول.لوگ (طویل ترین سوسٹرنگ) ؛ یہ \"ای سی ای\" کو آؤٹ پٹ کرے گا۔ نوٹ کریں کہ یہ نفاذ یہ فرض کرتے ہیں کہ ان پٹ درست ہے اور یہ کہ سٹرنگ ڈیٹا کی قسم کا استعمال کرتے ہوئے سٹرنگ کو نافذ کیا جاتا ہے اور عددی K ایک مثبت عدد ہے۔اگر ان پٹ درست نہیں ہے یا مختلف ڈیٹا ڈھانچے کا استعمال کرتے ہوئے اسٹرنگ کو نافذ کیا گیا ہے تو ، یہ عمل درآمد کام نہیں کرے گا"
    },
    {
        "Question": "جاوا اسکرپٹ",
        "Answer": "جاوا اسکرپٹ ایک پروگرامنگ زبان ہے جو ویب ڈویلپمنٹ 12 میں وسیع پیمانے پر استعمال ہوتی ہے۔یہ ایک ہلکا پھلکا ، تشریح شدہ ، یا صرف وقتی طور پر مرتب شدہ زبان ہے جو ECMAScript Standard32 کے مطابق ہے۔جاوا اسکرپٹ کا استعمال اکثر متحرک طور پر اپ ڈیٹ کرنے والے مواد کو بنانے ، ملٹی میڈیا کو کنٹرول کرنے ، تصاویر کو متحرک کرنے اور ویب پیجز 4 پر پیچیدہ خصوصیات کو نافذ کرنے کے لئے استعمال کیا جاتا ہے۔جاوا اسکرپٹ کو سیکھنے کے لئے کچھ وسائل یہ ہیں: جاوا اسکرپٹ ڈاٹ کام: یہ ویب سائٹ جاوا اسکرپٹ کے ابتدائی افراد کے لئے وسائل اور مثالوں کے ساتھ ساتھ جاوا اسکرپٹ کے ماہرین کی حمایت فراہم کرتی ہے۔یہ آپ کو جاوا اسکرپٹ 5.W3Schools سیکھنے میں مدد کے ل on آن ڈیمانڈ ایونٹس ، کورسز اور راستے بھی پیش کرتا ہے: یہ ویب سائٹ جاوا اسکرپٹ کا ایک جامع ٹیوٹوریل پیش کرتی ہے جس میں جاوا اسکرپٹ کے ہر ورژن کو بنیادی سے لے کر ایڈوانسڈ تک کا احاطہ کیا گیا ہے۔اس میں ہر باب کی مثالیں اور \"خود کوشش کریں\" ایڈیٹر بھی شامل ہیں جہاں آپ ماخذ کوڈ میں ترمیم کرسکتے ہیں اور نتیجہ 1. ایم ڈی این ویب دستاویزات دیکھ سکتے ہیں: یہ ویب سائٹ جاوا اسکرپٹ کی تفصیلی وضاحت فراہم کرتی ہے ، جس میں اس کی بنیادی خصوصیات ، بلڈنگ بلاکس اور اشیاء شامل ہیں۔اس میں کچھ بنیادی سوالات کے جوابات بھی دیئے گئے ہیں جیسے \"جاوا اسکرپٹ کیا ہے؟\" ، \"یہ کس طرح لگتا ہے؟\" ، اور \"یہ کیا کرسکتا ہے؟\" 3. جدید جاوا اسکرپٹ ٹیوٹوریل: یہ ویب سائٹ جاوا اسکرپٹ کی ایک سادہ ، لیکن تفصیلی وضاحت پیش کرتی ہے۔، شروع سے شروع ہوکر اور او او پی جیسے اعلی درجے کے تصورات کی طرف جانا۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں لہرانے کے تصور کی وضاحت کریں اور یہ کہ کس طرح متغیر اور فنکشن اعلانات کو متاثر کرتا ہے۔",
        "Answer": "لہرا دینا جاوا اسکرپٹ میں ایک ایسا طریقہ کار ہے جو متغیرات اور فنکشن کے اعلامیے کو کوڈ کو 123456 پر عمل درآمد کرنے سے پہلے اپنے متعلقہ اسکوپس کے اوپری حصے میں منتقل کرنے کی اجازت دیتا ہے۔اس کا مطلب یہ ہے کہ آپ کسی متغیر یا فنکشن کو اعلان کرنے سے پہلے استعمال کرسکتے ہیں ، لیکن صرف اس صورت میں جب اسے VAR مطلوبہ الفاظ کے ساتھ اعلان کیا جائے۔اگر آپ لیٹ یا کانسٹ کے ساتھ کسی متغیر کا اعلان کرتے ہیں تو ، آپ اس کی قیمت کو کسی قیمت کے ساتھ شروع کرنے سے پہلے اس تک رسائی حاصل نہیں کرسکتے ہیں۔ یہاں کہ کس طرح ہائسٹنگ متغیر اور فنکشن کے اعلامیے کو متاثر کرتی ہے: متغیر اعلامیہ: جب متغیر کو VAR مطلوبہ الفاظ کے ساتھ اعلان کیا جاتا ہے تو ، اسے اوپر سے لہرایا جاتا ہے۔اس کے دائرہ کار کی اور غیر متعینہ قیمت کی قیمت کے ساتھ شروع کیا گیا۔اس کا مطلب یہ ہے کہ آپ متغیر کو اعلان کرنے سے پہلے ہی استعمال کرسکتے ہیں ، لیکن اس کی قیمت اس وقت تک وضاحت کی جائے گی جب تک کہ اس کو بعد میں کوڈ 13456 میں ایک قیمت تفویض نہ کی جائے۔اگر آپ لیٹ یا کانسٹ کے ساتھ کسی متغیر کا اعلان کرتے ہیں تو ، اسے اپنے دائرہ کار کے اوپری حصے میں بھی لہرایا جاتا ہے ، لیکن اس کی ابتدا کسی قدر کے ساتھ نہیں کی جاتی ہے۔اس کا مطلب یہ ہے کہ آپ متغیر کو ویلیو 1 کے ساتھ شروع کرنے سے پہلے استعمال نہیں کرسکتے ہیں۔ فنکشن اعلانات: جب کسی فنکشن کو فنکشن کی ورڈ کے ساتھ اعلان کیا جاتا ہے تو ، اسے اس کے دائرہ کار کے اوپری حصے میں لہرایا جاتا ہے اور اس سے پہلے کہ اس کا اعلان 123456 ہو۔اس کی وجہ یہ ہے کہ اس کا نام اور جسم سمیت سارا فنکشن لہرایا جاتا ہے۔تاہم ، اگر آپ کسی فنکشن کے اظہار کا استعمال کرتے ہوئے کسی فنکشن کا اعلان کرتے ہیں (جیسے Myfunc = فنکشن () {}) ، تو صرف متغیر اعلامیہ لہرایا جاتا ہے ، فنکشن باڈی نہیں۔اس کا مطلب یہ ہے کہ آپ اس فنکشن کو اعلان کرنے سے پہلے استعمال نہیں کرسکتے ہیں۔ خلاصہ میں ، لہرانے سے آپ متغیرات اور افعال کو اعلان کرنے سے پہلے استعمال کرنے کی اجازت دیتے ہیں ، لیکن صرف اس صورت میں جب وہ VAR مطلوبہ الفاظ کے ساتھ اعلان کیا جاتا ہے یا بطور فنکشن اعلانات۔اگر آپ لیٹ یا کانسٹ کے ساتھ کسی متغیر کا اعلان کرتے ہیں ، یا کسی فنکشن کا استعمال کرتے ہوئے کسی فنکشن کے ساتھ ، آپ ان کو شروع کرنے سے پہلے بالترتیب یا اعلان کرنے سے پہلے استعمال نہیں کرسکتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں ڈیٹا کی مختلف اقسام کیا ہیں؟مثالوں کے ساتھ ہر قسم کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ میں ڈیٹا کی مختلف اقسام ہیں جن کو تین اہم اقسام میں تقسیم کیا جاسکتا ہے: قدیم ، جامع اور خصوصی ڈیٹا ٹائپ 12۔جاوا اسکرپٹ میں ڈیٹا کی مختلف اقسام یہ ہیں: قدیم اعداد و شمار کی اقسام: یہ جاوا اسکرپٹ میں ڈیٹا کی بنیادی اقسام ہیں۔ان میں شامل ہیں: سٹرنگ: متنی اعداد و شمار کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے ، جیسے نام ، پتے اور پیغامات۔تار سنگل یا ڈبل قیمتوں یا بیک ٹکس میں بند ہیں۔مثال کے طور پر: \"ہیلو\" ، 'ورلڈ' ، یا `ہیلو ، $ {نام}!`. نمبر: عددی اعداد و شمار کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے ، جس میں عددی ، اعشاریہ اور سائنسی اشارے شامل ہیں۔مثال کے طور پر: 42 ، 3.14 ، یا 1.23E-4.wolean: منطقی اقدار کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے ، یا تو صحیح یا غلط۔مثال کے طور پر: آئیے x ؛ .null: کسی بھی چیز کی قیمت کی جان بوجھ کر عدم موجودگی کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے۔مثال کے طور پر: چلو y = null ؛. symbol: ایک انوکھا شناخت کنندہ کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے۔علامتیں اکثر اشیاء میں چابیاں کے طور پر استعمال ہوتی ہیں۔مثال کے طور پر: کانسٹ سم = علامت ('تفصیل') ؛. بگینٹ: صوابدیدی صحت سے متعلق عدد کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے۔ایک عدد لفظی کے اختتام تک N کو شامل کرکے بڑے پیمانے پر تفریق کی جاتی ہے۔مثال کے طور پر: Const BigInt = 9007199254740991n ؛. کامپوزائٹ ڈیٹا کی اقسام: یہ پیچیدہ اعداد و شمار کی اقسام ہیں جو متعدد اقدار کا انعقاد کرسکتی ہیں۔ان میں شامل ہیں: آبجیکٹ: متعلقہ اعداد و شمار کے ذخیرے کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے۔اشیاء گھوبگھرالی منحنی خطوط وحدانی میں بند ہیں اور کلیدی قدر کے جوڑے پر مشتمل ہیں۔مثال کے طور پر: کانسٹ پرسن = {نام: 'جان' ، عمر: 30} ؛. سرنی: اقدار کے ذخیرے کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے ، جو کسی بھی ڈیٹا کی قسم کا ہوسکتا ہے۔صفیں مربع بریکٹ میں بند ہیں۔مثال کے طور پر: کانسٹ نمبر = [1] [2] [3] [4] [5] ؛. فنکشن: کوڈ کے دوبارہ استعمال کے قابل بلاک کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے جو ایک خاص کام انجام دیتا ہے۔افعال پیرامیٹرز اور واپسی کی اقدار لے سکتے ہیں۔مثال کے طور پر: فنکشن شامل کریں (a ، b) a + b واپس کریں ؛}. خصوصی اعداد و شمار کی اقسام: یہ جاوا اسکرپٹ میں اعداد و شمار کی انوکھی اقسام ہیں۔ان میں شامل ہیں: نان: کسی ایسی قدر کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے جو نمبر نہیں ہے۔مثال کے طور پر: کانسٹنگ نتیجہ = 10 / 'ہیلو' ؛. انفینٹی: کسی ایسی قدر کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے جو کسی بھی دوسرے نمبر سے زیادہ ہے۔مثال کے طور پر: کانسٹ زیادہ سے زیادہ = نمبر۔ میکس_ ویلیو * 2 ؛. خلاصہ میں ، جاوا اسکرپٹ میں آٹھ قدیم اعداد و شمار کی اقسام ، تین جامع ڈیٹا کی اقسام ، اور دو خصوصی ڈیٹا کی اقسام ہیں۔ان اعداد و شمار کی اقسام کو سمجھنا موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں اشیاء کو کس طرح تخلیق اور استعمال کرتے ہیں؟آبجیکٹ تخلیق اور پراپرٹی تک رسائی کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹ میں اشیاء بنانے اور استعمال کرنے کے مختلف طریقے ہیں۔یہاں کچھ مثالیں ہیں: آبجیکٹ کے لفظی نحو کا استعمال کرتے ہوئے اشیاء کی تشکیل: جاوا اسکرپٹ میں کسی شے کو بنانے کا یہ آسان ترین طریقہ ہے۔آپ گھوبگھرالی منحنی خطوط وحدانی {} کا استعمال کرتے ہوئے ایک بیان میں کسی شے کی وضاحت اور تشکیل دے سکتے ہیں۔مثال کے طور پر: کانسٹ پرسن = {نام: 'جان' ، عمر: 30 ، مشغلہ: ['پڑھنا' ، 'کھیل' ، 'کوڈنگ'] ، سلام: فنکشن () {کنسول.لاگ ('سب کو ہیلو۔') ؛} ، اسکور: {ریاضی: 90 ، سائنس: 80}} نئے مطلوبہ الفاظ کا استعمال کرتے ہوئے آبجیکٹ بنانا: آبجیکٹ تخلیق کا یہ طریقہ جیووا کی طرح کلاس پر مبنی زبانوں میں اشیاء کو تخلیق کرنے کے طریقے سے ملتا جلتا ہے۔نئے مطلوبہ الفاظ کا استعمال کرتے ہوئے کسی شے کو بنانے کے ل you ، آپ کو کنسٹرکٹر فنکشن کی ضرورت ہے۔مثال کے طور پر: فنکشن شخص (نام ، عمر) {this.name = نام ؛this.age = عمر ؛this.greet = فنکشن () {کنسول.لوگ ('ہیلو سب۔') ؛} ؛} const پرنٹ 1 = نیا شخص ('جان' ، 30) const const conster2 = نیا شخص ('جین' ، 25) ؛ آبجیکٹ کا استعمال کرتے ہوئے اشیاء بنانا۔پروٹو ٹائپ آبجیکٹ۔مثال کے طور پر: کانسٹ پرسن = {نام: 'جان' ، عمر: 30 ، سلام: فنکشن () {کنسول.لاگ ('ہیلو سب۔') ؛}} ؛ const person1 = اعتراض۔مثال کے طور پر: کنسول.لوگ (شخصی نام) ؛// آؤٹ پٹ: johnconsole.log (شخص ['عمر']) ؛// آؤٹ پٹ: 30in کا خلاصہ ، آپ جاوا اسکرپٹ میں آبجیکٹ لغوی نحو ، نیا مطلوبہ الفاظ ، یا آبجیکٹ کا استعمال کرتے ہوئے اشیاء تشکیل دے سکتے ہیں۔ کریٹ ()۔آپ ڈاٹ اشارے یا بریکٹ اشارے کا استعمال کرتے ہوئے کسی شے کی خصوصیات تک رسائی حاصل کرسکتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں NULL اور غیر متعینہ کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ میں کالعدم اور غیر متعینہ دو مختلف تصورات ہیں۔نول اور غیر متعینہ کے مابین اختلافات یہ ہیں: تعریف: NULL کسی بھی چیز کی قیمت کی جان بوجھ کر عدم موجودگی ہے ، جبکہ غیر متعینہ مطلب یہ ہے کہ ایک متغیر کا اعلان کیا گیا ہے لیکن اسے ایک قدر کی قیمت نہیں دی گئی ہے۔ٹائپ آبجیکٹ کی ، جبکہ غیر متعینہ طور پر جاوا اسکرپٹ 123 میں ایک قسم ہے۔ قیمت: جب کسی متغیر کو کالعدم قرار دیا جاتا ہے تو ، اس کی کوئی قدر نہیں ہوتی ہے ، جبکہ جب کوئی متغیر غیر متعینہ نہیں ہوتا ہے تو ، اس کا مطلب یہ ہوتا ہے کہ قیمت مرتب کرنے والے 123 میں موجود نہیں ہے۔کسی خالی یا غیر موجود قیمت کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے ، جبکہ غیر متعینہ طور پر کسی متغیر کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے جس کا اعلان کیا گیا ہے لیکن اس کو تفویض نہیں کیا گیا ہے۔جب سخت مساوات آپریٹر (===) استعمال کرتے ہو تو ، کالعدم اور غیر متعینہ طور پر برابر نہیں ہوتے ہیں۔تاہم ، جب ڈھیلے مساوات آپریٹر (==) کا استعمال کرتے ہیں تو ، NULL اور غیر وضاحتی طور پر 123 کے برابر ہیں۔ خلاصہ ، NULL اور غیر متعینہ جاوا اسکرپٹ میں مختلف تصورات ہیں۔NULL کو خالی یا غیر موجود قدر کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے ، جبکہ غیر متعینہ طور پر کسی متغیر کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے جس کا اعلان کیا گیا ہے لیکن اس کی قیمت تفویض نہیں کی گئی ہے۔NULL قسم کی چیز ہے ، جبکہ غیر متعینہ طور پر جاوا اسکرپٹ میں ایک قسم ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں بندش کیا ہے؟اس کی ایک مثال فراہم کریں کہ کس طرح بندش کو استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک بندش جاوا اسکرپٹ میں ایک خصوصیت ہے جو بیرونی فنکشن کے بعد 123456 واپس آنے کے بعد بھی کسی فنکشن کو بیرونی فنکشن سے متغیر تک رسائی حاصل کرنے کی اجازت دیتی ہے۔دوسرے لفظوں میں ، ایک بندش ایک ایسا فنکشن ہے جو اس جگہ سے متغیرات کو یاد کرتا ہے جہاں اس کی تعریف کی جاتی ہے ، قطع نظر اس سے قطع نظر کہ اسے بعد میں انجام دیا جاتا ہے۔یہاں ایک مثال ہے کہ بندش کو کس طرح استعمال کیا جاسکتا ہے: فنکشن آؤٹ فینکشن () {const name = 'John' ؛فنکشن innerfunction () {کنسول.لاگ (`ہیلو ، $ {نام}!`) ؛inner enternfunction ؛} constrabeling = آؤٹ فنکشن () ؛ مبارکباد () ؛// آؤٹ پٹ: ہیلو ، جان! اس مثال میں ، آؤٹ فینکشن () واپس آنے والا انرفکشن () ، جس میں آؤٹ فنکشن () میں نام کے متغیر تک رسائی حاصل ہے۔اگرچہ آؤٹ فینکشن () واپس آگیا ہے ، اس کے باوجود ، بند ہونے کا شکریہ ، نام متغیر تک تک رسائی حاصل ہے۔جب سلام () کہا جاتا ہے ، تو یہ ہیلو لاگ ان ہوتا ہے ، جان!کنسول کے لئے۔ کلوزور اکثر جاوا اسکرپٹ میں ڈیٹا پرائیویسی ، انکپسولیشن ، اور فیکٹری کے افعال 123456 بنانے کے لئے استعمال کیے جاتے ہیں۔ان کا استعمال ایونٹ کے ہینڈلرز ، کال بیکس ، اور اعلی آرڈر کے افعال بنانے کے لئے بھی کیا جاسکتا ہے۔جاوا اسکرپٹ پروگرامنگ میں بندشوں کو سمجھنا ایک اہم تصور ہے"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپل وراثت کیسے کام کرتی ہے؟پروٹو ٹائپ زنجیر کے تصور کی وضاحت کریں۔",
        "Answer": "پروٹو ٹائپل وراثت جاوا اسکرپٹ میں ایک ایسا طریقہ کار ہے جو اشیاء کو دیگر اشیاء سے خصوصیات اور طریقوں کا وارث ہونے کی اجازت دیتا ہے۔جاوا اسکرپٹ میں ، ہر شے کی ایک نجی پراپرٹی ہوتی ہے جسے [[پروٹو ٹائپ]] کہا جاتا ہے ، جو کسی اور شے کی طرف اشارہ کرتا ہے جسے اس کے پروٹو ٹائپ 123 کہا جاتا ہے۔جب کسی شے پر کسی پراپرٹی یا طریقہ کار تک رسائی حاصل کی جاتی ہے تو ، جاوا اسکرپٹ پہلے اس کی تلاش میں ہی اسے تلاش کرتا ہے۔اگر یہ نہیں ملا ہے تو ، یہ اس چیز کو آبجیکٹ کے پروٹو ٹائپ پر تلاش کرتا ہے۔اگر یہ اب بھی نہیں ملا ہے تو ، یہ اس کو پروٹو ٹائپ کے پروٹو ٹائپ پر تلاش کرتا ہے ، اور اسی طرح ، جب تک کہ یہ پروٹو ٹائپ چین 123 کے اختتام تک نہیں پہنچ جاتا ہے۔ یہاں پر پروٹوٹائپ کی زنجیروں کے کام کرنے کی ایک مثال ہے۔: 30 ، مبارکباد: فنکشن () {کنسول.لوگ (`ہیلو ، میرا نام $ {this.name} ہے اور میں $ {this.age} سال کی عمر میں ہوں۔) ؛}} ؛ کانسٹ طالب علم = {میجر: 'کمپیوٹر سائنس' ، __proto__: شخص} ؛ طالب علم۔ گریٹ () ؛// آؤٹ پٹ: ہیلو ، میرا نام جان ہے اور میں 30 سال کا ہوں۔ اس مثال میں ، طالب علم ایک ایسی چیز ہے جو __proto__ پراپرٹی کے ذریعے شخص سے خصوصیات اور طریقوں کو وراثت میں ملتی ہے۔جب طالب علم. گریٹ () کو بلایا جاتا ہے تو ، جاوا اسکرپٹ پہلے طالب علم پر مبارکباد کے طریقہ کار کی تلاش کرتا ہے۔چونکہ یہ نہیں پایا جاتا ہے ، لہذا یہ اس شخص پر تلاش کرتا ہے ، جہاں اسے پایا جاتا ہے اور اس پر عمل درآمد ہوتا ہے۔ پروٹوٹائپ چیننگ جاوا اسکرپٹ میں ایک طاقتور خصوصیت ہے جو اشیاء کو خصوصیات اور طریقوں کو بانٹنے ، کوڈ کی نقل کو کم کرنے اور کوڈ کو زیادہ موثر بنانے کی اجازت دیتی ہے۔تاہم ، اگر احتیاط سے استعمال نہیں کیا گیا تو یہ غیر متوقع سلوک کا باعث بھی بن سکتا ہے۔یہ سمجھنا کہ کس طرح پروٹو ٹائپ چیننگ کام کرتا ہے موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے اہم ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں واقعہ کا لوپ کیا ہے؟یہ غیر متزلزل کارروائیوں کو کس طرح سنبھالتا ہے؟",
        "Answer": "ایونٹ لوپ جاوا اسکرپٹ میں ایک ایسا طریقہ کار ہے جو کوڈ پر عمل درآمد کا انتظام کرتا ہے اور اسینکرونس آپریشنز 123456 کو سنبھالتا ہے۔جاوا اسکرپٹ ایک واحد تھریڈڈ زبان ہے ، جس کا مطلب ہے کہ یہ ایک وقت میں صرف ایک کام پر عملدرآمد کرسکتا ہے۔تاہم ، یہ ایونٹ لوپ کا استعمال کرکے غیر متزلزل کارروائیوں کو سنبھال سکتا ہے۔ایونٹ لوپ کے کام کرنے کا طریقہ یہ ہے: کال اسٹیک: جب کسی فنکشن کو کہا جاتا ہے تو ، اسے کال اسٹیک میں شامل کیا جاتا ہے۔کال اسٹیک ایک ڈیٹا ڈھانچہ ہے جو فی الحال ان افعال کو ٹریک کرتا ہے جو فی الحال پھانسی دی جارہی ہیں۔ WEB APIs: جب ایک متضاد فنکشن کہا جاتا ہے تو ، اسے ویب API میں بھیجا جاتا ہے ، جو براؤزر میں ایک بلٹ ان API ہے۔ویب API اپنا ایک واحد تھریڈ آپریشن شروع کرتا ہے اور پروسیسنگ کے لئے آپریشن کو واپس بھیجنے کے لئے مخصوص وقت کا انتظار کرتا ہے۔ کال بیک قطار: جب ویب API آپریشن واپس بھیجتا ہے تو ، اسے کال بیک قطار میں شامل کیا جاتا ہے۔کال بیک قطار ایک ڈیٹا ڈھانچہ ہے جس میں افعال کو انجام دیا جاتا ہے جو عملدرآمد کے لئے تیار ہیں۔ ایونٹ لوپ: ایونٹ لوپ مستقل طور پر کال اسٹیک اور کال بیک قطار کی جانچ پڑتال کرتا ہے۔اگر کال اسٹیک خالی ہے تو ، یہ کال بیک قطار سے پہلا فنکشن لیتا ہے اور اسے کال اسٹیک میں شامل کرتا ہے۔اس کے بعد فنکشن پر عمل درآمد کیا جاتا ہے۔ ریپیٹ: ایونٹ کا لوپ کال اسٹیک اور کال بیک قطار کی جانچ پڑتال جاری رکھے ہوئے ہے ، اس عمل کو دہراتا ہے جب تک کہ کال بیک قطار میں مزید کام نہ ہوں۔ پروٹوٹائپ چیننگ جاوا اسکرپٹ میں ایک طاقتور خصوصیت ہے جو اشیاء کو خصوصیات کو بانٹنے کی اجازت دیتی ہے۔اور طریقے ، کوڈ کی نقل کو کم کرنا اور کوڈ کو زیادہ موثر بنانا۔تاہم ، اگر احتیاط سے استعمال نہیں کیا گیا تو یہ غیر متوقع سلوک کا باعث بھی بن سکتا ہے۔یہ سمجھنا کہ کس طرح پروٹو ٹائپ چیننگ کام کرتا ہے موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے اہم ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں وعدوں کے تصور کی وضاحت کریں اور ان کو کس طرح متضاد پروگرامنگ کے لئے استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک وعدہ ایک خاص جاوا اسکرپٹ آبجیکٹ ہے جو حتمی تکمیل یا غیر متزلزل آپریشن 12345 کی ناکامی کی نمائندگی کرتا ہے۔وعدوں کا استعمال غیر متزلزل کارروائیوں کو سنبھالنے کے لئے کیا جاتا ہے ، جیسے کسی API سے ڈیٹا لانا ، اور وہ جدید جاوا اسکرپٹ ڈویلپمنٹ 12345 میں بڑے پیمانے پر استعمال ہوتے ہیں۔ویب ایپلی کیشنز میں غیر متزلزل پروگرامنگ کو سنبھالنے کے لئے وعدے اہم ہیں ، اور یہ سمجھنا ضروری ہے کہ وہ کس طرح کام کرتے ہیں اور آپ کے کوڈ 12345 میں ان کا استعمال کیسے کریں گے۔ یہاں وعدہ کرنا وعدہ کرنا: وعدہ کنسٹرکٹر کا استعمال کرتے ہوئے ایک وعدہ تخلیق کیا گیا ہے۔کنسٹرکٹر ایک فنکشن لیتا ہے جسے ایگزیکٹر فنکشن کہا جاتا ہے ، جو دو پیرامیٹرز لیتا ہے: حل اور مسترد کریں۔حل کے فنکشن کو اس وقت کہا جاتا ہے جب غیر متزلزل آپریشن کامیاب ہوتا ہے ، اور جب آپریشن ناکام ہوجاتا ہے تو مسترد ہونے والے فنکشن کو کہا جاتا ہے۔اس کا مطلب یہ ہے کہ غیر متزلزل آپریشن ابھی تک مکمل نہیں ہوا ہے۔ پوری ریاست: جب متضاد آپریشن کامیاب ہوتا ہے تو ، عزم کی تقریب کو کہا جاتا ہے ، اور وعدہ پورا ہوتا ہے۔اس کا مطلب یہ ہے کہ آپریشن کامیابی کے ساتھ مکمل ہوچکا ہے ، اور یہ وعدہ آپریشن کے نتیجے میں واپس آجاتا ہے۔ ریجیکٹڈ ریاست: جب غیر متزلزل آپریشن ناکام ہوجاتا ہے تو ، مسترد فنکشن کو بلایا جاتا ہے ، اور وعدہ مسترد کردیا جاتا ہے۔اس کا مطلب یہ ہے کہ آپریشن ناکام ہوچکا ہے ، اور وعدہ ایک غلطی کو واپس کرتا ہے۔یہ طریقہ پیرامیٹرز کے بطور دو کام لیتا ہے: مکمل اور تندرست۔جب وعدہ پورا ہوتا ہے تو اس کی تکمیل شدہ فنکشن کو کہا جاتا ہے ، اور جب وعدہ مسترد ہوجاتا ہے تو اس سے متعلق فنکشن کہا جاتا ہے۔ جاوا اسکرپٹ میں غیر متزلزل آپریشنوں کو سنبھالنے کے لئے پیش گوئیاں استعمال کی جاتی ہیں۔ان کا استعمال کوڈ کو آسان بنانے اور اسے مزید پڑھنے کے قابل بنانے کے لئے کیا جاسکتا ہے۔وعدوں کا استعمال کسی API سے ڈیٹا لانے ، صارف کے ان پٹ کو سنبھالنے ، اور بہت سے دوسرے استعمال کے معاملات کے لئے کیا جاسکتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں غلطیوں اور استثناء کو کس طرح سنبھالتے ہیں؟کوشش کیچ فائنل بیان کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ میں ، کوششیں کیچ فائنل بیان 123456 کا استعمال کرتے ہوئے غلطیاں اور مستثنیات کو سنبھالا جاسکتا ہے۔آزمائشی بلاک میں کوڈ ہوتا ہے جو غلطی یا استثناء کا سبب بن سکتا ہے۔اگر کوئی غلطی واقع ہوتی ہے تو ، کیچ بلاک پر عمل درآمد ہوتا ہے ، جس میں غلطی کو سنبھالنے کے لئے کوڈ ہوتا ہے۔آخر میں بلاک پر عمل درآمد کیا جاتا ہے اس سے قطع نظر کہ کوئی غلطی واقع ہوتی ہے یا نہیں۔یہاں کوشش ہے کہ کوشش کیچ-فائنل بیان کس طرح کام کرتا ہے: آزمائیں بلاک: آزمائشی بلاک میں کوڈ ہوتا ہے جس کی وجہ سے کسی غلطی یا استثناء کا سبب بن سکتا ہے۔اس میں غلطی کو سنبھالنے کے لئے کوڈ موجود ہے۔کیچ بلاک پیرامیٹر کے طور پر غلطی کا آبجیکٹ لیتا ہے ، جس میں غلطی کے بارے میں معلومات ہوتی ہے۔اس میں وہ کوڈ شامل ہے جس کو آزمائشی بلاک کے نتائج سے قطع نظر اس پر عمل درآمد کرنے کی ضرورت ہے۔ یہاں کوشش کی جانے والی ایک مثال ہے کہ کس طرح ٹر کیچ فائنل بیان کو استعمال کیا جاسکتا ہے: کوشش کریں {// کوڈ جس میں غلطی کا نتیجہ ہوسکتا ہے = 10 / '۔ہیلو'؛کنسول.لاگ (نتیجہ) ؛} کیچ (غلطی) {// غلطی کونسول کو سنبھالنے کے لئے {// کوڈ ('ایک غلطی واقع ہوئی ہے:' ، غلطی) ؛} آخر {// کوڈ جس کو نتائج کنسول سے قطع نظر اس پر عمل درآمد کرنے کی ضرورت ہے۔.log ('اس کوڈ کو ہمیشہ عمل میں لایا جائے گا۔') ؛} اس مثال میں ، آزمائشی بلاک میں کوڈ موجود ہے جس میں غلطی کا سبب بن سکتا ہے۔اگر کوئی غلطی واقع ہوتی ہے تو ، کیچ بلاک پر عمل درآمد ہوتا ہے ، جو کنسول میں غلطی کا پیغام لاگ ان کرتا ہے۔آخر میں بلاک پر عمل درآمد کیا جاتا ہے اس سے قطع نظر کہ کوئی غلطی واقع ہوتی ہے یا نہیں ، جو کنسول کو پیغام لاگ ان کرتا ہے۔ کوشش کیچ فائنل بیان جاوا اسکرپٹ میں ایک طاقتور خصوصیت ہے جو آپ کو غلطیوں اور استثناء کو خوبصورتی سے سنبھالنے کی اجازت دیتی ہے۔آپ کے کوڈ میں غلطیوں اور استثناء کو سنبھالنا ضروری ہے تاکہ آپ کی درخواست کو کریش ہونے سے بچایا جاسکے اور صارف کا بہتر تجربہ فراہم کیا جاسکے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں تیر کے فنکشن کیا ہیں؟وہ باقاعدہ افعال سے کیسے مختلف ہیں؟",
        "Answer": "یرو افعال ES6 میں متعارف کرائی جانے والی ایک نئی خصوصیت ہیں جو فنکشن کے اظہار 123456 لکھنے کے لئے زیادہ جامع نحو فراہم کرتی ہیں۔وہ متعدد طریقوں سے باقاعدہ افعال سے مختلف ہیں: نحو: تیر کے افعال میں باقاعدہ افعال سے کم نحو ہوتا ہے۔وہ فنکشن کی ورڈ کی بجائے => آپریٹر استعمال کرتے ہیں۔مثال کے طور پر: // باقاعدہ فنکشن فنکشن شامل کریں (a ، b) a + b ؛} // یرو فنکشنکونسٹ شامل کریں = (a ، b) => a + b ؛ اس کلیدی لفظ: تیر کے افعال میں اس کی اپنی مطلوبہ الفاظ نہیں ہیں۔اس کے بجائے ، وہ آس پاس کے کوڈ سے اس قدر کے وارث ہیں۔اس سے وہ اشیاء اور ایونٹ کے ہینڈلرز کے ساتھ کام کرنے کے ل useful مفید ہے۔دوسری طرف ، باقاعدہ افعال کا اپنا اپنا کلیدی لفظ ہوتا ہے ، جو کچھ حالات میں الجھن میں پڑ سکتا ہے۔اس کے بجائے ، وہ آس پاس کے کوڈ کے دلائل آبجیکٹ کا استعمال کرتے ہیں۔باقاعدہ افعال میں ان کے اپنے دلائل آبجیکٹ ہوتے ہیں ، جو متغیر تعداد کے دلائل کے ساتھ کام کرنے کے لئے کارآمد ثابت ہوسکتے ہیں۔ دوبارہ بیان: تیر کے افعال میں واپسی کی ایک خاص خصوصیت ہے۔اگر فنکشن جسم ایک ہی اظہار پر مشتمل ہوتا ہے تو ، فنکشن اس اظہار کو لوٹاتا ہے۔باقاعدگی سے افعال کو کسی قدر کو واپس کرنے کے لئے واپسی کے بیان کی ضرورت ہوتی ہے۔ کوشش کیچ فائنل بیان جاوا اسکرپٹ میں ایک طاقتور خصوصیت ہے جو آپ کو غلطیوں اور مستثنیات کو احسن طریقے سے سنبھالنے کی اجازت دیتی ہے۔آپ کے کوڈ میں غلطیوں اور استثناء کو سنبھالنا ضروری ہے تاکہ آپ کی درخواست کو کریش ہونے سے بچایا جاسکے اور صارف کا بہتر تجربہ فراہم کیا جاسکے۔"
    },
    {
        "Question": "\"آپ جاوا اسکرپٹ میں متضاد پروگرامنگ کو کس طرح سنبھالتے ہیں؟ کال بیکس ، وعدوں ، اور async/انتظار کے استعمال کی وضاحت کریں۔\"",
        "Answer": "جاوا اسکرپٹ میں غیر متزلزل پروگرامنگ ایک لازمی تصور ہے ، اور اسے سنبھالنے کے مختلف طریقے ہیں۔جاوا اسکرپٹ میں غیر متزلزل پروگرامنگ کو سنبھالنے کے تین اہم طریقے یہ ہیں: کال بیکس: کال بیک ایک فنکشن ہے جو کسی اور فنکشن کی دلیل کے طور پر منظور کیا جاتا ہے جو پس منظر میں کسی کام کو انجام دینا شروع کردے گا۔جب پس منظر کا کام چل رہا ہے تو ، یہ کال بیک فنکشن کو کال کرتا ہے تاکہ آپ کو نتیجہ 123456 کے بارے میں آگاہ کیا جاسکے۔کال بیکس جاوا اسکرپٹ میں غیر متزلزل پروگرامنگ کو سنبھالنے کا قدیم ترین طریقہ ہے۔وعدوں کا استعمال غیر متزلزل کارروائیوں کو سنبھالنے کے لئے کیا جاتا ہے ، جیسے کسی API سے ڈیٹا لانا ، اور وہ جدید جاوا اسکرپٹ ڈویلپمنٹ 123456 میں بڑے پیمانے پر استعمال ہوتے ہیں۔وعدے کال بیک بیک کے مقابلے میں غیر سنجیدہ پروگرامنگ کو سنبھالنے کا ایک صاف ستھرا اور زیادہ لچکدار طریقہ فراہم کرتے ہیں۔ اے ایس این سی/انتظار کریں: ASYNC/انتظار جاوا اسکرپٹ میں غیر متزلزل پروگرامنگ کو سنبھالنے کا ایک نیا طریقہ ہے۔یہ وعدوں کے اوپری حصے پر بنایا گیا ہے اور اسینکرونس آپریشنز 123456 کو سنبھالنے کے لئے ایک صاف ستھرا اور زیادہ جامع نحو فراہم کرتا ہے۔Async/انتظار کرنا غیر متزلزل کوڈ کو لکھنا اور پڑھنا آسان بناتا ہے ، خاص طور پر جب متعدد وعدوں سے نمٹنے کے لئے۔ خلاصہ ، کال بیکس ، وعدوں ، اور Async/Await جاوا اسکرپٹ میں غیر متزلزل پروگرامنگ کو سنبھالنے کے تین اہم طریقے ہیں۔کال بیکس غیر متزلزل پروگرامنگ کو سنبھالنے کا سب سے قدیم طریقہ ہے ، جبکہ وعدے اور Async/انتظار کرنے والے asynchronous پروگرامنگ کو سنبھالنے کے کلینر اور زیادہ لچکدار طریقے مہیا کرتے ہیں۔"
    },
    {
        "Question": "\"جاوا اسکرپٹ میں لیٹ ، کانسٹ ، اور وی آر میں کیا فرق ہے؟ آپ ہر ایک کو کب استعمال کریں گے؟\"",
        "Answer": "آئیے ، کانسٹ ، اور وی آر سب جاوا اسکرپٹ میں متغیرات کا اعلان کرنے کے لئے استعمال ہوتے ہیں ، لیکن وہ اپنے طرز عمل اور استعمال میں مختلف ہیں۔لیٹ ، کانسٹ ، اور وی آر کے مابین اختلافات یہ ہیں: دائرہ کار: لیٹ اور کانسٹ بلاک اسکوپڈ ہیں ، جس کا مطلب ہے کہ وہ صرف اس بلاک کے اندر ہی قابل رسائی ہیں جن میں وہ اعلان کیے جاتے ہیں ، جبکہ ور فنکشن اسکوپڈ ہے ، جس کا مطلب ہے کہ یہ قابل رسائی ہے۔فنکشن کے اندر اس کا اعلان 123456 میں کیا جاتا ہے۔آئیے اور متغیر متغیرات کو لہرایا نہیں جاتا ہے ، اس کا مطلب یہ ہے کہ ان کا استعمال 123456 کا اعلان کرنے سے پہلے نہیں کیا جاسکتا ہے۔var متغیرات کو دوبارہ تفویض کیا جاسکتا ہے۔متغیر جس کو بعد میں دوبارہ تفویض کیا جاسکتا ہے۔ استعمال کریں جب آپ کو کسی متغیر کا اعلان کرنے کی ضرورت ہوتی ہے جس کو دوبارہ تفویض نہیں کیا جاسکتا۔ جب آپ کو پرانے براؤزرز کی حمایت کرنے کی ضرورت ہو یا جب آپ کو کسی متغیر کا اعلان کرنے کی ضرورت ہو جو اس میں قابل رسائی ہے جس میں اس کا اعلان کیا جاتا ہے۔خلاصہ ، آئیے ، کانسٹ ، اور وی آر جاوا اسکرپٹ میں متغیرات کا اعلان کرنے کے لئے استعمال ہوتے ہیں ، لیکن وہ اپنے طرز عمل اور استعمال میں مختلف ہیں۔آئیے اور کانسٹ بلاک اسکوپڈ ہیں ، جبکہ ور فنکشن اسکوپڈ ہے۔آئیے متغیرات کو دوبارہ تفویض کیا جاسکتا ہے ، جبکہ متغیرات کو دوبارہ تفویض نہیں کیا جاسکتا ہے۔جب ان کا اعلان کیا جاتا ہے تو وہ متغیرات کو شروع کرنا ضروری ہے"
    },
    {
        "Question": "جاوا اسکرپٹ میں لغوی اسکوپنگ کے تصور کی وضاحت کریں اور یہ کہ کس طرح متغیر مرئیت کو متاثر کرتا ہے۔",
        "Answer": "لغوی اسکوپنگ جاوا اسکرپٹ میں ایک بنیادی تصور ہے جو پروگرام 123456 میں متغیر اور افعال کی مرئیت کا تعین کرتا ہے۔اس سے مراد اس طرح سے ہے کہ جب کسی فنکشن کے اندر کوئی فنکشن تشکیل دیا جاتا ہے تو جاوا اسکرپٹ متغیر ناموں کو حل کرتا ہے۔یہ یہ دیکھ کر فنکشن کے والدین کی گنجائش کا تعین کرتا ہے کہ اس کی بجائے فنکشن کہاں بنائی گئی تھی جہاں اس کی درخواست کی گئی تھی۔لغوی اسکوپنگ کے بارے میں کچھ کلیدی نکات یہ ہیں: لغوی اسکوپنگ کو جامد اسکوپنگ کے نام سے بھی جانا جاتا ہے۔ جاوا اسکرپٹ ایک خاص اسکوپ میں متغیرات کو قابل رسائی تلاش کرنے کے لئے اسکوپ چین کہا جاتا ہے ، جس کو اسکوپ چین کہا جاتا ہے۔والدین کے اسکوپس تک جاری رہتا ہے جب تک کہ وہ عالمی دائرہ کار تک نہ پہنچے اور متغیر کو پائے۔ کسی فنکشن کے باہر اعلان کردہ متغیر عالمی متغیرات ہیں اور پروگرام میں کہیں بھی تک رسائی حاصل کی جاسکتی ہے۔ کسی فنکشن کے اندر اعلان کردہ مختلف متغیرات ہیں اور صرف اس میں تک رسائی حاصل کی جاسکتی ہے اور اس تک رسائی حاصل کی جاسکتی ہے۔یہ فنکشن۔ فنکشن ان کے والدین کے اسکوپ سے عالمی دائرہ کار تک متغیرات تک رسائی حاصل کرسکتے ہیں ، لیکن اس کے اندر بیان کردہ افعال سے کوئی گنجائش متغیر تک رسائی حاصل نہیں کرسکتی ہے۔ جیو سکرپٹ میں بندشوں میں لیکسیکل اسکوپنگ بہت زیادہ استعمال ہوتی ہے۔جاوا اسکرپٹ جو کسی پروگرام میں متغیر اور افعال کی مرئیت کا تعین کرتا ہے۔اس سے مراد اس طرح سے ہے کہ جب کسی فنکشن کے اندر کوئی فنکشن تشکیل دیا جاتا ہے تو جاوا اسکرپٹ متغیر ناموں کو حل کرتا ہے۔مؤثر جاوا اسکرپٹ کوڈ لکھنے کے لئے لغوی اسکوپنگ کو سمجھنا ضروری ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں ڈوم (دستاویز آبجیکٹ ماڈل) کو کس طرح جوڑ توڑ کرتے ہیں؟ڈوم ہیرا پھیری کی کارروائیوں کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹ میں ڈوم ہیرا پھیری ایک HTML دستاویز کو تبدیل کرنے یا اس میں ترمیم کرنے کے لئے DOM API کے ساتھ بات چیت کرنے کا عمل ہے جو ویب براؤزر میں ظاہر ہوگا۔ڈوم میں جوڑ توڑ کرکے ، ہم ایسے ویب ایپلی کیشنز تشکیل دے سکتے ہیں جو صفحے کو تازہ دم کیے بغیر ویب پیج میں موجود ڈیٹا کو اپ ڈیٹ کرتے ہیں اور ریفریش 123456 کے بغیر اس کی ترتیب کو تبدیل کرسکتے ہیں۔ڈوم ہیرا پھیری کی کارروائیوں کی کچھ مثالیں یہ ہیں: عناصر کا انتخاب: ہم ڈوم میں عناصر کو منتخب کرسکتے ہیں جیسے مختلف طریقوں جیسے گیٹیلیمنٹ بائی آئی ڈی () ، گیٹیلیمنٹ بائکلاس نام () ، گیٹیلیمنٹ بائ ٹیگ نام () ، استفسار سلیکٹر () ، وغیرہ۔ یہ طریقے منتخب کردہ کا حوالہ واپس کرتے ہیں۔عنصر ، جو عنصر کو جوڑنے کے لئے استعمال کیا جاسکتا ہے۔ عنصر پیدا کرنے کے لئے: ہم کریٹیلیمنٹ () طریقہ کار کا استعمال کرتے ہوئے ڈوم میں نئے عناصر تشکیل دے سکتے ہیں۔یہ طریقہ مخصوص ٹیگ نام کے ساتھ ایک نیا عنصر تشکیل دیتا ہے اور نئے عنصر کا حوالہ واپس کرتا ہے۔اس کے بعد ہم ضمیمہ () کے طریقہ کار کا استعمال کرتے ہوئے ڈوم میں نئے عنصر کو شامل کرسکتے ہیں۔ٹیکسٹ کنٹینٹ پراپرٹی کسی عنصر کے ٹیکسٹ مواد کو سیٹ یا لوٹاتی ہے ، جبکہ اندرونی ایچ ٹی ایم ایل پراپرٹی کسی عنصر کے HTML مواد کو سیٹ کرتی ہے یا لوٹاتی ہے۔ دوبارہ کام کرنے والے عناصر: ہم ہٹانے والے ()) کے طریقہ کار کا استعمال کرتے ہوئے DOM سے عناصر کو ہٹا سکتے ہیں۔یہ طریقہ ڈوم سے بچے کے نوڈ کو ہٹا دیتا ہے اور ہٹائے گئے نوڈ کا حوالہ واپس کرتا ہے۔ اسٹائلنگ عناصر: ہم اسٹائل پراپرٹی کا استعمال کرتے ہوئے کسی عنصر کے انداز کو تبدیل کرسکتے ہیں۔یہ پراپرٹی ہمیں کسی عنصر کی ایک مخصوص سی ایس ایس پراپرٹی کی قیمت مرتب کرنے یا واپس کرنے کی اجازت دیتی ہے۔ ایونٹ کے سننے والوں کو شامل کرتے ہیں: ہم ایونٹ سننے والوں کو ایڈونٹ لسٹنر () کے طریقہ کار کا استعمال کرتے ہوئے عناصر میں شامل کرسکتے ہیں۔اس طریقہ کار سے ایونٹ کے سننے والوں کو کسی عنصر میں شامل کیا جاتا ہے اور جب اس واقعے کو متحرک کیا جاتا ہے تو اس کی وضاحت کی جاتی ہے۔ خلاصہ میں ، جاوا اسکرپٹ میں ڈوم ہیرا پھیری میں ڈوم میں عناصر میں عناصر کے ساتھ ایونٹ کے سننے والوں کو منتخب کرنا ، تخلیق کرنا ، ترمیم کرنا ، ہٹانا ، اسٹائل کرنا شامل ہے۔ڈوم میں جوڑ توڑ کرکے ، ہم متحرک اور انٹرایکٹو ویب ایپلی کیشنز تشکیل دے سکتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں ایونٹ کا وفد کیا ہے؟یہ کیسے کام کرتا ہے اور اس کے کیا فوائد ہیں؟",
        "Answer": "ایونٹ کا وفد جاوا اسکرپٹ میں ایک تکنیک ہے جو آپ کو ایک ہی واقعہ سننے والے کے ساتھ متعدد عناصر کے واقعات کو سنبھالنے کی اجازت دیتا ہے۔ہر عنصر میں ایونٹ سننے والوں کو شامل کرنے کے بجائے ، آپ کسی ایک واقعہ سننے والے کو والدین کے عنصر میں شامل کرتے ہیں اور اس کے بچوں کے عناصر 123456 پر واقعات کو سنبھالنے کے لئے ایونٹ کی بلبلنگ کا استعمال کرتے ہیں۔ایونٹ کے وفد کے استعمال کے کچھ فوائد یہ ہیں: بہتر کارکردگی اور کم میموری کا استعمال: ایونٹ کے وفد کا استعمال کرکے ، آپ کسی صفحے پر واقعہ کے سننے والوں کی تعداد کو کم کرسکتے ہیں ، جو کارکردگی کو بہتر بناسکتے ہیں اور آپ کی درخواست کی میموری کے استعمال کو کم کرسکتے ہیں۔: ایونٹ کا وفد آپ کو متحرک طور پر شامل عناصر پر واقعات کو سنبھالنے کی اجازت دیتا ہے ، جو AJAX یا دوسرے متحرک مواد کے ساتھ کام کرتے وقت مفید ثابت ہوسکتا ہے۔واقعہ کا وفد کس طرح کام کرتا ہے: // والدین کے عنصر ڈوکیومنٹ میں ایک پرک ایونٹ سننے والا شامل کریں۔.target && ایونٹ.ٹارجٹ.مچیس ('. چائلڈ')) {// بچوں کے عنصر کنسول پر واقعہ کو سنبھالیں۔والدین کے عنصر پر واقعہ سننے والوں پر کلک کریں اور یہ چیک کرنے کے لئے میچز () کے طریقہ کار کا استعمال کریں کہ آیا کلیک عنصر بچوں کا عنصر ہے یا نہیں۔اگر یہ ہے تو ، ہم ایونٹ کو چائلڈ عنصر پر سنبھالتے ہیں۔ ایونٹ وفد جاوا اسکرپٹ میں ایک طاقتور تکنیک ہے جو آپ کو ایک ہی واقعہ سننے والے کے ساتھ متعدد عناصر کے واقعات کو سنبھالنے کی اجازت دیتا ہے۔یہ کارکردگی کو بہتر بنا سکتا ہے ، کوڈ کو آسان بنا سکتا ہے ، اور آپ کی ایپلی کیشن کو مزید متحرک بنا سکتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں فارم کی توثیق کو کس طرح سنبھالتے ہیں؟فارم کی توثیق کی تکنیک کی مثالیں فراہم کریں۔",
        "Answer": "فارم کی توثیق ویب ڈویلپمنٹ کا ایک لازمی حصہ ہے جو یقینی بناتا ہے کہ صارف کے ذریعہ داخل کردہ ڈیٹا درست ہے اور مخصوص معیار کو پورا کرتا ہے۔جاوا اسکرپٹ فارم کی توثیق کے ل several کئی تکنیک مہیا کرتا ہے ، بشمول: بنیادی توثیق: بنیادی توثیق کی جانچ پڑتال کرتی ہے کہ آیا تمام لازمی شعبوں کو پُر کیا گیا ہے۔ اس میں ہر فیلڈ کو فارم میں لوپنگ کی ضرورت ہوتی ہے اور ڈیٹا 123456. ڈیٹا فارمیٹ کی توثیق: ڈیٹا فارمیٹ کی توثیق کی جانچ پڑتال نہیں کی جاتی ہے یا نہیںدرج کیا صحیح شکل اور قدر میں ہے۔ڈیٹا 123456.html5 توثیق کی درستگی کو جانچنے کے لئے مناسب منطق کی ضرورت ہوتی ہے: HTML5 بلٹ ان فارم کی توثیق کی خصوصیات فراہم کرتا ہے جو فارم ڈیٹا کو درست کرنے کے لئے استعمال کیا جاسکتا ہے۔اس توثیق میں جاوا اسکرپٹ کی توثیق سے بہتر کارکردگی ہے ، لیکن یہ بطور حسب ضرورت 6 نہیں ہے۔ جاوا اسکرپٹ کی توثیق: جاوا اسکرپٹ کی توثیق ایک کلائنٹ سائیڈ کی توثیق کی تکنیک ہے جسے سرور کو جمع کروانے سے پہلے فارم ڈیٹا کو درست کرنے کے لئے استعمال کیا جاسکتا ہے۔یہ صارف کو فوری آراء فراہم کرتا ہے اور مخصوص تقاضوں کو پورا کرنے کے لئے اپنی مرضی کے مطابق بنایا جاسکتا ہے ۔123456. جاوا اسکرپٹ کی شکل کو کس طرح انجام دینے کی ایک مثال ہے: فنکشن کوئٹیٹیٹفارم () {CONT نام = دستاویزات۔؛اگر (نام == \"\") {الرٹ (\"نام کو پُر کرنا ضروری ہے\") ؛جھوٹا واپس ؛Email ای میل = دستاویزات۔اگر (ای میل == \"\") {الرٹ (\"ای میل کو پُر کرنا ضروری ہے\") ؛جھوٹا واپس ؛passion پاس ورڈ = دستاویزات۔ شکلیں [\"مائیفارم\"] [\"پاس ورڈ\"]اگر (پاس ورڈ == \"\") {الرٹ (\"پاس ورڈ کو پُر کرنا ضروری ہے\") ؛جھوٹا واپس ؛confort confornassword = دستاویزات۔اگر (تصدیق پاس ورڈ == \"\") {الرٹ (\"تصدیق پاس ورڈ کو پُر کرنا ضروری ہے\") ؛جھوٹا واپس ؛} اگر (پاس ورڈ! = تصدیق پاس ورڈ) {الرٹ (\"پاس ورڈ مماثل نہیں ہوتے\") ؛جھوٹا واپس ؛true سچائی واپس ؛} اس مثال میں ، ہم ایک فنکشن کی وضاحت کرتے ہیں جس کو ویلیویٹیٹفارم () کہا جاتا ہے جو چیک کرتا ہے کہ آیا نام ، ای میل ، پاس ورڈ ، اور اس کی تصدیق پاس ورڈ کے فیلڈز کو پُر کیا گیا ہے اور آیا پاس ورڈز مماثل ہیں یا نہیں۔اگر کسی بھی فیلڈ کو پُر نہیں کیا گیا ہے یا پاس ورڈ مماثل نہیں ہیں تو ، ایک الرٹ پیغام ظاہر ہوتا ہے ، اور فنکشن غلط لوٹاتا ہے۔اگر تمام فیلڈز کو پُر کیا گیا ہے اور پاس ورڈز مماثل ہیں تو ، فنکشن سچ واپس آجاتا ہے۔ خلاصہ یہ کہ ، فارم کی توثیق ویب ڈویلپمنٹ کا ایک لازمی حصہ ہے جو اس بات کو یقینی بناتا ہے کہ صارف کے ذریعہ داخل کردہ ڈیٹا درست ہے اور مخصوص معیار پر پورا اترتا ہے۔جاوا اسکرپٹ فارم کی توثیق کے لئے متعدد تکنیک فراہم کرتا ہے ، بشمول بنیادی توثیق ، ڈیٹا فارمیٹ کی توثیق ، HTML5 توثیق ، اور جاوا اسکرپٹ کی توثیق۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں اعلی آرڈر کے افعال کے تصور کی وضاحت کریں اور ان کے استعمال کی مثالیں فراہم کریں۔",
        "Answer": "اعلی آرڈر کے افعال ایسے افعال ہیں جو ایک یا زیادہ افعال کو دلائل کے طور پر لیتے ہیں یا کسی فنکشن کو ان کے نتائج 123456 کے طور پر لوٹاتے ہیں۔وہ جاوا اسکرپٹ میں ایک طاقتور تصور ہیں جو زیادہ ماڈیولر ، دوبارہ قابل استعمال اور لچکدار کوڈ کی اجازت دیتا ہے۔ان کے استعمال کی کچھ مثالیں یہ ہیں: نقشہ: نقشہ () کا طریقہ ایک اعلی آرڈر کا فنکشن ہے جو موجودہ صف کے ہر عنصر پر کسی فنکشن کا اطلاق کرکے ایک نئی صف تیار کرتا ہے۔یہ ایک دلیل کے طور پر ایک فنکشن لیتا ہے اور ہر عنصر 123456 پر فنکشن کا اطلاق کرنے کے نتائج کے ساتھ ایک نئی صف لوٹاتا ہے۔ فلٹر: فلٹر () کا طریقہ ایک اعلی آرڈر کا فنکشن ہے جو ایک نئی صف کو تیار کرتا ہے جو ان تمام عناصر کے ساتھ ہوتا ہے جو ایک ٹیسٹ کو نافذ کرتے ہیں۔فراہم کردہ فنکشن کے ذریعہ۔یہ ایک دلیل کے طور پر ایک فنکشن لیتا ہے اور ان عناصر کے ساتھ ایک نئی صف لوٹاتا ہے جو TEST123456 کو منتقل کرتے ہیں۔ reduce: کم () طریقہ ایک اعلی آرڈر کا فنکشن ہے جو کسی ایک قدر میں کم کرنے کے لئے کسی صف کے ہر عنصر پر ایک فنکشن کا اطلاق کرتا ہے۔یہ ایک دلیل کے طور پر ایک فنکشن لیتا ہے اور ایک ہی قیمت کو لوٹاتا ہے جو ہر عنصر 123456 پر فنکشن کو لاگو کرنے کا نتیجہ ہے۔ کال بیکس: کال بیکس ایسے کام ہیں جو دوسرے افعال کو دلائل کے طور پر منظور کیے جاتے ہیں اور جب کوئی خاص واقعہ پیش آتا ہے تو اس پر عملدرآمد کیا جاتا ہے۔وہ عام طور پر غیر متزلزل پروگرامنگ ، ایونٹ ہینڈلنگ ، اور دیگر منظرناموں میں استعمال ہوتے ہیں جہاں عملدرآمد کے حکم کی ضمانت نہیں ہے 123456. کلوز: بندشیں ایسے افعال ہیں جن کے بیرونی دائرہ کار میں متغیر تک رسائی ہوتی ہے ، یہاں تک کہ بیرونی فنکشن واپس آنے کے بعد بھی۔وہ عام طور پر جاوا اسکرپٹ 123456 میں نجی متغیرات اور افعال پیدا کرنے کے لئے استعمال ہوتے ہیں۔ خلاصہ میں ، اعلی آرڈر کے افعال جاوا اسکرپٹ میں ایک طاقتور تصور ہیں جو زیادہ ماڈیولر ، دوبارہ قابل استعمال اور لچکدار کوڈ کی اجازت دیتا ہے۔وہ عام طور پر نقشہ () ، فلٹر () ، اور کم () کے ساتھ ساتھ کال بیکس اور بندشوں میں بھی سرنی طریقوں میں استعمال ہوتے ہیں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں ایجیکس کی درخواستیں کیسے کرتے ہیں؟XMLHTTPrequest کے استعمال کی وضاحت کریں اور API بازیافت کریں۔",
        "Answer": "جاوا اسکرپٹ میں ایجیکس کی درخواستیں کرنے کے دو اہم طریقے ہیں: XMLHTTTPREQUEST (XHR) آبجیکٹ کا استعمال اور بازیافت API.XMLHTTPREQUEST (XHR) آبجیکٹ کا استعمال: XHR آبجیکٹ ایک بلٹ ان جاوا اسکرپٹ آبجیکٹ ہے جو کسی ویب صفحے کو درخواست کرنے کی اجازت دیتا ہے۔سرور کو اور پورے صفحہ 123456 کو دوبارہ لوڈ کیے بغیر جواب وصول کریں۔یہاں XHR آبجیکٹ کا استعمال کرتے ہوئے AJAX درخواست کرنے کا طریقہ اس کی ایک مثال ہے: const xhr = new xmlhttprequest () ؛ xhr.onreadystatechange = فنکشن () {اگر (xhr.readystate === 4 &&status === 200) {{کنسول.لاگ (xhr.responsetext) ؛}} ؛ xhr.open ('get' ، 'https://api.example.com/data') ؛xhr.send() ؛ اس مثال میں ، ہم ایک نیا XHR آبجیکٹ تیار کرتے ہیں ، آنڈی اسٹیٹ چینج ایونٹ ہینڈلر کو اے میں سیٹ کریں۔فنکشن جو جوابی متن کو کنسول پر لاگ ان کرتا ہے اگر درخواست کامیاب ہے تو ، مخصوص یو آر ایل کو گیٹ کی درخواست کھولیں ، اور درخواست بھیجیں۔ فیٹچ API: بازیافت API جاوا اسکرپٹ میں ایجیکس کی درخواستوں کو بنانے کا ایک نیا اور جدید طریقہ ہے۔یہ درخواستیں بنانے اور جوابات سے نمٹنے کے لئے ایک آسان اور زیادہ لچکدار انٹرفیس فراہم کرتا ہے ۔123456۔بازیافت API: بازیافت ('https://api.example.com/data') کا استعمال کرتے ہوئے ایجیکس کی درخواست کرنے کا طریقہ یہاں ہے۔.log (ڈیٹا)) .catch (غلطی => کنسول.ریرر (غلطی)) ؛ اس مثال میں ، ہم مخصوص URL سے درخواست دینے کے لئے بازیافت () کا طریقہ استعمال کرتے ہیں ، JSON () کے طریقہ کار کو تجزیہ کرنے کے لئے استعمال کریںJSON کے طور پر جواب دیں ، کنسول میں ڈیٹا کو لاگ ان کریں ، اور کسی بھی غلطیوں کو پکڑیں۔ خلاصہ میں ، AJAX درخواستیں XMLHTTPREQUEST (XHR) آبجیکٹ یا بازیافت API کا استعمال کرتے ہوئے جاوا اسکرپٹ میں کی جاسکتی ہیں۔دونوں طریقوں سے آپ کو سرور سے غیر متزلزل درخواستیں کرنے اور پورے صفحے کو دوبارہ لوڈ کیے بغیر جواب موصول ہونے کی اجازت دیتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں صفوں کو لوپ کرنے کے مختلف طریقے کیا ہیں؟ہر طریقہ کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹ میں صفوں کو لوپ کرنے کے بہت سارے طریقے ہیں ، جن میں شامل ہیں: لوپ کے لئے: جاوا اسکرپٹ میں صفوں کے ذریعے لوپ لوپ کا ایک عام طریقہ ہے۔یہ سرنی کے اوپر تکرار کرنے کے لئے کاؤنٹر متغیر کا استعمال کرتا ہے اور ہر ایک پر کوڈ کا ایک بلاک چلاتا ہے۔{کنسول.لوگ (آر آر [i]) ؛} کے لئے ... لوپ میں: دی لوپ میں لوپ ایک کنٹرول فلو بیان ہے جو آپ کو کسی شے کی خصوصیات پر تکرار کرنے کی اجازت دیتا ہے۔لوپ کے لئے ایک کے برعکس ، جو صرف صفوں کے اوپر تکرار کرسکتا ہے ، A کے لئے ... لوپ میں کسی بھی آبجیکٹ پر تکرار کرسکتا ہے۔کنسول.لوگ (آر آر [i]) ؛} کے لئے ... لوپ کے: لوپ کا ... لوپ کا ایک نیا لوپ ہے جو ES6 میں متعارف کرایا جاتا ہے جو آپ کو کسی بھی چیز کی اقدار پر تکرار کرنے کی اجازت دیتا ہے ، جیسے کسی صف میں یاایک سٹرنگ 123456.const arr = [1 ، 2 ، 3 ، 4 ، 5 ،] ؛ کے لئے (ARR کی قیمت) {کنسول.لاگ (ویلیو) ؛} جبکہ لوپ: جبکہ لوپ ایک کنٹرول فلو بیان ہے جو آپ کو انجام دینے کی اجازت دیتا ہےکوڈ کا ایک بلاک بار بار جب ایک مخصوص حالت درست ہے۔اس کا استعمال کاؤنٹر متغیر 123456.const arr = [1 ، 2 ، 3 ، 4 ، 5] کا استعمال کرکے صفوں کو لوپ کرنے کے لئے کیا جاسکتا ہے۔ i = 0 ؛]] ؛i ++ ؛} foreach () طریقہ: پیش گوئی () کا طریقہ ایک اعلی آرڈر کا فنکشن ہے جو آپ کو کسی صف کے عناصر پر تکرار کرنے اور ہر عنصر کے لئے ایک بار فراہم کردہ فنکشن پر عمل درآمد کرنے کی اجازت دیتا ہے انڈیکس آرڈر 123456.const arr = [1 ،2 ، 3 ، 4 ، 5] arr.for.foreach (فنکشن (ویلیو) {کنسول.لاگ (قدر) ؛}) ؛ نقشہ () طریقہ: نقشہ () کا طریقہ ایک اعلی آرڈر کا فنکشن ہے جو ایک نئی صف پیدا کرتا ہےموجودہ صف کے ہر عنصر پر کسی فنکشن کا اطلاق کرنا۔یہ ہر عنصر 123456 پر فنکشن کا اطلاق کرنے کے نتائج کے ساتھ ایک نئی صف لوٹاتا ہے۔؛ کنسول.لوگ (نیوار) ؛ خلاصہ یہ کہ جاوا اسکرپٹ میں صفوں کو لوپ کرنے کے بہت سارے طریقے ہیں ، جن میں لوپ کے لئے ... لوپ میں ، لوپ میں ، جبکہ لوپ ، پیش گوئی () طریقہ () طریقہ ، اور نقشہ شامل ہے۔() طریقہہر طریقہ کے اپنے فوائد اور نقصانات ہوتے ہیں ، اور طریقہ کا انتخاب پروگرام کی مخصوص ضروریات پر منحصر ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں بندشوں اور ماڈیول پیٹرن کے تصور کی وضاحت کریں اور ان کا استعمال نجی متغیرات اور انکپسولیشن کو بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "بندش اور ماڈیول کا نمونہ جاوا اسکرپٹ میں دو اہم تصورات ہیں جو نجی متغیرات اور انکپسولیشن بنانے کے لئے استعمال ہوسکتے ہیں۔ کلوزر: ایک بندش ایک ایسا فنکشن ہے جس میں بیرونی فنکشن واپس آنے کے بعد بھی ، اس کے بیرونی (منسلک) فنکشن میں متغیر تک رسائی ہوتی ہے۔فنکشن تخلیق کے وقت ، جب بھی ایک فنکشن تیار کیا جاتا ہے تو بندش پیدا کی جاتی ہے۔ کلوزور کو جاوا اسکرپٹ میں نجی متغیرات اور افعال بنانے کے لئے استعمال کیا جاتا ہے۔ کلوز کو ماڈیولر اور دوبارہ قابل استعمال کوڈ بنانے کے لئے استعمال کیا جاسکتا ہے۔ کلوزر تیار کیے جاتے ہیں جب کسی فنکشن کی وضاحت کی جاتی ہے ، جب نہیں جب ایسا نہیں ہوتا ہے۔عمل میں لایا جاتا ہے۔ ماڈل پیٹرن: ماڈیول پیٹرن جاوا اسکرپٹ میں ایک ڈیزائن کا نمونہ ہے جو آپ کو نجی متغیرات اور افعال بنانے اور اپنے کوڈ کے دوسرے حصوں کو استعمال کرنے کے لئے عوامی API کو بے نقاب کرنے کی اجازت دیتا ہے۔ ماڈیول پیٹرن نجی متغیرات اور افعال کو بنانے کے لئے بندش کا استعمال کرتا ہے۔ماڈیول پیٹرن کسی ایک شے کے اندر سرکاری اور نجی طریقوں اور متغیرات کے مرکب کو لپیٹنے کا ایک طریقہ فراہم کرتا ہے ، اس طرح خاص حصوں کو عالمی اسکوپ سے بچاتا ہے۔ ماڈیول پیٹرن کو ماڈیولر اور دوبارہ قابل استعمال کوڈ بنانے کے لئے استعمال کیا جاسکتا ہے۔ ماڈیول پیٹرن کو نافذ کیا جاسکتا ہے۔فوری طور پر پائے جانے والے فنکشن اظہار (IIFE) کا استعمال کرتے ہوئے۔ یہاں نجی متغیرات اور encapsulation بنانے کے لئے ماڈیول پیٹرن کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: mymodule = (فنکشن () const {پرائیویٹور = 0 ؛فنکشن پرائیویٹ فنکشن () {کنسول.لاگ ('نجی فنکشن جسے کہا جاتا ہے') ؛} واپسی {پبلک وی آر: 1 ، پبلک فنکشن: فنکشن () {کنسول.لاگ ('عوامی فنکشن کہا جاتا ہے') ؛}} ؛}) () ؛ کنسول.لوگ (mymodule.publicvar) ؛// آؤٹ پٹ: 1mymodule.publicfunction () ؛// آؤٹ پٹ: 'عوامی فنکشن جسے' console.log (mymodule.privatevar) کہا جاتا ہے ؛// آؤٹ پٹ: undfinedmymodule.privateFunction () ؛// آؤٹ پٹ: ٹائپ ایرر: mymodule.privateFunction اس مثال کے طور پر ، ہم ایک IIFE استعمال کرتے ہیں تاکہ ایک ماڈیول تیار کیا جاسکے جس میں نجی متغیر اور نجی فنکشن ہو۔اس کے بعد ہم ایک ایسی شے لوٹتے ہیں جس میں عوامی متغیر اور عوامی فنکشن ہوتا ہے جس تک ماڈیول کے باہر سے رسائی حاصل کی جاسکتی ہے۔نجی متغیر اور فنکشن کو ماڈیول کے باہر سے حاصل نہیں کیا جاسکتا۔ خلاصہ ، بندش اور ماڈیول پیٹرن جاوا اسکرپٹ میں دو اہم تصورات ہیں جن کا استعمال نجی متغیرات اور انکپسولیشن بنانے کے لئے کیا جاسکتا ہے۔بندشیں آپ کو ایسے افعال پیدا کرنے کی اجازت دیتی ہیں جن کو ان کے بیرونی فنکشن میں متغیر تک رسائی حاصل ہوتی ہے ، جبکہ ماڈیول پیٹرن آپ کو نجی متغیرات اور افعال بنانے اور اپنے کوڈ کے دوسرے حصوں کو استعمال کرنے کے لئے عوامی API کو بے نقاب کرنے کی اجازت دیتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں JSON ڈیٹا کو کس طرح سنبھالتے ہیں؟json.stringify () اور json.parse () طریقوں کے استعمال کی وضاحت کریں۔",
        "Answer": "JSON (جاوا اسکرپٹ آبجیکٹ نوٹیشن) ایک ہلکا پھلکا ڈیٹا انٹرچینج فارمیٹ ہے جو عام طور پر ویب ایپلی کیشنز 12 میں سرور اور کسی کلائنٹ کے مابین ڈیٹا منتقل کرنے کے لئے استعمال ہوتا ہے۔جاوا اسکرپٹ میں ، JSON ڈیٹا کو json.stringify () اور json.parse () methods.json.stringify () کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے: یہ طریقہ جاوا اسکرپٹ آبجیکٹ کو JSON سٹرنگ میں تبدیل کرتا ہے۔یہ ایک دلیل کے طور پر کسی شے کو لیتا ہے اور JSON سٹرنگ 1342.const obj = {نام: 'جان' ، عمر: 30} ؛ const jsonstr = json.stringify (OBJ) ؛ کنسول.لاگ (jsonston) ؛// آؤٹ پٹ: {\"نام\": \"جان\" ، \"عمر\": 30} json.parse (): یہ طریقہ JSON تار کو جاوا اسکرپٹ آبجیکٹ میں تبدیل کرتا ہے۔یہ ایک دلیل کے طور پر JSON تار لیتا ہے اور جاوا اسکرپٹ آبجیکٹ 1342.const jsonst = '{\"name\": \"جان\" ، \"عمر\": 30}' ؛ const obj = json.parse (jsonston) ؛ کنسول.لوگ (OBJ) ؛// آؤٹ پٹ: {نام: 'جان' ، عمر: 30} یہ طریقے جاوا اسکرپٹ میں JSON ڈیٹا کو سنبھالنے کے لئے کارآمد ہیں ، خاص طور پر جب APIs کے ساتھ کام کرتے ہیں جو JSON ڈیٹا لوٹتے ہیں۔یاد رکھنے کے لئے کچھ اہم نکات یہ ہیں: JSON ڈیٹا کو جاوا اسکرپٹ میں ایک تار کے طور پر پیش کیا جاتا ہے اور اسے JSON.Parse () تک رسائی حاصل کرنے سے پہلے JSON.Parse () کا استعمال کرتے ہوئے جاوا اسکرپٹ آبجیکٹ میں تبدیل کرنے کی ضرورت ہے۔ جاوا اسکرپٹ آبجیکٹ JSON کے ذریعہ JSON..json string.in سمری میں شامل کرنے کے لئے پراپرٹیز کی صف ، json.stringify () اور JSON.Parse () کے طریقے جاوا اسکرپٹ میں JSON ڈیٹا کو سنبھالنے کے لئے استعمال کیے جاتے ہیں۔وہ آپ کو جاوا اسکرپٹ آبجیکٹ کو JSON اسٹرنگز اور اس کے برعکس تبدیل کرنے کی اجازت دیتے ہیں ، جس سے ویب ایپلی کیشنز میں JSON ڈیٹا کے ساتھ کام کرنا آسان ہوجاتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں اس کلیدی لفظ کا مقصد کیا ہے؟اس کی قدر مختلف سیاق و سباق میں کیسے تبدیل ہوتی ہے؟",
        "Answer": "جاوا اسکرپٹ میں اس کلیدی لفظ کا استعمال اس شے کی طرف اشارہ کرنے کے لئے کیا جاتا ہے جو موجودہ کوڈ یا فنکشن کو انجام دے رہا ہے۔اس سیاق و سباق پر منحصر ہے جس میں اس کا استعمال ہوتا ہے اس کی قدر۔یہاں کچھ طریقے ہیں جن میں اس کی قدر مختلف سیاق و سباق میں تبدیل ہوسکتی ہے: عالمی سیاق و سباق: عالمی تناظر میں ، اس سے مراد عالمی شے ہے ، جو ویب براؤزرز میں ونڈو آبجیکٹ اور نوڈ. js123456.console میں عالمی آبجیکٹ ہے۔لاگ (یہ) ؛// آؤٹ پٹ: ونڈو (ویب براؤزرز میں) فنکشن سیاق و سباق: کسی فنکشن میں ، اس کی قدر اس بات پر منحصر ہوتی ہے کہ فنکشن کو کس طرح کہا جاتا ہے۔اگر فنکشن کو کسی شے کے طریقہ کار کے طور پر کہا جاتا ہے تو ، اس سے مراد شے سے مراد ہے۔اگر فنکشن کو اسٹینڈ اسٹون فنکشن کے طور پر کہا جاتا ہے تو ، اس سے مراد عالمی آبجیکٹ 123456.کونسٹ OBJ = {نام: 'جان' ، CAYNAME: فنکشن () {کنسول.لوگ (یہ. نام) ؛}} ؛ Obj.sayname () ؛// آؤٹ پٹ: جانفکشن سی نام () {کنسول.لاگ (یہ۔ نام) ؛} sayname () ؛// آؤٹ پٹ: غیر طے شدہ کنسٹرکٹر سیاق و سباق: کسی کنسٹرکٹر فنکشن میں ، اس سے مراد اس چیز سے مراد ہے جو کنسٹرکٹر فنکشن 123456. فنکشن پرسن (نام ، عمر) کے ذریعہ تخلیق کیا جارہا ہے۔this.age = عمر ؛} const John = نیا شخص ('جان' ، 30) ؛ کنسول.لوگ (جان. نام) ؛// آؤٹ پٹ: جانیوینٹ سیاق و سباق: ایونٹ ہینڈلر میں ، اس سے مراد اس عنصر سے ہوتا ہے جس نے ایونٹ 123456.const بٹن = دستاویز۔ کوئری سلیکٹر ('بٹن') ؛ بٹن.اڈی ایونٹ لسٹنر ('کلک' ، فنکشن () {کنسول.لوگ ({کنسول.لوگ (یہ) ؛ // آؤٹ پٹ: <بٹن>}) ؛ خلاصہ یہ کہ جاوا اسکرپٹ میں یہ کلیدی لفظ اس شے کا حوالہ دینے کے لئے استعمال ہوتا ہے جو موجودہ کوڈ یا فنکشن کو انجام دے رہا ہے۔اس کی قدر اس سیاق و سباق پر منحصر ہوتی ہے جس میں اس کا استعمال ہوتا ہے ، جیسے عالمی سیاق و سباق ، فنکشن سیاق و سباق ، تعمیر کنندہ سیاق و سباق اور واقعہ کا سیاق و سباق۔اس کی قدر کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے اہم ہے ۔1 کوڈبرسٹ 2 ٹیوٹوریلسٹیر 3 ٹواارڈسڈاسٹی سائنس 4simplilearn5mozilla6javascriptaturial"
    },
    {
        "Question": "جاوا اسکرپٹ میں واقعہ کے بلبلنگ اور ایونٹ کی گرفت کے تصور کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ ایونٹ بلبلنگ اور ایونٹ کیپنگ میں واقعہ کی بلبلنگ اور ایونٹ کی گرفتاری جاوا اسکرپٹ میں دو تصورات ہیں جو اس ترتیب کی وضاحت کرتے ہیں جس میں واقعات کو ڈوم (دستاویز آبجیکٹ ماڈل) کے ذریعے پھیلایا جاتا ہے جب کسی ایسے عنصر پر واقع ہوتا ہے جو کسی دوسرے عنصر کے اندر گھونسلے ہوتا ہے۔ ایونٹ بلبلنگ: ایونٹ بلبلنگ:ایونٹ بلبلنگ میں ، واقعہ اندرونی عنصر سے شروع ہوتا ہے اور پھر بیرونی عنصر کی طرف ظاہری طور پر پھیلتا ہے۔اس کا مطلب یہ ہے کہ اس واقعہ کو سب سے پہلے اندرونی عنصر کے ذریعہ پکڑا اور سنبھالا جاتا ہے اور پھر بیرونی عناصر 123456 پر پھیلایا جاتا ہے۔ ایونٹ کیپنگ: ایونٹ کی گرفتاری میں ، واقعہ بیرونی عنصر سے شروع ہوتا ہے اور پھر اندرونی عنصر کی طرف اندر کی طرف پھیلتا ہے۔اس کا مطلب یہ ہے کہ اس واقعہ کو سب سے پہلے بیرونی عنصر کے ذریعہ قبضہ اور سنبھالا جاتا ہے اور پھر اندرونی عناصر 123456 میں پھیلایا جاتا ہے۔ دونوں ایونٹ کی بلبلنگ اور ایونٹ کیپنگ جاوا اسکرپٹ ایونٹ ہینڈلنگ میں اہم تصورات ہیں۔پہلے سے طے شدہ طور پر ، جاوا اسکرپٹ میں زیادہ تر واقعات ایونٹ کی بلبلنگ کا استعمال کرتے ہیں ، لیکن ایونٹ کی گرفتاری کو ایونٹ کے سننے والے 123456 کو شامل کرتے وقت یو ایس کیپچر پیرامیٹر کو درست ترتیب دینے کے ذریعہ بھی استعمال کیا جاسکتا ہے۔.addventListener ('کلک' ، فنکشن () {کنسول.لاگ ('آؤٹ عنصر پر کلک کیا گیا') ؛} ، سچ) ؛ دستاویزات.کیری سلیکٹر ('#اندرونی')('اندرونی عنصر پر کلک کیا گیا') ؛} ، سچ) ؛ اس مثال میں ، ہم ایونٹ کے سامعین کو #یار اور #ان عناصر میں شامل کرتے ہیں جس میں یو ایس کیپچر پیرامیٹر کو سچ پر سیٹ کیا جاتا ہے۔اس کا مطلب یہ ہے کہ واقعات کو سب سے پہلے بیرونی عنصر کے ذریعہ قبضہ اور سنبھالا جائے گا اور پھر اندرونی عنصر پر پھیلایا جائے گا۔ خلاصہ میں ، ایونٹ کی بلبلنگ اور ایونٹ کیپنگ جاوا اسکرپٹ ایونٹ ہینڈلنگ میں دو اہم تصورات ہیں جس میں اس ترتیب کی وضاحت کی جاتی ہے جس میں واقعات کو پیش کیا جاتا ہے۔ڈومپہلے سے طے شدہ طور پر ، جاوا اسکرپٹ میں زیادہ تر واقعات ایونٹ کی بلبلنگ کا استعمال کرتے ہیں ، لیکن ایونٹ کی گرفتاری کو کسی واقعہ سننے والوں کو شامل کرتے وقت یو ایس کیپچر پیرامیٹر کو درست ترتیب دے کر بھی استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد غلطیوں کو کس طرح سنبھالتے ہیں؟کوشش کے استعمال کی وضاحت کریں ... async/انتظار اور وعدوں کے ساتھ پکڑو۔",
        "Answer": "جاوا اسکرپٹ میں غیر متزلزل غلطیوں کو کوشش کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے ... Async/انتظار اور وعدوں کے ساتھ کیچ کا بیان۔یہاں ہر طریقہ کو کس طرح استعمال کیا جاسکتا ہے: 1۔کوشش کریں ... async/انتظار کے ساتھ کیچ: کوشش ... کیچ اسٹیٹمنٹ کو مطابقت پذیری کے کوڈ میں پائے جانے والی غلطیوں کو پکڑنے کے لئے استعمال کیا جاتا ہے۔ جب Async/انتظار کرتے ہیں تو ، کوشش ... کیچ کے بیان کو غلطیوں کو پکڑنے کے لئے استعمال کیا جاسکتا ہے جو اس میں پائے جاتے ہیں۔غیر متزلزل کوڈ۔ کوشش بلاک میں کوڈ ہوتا ہے جس میں غلطی پھینک سکتی ہے ، اور کیچ بلاک میں وہ کوڈ ہوتا ہے جو غلطی 123456.async فنکشن getData () {کوشش کریں {کانٹ response response جواب = انتظار کریں بازیافت ('https: //api.example.com/ڈیٹا ') ؛کانسٹ ڈیٹا = جواب دینے کا انتظار کریں۔ json () ؛کنسول.لاگ (ڈیٹا) ؛} کیچ (غلطی) {کنسول.رور (غلطی) ؛}} اس مثال میں ، ہم غلطیوں کو پکڑنے کے لئے کوشش کا استعمال کرتے ہیں جو کسی API سے ڈیٹا لانے کے وقت ہوسکتا ہے۔اگر کوئی غلطی واقع ہوتی ہے تو ، کیچ بلاک کنسول 2 میں غلطی کو لاگ ان کرتا ہے۔وعدے: وعدے جاوا اسکرپٹ میں غیر متزلزل کوڈ کو سنبھالنے کا ایک طریقہ ہے۔ پرومائزز کے پاس اس وقت () طریقہ ہے جسے وعدہ حل کیا جاتا ہے اور ایک کیچ () طریقہ جس کو کہا جاتا ہے جب وعدہ مسترد ہوجاتا ہے۔ کیچ () کا طریقہ استعمال ہوتا ہے۔غیر متزلزل کوڈ 123456 میں پیش آنے والی غلطیوں کو پکڑنے کے لئے۔لاگ (ڈیٹا)). کیچ (غلطی => کنسول.رور (غلطی)) ؛} اس مثال میں ، ہم غلطیوں کو پکڑنے کے لئے کیچ () کا طریقہ استعمال کرتے ہیں جو کسی API سے ڈیٹا لاتے وقت پیش آسکتے ہیں۔اگر کوئی غلطی واقع ہوتی ہے تو ، کیچ () کا طریقہ کار کو کنسول ڈاٹ کام میں غلطی کو لاگ ان کرتا ہے ، جاوا اسکرپٹ میں غیر متزلزل غلطیوں کو کوشش کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے ... Async/انتظار اور وعدوں کے ساتھ کیچ کے بیان۔کوشش ... کیچ کے بیان کا استعمال ASYNC/انتظار کرتے وقت غیر متزلزل کوڈ میں پائے جانے والے غلطیوں کو پکڑنے کے لئے کیا جاتا ہے ، جبکہ کیچ () طریقہ استعمال کیا جاتا ہے جو وعدوں کا استعمال کرتے وقت غیر متزلزل کوڈ میں پائے جانے والے غلطیوں کو پکڑنے کے لئے استعمال ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں آبجیکٹ کی خصوصیات پر تکرار کرنے کے مختلف طریقے کیا ہیں؟ہر طریقہ کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹ میں آبجیکٹ کی خصوصیات پر تکرار کرنے کے بہت سارے طریقے ہیں۔یہاں کچھ عام طریقے ہیں: کیونکہ ... لوپ میں: لوپ میں ... لوپ ایک کنٹرول فلو بیان ہے جو آپ کو کسی شے کی خصوصیات پر تکرار کرنے کی اجازت دیتا ہے۔ہر تکرار میں ، لوپ متغیر پراپرٹی 123456 کے نام پر سیٹ کیا جاتا ہے۔[پروپ]) ؛} آبجیکٹ.کیز () طریقہ: آبجیکٹ.کیز () طریقہ کار کو شے کے اپنے قابل جائیداد کے ناموں کی ایک صف لوٹاتا ہے۔اس کا استعمال کسی آبجیکٹ 123456 کی خصوصیات پر تکرار کرنے کے لئے کیا جاسکتا ہے۔' + OBJ [prop]) ؛}) ؛ آبجیکٹ.اولیوز () طریقہ: آبجیکٹ.اولیوز () طریقہ کار کی اپنی پراپرٹی کی اقدار کی ایک صف لوٹاتا ہے۔اس کا استعمال کسی آبجیکٹ 123456 کی اقدار پر تکرار کرنے کے لئے کیا جاسکتا ہے۔) ؛ آبجیکٹ.انٹریز () طریقہ: آبجیکٹ.انٹریز () طریقہ کار کی اپنی پراپرٹی کلیدی قدر کے جوڑے کی اپنی ایک سرنی لوٹاتا ہے۔اس کا استعمال کسی آبجیکٹ 123456 کی خصوصیات اور اقدار پر تکرار کرنے کے لئے کیا جاسکتا ہے۔لاگ (پروپ + ':' + ویلیو) ؛}) ؛ خلاصہ یہ کہ ، جاوا اسکرپٹ میں آبجیکٹ کی خصوصیات سے زیادہ تکرار کرنے کے بہت سارے طریقے ہیں ، بشمول ... لوپ میں ، آبجیکٹ.کیز () طریقہ ، آبجیکٹ.ایلوز () طریقہ () طریقہ، اور آبجیکٹ.ٹریز () طریقہ۔ہر طریقہ کے اپنے فوائد اور نقصانات ہوتے ہیں ، اور طریقہ کا انتخاب پروگرام کی مخصوص ضروریات پر منحصر ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں اسپریڈ آپریٹر کے تصور کی وضاحت کریں اور یہ کس طرح سرنی ہیرا پھیری کے لئے استعمال کیا جاسکتا ہے۔",
        "Answer": "اسپریڈ آپریٹر جاوا اسکرپٹ ES6 میں آپریٹرز کے سیٹ میں ایک نیا اضافہ ہے۔اس کی نمائندگی تین نقطوں (…) کے ذریعہ کی جاتی ہے اور یہ کسی صف یا کسی شے کو کھولنے کے لئے استعمال ہوتا ہے۔اسپریڈ آپریٹر کو کئی طریقوں سے سرنی ہیرا پھیری کے لئے استعمال کیا جاسکتا ہے ، جیسا کہ ذیل میں بیان کیا گیا ہے: ضم کرنا صفوں: اسپریڈ آپریٹر کو دو یا زیادہ صفوں کو ایک ہی سرنی 123.const arr1 = [1 ، 2 ، 3] ؛ Const arr2 میں ضم کرنے کے لئے استعمال کیا جاسکتا ہے۔= [4 ، 5 ، 6] Cont Const wergedarr = [... arr1 ، ... arr2] ؛ کنسول.لوگ (مرجر) ؛// آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6] کلوننگ سرنی: اسپریڈ آپریٹر کو Array123.const arr1 = [1 ، 2 ، 3] کی اتلی کاپی بنانے کے لئے استعمال کیا جاسکتا ہے۔... arr1] ؛ کنسول.لوگ (کلونڈر) ؛// آؤٹ پٹ: [1 ، 2 ، 3] تاروں کو صفوں میں تبدیل کرنا: اسپریڈ آپریٹر کو تار کو کسی اری 1.const str = 'ہیلو' میں تبدیل کرنے کے لئے استعمال کیا جاسکتا ہے۔(arr) ؛// آؤٹ پٹ: ['H' ، 'E' ، 'L' ، 'L' ، 'O'] سیٹوں کو صفوں میں تبدیل کرنا: اسپریڈ آپریٹر کو سیٹ کو aray1.const سیٹ = نیا سیٹ (نیا سیٹ (نیا سیٹ تبدیل کرنے کے لئے استعمال کیا جاسکتا ہے[1 ، 2 ، 3]) ؛ Const arr = [... سیٹ] ؛ کنسول.لاگ (ARR) ؛// آؤٹ پٹ: [1 ، 2 ، 3] نوڈ کی فہرستوں کو سرنیوں میں تبدیل کرنا: اسپریڈ آپریٹر کو نوڈ کی فہرست کو کسی اری 1.const نوڈلسٹ = دستاویز میں تبدیل کرنے کے لئے استعمال کیا جاسکتا ہے۔.nodelist] ؛ کنسول.لوگ (ARR) ؛// آؤٹ پٹ: [پی ، پی ، پی ، ...] دلائل کو صفوں میں تبدیل کرنا: اسپریڈ آپریٹر کو دلائل آبجیکٹ کو کسی سرنی 1 میں تبدیل کرنے کے لئے استعمال کیا جاسکتا ہے۔کنسول.لاگ (آرگس) ؛} myfunction (1 ، 2 ، 3) ؛// آؤٹ پٹ: [1 ، 2 ، 3] خلاصہ یہ کہ ، جاوا اسکرپٹ میں اسپریڈ آپریٹر کو کئی طریقوں سے سرنی ہیرا پھیری کے لئے استعمال کیا جاسکتا ہے ، جس میں انضمام کرنے والی صفیں ، کلوننگ سرنی ، تبدیل کرنا ، تاروں کو تبدیل کرنا ، سیٹ ، نوڈ کی فہرستیں ، اور صفوں میں دلائل شامل ہیں۔اسپریڈ آپریٹر ایک طاقتور ٹول ہے جو کوڈ کو آسان بنا سکتا ہے اور اسے مزید جامع اور پڑھنے کے قابل بنا سکتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں مقامی اسٹوریج اور سیشن اسٹوریج کو کس طرح سنبھالتے ہیں؟لوکل اسٹوریج اور سیشن اسٹوریج آبجیکٹ کے استعمال کی وضاحت کریں۔",
        "Answer": "مقامی اسٹوریج اور سیشن اسٹوریج جاوا اسکرپٹ میں دو ویب اسٹوریج آبجیکٹ ہیں جو ڈویلپرز کو براؤزر میں کلیدی قدر کے جوڑے کو بچانے کی اجازت دیتے ہیں۔یہاں ان کا استعمال کیسے کیا جاسکتا ہے: 1۔مقامی اسٹوریج: لوکل اسٹورج آبجیکٹ ڈیٹا کو اسٹور کرتا ہے جس کی میعاد ختم ہونے کی تاریخ نہیں ہے۔جب براؤزر بند ہوجائے گا تو اعداد و شمار کو حذف نہیں کیا جائے گا اور اگلے دن ، ہفتہ ، یا سال 123 میں دستیاب ہوگا۔ لوکل اسٹوریج آبجیکٹ تمام جدید براؤزرز میں دستیاب ہے اور ونڈو آبجیکٹ 123 کی لوکل اسٹوریج پراپرٹی کا استعمال کرتے ہوئے اس تک رسائی حاصل کی جاسکتی ہے۔ لوکل اسٹوریج آبجیکٹ میں شامل ہے۔مندرجہ ذیل طریقے: سیٹ آئٹم () ، گیٹ آئٹم () ، ہٹانے والا آئٹم () ، اور واضح () 4123.localstorage.setitem ('نام' ، 'جان') ؛ const name = localstorage.getitem ('نام') ؛ لوکل اسٹوریج.رمو ویٹیم('نام') ؛ لوکل اسٹوریج۔ کلیئر () ؛ اس مثال میں ، ہم لوکل اسٹوریج آبجیکٹ کو ذخیرہ کرنے ، بازیافت ، ہٹانے اور صاف کرنے کے لئے استعمال کرتے ہیں۔سیشن اسٹوریج: سیشن اسٹوریج آبجیکٹ لوکل اسٹورج آبجیکٹ کی طرح ہے ، سوائے اس کے کہ جب صفحہ سیشن ختم ہوجائے تو سیشن اسٹوریج میں موجود ڈیٹا صاف ہوجاتا ہے۔ایک صفحہ سیشن اس وقت تک جاری رہتا ہے جب تک ٹیب یا براؤزر کھلا ہوا ہے اور صفحہ دوبارہ لوڈ اور بحالی 523 پر زندہ رہتا ہے۔ سیشن اسٹوریج آبجیکٹ تمام جدید براؤزرز میں دستیاب ہے اور ونڈو آبجیکٹ 523 کی سیشن اسٹوریج پراپرٹی کا استعمال کرتے ہوئے اس تک رسائی حاصل کی جاسکتی ہے۔ سیشن اسٹوریج آبجیکٹ میں وہی شامل ہے۔لوکل اسٹوریج آبجیکٹ کے طور پر طریقے: سیٹ آئٹم () ، گیٹ آئٹم () ، ہٹانے والا آئٹم () ، اور واضح () 523.sessionstorage.setitem ('نام' ، 'جان') ؛ const name = سیشن اسٹوریج.جیٹ آئٹم ('نام') ؛ سیشن اسٹوریج.removeitem ('نام') Sound سیشن اسٹوریج.لیئر () ؛ اس مثال میں ، ہم سیشن اسٹوریج آبجیکٹ کو اسٹور ، بازیافت ، ہٹانے اور صاف کرنے کے لئے استعمال کرتے ہیں۔ڈویلپرز کو براؤزر میں کلیدی قدر کے جوڑے بچانے کی اجازت دیں۔لوکل اسٹوریج آبجیکٹ ڈیٹا کو بغیر کسی میعاد ختم ہونے کی تاریخ کے ذخیرہ کرتا ہے ، جب کہ صفحہ سیشن ختم ہونے پر سیشن اسٹوریج آبجیکٹ ڈیٹا کو صاف کرتا ہے۔دونوں اشیاء میں ایک ہی طریقے شامل ہیں: سیٹ آئٹم () ، گیٹ آئٹم () ، ہٹانے والا آئٹم () ، اور واضح ()۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں ہم آہنگی اور غیر متزلزل کوڈ میں کیا فرق ہے؟ہر ایک کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹینکرونس اور اسینکرونس کوڈ میں ہم آہنگی اور غیر متزلزل کوڈ جاوا اسکرپٹ میں کوڈ کو چلانے کے دو طریقے ہیں۔ان کے مابین اختلافات یہ ہیں: ہم وقت ساز کوڈ: ہم وقت ساز کوڈ ترتیب میں چلتا ہے ، اس کا مطلب یہ ہے کہ ہر آپریشن کو پھانسی دینے سے پہلے پچھلے ایک کو مکمل ہونے کا انتظار کرنا ہوگا۔مطابقت پذیری کوڈ اس وقت تک پروگرام پر عمل درآمد کو روکتا ہے جب تک کہ موجودہ آپریشن 123456.console.log ('ایک') ؛ کنسول.لوگ ('دو') ؛ کنسول.لوگ ('تین') ؛ // آؤٹ پٹ: 'ایک' ،'دو' ، 'تھری'سینکرونس کوڈ: متوازی کوڈ متوازی طور پر چلتا ہے ، اس کا مطلب یہ ہے کہ آپریشن ہوسکتا ہے جبکہ کسی اور پر کارروائی کی جارہی ہے۔غیر متزلزل کوڈ پروگرام کی نفاذ کو مسدود نہیں کرتا ہے اور دیگر کارروائیوں کو چلانے کی اجازت دیتا ہے جبکہ موجودہ آپریشن پر کارروائی کی جارہی ہے۔؛ کنسول.لوگ ('تین') ؛ // آؤٹ پٹ: 'ایک' ، 'تین' ، 'دو' اس مثال کے طور پر ، سیٹ ٹائم آؤٹ () فنکشن غیر متزلزل کوڈ کی ایک مثال ہے۔کنسول.لاگ ('دو') کے بیان کو 100 ملی سیکنڈ کی تاخیر کے بعد عمل میں لایا جاتا ہے ، جبکہ دیگر بیانات کو فوری طور پر عمل میں لایا جاتا ہے۔ ان حالات میں غیر یقینی کوڈ پر عمل درآمد اکثر افضل ہوتا ہے جہاں عملدرآمد کو غیر معینہ مدت تک روکا جاسکتا ہے۔اس کی کچھ مثالوں میں نیٹ ورک کی درخواستیں ، طویل عرصے سے چلنے والے حساب کتاب ، فائل سسٹم کی کارروائیوں ، وغیرہ ہیں۔ براؤزر میں غیر متزلزل کوڈ کا استعمال کرتے ہوئے یہ یقینی بناتا ہے کہ صفحہ جوابدہ ہے اور صارف کا تجربہ زیادہ تر متاثر نہیں ہوتا ہے۔موجودہ آپریشن مکمل ہونے تک پروگرام کا ، جبکہ غیر متزلزل کوڈ متوازی طور پر چلتا ہے اور دیگر آپریشنوں کو چلانے کی اجازت دیتا ہے جبکہ موجودہ آپریشن پر کارروائی کی جارہی ہے۔ہم وقت ساز اور غیر متزلزل کوڈ کے مابین اختلافات کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے اہم ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں فنکشن کرینگ کے تصور کی وضاحت کریں اور اسے دوبارہ استعمال کے قابل فنکشن فیکٹریوں کو بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ فانکشن میں فنکشن کرینگ جاوا اسکرپٹ میں ایک ایسی تکنیک ہے جو ڈویلپرز کو ایک فنکشن کو توڑ کر دوبارہ قابل استعمال فنکشن فیکٹریوں کو بنانے کی اجازت دیتی ہے جو متعدد دلائل کو افعال کی ایک سیریز میں لے جاتی ہے جس میں ہر ایک صرف ایک دلیل لیتا ہے۔نتیجے میں آنے والے افعال کو پہلے سے سیٹ دلائل کے ساتھ نئے افعال پیدا کرنے کے لئے استعمال کیا جاسکتا ہے ، جس سے کوڈ کو دوبارہ استعمال کرنا اور تکرار 123456 کو کم کرنا آسان ہوجاتا ہے۔ دوبارہ استعمال کے قابل فنکشن فیکٹری بنانے کے لئے فنکشن کرینگ کو کس طرح استعمال کیا جاسکتا ہے: فنکشن ضرب (x) {واپسیفنکشن (y) {x * y ؛} ؛} کنسٹ ڈبل = ضرب (2) ؛ Const ٹرپل = ضرب (3) ؛ کنسول.لوگ (ڈبل (5)) ؛// آؤٹ پٹ: 10console.log (ٹرپل (5)) ؛// آؤٹ پٹ: 15 اس مثال کے طور پر ، ہم دوبارہ قابل استعمال فنکشن فیکٹری بنانے کے لئے فنکشن کرینگ کا استعمال کرتے ہیں جو پہلے سے طے شدہ قیمت سے ایک نمبر کو بڑھاتا ہے۔ضرب () فنکشن ایک نمبر X لیتا ہے اور ایک نیا فنکشن لوٹاتا ہے جو دوسرا نمبر y لیتا ہے اور اسے ایکس کے ذریعہ ضرب دیتا ہے۔اس کے بعد ہم ضرب () فنکشن کو دو نئے افعال پیدا کرنے کے لئے استعمال کرتے ہیں ، ڈبل اور ٹرپل ، جو بالترتیب 2 اور 3 کی تعداد کو ضرب دیتے ہیں۔ فنکشن کرینگ ایک طاقتور تکنیک ہے جسے دوبارہ استعمال کے قابل فنکشن فیکٹریوں کو بنانے اور کوڈ میں تکرار کو کم کرنے کے لئے استعمال کیا جاسکتا ہے۔کسی ایسے فنکشن کو توڑنے سے جو متعدد دلائل کو ایک سلسلہ میں لے جاتا ہے جس میں ہر ایک صرف ایک ہی دلیل لیتا ہے ، ڈویلپر پہلے سے سیٹ دلائل کے ساتھ نئے افعال تشکیل دے سکتے ہیں ، جس سے کوڈ کو دوبارہ استعمال کرنا اور تکرار کو کم کرنا آسان ہوجاتا ہے۔ خلاصہ یہ ہے کہ ، فنکشن کرینگ ایک تکنیک ہے۔جاوا اسکرپٹ میں جو ڈویلپرز کو کسی ایسے فنکشن کو توڑ کر دوبارہ قابل استعمال فنکشن فیکٹریوں کو بنانے کی اجازت دیتا ہے جو متعدد دلائل کو افعال کی ایک سیریز میں لے جاتا ہے جس میں سے ہر ایک صرف ایک ہی دلیل لیتا ہے۔نتیجے میں آنے والے افعال کو پہلے سے سیٹ دلائل کے ساتھ نئے افعال پیدا کرنے کے لئے استعمال کیا جاسکتا ہے ، جس سے کوڈ کو دوبارہ استعمال کرنا اور تکرار کو کم کرنا آسان ہوجاتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کراس-ارگین ریسورس شیئرنگ (CORS) کو کس طرح سنبھالتے ہیں؟CORS ہیڈر اور CORS- قابل درخواستوں کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ کراس اوریگین ریسورس شیئرنگ (CORS) میں کراس اوریگین ریسورس شیئرنگ (CORS) ویب براؤزرز میں ایک حفاظتی خصوصیت ہے جو ویب صفحات کو ویب پیج کی خدمت کے مقابلے میں کسی مختلف ڈومین میں درخواستوں کو درخواست دینے سے روکتی ہے۔کارس کو براؤزر کے ذریعہ نافذ کیا جاتا ہے ، جو سرور کو سرور کو HTTP ہیڈروں کا ایک سیٹ بھیجتا ہے تاکہ اس بات کا تعین کیا جاسکے کہ سرور کو درخواست کی اجازت دینی چاہئے یا نہیں۔جاوا اسکرپٹ میں CORS کو کس طرح سنبھالا جاسکتا ہے: 1۔CORS ہیڈر: CORS ہیڈر HTTP ہیڈر ہیں جو سرور کو اس بات کی نشاندہی کرنے کی اجازت دیتے ہیں کہ کون سے ڈومینز ، اسکیموں ، یا بندرگاہوں کو اس کے وسائل 123456 تک رسائی حاصل کرنے کی اجازت ہے۔ رسائی کنٹرول-الل وورن ہیڈر کو یہ بتانے کے لئے استعمال کیا جاتا ہے کہ کون سے ڈومینز کو سرور کے وسائل 123456 تک رسائی حاصل کرنے کی اجازت ہے۔.سیس کنٹرول-الو-میتھوڈس ہیڈر کا استعمال یہ بتانے کے لئے کیا جاتا ہے کہ ریسورس 123456 کے لئے کون سے HTTP طریقوں کی اجازت ہے۔اصلیت: *رسائی کنٹرول-الو کے طریقہ کار: حاصل کریں ، پوسٹ کریں ، پوٹ ، ڈیلیٹیکیس-کنٹرول-آبی ہیڈر: مواد کی قسم کی اس مثال کے طور پر ، رسائی کنٹرول الل وورن ہیڈر کسی بھی ڈومین کو سرور کے وسائل تک رسائی حاصل کرنے کی اجازت دیتا ہے ، جبکہایکسیس کنٹرول الل ویلی میٹوڈس ہیڈر حاصل کرنے ، پوسٹ ، ڈالنے اور طریقوں کو حذف کرنے کی اجازت دیتا ہے۔ایکسیس کنٹرول الل وے ہیڈرز ہیڈر مواد کی قسم کے ہیڈر 2 کی اجازت دیتا ہے۔CORS- قابل درخواستوں: CORS- قابل درخواستوں کی درخواستیں ایسی درخواستیں ہیں جن میں اصل ہیڈر شامل ہوتا ہے ، جو ڈومین کی وضاحت کرتا ہے جو درخواست 123456 بنا رہا ہے۔ اس کے بعد سرور تک رسائی کے کنٹرول-اللو اورجین ہیڈر کا استعمال کرسکتا ہے تاکہ درخواست 123456.Cors.orsors.cors.ors.ors.ors.ors.ors.cunterollollow-origin ہیڈر کو استعمال کیا جاسکتا ہے۔قابل درخواست کی درخواستیں XMLHTTPREQUEST آبجیکٹ یا بازیافت () طریقہ 123456.Const XHR = نیا XMLHTTPREQUEST () ؛ XHR.open ('get' ، 'https://api.example.com/data') ؛ ایکس ایچ آر کا استعمال کرتے ہوئے کی جاسکتی ہیں۔setRequestHeader ('اصلیت' ، 'https://example.com') ؛ xhr.onload = فنکشن () {کنسول.لوگ (xhr.responsetext) ؛} ؛ xhr.send () ؛ اس مثال میں ، ہم xmlhtprequest استعمال کرتے ہیںکسی API کو CORS- قابل بنانے کی درخواست کرنے پر اعتراض کریں۔ہم نے اصل ہیڈر کو https://example.com پر سیٹ کیا کہ اس ڈومین کی وضاحت کے لئے جو درخواست دے رہا ہے۔ خلاصہ یہ ہے کہ ، کراس اوریگین ریسورس شیئرنگ (CORS) ویب براؤزرز میں ایک حفاظتی خصوصیت ہے جو ویب صفحات کو A سے درخواستیں دینے سے روکتی ہے۔ویب پیج کی خدمت کرنے والے سے مختلف ڈومین۔CORS ہیڈر اور CORS- قابل درخواستوں کا استعمال کرتے ہوئے جاوا اسکرپٹ میں CORs کو سنبھالا جاسکتا ہے۔CORS ہیڈر HTTP ہیڈر ہیں جو سرور کو اس بات کی نشاندہی کرنے کی اجازت دیتے ہیں کہ کون سے ڈومینز ، اسکیموں یا بندرگاہوں کو اس کے وسائل تک رسائی حاصل کرنے کی اجازت ہے ، جبکہ CORS- قابل درخواستوں میں ڈومین کی وضاحت کرنے کے لئے اصل ہیڈر شامل ہے جو درخواست دے رہا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں واقعہ سے چلنے والی پروگرامنگ کیا ہے؟ایونٹ کے سننے والوں اور ایونٹ کے اخراج کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ ایونٹ سے چلنے والے پروگرامنگ میں واقعہ سے چلنے والی پروگرامنگ ایک پروگرامنگ نمونہ ہے جو واقعات اور ان سے وابستہ افعال کو سنبھالنے پر مرکوز ہے۔اس نمونہ میں ، پروگرام کے بہاؤ کا تعین صارف کے تعامل ، سینسر آؤٹ پٹ ، یا دوسرے پروگراموں یا تھریڈس 123456 کے پیغامات جیسے واقعات سے ہوتا ہے۔جاوا اسکرپٹ میں ، ایونٹ سے چلنے والی پروگرامنگ خاص طور پر صارف کے انٹرفیس کے لئے مناسب ہے ، جہاں صارف کے اقدامات پروگرام کے بہاؤ کا تعین کرتے ہیں۔ ایونٹ کے سامعین اور ایونٹ ایمیٹرین جاوا اسکرپٹ کا استعمال ، ایونٹ کے سننے والوں اور ایونٹ ایمیٹرز کو واقعات اور ان سے وابستہ افعال کو سنبھالنے کے لئے استعمال کیا جاتا ہے۔سننے والے سامعین: ایونٹ کے سننے والے ایسے کام ہوتے ہیں جو کسی خاص واقعہ کے پیش آنے پر کہتے ہیں۔جب ایونٹ واقع ہوتا ہے تو وہ واقعات کو سننے اور اعمال انجام دینے کے لئے استعمال ہوتے ہیں۔) ؛ اس مثال میں ، ہم ایک بٹن عنصر میں واقعہ سننے والے کو شامل کرنے کے لئے ایڈونٹ لسٹنر () کا طریقہ استعمال کرتے ہیں۔واقعہ سننے والا ایک فنکشن ہے جسے بٹن پر کلک کرنے پر کہا جاتا ہے۔ Emitters: ایونٹ ایمیٹرز ایسی چیزیں ہیں جو واقعات کو خارج کرتی ہیں جب کوئی خاص عمل ہوتا ہے۔جب ایونٹ واقع ہوتا ہے تو وہ واقعات کو متحرک کرنے اور سننے والوں کو مطلع کرنے کے لئے استعمال ہوتے ہیں۔واقع ہوا ') ؛}) ؛ myemitter.emit (' واقعہ ') ؛ اس مثال میں ، ہم ایک نیا واقعہ ایمیٹر آبجیکٹ بنانے کے لئے ایونٹ میٹٹر کلاس کا استعمال کرتے ہیں۔اس کے بعد ہم واقعہ کے پروگرام میں ایونٹ سننے والوں کو شامل کرنے کے لئے آن () طریقہ استعمال کرتے ہیں۔آخر میں ، ہم ایونٹ () کے طریقہ کار کو ایونٹ کے واقعہ کو متحرک کرنے اور سننے والوں کو مطلع کرنے کے لئے استعمال کرتے ہیں۔ خلاصہ میں ، واقعہ سے چلنے والی پروگرامنگ ایک پروگرامنگ نمونہ ہے جو واقعات اور ان سے وابستہ افعال کو سنبھالنے پر مرکوز ہے۔جاوا اسکرپٹ میں ، ایونٹ کے سامعین اور ایونٹ ایمیٹرز واقعات اور ان سے وابستہ افعال کو سنبھالنے کے لئے استعمال ہوتے ہیں۔واقعہ کے سننے والے ایسے کام ہوتے ہیں جن کو کسی خاص واقعہ کے پیش آنے پر کہا جاتا ہے ، جبکہ ایونٹ کے اخراجات ایسی چیزیں ہیں جو کسی خاص کارروائی کے واقع ہونے پر واقعات کا اخراج کرتی ہیں۔متحرک ، انٹرایکٹو ویب ایپلی کیشنز کی تشکیل کے لئے ایونٹ کے سننے والوں اور ایونٹ ایمیٹرز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں تاریخ اور وقت کو کس طرح سنبھالتے ہیں؟تاریخ آبجیکٹ کے استعمال اور عام تاریخ میں ہیرا پھیری کے طریقوں کی وضاحت کریں۔",
        "Answer": "ہینڈلنگ کی تاریخ اور وقت جاوا اسکرپٹین جاوا اسکرپٹ میں ، تاریخ کا آبجیکٹ تاریخ اور وقت کے ساتھ کام کرنے کے لئے استعمال ہوتا ہے۔تاریخ کا آبجیکٹ موجودہ تاریخ اور وقت UTC میں اندرونی طور پر رکھتا ہے۔تاہم ، پہلے سے طے شدہ طور پر ، جب ہم تاریخ اور وقت کو آؤٹ پٹ کرتے ہیں تو ، تاریخ کا آبجیکٹ آؤٹ پٹ کو مقامی ٹائم زون میں تبدیل کرتا ہے ، ماحول کا ٹائم زون جہاں جاوا اسکرپٹ کوڈ چل رہا ہے (جیسے ، ایک براؤزر ، نوڈ۔ جے ایس ، وغیرہ)جب پیرامیٹرز کے بغیر انسٹینٹ کیا جاتا ہے تو ، تاریخ آبجیکٹ موجودہ تاریخ اور وقت (نئی تاریخ () موجودہ تاریخ رکھتا ہے) رکھتا ہے۔ہم تاریخ کے کنسٹرکٹر میں یا انسٹیٹیوٹیشن 12 کے بعد تاریخ اور وقت طے کرسکتے ہیں۔ یہاں تاریخ میں ہیرا پھیری کے کچھ عام طریقے ہیں: getlyear (): مقامی وقت کے مطابق مخصوص تاریخ کے سال (4 ہندسوں کے 4 ہندسے) کو واپس کرتا ہے۔تاریخ = نئی تاریخ () const کانسٹ سال = تاریخ۔ گیٹلیئر () ؛ کنسول.لاگ (سال) ؛// آؤٹ پٹ: 2023GETMONTH (): مقامی وقت کے مطابق مخصوص تاریخ کا مہینہ (0-11) واپس کرتا ہے۔// آؤٹ پٹ: 5 گیٹ ڈیٹ (): مقامی وقت کے مطابق مخصوص تاریخ کے لئے مہینے کے دن (1-31) کی واپسی۔) ؛// آؤٹ پٹ: 22 گیٹ ڈے (): مقامی وقت کے مطابق مخصوص تاریخ کے لئے ہفتے کے دن (0-6) کی واپسی۔) ؛// آؤٹ پٹ: 4 گیٹھورس (): مقامی وقت کے مطابق مخصوص تاریخ میں گھنٹہ (0-23) لوٹاتا ہے۔ کونسٹ تاریخ = نئی تاریخ () ؛ کانسٹر گھنٹے = تاریخ.جیتھورس () ؛ کنسول.لاگ (گھنٹے) ؛// آؤٹ پٹ: 14 گیٹ منٹس (): مقامی وقت کے مطابق مخصوص تاریخ میں منٹ (0-59) واپس کرتا ہے۔// آؤٹ پٹ: 30 گیٹ سیکنڈ (): مقامی وقت کے مطابق مخصوص تاریخ میں سیکنڈ (0-59) واپس کرتا ہے۔// آؤٹ پٹ: 45in کا خلاصہ ، تاریخ آبجیکٹ جاوا اسکرپٹ میں تاریخ اور وقت کے ساتھ کام کرنے کے لئے استعمال ہوتا ہے۔عام تاریخ میں ہیرا پھیری کے طریقوں میں getllyear () ، getMonth () ، getDate () ، getday () ، gethours () ، getminutes () ، اور getsecond () شامل ہیں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے تاریخوں اور اوقات کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے کیلنڈرز ، نظام الاوقات ، اور الٹی گنتی ٹائمر ۔1dd2mozilla"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک ایسی تکنیک ہے جس میں مہنگے فنکشن کالوں کے نتائج کو کیچنگ کرنا اور جب وہی آدانوں کے دوبارہ ہونے پر ان کو واپس کرنا شامل ہے۔یہ تکنیک پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹنے کے لئے 123456۔موسیائزیشن کو فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے: فنکشن فبونیکی (این) {اگر (n <= 1) {واپسی n ؛} واپس fibonacci (n - 1) + fibonacci (n - 2) ؛} فنکشن میموئز (fn) {const cache = {} ؛واپسی فنکشن (... آرگس) {اگر (کیشے [آرگس]) {واپس کیشے [آرگس] ؛} کانسٹنگ کا نتیجہ = fn.apply (یہ ، آرگس) ؛کیشے [آرگس] = نتیجہ ؛واپسی کا نتیجہ ؛} ؛} constimeizedfibonacci = memoize (fibonacci) ؛ کنسول.لوگ (میموئزڈفیبونیکی (10)) ؛// آؤٹ پٹ: 555 اس مثال کے طور پر ، ہم Fibonacci () فنکشن کو بہتر بنانے کے لئے میموائزیشن کا استعمال کرتے ہیں ، جو Fibonacci ترتیب میں NTH نمبر کا حساب لگاتا ہے۔میموئز () فنکشن ایک دلیل کے طور پر ایک فنکشن لیتا ہے اور ایک نیا فنکشن لوٹاتا ہے جو اصل فنکشن کے نتائج کو کیچ کرتا ہے۔کیشڈ نتائج کسی شے میں محفوظ کیے جاتے ہیں جسے کیشے کہتے ہیں۔جب یادگار فنکشن کو ایک ہی دلائل کے ساتھ دوبارہ بلایا جاتا ہے تو ، یہ اس کی دوبارہ گنتی کے بجائے کیچڈ نتیجہ کو لوٹاتا ہے۔ یادداشت ایک طاقتور تکنیک ہے جو ایپلی کیشنز کی کارکردگی کو نمایاں طور پر بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے۔مہنگے فنکشن کالز کے نتائج کو حاصل کرنے اور ان کو واپس کرنے سے جب وہی آدانوں کو دوبارہ پیش کیا جاتا ہے تو ، میموائزیشن پروسیسنگ کے وقت کو کم کرسکتی ہے اور صارف کے تجربے کو بہتر بنا سکتی ہے۔ خلاصہ میں ، یادداشت جاوا اسکرپٹ میں ایک ایسی تکنیک ہے جس میں مہنگے فنکشن کالز کے نتائج کو کیچ کرنا اور ان کو واپس کرنا شامل ہے۔جب وہی آدانوں کو دوبارہ ہوتا ہے۔میمورائزیشن کو فنکشن پر عمل درآمد کو بہتر بنانے اور ایپلی کیشنز کی کارکردگی کو نمایاں طور پر بہتر بنانے کے لئے استعمال کیا جاسکتا ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقے 123456 کا استعمال کرتے ہوئے کوکیز کو سنبھالا جاسکتا ہے۔ کوکیز کو سنبھالنے کے لئے دستاویزات کوکی پراپرٹی کو کس طرح استعمال کریں: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز کو کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری 123456.docament.cookie = \"صارف نام = جان ڈو ؛ میعاد ختمیاں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جسے سیمیولونز 123456.CONST کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز ڈاٹ کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں طے کریں۔مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹین جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق ، مساوات کی جانچ پڑتال کے لئے دو موازنہ آپریٹرز ہیں: == اور ===۔اگرچہ دونوں آپریٹرز مساوات کے ل two دو اقدار کا موازنہ کرنے کے لئے استعمال ہوتے ہیں ، ان کے درمیان ایک خاص فرق ہے: ڈبل برابر (==) آپریٹر: ڈبل برابر آپریٹر ایک تجریدی مساوات کا موازنہ آپریٹر ہے۔یہ مساوات کے ل two دو اقدار کا موازنہ ایک عام قسم میں تبدیل کرنے کے بعد کرتا ہے۔اگر اقدار مختلف اقسام کی ہیں تو ، جاوا اسکرپٹ موازنہ 123456.console.log (2 == \"2\") بنانے سے پہلے ایک یا دونوں اقدار کو ایک عام قسم میں تبدیل کرنے کی کوشش کرتا ہے۔// آؤٹ پٹ: trueconsole.log (0 == \"\") ؛// آؤٹ پٹ: trueconsole.log (null == غیر متعینہ) ؛// آؤٹ پٹ: یہ مثال کے طور پر ، ڈبل برابر آپریٹر درست واپس آجاتا ہے کیونکہ موازنہ ہونے سے پہلے 2 کو اسٹرنگ \"2\" میں تبدیل کیا جاتا ہے۔ ٹرپل برابر (===) آپریٹر: ٹرپل برابر آپریٹر ایک سخت مساوات موازنہ آپریٹر ہےیہ ان کی اقسام کو تبدیل کیے بغیر مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔اگر اقدار مختلف اقسام کی ہیں تو ، موازنہ غلط 123456.console.log (2 === \"2\") لوٹاتا ہے۔// آؤٹ پٹ: falseconsole.log (0 === \"\") ؛// آؤٹ پٹ: falseconsole.log (null === غیر متعینہ) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ٹرپل کے برابر آپریٹر غلط کو لوٹاتا ہے کیونکہ اوپریینڈ کے ڈیٹا کی اقسام مختلف ہیں۔ خلاصہ یہ کہ ڈبل برابر آپریٹر ایک خلاصہ مساوات کا موازنہ آپریٹر ہے جو مساوات کے لئے دو اقدار کو عام قسم میں تبدیل کرنے کے بعد موازنہ کرتا ہے۔، جبکہ ٹرپل برابر آپریٹر ایک سخت مساوات کا موازنہ آپریٹر ہے جو ان کی اقسام کو تبدیل کیے بغیر مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ان دونوں آپریٹرز کے مابین اختلافات کو سمجھنا ضروری ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جاوا اسکرپٹ اور آبجیکٹ وراثت میں جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ ، پروٹو ٹائپ آبجیکٹ ہر شے کی ایک پوشیدہ پراپرٹی ہے جو اس کے پروٹو ٹائپ نامی کسی اور شے سے لنک رکھتی ہے۔پروٹو ٹائپ آبجیکٹ کا اپنا ایک پروٹو ٹائپ ہے ، اور اسی طرح جب تک کسی چیز کو اس کے پروٹو ٹائپ کے طور پر کالعدم کے ساتھ نہیں پہنچ جاتا ہے۔یہ پروٹو ٹائپ چین 123456 کے نام سے جانا جاتا ہے۔ جب کوئی شے تیار کی جاتی ہے تو ، اس کو اس کے پروٹو ٹائپ آبجیکٹ سے خصوصیات اور طریقے وراثت میں ملتے ہیں۔اسے آبجیکٹ وراثت کے نام سے جانا جاتا ہے۔اگر کسی پراپرٹی یا طریقہ کار پر ہی کوئی چیز نہیں ملتی ہے تو ، جاوا اسکرپٹ پروٹو ٹائپ چین کو اس وقت تک دیکھتا ہے جب تک کہ اسے پراپرٹی یا طریقہ کار یا طریقہ کار نہ مل جائے۔ اس کی ایک مثال ہے کہ پروٹوٹائپ آبجیکٹ کو آبجیکٹ کی وراثت کے لئے کس طرح استعمال کیا جاسکتا ہے: فنکشن شخص (نام ، عمر) {this.name = نام ؛this.age = عمر ؛} شخصی۔ پروٹوٹائپ۔ گریٹ = فنکشن () {کنسول.لاگ (`ہیلو ، میرا نام $ {یہ ہے۔ نام} اور میں $ {this.age} سال کی عمر میں ہوں۔)} ؛}؛ فنکشن طالب علم (نام ، عمر ، میجر) {شخص۔ کال (یہ ، نام ، عمر) ؛this.major =} طالب علم.پروٹوٹائپ = آبجیکٹ.کریٹ (شخص.پروٹوٹائپ) ؛ طالب علم.پروٹوٹائپ.کونٹرکٹر = طالب علم ؛ طالب علم.پروٹائپ۔ اسٹوڈی = فنکشن () {کنسول.لوگ (`میں مطالعہ کر رہا ہوں $ {یہ اس کا مطالعہ کر رہا ہوں.major} .`) ؛} ؛ کانسٹ جان = نیا طالب علم ('جان' ، 20 ، 'کمپیوٹر سائنس') John جان.گریٹ () ؛// آؤٹ پٹ: 'ہیلو ، میرا نام جان ہے اور میں 20 سال کا ہوں۔// آؤٹ پٹ: 'میں کمپیوٹر سائنس کا مطالعہ کر رہا ہوں۔' اس مثال میں ، ہم ایک شخص کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو ایک نام اور عمر پیرامیٹر لیتا ہے۔ہم شخصی پروٹو ٹائپ آبجیکٹ میں ایک مبارکباد () طریقہ شامل کرتے ہیں۔اس کے بعد ہم ایک طالب علم کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو ایک نام ، عمر اور ایک اہم پیرامیٹر لیتا ہے۔ہم کال () کا طریقہ استعمال کرتے ہیں تاکہ اس کلیدی لفظ کو طالب علم آبجیکٹ پر سیٹ کیا جائے۔اس کے بعد ہم ایک نیا اسٹوڈنٹ پروٹوٹائپ آبجیکٹ بناتے ہیں جو آبجیکٹ کا استعمال کرتے ہوئے شخصی پروٹو ٹائپ آبجیکٹ سے وراثت میں ملتا ہے۔ کریٹ () طریقہ۔آخر میں ، ہم طلباء کے پروٹو ٹائپ آبجیکٹ میں ایک مطالعہ () کا طریقہ شامل کرتے ہیں۔ خلاصہ ، پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ میں ہر شے کی ایک پوشیدہ پراپرٹی ہے جس میں کسی اور شے کا لنک ہے جس کو اس کے پروٹو ٹائپ کہا جاتا ہے۔پروٹوٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جہاں کوئی شے اس کے پروٹو ٹائپ آبجیکٹ سے خصوصیات اور طریقوں کو وراثت میں ملتی ہے۔جاوا اسکرپٹ میں پیچیدہ ، آبجیکٹ پر مبنی ایپلی کیشنز بنانے کے لئے پروٹو ٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کو لوپ کے لئے بہاؤ کا استعمال کرتے ہوئے نافذ کیا جاتا ہے ، جو لوپ 123456 کے لئے ایک متضاد ورژن ہے۔ یہاں اسنکرونس فنکشن کو سنبھالنے کے لئے اوور آف لوپ کو کس طرح استعمال کرنے کی ایک مثال ہے: async فنکشن* asyncgenerator (){پیداوار 1 ؛پیداوار 2 ؛پیداوار 3 ؛} async فنکشن مین () wait انتظار کے لئے (asyncgenerator ()) {console.log (قدر) ؛}}مرکزی()؛// آؤٹ پٹ: 1 ، 2 ، 3 میں اس مثال کے طور پر ، ہم ایک غیر متزلزل جنریٹر فنکشن کی وضاحت کرتے ہیں جس کو asyncgenerator () کہا جاتا ہے جس سے تین اقدار ملتی ہیں۔اس کے بعد ہم ایک Async فنکشن کی وضاحت کرتے ہیں جس کو مین () کہتے ہیں جو asyncgenerator () کے ذریعہ حاصل کردہ اقدار پر تکرار کرنے کے لئے بہاؤ کے لوپ کا استعمال کرتا ہے۔اگلی قیمت پر جانے سے پہلے ہر قیمت کو حل کرنے کے لئے لوپ کے لئے انتظار کے انتظار میں۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ لوٹاتا ہے اور کیا جاتا ہے۔ خلاصہ میں ، اسینکرونس تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو ترتیب وار اعداد و شمار کے ذرائع کو ترتیب دینے کی اجازت دیتا ہے۔غیر متزلزل تکرار کا اطلاق لوپ کے لئے اوور آف لوپ کا استعمال کرتے ہوئے کیا جاتا ہے ، جو لوپ کا ایک متضاد ورژن ہے۔غیر محفوظ لوپ کا استعمال ان چیزوں پر تکرار کرنے کے لئے کیا جاتا ہے جو اسینکرونوس ایٹریشن پروٹوکول کو نافذ کرتے ہیں ، جس کے لئے اس چیز کی ضرورت ہوتی ہے جس میں ایک [علامت.اسائٹریٹر] طریقہ ہوتا ہے جو ایک غیر متزلزل Iterator آبجیکٹ کو واپس کرتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی مختلف اقسام یہ ہیں: نحو کی خرابی: نحو کی غلطیاں اس وقت ہوتی ہیں جب جاوا اسکرپٹ کوڈ کو صحیح طریقے سے نہیں لکھا جاتا ہے ، جیسے گمشدہ بریکٹ ، سیمیکولون یا قوسین۔تالیف کے مرحلے کے دوران جاوا اسکرپٹ انجن کے ذریعہ نحو کی غلطیوں کا پتہ چلتا ہے اور کوڈ کو رننگ 123456.console.log ('ہیلو ، ورلڈ!' 'سے روکتا ہے۔لیکن اعلان نہیں کیا گیا ہے یا اس سے باہر نہیں ہے۔ عملدرآمد کے مرحلے کے دوران حوالہ کی غلطیوں کا پتہ لگایا جاتا ہے اور کوڈ کو رننگ 123456.console.log (فو) سے روکتا ہے۔متوقع قسم کا نہیں ہے ، جیسے کسی غیر متعینہ متغیر پر کسی طریقہ کو کال کرنے کی کوشش کرنا۔ عمل کے مرحلے کے دوران قسم کی غلطیوں کا پتہ لگایا جاتا ہے اور کوڈ کو رننگ 123456.const فو = غیر متعینہ ؛ foo.touppercase () ؛ // قسم کی خرابی سے روکتا ہے۔غیر متعینہ طور پر غلطی پر ٹوپپر کیس () کو کال نہیں کرسکتے ہیں: رینج کی غلطیاں اس وقت ہوتی ہیں جب کوئی قیمت متوقع حد کے اندر نہیں ہوتی ہے ، جیسے منفی لمبائی کے ساتھ سرے بنانے کی کوشش کرنا۔ عملدرآمد کے مرحلے کے دوران رینج کی غلطیوں کا پتہ لگایا جاتا ہے اور کوڈ کو رننگ 123456.NEW سے روکا جاتا ہے۔سرنی (-1) ؛// رینج کی خرابی: غلط سرنی لمبائی سے متعلق غلطی: تشخیص کی غلطیاں اس وقت ہوتی ہیں جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے ، جیسے جاوا اسکرپٹ کوڈ کے غلط تار کو گزرنا۔تالیف کے مرحلے کے دوران تشخیصی غلطیوں کا پتہ لگایا جاتا ہے اور کوڈ کو رننگ 6. یو آر آئی کی غلطی سے روکتا ہے: یو آر آئی کی غلطیاں اس وقت ہوتی ہیں جب عالمی سطح پر یو آر آئی ہینڈلنگ فنکشن غلط طریقے سے استعمال ہوتا ہے ، جیسے انکوڈوری () یا ڈیکوڈوری () افعال کو غلط یو آر آئی کے تار کو منتقل کرنا۔عملدرآمد کے مرحلے کے دوران یو آر آئی کی غلطیوں کا پتہ لگایا جاتا ہے اور کوڈ کو رننگ 5 سے روکتا ہے۔ اندرونی غلطی: داخلی غلطیاں اس وقت ہوتی ہیں جب جاوا اسکرپٹ انجن کو داخلی غلطی کا سامنا کرنا پڑتا ہے ، جیسے میموری یا اسٹیک کی جگہ ختم ہوجاتی ہے۔عملدرآمد کے مرحلے کے دوران داخلی غلطیوں کا پتہ لگایا جاتا ہے اور کوڈ کو چلانے سے روکتا ہے۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔دوسرے لفظوں میں ، میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے حساب شدہ نتائج کو اسٹور کرکے اور ان کو واپس کرنے کی بجائے اس کو واپس کرنے کی بجائے جب بھی فنکشن کو اسی دلائل کے ساتھ بلایا جاتا ہے۔یادگار فنکشن: ایک یادگار فنکشن بنانے کے ل we ، ہمیں کسی کیشے آبجیکٹ کی وضاحت کرنے کی ضرورت ہے جو پچھلی فنکشن کالز کے نتائج کو ذخیرہ کرے گی۔اس کے بعد ہم ایک نیا فنکشن واپس کرتے ہیں جو چیک کرتا ہے کہ آیا کیشے آبجیکٹ میں پہلے سے دیئے گئے ان پٹ کا نتیجہ موجود ہے۔اگر نتیجہ کیشے میں مل جاتا ہے تو ، ہم اسے لوٹاتے ہیں۔بصورت دیگر ، ہم نتیجہ کی گنتی کرتے ہیں اور اسے واپس کرنے سے پہلے کیشے آبجیکٹ میں اسٹور کرتے ہیں۔واپسی کا فنکشن (... آرگس) {کونٹ کلید = json.Stringify (args) ؛اگر (کیشے [کلید]) {واپس کیشے [کلید] ؛} کانسٹنگ کا نتیجہ = فنک.اپیپلی (یہ ، آرگس) ؛کیشے [کلید] = نتیجہ ؛واپسی کا نتیجہ ؛} ؛} فنکشن fibonacci (n) {اگر (n <= 1) {واپسی n ؛fib fibonacci (n - 1) + fibonacci (n - 2) ؛} constimeizedfibonacci = memoize (fibonacci) ؛ کنسول.لاگ (میموئزڈفیبوناکی (10)) ؛// آؤٹ پٹ: 555 اس مثال کے طور پر ، ہم ایک میموئز () فنکشن کی وضاحت کرتے ہیں جو ایک فنکشن کو دلیل کے طور پر لیتا ہے اور ایک نیا فنکشن لوٹاتا ہے جو اصل فنکشن کے نتائج کیچ کرتا ہے۔کیشڈ نتائج کسی شے میں محفوظ کیے جاتے ہیں جسے کیشے کہتے ہیں۔جب یادگار فنکشن کو ایک ہی دلائل کے ساتھ دوبارہ بلایا جاتا ہے تو ، یہ اس کی دوبارہ گنتی کرنے کے بجائے کیچڈ کے نتائج کو لوٹاتا ہے۔مہنگے فنکشن کالز کے نتائج کو حاصل کرنے اور ان کو واپس کرنے سے جب وہی آدانوں کو دوبارہ پیش کیا جاتا ہے تو ، میموائزیشن پروسیسنگ کا وقت کم کرسکتی ہے اور صارف کے تجربے کو بہتر بنا سکتی ہے۔کیشڈ نتیجہ جب وہی آدانوں کو دوبارہ ہوتا ہے۔میمورائزیشن کا استعمال فنکشن پر عمل درآمد کو بہتر بنانے اور ایپلی کیشنز کی کارکردگی کو نمایاں طور پر بہتر بنانے کے لئے کیا جاسکتا ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹنے کے لئے۔مہنگے فنکشن کالز کے نتائج کو حاصل کرنے اور ان کو واپس کرنے سے جب وہی آدانوں کو دوبارہ پیش کیا جاتا ہے تو ، میموائزیشن پروسیسنگ کے وقت کو کم کرسکتی ہے اور صارف کے تجربے کو بہتر بنا سکتی ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھال لیا جاسکتا ہے۔ کوکیز کو سنبھالنے کے لئے دستاویزات کوکی پراپرٹی کا استعمال کیسے کریں: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز کو کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری 123456.docament.cookie = \"صارف نام = جان ڈو ؛ میعاد ختمیاں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جسے سیمیولونز 123456.CONST کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز ڈاٹ کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول پر لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں طے کریں۔مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹین جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق ، مساوات کی جانچ پڑتال کے لئے دو موازنہ آپریٹرز ہیں: == اور ===۔اگرچہ دونوں آپریٹرز مساوات کے ل two دو اقدار کا موازنہ کرنے کے لئے استعمال ہوتے ہیں ، ان کے درمیان ایک خاص فرق ہے: ڈبل برابر (==) آپریٹر: ڈبل برابر آپریٹر ایک تجریدی مساوات کا موازنہ آپریٹر ہے۔یہ مساوات کے ل two دو اقدار کا موازنہ ایک عام قسم میں تبدیل کرنے کے بعد کرتا ہے۔اگر اقدار مختلف اقسام کی ہیں تو ، جاوا اسکرپٹ موازنہ 123456.console.log (2 == \"2\") بنانے سے پہلے ایک یا دونوں اقدار کو ایک عام قسم میں تبدیل کرنے کی کوشش کرتا ہے۔// آؤٹ پٹ: trueconsole.log (0 == \"\") ؛// آؤٹ پٹ: trueconsole.log (null == غیر متعینہ) ؛// آؤٹ پٹ: یہ مثال کے طور پر ، ڈبل برابر آپریٹر درست واپس آجاتا ہے کیونکہ موازنہ ہونے سے پہلے 2 کو اسٹرنگ \"2\" میں تبدیل کیا جاتا ہے۔ ٹرپل برابر (===) آپریٹر: ٹرپل برابر آپریٹر ایک سخت مساوات موازنہ آپریٹر ہےیہ ان کی اقسام کو تبدیل کیے بغیر مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔اگر اقدار مختلف اقسام کی ہیں تو ، موازنہ غلط 123456.console.log (2 === \"2\") لوٹاتا ہے۔// آؤٹ پٹ: falseconsole.log (0 === \"\") ؛// آؤٹ پٹ: falseconsole.log (null === غیر متعینہ) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ٹرپل کے برابر آپریٹر غلط کو لوٹاتا ہے کیونکہ اوپریینڈ کے ڈیٹا کی اقسام مختلف ہیں۔ خلاصہ یہ کہ ڈبل برابر آپریٹر ایک خلاصہ مساوات کا موازنہ آپریٹر ہے جو مساوات کے لئے دو اقدار کو عام قسم میں تبدیل کرنے کے بعد موازنہ کرتا ہے۔، جبکہ ٹرپل برابر آپریٹر ایک سخت مساوات کا موازنہ آپریٹر ہے جو ان کی اقسام کو تبدیل کیے بغیر مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ان دونوں آپریٹرز کے مابین اختلافات کو سمجھنا ضروری ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جاوا اسکرپٹ اور آبجیکٹ میں پروٹو ٹائپ آبجیکٹ پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ میں ہر شے کی ایک پوشیدہ پراپرٹی ہے جس میں اس کے پروٹو ٹائپ نامی کسی اور شے کا لنک ہوتا ہے۔پروٹوٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جہاں کوئی شے اس کے پروٹو ٹائپ آبجیکٹ سے خصوصیات اور طریقوں کو وراثت میں ملتی ہے۔جب کوئی شے تیار کی جاتی ہے تو ، یہ اپنے پروٹو ٹائپ آبجیکٹ سے خصوصیات اور طریقوں کو وراثت میں ملتی ہے۔اسے آبجیکٹ وراثت کے نام سے جانا جاتا ہے۔اگر کسی پراپرٹی یا طریقہ کار پر ہی نہیں پایا جاتا ہے تو ، جاوا اسکرپٹ پروٹو ٹائپ چین کو اس وقت تک دیکھتا ہے جب تک کہ اسے پراپرٹی یا طریقہ کار یا طریقہ کار نہ مل جائے۔ یہاں پر پروٹوٹائپ آبجیکٹ کو آبجیکٹ کی وراثت کے لئے کس طرح استعمال کیا جاسکتا ہے: کسی چیز کو پروٹو ٹائپ کے ساتھ بنانا: کسی شے کو تخلیق کرنے کے لئے:ایک پروٹو ٹائپ کے ساتھ ، ہم آبجیکٹ کو استعمال کرسکتے ہیں۔ کریٹ () طریقہ۔یہ طریقہ ایک دلیل کے طور پر کسی شے کو لیتا ہے اور ایک نئی شے کو واپس کرتا ہے جو دلیل آبجیکٹ سے وراثت میں ہوتا ہے۔یہ. نام} اور میں $ {this.age} سال کی عمر میں ہوں۔) ؛}} ؛ const طالب علم = آبجیکٹ۔ کریٹ (شخص) ؛ طالب علم.مجور = 'کمپیوٹر سائنس' ؛ طالب علم۔ گریٹ () ؛// آؤٹ پٹ: 'ہیلو ، میرا نام جان ہے اور میں 30 سال کا ہوں۔ اس مثال میں ، ہم کسی ایسے شخص کی وضاحت کرتے ہیں جس کا نام ، ایک عمر اور ایک مبارکباد () طریقہ ہے۔اس کے بعد ہم طالب علم کے نام سے ایک نیا شے تیار کرتے ہیں جو آبجیکٹ کا استعمال کرتے ہوئے شخص سے وراثت میں ہوتا ہے۔ کریٹ () طریقہ۔ہم طالب علم آبجیکٹ میں ایک بڑی جائیداد شامل کرتے ہیں۔جب ہم طالب علم آبجیکٹ پر گریٹ () کے طریقہ کار کو کہتے ہیں تو ، یہ شخصی پروٹو ٹائپ آبجیکٹ پر پایا جاتا ہے اور اس پر عمل درآمد ہوتا ہے۔ ایک پروٹو ٹائپ کے ساتھ کنسٹرکٹر فنکشن تیار کرنا: ایک پروٹو ٹائپ کے ساتھ کنسٹرکٹر فنکشن بنانے کے ل we ، ہم ایک کنسٹرکٹر کی تقریب کی وضاحت کرسکتے ہیں اور پراپرٹیز شامل کرسکتے ہیں۔اور اس کے پروٹو ٹائپ آبجیکٹ کے طریقے۔جب کسی شے کو کنسٹرکٹر فنکشن کا استعمال کرتے ہوئے تخلیق کیا جاتا ہے تو ، اس میں پروٹو ٹائپ آبجیکٹ 123456 سے خصوصیات اور طریقے وراثت میں ملتے ہیں۔this.age = عمر ؛} شخصی۔ پروٹوٹائپ۔ گریٹ = فنکشن () {کنسول.لاگ (`ہیلو ، میرا نام $ {یہ ہے۔ نام} اور میں $ {this.age} سال کی عمر میں ہوں۔)} ؛}؛ فنکشن طالب علم (نام ، عمر ، میجر) {شخص۔ کال (یہ ، نام ، عمر) ؛this.major = میجر ؛} طالب علم.پروٹوٹائپ = آبجیکٹ.کریٹ (شخصی۔ پروٹوٹائپ) ؛ طالب علم.پروٹوٹائپ.کسٹرکٹر = طالب علم ؛ کانسٹ جان = نیا طالب علم ('جان' ، 20 ، 'کمپیوٹر سائنس') ؛ جان.گریت () ؛// آؤٹ پٹ: 'ہیلو ، میرا نام جان ہے اور میں 20 سال کا ہوں۔' اس مثال میں ، ہم ایک شخص کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو نام اور عمر کے پیرامیٹر لیتا ہے۔ہم شخصی پروٹو ٹائپ آبجیکٹ میں ایک مبارکباد () طریقہ شامل کرتے ہیں۔اس کے بعد ہم ایک طالب علم کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو ایک نام ، عمر اور ایک اہم پیرامیٹر لیتا ہے۔ہم کال () کا طریقہ استعمال کرتے ہیں تاکہ اس کلیدی لفظ کو طالب علم آبجیکٹ پر سیٹ کیا جائے۔اس کے بعد ہم ایک نیا اسٹوڈنٹ پروٹوٹائپ آبجیکٹ بناتے ہیں جو آبجیکٹ کا استعمال کرتے ہوئے شخصی پروٹو ٹائپ آبجیکٹ سے وراثت میں ملتا ہے۔ کریٹ () طریقہ۔آخر میں ، ہم طلباء کے پروٹو ٹائپ آبجیکٹ میں ایک مطالعہ () کا طریقہ شامل کرتے ہیں۔ خلاصہ ، پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ میں ہر شے کی ایک پوشیدہ پراپرٹی ہے جس میں کسی اور شے کا لنک ہے جس کو اس کے پروٹو ٹائپ کہا جاتا ہے۔پروٹوٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جہاں کوئی شے اس کے پروٹو ٹائپ آبجیکٹ سے خصوصیات اور طریقوں کو وراثت میں ملتی ہے۔پروٹو ٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا جاوا اسکرپٹ میں پیچیدہ ، آبجیکٹ پر مبنی ایپلی کیشنز بنانے کے لئے ضروری ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کے لئے لوپ 123 کا ایک غیر متزلزل ورژن ہے جو غیر متزلزل تکرار کو سنبھالنے کے لئے اوور آف لوپ کو کس طرح استعمال کرنے کا طریقہ ہے۔ایٹ ایبل ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں ایک [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ لوٹاتا ہے اور 123.const asynceterable = {[علامت.ایسیسیٹریٹر]: async فنکشن*() {پیداوار وعدہ.ریسول (1) ؛پیداوار وعدہ۔پیداوار وعدہ۔}} ؛ اس مثال میں ، ہم ایک ایسی شے کی وضاحت کرتے ہیں جس کو asynceterable کہا جاتا ہے جس میں ایک [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ میں تین وعدے برآمد ہوتے ہیں جو اقدار 1 ، 2 ، اور 3. کے لئے ویو آف ویٹ آف لوپ کا استعمال کرتے ہوئے حل کرتے ہیں: ویو آف آف لوپ کو استعمال کرنے کے ل we ، ہمیں اس کے بارے میں قابل تقلید اور پھر تکرار کرنے کی ضرورت ہے۔بہاؤ کے لئے لوپ کا استعمال کرتے ہوئے۔لوپ اگلے ویلیو 123 پر جانے سے پہلے حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔غیر متزلزل آبجیکٹ پر تکرار کرنے کے لئے لوپ کے لئے بہاؤ۔لوپ ہر وعدے کا انتظار کرتا ہے کہ وہ کنسول کی قیمت کو لاگ ان کرنے سے پہلے حل کریں۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔یہ سمجھنا کہ غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز بنانے کے لئے ضروری ہے جو غیر متزلزل ڈیٹا کے ذرائع سے نمٹتے ہیں۔/async-await-loops/https://dev.to/shadid12/how-to-use-async-await-inside-loops-in-javascript-4dlghttps://stackoverflow.com/questions/11488014/asynchonous-پروسیس-ان سائیڈ- A- جاواسکرپٹ- for-looophttps: //github.com/tc39/proposal-async-iterationhttps: //javascript.info/async-iterators-generators1exploringjs2github3javascript"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔پروگرامنگ میں غلطیوں کو دو اقسام میں تقسیم کیا جاسکتا ہے: پروگرام کی غلطیاں اور ڈویلپر کی غلطیاں۔جاوا اسکرپٹ 123456 میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: ایک نحو کی خرابی اس وقت ہوتی ہے جب آپ پہلے سے طے شدہ نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔// نحو کی خرابی: بند ہونے والی کوٹیشن کی گمشدگی کی غلطی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ console.log (x) ؛// حوالہ کی خرابی: X کی وضاحت نہیں ہے ٹائپ کی غلطی: ایک قسم کی غلطی اس وقت ہوتی ہے جب کسی قدر کو اس کے ڈیٹا ٹائپ کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔// قسم کی خرابی: اسپلٹ ایک فنکشن کی تشخیص کی غلطی نہیں ہے: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔یہ غلطی موجودہ جاوا اسکرپٹ انجنوں اور ای سی ایم ای ایس اسکرپٹ کی وضاحتوں کے ذریعہ نہیں پھینکتی ہے ، لیکن یہ اب بھی پسماندہ مطابقت کے لئے دستیاب ہے۔ ایول ('الرٹ (\"ہیلو ، ورلڈ!\")') ؛// تشخیص کی خرابی: ایول () فنکشن کو غلط استعمال کیا جاتا ہے غلطی: رینج کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔ کونسٹ ایکس = نیا سرنی (-1) ؛// رینج کی خرابی: منفی سرنی لمبائی کی خرابی: URI کی غلطی اس وقت ہوتی ہے جب عالمی فنکشن کو uri.decodeuricompient ('٪') کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔// یو آر آئی کی خرابی: خراب شدہ یو آر آئی تسلسل کو انٹرنل کی غلطی: داخلی غلطی اس وقت ہوتی ہے جب خود جاوا اسکرپٹ انجن کے ذریعہ کسی غلطی کو پھینک دیا جاتا ہے۔// داخلی غلطی: json.parse () فنکشن کو غلط استعمال کیا جاتا ہے ، غلط استعمال کیا جاتا ہے ، جاوا اسکرپٹ کوڈ کو جب اس پر عمل درآمد کیا جاتا ہے تو مختلف قسم کی غلطیوں کا سامنا کرسکتا ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بنا سکتے ہیں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کو لوپ کے لئے بہاؤ کا استعمال کرتے ہوئے نافذ کیا جاتا ہے ، جو لوپ کے لئے ایک متضاد ورژن ہے۔ غیر متزلزل تکرار کو سنبھالنے کے لئے کس طرح کے لوپ کو استعمال کرنے کا طریقہ: ایک غیر متزلزل پیدا کرنا: ایک async پیدا کرنا:ایٹ ایبل ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں ایک [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹاتا ہے۔متضاد ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز کی قیمت کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔ایٹ ایبل اور پھر اس کے اوپر آویٹ آف لوپ کا استعمال کرتے ہوئے اس پر تکرار کریں۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع سے زیادہ تکرار کرنے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔/ch_async-iteration.htmlhttps://zellwk.com/blog/async-await-in-loops/https://dev.to/shadid12/how-to-use-async-await-inside-loops-in-javascript-4dlghttps: //stackoverflow.com/questions/11488014/asynchronous-process-process-inside-a-javascript-for-looophtps: //github.com/tc39/proposal-asyt-citeration1flaviocopes2exploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringjsploringsplores3"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔دوسرے لفظوں میں ، میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے کے حساب سے نتائج کو اسٹور کرکے اور جب بھی فنکشن کو ایک ہی دلائل کے ساتھ بلایا جاتا ہے تو نتائج کی بحالی کے بجائے ان کو لوٹ کر ان کو لوٹائیں۔جاوا اسکرپٹ 123456 میں یادداشت کے بارے میں کچھ کلیدی نکات یہ ہیں: میمورائزیشن ایک اصلاح کی تکنیک ہے جو پچھلے ان پٹ کو آؤٹ پٹ میپنگس میں بچا کر وسیع حساب کو کم کرنے کے لئے استعمال کی جاسکتی ہے۔ میموئزیشن بندشوں اور اعلی آرڈر کے افعال کے تصورات پر مبنی ہے۔جاوا اسکرپٹ کے لئے لیکن بہت ساری دیگر پروگرامنگ زبانوں کے ذریعہ بھی وسیع پیمانے پر تائید کی جاتی ہے۔ میموئزیشن پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔ میموئزیشن کو کسی شے کا استعمال کرتے ہوئے یا کسی شے کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے یا کسی شے کو استعمال کرکے یا کسی شے کو استعمال کیا جاسکتا ہے۔ایک میمورائزیشن لائبریری۔ یہاں جاوا اسکرپٹ میں کسی شے کا استعمال کرتے ہوئے میمورائزیشن کو کس طرح نافذ کرنے کی ایک مثال ہے: فنکشن میموئز (فنک) {کونٹ کیشے = {} ؛واپسی کا فنکشن (... آرگس) {کونٹ کلید = json.Stringify (args) ؛اگر (کیشے [کلید]) {واپس کیشے [کلید] ؛} کانسٹنگ کا نتیجہ = فنک.اپیپلی (یہ ، آرگس) ؛کیشے [کلید] = نتیجہ ؛واپسی کا نتیجہ ؛} ؛} فنکشن fibonacci (n) {اگر (n <= 1) {واپسی n ؛fib fibonacci (n - 1) + fibonacci (n - 2) ؛} constimeizedfibonacci = memoize (fibonacci) ؛ کنسول.لاگ (میموئزڈفیبوناکی (10)) ؛// آؤٹ پٹ: 555 اس مثال کے طور پر ، ہم ایک میموئز () فنکشن کی وضاحت کرتے ہیں جو ایک فنکشن کو دلیل کے طور پر لیتا ہے اور ایک نیا فنکشن لوٹاتا ہے جو اصل فنکشن کے نتائج کیچ کرتا ہے۔کیشڈ نتائج کسی شے میں محفوظ کیے جاتے ہیں جسے کیشے کہتے ہیں۔جب یادگار فنکشن کو ایک ہی دلائل کے ساتھ دوبارہ بلایا جاتا ہے تو ، یہ اس کی دوبارہ گنتی کے بجائے کیشڈ نتیجہ کو لوٹاتا ہے۔ خلاصہ یہ کہ ، یادداشت جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور کیشڈ کے نتائج کو لوٹاتی ہے جب وہی آدانوں کا سامنا ہوتا ہے۔ایک بار پھریادداشت پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹنے کے۔یادداشت کو کسی شے کا استعمال کرتے ہوئے کیشڈ نتائج کو ذخیرہ کرنے یا میموائزیشن لائبریری کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: نحو کی خرابی اس وقت ہوتی ہے جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ میں ، جاوا اسکرپٹ کوڈ کا مقابلہ ہوسکتا ہے۔جب اس پر عملدرآمد کیا جاتا ہے تو مختلف قسم کی غلطیاں۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بنا سکتے ہیں۔ ذرائع: https: //www.tutorialspوائنٹ.-in-javascript/https: //www.geeksforgeeks.org/javascript-error-and-expedial-handling-ith-examples/https: //blog.bitsrc.io/types-of-native-errors in-javascript-you-must-know-b8238d40e492https: //study.com/academy/lesson/earrors-in-javascript-types-methods-prevention.htmlhttps: //www.educative.io/answers/tha-are-the-6-ٹائپس آف ایرر ان-جاوا اسکرپٹ-کوڈس 1 ٹیوٹوریلس پوائنٹ 2 ایسکلر 3 جی ای ای ای ایس ایف آر جی ای ای ایس 4 بی آئی ٹی ایس آر سی 5 اسٹڈی"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھال لیا جاسکتا ہے۔ کوکیز کو سنبھالنے کے لئے دستاویزات کوکی پراپرٹی کا استعمال کیسے کریں: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز کو کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری ہیں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = جان ڈو ؛ میعاد ختم ہوجاتے ہیں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جس کو سیمیولونز۔ کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز کو کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول میں لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں مقرر کریں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = ؛ میعاد ختمیاں = thu ، 01 جنوری 1970 00:00:00 UTC ؛ راستہ =/؛\"مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔ ذرائع: https: //www.javascripttutorial.net/web-apis/javascript-cookies/https: // wwww.w3schools.com/js/js_cookies.asphttps: //www.javatpوائنٹ./how-to-cesce-cokies- استعمال-Docament-object-in-javascripttps://www.tutorialspوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹین جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق ، مساوات کی جانچ پڑتال کے لئے دو موازنہ آپریٹرز استعمال کیے جاتے ہیں: == اور ===۔اگرچہ دونوں آپریٹرز مساوات کی جانچ پڑتال کے لئے استعمال ہوتے ہیں ، لیکن ان کے مختلف طرز عمل ہیں۔دونوں آپریٹرز کے مابین اختلافات یہ ہیں: خلاصہ مساوات کا موازنہ آپریٹر (==): == آپریٹر ایک خلاصہ مساوات کا موازنہ آپریٹر ہے۔یہ مساوات کے ل two دو اقدار کا موازنہ ایک عام قسم میں تبدیل کرنے کے بعد کرتا ہے۔== آپریٹر آپریٹ کے ڈیٹا کی اقسام پر غور نہیں کرتا ہے۔یہ صرف چیک کرتا ہے کہ آیا اقدار برابر ہیں یا نہیں۔ console.log (2 == \"2\") ؛// trueconsole.log (0 == \"\") ؛// trueconsole.log (null == غیر متعینہ) ؛// trueconsole.log ([] == \"\") ؛// اس مثال کے طور پر ، == آپریٹر درست لوٹتا ہے کیونکہ موازنہ سے پہلے آپ کو ایک عام قسم میں تبدیل کیا جاتا ہے۔ مساوات کا موازنہ آپریٹر (===): === آپریٹر ایک سخت مساوات کا موازنہ آپریٹر ہے۔یہ مساوات کے لئے دو اقدار کا موازنہ بغیر کسی عام قسم میں تبدیل کرتا ہے۔=== آپریٹر آپریٹ کے ڈیٹا کی اقسام پر غور کرتا ہے۔یہ چیک کرتا ہے کہ آیا اقدار اور ڈیٹا کی اقسام برابر ہیں یا نہیں۔ console.log (2 === \"2\") ؛// falseconsole.log (0 === \"\") ؛// falseconsole.log (null === غیر متعینہ) ؛// falseconsole.log ([] === \"\") ؛// اس مثال کے طور پر ، === آپریٹر جھوٹے لوٹتا ہے کیونکہ اوپریڈس میں مختلف اعداد و شمار کی اقسام ہوتی ہیں۔ خلاصہ ، == آپریٹر ایک خلاصہ مساوات کا موازنہ آپریٹر ہے جو مساوات کے لئے دو اقدار کو ایک عام قسم میں تبدیل کرنے کے بعد موازنہ کرتا ہے ، جبکہ=== آپریٹر ایک سخت مساوات کا موازنہ آپریٹر ہے جو مساوات کے لئے دو اقدار کو عام قسم میں تبدیل کیے بغیر موازنہ کرتا ہے۔=== آپریٹر استعمال کرنے میں زیادہ سخت اور محفوظ ہے کیونکہ یہ اوپیرینڈ کے ڈیٹا کی اقسام پر غور کرتا ہے۔غیر متوقع نتائج سے بچنے کے لئے == آپریٹر کے بجائے === آپریٹر کو استعمال کرنے کی سفارش کی جاتی ہے۔ ذرائع: https: //www.educative.io/answers/ what-is-the-diferences-betense- اور-operator-in-javascriptttps: //www.guru999.com/diferferences-equality-strict-operator-javascript.htmlhttps: //www.c-sharpcorner.com/article/diference-and-and-in-javascript2/https: // wwww.tutorialsPoint.com/فرق- BETENE-and-operator-in-javascriptttps: //developer.mozilla.org/en-us/docs/web/javascript/references/operators/strict_equalityhttps: //www.freecodecamp.org/news/LOOSE-VS-STRICT-ایکویٹی میں جاوا اسکرپٹ/1educative2guru993c-sharpcorner4tutorialsPoint5mozilla"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "پروٹو ٹائپ آبجیکٹ اور آبجیکٹ وراثت جاوا اسکرپٹین جاوا اسکرپٹ میں ، پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو والدین کی کلاس کی خصوصیات اور طریقوں کو بچوں کی کلاسوں میں بانٹنے کے لئے استعمال ہوتا ہے۔پروٹو ٹائپ آبجیکٹ بچے کی شے سے منسلک ہوتا ہے ، جس سے بچے کو آبجیکٹ کو والدین کی شے کی خصوصیات اور طریقوں کا وارث مل جاتا ہے۔جاوا اسکرپٹ 12345 میں پروٹو ٹائپ آبجیکٹ اور آبجیکٹ وراثت کے بارے میں کچھ اہم نکات یہ ہیں: پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو والدین کی کلاس کی خصوصیات اور طریقوں کو بچوں کی کلاسوں میں بانٹنے کے لئے استعمال ہوتا ہے۔__proto__ پراپرٹی۔ جب کسی پراپرٹی یا طریقہ کار تک کسی بچے کے آبجیکٹ پر رسائی حاصل کی جاتی ہے تو ، جاوا اسکرپٹ پہلے بچے کے آبجیکٹ پر پراپرٹی یا طریقہ کار کی تلاش کرتا ہے۔اگر یہ نہیں ملا ہے تو ، جاوا اسکرپٹ پروٹو ٹائپ آبجیکٹ پر پراپرٹی یا طریقہ کار کی تلاش کرتا ہے۔ اگر پراپرٹی یا طریقہ پروٹو ٹائپ آبجیکٹ پر نہیں ملتا ہے تو ، جاوا اسکرپٹ اسے پروٹوٹائپ آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے ، اور اسی طرح ، جب تک کہ پراپرٹی یا تکطریقہ پایا جاتا ہے یا پروٹو ٹائپ چین کا اختتام پہنچ جاتا ہے۔ جاوا اسکرپٹ میں آبجیکٹ وراثت __proto__ پراپرٹی کا استعمال کرتے ہوئے والدین کے آبجیکٹ کے پروٹو ٹائپ آبجیکٹ کو چائلڈ آبجیکٹ سے جوڑ کر حاصل کی جاتی ہے۔ اس کی ایک مثال ہے کہ آبجیکٹ کو حاصل کرنے کے لئے پروٹو ٹائپ آبجیکٹ کو کس طرح استعمال کیا جائے۔جاوا اسکرپٹ میں وراثت: فنکشن جانور (نام) {this.name = name ؛} جانور.پروٹوٹائپ.سے نام = فنکشن () {کنسول.لاگ (\"میرا نام ہے\" + یہ۔ نام) ؛} فنکشن کتا (نام ، نسل) {جانور.کال (یہ ، نام) ؛this.breed = breed ؛} dog.prototype = آبجیکٹ.کریٹ (جانوروں کی پروٹوٹائپ) ؛ dog.prototype.constructor = کتا ؛ dog.prototype.saybreed = فنکشن () {کنسول.لوگ (\"میری نسل ہے\" + یہ ہے۔نسل) ؛}} const کانسٹ کتا = نیا کتا (\"دوست\" ، \"گولڈن ریٹریور\") ؛ ڈاگ ۔سے نام () ؛// آؤٹ پٹ: میرا نام بڈی ڈاگ ہے ۔سے بریڈ () ؛// آؤٹ پٹ: میری نسل سنہری بازیافت ہے اس مثال کے طور پر ، ہم جانوروں کی کلاس کی وضاحت () کے طریقہ کار کے ساتھ کرتے ہیں۔اس کے بعد ہم ایک کتے کی کلاس کی وضاحت کرتے ہیں جو __proto__ پراپرٹی کا استعمال کرتے ہوئے جانوروں کی کلاس میں توسیع کرتا ہے۔ہم کتے کی کلاس پر ایک بریڈ () کے طریقہ کار کی بھی وضاحت کرتے ہیں۔جب ہم ایک نیا کتے کی شے بناتے ہیں تو ، اس میں جانوروں کی کلاس سے سی نام () کا طریقہ وراثت میں ملتا ہے اور کتے کی کلاس سے saybred () طریقہ۔ خلاصہ میں ، پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو خصوصیات اور طریقوں کو بانٹنے کے لئے استعمال ہوتا ہےبچوں کی کلاسوں کے لئے والدین کی کلاس۔جاوا اسکرپٹ میں آبجیکٹ کی وراثت __proto__ پراپرٹی کا استعمال کرتے ہوئے والدین آبجیکٹ کے پروٹو ٹائپ آبجیکٹ کو بچے کے آبجیکٹ سے جوڑ کر حاصل کی جاتی ہے۔یہ سمجھنا کہ پروٹوٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ موثر اور دوبارہ قابل استعمال جاوا اسکرپٹ کوڈ بنانے کے لئے ضروری ہے جو آبجیکٹ پر مبنی پروگرامنگ اصولوں کا استعمال کرتا ہے۔: //www.freecodecamp.org/news/prototypes-and-inheritance-in-javascript/https: //developer.mozilla.org/en-us/docs/web/javascript/inHeritance_and_prototype_chainhain_prototype_chainhe_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_the_/js/js_object_prototypes.asphttps://www.digitalocean.com/community/tutorials/undondending-prototypes-and-inheritance in-javascler2freecodecamp3mozilla4w3schools5mozillas5mozillas5mozillas5mozillas5mozillas5mozillas5mozillas5mozillas5mozillas5mozillas5mozillas5mozilla4w3schools5mozilla4w3schools"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کا اطلاق لوپ کے لئے اوور آف لوپ کا استعمال کرتے ہوئے کیا جاتا ہے ، جو لوپ کا ایک متضاد ورژن ہے۔یہاں یہ ہے کہ غیر متزلزل تکرار کو سنبھالنے کے لئے بہاؤ کے لوپ کو کس طرح استعمال کیا جائے: ایک قابل تقلید پیدا کرنا: ایک قابل تقلید پیدا کرنے کے ل we ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹتا ہے۔متضاد ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز کی قیمت کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔ایٹ ایبل اور پھر اس کے اوپر آویٹ آف لوپ کا استعمال کرتے ہوئے اس پر تکرار کریں۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع سے زیادہ تکرار کرنے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔/ch_async-iteration.htmlhttps://javascript.info/async-iterators-generatorshttps://dev.to/shadid12/how-to-to-asy-async-await-nside-rdlghttps-4dlghttps://stackoverfletps ://stackoverfliptps-4dlghttps ://stackoverfliptps-4dlghttps:/.com/سوالات/11488014/asynchronous-process-inside-a-javascript-for-looophttps: //flaviocopes.com/await-loop-javascript/1github2exploringjs3javascript4dev5stackoverflow"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: نحو کی خرابی اس وقت ہوتی ہے جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ میں ، جاوا اسکرپٹ کوڈ کا مقابلہ ہوسکتا ہے۔جب اس پر عملدرآمد کیا جاتا ہے تو مختلف قسم کی غلطیاں۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بنا سکتے ہیں۔ ذرائع: https: //www.scaler.com/topics/typics/types-of-errors-rors-javascript/https: //www.tutorialsptps.com/javascript/javascript_error_handling.htmhttps://www.geeksforgeeks.org/javascript-error-and-exception-handling-yxamples/https://academy-in-javascript-typtps-prevention.htmlhttps: //www.educative.io/answers/ what-are-the-types-of-errors-rors- javascript-codeshtps: //blog.bitsrc.io/types-of- native-rors-in-javascript-Y ou-must-know-8238d40e4921scaler2tutorialsPoint3geeksforgeeks4study5educative"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔دوسرے لفظوں میں ، میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے کے حساب سے نتائج کو اسٹور کرکے اور جب بھی فنکشن کو ایک ہی دلائل کے ساتھ بلایا جاتا ہے تو نتائج کی بحالی کے بجائے ان کو لوٹ کر ان کو لوٹائیں۔جاوا اسکرپٹ میں یادداشت کے بارے میں کچھ کلیدی نکات یہ ہیں: میمورائزیشن ایک اصلاح کی تکنیک ہے جو پچھلے ان پٹ کو آؤٹ پٹ میپنگس میں بچا کر وسیع حساب کو کم کرنے کے لئے استعمال کی جاسکتی ہے۔ میموئزیشن بندشوں اور اعلی آرڈر کے افعال کے تصورات پر مبنی ہے۔جاوا اسکرپٹ کے لئے لیکن بہت ساری دیگر پروگرامنگ زبانوں کے ذریعہ بھی وسیع پیمانے پر تائید کی جاتی ہے۔ میموئزیشن پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔ میموئزیشن کو کسی شے کا استعمال کرتے ہوئے یا کسی شے کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے یا کسی شے کو استعمال کرکے یا کسی شے کو استعمال کیا جاسکتا ہے۔ایک میمورائزیشن لائبریری۔ یہاں جاوا اسکرپٹ میں کسی شے کا استعمال کرتے ہوئے میمورائزیشن کو کس طرح نافذ کرنے کی ایک مثال ہے: فنکشن میموئز (فنک) {کونٹ کیشے = {} ؛واپسی کا فنکشن (... آرگس) {کونٹ کلید = json.Stringify (args) ؛اگر (کیشے [کلید]) {واپس کیشے [کلید] ؛} کانسٹنگ کا نتیجہ = فنک.اپیپلی (یہ ، آرگس) ؛کیشے [کلید] = نتیجہ ؛واپسی کا نتیجہ ؛} ؛} فنکشن fibonacci (n) {اگر (n <= 1) {واپسی n ؛fib fibonacci (n - 1) + fibonacci (n - 2) ؛} constimeizedfibonacci = memoize (fibonacci) ؛ کنسول.لاگ (میموئزڈفیبوناکی (10)) ؛// آؤٹ پٹ: 555 اس مثال کے طور پر ، ہم ایک میموئز () فنکشن کی وضاحت کرتے ہیں جو ایک فنکشن کو دلیل کے طور پر لیتا ہے اور ایک نیا فنکشن لوٹاتا ہے جو اصل فنکشن کے نتائج کیچ کرتا ہے۔کیشڈ نتائج کسی شے میں محفوظ کیے جاتے ہیں جسے کیشے کہتے ہیں۔جب یادگار فنکشن کو ایک ہی دلائل کے ساتھ دوبارہ بلایا جاتا ہے تو ، یہ اس کی دوبارہ گنتی کے بجائے کیشڈ نتیجہ کو لوٹاتا ہے۔ خلاصہ یہ کہ ، یادداشت جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور کیشڈ کے نتائج کو لوٹاتی ہے جب وہی آدانوں کا سامنا ہوتا ہے۔ایک بار پھریادداشت پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹنے کے۔میموئزیشن کو کسی شے کا استعمال کرتے ہوئے کیشڈ نتائج کو ذخیرہ کرنے یا میموائزیشن لائبریری کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔https:راکیبراہن/میموئزیشن میں جاوا اسکرپٹ اور کس طرح سے اپلائی-ٹو-ای جی گیٹ-بیٹر-کوڈ-پرفارمنس- 5d8khttps: //www.codingnjas.com/codestudio/library/memoization in-javascript1mediume2geeksforgeeksforgegeeksforgegeeksforgegeeksforgeksforgegeeksforgegeeksforgegeeksforgegeeksforgegeeksforgegedio"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکیز کو سنبھالنے کے لئے دستاویز ڈاٹ کوکی پراپرٹی کا استعمال کرنے کا طریقہ یہاں ہے: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری ہیں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = جان ڈو ؛ میعاد ختم ہوجاتے ہیں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جس کو سیمیولونز۔ کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز کو کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول میں لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں مقرر کریں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = ؛ میعاد ختمیاں = thu ، 01 جنوری 1970 00:00:00 UTC ؛ راستہ =/؛\"مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔ ذرائع: https: //www.javascripttutorial.net/web-apis/javascript-cookies/https: // wwww.w3schools.com/js/js_cookies.asphttps: //www.javatpوائنٹ./how-to-cesce-cokies- استعمال-Docament-object-in-javascripttps://www.tutorialspوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق == اور === آپریٹرز جاوا اسکرپٹ میں دو اقدار کا موازنہ کرنے کے لئے استعمال ہوتے ہیں۔اگرچہ دونوں آپریٹرز مساوات کی جانچ پڑتال کے لئے استعمال ہوتے ہیں ، لیکن ان کے مختلف طرز عمل ہیں۔دونوں آپریٹرز کے مابین اختلافات یہ ہیں: خلاصہ مساوات کا موازنہ آپریٹر (==): == آپریٹر ایک خلاصہ مساوات کا موازنہ آپریٹر ہے۔یہ مساوات کے ل two دو اقدار کا موازنہ ایک عام قسم میں تبدیل کرنے کے بعد کرتا ہے۔== آپریٹر آپریٹ کے ڈیٹا کی اقسام پر غور نہیں کرتا ہے۔یہ صرف چیک کرتا ہے کہ آیا اقدار برابر ہیں یا نہیں۔ console.log (2 == \"2\") ؛// trueconsole.log (0 == \"\") ؛// trueconsole.log (null == غیر متعینہ) ؛// trueconsole.log ([] == \"\") ؛// اس مثال کے طور پر ، == آپریٹر درست لوٹتا ہے کیونکہ موازنہ سے پہلے آپ کو ایک عام قسم میں تبدیل کیا جاتا ہے۔ مساوات کا موازنہ آپریٹر (===): === آپریٹر ایک سخت مساوات کا موازنہ آپریٹر ہے۔یہ مساوات کے لئے دو اقدار کا موازنہ بغیر کسی عام قسم میں تبدیل کرتا ہے۔=== آپریٹر آپریٹ کے ڈیٹا کی اقسام پر غور کرتا ہے۔یہ چیک کرتا ہے کہ آیا اقدار اور ڈیٹا کی اقسام برابر ہیں یا نہیں۔ console.log (2 === \"2\") ؛// falseconsole.log (0 === \"\") ؛// falseconsole.log (null === غیر متعینہ) ؛// falseconsole.log ([] === \"\") ؛// اس مثال کے طور پر ، === آپریٹر جھوٹے لوٹتا ہے کیونکہ اوپریڈس میں مختلف اعداد و شمار کی اقسام ہوتی ہیں۔ خلاصہ ، == آپریٹر ایک خلاصہ مساوات کا موازنہ آپریٹر ہے جو مساوات کے لئے دو اقدار کو ایک عام قسم میں تبدیل کرنے کے بعد موازنہ کرتا ہے ، جبکہ=== آپریٹر ایک سخت مساوات کا موازنہ آپریٹر ہے جو مساوات کے لئے دو اقدار کو عام قسم میں تبدیل کیے بغیر موازنہ کرتا ہے۔=== آپریٹر استعمال کرنے میں زیادہ سخت اور محفوظ ہے کیونکہ یہ اوپیرینڈ کے ڈیٹا کی اقسام پر غور کرتا ہے۔غیر متوقع نتائج سے بچنے کے لئے == آپریٹر کے بجائے === آپریٹر کو استعمال کرنے کی سفارش کی جاتی ہے۔ ذرائع: [ایجوکیٹو.یو] 1 [گرو 99] 2 [سی کارنر] 3 [ٹیوٹوریلس پوائنٹ] 4 [فری کوڈکیمپ] 5 [اسٹیکیز] 61.html3: https://www.c-sharpcorner.com/article/diferference-betine-and-in-javascript2/4: https://www.tutorialspوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ اور آبجیکٹ کی وراثت پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ میں ایک پوشیدہ شے ہے جو والدین کی کلاس کی خصوصیات اور طریقوں کو بچوں کی کلاسوں میں بانٹنے کے لئے استعمال ہوتا ہے۔پروٹو ٹائپ آبجیکٹ __proto__ پراپرٹی کا استعمال کرتے ہوئے بچوں کے آبجیکٹ سے منسلک ہے۔جب کسی بچے کے شے پر کسی پراپرٹی یا طریقہ کار تک رسائی حاصل کی جاتی ہے تو ، جاوا اسکرپٹ پہلے بچے کے آبجیکٹ پر پراپرٹی یا طریقہ کار کی تلاش کرتا ہے۔اگر یہ نہیں ملا ہے تو ، جاوا اسکرپٹ پروٹو ٹائپ آبجیکٹ پر پراپرٹی یا طریقہ کار تلاش کرتا ہے۔اگر پراپرٹی یا طریقہ پروٹو ٹائپ آبجیکٹ پر نہیں پایا جاتا ہے تو ، جاوا اسکرپٹ اسے پروٹوٹائپ آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے ، اور اسی طرح ، جب تک کہ پراپرٹی یا طریقہ مل جاتا ہے یا پروٹو ٹائپ چین کا اختتام نہیں ہوتا ہے۔جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ اور آبجیکٹ وراثت کے بارے میں کچھ اہم نکات یہ ہیں: پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو والدین کی کلاس کی خصوصیات اور طریقوں کو بچوں کی کلاسوں میں بانٹنے کے لئے استعمال ہوتا ہے۔__proto__ پراپرٹی۔ جب کسی پراپرٹی یا طریقہ کار تک کسی بچے کے آبجیکٹ پر رسائی حاصل کی جاتی ہے تو ، جاوا اسکرپٹ پہلے بچے کے آبجیکٹ پر پراپرٹی یا طریقہ کار کی تلاش کرتا ہے۔اگر یہ نہیں ملا ہے تو ، جاوا اسکرپٹ پروٹو ٹائپ آبجیکٹ پر پراپرٹی یا طریقہ کار کی تلاش کرتا ہے۔ اگر پراپرٹی یا طریقہ پروٹو ٹائپ آبجیکٹ پر نہیں ملتا ہے تو ، جاوا اسکرپٹ اسے پروٹوٹائپ آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے ، اور اسی طرح ، جب تک کہ پراپرٹی یا تکطریقہ پایا جاتا ہے یا پروٹو ٹائپ چین کا اختتام پہنچ جاتا ہے۔ جاوا اسکرپٹ میں آبجیکٹ وراثت __proto__ پراپرٹی کا استعمال کرتے ہوئے والدین کے آبجیکٹ کے پروٹو ٹائپ آبجیکٹ کو چائلڈ آبجیکٹ سے جوڑ کر حاصل کی جاتی ہے۔ اس کی ایک مثال ہے کہ آبجیکٹ کو حاصل کرنے کے لئے پروٹو ٹائپ آبجیکٹ کو کس طرح استعمال کیا جائے۔جاوا اسکرپٹ میں وراثت: فنکشن جانور (نام) {this.name = name ؛} جانور.پروٹوٹائپ.سے نام = فنکشن () {کنسول.لاگ (\"میرا نام ہے\" + یہ۔ نام) ؛} فنکشن کتا (نام ، نسل) {جانور.کال (یہ ، نام) ؛this.breed = breed ؛} dog.prototype = آبجیکٹ.کریٹ (جانوروں کی پروٹوٹائپ) ؛ dog.prototype.constructor = کتا ؛ dog.prototype.saybreed = فنکشن () {کنسول.لوگ (\"میری نسل ہے\" + یہ ہے۔نسل) ؛}} const کانسٹ کتا = نیا کتا (\"دوست\" ، \"گولڈن ریٹریور\") ؛ ڈاگ ۔سے نام () ؛// آؤٹ پٹ: میرا نام بڈی ڈاگ ہے ۔سے بریڈ () ؛// آؤٹ پٹ: میری نسل سنہری بازیافت ہے اس مثال کے طور پر ، ہم جانوروں کی کلاس کی وضاحت () کے طریقہ کار کے ساتھ کرتے ہیں۔اس کے بعد ہم ایک کتے کی کلاس کی وضاحت کرتے ہیں جو __proto__ پراپرٹی کا استعمال کرتے ہوئے جانوروں کی کلاس میں توسیع کرتا ہے۔ہم کتے کی کلاس پر ایک بریڈ () کے طریقہ کار کی بھی وضاحت کرتے ہیں۔جب ہم ایک نیا کتے کی شے بناتے ہیں تو ، اس میں جانوروں کی کلاس سے سی نام () کا طریقہ وراثت میں ملتا ہے اور کتے کی کلاس سے saybred () طریقہ۔ خلاصہ میں ، پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ میں ایک پوشیدہ شے ہے جو خصوصیات کو بانٹنے کے لئے استعمال ہوتا ہے اوربچوں کی کلاسوں میں والدین کی کلاس کے طریقے۔جاوا اسکرپٹ میں آبجیکٹ کی وراثت __proto__ پراپرٹی کا استعمال کرتے ہوئے والدین آبجیکٹ کے پروٹو ٹائپ آبجیکٹ کو بچے کے آبجیکٹ سے جوڑ کر حاصل کی جاتی ہے۔پروٹو ٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور دوبارہ قابل استعمال جاوا اسکرپٹ کوڈ بنانے کے لئے ضروری ہے جو آبجیکٹ پر مبنی پروگرامنگ اصولوں کا استعمال کرتا ہے۔/www.freecodecamp.org/news/prototypes-and-inheritance-in-javascript/https://www.scaler.com/topics/javascript/prototype-inheritance-in-javascript/https://javascript.inftps://javascript.inftps://javascript.infript/https://javascript.-inheritancehttps: //www.digitalocean.com/commune/tutorials/undonding-prototypes-and-inheritance in-javascript1mozilla2freecodecamp3scaler4javascript5mozilla"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کا اطلاق لوپ کے لئے اوور آف لوپ کا استعمال کرتے ہوئے کیا جاتا ہے ، جو لوپ کا ایک متضاد ورژن ہے۔یہاں یہ ہے کہ غیر متزلزل تکرار کو سنبھالنے کے لئے بہاؤ کے لوپ کو کس طرح استعمال کیا جائے: ایک قابل تقلید پیدا کرنا: ایک قابل تقلید پیدا کرنے کے ل we ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹتا ہے۔متضاد ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز کی قیمت کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔ایٹ ایبل اور پھر اس کے اوپر آویٹ آف لوپ کا استعمال کرتے ہوئے اس پر تکرار کریں۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع سے زیادہ تکرار کرنے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔/shadid12/how-to-use-async-await-loops-in-javascript-4dlghttps://www.30secondsofcode.org/js/s/async-array-loopshttps://flaviocopes.com/await-loop.com/await-loopes.com/await-loops.com/await-loops.com/awiait-loops.com-javaScript/https: //exploringjs.com/impatient-js/ch_async-iteration.htmlhttps: //stackoverflow.com/questions/111488014/asynchronous-process-side-a-javascript-for-loopusage-for-loopusegلوپٹے کے لئے لوپ کے لوپ کا استعمال ترتیب وار اعداد و شمار کے ذرائع کو ترتیب دینے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور ہو جاتا ہے۔ یہاں ایک مثال ہے کہ کس طرح ایک غیر متزلزل ڈیٹا ماخذ پر تکرار کرنے کے لئے بہاؤ کے لوپ کو کس طرح استعمال کیا جائے: async فنکشن getData() {کانٹ جواب = بازیافت کا انتظار کریں ('https://jsonplaceholder.typicode.com/posts') ؛کانسٹ ڈیٹا = جواب دینے کا انتظار کریں۔ json () ؛ڈیٹا لوٹنے ؛} async فنکشن پروسیس ڈیٹا () {Const ڈیٹا = getData () کا انتظار کریں ؛انتظار کے لئے (ڈیٹا کی کنسٹ آئٹم) {کنسول.لوگ (آئٹم. ٹائٹل) ؛}} پروسیس ڈیٹا () ؛ اس مثال میں ، ہم گیٹ ڈیٹا () نامی ایک ASYNC فنکشن کی وضاحت کرتے ہیں جو API سے ڈیٹا لاتا ہے اور اسے JSON آبجیکٹ کے طور پر واپس کرتا ہے۔اس کے بعد ہم ایک اور Async فنکشن کی وضاحت کرتے ہیں جس کو پروسیس ڈیٹا () کہتے ہیں جو گیٹ ڈیٹا () فنکشن کہتے ہیں اور لوٹ کے لئے لوپ کا استعمال کرتے ہوئے ڈیٹا پر تکرار کرتا ہے۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ خلاصہ میں ، ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع کو ترتیب دینے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے لوپ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے جو غیر متزلزل ڈیٹا کے ذرائع سے نمٹتے ہیں۔//dev.to/shadid12/how-to-use-async-await-loops-in-javascript-4dlghttps://www.30secondsofcode.org/js/s/async-array-looopshttps://flaviocops.com/wait-loop-javascript/https: //exploringjs.com/impatient-js/ch_async-iteration.htmlhttps: //stackoverflow.com/quests330148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014880 ocopes5exploringjs"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: نحو کی خرابی اس وقت ہوتی ہے جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ میں ، جاوا اسکرپٹ کوڈ کا مقابلہ ہوسکتا ہے۔جب اس پر عملدرآمد کیا جاتا ہے تو مختلف قسم کی غلطیاں۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بنا سکتے ہیں۔ ذرائع: https: //www.scaler.com/topics/typics/types-of-errors-rors-javascript/https: //www.tutorialsptps.com/javascript/javascript_error_handling.htmhttps://www.geeksforgeeks.org/javascript-error-and-exception-handling-yxamples/https://academy-in-javascript-typtps-prevention.htmlhttps: //www.educative.io/answers/ what-are-the-types-of-errors-rors- javascript-codeshtps: //blog.bitsrc.io/types-of- native-rors-in-javascript-Y ou-must-know-8238d40e4921scaler2tutorialsPoint3geeksforgeeks4study5educative"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔دوسرے لفظوں میں ، میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے کے حساب سے نتائج کو اسٹور کرکے اور جب بھی فنکشن کو ایک ہی دلائل کے ساتھ بلایا جاتا ہے تو نتائج کی بحالی کے بجائے ان کو لوٹ کر ان کو لوٹائیں۔جاوا اسکرپٹ میں یادداشت کے بارے میں کچھ کلیدی نکات یہ ہیں: میمورائزیشن ایک اصلاح کی تکنیک ہے جو پچھلے ان پٹ کو آؤٹ پٹ میپنگس میں بچا کر وسیع حساب کو کم کرنے کے لئے استعمال کی جاسکتی ہے۔ میموئزیشن بندشوں اور اعلی آرڈر کے افعال کے تصورات پر مبنی ہے۔جاوا اسکرپٹ کے لئے لیکن بہت ساری دیگر پروگرامنگ زبانوں کے ذریعہ بھی وسیع پیمانے پر تائید کی جاتی ہے۔ میموئزیشن پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔ میموئزیشن کو کسی شے کا استعمال کرتے ہوئے یا کسی شے کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے یا کسی شے کو استعمال کرکے یا کسی شے کو استعمال کیا جاسکتا ہے۔ایک میمورائزیشن لائبریری۔ عام غلطی کے خطوط ٹائپیسیسنٹیکس غلطی: جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں تو نحو کی خرابی اس وقت ہوتی ہے۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط طریقے سے استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ یہ کہ ایک اصلاح ہے ، یادداشت ایک اصلاح ہے۔جاوا اسکرپٹ میں تکنیک جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب ایک ہی آدانوں کے دوبارہ ہونے پر کیشڈ نتیجہ لوٹاتا ہے۔یادداشت پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹنے کے۔نحو کی خرابی ، حوالہ کی خرابی ، قسم کی غلطی ، تشخیص کی خرابی ، حد کی خرابی ، یو آر آئی کی خرابی ، اور منطقی غلطی جاوا اسکرپٹ میں کچھ عام قسم کی غلطیوں کی ہے جن کا سامنا کوڈ لکھتے وقت کیا جاسکتا ہے۔/memoization- javascript-53db416e0ee3https://www.geeksforgeeks.org/javascript-memoization/https://dev.to/rakibrahman/rakibrahman/memoization- javascript-and-hop-tply-to--tply-tply-to-tply-to-tply-to-tply-tply-to-tply-tply-to-tply-tply-to-tply-to-to-tply-to-to-tply-to-to-to-tply-to-ply-tply-to-tply-to-to-بیٹر-کوڈ-پرفارمنس- 5d8khttps: //www.section.io/engineering-education/an-introduction-to-moization-javascript/https: //www.scaler.com/topics/javascript-memoization/htttts: //blog.bitsrc.io/undonding-memoization in-javascript-to- improve-performance-2763ab107092https: //www.tutorialspوائنٹ"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکیز کو سنبھالنے کے لئے دستاویز ڈاٹ کوکی پراپرٹی کا استعمال کرنے کا طریقہ یہاں ہے: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری ہیں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = جان ڈو ؛ میعاد ختم ہوجاتے ہیں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جس کو سیمیولونز۔ کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز کو کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول میں لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں مقرر کریں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = ؛ میعاد ختمیاں = thu ، 01 جنوری 1970 00:00:00 UTC ؛ راستہ =/؛\"مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔ ذرائع: جاوا اسکرپٹ ٹیوٹوریل [W3Schools] 2 [جاواٹ پوائنٹ] 3 [ہوچو] 4 [ٹیوٹوریل پوائنٹ] 5 [ٹیوٹوریل پوائنٹ] 62: 62:https://www.w3schools.com/js/js_cookies.asp3: https://www.javatptine.com/javascript-cookies4: https://owhchoo.com/howchoo.com/javascript/how-to-manage-cookies-in-جاوا اسکرپٹ 5: https://www.tutorialspوائنٹ ialsPoint"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹین جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق ، دو موازنہ آپریٹرز ہیں جو اقدار کا موازنہ کرنے کے لئے استعمال ہوتے ہیں: == اور ===۔== آپریٹر کو خلاصہ مساوات آپریٹر کہا جاتا ہے ، جبکہ === آپریٹر کو سخت مساوات آپریٹر کہا جاتا ہے۔دونوں آپریٹرز کے مابین کلیدی اختلافات یہ ہیں: ٹائپ جبر: == آپریٹر ٹائپ جبر انجام دیتا ہے ، جس کا مطلب ہے کہ یہ موازنہ سے پہلے آپ کو عام قسم میں تبدیل کرتا ہے۔دوسری طرف ، === آپریٹر ٹائپ جبر نہیں انجام دیتا ہے اور آپ کو سختی سے موازنہ کرتا ہے۔ ایکویٹی چیک: خلاصہ مساوات کے لئے == آپریٹر چیک کرتا ہے ، جس کا مطلب ہے کہ دونوں اطراف میں متغیر یا اقدار کو ایک ہی ڈیٹا رکھنے کی ضرورت نہیں ہے۔ہر بار ٹائپ کریں ، یعنی ، یہ چیک کرتا ہے کہ کیا بائیں طرف سے کچھ دائیں طرف کے کسی چیز کے برابر ہے۔سخت مساوات کے لئے === آپریٹر چیک کرتا ہے ، جس کا مطلب ہے کہ دونوں اطراف میں متغیرات یا اقدار میں ایک ہی ڈیٹا کی قسم اور قیمت ہونی چاہئے۔ == اور === آپریٹرز کے مابین فرق کو واضح کرنے کے لئے کچھ مثالیں ہیں: کنسول.لوگ (2 (2== \"2\") ؛// trueconsole.log (2 === \"2\") ؛// falseconsole.log (0 == \"\") ؛// trueconsole.log (0 === \"\") ؛// falseconsole.log (null == غیر متعینہ) ؛// trueconsole.log (null === غیر متعینہ) ؛// پہلی مثال کو جھوٹی ، == آپریٹر سچ کو واپس کرتا ہے کیونکہ یہ موازنہ سے پہلے نمبر 2 پر \"2\" پر زور دیتا ہے۔دوسری مثال میں ، === آپریٹر جھوٹے لوٹتا ہے کیونکہ اس میں نمبر 2 کا موازنہ \"2\" کے ساتھ ہوتا ہے ، جو ایک ہی ڈیٹا کی قسم کے نہیں ہیں۔تیسری مثال میں ، == آپریٹر سچ کو واپس کرتا ہے کیونکہ یہ موازنہ سے پہلے نمبر 0 پر خالی تار \"\" پر مجبور کرتا ہے۔چوتھی مثال میں ، === آپریٹر غلط کو واپس کرتا ہے کیونکہ اس میں نمبر 0 کا موازنہ خالی تار \"\" سے ہوتا ہے ، جو ایک ہی ڈیٹا کی قسم کے نہیں ہیں۔پانچویں مثال میں ، == آپریٹر درست لوٹتا ہے کیونکہ کالعدم اور غیر متعینہ طور پر مساوی ہیں۔چھٹے مثال میں ، === آپریٹر غلط کو واپس کرتا ہے کیونکہ کالعدم اور غیر متعینہ طور پر مساوی نہیں ہوتے ہیں۔ خلاصہ میں ، == آپریٹر کو خلاصہ مساوات آپریٹر کہا جاتا ہے ، جبکہ === آپریٹر کو سخت مساوات آپریٹر کہا جاتا ہے۔== آپریٹر ٹائپ جبر انجام دیتا ہے ، جبکہ === آپریٹر نہیں کرتا ہے۔== آپریٹر خلاصہ مساوات کے لئے چیک کرتا ہے ، جبکہ === آپریٹر سخت مساوات کے لئے چیک کرتا ہے۔== اور === آپریٹرز کے درمیان فرق کو سمجھنا صحیح اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے اہم ہے۔-javascripttps: //www.guru999.com/difference-equality-strict-operator-javascript.htmlhttps: //www.stechies.com/diferferences-beten-javascript/https: //www.c-sharpcorner.com/آرٹیکل/فرق-اور ان-جیووسکرپٹ 2/https: //www.tutorialspوائنٹ.جاوا اسکرپٹ/حوالہ/آپریٹرز/سخت_ایکٹیویٹی 1 ایڈوکیٹیو 2 جیورو 9993 اسٹیکیز 4 سی-شارپکورنر 5 ٹیوٹوریالس پوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ اور آبجیکٹ وراثت میں جاوا اسکرپٹ میں ، پروٹوٹائپ آبجیکٹ کسی شے کی ایک پوشیدہ پراپرٹی ہے جو آبجیکٹ کی وراثت کے لئے استعمال ہوتی ہے۔ہر شے میں ایک نجی پراپرٹی ہوتی ہے جس میں کسی اور شے سے لنک ہوتا ہے جسے اس کا پروٹو ٹائپ کہا جاتا ہے۔اس پروٹو ٹائپ آبجیکٹ کا اپنا ایک پروٹو ٹائپ ہے ، اور اسی طرح جب تک کسی چیز کو اس کے پروٹو ٹائپ کے طور پر کالعدم کے ساتھ نہیں پہنچ جاتا ہے۔پروٹو ٹائپ آبجیکٹ کا استعمال اشیاء کے مابین خصوصیات اور طریقوں کو بانٹنے کے لئے کیا جاتا ہے ، جسے وراثت کے نام سے جانا جاتا ہے۔جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے بارے میں کچھ اہم نکات یہ ہیں: پروٹو ٹائپ آبجیکٹ کسی شے کی ایک پوشیدہ پراپرٹی ہے جو شے کی وراثت کے لئے استعمال ہوتی ہے۔ ہر شے میں ایک نجی پراپرٹی ہوتی ہے جس میں کسی اور شے کا لنک ہوتا ہے جسے اس کے پروٹو ٹائپ کہتے ہیں۔اس کی اپنی ایک پروٹو ٹائپ ، اور اسی طرح جب تک کسی چیز کو اس کے پروٹو ٹائپ کے طور پر کالعدم کے ساتھ نہیں پہنچ جاتا ہے۔ پروٹو ٹائپ آبجیکٹ اشیاء کے مابین خصوصیات اور طریقوں کو بانٹنے کے لئے استعمال ہوتا ہے ، جسے وراثت کے نام سے جانا جاتا ہے۔ جاوا اسکرپٹ میں ، تمام اشیاء آبجیکٹ کنسٹرکٹر کی مثال ہیں۔، جس کا مطلب ہے کہ وہ آبجیکٹ سے خصوصیات اور طریقوں کا وارث ہیں۔ پروٹوٹائپ آبجیکٹ۔ یہاں ایک مثال پیش کرنے کی مثال ہے کہ پروٹوٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے کس طرح استعمال ہوتا ہے: فنکشن شخص (نام ، عمر) {اس. نام = نام ؛this.age = عمر ؛} شخصی۔ پروٹوٹائپ۔ گریٹ = فنکشن () {کنسول.لاگ (`ہیلو ، میرا نام $ {this.name} ہے اور میں $ {this.age} سال پرانا ہوں۔) ؛} ؛کانسٹ جان = نیا شخص (\"جان\" ، 30) John جان. گریٹ () ؛// ہیلو ، میرا نام جان ہے اور میں 30 سال کا ہوں۔ اس مثال میں ، ہم شخص نامی ایک کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو دو پیرامیٹرز لیتا ہے: نام اور عمر۔اس کے بعد ہم اس شخص کو مبارکباد کے نام سے ایک طریقہ شامل کرتے ہیں۔ پروٹوٹائپ آبجیکٹ ، جو کنسول میں مبارکباد کے پیغام کو لاگ ان کرتا ہے۔آخر میں ، ہم جان کنسٹرکٹر کا استعمال کرتے ہوئے جان نامی ایک نئی شے بناتے ہیں اور اس پر مبارکباد کے طریقہ کار کو کال کرتے ہیں۔چونکہ جان شخص تعمیر کنندہ کی ایک مثال ہے ، لہذا اس شخص سے مبارکباد کا طریقہ وراثت میں ہے۔ہر شے میں ایک نجی پراپرٹی ہوتی ہے جس میں کسی اور شے سے لنک ہوتا ہے جسے اس کا پروٹو ٹائپ کہا جاتا ہے۔پروٹو ٹائپ آبجیکٹ کا استعمال اشیاء کے مابین خصوصیات اور طریقوں کو بانٹنے کے لئے کیا جاتا ہے ، جسے وراثت کے نام سے جانا جاتا ہے۔پروٹو ٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور دوبارہ قابل استعمال جاوا اسکرپٹ کوڈ بنانے کے لئے ضروری ہے۔نیوز/پروٹو ٹائپز۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹ میں غیر متزلزل تکرار اور لوپاسینکرونس تکرار کے لئے بہاؤ کے استعمال کا استعمال جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو ترتیب وار اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ترتیب دینے کی اجازت دیتا ہے۔غیر متزلزل تکرار کا اطلاق لوپ کے لئے اوور آف لوپ کا استعمال کرتے ہوئے کیا جاتا ہے ، جو لوپ کا ایک متضاد ورژن ہے۔یہاں یہ ہے کہ غیر متزلزل تکرار کو سنبھالنے کے لئے بہاؤ کے لوپ کو کس طرح استعمال کیا جائے: ایک قابل تقلید پیدا کرنا: ایک قابل تقلید پیدا کرنے کے ل we ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹتا ہے۔متضاد ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز کی قیمت کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔ایٹ ایبل اور پھر اس کے اوپر آویٹ آف لوپ کا استعمال کرتے ہوئے اس پر تکرار کریں۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع سے زیادہ تکرار کرنے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔ ہر ایک مثال کے طور پر ایک غیر متزلزل ڈیٹا ماخذ پر تکرار کرنے کے لئے کس طرح کے لوپ کو استعمال کیا جائے: async فنکشن getData (){کانٹس جواب = بازیافت کا انتظار کریں ('کانسٹ ڈیٹا = جواب دینے کا انتظار کریں۔ json () ؛ڈیٹا لوٹنے ؛} async فنکشن پروسیس ڈیٹا () {Const ڈیٹا = getData () کا انتظار کریں ؛انتظار کے لئے (ڈیٹا کی کنسٹ آئٹم) {کنسول.لوگ (آئٹم. ٹائٹل) ؛}} پروسیس ڈیٹا () ؛ اس مثال میں ، ہم گیٹ ڈیٹا () نامی ایک ASYNC فنکشن کی وضاحت کرتے ہیں جو API سے ڈیٹا لاتا ہے اور اسے JSON آبجیکٹ کے طور پر واپس کرتا ہے۔اس کے بعد ہم ایک اور Async فنکشن کی وضاحت کرتے ہیں جس کو پروسیس ڈیٹا () کہتے ہیں جو گیٹ ڈیٹا () فنکشن کہتے ہیں اور لوٹ کے لئے لوپ کا استعمال کرتے ہوئے ڈیٹا پر تکرار کرتا ہے۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ خلاصہ میں ، ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع کو ترتیب دینے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے لوپ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے جو غیر متزلزل ڈیٹا کے ذرائع سے نمٹتے ہیں۔//exploringjs.com/impatient-js/ch_async-iteration.htmlhttps://www.30secondsofcode.org/js/async-array-loopshttps://dev.to/shadid12/hows-asysync-انتظار کریں inside-loops-in-javascript-4dlghttps: //flaviocopes.com/await-looop-javascript/https: //stackoverflow.com/questions/11488010148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014801480148014880 flaviocopes"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: نحو کی خرابی اس وقت ہوتی ہے جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ میں ، جاوا اسکرپٹ کوڈ کا مقابلہ ہوسکتا ہے۔جب اس پر عملدرآمد کیا جاتا ہے تو مختلف قسم کی غلطیاں۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بنا سکتے ہیں۔ ذرائع: https: //www.scaler.com/topics/typics/types-of-errors-rors-javascript/https: //www.tutorialsptps.com/javascript/javascript_error_handling.htmhttps://www.geeksforgeeks.org/javascript-error-and-exception-handling-yxamples/https://academy-in-javascript-typtps-prevention.htmlhttps: //www.educative.io/answers/ what-are-the-types-of-errors-rors- javascript-codeshtps: //blog.bitsrc.io/types-of- native-rors-in-javascript-Y ou-must-know-8238d40e4921scaler2tutorialsPoint3geeksforgeeks4study5educative"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے حساب شدہ نتائج کو اسٹور کرکے اور جب بھی فنکشن کو ایک ہی دلائل کے ساتھ بلایا جاتا ہے تو نتائج کو دوبارہ گننے کے بجائے واپس کرکے ان کو لوٹاتے ہیں۔جاوا اسکرپٹ میں یادداشت کے بارے میں کچھ کلیدی نکات یہ ہیں: میمورائزیشن ایک اصلاح کی تکنیک ہے جو پچھلے ان پٹ کو آؤٹ پٹ میپنگس میں بچا کر وسیع حساب کو کم کرنے کے لئے استعمال کی جاسکتی ہے۔ میموئزیشن بندشوں اور اعلی آرڈر کے افعال کے تصورات پر مبنی ہے۔جاوا اسکرپٹ کے لئے لیکن بہت ساری دیگر پروگرامنگ زبانوں کے ذریعہ بھی وسیع پیمانے پر تائید کی جاتی ہے۔ میموئزیشن پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔ میموئزیشن کو کسی شے کا استعمال کرتے ہوئے یا کسی شے کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے یا کسی شے کو استعمال کرکے یا کسی شے کو استعمال کیا جاسکتا ہے۔ایک میمورائزیشن لائبریری۔ عام غلطی کے خطوط ٹائپیسیسنٹیکس غلطی: جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں تو نحو کی خرابی اس وقت ہوتی ہے۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط طریقے سے استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ یہ کہ ایک اصلاح ہے ، یادداشت ایک اصلاح ہے۔جاوا اسکرپٹ میں تکنیک جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب ایک ہی آدانوں کے دوبارہ ہونے پر کیشڈ نتیجہ لوٹاتا ہے۔یادداشت پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹنے کے۔نحو کی خرابی ، حوالہ کی خرابی ، قسم کی غلطی ، تشخیص کی خرابی ، حد کی خرابی ، یو آر آئی کی خرابی ، اور منطقی غلطی جاوا اسکرپٹ میں کچھ عام قسم کی غلطیوں کی ہے جن کا سامنا کوڈ لکھتے وقت کیا جاسکتا ہے۔/جاواسکرپٹ- یادداشت.to/rakibrahman/میموئزیشن میں جاواسکرپٹ اور کس طرح سے اپلائی-ٹو-ای جی گیٹ-بیٹر-کوڈ-پرفارمنس- 5D8KHTTPS: //www.section.io/engineering-education/an-introduction-to-memoization in-javascript/https: //www.scaler.com/topics/javascript-meoization/1geeksforgeeks2medium3bitsrc4dev5section"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکیز کو سنبھالنے کے لئے دستاویز ڈاٹ کوکی پراپرٹی کا استعمال کرنے کا طریقہ یہاں ہے: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری ہیں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = جان ڈو ؛ میعاد ختم ہوجاتے ہیں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جس کو سیمیولونز۔ کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز کو کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول میں لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں مقرر کریں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = ؛ میعاد ختمیاں = thu ، 01 جنوری 1970 00:00:00 UTC ؛ راستہ =/؛\"مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔ ذرائع: جاوا اسکرپٹ ٹیوٹوریل [W3Schools] 2 [جاواٹ پوائنٹ] 3 [ہوچو] 4 [ٹیوٹوریل پوائنٹ] 5 [ٹیوٹوریل پوائنٹ] 62: 62:https://www.w3schools.com/js/js_cookies.asp3: https://www.javatptine.com/javascript-cookies4: https://owhchoo.com/howchoo.com/javascript/how-to-manage-cookies-in-جاوا اسکرپٹ 5: https://www.tutorialspوائنٹ ialsPoint"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق == اور === آپریٹرز جاوا اسکرپٹ میں اقدار کا موازنہ کرنے کے لئے استعمال ہوتے ہیں۔== آپریٹر کو خلاصہ مساوات آپریٹر کہا جاتا ہے ، جبکہ === آپریٹر کو سخت مساوات آپریٹر کہا جاتا ہے۔دونوں آپریٹرز کے مابین کلیدی اختلافات یہ ہیں: ٹائپ جبر: == آپریٹر ٹائپ جبر انجام دیتا ہے ، جس کا مطلب ہے کہ یہ موازنہ سے پہلے آپ کو عام قسم میں تبدیل کرتا ہے۔دوسری طرف ، === آپریٹر ٹائپ جبر نہیں انجام دیتا ہے اور آپ کو سختی سے موازنہ کرتا ہے۔ ایکویٹی چیک: خلاصہ مساوات کے لئے == آپریٹر چیک کرتا ہے ، جس کا مطلب ہے کہ دونوں اطراف میں متغیر یا اقدار کو ایک ہی ڈیٹا رکھنے کی ضرورت نہیں ہے۔ہر بار ٹائپ کریں ، یعنی ، یہ چیک کرتا ہے کہ کیا بائیں طرف سے کچھ دائیں طرف کے کسی چیز کے برابر ہے۔سخت مساوات کے لئے === آپریٹر چیک کرتا ہے ، جس کا مطلب ہے کہ دونوں اطراف میں متغیرات یا اقدار میں ایک ہی ڈیٹا کی قسم اور قیمت ہونی چاہئے۔ == اور === آپریٹرز کے مابین فرق کو واضح کرنے کے لئے کچھ مثالیں ہیں: کنسول.لوگ (2 (2== \"2\") ؛// trueconsole.log (2 === \"2\") ؛// falseconsole.log (0 == \"\") ؛// trueconsole.log (0 === \"\") ؛// falseconsole.log (null == غیر متعینہ) ؛// trueconsole.log (null === غیر متعینہ) ؛// پہلی مثال کو جھوٹی ، == آپریٹر سچ کو واپس کرتا ہے کیونکہ یہ موازنہ سے پہلے نمبر 2 پر \"2\" پر زور دیتا ہے۔دوسری مثال میں ، === آپریٹر جھوٹے لوٹتا ہے کیونکہ اس میں نمبر 2 کا موازنہ \"2\" کے ساتھ ہوتا ہے ، جو ایک ہی ڈیٹا کی قسم کے نہیں ہیں۔تیسری مثال میں ، == آپریٹر سچ کو واپس کرتا ہے کیونکہ یہ موازنہ سے پہلے نمبر 0 پر خالی تار \"\" پر مجبور کرتا ہے۔چوتھی مثال میں ، === آپریٹر غلط کو واپس کرتا ہے کیونکہ اس میں نمبر 0 کا موازنہ خالی تار \"\" سے ہوتا ہے ، جو ایک ہی ڈیٹا کی قسم کے نہیں ہیں۔پانچویں مثال میں ، == آپریٹر درست لوٹتا ہے کیونکہ کالعدم اور غیر متعینہ طور پر مساوی ہیں۔چھٹے مثال میں ، === آپریٹر غلط کو واپس کرتا ہے کیونکہ کالعدم اور غیر متعینہ طور پر مساوی نہیں ہوتے ہیں۔ خلاصہ میں ، == آپریٹر کو خلاصہ مساوات آپریٹر کہا جاتا ہے ، جبکہ === آپریٹر کو سخت مساوات آپریٹر کہا جاتا ہے۔== آپریٹر ٹائپ جبر انجام دیتا ہے ، جبکہ === آپریٹر نہیں کرتا ہے۔== آپریٹر خلاصہ مساوات کے لئے چیک کرتا ہے ، جبکہ === آپریٹر سخت مساوات کے لئے چیک کرتا ہے۔== اور === آپریٹرز کے درمیان فرق کو سمجھنا صحیح اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے اہم ہے۔] 61: https://www.educative.io/answers/ what-is-the-diferference-betende-and-operator-javascript2: https://www.guru99.com/diferferences-equity-strict-operater-javascript.html3: https://www.stechies.com/diferferences-beten-javascript/4: https://www.c-sharpcorner.com/article/diferference- اور in-javascript2/5:https://developer.mozilla.org/en-us/web/wascript/referents/operators/strict_equality6: https://www.freecodecamp.org/news/loose-vs-vs-strict-equality-javascript/1educative2guru993Steches4c-sharpcorner5mozilla6freecodecamp"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ اور آبجیکٹ وراثت میں جاوا اسکرپٹ ، آبجیکٹ کنسٹرکٹرز یا لٹریلز کا استعمال کرتے ہوئے بنائے جاتے ہیں۔ہر شے میں ایک پوشیدہ پراپرٹی ہوتی ہے جسے [[پروٹو ٹائپ]] کہا جاتا ہے ، جو کسی اور شے کا حوالہ ہے جسے اس کا پروٹو ٹائپ کہا جاتا ہے۔پروٹو ٹائپ آبجیکٹ کا اپنا ایک پروٹو ٹائپ ہے ، اور اسی طرح جب تک کسی چیز کو اس کے پروٹو ٹائپ کے طور پر کالعدم کے ساتھ نہیں پہنچ جاتا ہے۔اشیاء کی اس زنجیر کو پروٹو ٹائپ چین کہا جاتا ہے ، اور یہ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے بارے میں کچھ کلیدی نکات یہ ہیں: پروٹو ٹائپ آبجیکٹ اشیاء کو بنانے کے لئے ایک ٹیمپلیٹ یا بلیو پرنٹ ہے۔ پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو اشیاء کو ان کے پروٹو ٹائپ سے خصوصیات اور طریقوں کا وارث کرنے کی اجازت دیتا ہے۔آبجیکٹ.جیٹ پروٹوٹائپ () طریقہ یا __proto__ پراپرٹی کا استعمال کرتے ہوئے۔ پروٹو ٹائپ آبجیکٹ کو آبجیکٹ کے استعمال سے ترمیم کی جاسکتی ہے۔فنکشن شخص (نام ، عمر) {this.name = نام ؛this.age = عمر ؛} شخصی۔ پروٹوٹائپ۔ گریٹ = فنکشن () {کنسول.لاگ (`ہیلو ، میرا نام $ {یہ ہے۔ نام} اور میں $ {this.age} سال کی عمر میں ہوں۔طالب علم (نام ، عمر ، گریڈ) {شخص۔ کال (یہ ، نام ، عمر) ؛this.grade = گریڈ ؛} طالب علم.پروٹوٹائپ = آبجیکٹ.کریٹ (شخصی۔ پروٹوٹائپ) ؛ طالب علم.پروٹوٹائپ.کسٹرکٹر = طالب علم ؛ طالب علم.پروٹوٹائپ۔ اسٹڈی = فنکشن () {کنسول.لوگ (`$ {یہ نام} ہے ہےگریڈ میں مطالعہ $ {this.grade} .`) ؛} const John = نیا طالب علم (\"جان\" ، 18 ، 12) John جان.گریٹ () ؛// ہیلو ، میرا نام جان ہے اور میں 18 سال کا ہوں۔ جان۔ اسٹڈی () ؛// جان گریڈ 12 میں تعلیم حاصل کر رہا ہے۔ہم شخصی پروٹو ٹائپ آبجیکٹ میں ایک مبارکباد () طریقہ شامل کرتے ہیں۔اس کے بعد ہم ایک طالب علم کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو ایک نام ، عمر اور گریڈ پیرامیٹر لیتا ہے۔ہم نام اور عمر کی خصوصیات کو مقرر کرنے کے لئے کال () کے طریقہ کار کا استعمال کرتے ہوئے اسٹوڈنٹ کنسٹرکٹر فنکشن کے اندر فرد کنسٹرکٹر فنکشن کہتے ہیں۔اس کے بعد ہم ایک نیا اسٹوڈنٹ پروٹوٹائپ آبجیکٹ بناتے ہیں جو آبجیکٹ کا استعمال کرتے ہوئے شخصی پروٹو ٹائپ آبجیکٹ سے وراثت میں ملتا ہے۔ کریٹ () طریقہ۔ہم طالب علم پروٹو ٹائپ آبجیکٹ کی کنسٹرکٹر پراپرٹی کو طالب علم پر سیٹ کرتے ہیں۔ہم طلباء کے پروٹو ٹائپ آبجیکٹ میں ایک مطالعہ () کا طریقہ شامل کرتے ہیں۔آخر میں ، ہم جان نامی ایک نیا اسٹوڈنٹ آبجیکٹ تیار کرتے ہیں اور گریٹ () اور مطالعہ () طریقوں کو کال کرتے ہیں۔ سمری ، پروٹو ٹائپ آبجیکٹ جاوا اسکرپٹ میں اشیاء بنانے کے لئے ایک ٹیمپلیٹ یا بلیو پرنٹ ہے۔پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو اشیاء کو ان کے پروٹو ٹائپ سے خصوصیات اور طریقوں کا وارث ہونے کی اجازت دیتا ہے۔موثر اور دوبارہ قابل استعمال جاوا اسکرپٹ کوڈ بنانے کے لئے پروٹو ٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے۔ڈویلپر.موزیلہ.ورگ/en-us/web/javascript/inheritance_and_the_prototype_chain2: https://www.freecodecamp.org/news/prototypes-and-inheritance-in-javascript/3: https:com/عنوانات/جاوا اسکرپٹ/پروٹو ٹائپ ان ہیریٹینس-ان-جاواسکرپٹ/4: https://javascript.info/prototype-inheritance5: https://www.digitalocean.com/commune/tutorials/undspretitynding-prototypes-prototypes-prototypes-prototypes-prototypes-prototypes-interials/undsprototypes-interials/undsprotitypin-javascript1mozilla2freecodecamp3scaler4javascript5mozilla"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کا اطلاق لوپ کے لئے اوور آف لوپ کا استعمال کرتے ہوئے کیا جاتا ہے ، جو لوپ کا ایک متضاد ورژن ہے۔یہاں یہ ہے کہ غیر متزلزل تکرار کو سنبھالنے کے لئے بہاؤ کے لوپ کو کس طرح استعمال کیا جائے: ایک قابل تقلید پیدا کرنا: ایک قابل تقلید پیدا کرنے کے ل we ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹتا ہے۔متضاد ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز کی قیمت کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔ایٹ ایبل اور پھر اس کے اوپر آویٹ آف لوپ کا استعمال کرتے ہوئے اس پر تکرار کریں۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع سے زیادہ تکرار کرنے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔ ہر ایک مثال کے طور پر ایک غیر متزلزل اعداد و شمار کے ذریعہ تکرار کرنے کے لئے کس طرح کے لوپ کو استعمال کیا جائے: جاواسکرپٹیسینک فنکشن گیٹ ڈیٹا () ()){کانٹس جواب = بازیافت کا انتظار کریں ('کانسٹ ڈیٹا = جواب دینے کا انتظار کریں۔ json () ؛ڈیٹا لوٹنے ؛} async فنکشن پروسیس ڈیٹا () {Const ڈیٹا = getData () کا انتظار کریں ؛انتظار کے لئے (ڈیٹا کی کنسٹ آئٹم) {کنسول.لوگ (آئٹم. ٹائٹل) ؛}} پروسیس ڈیٹا () ؛ اس مثال میں ، ہم گیٹ ڈیٹا () نامی ایک ASYNC فنکشن کی وضاحت کرتے ہیں جو API سے ڈیٹا لاتا ہے اور اسے JSON آبجیکٹ کے طور پر واپس کرتا ہے۔اس کے بعد ہم ایک اور Async فنکشن کی وضاحت کرتے ہیں جس کو پروسیس ڈیٹا () کہتے ہیں جو گیٹ ڈیٹا () فنکشن کہتے ہیں اور لوٹ کے لئے لوپ کا استعمال کرتے ہوئے ڈیٹا پر تکرار کرتا ہے۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ خلاصہ میں ، ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع کو ترتیب دینے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے لوپ کے لئے لوپ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔ ذرائع: فلاویو کاپز [جے ایس کی کھوج کرنا] 2 [زیل لیو] 3 [دیو کمیونٹی] 4 [30 سیکنڈ [30 سیکنڈکوڈ] 52: https://exploringjs.com/impatient-js/ch_async-iteration.html3: https://zellwk.com/blog/async-await-in-looops/4: https://dev.to/SHADID12/How-to-async-await-inside-loops-in-javascript-4dlg5: https://www.30secondsofcode.org/js/s/async-array-loops1flaviocopes2exploringjs3zellwk4dev5330sedsofcode"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: نحو کی خرابی اس وقت ہوتی ہے جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ میں ، جاوا اسکرپٹ کوڈ کا مقابلہ ہوسکتا ہے۔جب اس پر عملدرآمد کیا جاتا ہے تو مختلف قسم کی غلطیاں۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بنا سکتے ہیں۔ ذرائع: https: //www.scaler.com/topics/typics/types-of-errors-rors-javascript/https: //www.tutorialsptps.com/javascript/javascript_error_handling.htmhttps://www.geeksforgeeks.org/javascript-error-and-exception-handling-yxamples/https://academy-in-javascript-typtps-prevention.htmlhttps: //www.educative.io/answers/ what-are-the-types-of-errors-rors- javascript-codeshtps: //blog.bitsrc.io/types-of- native-rors-in-javascript-Y ou-must-know-8238d40e4921scaler2tutorialsPoint3geeksforgeeks4study5educative"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے حساب شدہ نتائج کو اسٹور کرکے اور جب بھی فنکشن کو ایک ہی دلائل کے ساتھ بلایا جاتا ہے تو نتائج کو دوبارہ گننے کے بجائے واپس کرکے ان کو لوٹاتے ہیں۔جاوا اسکرپٹ میں یادداشت کے بارے میں کچھ کلیدی نکات یہ ہیں: میمورائزیشن ایک اصلاح کی تکنیک ہے جو پچھلے ان پٹ کو آؤٹ پٹ میپنگس میں بچا کر وسیع حساب کو کم کرنے کے لئے استعمال کی جاسکتی ہے۔ میموئزیشن بندشوں اور اعلی آرڈر کے افعال کے تصورات پر مبنی ہے۔جاوا اسکرپٹ کے لئے لیکن بہت ساری دیگر پروگرامنگ زبانوں کے ذریعہ بھی وسیع پیمانے پر تائید کی جاتی ہے۔ میموئزیشن پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔ میموئزیشن کو کسی شے کا استعمال کرتے ہوئے یا کسی شے کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے یا کسی شے کو استعمال کرکے یا کسی شے کو استعمال کیا جاسکتا ہے۔ایک میمورائزیشن لائبریری۔ جاوا اسکرپٹ میں عام غلطی کی اقسام کی کچھ مثالیں ہیں: نحو کی خرابی: ایک نحو کی خرابی اس وقت ہوتی ہے جب آپ کسی پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط طریقے سے استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ یہ کہ ایک اصلاح ہے ، یادداشت ایک اصلاح ہے۔جاوا اسکرپٹ میں تکنیک جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب ایک ہی آدانوں کے دوبارہ ہونے پر کیشڈ نتیجہ لوٹاتا ہے۔نحو کی خرابی ، حوالہ کی خرابی ، قسم کی غلطی ، تشخیص کی خرابی ، حد کی خرابی ، یو آر آئی کی خرابی ، اور منطقی غلطی جاوا اسکرپٹ میں غلطیوں کی کچھ عام قسمیں ہیں جن کا سامنا کوڈ لکھنے کے دوران کیا جاسکتا ہے۔جاوا اسکرپٹ میں میمورائزیشن اور غلطی کی اقسام کو سمجھنا موثر اور قابل اعتماد جاوا اسکرپٹ ایپلی کیشنز بنانے کے لئے ضروری ہے۔ ذرائع: گیکسفورجیکس [میڈیم] 2 [بٹس اور ٹکڑوں] 3 [دیو کمیونٹی] 4 [انجینئرنگ ایجوکیشن] 5 [اسکیلر] 62: HTTPS: // نکیچرسٹینسن.medium.com/میموئزیشن ان-جاواسکرپٹ- 53DB416E0EE33: https://blog.bitsrc.io/undondending-memoization-javascript-to-improve-performance-performance-27633924: https://dev.to/rakibrahization-IN-JAVASCRIPT-AND-HOW-AP-IT-IT-GET-BETTER-CODE-PREFFORMANCE-5D8K5: https://www.section.io/engineering-education/an-introduction-to-moization-in-جاوسکرپٹ/6: https://www.scaler.com/topics/javascript-memoization/1geeksforgeeks2medium3bitsrc4dev5section6scaler"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔وہ صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال ہوتے ہیں ، جیسے لاگ ان کی اسناد ، ترجیحات ، اور شاپنگ کارٹ آئٹمز۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکیز کو سنبھالنے کے لئے دستاویز ڈاٹ کوکی پراپرٹی کا استعمال کرنے کا طریقہ یہاں ہے: کوکی ترتیب دینا: کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔تار فارمیٹ نام = قدر میں ہونا چاہئے ؛ میعاد ختم ہوجاتا ہے = تاریخ ؛ راستہ = راستہ ؛ ڈومین = ڈومین ؛ محفوظ۔نام اور قدر کے پیرامیٹرز کی ضرورت ہے ، جبکہ میعاد ختم ہونے ، راستہ ، ڈومین اور محفوظ پیرامیٹرز اختیاری ہیں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = جان ڈو ؛ میعاد ختم ہوجاتے ہیں = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ اس مثال میں ، ہم نے ایک کوکی کا نام صارف نام جان ڈو ویلیو کے ساتھ رکھا ہے۔کوکی 22 جولائی ، 2023 کو ختم ہو رہی ہے ، اور جڑ کے راستے سے قابل رسائی ہے۔ کوکی کو گیٹ کرنا: کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔پراپرٹی صفحہ پر دستیاب تمام کوکیز کا ایک تار واپس کرتی ہے ، جس کو سیمیولونز۔ کوکیز = دستاویز ڈاٹ کوکی ؛ کنسول.لاگ (کوکیز) کے ذریعہ الگ کیا جاتا ہے۔ اس مثال میں ، ہم دستاویز کو کوکی پراپرٹی پڑھتے ہیں اور نتیجہ کو کنسول میں لاگ ان کرتے ہیں۔کوکی کو حذف کرنا: کوکی کو حذف کرنے کے لئے ، میعاد ختم ہونے والے پیرامیٹر کو ماضی کی تاریخ میں مقرر کریں۔ ڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = ؛ میعاد ختمیاں = thu ، 01 جنوری 1970 00:00:00 UTC ؛ راستہ =/؛\"مثال کے طور پر ، ہم 1 جنوری 1970 کو میعاد ختم ہونے والے پیرامیٹر کو ترتیب دے کر صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے سنبھالا جاسکتا ہے۔کوکی سیٹ کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی کو سٹرنگ ویلیو تفویض کریں۔کوکی حاصل کرنے کے لئے ، دستاویز ڈاٹ کوکی پراپرٹی پڑھیں۔کوکی کو حذف کرنے کے لئے ، ماضی کی تاریخ کی میعاد ختم ہونے والے پیرامیٹر کو مقرر کریں۔جاوا اسکرپٹ میں بہت سے عام کاموں کے لئے کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے ، جیسے صارف کی توثیق ، ذاتی نوعیت ، اور ٹریکنگ۔ ذرائع: جاوا اسکرپٹ ٹیوٹوریل [W3Schools] 2 [جاواٹ پوائنٹ] 3 [ہوچو] 4 [ٹیوٹوریل پوائنٹ] 5 [ٹیوٹوریل پوائنٹ] 62: 62:https://www.w3schools.com/js/js_cookies.asp3: https://www.javatptine.com/javascript-cookies4: https://owhchoo.com/howchoo.com/javascript/how-to-manage-cookies-in-جاوا اسکرپٹ 5: https://www.tutorialspوائنٹ ialsPoint"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹین جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق ، == اور === آپریٹرز مساوات کے ل two دو اقدار کا موازنہ کرنے کے لئے استعمال ہوتے ہیں۔== آپریٹر کو خلاصہ مساوات آپریٹر کہا جاتا ہے ، جبکہ === آپریٹر کو سخت مساوات آپریٹر کہا جاتا ہے۔یہاں دونوں آپریٹرز کے مابین کلیدی اختلافات ہیں: == آپریٹر ٹائپ جبر انجام دیتا ہے ، جس کا مطلب ہے کہ یہ آپ کو موازنہ کرنے سے پہلے آپ کو عام قسم میں تبدیل کرتا ہے۔=== آپریٹر ٹائپ جبر انجام نہیں دیتا ہے اور اس کی ضرورت ہوتی ہے کہ وہ ایک ہی قسم کی ہو۔== آپریٹر سے زیادہ محفوظ اور زیادہ قابل اعتماد سمجھا جاتا ہے کیونکہ یہ غیر متوقع قسم کے جبر سے پرہیز کرتا ہے۔ یہاں == اور === آپریٹرز کے درمیان فرق کو واضح کرنے کے لئے کچھ مثالیں ہیں: جاوا اسکرپٹ کنسول.لاگ (2 == \"2\") ؛// trueconsole.log (2 === \"2\") ؛// falseconsole.log (0 == \"\") ؛// trueconsole.log (0 === \"\") ؛// falseconsole.log (null == غیر متعینہ) ؛// trueconsole.log (null === غیر متعینہ) ؛// پہلی مثال کی وجہ سے ، == آپریٹر درست لوٹتا ہے کیونکہ یہ ٹائپ جبر انجام دیتا ہے اور موازنہ کرنے سے پہلے اسٹرنگ کو \"2\" نمبر 2 میں تبدیل کرتا ہے۔=== آپریٹر جھوٹے لوٹتا ہے کیونکہ اس کے لئے دونوں کو ایک ہی قسم کی ضرورت ہوتی ہے۔ دوسری مثال میں ، == آپریٹر غلط کو واپس کرتا ہے کیونکہ یہ قسم کا جبر انجام دیتا ہے اور \"2\" کو \"2\" کو نمبر 2 میں تبدیل کرتا ہے ، جو برابر نہیں ہے۔نمبر 2 پر۔موازنہ کرنے سے پہلے=== آپریٹر غلط لوٹتا ہے کیونکہ اس کے لئے دونوں کو ایک ہی قسم کی ضرورت ہوتی ہے۔ چوتھی مثال میں ، == آپریٹر غلط کو واپس کرتا ہے کیونکہ یہ ٹائپ جبر انجام دیتا ہے اور خالی تار کو \"\" نمبر 0 میں تبدیل کرتا ہے ، جو برابر نہیں ہے۔نمبر 0 پر 0. === آپریٹر غلط لوٹتا ہے کیونکہ اس کے لئے دونوں کو ایک ہی قسم کی ضرورت ہوتی ہے۔ پانچویں مثال میں ، == آپریٹر درست لوٹتا ہے کیونکہ نول اور غیر متعینہ طور پر == آپریٹر کے ذریعہ برابر سمجھا جاتا ہے۔=== آپریٹر غلط لوٹتا ہے کیونکہ اس کے لئے دونوں کو ایک ہی قسم کی ضرورت ہوتی ہے۔ چھٹے مثال میں ، == آپریٹر غلط کو واپس کرتا ہے کیونکہ کالعدم اور غیر متعینہ ایک ہی قسم کے نہیں ہیں۔=== آپریٹر غلط لوٹتا ہے کیونکہ اس کے لئے دونوں کو ایک ہی قسم کی ضرورت ہوتی ہے۔ خلاصہ ، == آپریٹر قسم کی جبر اور ویلیو مساوات کے لئے چیک کرتا ہے ، جبکہ === آپریٹر دونوں کو ایک ہی قسم اور چیک کرنے کی ضرورت ہوتی ہے۔قدر اور قسم کی مساوات دونوں کے لئے۔معتبر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے == اور === آپریٹرز کے مابین فرق کو سمجھنا ضروری ہے۔61: https://www.educative.io/answers/ what-is-the-diferferences-betine-and-operator-in-javascript2: https://www.guru99.com/diferferences-equity-strict-operator-javascript.html3: https://www.stechies.com/diferference-beten-javascript/4: https://www.c-sharpcorner.com/article/diferference- اور in-javascript2/5: https: //www.tutorialspوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جاوا اسکرپٹ اور آبجیکٹ وراثت میں جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ ، پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو کنسٹرکٹر فنکشن کا استعمال کرتے ہوئے تخلیق کردہ ہر شے سے منسلک ہے۔پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو اشیاء کو دوسری اشیاء سے خصوصیات اور طریقوں کا وارث کرنے کی اجازت دیتا ہے۔جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے بارے میں کچھ کلیدی نکات یہ ہیں: پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو کنسٹرکٹر فنکشن کا استعمال کرتے ہوئے ہر شے سے منسلک ہوتی ہے۔ پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو اشیاء کو دوسرے سے خصوصیات اور طریقوں کا وارث کرنے کی اجازت دیتا ہے۔آبجیکٹ۔ پروٹو ٹائپ آبجیکٹ کو کسی کنسٹرکٹر فنکشن کی پروٹو ٹائپ پراپرٹی کا استعمال کرتے ہوئے رسائی حاصل کی جاتی ہے۔ __proto__ پراپرٹی کسی شے کے پروٹو ٹائپ آبجیکٹ کا حوالہ ہے۔ پروٹوٹائپ چین منسلک پروٹو ٹائپ آبجیکٹ کا ایک سلسلہ ہے جو پراپرٹیز اور طریقوں کو دیکھنے کے لئے استعمال ہوتا ہے۔ایک شے۔ ہر ایک مثال ہے کہ آبجیکٹ وراثت کے لئے پروٹو ٹائپ آبجیکٹ کو کس طرح استعمال کیا جائے: جاوا اسکرپٹ فنکشن شخص (نام ، عمر) {this.name = نام ؛this.age = عمر ؛} شخصی۔ پروٹوٹائپ۔ گریٹ = فنکشن () {کنسول.لاگ (`ہیلو ، میرا نام $ {this.name} ہے اور میں $ {this.age} سال پرانا ہوں۔) ؛} ؛فنکشن طالب علم (نام ، عمر ، گریڈ) {شخص۔ کال (یہ ، نام ، عمر) ؛this.grade = گریڈ ؛} طالب علم.پروٹوٹائپ = آبجیکٹ.کریٹ (شخصی۔ پروٹوٹائپ) ؛ طالب علم.پروٹوٹائپ.کسٹرکٹر = طالب علم ؛ کانسٹ جان = نیا طالب علم (\"جان\" ، 18 ، \"12 ویں\") ؛ جان.گریت () گریٹ ()؛// ہیلو ، میرا نام جان ہے اور میں 18 سال کا ہوں۔ اس مثال میں ، ہم ایک ایسے شخص کی تعمیراتی تقریب کی وضاحت کرتے ہیں جو ایک نام اور عمر کا پیرامیٹر لیتا ہے اور انہیں آبجیکٹ کی خصوصیات کے طور پر متعین کرتا ہے۔ہم شخصی پروٹو ٹائپ آبجیکٹ پر ایک مبارکبادی کے طریقہ کار کی بھی وضاحت کرتے ہیں جو کنسول کو مبارکباد کے پیغام کو لاگ ان کرتا ہے۔ ہم اس کے بعد ایک طالب علم کنسٹرکٹر فنکشن کی وضاحت کرتے ہیں جو نام ، عمر اور ایک گریڈ پیرامیٹر لیتا ہے اور انہیں آبجیکٹ کی خصوصیات کے طور پر مرتب کرتا ہے۔ہم کال کا طریقہ استعمال کرتے ہیں تاکہ اس شخص کو کنسٹرکٹر فنکشن کو اس کلیدی لفظ کے ساتھ طلب کیا جاسکے جس کو طالب علم آبجیکٹ پر مقرر کیا جائے۔اس سے ایک نیا شے پیدا ہوتا ہے جو شخص سے وراثت میں ہوتا ہے۔ پروٹوٹائپ آبجیکٹ۔ہم طالب علم کی کنسٹرکٹر پراپرٹی کو بھی مرتب کرتے ہیں۔مبارکباد کا طریقہ شخص سے وراثت میں ملا ہے۔ پروٹوٹائپ آبجیکٹ۔ خلاصہ ، جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ ایک پوشیدہ شے ہے جو کنسٹرکٹر فنکشن کا استعمال کرتے ہوئے تخلیق کردہ ہر شے سے منسلک ہے۔پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو اشیاء کو دوسری اشیاء سے خصوصیات اور طریقوں کا وارث کرنے کی اجازت دیتا ہے۔موثر اور دوبارہ قابل استعمال جاوا اسکرپٹ کوڈ بنانے کے لئے پروٹو ٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے۔ایم ڈی این] 61: https://developer.mozilla.org/en-us/docs/web/javascript/inheritance_and_the_prototype_chain2: https://wwww.freecodecamp.org/news/prototypes/news/prototypes/news/prototypes/news/prototypes/news/prototypes/news/prototypes/news/prototypes/news/prototypes/News.https://www.scaler.com/topics/javascript/prototype-inheritance-in-javascript/4: https://www.w3schools.com/js/js_object_prototypes.asp5: https://javascript.infipt.infipوراثت 6: https://developer.mozilla.org/en-us/docs/learn/javascript/objects/object_prototypes1mozilla2freecodecamp3scaler4w3schools5javascript6mozilla"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "جاوا اسکرپٹیسینکرونس تکرار میں غیر متزلزل تکرار جاوا اسکرپٹ میں ایک خصوصیت ہے جو ڈویلپرز کو غیر متزلزل اعداد و شمار کے ذرائع ، جیسے نیٹ ورک کی درخواستوں یا فائل سسٹم کی کارروائیوں کو ایک ترتیب وار انداز میں تکرار کرنے کی اجازت دیتی ہے۔غیر متزلزل تکرار کا اطلاق لوپ کے لئے اوور آف لوپ کا استعمال کرتے ہوئے کیا جاتا ہے ، جو لوپ کا ایک متضاد ورژن ہے۔یہاں یہ ہے کہ غیر متزلزل تکرار کو سنبھالنے کے لئے بہاؤ کے لوپ کو کس طرح استعمال کیا جائے: ایک قابل تقلید پیدا کرنا: ایک قابل تقلید پیدا کرنے کے ل we ، ہمیں کسی ایسی شے کی وضاحت کرنے کی ضرورت ہے جس میں [علامت.اسائٹریٹر] طریقہ ہے جو ایک متضاد ایٹریٹر آبجیکٹ کو لوٹتا ہے۔متضاد ایٹریٹر آبجیکٹ کے پاس اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز کی قیمت کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔ایٹ ایبل اور پھر اس کے اوپر آویٹ آف لوپ کا استعمال کرتے ہوئے اس پر تکرار کریں۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع سے زیادہ تکرار کرنے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔غیر متزلزل ایٹریٹر آبجیکٹ کا اگلا () طریقہ ہونا ضروری ہے جو پراپرٹیز ویلیو کے ساتھ کسی شے کے لئے وعدہ واپس کرتا ہے اور کیا جاتا ہے۔غیر متزلزل تکرار کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔ ہر ایک مثال کے طور پر ایک غیر متزلزل اعداد و شمار کے ذریعہ تکرار کرنے کے لئے کس طرح کے لوپ کو استعمال کیا جائے: جاواسکرپٹیسینک فنکشن گیٹ ڈیٹا () ()){کانٹس جواب = بازیافت کا انتظار کریں ('کانسٹ ڈیٹا = جواب دینے کا انتظار کریں۔ json () ؛ڈیٹا لوٹنے ؛} async فنکشن پروسیس ڈیٹا () {Const ڈیٹا = getData () کا انتظار کریں ؛انتظار کے لئے (ڈیٹا کی کنسٹ آئٹم) {کنسول.لوگ (آئٹم. ٹائٹل) ؛}} پروسیس ڈیٹا () ؛ اس مثال میں ، ہم گیٹ ڈیٹا () نامی ایک ASYNC فنکشن کی وضاحت کرتے ہیں جو API سے ڈیٹا لاتا ہے اور اسے JSON آبجیکٹ کے طور پر واپس کرتا ہے۔اس کے بعد ہم ایک اور Async فنکشن کی وضاحت کرتے ہیں جس کو پروسیس ڈیٹا () کہتے ہیں جو گیٹ ڈیٹا () فنکشن کہتے ہیں اور لوٹ کے لئے لوپ کا استعمال کرتے ہوئے ڈیٹا پر تکرار کرتا ہے۔اگلی قیمت پر جانے سے پہلے ہر وعدے کو حل کرنے کے ہر وعدے کا انتظار کرتا ہے۔ خلاصہ میں ، ویو آف آف لوپ کو ترتیب وار اعداد و شمار کے ذرائع کو ترتیب دینے کے لئے استعمال کیا جاتا ہے۔اس کا استعمال کسی بھی شے کے ساتھ کیا جاسکتا ہے جو غیر متزلزل تکرار پروٹوکول کو نافذ کرتا ہے ، جس کے لئے شے کی ضرورت ہوتی ہے کہ وہ ایک [علامت.اسائٹریٹر] طریقہ ہو جو ایک متضاد Iterator آبجیکٹ کو لوٹاتا ہے۔موثر اور جوابدہ جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے لوپ کے لئے لوپ کے ساتھ کام کرنے کا طریقہ سمجھنا ضروری ہے جو غیر متزلزل اعداد و شمار کے ذرائع سے نمٹتے ہیں۔ڈیزائن کے نمونے] 4 [اسٹیک اوور فلو] 5 [ایگھیڈ.یو] 61: https://javascript.info/async-iterators-generators2: https://dev.to/shadid12/how-to-async-await-اندر- LOOPS-in- JAVASCRIPT-4DLG3: https://zellwk.com/blog/async-await-in-loops/4: https://www.nodejsdesignpatterns.com/blog/javascript-async-eterators/5:"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹجا اسکرپٹ کوڈ میں غلطیوں کی اقسام مختلف قسم کی غلطیوں کا سامنا کر سکتی ہیں جب اسے پھانسی دی جاتی ہے۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں غلطیوں کی کچھ عام اقسام یہ ہیں: نحو کی خرابی: نحو کی خرابی اس وقت ہوتی ہے جب آپ پیش وضاحتی نحو کو غلط استعمال کرتے ہیں۔مثال کے طور پر ، سیمیکولن ، بریکٹ ، یا کوٹیشن نشان کو فراموش کرنا نحو کی خرابی کا سبب بن سکتا ہے۔ حوالہ کی خرابی: ایک حوالہ کی خرابی اس وقت ہوتی ہے جب متغیر حوالہ نہیں مل سکتا ہے یا اعلان نہیں کیا گیا ہے۔ ٹائپ غلطی: ایک قسم کی غلطی واقع ہوتی ہے۔جب کسی قدر کو اس کے اعداد و شمار کی قسم کے دائرہ کار سے باہر استعمال کیا جاتا ہے۔ تشخیص میں خرابی: تشخیص کی غلطی اس وقت ہوتی ہے جب ایول () فنکشن کو غلط طریقے سے استعمال کیا جاتا ہے۔ ریناج کی خرابی: ایک حد کی خرابی اس وقت ہوتی ہے جب ایک عددی متغیر یا پیرامیٹر اس کی درست حد سے باہر ہوتا ہے۔غلطی: یو آر آئی کی خرابی اس وقت ہوتی ہے جب کسی عالمی فنکشن کو کسی URI کو انکوڈ کرنے یا ڈیکوڈ کرنے کے لئے غلط استعمال کیا جاتا ہے۔ لاجیکل غلطی: ایک منطقی غلطی اس وقت ہوتی ہے جب کوڈ مصنوعی طور پر درست ہوتا ہے ، لیکن اس سے متوقع نتیجہ پیدا نہیں ہوتا ہے۔ خلاصہ میں ، جاوا اسکرپٹ کوڈ کا مقابلہ ہوسکتا ہے۔جب اس پر عملدرآمد کیا جاتا ہے تو مختلف قسم کی غلطیاں۔غلطیاں پروگرامنگ کی غلطیوں ، غلط ان پٹ ، یا دیگر غیر متوقع واقعات کی وجہ سے ہوسکتی ہیں۔جاوا اسکرپٹ میں مختلف قسم کی غلطیوں کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔غلطیوں کو صحیح طریقے سے سنبھالنے سے ، ڈویلپرز اپنی ایپلی کیشنز کی وشوسنییتا اور صارف کے تجربے کو بہتر بناسکتے ہیں۔ ذرائع: اسکیلر [ٹیوٹوریلس پوائنٹ] 2 [گیکسفورجیکس] 3 [اسٹڈی ڈاٹ کام] 4 [ایجوکیٹو.یو] 5 [بٹس اور ٹکڑے] 62: HTTPS:/ HTTPS://www.tutorialspوائنٹ/لیسون/ایرورز- JAVASCRIPT-TYPES-methods-prevention.html5: https://www.educative.io/answers/ what-are-the-the-6-types-of-ers- ایرروں میں جاواسکرپٹ-کوڈس 6: https"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "جاوا اسکرپٹ میموزائزیشن میں میمورائزیشن جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہوتی ہے تو کیشڈ کے نتائج کو لوٹاتا ہے۔دوسرے لفظوں میں ، میمورائزیشن کسی فنکشن کو تیز کرنے کا ایک طریقہ ہے جو اس کے پہلے کے حساب سے نتائج کو اسٹور کرکے اور جب بھی فنکشن کو ایک ہی دلائل کے ساتھ بلایا جاتا ہے تو نتائج کی بحالی کے بجائے ان کو لوٹ کر ان کو لوٹائیں۔جاوا اسکرپٹ میں یادداشت کے بارے میں کچھ کلیدی نکات یہ ہیں: میمورائزیشن ایک اصلاح کی تکنیک ہے جو پچھلے ان پٹ کو آؤٹ پٹ میپنگس میں بچا کر وسیع حساب کو کم کرنے کے لئے استعمال کی جاسکتی ہے۔ میموئزیشن بندشوں اور اعلی آرڈر کے افعال کے تصورات پر مبنی ہے۔جاوا اسکرپٹ کے لئے لیکن بہت ساری دیگر پروگرامنگ زبانوں کے ذریعہ بھی وسیع پیمانے پر تائید کی جاتی ہے۔ میموئزیشن پروسیسنگ کے وقت کو نمایاں طور پر کم کرسکتی ہے اور ایپلی کیشنز کی کارکردگی کو بہتر بنا سکتی ہے ، خاص طور پر جب بار بار اور بھاری کمپیوٹنگ افعال سے نمٹنے کے لئے۔ میموئزیشن کو کسی شے کا استعمال کرتے ہوئے یا کسی شے کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے یا کسی شے کو استعمال کرکے یا کسی شے کو استعمال کیا جاسکتا ہے۔ایک میمورائزیشن لائبریری۔ میمورائزیشن ایک پروگرامنگ تصور ہے جسے کسی بھی پروگرامنگ زبان پر لاگو کیا جاسکتا ہے۔اس کا بنیادی مقصد اپنے پروگرام کو بہتر بنانا ہے۔یہ بنیادی طور پر دیکھا جاتا ہے کہ اگر کوئی پروگرام بھاری گنتی کر رہا ہے۔میموائزیشن ان گنتی کے نتائج کو کیش کرے گی تاکہ کسی بھاری آپریشن کو انجام دیتے وقت اسے دباؤ نہ پڑے جس کے لئے پہلے سے پھانسی دی گئی گنتی کی ضرورت ہوتی ہے۔میموئزیشن کو کسی شے کا استعمال کرتے ہوئے کیشڈ نتائج کو ذخیرہ کرنے یا میموائزیشن لائبریری کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ جاوا اسکرپٹ میں میموزائزیشن کو کس طرح استعمال کرنے کی ایک مثال ہے: جاوا اسکرپٹ فنکشن فبونیکی (این) {اگر (n <= 1) {واپسی n ؛} واپس fibonacci (n - 1) + fibonacci (n - 2) ؛} فنکشن میموئز (fn) {const cache = {} ؛واپسی فنکشن (... آرگس) {اگر (کیشے [آرگس]) {واپس کیشے [آرگس] ؛} کانسٹنگ کا نتیجہ = fn.apply (یہ ، آرگس) ؛کیشے [آرگس] = نتیجہ ؛واپسی کا نتیجہ ؛} ؛} constimeizedfibonacci = memoize (fibonacci) ؛ کنسول.لوگ (میموئزڈفیبونیکی (10)) ؛// 55console.log (memoizedfibonacci (10)) ؛// 55 (کیچڈ) اس مثال میں ، ہم ایک فبونیکی فنکشن کی وضاحت کرتے ہیں جو نویں فبونیکی نمبر کو بار بار حساب کتاب کرتا ہے۔اس کے بعد ہم ایک میموئز فنکشن کی وضاحت کرتے ہیں جو ایک فنکشن کو دلیل کے طور پر لیتا ہے اور فنکشن کا ایک یادگار ورژن لوٹاتا ہے۔یادگار فنکشن پچھلے فنکشن کالز کے نتائج کو کیشے آبجیکٹ میں اسٹور کرتا ہے اور کیشڈ کے نتائج کو واپس کرتا ہے جب ایک ہی دلائل کو دوبارہ گزر جاتا ہے۔پہلی کال نتیجہ کا حساب لگاتی ہے اور اسے کیشے آبجیکٹ میں اسٹور کرتی ہے۔دوسری کال کیشے آبجیکٹ سے نتیجہ بازیافت کرتی ہے اور نتیجہ کو دوبارہ گنتی کیے بغیر اسے لوٹاتی ہے۔ خلاصہ میں ، یادداشت جاوا اسکرپٹ میں ایک اصلاح کی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو محفوظ کرتی ہے اور جب وہی آدانوں کے دوبارہ واقع ہونے پر کیشڈ نتیجہ لوٹاتا ہے۔یادداشت کو کسی شے کا استعمال کرتے ہوئے کیشڈ نتائج کو ذخیرہ کرنے یا میموائزیشن لائبریری کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔یادداشت کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو بار بار اور بھاری کمپیوٹنگ کے افعال سے نمٹتے ہیں۔ ذرائع: [میڈیم] 1 [گیکسفورجیکس] 2 [دیو کمیونٹی] 3 [انجینئرنگ ایجوکیشن] 4 [اسکیلر] 5 [بٹساور ٹکڑوں] 61: https://nickychristensen.medium.com/memoization-javascript-53db416e0eee32: https://www.geeksforgeeks.org/javascript-memoization/3: https://dev.chtps://dev.-IN-JAVASCRIPT-AND-HOW-AP-IT-IT-GET-BETTER-CODE-PREFFORMANCE-5D8K4: https://www.section.io/engineering-education/an-introduction-to-moization-in-جاوس اسکرپٹ/5: https://www.scaler.com/topics/javascript/prototype-inheritance-in-javascript/6: https://blog.bitsrc.io/undonding-memoization in-javascript-to-improve-فارمنس-2763ab1070921medium2geeksforgeeks3dev4section5scaler6bitsrc"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "جاوا اسکرپٹ کوکیز میں کوکیز کو سنبھالنے والی چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔کوکیز کو صارف کی معلومات کو ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے ، جیسے لاگ ان کی اسناد ، شاپنگ کارٹ آئٹمز ، اور صارف کی ترجیحات۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے انتظام کیا جاسکتا ہے۔جاوا اسکرپٹ میں کوکیز کو سنبھالنے کے لئے یہ اقدامات ہیں: کوکی بنائیں: کوکی بنانے کے ل you ، آپ دستاویز ڈاٹ کوکی پراپرٹی کو ایک تار پر سیٹ کرسکتے ہیں جس میں کوکی کا نام ، قیمت ، اور اختیاری صفات جیسے میعاد ختم ہونے کی تاریخ اور راستہ شامل ہو۔ایک کوکی: کوکی کو پڑھنے کے ل you ، آپ دستاویز ڈاٹ کوکی پراپرٹی تک رسائی حاصل کرسکتے ہیں ، جو صفحے پر دستیاب تمام کوکیز کا ایک تار واپس کرتا ہے۔اس کے بعد آپ کسی مخصوص کوکی کی قیمت نکالنے کے لئے تار کو پارس کرسکتے ہیں۔ کوکی کو اپ ڈیٹ کریں: کوکی کو اپ ڈیٹ کرنے کے ل you ، آپ اسی نام اور ایک نئی قدر کے ساتھ ایک نئی کوکی تشکیل دے سکتے ہیں۔براؤزر پرانی کوکی کو نئی کے ساتھ اوور رائٹ کرے گا۔ کوکی کو ڈیلیٹ کریں: کوکی کو حذف کرنے کے ل you ، آپ کوکی کی میعاد ختم ہونے کی تاریخ کو ماضی کی تاریخ میں مقرر کرسکتے ہیں۔براؤزر کوکی کو صارف کے کمپیوٹر سے ہٹا دے گا۔ ایک کوکی بنانے ، پڑھنے ، اپ ڈیٹ کرنے اور حذف کرنے کے لئے دستاویز کو کوکی پراپرٹی کو کس طرح استعمال کرنے کی ایک مثال ہے: جاوا اسکرپٹ // ایک کوکیڈوکیومنٹ ڈاٹ کوکی بنائیں۔= thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\"؛ // ایک کوکیونسٹ کوکیز پڑھیں= کوکی.سپلٹ (\"=\") ؛اگر (نام === \"صارف نام\") {کنسول.لاگ (قدر) ؛}} // ایک کوکیڈوکیومنٹ ڈاٹ کوکی = \"صارف نام = جینسمتھ کی اپ ڈیٹ کریں ؛ میعاد ختم ہوجاتی ہے = thu ، 22 جولائی 2023 12:00:00 UTC ؛ راستہ =/\" ؛ // ایک کوکیڈوکیومنٹ ڈاٹ کوکی = \"صارف نام =\" میعاد ختمیاں = thu ، کو حذف کریں ،01 جنوری 1970 00:00:00 UTC ؛ راستہ = /؛ \"؛ اس مثال میں ، ہم ایک کوکی تیار کرتے ہیں جس کو صارف نام کہا جاتا ہے جس کی قدر جانڈو ، 22 جولائی ، 2023 کی میعاد ختم ہونے کی تاریخ ، اور /کا راستہ /کا راستہ ہے۔اس کے بعد ہم دستاویز کو تقسیم کرکے اور اس کے نتیجے میں صف کو پارس کرکے صارف نام کوکی کی قدر پڑھتے ہیں۔ہم یوزر نام کوکی کی قیمت کو جینسمتھ کو اپ ڈیٹ کرتے ہیں اور ماضی میں اس کی میعاد ختم ہونے کی تاریخ طے کرکے صارف نام کوکی کو حذف کرتے ہیں۔ خلاصہ میں ، کوکیز چھوٹی ٹیکسٹ فائلیں ہیں جو کسی ویب سرور کے ذریعہ صارف کے کمپیوٹر پر محفوظ ہوتی ہیں۔جاوا اسکرپٹ میں ، کوکیز کو دستاویز ڈاٹ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں کا استعمال کرتے ہوئے انتظام کیا جاسکتا ہے۔کوکیز کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو صارف کی معلومات اور ترجیحات سے نمٹتے ہیں۔ ذرائع: جاوا اسکرپٹ ٹیوٹوریل [W3Schools] 2 [جاواٹ پوائنٹ] 3 [سیکشن.یو] 4 [ہوچو] 5 [ٹیوٹوریل پوائنٹ] 62:https://www.w3schools.com/js/js_cookies.asp3: https://www.javatptine.com/javascript-cookies4: https://www.section.io/engineering-education/undspressed-and-working-کے ساتھ جاواسکرپٹ- کوکیز/5: https://howchoo.com/javascript/how-to-manage-cookies-in-javascript6: https://www.tutorialspوائنٹ.دستاویز-آبجیکٹ میں-جاواس اسکرپٹ 1 جاواس اسکرپٹ ٹیوٹوریل 2 ڈبلیو 3 ایس سی او ایل ایس 3 جےواٹ پوائنٹ 4section5 ہاوچو 6 ٹیوٹوریالس پوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "جاوا اسکرپٹین جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان فرق ، مساوات کے دو قسم کے آپریٹرز ہیں: == اور ===۔== آپریٹر کو خلاصہ مساوات آپریٹر کہا جاتا ہے ، جبکہ === آپریٹر کو سخت مساوات آپریٹر کہا جاتا ہے۔وہ دونوں مساوات کی جانچ پڑتال کے لئے استعمال ہوتے ہیں ، لیکن وہ مختلف طریقے سے کام کرتے ہیں۔دونوں آپریٹرز کے مابین کلیدی اختلافات یہ ہیں: == آپریٹر خلاصہ مساوات آپریٹر ہے ، جبکہ === آپریٹر سخت مساوات آپریٹر ہے۔ == آپریٹر دونوں اقدار کو ایک عام قسم میں تبدیل کرنے کے بعد مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔=== آپریٹر ان کی اقسام کو تبدیل کیے بغیر مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔ == آپریٹر === آپریٹر سے کم سخت ہے۔دونوں آپریٹرز کے مابین فرق کو واضح کرنے کے لئے کچھ مثالیں ہیں: جاوا اسکرپٹ کنسول۔ لاگ (2 == \"2\") ؛// trueconsole.log (2 === \"2\") ؛// falseconsole.log (0 == \"\") ؛// trueconsole.log (0 === \"\") ؛// falseconsole.log (null == غیر متعینہ) ؛// trueconsole.log (null === غیر متعینہ) ؛// پہلی مثال کی وجہ سے ، == آپریٹر درست لوٹتا ہے کیونکہ موازنہ کرنے سے پہلے \"2\" نمبر 2 میں تبدیل ہوجاتا ہے۔=== آپریٹر غلط لوٹتا ہے کیونکہ یہ دیکھتا ہے کہ اعداد و شمار کی قسمیں مختلف ہیں۔ دوسری مثال میں ، == آپریٹر درست لوٹتا ہے کیونکہ تقابل کرنے سے پہلے خالی تار نمبر 0 میں تبدیل ہوجاتا ہے۔=== آپریٹر غلط لوٹتا ہے کیونکہ یہ دیکھتا ہے کہ اعداد و شمار کی قسمیں مختلف ہیں۔ تیسری مثال میں ، == آپریٹر درست واپس آجاتا ہے کیونکہ خلاصہ مساوات آپریٹر کے ذریعہ کالعدم اور غیر متعینہ طور پر مساوی سمجھا جاتا ہے۔=== آپریٹر غلط کو واپس کرتا ہے کیونکہ یہ دیکھتا ہے کہ ڈیٹا کی قسمیں مختلف ہیں۔ خلاصہ میں ، == آپریٹر خلاصہ مساوات آپریٹر ہے ، جبکہ === آپریٹر سخت مساوات آپریٹر ہے۔== آپریٹر دونوں اقدار کو ایک عام قسم میں تبدیل کرنے کے بعد مساوات کے لئے دو اقدار کا موازنہ کرتا ہے ، جبکہ === آپریٹر اپنی اقسام کو تبدیل کیے بغیر مساوات کے لئے دو اقدار کا موازنہ کرتا ہے۔ان دونوں آپریٹرز کے مابین فرق کو سمجھنا موثر اور موثر جاوا اسکرپٹ کوڈ لکھنے کے لئے ضروری ہے۔.www.tutorialspوائنٹ"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جاوا اسکرپٹ اور آبجیکٹ وراثت میں جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ ، پروٹو ٹائپ آبجیکٹ کسی شے کی ایک پوشیدہ ملکیت ہے جو کسی اور شے کا حوالہ رکھتی ہے۔پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو موجودہ اشیاء پر مبنی نئی اشیاء بنانے کا ایک طریقہ ہے۔جب کسی شے پر کسی پراپرٹی یا طریقہ کار تک رسائی حاصل کی جاتی ہے تو ، جاوا اسکرپٹ پہلے اس چیز پر جائیداد یا طریقہ کار تلاش کرتا ہے۔اگر پراپرٹی یا طریقہ نہیں ملا ہے تو ، جاوا اسکرپٹ اسے آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے۔اگر پراپرٹی یا طریقہ کار ابھی بھی نہیں ملا ہے تو ، جاوا اسکرپٹ اسے پروٹو ٹائپ آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے ، اور اسی طرح جب تک یہ پروٹو ٹائپ چین کے اختتام تک نہیں پہنچتا ہے۔ جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے بارے میں کچھ اہم نکات ہیں: پروٹو ٹائپ آبجیکٹ ہے۔کسی شے کی ایک پوشیدہ جائیداد جو کسی اور شے کا حوالہ رکھتی ہے۔ پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو موجودہ اشیاء پر مبنی نئی اشیاء بنانے کا ایک طریقہ ہے۔ جب کسی پراپرٹی یا طریقہ کار تک کسی شے پر رسائی حاصل کی جاتی ہے تو ، جاوا اسکرپٹ پہلے نظر آتی ہے۔شے پر ہی پراپرٹی یا طریقہ کار کے لئے۔اگر پراپرٹی یا طریقہ نہیں ملا ہے تو ، جاوا اسکرپٹ اسے آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے۔اگر پراپرٹی یا طریقہ کار ابھی بھی نہیں ملا ہے تو ، جاوا اسکرپٹ اسے پروٹو ٹائپ آبجیکٹ کے پروٹو ٹائپ آبجیکٹ پر تلاش کرتا ہے ، اور اسی طرح جب تک یہ پروٹو ٹائپ چین کے اختتام تک نہیں پہنچ جاتا ہے۔ایک مخصوص پروٹو ٹائپ آبجیکٹ۔ یہاں جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کو آبجیکٹ وراثت کے لئے کس طرح استعمال کیا جائے اس کی ایک مثال ہے: جاوا اسکرپٹ فانکشن شخص (نام ، عمر) {this.name = نام ؛this.age = عمر ؛} شخصی۔ پروٹوٹائپ۔ گریٹ = فنکشن () {کنسول.لاگ (`ہیلو ، میرا نام $ {this.name} ہے اور میں $ {this.age} سال پرانا ہوں۔) ؛} ؛فنکشن طالب علم (نام ، عمر ، گریڈ) {شخص۔ کال (یہ ، نام ، عمر) ؛this.grade = گریڈ ؛} طالب علم.پروٹوٹائپ = آبجیکٹ.کریٹ (شخصی۔ پروٹوٹائپ) ؛ طالب علم.پروٹوٹائپ.کسٹرکٹر = طالب علم ؛ طالب علم.پروٹوٹائپ۔ اسٹڈی = فنکشن () {کنسول.لوگ (`$ {یہ نام} ہے ہےان کے $ {this.grade} گریڈ.`) کے لئے سخت مطالعہ کرنا ؛} ؛ کانسٹ جان = نیا طالب علم (\"جان\" ، 18 ، \"12 واں\") ؛ جان.گریٹ () ؛// ہیلو ، میرا نام جان ہے اور میں 18 سال کا ہوں۔ جان۔ اسٹڈی () ؛// جان اپنی 12 ویں جماعت کے لئے سخت مطالعہ کر رہا ہے۔ اس مثال میں ، ہم کسی ایسے شخص کی تعمیراتی تقریب کی وضاحت کرتے ہیں جو نام اور عمر کے پیرامیٹر لیتا ہے اور انہیں آبجیکٹ پر خصوصیات کے طور پر متعین کرتا ہے۔اس کے بعد ہم شخصی پروٹو ٹائپ آبجیکٹ پر ایک مبارکبادی کے طریقہ کار کی وضاحت کرتے ہیں جو کنسول کو سلام لاگ ان کرتا ہے۔ ہم اس کے بعد طلباء کے تعمیر کنندہ کی تقریب کی وضاحت کرتے ہیں جو نام ، عمر اور گریڈ پیرامیٹر لیتا ہے اور انہیں آبجیکٹ پر خصوصیات کے طور پر مرتب کرتا ہے۔ہم طالب علم آبجیکٹ پر نام اور عمر کی خصوصیات کو طے کرنے کے لئے کال کے طریقہ کار کا استعمال کرتے ہوئے اسٹوڈنٹ کنسٹرکٹر فنکشن کے اندر فرد کنسٹرکٹر فنکشن کہتے ہیں۔ ہم اس کے بعد شخصی پروٹو ٹائپ آبجیکٹ کے ساتھ ایک نیا آبجیکٹ بنائیں جس کا استعمال کرتے ہیں۔اسے اسٹوڈنٹ پروٹوٹائپ آبجیکٹ کے پروٹو ٹائپ آبجیکٹ کے طور پر سیٹ کریں۔ہم اسٹوڈنٹ پروٹو ٹائپ آبجیکٹ کی کنسٹرکٹر پراپرٹی کو اسٹوڈنٹ کنسٹرکٹر فنکشن پر بھی مرتب کرتے ہیں۔ ہم اس کے بعد اسٹوڈنٹ پروٹو ٹائپ آبجیکٹ پر مطالعاتی طریقہ کی وضاحت کرتے ہیں جو کنسول پر پیغام دیتا ہے۔اور اس کے بارے میں مطالعے کے طریقوں کا خلاصہ یہ ہے کہ ، پروٹو ٹائپ آبجیکٹ کسی شے کی پوشیدہ پراپرٹی ہے جو کسی اور شے کا حوالہ دیتا ہے۔پروٹو ٹائپ آبجیکٹ آبجیکٹ وراثت کے لئے استعمال ہوتا ہے ، جو موجودہ اشیاء پر مبنی نئی اشیاء بنانے کا ایک طریقہ ہے۔پروٹوٹائپ آبجیکٹ کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز بنانے کے لئے ضروری ہے جو آبجیکٹ کی وراثت سے نمٹتے ہیں۔ ذرائع: [MDN ویب دستاویزات] 1 [فری کوڈکیمپ] 2 [اسکیلر] 3 [ڈیجیٹلوسین] 4 [جاواسکرپٹ.نفو] 5 [جاواٹپوائنٹ] 61: https://developer.mozilla.org/en-us/docs/web/javascript/inheritance_and_the_prototype_chain2: https://wwww.freecodecamp.org/news/prototypes/news/news/news/news/news/news/news/news/news/news/prototypes/news/prototypes/news/prototypes/news/prototypes/news/news/news/prototypes/news.https://www.scaler.com/topics/javascript/prototype-inheritance-i-javascript/4: https://www.digitalocean.com/community/tutorials/undonding-prototypes-inheritance-in-javascrept5https://javascript.info/prototype-inheritance6: https://www.javatptipinecy.com/javascript-prototype-inheritance1mozilla2freecodecamp3scaler4javascleridgavascleridgavascleridgavascleridgavascleridgavascleridgavascleridgoascleridgascleridcamp3mozela6digitigalocean"
    },
    {
        "Question": "لنکڈ فہرست کو جگہ پر الٹ کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "جاوا اسکرپٹریورز میں لنکڈ فہرست کو تبدیل کرنا جاوا اسکرپٹ میں انٹرویو کا ایک عام سوال ہے۔ایک منسلک فہرست ایک ڈیٹا ڈھانچہ ہے جس میں نوڈس کے تسلسل پر مشتمل ہوتا ہے ، جہاں ہر نوڈ میں ایک قیمت اور ترتیب میں اگلے نوڈ کا حوالہ ہوتا ہے۔منسلک فہرست کو تبدیل کرنے کا مطلب ہے نوڈس کے مابین حوالوں کی سمت کو تبدیل کرنا تاکہ آخری نوڈ پہلا نوڈ بن جائے ، اور پہلا نوڈ آخری نوڈ بن جائے۔جاوا اسکرپٹ میں ایک منسلک فہرست کو الٹ کرنے کے لئے کچھ حکمت عملی یہ ہیں: تکراری نقطہ نظر: تکراری نقطہ نظر میں منسلک فہرست کے ذریعے تکرار کرنا اور نوڈس کے مابین حوالوں کی سمت کو تبدیل کرنا شامل ہے۔اس نقطہ نظر کے لئے تین پوائنٹرز کو ٹریک رکھنے کی ضرورت ہے: موجودہ نوڈ ، پچھلا نوڈ ، اور اگلا نوڈ۔ ریفرسیو نقطہ نظر: تکرار نقطہ نظر میں منسلک فہرست کو متنازعہ طور پر عبور کرنا اور نوڈس کے مابین حوالوں کی سمت کو تبدیل کرنا شامل ہے۔اس نقطہ نظر کے لئے لنکڈ فہرست کو عبور کرنے کے لئے تکرار کو روکنے کے لئے بیس کیس کی ضرورت ہوتی ہے۔ یہاں تک کہ جاوا اسکرپٹ میں لنکڈ لسٹ کو الٹا کرنے کی ایک مثال ہے جس میں تکراری نقطہ نظر کا استعمال کرتے ہوئے جاوا اسکرپٹ میں ایک لنکڈ فہرست کو الٹا کیا جائے: جاوا اسکرپٹ فینکشن ریورس لنکڈ لسٹ (ہیڈ) {موجودہ = ہیڈ ؛آئیے پچھلا = null ؛جبکہ (موجودہ) {آئیے اگلے = موجودہ۔ نیکسٹ ؛موجودہ۔ نیکسٹ = پچھلا ؛پچھلا = موجودہ ؛موجودہ = اگلا ؛} پچھلی واپسی ؛} اس مثال میں ، ہم ایک ریورس لنکڈ لسٹ فنکشن کی وضاحت کرتے ہیں جو ایک لنکڈ فہرست کے سر کو ایک دلیل کے طور پر لیتا ہے اور الٹ لنکڈ لسٹ کے نئے سربراہ کو لوٹاتا ہے۔ہم موجودہ پوائنٹر کو لنکڈ لسٹ کے سربراہ اور پچھلے پوائنٹر کو NULL میں شروع کرتے ہیں۔اس کے بعد ہم تھوڑی دیر کے لوپ کا استعمال کرتے ہوئے لنکڈ فہرست کے ذریعے تکرار کرتے ہیں اور اگلے پوائنٹر کو اگلے نوڈ پر ، موجودہ نوڈ کی طرف موجودہ نوڈ پر ، موجودہ نوڈ پر پچھلا پوائنٹر ، اور نوڈس کے مابین حوالوں کی سمت کو الٹ دیتے ہیں۔اگلے نوڈ کی طرف موجودہ پوائنٹر۔آخر میں ، ہم سابقہ پوائنٹر کو الٹ لنکڈ لسٹ کے نئے سربراہ کی حیثیت سے لوٹاتے ہیں۔ یہاں تک کہ جاوا اسکرپٹ میں لنکڈ لسٹ کو تبدیل کرنے کے طریقہ کار کو تبدیل کرنے کی ایک مثال ہے: جاوا اسکرپٹ فنکشن ریورس لنکڈ لسٹ (ہیڈ) {اگر (! ہیڈ ||! ہیڈ ڈاٹ نیکسٹ) {سربراہ واپس ؛} آئیے نیو ہیڈ = ریورسلن لسٹ لسٹ (ہیڈ. نیکسٹ) ؛ہیڈ ڈاٹ نیکسٹ۔ نیکسٹ = ہیڈ ؛ہیڈ. نیکسٹ = null ؛نیو ہیڈ واپس کریں ؛} اس مثال کے طور پر ، ہم ایک ریورس لنکڈ لسٹ فنکشن کی وضاحت کرتے ہیں جو ایک لنکڈ فہرست کے سر کو دلیل کے طور پر لیتا ہے اور الٹ لنکڈ لسٹ کے نئے سربراہ کو واپس کرتا ہے۔ہم منسلک فہرست کو عبور کرنے کے لئے ایک تکرار نقطہ نظر کا استعمال کرتے ہیں اور نوڈس کے مابین حوالوں کی سمت کو الٹ دیتے ہیں۔ہم ایک بیس کیس کی وضاحت کرتے ہیں جو تکرار کو روکتا ہے جب ہیڈ پوائنٹر کالعدم ہوتا ہے یا ہیڈ۔ نیکسٹ پوائنٹر کالعدم ہوتا ہے۔اس کے بعد ہم بار بار ریورس لنک لسٹ فنکشن کو ہیڈ کے ساتھ کال کرتے ہیں۔ نیکسٹ پوائنٹر اور نیو ہیڈ پوائنٹر کو واپس شدہ قیمت پر سیٹ کریں۔اس کے بعد ہم نوڈس کے مابین حوالہ جات کی سمت کو سر نوڈ پر سر نوڈ پر ، سر کے نوڈ پر ، نیکسٹ پوائنٹر ، اور نیو ہیڈ پوائنٹر کو ہیڈ پر نوڈ نوڈ کے ذریعہ تبدیل کرتے ہیں۔آخر میں ، ہم نیو ہیڈ پوائنٹر کو الٹ لنکڈ لسٹ کے نئے سربراہ کی حیثیت سے واپس کرتے ہیں۔ خلاصہ میں ، ایک منسلک فہرست کو تبدیل کرنا جاوا اسکرپٹ میں انٹرویو کا ایک عام سوال ہے۔ایک منسلک فہرست کو الٹ کرنے کے لئے دو حکمت عملی ہیں: تکراری نقطہ نظر اور تکرار نقطہ نظر۔لنکڈ فہرستوں کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار جاوا اسکرپٹ ایپلی کیشنز کی تشکیل کے لئے ضروری ہے جو اعداد و شمار کے ڈھانچے سے نمٹتے ہیں۔ ذرائع: [اسٹیک اوور فلو] 1 [سادہ انگریزی میں جاوا اسکرپٹ] 2 [یوٹیوب] 3 [ونسنٹ] 4 [دیو کمیونٹی] 5-A2D235D645483: https://youtube.com/watch؟v=UCV-emtvpe44: https://wsvincent.com/javascrept-reverse-linked-list/5: https://dev.to/coderjay06/reverse-a-سنگلی سے منسلک لسٹ-ان-جاواسکرپٹ-اور recursively-2n046: https://youtube.com/watch؟v=KlxK37TTMMO1STACKOVERLOW2LAINENGLISH3YOUTUBE4WSVINCENT5DEV6YOUTUBE"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں شروع سے ایک واحد منسلک فہرست کو نافذ کریں۔",
        "Answer": "ٹائپ اسکرپٹا میں واحد منسلک فہرست کو لاگو کرنا ایک ڈیٹا ڈھانچہ ہے جس میں نوڈس کے تسلسل پر مشتمل ہوتا ہے ، جہاں ہر نوڈ میں ایک قیمت اور ترتیب میں اگلے نوڈ کا حوالہ ہوتا ہے۔ٹائپ اسکرپٹ میں ایک واحد منسلک فہرست کو نافذ کرنے میں نوڈ کلاس کی وضاحت شامل ہے جو لنکڈ فہرست میں نوڈ کی نمائندگی کرتی ہے اور لنکڈ لسٹ کلاس جو لنکڈ فہرست کی نمائندگی کرتی ہے۔یہاں ٹائپ اسکرپٹ میں واحد منسلک فہرست کو نافذ کرنے کے طریقہ کی ایک مثال ہے: ٹائپ اسکرپٹ کلاس نوڈ <T> {ڈیٹا: ٹی ؛اگلا: نوڈ <t> |خالی؛کنسٹرکٹر (ڈیٹا: ٹی) {this.data = ڈیٹا ؛this.next = null ؛}} کلاس لنکڈ لسٹ <t> {سر: نوڈ <t> |خالی؛کنسٹرکٹر () {this.head = null ؛} داخلہ (ڈیٹا: ٹی): باطل {کونسٹ نیو نوڈ = نیا نوڈ (ڈیٹا) ؛اگر (! this.head) {this.head = newnode ؛واپسی ؛} موجودہ = this.head ؛جبکہ (موجودہ۔ نیکسٹ) {موجودہ = موجودہ۔ نیکسٹ ؛} موجودہ۔ نیکسٹ = نیونوڈ ؛} insertatBeginning (ڈیٹا: ٹی): باطل {کونسٹ نیو نوڈ = نیا نوڈ (ڈیٹا) ؛newnode.next = this.head ؛this.head = newnode ؛} ڈیلیٹینوڈ (ڈیٹا: ٹی): باطل {اگر (! this.head) {واپسی ؛} if (this.head.data === ڈیٹا) {this.head = this.head.next ؛واپسی ؛} موجودہ = this.head ؛جبکہ (موجودہ. نیکسٹ) {if (موجودہ. next.data === ڈیٹا) {موجودہ. نیکسٹ = کرنٹ.نیکسٹ. نیکسٹ ؛واپسی ؛} موجودہ = موجودہ۔ نیکسٹ ؛}} پرنٹ لسٹ (): باطل {آئیے موجودہ = this.head ؛جبکہ (موجودہ) {کنسول.لاگ (موجودہ.ڈیٹا) ؛موجودہ = موجودہ۔ نیکسٹ ؛}}} اس مثال میں ، ہم ایک نوڈ کلاس کی وضاحت کرتے ہیں جو منسلک فہرست میں نوڈ کی نمائندگی کرتا ہے۔نوڈ کلاس میں ایک ڈیٹا پراپرٹی ہوتی ہے جس میں نوڈ کی قیمت ہوتی ہے اور اگلی پراپرٹی جس میں تسلسل میں اگلے نوڈ کا حوالہ ہوتا ہے۔ ہم پھر لنکڈ لسٹ کلاس کی وضاحت کرتے ہیں جو لنکڈ فہرست کی نمائندگی کرتا ہے۔لنکڈ لسٹ کلاس میں ایک ہیڈ پراپرٹی ہے جو ترتیب میں پہلے نوڈ کا حوالہ رکھتی ہے۔لنکڈ لسٹ کلاس کے پاس لنکڈ فہرست کے اختتام پر نوڈ داخل کرنے ، لنکڈ فہرست کے آغاز میں ایک نوڈ داخل کرنے ، لنکڈ فہرست سے نوڈ کو حذف کرنے کے طریقے ہیں ، اور لنکڈ فہرست کے مندرجات کو پرنٹ کریں۔ ہم بنانے کے لئے جنرکس کا استعمال کریں۔نوڈ اور لنکڈ لسٹ کلاسز کسی بھی ڈیٹا کی قسم کے لئے دوبارہ استعمال کے قابل ہیں۔جب ہم کالعدم یا غیر متعینہ اقدار کی خصوصیات تک رسائی حاصل کرتے ہیں تو ہم غلطیوں سے بچنے کے لئے اختیاری زنجیر (؟) بھی استعمال کرتے ہیں۔ یہاں لنکڈ لسٹ کلاس کو کسی لنکڈ فہرست کو بنانے اور جوڑ توڑ کرنے کے لئے کس طرح استعمال کیا جائے: ٹائپ اسکرپٹکونسٹ فہرست = نئی لنکڈ لسٹ <نمبر> () ؛لسٹ۔ Insertatend (1) ؛ فہرست۔ Insertatend (2) ؛ فہرست۔ Insertatend (3) ؛ فہرست۔ InsertatBeginning (0) ؛ لسٹ۔ ڈیلیٹینوڈ (2) ؛ لسٹ۔ پرنٹ لسٹ () ؛// 0 1 3 اس مثال کے طور پر ، ہم لسٹ نامی ایک نیا لنکڈ لسٹ آبجیکٹ تیار کرتے ہیں اور لنکڈ لسٹ میں چار نوڈس داخل کرتے ہیں جس میں داخلہ اور داخل کرنے کے طریقوں کا استعمال کرتے ہیں۔اس کے بعد ہم ڈیلیٹینوڈ کے طریقہ کار کا استعمال کرتے ہوئے ویلیو 2 کے ساتھ نوڈ کو حذف کرتے ہیں اور پرنٹ لسٹ کے طریقہ کار کا استعمال کرتے ہوئے منسلک فہرست کے مندرجات کو پرنٹ کرتے ہیں۔ خلاصہ میں ، ٹائپ اسکرپٹ میں ایک واحد منسلک فہرست کو نافذ کرنے میں ایک نوڈ کلاس کی وضاحت شامل ہے جو منسلک فہرست میں نوڈ کی نمائندگی کرتی ہے اورایک لنکڈ لسٹ کلاس جو لنکڈ فہرست کی نمائندگی کرتی ہے۔لنکڈ لسٹ کلاس کے پاس لنکڈ فہرست کے اختتام پر نوڈ داخل کرنے ، لنکڈ فہرست کے آغاز میں ایک نوڈ داخل کرنے ، لنکڈ فہرست سے نوڈ کو حذف کرنے اور لنکڈ فہرست کے مندرجات کو پرنٹ کرنے کے طریقے ہیں۔لنکڈ لسٹوں کے ساتھ کام کرنے کا طریقہ سمجھنا موثر اور ذمہ دار ٹائپ اسکرپٹ ایپلی کیشنز بنانے کے لئے ضروری ہے جو اعداد و شمار کے ڈھانچے سے نمٹتے ہیں۔ ذرائع: [سطح کو کوڈنگ] 1 [ایگ ہیڈ.یو] 2 [ریکارڈو بورجز] 3 [دیو کمیونٹی] 4 [میڈیم] 5۔in-typescript3: https://icardoborges.dev/data-structuresin-typescript-linked-list4: https://dev.to/glebirovich/typescript-scructures-linked-list-3o8i5: //"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی صف پر بائنری تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ٹائپ اسکرپٹ بائنری تلاش میں انٹیجرز کی ایک صف پر بائنری تلاش کرنا ایک سرچ الگورتھم ہے جو اعداد و شمار کی ترتیب شدہ صف میں کسی قدر کی حیثیت کو تلاش کرتا ہے۔ایک ترتیب شدہ سرنی اور ایک ہدف کی قیمت کے پیش نظر ، بائنری سرچ سرنی کو دو پارٹیشنوں میں توڑ دیتی ہے اور ہدف کا موازنہ ہر پارٹیشن میں درمیانی عنصر سے کرتی ہے۔اگر یہ ہدف کے برابر ہے تو پھر یہ ان دونوں پوزیشنوں میں سے کسی ایک میں ہے ، بصورت دیگر ، بائنری سرچ یہ نتیجہ اخذ کرسکتی ہے کہ ہدف کی قیمت ان دو پارٹیشنوں میں سے ایک میں ہوگی جو ابھی تلاش کی جاسکتی ہے۔ یہاں ایک صف پر بائنری تلاش کرنے کے لئے کچھ حکمت عملی ہیں۔ٹائپ اسکرپٹ میں انٹیجرز کا: تکراری نقطہ نظر: تکراری نقطہ نظر میں صف کے ذریعے تکرار کرنا اور ہدف کی قیمت کا موازنہ سرنی کے درمیانی عنصر سے کرنا شامل ہے۔اگر ہدف کی قیمت درمیانی عنصر سے کم ہے تو ، سرنی کے بائیں نصف حصے میں تلاش جاری رہتی ہے۔اگر ہدف کی قیمت درمیانی عنصر سے زیادہ ہے تو ، سرنی کے دائیں نصف حصے میں تلاش جاری رہتی ہے۔اس نقطہ نظر کے لئے دو پوائنٹرز کو ٹریک رکھنے کی ضرورت ہے: کم پوائنٹر اور اعلی پوائنٹر۔ ریفرسیو نقطہ نظر: تکرار نقطہ نظر میں سرے کو دو حصوں میں تقسیم کرنا اور ہدف کی قیمت کا موازنہ سرنی کے درمیانی عنصر کے ساتھ کرنا شامل ہے۔اگر ہدف کی قیمت درمیانی عنصر سے کم ہے تو ، سرنی کے بائیں نصف حصے میں تلاش جاری رہتی ہے۔اگر ہدف کی قیمت درمیانی عنصر سے زیادہ ہے تو ، سرنی کے دائیں نصف حصے میں تلاش جاری رہتی ہے۔اس نقطہ نظر کے لئے تکرار کو روکنے کے لئے ایک بیس کیس کی ضرورت ہوتی ہے اور سرنی کو دو حصوں میں تقسیم کرنے کے لئے ایک بار بار آنے والی کال کی ضرورت ہوتی ہے۔ یہاں تک کہ تکراری نقطہ نظر کا استعمال کرتے ہوئے ٹائپ اسکرپٹ میں انٹیجرز کی صف پر بائنری تلاش کرنے کا طریقہ یہ ہے: ٹائپ اسکرپٹ فینکشن بائنری سرچ (نمبر: سرنی <<<نمبر> ، کلید: نمبر): نمبر {کم = 0 ؛چلیں اعلی = nums.length - 1 ؛جبکہ (کم <= اعلی) {آئیے مڈ = ریاضی۔ فلور ((کم + اعلی) / 2) ؛if (nums [وسط] === key) {واپس وسط ؛} if (key> nums [وسط]) {کم = وسط + 1 ؛} else {اعلی = وسط - 1 ؛}} ریٹرن -1 ؛} اس مثال میں ، ہم ایک بائنری سرچ فنکشن کی وضاحت کرتے ہیں جو نمبروں کی ایک صف اور ایک ہدف کی قیمت کو دلائل کے طور پر لیتا ہے اور صف میں ہدف کی قیمت کا اشاریہ واپس کرتا ہے۔ہم کم پوائنٹر کو 0 اور اعلی پوائنٹر کو سرنی کے آخری انڈیکس کی طرف شروع کرتے ہیں۔اس کے بعد ہم تھوڑی دیر کا استعمال کرتے ہوئے صف کے ذریعے تکرار کرتے ہیں اور فارمولے (کم + ہائی) / 2 کا استعمال کرتے ہوئے مڈ انڈیکس کا حساب کتاب کرکے سرنی کے درمیانی عنصر کے ساتھ ہدف کی قیمت کا موازنہ کرتے ہیں۔سرنی ، ہم مڈ انڈیکس لوٹاتے ہیں۔اگر ہدف کی قیمت صف کے درمیانی عنصر سے زیادہ ہے تو ، ہم نے کم پوائنٹر کو وسط + 1 پر سیٹ کیا۔ہدف کی قیمت صف میں نہیں پائی جاتی ہے ، ہم -1 کو واپس کرتے ہیں۔ یہاں تک کہ تکرار نقطہ نظر کا استعمال کرتے ہوئے ٹائپ اسکرپٹ میں عدد کی ایک صف پر بائنری تلاش کرنے کے طریقہ کی ایک مثال ہے: ٹائپ اسکرپٹ فنکشن بائنری سرچ (نمبر: سرنی <نمبر> ، کلید: کم نمبر ، کم کم ، کم ، کم ، کم ، کم ، کم ، کم نمبر ، کم نمبر ، کم نمبر ، کم ، کم: نمبر = 0 ، اعلی: نمبر = nums.length - 1): نمبر {if (کم> زیادہ) {واپسی -1 ؛mid مڈ = ریاضی۔ فلور ((کم + اعلی) / 2) ؛if (nums [وسط] === key) {واپس وسط ؛} if (key> nums [وسط]) {بائنری سرچ (نمبر ، کلید ، وسط + 1 ، اعلی) لوٹائیں۔} دوسری {بائنری سرچ (نمبر ، کلید ، کم ، وسط - 1) کی واپسی ؛}} اس مثال میں ، ہم ایک بائنری سرچ فنکشن کی وضاحت کرتے ہیں جو نمبروں کی ایک صف ، ایک ہدف کی قیمت ، ایک کم پوائنٹر ، اور ایک اعلی پوائنٹر کو دلائل کے طور پر لیتا ہے اور صف میں ہدف کی قیمت کا اشاریہ واپس کرتا ہے۔ہم کم پوائنٹر کو 0 اور اعلی پوائنٹر کو سرنی کے آخری انڈیکس تک شروع کرنے کے لئے پہلے سے طے شدہ پیرامیٹرز کا استعمال کرتے ہیں۔ہم ایک بیس کیس کی وضاحت کرتے ہیں جو کم پوائنٹر اعلی پوائنٹر سے زیادہ ہوتا ہے تو تکرار کو روکتا ہے۔اس کے بعد ہم فارمولے (کم + ہائی) / 2 کا استعمال کرتے ہوئے مڈ انڈیکس کا حساب لگاتے ہیں اور ہدف کی قیمت کو صف کے درمیانی عنصر سے موازنہ کرتے ہیں۔اگر ہدف کی قیمت صف کے درمیانی عنصر کے برابر ہے تو ، ہم مڈ انڈیکس کو لوٹاتے ہیں۔اگر ہدف کی قیمت صف کے درمیانی عنصر سے زیادہ ہے تو ، ہم بار بار بائنری سرچ فنکشن کو `مڈ + کے ساتھ کہتے ہیں۔"
    }
]