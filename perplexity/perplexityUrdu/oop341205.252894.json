[
    {
        "Question": "oop",
        "Answer": "آبجیکٹ پر مبنی پروگرامنگ (او او پی) ایک پروگرامنگ نمونہ ہے جو افعال اور منطق 123456 کے بجائے ڈیٹا ، یا اشیاء کے ارد گرد سافٹ ویئر ڈیزائن کا اہتمام کرتا ہے۔او او پی ایک بنیادی پروگرامنگ پیراڈیم ہے جو اپنے کیریئر 4 کے کسی موقع پر تقریبا ہر ڈویلپر کے ذریعہ استعمال ہوتا ہے۔او او پی کا بنیادی مقصد اعداد و شمار اور ان کے افعال کو ایک ساتھ باندھنا ہے جو ان پر چلتے ہیں تاکہ کوڈ کا کوئی دوسرا حصہ اس ڈیٹا تک رسائی حاصل نہ کرسکے۔آبجیکٹ ، جو صفات اور طریقوں کا ایک مجموعہ بیان کرتے ہیں جس میں آبجیکٹ 46. Objects: ایک شے ایک کلاس کی مثال ہے ، جس میں اس کی اپنی خصوصیات اور طریقوں کا ایک انوکھا سیٹ ہے۔ایک موجودہ طبقے پر مبنی ہو ، اس کی صفات اور طریقوں کو وراثت میں لائیں۔وہ پروگرام جو بڑے ، پیچیدہ اور فعال طور پر اپ ڈیٹ یا برقرار ہیں ، جیسے مینوفیکچرنگ اور ڈیزائن پروگرام ، نیز موبائل ایپلی کیشن 1۔تاہم ، او او پی کو سافٹ ویئر ڈویلپمنٹ کے ڈیٹا جزو کو زیادہ سے زیادہ سمجھنے اور گنتی یا الگورتھمز 12.1 ٹیٹارجٹ 2 ڈبلیو کیپیڈیا 3 جی ای ای ای ایس ایف آر جی ای ای ای ایکس 4 ای ڈی سی ٹی وی اے ٹی اے ٹی آر 6 ایموزیلہ پر زیادہ توجہ دینے پر تنقید کی گئی ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں انکیپسولیشن کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "انکپسولیشن آبجیکٹ پر مبنی پروگرامنگ (او او پی) میں ایک بنیادی تصور ہے جس میں اعداد و شمار میں حادثاتی ترمیم کو روکنے اور بیرونی دنیا 123456 سے پوشیدہ ہونے والی صفات تک رسائی کو کنٹرول کرنے کے لئے کسی ایک یونٹ جیسے ایک یونٹ کے اندر ڈیٹا اور طریقوں کو بنڈل کرنا شامل ہے۔کسی طبقے کے ڈیٹا ممبروں اور طریقوں کو نجی یا محفوظ قرار دے کر انکپسولیشن حاصل کیا جاتا ہے ، جس کا مطلب ہے کہ ان تک صرف کلاس یا اس کے سبکلاسس 12. میں ہی تک رسائی حاصل کی جاسکتی ہے ، انکپسولیشن کو عوامی ، محفوظ اور نجی استعمال کرکے نافذ کیا جاسکتا ہے۔ممبران ، جو ممبر 12 کے نام سے پہلے انڈر سکور کی عدم موجودگی یا موجودگی سے ظاہر ہوتے ہیں۔عوامی ممبروں تک کہیں سے بھی رسائی حاصل کی جاسکتی ہے ، محفوظ ممبروں تک صرف کلاس اور اس کے ذیلی طبقات سے ہی رسائی حاصل کی جاسکتی ہے ، اور نجی ممبروں کو صرف خود ہی کلاس کے اندر ہی تک رسائی حاصل کی جاسکتی ہے۔ یہاں ازگر میں انکپولیشن کی ایک مثال ہے: پائیٹونکلاس بینک اے سی اکاؤنٹ: ڈیف __init __ (__ __init __ (خود ، نام ، توازن): سیلف ۔_ نام = نام # محفوظ ممبر خود ۔__ بیلنس = بیلنس # نجی ممبر ڈیف ڈپازٹ (خود ، رقم): خود= مقدار: خودپرنٹس \"ناکافی بیلنس\" پرنٹ (اکاؤنٹ۔ گیٹ_بلنس ()) # پرنٹس 1500 پرنٹ (اکاؤنٹ۔ نام) # پرنٹس \"جان\" پرنٹ (اکاؤنٹ .__ بیلنس) # اس مثال کو بڑھاتا ہے اس مثال کے طور پر ، بینک اکاؤنٹ کلاس میں ایک محفوظ ممبر _ نام اور نجی ہے۔ممبر __ بیلنس ، جس تک صرف کلاس ہی سے ہی رسائی حاصل کی جاسکتی ہے۔کلاس میں عوامی طریقوں کی جمع ، واپسی ، اور get_balance بھی ہے ، جو اکاؤنٹ کے توازن میں ترمیم یا بازیافت کے لئے استعمال کیا جاسکتا ہے۔جمع کروانے اور واپس لینے کے طریقوں سے نجی ممبر __ توازن میں ترمیم کی جاتی ہے ، جبکہ get_balance طریقہ اسے بازیافت کرتا ہے۔آخر میں ، اکاؤنٹ کا آبجیکٹ تیار کیا جاتا ہے اور اکاؤنٹ کے توازن کو جمع کرنے ، واپس لینے اور بازیافت کرنے کے ساتھ ساتھ اکاؤنٹ کا نام اور توازن پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔"
    },
    {
        "Question": "ساخت اور وراثت میں کیا فرق ہے؟ہر ایک کے لئے ایک مثال دیں۔",
        "Answer": "مرکب اور وراثت آبجیکٹ پر مبنی پروگرامنگ (OOP) میں دو بڑے تصورات ہیں جو دو طبقوں کے مابین تعلقات کو ماڈل بنانے کے لئے استعمال ہوتے ہیں تاکہ ڈویلپرز کے لئے دوبارہ استعمال کے قابل کوڈ 123456 لکھنا آسان ہو۔ساخت اور وراثت کے درمیان بنیادی فرق یہ ہے کہ وہ کوڈ کو دوبارہ استعمال کیسے کرتے ہیں اور کلاسوں کو کس طرح مضبوطی سے جوڑ دیا جاتا ہے۔ یہاں ساخت اور وراثت کے مابین کلیدی اختلافات ہیں: وراثت: وراثت کلاسوں کے مابین ایک \"IS-A\" رشتہ ہے ، جہاں ایک ذیلی طبقہ وراثت میں ہوتا ہےاس کے سپر کلاس 12346 کی خصوصیات اور طریقے۔وراثت کا استعمال کلاسوں کے ایک درجہ بندی کے ماڈل کے لئے کیا جاتا ہے ، جہاں ہر ذیلی طبقے اس کے سپر کلاس 12346 کا ایک زیادہ خصوصی ورژن ہے۔وراثت کو مضبوطی سے جوڑ دیا جاتا ہے ، اس کا مطلب یہ ہے کہ سپر کلاس میں تبدیلیاں سبکلاس 12346 کے طرز عمل کو متاثر کرسکتی ہیں۔ساخت کا استعمال آسان اشیاء سے پیچیدہ اشیاء بنانے کے لئے کیا جاتا ہے ، جہاں ہر شے کی ایک مخصوص ذمہ داری 123456 ہوتی ہے۔ساخت ڈھیلے سے مل کر ہے ، اس کا مطلب یہ ہے کہ ایک طبقے میں تبدیلیاں دوسری کلاس 123456 کے طرز عمل کو متاثر نہیں کرتی ہیں۔ یہاں ازگر میں وراثت کی ایک مثال ہے: ازگرکلاس جانور: ڈیف __init __ (خود ، نام)): پاسکلاس کتا (جانور): ڈیف اسپیک (خود): واپس \"ووف!\" کلاس بلی (جانور): ڈیف اسپیک (خود): واپس \"میانو!\" کتا = کتا (\"فیڈو\") بلی = بلی (\"سرگوشیاں\") پرنٹ (ڈاگ اسپیک ()) # پرنٹس\" ووف! \"پرنٹ (بلی.س اسپیک ()) # پرنٹس\" میو! \"اس مثال میں ، جانوروں کی کلاس سپر کلاس ہے ، اور کتا اور بلی کی کلاسیں سب کلاس ہیں۔جو جانوروں کی کلاس سے وارث ہے۔جانوروں کی کلاس میں ایک __init__ طریقہ ہے جو نام کی وصف کو شروع کرتا ہے ، اور ایک ایسا بولنے والا طریقہ ہے جو کتے اور بلی کی کلاسوں کے بولنے کے طریقوں سے اوورڈ ہوتا ہے۔کتے اور بلی کی کلاسوں کے اپنے بولنے کے طریقے ہیں جو جانوروں کی آواز کو لوٹاتے ہیں۔آخر میں ، کتا اور بلی کی اشیاء تخلیق کی جاتی ہیں اور ان کے متعلقہ بولنے کے طریقوں کو کال کرنے کے لئے استعمال کی جاتی ہیں۔ یہاں ازگر میں تشکیل کی ایک مثال ہے: ازگر کلاس انجن: ڈیف اسٹارٹ (خود): پرنٹ (\"انجن شروع\") ڈیف اسٹاپ (خود): پرنٹ.CAR () CAR.START () # پرنٹس \"انجن نے شروع کیا\" کار۔ اسٹاپ () # پرنٹس \"انجن رک گیا\" اس مثال میں ، انجن کلاس ایک علیحدہ کلاس ہے جس کے انجن کو شروع کرنے اور روکنے کے اپنے طریقے ہیں۔کار کلاس میں انجن کلاس کی ایک مثال ممبر متغیر کی حیثیت سے ہوتی ہے ، جو __init__ طریقہ کار میں شروع کی جاتی ہے۔کار کلاس کا اپنا آغاز اور اسٹاپ طریقے بھی ہیں جو انجن کلاس کے آغاز اور اسٹاپ طریقوں کے لئے تفویض کرتے ہیں۔آخر میں ، کار آبجیکٹ کو اپنے اسٹارٹ اور اسٹاپ طریقوں کو کال کرنے کے لئے تخلیق اور استعمال کیا جاتا ہے ، جو اس کے نتیجے میں انجن کی کلاس کے آغاز اور اسٹاپ طریقوں کو کہتے ہیں۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں ٹھوس اصولوں کی وضاحت کریں اور بتائیں کہ وہ سافٹ ویئر سسٹم کے معیار کو کس طرح بہتر بناسکتے ہیں۔",
        "Answer": "ٹھوس اصول پانچ ڈیزائن اصولوں کا ایک مجموعہ ہیں جو 2000 میں رابرٹ سی مارٹن (a.k.a انکل باب) نے متعارف کروائے تھے ، جن کا مقصد آبجیکٹ پر مبنی ڈیزائنوں کو زیادہ قابل فہم ، لچکدار اور برقرار رکھنے والا 1234 بنانا ہے۔ٹھوس مخفف کا مطلب مندرجہ ذیل اصولوں کے لئے ہے: واحد ذمہ داری کا اصول (ایس آر پی): کسی کلاس کے پاس تبدیل ہونے کی صرف ایک وجہ ہونی چاہئے ، اس کا مطلب یہ ہے کہ اس کی صرف ایک ذمہ داری 13 ہونی چاہئے۔اس اصول سے کلاسوں کو مرکوز اور برقرار رکھنے میں مدد ملتی ہے ، اور کلاسوں کے مابین سخت جوڑے سے بچنے کے ل .۔ اوپن بند اصول (او سی پی): ایک کلاس توسیع کے لئے کھلا لیکن ترمیم کے لئے بند ہونا چاہئے ، اس کا مطلب ہے کہ A میں نئی فعالیت شامل کرنا ممکن ہونا چاہئے۔اس کے موجودہ کوڈ 13 کو تبدیل کیے بغیر کلاس۔یہ اصول کوڈ کو مزید لچکدار اور دوبارہ قابل استعمال بنانے میں مدد کرتا ہے ، اور جب نئی خصوصیات کو شامل کیا جاتا ہے تو موجودہ کوڈ کو توڑنے سے بچنے کے ل .۔ لیسکوف متبادل اصول (ایل ایس پی): ذیلی قسمیں ان کی بنیاد کی اقسام کے لئے متبادل ہونا چاہئے ، اس کا مطلب ہے کہ ذیلی طبقے کی اشیاء کو تبدیل کرنے کے قابل ہونا چاہئے۔پروگرام 123 کی درستگی کو متاثر کیے بغیر ان کے سپر کلاس کے آبجیکٹ۔یہ اصول اس بات کو یقینی بنانے میں مدد کرتا ہے کہ کلاس اچھی طرح سے ڈیزائن کیا گیا ہے اور جب وہ مختلف سیاق و سباق میں استعمال ہونے پر توقع کے مطابق برتاؤ کرتے ہیں۔جتنا چھوٹا اور ممکنہ حد تک مرکوز ہونے کے لئے ڈیزائن کیا گیا ہے۔یہ اصول کلاسوں کے مابین جوڑے کو کم کرنے اور کوڈ کو زیادہ ماڈیولر اور برقرار رکھنے میں مدد کرتا ہے۔ انحصار الٹا اصول (DIP): اعلی سطح کے ماڈیولز کو کم سطح کے ماڈیول پر انحصار نہیں کرنا چاہئے ، لیکن دونوں کو تجریدوں پر انحصار کرنا چاہئے ، اس کا مطلب ہے کہ کلاسوں پر انحصار کرنا چاہئے۔کنکریٹ کے نفاذ 123 کے بجائے خلاصہ۔اس اصول سے کلاسوں کے مابین جوڑے کو کم کرنے اور کوڈ کو زیادہ لچکدار اور قابل جانچ بنانے میں مدد ملتی ہے۔ ٹھوس اصولوں پر عمل کرتے ہوئے ، ڈویلپرز سافٹ ویئر سسٹم کے معیار کو کئی طریقوں سے بہتر بنا سکتے ہیں ، جن میں شامل ہیں: کلاس میکنگ کوڈ کے مابین کوڈ کو زیادہ ماڈیولر اور برقرار رکھنے کے جوڑے کو زیادہ لچکدار اور برقرار رکھنے میں مدد مل سکتی ہے۔دوبارہ استعمال کرنے والے کوڈ کو زیادہ قابل امتحان اور کم غلطی کی پیش کش کا کوڈ زیادہ توسیع پذیر اور تقاضوں کو تبدیل کرنے کے ل app موافقت پذیر ، ٹھوس اصول رہنما اصولوں اور بہترین طریقوں کا ایک مجموعہ فراہم کرتے ہیں جو ڈویلپرز کو بہتر کوڈ لکھنے اور زیادہ مضبوط اور برقرار رکھنے والے سافٹ ویئر سسٹمز بنانے میں مدد فراہم کرسکتے ہیں۔"
    },
    {
        "Question": "\"پش ، پاپ اور جھانکنے کے طریقوں کے ساتھ اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو پش ، پاپ ، اور جھانکنے کے طریقوں کے ساتھ اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتا ہے: پائیٹونکلاس اسٹیک: ڈیف __init __ (خود): سیلف ڈاٹ آئٹمز = [] ڈیف پش (خود ، آئٹم).خود): ریٹرن لین (self.items) == 0 اس پر عمل درآمد میں ، اسٹیک کلاس میں ایک __init__ طریقہ ہے جو اسٹیک کی اشیاء کو ذخیرہ کرنے کے لئے خالی فہرست کو شروع کرتا ہے۔کلاس کے پاس ایک پش طریقہ بھی ہے جو اسٹیک کے اوپری حصے میں فہرست میں شامل کرکے ، ایک پاپ طریقہ جو اسٹیک کی اوپری شے کو ہٹاتا ہے اور واپس کرتا ہے اگر اسٹیک خالی نہیں ہے تو ، ایک جھانکنے والا طریقہ جو واپس کرتا ہے۔اگر اسٹیک خالی نہیں ہے تو اسٹیک کی سب سے اوپر کی شے کو ہٹائے بغیر ، اور اگر اسٹیک خالی اور غلط ہے تو اس کا ایک ایسا طریقہ ہے جو اسٹیک کلاس کو استعمال کرنے کی ایک مثال ہے: ازگر اسٹیک = اسٹیک () اسٹیک۔پش (1) اسٹیک۔ پش (2) اسٹیک۔ پش (3) پرنٹ (اسٹیک.پیک ()) # پرنٹ 3 پرنٹ (اسٹیک.پپ ()) # پرنٹ 3 پرنٹ (اسٹیک.پپ ()) # پرنٹ 2 پرنٹ (اسٹیک۔پاپ ()) # پرنٹس 1 پرنٹ (اسٹیک.پپ ()) # پرنٹس نمبر نہیں یہ مثال کے طور پر ، ایک اسٹیک آبجیکٹ تیار کیا جاتا ہے اور تین اشیاء کو اسٹیک پر دھکیلنے کے لئے استعمال کیا جاتا ہے۔اس کے بعد اسٹیک کی اوپری آئٹم کو بغیر ہٹائے بغیر بازیافت کرنے کے لئے جھانکنے کا طریقہ استعمال کیا جاتا ہے ، اور پاپ طریقہ کار کو ایک ایک کرکے اسٹیک کی اوپری اشیاء کو ہٹانے اور واپس کرنے کے لئے استعمال کیا جاتا ہے۔آخر میں ، پاپ طریقہ کو خالی اسٹیک پر بلایا جاتا ہے ، جو کوئی بھی نہیں لوٹتا ہے۔"
    },
    {
        "Question": "ازگر میں طریقہ اوورلوڈنگ اور طریقہ اوور رائڈنگ کیا ہے؟ہر ایک کے لئے ایک مثال پیش کریں۔",
        "Answer": "طریقہ اوورلوڈنگ اور طریقہ اوور رائڈنگ آبجیکٹ پر مبنی پروگرامنگ میں دو تصورات ہیں جو اسی نام کے ساتھ طریقوں کی وضاحت کرنے کے لئے استعمال ہوتے ہیں لیکن مختلف طرز عمل 123456۔طریقہ اوورلوڈنگ اور طریقہ اوور رائڈنگ کے درمیان بنیادی فرق یہ ہے کہ طریقہ اوورلوڈنگ ایک ہی کلاس کے اندر انجام دی جاتی ہے ، جبکہ والدین کی کلاس اور بچے کی کلاس 13456 کے مابین طریقہ کار اوور رائڈنگ انجام دی جاتی ہے۔ طریقہ کار اوورلوڈنگ اور طریقہ اوور رائڈنگ کے مابین کلیدی اختلافات: طریقہ اوورلوڈنگ: طریقہ کار: طریقہ کار: طریقہاوورلوڈنگ مرتب وقتی پولیمورفزم کی ایک خصوصیت ہے ، جہاں ایک ہی طبقے کے متعدد طریقوں میں ایک ہی نام ہوسکتا ہے لیکن مختلف پیرامیٹرز 13456۔طریقوں میں زیادہ فعالیت شامل کرنے اور کوڈ کو زیادہ پڑھنے کے قابل اور برقرار رکھنے والے 13456 بنانے کے لئے طریقہ اوورلوڈنگ کا استعمال کیا جاتا ہے۔نوٹ کریں کہ ازگر طریقہ کار سے زیادہ بوجھ ڈالنے کی حمایت نہیں کرتا ہے ، لیکن یہ ممکن ہے کہ پہلے سے طے شدہ دلائل یا متغیر لمبائی کے دلائل 1456 کا استعمال کرتے ہوئے اس کی نقالی ممکن ہو۔وہ طریقہ جو پہلے ہی اس کے والدین کی کلاس 13456 کے ذریعہ فراہم کیا گیا ہے۔موجودہ طریقوں کے طرز عمل کو تبدیل کرنے اور کوڈ کو مزید لچکدار اور قابل توسیع 13456 بنانے کے لئے طریقہ کار اوور رائڈنگ کا استعمال کیا جاتا ہے۔طریقہ اوور رائڈنگ کے لئے والدین اور بچوں کی کلاسوں کے مابین وراثت کی ضرورت ہوتی ہے ، اور یہ والدین کی کلاس 13456 کی طرح بچوں کی کلاس میں اسی نام اور دستخط کے ساتھ کسی طریقہ کی وضاحت کرکے کیا جاتا ہے۔ یہاں ازگر میں اوورلوڈنگ کے طریقہ کار کی ایک مثال ہے: پیتھونکلاس کیلکولیٹر.کیلکولیٹر.اڈی (1 ، 2 ، 3)) # پرنٹس 6 ان مثال کے طور پر ، کیلکولیٹر کلاس میں ایک ہی نام کے ساتھ دو طریقے شامل ہیں لیکن مختلف پیرامیٹرز۔پہلا ADD طریقہ دو دلائل لیتا ہے اور ان کی رقم واپس کرتا ہے ، جبکہ دوسرا ADD طریقہ تین دلائل لیتا ہے اور ان کی رقم واپس کرتا ہے۔تاہم ، جب ADD کے طریقہ کار کو دو دلائل کے ساتھ بلایا جاتا ہے تو ، یہ ایک ٹائپ ایرر اٹھاتا ہے کیونکہ ازگر طریقہ کار سے زیادہ بوجھ ڈالنے کی حمایت نہیں کرتا ہے۔ یہاں ازگر میں طریقہ کار کی ایک مثال ہے: ازگر کلاس جانوروں: ڈیف اسپیک (خود): پرنٹ (\"جانور بولتا ہے\")کلاس ڈاگ (جانور): ڈیف اسپیک (خود): پرنٹ (\"کتے کے چھال\") جانور = جانور () جانور () اسپیک () # پرنٹس \"جانور بولتا ہے\" کتا = کتا () ڈاگ۔ اسپیک () # پرنٹس \"ڈاگ بارک\"اس مثال میں ، جانوروں کی کلاس کے پاس ایک بولنے کا طریقہ ہے جو عام پیغام پرنٹ کرتا ہے ، جبکہ کتے کی کلاس کتوں کے لئے ایک مخصوص پیغام پرنٹ کرنے کے لئے بولنے کے طریقہ کار کو زیر کرتی ہے۔جب کسی جانوروں کی شے پر بولنے کا طریقہ طلب کیا جاتا ہے تو ، یہ عام پیغام پرنٹ کرتا ہے ، جب جب اسپیکر کے طریقہ کار کو کتے کے آبجیکٹ پر بلایا جاتا ہے تو ، یہ کتوں کے لئے مخصوص پیغام پرنٹ کرتا ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں پولیمورفزم کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "پولیمورفزم آبجیکٹ پر مبنی پروگرامنگ (OOP) میں ایک تصور ہے جو مختلف طبقوں کے اشیاء کو ایسا سلوک کرنے کی اجازت دیتا ہے جیسے وہ ایک مشترکہ انٹرفیس 123456 کا استعمال کرکے ایک ہی طبقے کی اشیاء ہیں۔پولیمورفزم وراثت اور انٹرفیس کا استعمال کرکے حاصل کیا جاتا ہے ، جو اشیاء کو اپنے مخصوص ٹائپ 123456 کو جانے بغیر ، عام انداز میں استعمال کرنے کی اجازت دیتے ہیں۔پولیمورفزم او او پی کی ایک طاقتور خصوصیت ہے جو ڈویلپرز کو زیادہ لچکدار اور قابل توسیع کوڈ لکھنے کی اجازت دیتی ہے ، اور موجودہ کوڈ کو زیادہ آسانی سے استعمال کرنے کی اجازت دیتی ہے۔) کلاس ڈاگ (جانور): ڈیف اسپیک (خود): پرنٹ (\"کتے کے چھالے\") کلاس بلی (جانور): ڈیف اسپیک (خود): پرنٹ (\"بلی میئو\") ڈیف میک_انیمل_ اسپیک (جانور): جانوروں کی جگہ (جانوروں کی)جانور = جانوروں () کتا = کتا () بلی = بلی () میک_انیمل_ اسپیک (جانور) # پرنٹس \"جانور بولتا ہے\" میک_انیمل_ اسپیک (کتا) # پرنٹس \"ڈاگ بارکس\" میک_انیمل_ اسپیک (بلی) # پرنٹس \"بلی میو\"جانوروں کی کلاس کے پاس ایک بولنے کا طریقہ ہے جو ایک عام پیغام پرنٹ کرتا ہے ، جبکہ کتے اور بلیوں کی کلاسیں بالترتیب کتوں اور بلیوں کے لئے ایک مخصوص پیغام پرنٹ کرنے کے لئے بولنے کے طریقہ کار کو زیر کرتی ہیں۔میک_انیمل_ اسپیک فنکشن جانوروں کی شے کو پیرامیٹر کے طور پر لیتا ہے اور اس کے بولنے کے طریقہ کار کو کال کرتا ہے ، جسے کتے اور بلی کی کلاسوں کے بولنے کے طریقوں سے اوورراڈ کیا جاسکتا ہے۔آخر میں ، جانور ، کتا ، اور بلی کی اشیاء بنائی جاتی ہیں اور میک_انیمل_ اسپیک فنکشن کو کال کرنے کے لئے استعمال کی جاتی ہیں ، جو اس کے نتیجے میں ان کے متعلقہ بولتے ہیں۔"
    },
    {
        "Question": "\"ایک ازگر کی کلاس کو نافذ کریں جو بائنری سرچ ٹری کی نمائندگی کرتے ہیں جس میں اندراج ، حذف کرنے اور تلاش کے طریقوں کے ساتھ۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو بائنری سرچ ٹری کی نمائندگی کرتا ہے جس میں اندراج ، حذف کرنے ، اور تلاش کے طریقوں کے ساتھ: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹا = ڈیٹا سیلف = کوئی بھی نہیں۔ نونکلاس بائنری سرچ ٹری: Def __init __ (خود): self.root = کوئی بھی Def داخل (خود ، ڈیٹا): اگر self.root کوئی نہیں ہے: self.root = نوڈ (ڈیٹا) اور: سیلف۔خود ، ڈیٹا ، نوڈ): اگر ڈیٹا <نوڈ.ڈیٹا: اگر نوڈ ڈاٹ ایل ایف ٹی کوئی نہیں ہے: نوڈ۔ لیفٹ = نوڈ (ڈیٹا) اور: خود۔نوڈ۔ رائٹ = نوڈ (ڈیٹا) اور: سیلف۔Def _delete (خود ، ڈیٹا ، نوڈ): اگر نوڈ کوئی نہیں ہے: نوڈ واپس کریں اگر ڈیٹا <نوڈ ڈاٹ ڈیٹا: نوڈ.لفٹ = سیلف۔._delete (ڈیٹا ، نوڈ. رائٹ) اور: اگر node.left کوئی نہیں ہے: واپسی نوڈ۔ رائٹ ایلف نوڈ۔ رائٹ کوئی نہیں ہے: واپسی نوڈ۔ لیفٹ اور: ٹیمپ = سیلف۔.data node.right = self._delete (temp.data ، node.right) واپسی نوڈ Def _find_min_node (سیلف ، نوڈ): جبکہ نوڈ. لیفٹ کوئی نہیں ہے: نوڈ = نوڈ۔ لیفٹ ریٹرن نوڈ ڈیف سرچ (خود ، ڈیٹا): اگر self.rot کوئی بھی نہیں ہے: خود واپس کریں۔سچے الیف ڈیٹا <نوڈ.ڈیٹا: خود کو واپس کریں۔ایک ڈیٹا وصف اور دو بچوں کے نوڈس ، بائیں اور دائیں۔بائنری سرچ ٹری کلاس میں ایک جڑ وصف ہے جو درخت کے جڑ نوڈ کی نمائندگی کرتا ہے۔کلاس کے پاس ایک داخل کرنے کا طریقہ بھی ہے جو درخت میں ایک نیا نوڈ داخل کرتا ہے ، ایک _ انرٹ کا طریقہ جو نئے نوڈ کو داخل کرنے کے لئے صحیح پوزیشن کی بار بار تلاش کرتا ہے ، ایک حذف کرنے والا طریقہ جو درخت سے نوڈ کو حذف کرتا ہے ، ایک _ ڈیلیٹ طریقہ جو بار بار تلاش کرتا ہے جو بار بار تلاش کرتا ہےحذف کرنے اور حذف کرنے کے مختلف معاملات کو سنبھالنے کے لئے نوڈ ، ایک _find_min_node طریقہ جو ایک ذیلی ٹری میں کم سے کم نوڈ تلاش کرتا ہے ، ایک تلاش کا طریقہ جو درخت میں دی گئی قیمت کے ساتھ نوڈ کی تلاش کرتا ہے ، اور ایک _ تلاش کا طریقہ جو نوڈ کے لئے بار بار تلاش کرتا ہے۔دی گئی قیمت کے ساتھ۔ یہاں بائنری سرچ ٹری کلاس کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیتھنبسٹ = بائنری سرچ ٹری () بی ایس ٹی. insert (5) BST.Insert (3) BST.Insert (7) BST.Insert (1) BST.Insert (9) پرنٹ (bst.search (7)) # پرنٹس ٹری بی ایس ٹی۔ ڈیلیٹ (7) پرنٹ (bst.search (7)) # پرنٹس فالس اس مثال کے طور پر ، ایک بائنری سرچ ٹری آبجیکٹ تیار کیا جاتا ہے اور درخت میں پانچ نوڈس داخل کرنے کے لئے استعمال ہوتا ہے۔اس کے بعد تلاش کا طریقہ استعمال کیا جاتا ہے جس کی قیمت 7 کے ساتھ نوڈ کی تلاش ہوتی ہے ، جو سچائی لوٹتی ہے۔اس کے بعد حذف کرنے کا طریقہ نوڈ کو ویلیو 7 کے ساتھ حذف کرنے کے لئے استعمال کیا جاتا ہے ، اور تلاش کے طریقہ کار کو دوبارہ قیمت 7 کے ساتھ نوڈ کی تلاش کے لئے استعمال کیا جاتا ہے ، جو غلط کو واپس کرتا ہے۔"
    },
    {
        "Question": "طبقاتی متغیر اور ازگر میں ایک مثال کے متغیر کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے ایک مثال دیں۔",
        "Answer": "ازگر میں ، ایک کلاس میں متغیر کی دو اقسام ہیں: کلاس متغیر اور مثال کے متغیر 123456۔متغیر کی ان دو اقسام کے درمیان بنیادی فرق یہ ہے کہ کلاس متغیر کلاس کے تمام واقعات میں مشترکہ ہیں ، جبکہ مثال کے متغیر کلاس 123456 کی ہر مثال کے لئے منفرد ہیں۔ کلاس متغیر اور مثال کے متغیر کے مابین کلیدی اختلافات: کلاس متغیر: کلاس متغیر: کلاس متغیر: کلاس متغیرمتغیرات کو کلاس کی سطح پر اعلان کیا جاتا ہے اور کلاس 123456 کی تمام مثالوں میں مشترکہ ہیں۔کلاس متغیر اعداد و شمار کو ذخیرہ کرنے کے لئے مفید ہیں جو کلاس کے تمام واقعات ، جیسے مستقل یا پہلے سے طے شدہ اقدار 25 کے لئے عام ہے۔کلاس کے نام کا استعمال کرتے ہوئے کلاس کے متغیرات تک رسائی حاصل کی جاتی ہے ، بجائے اس کے کہ نام 123456۔ انسٹینس متغیرات: مثال کے طور پر متغیرات کو مثال کے طور پر اعلان کیا جاتا ہے اور کلاس 123456 کی ہر مثال کے لئے انفرادیت رکھتے ہیں۔مثال کے طور پر متغیر ڈیٹا کو ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے جو کلاس کی ہر مثال کے لئے مخصوص ہے ، جیسے آبجیکٹ پراپرٹیز 25۔مثال کے طور پر نام کا استعمال کرتے ہوئے مثال کے طور پر متغیرات تک رسائی حاصل کی جاتی ہے۔: self.make = بنائیں # مثالCAR2.WEELS) # پرنٹس 4 پرنٹ (CAR1.MAKE) # پرنٹس \"ٹویوٹا\" پرنٹ (CAR2.MAKE) # پرنٹس \"ہونڈا\" کار 1. وہیل = 3 پرنٹ (CAR1.WHEELS) # پرنٹس 3 پرنٹ (CAR2.Wheels) # پرنٹس 4 انمثال کے طور پر ، کار کلاس میں ایک کلاس متغیر پہیے ہیں جو کلاس کے تمام واقعات میں مشترکہ ہیں اور 4 پر سیٹ کیا گیا ہے۔ کلاس میں دو مثال کے متغیرات ، میک اور ماڈل بھی ہیں ، جو کلاس کی ہر مثال کے لئے منفرد ہیں۔دو کار آبجیکٹ ، CAR1 اور CAR2 ، مختلف میک اور ماڈل اقدار کے ساتھ تخلیق کیے گئے ہیں۔جب پہیے وصف کو مثال کے ناموں کا استعمال کرتے ہوئے حاصل کیا جاتا ہے تو ، یہ کلاس متغیر کی قیمت لوٹاتا ہے ، جو دونوں واقعات کے لئے 4 ہے۔جب میک وصف کو مثال کے ناموں کا استعمال کرتے ہوئے حاصل کیا جاتا ہے تو ، یہ مثال کے متغیر کی قیمت لوٹاتا ہے ، جو ہر مثال کے لئے مختلف ہے۔آخر میں ، CAR1 کی پہیے وصف کو 3 میں تبدیل کردیا گیا ہے ، لیکن اس سے صرف کار 1 کے پہیے وصف پر اثر پڑتا ہے ، نہ کہ کار 2.1 javatPoint2atatus3careerkarrakrama4geeksforgeiks5digitalocean6tuturialspoint کی پہیے وصف"
    },
    {
        "Question": "ازگر میں وراثت کے تصور کی وضاحت کریں اور ایک مثال پیش کریں جس میں واحد وراثت کا مظاہرہ کیا جائے۔",
        "Answer": "وراثت آبجیکٹ پر مبنی پروگرامنگ میں ایک تصور ہے جو ایک نئی کلاس کو موجودہ طبقے پر مبنی ہونے کی اجازت دیتا ہے ، جو اس کی صفات اور طریقوں کو وراثت میں حاصل کرتا ہے ۔123456۔موجودہ کلاس کو پیرنٹ کلاس یا بیس کلاس کہا جاتا ہے ، اور نئی کلاس کو چائلڈ کلاس یا ماخوذ کلاس 123456 کہا جاتا ہے۔والدین کی کلاس 123456 کا ایک زیادہ خصوصی ورژن بنانے کے لئے چائلڈ کلاس نئی صفات اور طریقوں کو شامل کرسکتی ہے ، یا موجودہ طریقوں کو اوور رائڈ کرسکتی ہے۔ازگر میں ، وراثت کو نحو کلاس چائلڈ کلاس (پیرنٹکلاس) کا استعمال کرتے ہوئے نافذ کیا جاتا ہے: 123456. اس کی ایک مثال ہے جو ازگر میں واحد وراثت کا مظاہرہ کرتی ہے: ازگرکلاس جانور: ڈیف __init __ (خود ، نام): سیلف ڈاٹ نام = نام ڈیف (خود): پرنٹ(\"جانور بولتا ہے\") کلاس ڈاگ (جانور): ڈیف __init __ (خود ، نام ، نسل): سپر ()جانوروں (\"عام جانور\") کتا = کتا (\"فیڈو\" ، \"لیبراڈور\") پرنٹ (جانوروں کا نام) # پرنٹس \"جنرک جانوروں\" جانور \"اسپیک () # پرنٹس\" جانوروں کی بات \"پرنٹ (ڈاگ نام) # پرنٹس\"فیڈو\" پرنٹ (ڈاگ بریڈ) # پرنٹس \"لیبراڈور\" ڈاگ۔ اسپیک () # پرنٹس \"ڈاگ بارکس\" اس مثال میں ، جانوروں کی کلاس میں ایک __init__ طریقہ ہے جو جانوروں کے نام کے وصف کو شروع کرتا ہے ، اور ایک بولنے کا طریقہ یہ ہے کہایک عام پیغام پرنٹ کرتا ہے۔کتے کی کلاس نحو کلاس ڈاگ (جانور) کا استعمال کرتے ہوئے جانوروں کی کلاس سے وراثت میں ملتی ہے ، اور کتے کو نسل کی ایک وصف شامل کرتی ہے۔کتے کی کلاس کتوں کے لئے ایک مخصوص پیغام پرنٹ کرنے کے لئے جانوروں کی کلاس کے بولنے کے طریقہ کار کو بھی زیر کرتی ہے۔جانوروں اور کتے کی کلاسوں کا استعمال کرتے ہوئے بالترتیب دو چیزیں ، جانوروں اور کتے کو تخلیق کیا گیا ہے۔جب جانوروں اور کتے کے نام کی وصف تک رسائی حاصل ہوتی ہے تو ، یہ متعلقہ شے کے نام کے وصف کی قیمت لوٹاتا ہے۔جب جانوروں اور کتے کے بولنے کا طریقہ کہا جاتا ہے تو ، یہ جانوروں کے لئے عام پیغام اور کتوں کے لئے مخصوص پیغام پرنٹ کرتا ہے۔"
    },
    {
        "Question": "\"اندراج ، حذف کرنے اور ٹریورسل کے طریقوں کے ساتھ منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو اندراج ، حذف کرنے ، اور ٹریورسل کے طریقوں کے ساتھ منسلک فہرست کی نمائندگی کرتا ہے: پائیتھنکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیل۔ نیکسٹ = نون کلاس لنکڈ لسٹ: ڈیف __init __ (خود): self.head = کوئی بھی DEF ضمیمہ (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر سیلف ہیڈ کوئی نہیں ہے: خود نہیں ہے۔.next موجودہ۔ نیکسٹ = new_node def داخل (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) new_node.next = self.head self.head = new_node def ڈیلیٹ (خود ، ڈیٹا)self.head.data == اعداد و شمار: self.head = self.head.next else: موجودہ = self.head جبکہ موجودہ نہیں۔ نیکسٹ کوئی نہیں ہے: اگر موجودہ۔ نیکسٹ.ڈیٹا == ڈیٹا: موجودہ۔ نیکسٹ = کرنٹ۔ نیکسٹ. نیکسٹ ریٹرن کرنٹ = کرنٹ۔ نیکسٹ ڈیف پرنٹ (خود): موجودہ = سیلف ہیڈ جبکہ موجودہ کوئی نہیں ہے: پرنٹ (کرنٹ.ڈیٹا) موجودہ = کرنٹ۔ اس نفاذ کو ، نوڈ کلاس لنکڈ فہرست میں ایک نوڈ کی نمائندگی کرتا ہے ،جس میں ڈیٹا وصف اور اگلی وصف ہے جو فہرست میں اگلے نوڈ کی طرف اشارہ کرتا ہے۔لنکڈ لسٹ کلاس میں ایک سر وصف ہے جو فہرست میں پہلے نوڈ کی نمائندگی کرتا ہے۔کلاس کے پاس ایک ضمیمہ کا طریقہ بھی ہے جو فہرست کے آخر میں ایک نیا نوڈ شامل کرتا ہے ، ایک داخل کرنے کا طریقہ جو فہرست کے آغاز میں ایک نیا نوڈ داخل کرتا ہے ، ایک حذف کرنے والا طریقہ جو فہرست سے دی گئی قیمت کے ساتھ نوڈ کو حذف کرتا ہے ، اورایک پرنٹ کا طریقہ جو فہرست میں تمام نوڈس کی اقدار کو پرنٹ کرتا ہے۔ اس کی ایک مثال ہے کہ لنکڈ لسٹ کلاس کو کس طرح استعمال کیا جائے: پائیتھنل = لنکڈ لسٹ () ll.append (1) ll.append (2) ll.append (3) LL.insert (0) ll.delete (2) ll.print () # پرنٹس 0 1 3 میں اس مثال کے طور پر ، ایک لنکڈ لسٹ آبجیکٹ تیار کیا جاتا ہے اور اس فہرست میں چار نوڈس کو شامل کرنے کے لئے استعمال کیا جاتا ہے ، فہرست کے آغاز میں ایک نیا نوڈ داخل کریں ،اور فہرست سے ویلیو 2 کے ساتھ نوڈ کو حذف کریں۔آخر میں ، پرنٹ کا طریقہ فہرست میں تمام نوڈس کی اقدار کو پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں تجرید کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "خلاصہ آبجیکٹ پر مبنی پروگرامنگ کا ایک تصور ہے جو کسی شے کی ضروری خصوصیات کو عمل درآمد کی تفصیلات 123456 ظاہر کیے بغیر نمائندگی کرنے کی اجازت دیتا ہے۔خلاصہ کسی شے کی غیر ضروری تفصیلات کو چھپا کر اور صارف 123456 سے متعلقہ معلومات کو بے نقاب کرکے پیچیدگی کو کم کرنے اور ماڈیولریٹی کو بڑھانے میں مدد کرتا ہے۔ازگر میں ، تجریدی کلاسوں اور انٹرفیسس 123456 کا استعمال کرتے ہوئے خلاصہ حاصل کیا جاسکتا ہے۔ یہاں ایک تجریدی کلاس کا استعمال کرتے ہوئے ازگر میں خلاصہ کی ایک مثال ہے: ازگر سے اے بی سی امپورٹ اے بی سی ، خلاصہ میتھڈ کلاس جانوروں (اے بی سی): @اے بی ایس ٹی ایم ای ٹی ڈیف اسپیک (خود): پاس کلاس ڈاگ (جانور): ڈیف اسپیک (خود): پرنٹ (\"ڈاگ بارکس\") کلاس بلی (جانور): ڈیف اسپیک (خود): پرنٹ (\"بلی میئو\") کتا = کتا () بلی = بلی () کتے۔ اسپیک () # پرنٹس\"ڈاگ بارکس\" بلی۔ اسپیک () # پرنٹس \"بلی میئوز\" اس مثال میں ، جانوروں کی کلاس ایک تجریدی کلاس ہے جو ایک تجریدی طریقہ بولنے کی وضاحت کرتی ہے۔کتے اور بلی کی کلاسیں جانوروں کی کلاس سے وارث ہوتی ہیں اور کتوں اور بلیوں کے لئے بالترتیب ایک مخصوص پیغام پرنٹ کرنے کے لئے بولنے کے طریقہ کار کو نافذ کرتی ہیں۔کتے اور بلی کی اشیاء بالترتیب کتے اور بلی کی کلاسوں کا استعمال کرتے ہوئے تخلیق کی جاتی ہیں ، اور ان کے بولنے کے طریقوں کو اپنے متعلقہ پیغامات پرنٹ کرنے کے لئے کہا جاتا ہے۔نوٹ کریں کہ جانوروں کی کلاس کو براہ راست فوری نہیں کیا جاسکتا کیونکہ یہ ایک تجریدی کلاس ہے ، اور اس کا خلاصہ طریقہ اس کی اخذ کردہ کلاسوں کے ذریعہ نافذ کیا جانا چاہئے۔"
    },
    {
        "Question": "ازگر میں خلاصہ کلاس اور انٹرفیس کیا ہیں؟وہ کیسے مختلف ہیں؟",
        "Answer": "خلاصہ کلاس اور انٹرفیس ازگر میں وہ ادارے ہیں جو آبجیکٹ پر مبنی پروگرامنگ میں خلاصہ حاصل کرنے کے لئے استعمال ہوتے ہیں۔ازگر میں تجریدی کلاسوں اور انٹرفیس کے مابین اختلافات یہ ہیں: خلاصہ کلاس: ایک خلاصہ کلاس ایک ایسی کلاس ہے جس میں ایک یا زیادہ خلاصہ طریقے شامل ہیں ۔123456. ایک تجریدی طریقہ ایک ایسا طریقہ ہے جس کا اعلان کیا جاتا ہے لیکن اس میں کوئی عمل درآمد نہیں کیا جاسکتا ہے۔ان کے تجریدی طریقوں کو ان کے ذیلی طبقے کے ذریعہ نافذ کیا جانا چاہئے۔خلاصہ ہیں اور ان پر عمل درآمد نہیں ہے ۔13456۔ انٹرفیس میں مثال کے طور پر متغیرات یا کنکریٹ کے طریقے نہیں ہوتے ہیں ۔13456۔ انٹرفیس کو براہ راست ازگر میں براہ راست نافذ نہیں کیا جاتا ہے ، لیکن خلاصہ کلاسوں یا غیر رسمی انٹرفیس 13456 کا استعمال کرتے ہوئے نقالی کیا جاسکتا ہے۔اے بی سی امپورٹ اے بی سی ، خلاصہ میتھڈکلاس اینیمل (اے بی سی): @اے بی ایس ٹی آر ایم ٹی ڈی ڈیف اسپیک (خود).ایک تجریدی طریقہ بولنے کی وضاحت کرتا ہے۔کتے اور بلی کی کلاسیں جانوروں کی کلاس سے وارث ہوتی ہیں اور کتوں اور بلیوں کے لئے بالترتیب ایک مخصوص پیغام پرنٹ کرنے کے لئے بولنے کے طریقہ کار کو نافذ کرتی ہیں۔کتے اور بلی کی اشیاء بالترتیب کتے اور بلی کی کلاسوں کا استعمال کرتے ہوئے تخلیق کی جاتی ہیں ، اور ان کے بولنے کے طریقوں کو اپنے متعلقہ پیغامات پرنٹ کرنے کے لئے کہا جاتا ہے۔نوٹ کریں کہ جانوروں کی کلاس کو براہ راست فوری نہیں بنایا جاسکتا کیونکہ یہ ایک تجریدی کلاس ہے ، اور اس کا خلاصہ طریقہ اس کی اخذ کردہ کلاسوں کے ذریعہ نافذ کیا جانا چاہئے۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی ہوتی ہے جس میں انکیو ، ڈی کیوئو ، اور سائز کے طریقوں سے ہوتا ہے۔\"",
        "Answer": "ایک قطار ایک اعداد و شمار کا ڈھانچہ ہے جو پہلے میں پہلے آؤٹ (FIFO) اصول کی پیروی کرتا ہے۔ازگر میں ، فہرست یا قطار ماڈیول 1234 کا استعمال کرتے ہوئے ایک قطار نافذ کی جاسکتی ہے۔یہاں ایک ازگر کلاس کا نفاذ ہے جس میں ایک فہرست کا استعمال کرتے ہوئے انکیو ، ڈی کیوئو ، اور سائز کے طریقوں کے ساتھ قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کی گئی ہے: ازگرکلاس قطار: ڈیف __init __ (خود): سیلف ڈاٹ آئٹمز = [] ڈیف انکیو (خود ، آئٹم): خود۔items.append (آئٹم) Def dequeue (self): اگر خود نہیں۔ is_empty (): واپس کریں۔ آئٹمز.پوپ (0) اور: انڈیکس ایرر (\"خالی قطار سے ڈی کیوئ نہیں کر سکتے ہیں۔\") ڈیف آئی ایس_پٹی (خود):ریٹرن لین (self.items) == 0 DEF سائز (خود): ریٹرن لین (self.items) اس نفاذ میں ، قطار کلاس میں ایک آئٹمز وصف ہوتا ہے جو قطار میں موجود اشیاء کی فہرست کی نمائندگی کرتا ہے۔کلاس کے پاس ایک انکیو طریقہ بھی ہے جو قطار کے اختتام پر کسی شے کو شامل کرتا ہے ، ایک ایسا طریقہ جو قطار کے اگلے حصے میں آئٹم کو ہٹاتا ہے اور لوٹاتا ہے ، ایک آئی ایس پیٹی طریقہ ہے جو قطار خالی ہے ، اور ایک سائز کا طریقہ یہ ہےقطار میں آئٹمز کی تعداد لوٹاتا ہے۔ یہاں قطار کلاس کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیٹونق = قطار () Q.enqueue (1) Q.enqueue (2) Q.enqueue (3) پرنٹ (Q.SIZE (Q.SIZE (Q.Size ()) # پرنٹ 3 پرنٹ (Q.dequeue ()) # پرنٹ 1 پرنٹ (Q.dequeue ()) # پرنٹس 2 پرنٹ (Q.IS_EMPTY ()) # پرنٹس فالس پرنٹ (Q.dequeue ()) # پرنٹ 3 پرنٹ (Q.is_empty (Q.is_empty ()) # پرنٹس اس مثال کے طور پر ، ایک قطار آبجیکٹ تیار کی جاتی ہے اور تین اشیاء کو قطار میں ڈالنے کے لئے استعمال ہوتی ہے۔اس کے بعد سائز کا طریقہ استعمال کیا جاتا ہے تاکہ قطار میں اشیاء کی تعداد پرنٹ کیا جاسکے ، جو 3 ہے۔اس کے بعد آئی ایس_پٹی کا طریقہ یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا قطار خالی ہے یا نہیں ، جو غلط لوٹتی ہے۔اس کے بعد ڈیکوئو کا طریقہ قطار میں آخری آئٹم کو ہٹانے اور پرنٹ کرنے کے لئے استعمال کیا جاتا ہے ، جو 3 ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں مرکب کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "مرکب آبجیکٹ پر مبنی پروگرامنگ میں ایک تصور ہے جس میں ایسی اشیاء تیار کرنا شامل ہیں جن میں دوسری اشیاء پر مشتمل ہوتا ہے جیسے کہ متغیر 1234۔مشترکہ مقصد کے حصول کے لئے اشیاء مل کر کام کرتی ہیں ، اور بڑی شے ایک یا زیادہ چھوٹی اشیاء 1234 پر مشتمل ہوسکتی ہے۔مرکب کے پیچھے بنیادی خیال یہ ہے کہ ایک پیچیدہ مسئلے کو چھوٹے ، زیادہ قابل انتظام ٹکڑوں 1234 میں توڑنا ہے۔ڈویلپر چھوٹی چھوٹی اشیاء تیار کرکے زیادہ لچکدار اور برقرار رکھنے والے کوڈ تشکیل دے سکتے ہیں جو بڑی اشیاء کی تشکیل کے ل. مل سکتے ہیں۔ یہاں ایک مثال ہے کہ ہم کس طرح ازگر میں کار کلاس بنانے کے لئے تشکیل کا استعمال کرسکتے ہیں: ازگر کلاس انجن: ڈیف اسٹارٹ (خود): پرنٹ (پرنٹ (پرنٹ (پرنٹ (خود)\"انجن شروع ہوا\") کلاس ٹرانسمیشن: ڈیف شفٹ (خود): پرنٹ (\"ٹرانسمیشن شفٹ\") کلاس پہیے: ڈیف روٹیٹ (خود): پرنٹ (\"پہیے سے گھوما\") کلاس کار: ڈیف __ __init __ (خود): سیلف۔ انجین =انجن () سیلف ٹرانسمیشن = ٹرانسمیشن () سیلف۔ وہیلز = [پہیے () کے لئے I (4)] ڈیف اسٹارٹ (سیلف): سیلف.ینگائن۔ اسٹارٹ () ڈیف شفٹ (خود)() ڈیف ڈرائیو (خود): خود میں پہیے کے لئے۔ پہیے: پہیے۔() # پرنٹس \"پہیے نے گھوما\" اس مثال کے طور پر ، انجن ، ٹرانسمیشن ، اور پہیے کی کلاسیں کار کے اجزاء کی نمائندگی کرتی ہیں۔کار کلاس میں ان کلاسوں کی مثال کے طور پر مثال کے طور پر متغیرات ہوتے ہیں ، اور اس کے طریقے مطلوبہ طرز عمل کو حاصل کرنے کے لئے ان مثالوں کے طریقوں کا استعمال کرتے ہیں۔کار کلاس کا آغاز طریقہ انجن مثال کے آغاز کے طریقہ کار کو کہتے ہیں ، کار کلاس کا شفٹ طریقہ ٹرانسمیشن مثال کے شفٹ طریقہ کو کال کرتا ہے ، اور کار کلاس کا ڈرائیو کا طریقہ ہر پہیے کی مثال کے گھومنے والے طریقہ کو کال کرتا ہے۔اس طرح ، کار کلاس چھوٹی چھوٹی اشیاء پر مشتمل ہے جو کار کے طرز عمل کو حاصل کرنے کے لئے مل کر کام کرتی ہے۔"
    },
    {
        "Question": "ازگر کی کلاس میں ابتدائی طریقہ کا مقصد کیا ہے؟یہ دوسرے طریقوں سے کیسے مختلف ہے؟",
        "Answer": "__init__ طریقہ ازگر کی کلاسوں میں ایک خاص طریقہ ہے جو کسی شے کی صفات کو شروع کرنے کے لئے استعمال ہوتا ہے جیسے ہی شے کو تشکیل دیا جاتا ہے 123456۔__init__ کے طریقہ کار کو کنسٹرکٹر کہا جاتا ہے کیونکہ یہ آبجیکٹ کی تعمیر کرتا ہے اور اس کی صفات 123456 شروع کرتا ہے۔__init__ طریقہ کو ہمیشہ کہا جاتا ہے جب کسی کلاس کا کوئی شے تشکیل دیا جاتا ہے ، اور یہ خود پیرامیٹر کو اپنی پہلی دلیل کے طور پر لیتا ہے ، جس سے مراد اس چیز سے ہوتا ہے جس میں خود 123456 ہوتا ہے۔سیلف پیرامیٹر کو کلاس 123456 کے اندر موجود خصوصیات اور طریقوں تک رسائی کے لئے استعمال کیا جاتا ہے۔ __ __init__ طریقہ ایک ازگر کلاس میں دوسرے طریقوں سے مختلف ہے کیونکہ جب کلاس کا کوئی شے پیدا ہوتا ہے تو اسے خود بخود کہا جاتا ہے ، جبکہ دوسرے طریقوں کو واضح طور پر 123456 کہا جانا چاہئے۔__init__ کا طریقہ کسی شے کی صفات کو شروع کرنے کے لئے استعمال کیا جاتا ہے ، جبکہ دوسرے طریقوں کو آبجیکٹ 123456 پر مخصوص اعمال انجام دینے کے لئے استعمال کیا جاتا ہے۔ یہاں __init__ طریقہ کے ساتھ ایک ازگر کلاس کی ایک مثال ہے: پائیٹونکلاس شخص: Def __init __ (خود ، نام ، عمر): self.name = name self.age = Age Def say_hello (خود): پرنٹ (f \"ہیلو ، میرا نام {سیلف ڈاٹ نام} ہے اور میں {سیلف.ایج} سال کی عمر میں ہوں۔\") شخص = شخص (\"جان \"، 30) شخص ۔سے_ہیلو () # پرنٹس\" ہیلو ، میرا نام جان ہے اور میں 30 سال کا ہوں۔ \"اس مثال میں ، اس شخص کی کلاس کے پاس ایک __init__ طریقہ ہے جو کسی شخص کے نام اور عمر کی خصوصیات کو شروع کرتا ہے۔شخص کلاس کا say_hello طریقہ ایک مبارکباد کے پیغام کو پرنٹ کرنے کے لئے نام اور عمر کے اوصاف کا استعمال کرتا ہے۔شخص کی کلاس کا ایک مقصد \"جان\" اور 30 سال کی عمر کے ساتھ تخلیق کیا گیا ہے ، اور اس کے sayllo طریقہ کو ایک مبارکبادی پیغام پرنٹ کرنے کے لئے کہا جاتا ہے۔"
    },
    {
        "Question": "\"گراف ڈیٹا ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور عمودی ، کناروں کو شامل کرنے اور گراف ٹریورسل کو انجام دینے کے طریقے فراہم کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو گراف ڈیٹا ڈھانچے کی نمائندگی کرتا ہے جس میں عمودی ، کناروں کو شامل کرنے کے طریقوں کے ساتھ ، گراف ٹریورسل شامل کرنے کے طریقوں کے ساتھ: پائیٹونکلاس گراف: ڈیف __init __ (خود): سیلف ڈاٹ گراف = {} ڈیف ایڈ_ورٹیکس (خود ، ورٹیکس): اگر: اگرورٹیکس سیلف گراف میں نہیں۔ورٹیکس 1] = [ورٹیکس 2] ڈیف ڈی ایف ایس (خود ، اسٹارٹ): ملاحظہ کریں = سیٹ () اسٹیک = [اسٹیک] جبکہ اسٹیک: ورٹیکس = اسٹیک.پپ () اگر ورٹیکس میں نہیں ملاحظہ کیا گیا: ملاحظہ کیا گیا۔sell.graph [vertex] - ملاحظہ کریں) واپسی کا دورہ Def Bfs (خود ، start): ملاحظہ کریں = سیٹ () قطار = [شروع]ورٹیکس) قطار۔کلاس کے پاس ایک ADD_VERTEX کا طریقہ بھی ہے جو گراف میں ایک چوٹی کا اضافہ کرتا ہے ، ایک ADD_EDGE کا طریقہ جو دو عمودیوں کے درمیان ایک کنارے کا اضافہ کرتا ہے ، ایک DFS طریقہ جو گراف کی گہرائی سے پہلے تلاش کی طرف جاتا ہے ، اور BFS کا طریقہ جو ایک چوڑائی انجام دیتا ہے-گراف کی پہلی تلاش ٹراورسل۔ یہاں گراف کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونگ = گراف () g.add_vertex ('a') g.add_vertex ('b') g.add_vertex ('c') g.add_vertex ('d') g.add_edge ('a' ، 'b') g.add_edge ('b' ، 'c') g.add_edge ('c' ، 'd') پرنٹ (g.dfs ('a')) # پرنٹس {' A '،' B '،' C '،' D '} پرنٹ (g.bfs (' a ')) # پرنٹس {' a '،' b '،' c '،' d'} اس مثال میں ، ایک گراف آبجیکٹ تیار کیا جاتا ہے اور گراف میں چار عمودی اور ان کے درمیان تین کناروں کو شامل کرنے کے لئے استعمال کیا جاتا ہے۔اس کے بعد گراف کلاس کے ڈی ایف ایس کا طریقہ کار ورٹیکس 'اے' سے شروع ہونے والے گراف کی گہرائی سے پہلے تلاش کرنے کے لئے استعمال کیا جاتا ہے ، جو ملاحظہ شدہ عمودی {'A' ، 'B' ، 'C' ، 'D کا سیٹ لوٹاتا ہے۔'}.اس کے بعد گراف کلاس کا بی ایف ایس طریقہ استعمال کیا جاتا ہے تاکہ ورٹیکس 'اے' سے شروع ہونے والے گراف کی چوڑائی کی پہلی تلاش کے ٹریورسل کو انجام دیا جاسکے ، جو ملاحظہ شدہ عمودی {'A' ، 'B' ، 'C' ، 'D کا سیٹ لوٹتا ہے۔'} .1tutorialsPoint2plainglish3youtube4bogotobogo5python"
    },
    {
        "Question": "وراثت کے درجہ بندی کے تصور اور آبجیکٹ پر مبنی پروگرامنگ میں اس کے فوائد کی وضاحت کریں۔",
        "Answer": "وراثت کا درجہ بندی آبجیکٹ پر مبنی پروگرامنگ میں ایک تصور ہے جس میں کلاسوں کا ایک کنبہ بنانا شامل ہوتا ہے جہاں ہر طبقے کو اپنے والدین کی کلاس 123456 سے صفات اور طریقے وراثت میں ملتے ہیں۔والدین کی کلاس کو بیس کلاس یا سپر کلاس کے نام سے بھی جانا جاتا ہے ، جبکہ چائلڈ کلاس ماخوذ کلاس یا سبکلاس 123456 کے نام سے جانا جاتا ہے۔چائلڈ کلاس اپنے والدین کی کلاس سے ڈیٹا اور طریقوں کا وارث ہوسکتی ہے اور کلاس ہائیرارچی 123456 میں اپنے ڈیٹا اور طریقے بھی شامل کرسکتی ہے۔وراثت کا درجہ بندی کوڈ کو دوبارہ استعمال کرنے کی اجازت دیتا ہے ، کوڈ کی نقل کو کم کرتا ہے ، اور کوڈ کو زیادہ ماڈیولر اور برقرار رکھنے والا 123456 بناتا ہے۔ یہاں آبجیکٹ پر مبنی پروگرامنگ میں وراثت کے درجہ بندی کے کچھ فوائد ہیں: کوڈ دوبارہ استعمال: وراثت میں موجودہ کلاسوں سے کوڈ کو دوبارہ استعمال کرنے کی اجازت ملتی ہے ، جس سے وقت کی بچت ہوتی ہے ، جس سے وقت کی بچت ہوتی ہے۔اور کوشش 123456. کوڈ کوڈ کی نقل: وراثت ڈویلپرز کو متعدد کلاسوں میں نقل کرنے والے کوڈ سے بچنے کی اجازت دیتی ہے ، جس سے کوڈ کی مقدار کو کم کیا جاتا ہے جس کو لکھنے اور برقرار رکھنے کی ضرورت ہوتی ہے۔جو کوڈ کو زیادہ ماڈیولر اور برقرار رکھنے میں آسان بناتا ہے۔ازگر میں وراثت کا درجہ بندی: ازگرکلاس جانور: ڈیف __ __init __ (خود ، نام): سیلف۔ نام = نام ڈیف اسپیک (خود): پرنٹ (\"جانور بولتا ہے\") کلاس کتا (جانور): ڈیف __ __init __ (خود ، نام ، نسل):سپر ()self.color = رنگین Def speak (خود): پرنٹ (\"بلی میوز\") کتا = کتا (\"فیڈو\" ، \"لیبراڈور\") بلی = بلی (\"سرگوشیاں\" ، \"گرے\") پرنٹ (ڈاگ نام) # پرنٹس\"فیڈو\" پرنٹ (ڈاگ بریڈ) # پرنٹس \"لیبراڈور\" ڈاگ۔ اسپیک () # پرنٹس \"ڈاگ بارکس\" پرنٹ (بلی۔ نام) # پرنٹس \"سرگوشیاں\" پرنٹ (بلی.کلور) # پرنٹس \"گرے\" بلی۔ اسپیک() # پرنٹس \"بلی میوز\" اس مثال میں ، جانوروں کی کلاس والدین کی کلاس ہے ، اور کتا اور بلی کی کلاسیں بچوں کی کلاس ہیں جو جانوروں کی کلاس سے وارث ہوتی ہیں۔کتے کی کلاس ایک نسل کا وصف شامل کرتی ہے اور کتوں کے لئے ایک مخصوص پیغام پرنٹ کرنے کے لئے جانوروں کی کلاس کے بولنے کے طریقہ کار کو اوور رائڈ کرتی ہے۔بلی کی کلاس رنگین وصف کا اضافہ کرتی ہے اور بلیوں کے لئے ایک مخصوص پیغام پرنٹ کرنے کے لئے جانوروں کی کلاس کے بولنے کے طریقہ کار کو اوور رائڈ کرتی ہے۔دو اشیاء ، ڈاگ اور بلی ، بالترتیب کتے اور بلی کی کلاسوں کا استعمال کرتے ہوئے تخلیق کی گئیں ، اور ان کی صفات اور طریقوں تک وراثت کے درجہ بندی کا مظاہرہ کرنے کے لئے رسائی حاصل کی جاتی ہے۔"
    },
    {
        "Question": "\"ازگر (عوامی ، نجی ، محفوظ) میں طریقہ کار کی نمائش کے تصور کی وضاحت کریں اور ایک مثال پیش کریں۔\"",
        "Answer": "ازگر میں ، کلاس 123 کے طریقوں اور صفات کے لئے مرئیت کی کوئی سخت پابندیاں نہیں ہیں۔تاہم ، ایسے کنونشنز ہیں جو کسی طریقہ یا وصف 1423 کی مطلوبہ مرئیت کی نشاندہی کرنے کے لئے استعمال ہوسکتے ہیں۔ازگر میں طریقہ کار کی نمائش کے لئے یہاں کنونشنز ہیں: عوامی طریقے: عوامی طریقے ایسے طریقے ہیں جن تک کہیں بھی ، کلاس 123 کے اندر اور باہر کہیں سے بھی رسائی حاصل کی جاسکتی ہے۔کنونشن کے ذریعہ ، عوامی طریقوں کو کسی بھی انڈر سکورز 123 کے ساتھ پیش نہیں کیا جاتا ہے۔ محفوظ طریقے: محفوظ طریقے ایسے طریقے ہیں جن تک کلاس اور اس کے ذیلی طبقے 423 کے اندر سے رسائی حاصل کی جاسکتی ہے۔کنونشن کے ذریعہ ، محفوظ طریقوں کو ایک واحد انڈر سکور 423 کے ساتھ پیش کیا جاتا ہے۔کنونشن کے ذریعہ ، نجی طریقوں کو ڈبل انڈر سکور 5423 کے ساتھ پیش کیا جاتا ہے۔ یہ نوٹ کرنا ضروری ہے کہ ان کنونشنوں کو ازگر کے ترجمان کے ذریعہ نافذ نہیں کیا جاتا ہے ، اور اگر صارف اپنے نام 123 کو جانتا ہے تو کلاس کے باہر سے کسی بھی طریقہ یا وصف تک رسائی حاصل کی جاسکتی ہے۔تاہم ، ان کنونشنوں کی پیروی کوڈ کو مزید پڑھنے کے قابل اور برقرار رکھنے میں مدد مل سکتی ہے۔ یہاں ازگر میں طریقہ کار کی نمائش کی ایک مثال ہے: ازگرکلاس مائکلاس: ڈیف پبلک_میتھوڈ (خود): پرنٹ (\"یہ عوامی طریقہ ہے\") ڈیف _ پروٹیکٹڈ_میتھوڈ (خود): پرنٹ (\"یہ ایک محفوظ طریقہ ہے\") Def __private_method (خود): پرنٹ (\"یہ ایک نجی طریقہ ہے\") OBJ = MyClass () obj.public_method () # پرنٹس \"یہ ایک عوامی طریقہ ہے\" OBJ.PROTECT_METHOD () # پرنٹس \"یہ ایک محفوظ طریقہ ہے\" OBJ .__ پرائیویٹ_میتھوڈ () # ایک انتسابیررن کو اٹھاتا ہے ، اس مثال کے طور پر ، مائکلاس کلاس میں عوامی طریقہ پبلک_میتھوڈ ، ایک محفوظ طریقہ _ پروٹیکٹڈ_میتھوڈ ، اور ایک نجی طریقہ __PRIVATE_METHOD ہے۔مائکلاس کلاس کا ایک شے تیار کیا جاتا ہے ، اور اس کے طریقوں تک ان کی مرئیت کا مظاہرہ کرنے کے لئے رسائی حاصل کی جاتی ہے۔پبلک_میتھوڈ اور _ پروٹیکٹڈ_میتھوڈ طریقوں کو کلاس سے باہر سے حاصل کیا جاسکتا ہے ، لیکن __private_method طریقہ ایک انتساب دہندہ کو اٹھاتا ہے کیونکہ یہ ایک نجی طریقہ ہے۔"
    },
    {
        "Question": "\"کلیدی قدر کی جوڑی داخل کرنے ، بازیافت اور ہٹانے کے طریقوں کے ساتھ ہیش ٹیبل (لغت) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو ہیش ٹیبل (لغت) کی نمائندگی کرتا ہے جس میں کلیدی قدر کی جوڑی داخل کرنے ، بازیافت ، اور ہٹانے کے طریقوں کے ساتھ: پائیٹونکلاس ہیش ٹیبل: ڈیف __init __ (خود): خود۔رینج میں _ کے لئے (خود۔۔): ہیش_ویلیو = سیلف۔_hash_function (کلیدی) بالٹی = سیلف. ٹیبل [ہیش_والیو] I ، (k ، v) کے لئے ، (بالٹی) میں (بالٹی): اگر k == key: ڈیل بالٹی [i] اس عمل درآمد میں کلیدی ایرر (کلیدی) کی واپسی ، ہیش ٹیبل کلاسایک سائز کا وصف ہے جو ہیش ٹیبل کے سائز اور ایک ٹیبل وصف کی نمائندگی کرتا ہے جو بالٹیوں کی فہرست کے طور پر ہیش ٹیبل کی نمائندگی کرتا ہے۔کلاس میں ایک _hash_function کا طریقہ بھی ہوتا ہے جو ایک کلید لیتا ہے اور ہیش ویلیو لوٹاتا ہے ، ایک داخل کرنے کا طریقہ جو ہیش ٹیبل میں کلیدی قدر کی جوڑی داخل کرتا ہے ، ایک ایسا طریقہ ہے جو ہیش ٹیبل سے کسی کلید سے وابستہ قدر کو بازیافت کرتا ہے ، اور ایکہیش ٹیبل سے کلیدی قدر کی جوڑی کو ہٹانے کا طریقہ ہٹا دیں۔ یہاں ہیش ٹیبل کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹون ایچ ٹی = ہیش ٹیبل () ht.insert ('ایپل' ، 1) ht.insert ('کیلے' ، 2) ht.insert ('چیری' ، 3) پرنٹ (ht.get ('ایپل')) # پرنٹس 1ht.remove ('کیلے') پرنٹ (ht.get ('کیلے')) # اس مثال کو اٹھاتا ہے ،ہیش ٹیبل آبجیکٹ بنائی جاتی ہے اور ہیش ٹیبل میں تین کلیدی قیمت کے جوڑے ڈالنے کے لئے استعمال ہوتی ہے۔اس کے بعد ہیش ٹیبل کلاس کا GET طریقہ استعمال کیا جاتا ہے اس کے بعد کلیدی 'ایپل' سے وابستہ قدر کو بازیافت کرنے کے لئے استعمال کیا جاتا ہے ، جو 1 ہے۔ اس کے بعد ہیش ٹیبل کلاس کا ہٹانے کا طریقہ کلیدی قدر کی جوڑی کو کلیدی 'کیلے' کے ساتھ ہٹانے کے لئے استعمال کیا جاتا ہے۔آخر میں ، ہیش ٹیبل کلاس کا GET طریقہ کلیدی 'کیلے' سے وابستہ قدر کو بازیافت کرنے کے لئے استعمال کیا جاتا ہے ، جو ایک کلیرر اٹھاتا ہے کیونکہ کلید اب ہیش ٹیبل میں نہیں ہے۔"
    },
    {
        "Question": "ازگر میں جامد طریقے اور مثال کے طریقے کیا ہیں؟وہ کیسے مختلف ہیں؟",
        "Answer": "ازگر میں ، طریقوں کی تین اقسام ہیں: مثال کے طریقے ، کلاس کے طریقے ، اور جامد طریقے 123456۔یہاں ہر قسم کی ایک مختصر وضاحت ہے: مثال کے طریقے: مثال کے طریقے ازگر میں سب سے عام قسم کا طریقہ ہے۔ان کی تعریف ایک کلاس کے اندر کی جاتی ہے اور کلاس کی ایک مثال کی ضرورت ہوتی ہے جس کو 123456 کہا جاتا ہے۔مثال کے طریقے خود پیرامیٹر کو اپنی پہلی دلیل کے طور پر لیتے ہیں ، جس سے مراد اس کلاس کی مثال ہے جس کو طریقہ 123456 کہتے ہیں۔مثال کے طریقے مثال کے اوصاف اور کلاس 123456 تک رسائی اور اس میں ترمیم کرسکتے ہیں۔ کلاس کے طریقے: کلاس کے طریقے ایسے طریقے ہیں جو کلاس کے پابند ہیں نہ کہ کلاس 123456 کی مثال۔ان کی وضاحت @کلاسیمیتھوڈ ڈیکوریٹر کا استعمال کرتے ہوئے کی گئی ہے اور سی ایل ایس پیرامیٹر کو اپنی پہلی دلیل کے طور پر لیں ، جو خود کلاس 123456 کلاس سے مراد ہے۔طبقاتی طریقے کلاس کی صفات تک رسائی اور اس میں ترمیم کرسکتے ہیں ، لیکن مثال کے طور پر مثال کے طور پر 123456۔ اسٹیٹک طریقے: جامد طریقے ایسے طریقے ہیں جو کلاس کے پابند ہیں نہ کہ کلاس 123456 کی مثال۔ان کی وضاحت @اسٹیٹمیٹوڈ ڈیکوریٹر کا استعمال کرتے ہوئے کی گئی ہے اور کوئی خاص پیرامیٹرز 123456 نہیں لیتے ہیں۔جامد طریقے نہ تو کلاس کی صفات یا مثال کے طور پر 123456 تک رسائی حاصل کرسکتے ہیں اور نہ ہی اس میں ترمیم کرسکتے ہیں۔ان کا استعمال افادیت کے افعال کی وضاحت کے لئے کیا جاتا ہے جو طبقے کی حالت یا مثال کے طور پر 123456 پر انحصار نہیں کرتے ہیں۔ یہاں ازگر میں ہر قسم کے طریقہ کار کی ایک مثال ہے: پائیتھنکلاس مائکلاس: class_variable = 0 def __init __ (خود ، مثال کے طور پر): خود. instance_variaber)= مثال کے طور پر_ااریبل ڈیف مثال کے طور پر_میتھوڈ (خود): پرنٹ (ایف \"یہ ایک مثال کا طریقہ ہے۔ مثال کے طور پر متغیر {سیلف.ایسنسٹنس_واریئبل}.متغیر {cls.class_variable}. \") @اسٹیٹیمیٹوڈ ڈیف جامد_میتھوڈ (): پرنٹ (\" یہ ایک مستحکم طریقہ ہے۔ \"متغیر 1 ہے۔مثال کے طور پر متغیر مثال کے طور پر ، ایک کلاس متغیر کلاس_ااریبل ، ایک مثال کے طریقہ کار مثال کے طور پر_میتھوڈ ، ایک کلاس طریقہ کلاس_میتھوڈ ، اور ایک جامد طریقہ جامد_میتھوڈ۔مائکلاس کلاس کا ایک شے تیار کیا گیا ہے ، اور اس کے مثال کے طریقہ کار کو مثال کے طریقوں کو ظاہر کرنے کے لئے کہا جاتا ہے۔مائکلاس کلاس کے کلاس کے طریقہ کار اور جامد طریقہ کو بالترتیب کلاس طریقوں اور جامد طریقوں کا مظاہرہ کرنے کے لئے کہا جاتا ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں پولیمورفک ایسوسی ایشن کے تصور کی وضاحت کریں اور ایک مثال پیش کریں۔",
        "Answer": "پولیمورفک ایسوسی ایشن آبجیکٹ پر مبنی پروگرامنگ میں ایک تصور ہے جو ایک ہی طبقے کو ایک سے زیادہ کلاسز 12 سے تعلق رکھنے کی اجازت دیتا ہے۔جاوا جیسی مستحکم ٹائپ شدہ زبانوں میں ، یہ متعدد کلاسیں ایک ہی سپر کلاس 1 کے ذیلی طبقات ہیں۔متحرک طور پر ٹائپ شدہ زبانوں جیسے روبی میں ، یہ ضروری نہیں کہ کیس 13 ہو۔پولیمورفک ایسوسی ایشن اکثر آبجیکٹ سے متعلقہ نقشہ سازی میں ایک طبقے سے ایک سے زیادہ طبقوں کے تعلقات کی نمائندگی کرنے کے لئے استعمال کیا جاتا ہے۔کمپیوٹر سائنس میں ، یہ اس تصور کو بیان کرتا ہے کہ آپ ایک ہی انٹرفیس 5 کے ذریعے مختلف اقسام کے اشیاء تک رسائی حاصل کرسکتے ہیں۔ہر قسم اس انٹرفیس 5 پر اپنا آزادانہ نفاذ فراہم کرسکتا ہے۔پولیمورفزم اعلی سطح کے دوبارہ استعمال کے ل necessary ضروری ہے جو ڈیزائن کے نمونوں اور فریم ورک 6 کا مقصد ہے۔آبجیکٹ پر مبنی پروگرامنگ میں پولیمورفزم کے متعدد ذائقے موجود ہیں ، اور ان سب کو تقاضا ہے کہ متغیرات پولیمورفک 6 ہوسکتے ہیں۔ یہاں ازگر میں پولیمورفک ایسوسی ایشن کی ایک مثال ہے: ازگرکلاس تبصرہ: ڈیف __ (خود ، جسم): Def __init __ (خود ، عنوان ، باڈی): سیلف۔ ٹائٹل = عنوان خود۔ باڈی = باڈی سیلف ڈاٹ کام = [] ڈیف ایڈ_کممنٹ (خود ، تبصرہ): سیلف ڈاٹ کام۔ اپینڈ (تبصرہ) کلاس ویڈیو: ڈیف __init __ (خود، عنوان ، یو آر ایل): سیلف۔ ٹائٹل = عنوان سیلف۔ url = url self.comments = [] def add_comment (خود ، تبصرہ): سیلف ڈاٹ کام۔ اپینڈ (تبصرہ) تبصرہ 1 = تبصرہ (\"عظیم پوسٹ!\") تبصرہ 2 =تبصرہ (\"اچھا ویڈیو!\") پوسٹ = پوسٹ (\"ہیلو ، ورلڈ!\" ، \"یہ میری پہلی پوسٹ ہے۔\") ویڈیو = ویڈیو (\"ازگر کا تعارف\" ، \"https://www.youtube.com/watch؟ v = rfscvs0vtbw \") post.add_comment (تبصرہ 1) ویڈیو.ایڈ_ کاممنٹ (تبصرہ 2) پرنٹ (پوسٹ ڈاٹ کام [0] .body) # پرنٹ\" زبردست پوسٹ! \"پرنٹ (ویڈیو ڈاٹ کام [0] .body) # پرنٹس\"اچھی ویڈیو! \"اس مثال میں ، تبصرہ کلاس ایک تبصرہ کی نمائندگی کرتا ہے ، پوسٹ کلاس ایک پوسٹ کی نمائندگی کرتی ہے ، اور ویڈیو کلاس ایک ویڈیو کی نمائندگی کرتا ہے۔پوسٹ اور ویڈیو کلاس دونوں کے پاس ایک تبصرے کا وصف ہے جو تبصروں کی فہرست ہے۔پوسٹ اور ویڈیو کلاسوں میں بھی دونوں کے پاس ایک ADD_COMMENT کا طریقہ ہے جو تبصرے کی فہرست میں ایک تبصرہ شامل کرتا ہے۔دو تبصرے کی اشیاء ، تبصرہ 1 اور تبصرہ 2 ، تشکیل دیئے گئے ہیں ، اور وہ بالترتیب پوسٹ اور ویڈیو آبجیکٹ کی تبصرے کی فہرست میں شامل کردیئے گئے ہیں۔پوسٹ اور ویڈیو آبجیکٹ کی تبصرے کی فہرست میں پہلے تبصرے کی باڈی وصف کو پھر پولیمورفک ایسوسی ایشن کا مظاہرہ کرنے کے لئے پرنٹ کیا جاتا ہے۔"
    },
    {
        "Question": "\"میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوزیشن کے طریقوں کے ساتھ میٹرکس کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یہاں ایک ازگر کلاس کا نفاذ ہے جو میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوزیشن کے طریقوں کے ساتھ میٹرکس کی نمائندگی کرتا ہے: پائیتھنکلاس میٹرکس: ڈیف __init __ (خود ، قطاریں ، کولس): سیلف.روز = قطاریں خود = کالز سیلز۔ ڈاٹا = [[[[0 رینج (COLs) کے لئے] I میں رینج (قطار) کے لئے] Def __RER __ (خود): واپسی '\\ n'.join ([' '. join ([str.data [i] [j]) J میں رینج (سیلف کولز)]) میں رینج (سیلف.روز)] کے لئے ڈیف __add __ (خود ، دوسرا): اگر سیلف ڈاٹ آر او!ویلیو ایرر کو بڑھاؤ (\"میٹرکس میں ایک ہی جہت شامل ہونا ضروری ہے\") نتیجہ = میٹرکس (سیلف.روز ، سیلف کولز) رینج (سیلف ڈاٹ آر او آرز) کے لئے: رینج میں جے کے لئے (سیلف.کولز): نتیجہ۔ ڈیٹا ڈیٹا[i] [j] = self.data [i] [j] + دیگر.ڈیٹا [i] [j] واپسی کا نتیجہ Def __mul __ (خود ، دوسرا): اگر سیلف.کولز! = دیگر.روز: ویلیو ایرر (\"بڑھاؤ (\"پہلے میٹرکس میں کالموں کی تعداد کو دوسرے میٹرکس میں قطاروں کی تعداد سے ملنا چاہئے \") نتیجہ = میٹرکس (سیلف.روز ، دیگر.کول) میں رینج (سیلف.روز) کے لئے: رینج میں جے کے لئے (دوسرے.کولز): رینج میں K کے لئے (self.cols): نتیجہ۔ ڈیٹا [i] [j] += سیلف ڈاٹ ڈیٹا [i] [k] * دوسرے.ڈیٹا [k] [j] واپسی کا نتیجہ ڈیف ٹرانسپوز (خود):نتیجہ = میٹرکس (سیلف.کولز ، سیلف.روز) رینج (سیلف.روز) کے لئے: رینج میں جے کے لئے (سیلف۔ کولز): نتیجہ۔ ڈیٹا [j] [i] = سیلف ڈاٹ ڈیٹا [i] [j] اس کے نفاذ کے نتیجے میں ، میٹرکس کلاس میں ایک قطار کا وصف ہے جو میٹرکس میں قطاروں کی تعداد کی نمائندگی کرتا ہے ، ایک COLS وصف جو میٹرکس میں کالموں کی تعداد کی نمائندگی کرتا ہے ، اور ایک ڈیٹا وصف جو میٹرکس کو فہرستوں کی فہرست کے طور پر نمائندگی کرتا ہے۔کلاس میں ایک __repr__ طریقہ بھی ہوتا ہے جو میٹرکس کی تار کی نمائندگی کرتا ہے ، ایک __ADD__ طریقہ جس میں دو میٹرک شامل ہوتا ہے ، ایک __mul__ کا طریقہ جو دو میٹرک کو بڑھاتا ہے ، اور ایک ٹرانسپوس طریقہ جو میٹرکس کو منتقل کرتا ہے۔ یہاں ایک مثال ہے کہ کس طرح استعمال کیا جائےمیٹرکس کلاس: پائیٹونم 1 = میٹرکس (2 ، 2) m1.data = [[1 ، 2] ، [3 ، 4]] M2 = میٹرکس (2 ، 2) m2.data = [[5 ، 6] ، [7 ،8]] پرنٹ (M1 + M2) # پرنٹس \"6 8 \\ n10 12\" M3 = میٹرکس (2 ، 3) M3.Data = [[1 ، 2 ، 3] ، [4 ، 5 ، 6]] M4 = میٹرکس.) # پرنٹس \"1 3 \\ n2 4\" اس مثال میں ، میٹرکس کے اضافے کا مظاہرہ کرنے کے لئے + آپریٹر کا استعمال کرتے ہوئے دو میٹرکس آبجیکٹ ، M1 اور M2 ، بنائے گئے ہیں اور شامل کیے گئے ہیں۔میٹرکس کی دو اشیاء ، M3 اور M4 ، میٹرکس ضرب کا مظاہرہ کرنے کے لئے * آپریٹر کا استعمال کرتے ہوئے ایک دوسرے کے ساتھ مل کر اور ضرب دیئے گئے ہیں۔اس کے بعد میٹرکس کلاس کا ٹرانسپوز طریقہ M1 میٹرکس کو منتقل کرنے اور نتیجہ کو پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔"
    },
    {
        "Question": "ازگر میں طریقہ کس طرح زنجیر ہے؟ایک مثال پیش کریں جس کا مظاہرہ کرنے والے طریقہ کار زنجیروں کو۔",
        "Answer": "طریقہ زنجیروں نے ازگر میں ایک پروگرامنگ کی تکنیک ہے جو DOT آپریٹر 123456 کا استعمال کرتے ہوئے کوڈ کی ایک ہی لائن میں ایک ہی چیز پر متعدد طریقوں کو طلب کرنے کی اجازت دیتا ہے۔ایک طریقہ کی آؤٹ پٹ کو اگلے طریقہ کار کے ان پٹ کے طور پر منظور کیا جاتا ہے ، اور اسی طرح ، جب تک کہ مطلوبہ نتیجہ 123456 حاصل نہ ہوجائے۔طریقہ کی زنجیر کوڈ کو زیادہ جامع اور پڑھنے کے قابل بنا سکتی ہے ، کیونکہ اس سے ہر طریقہ کار کی پیداوار کو اسٹور کرنے کے لئے انٹرمیڈیٹ متغیر بنانے کی ضرورت ختم ہوجاتی ہے۔ یہاں ازگر میں زنجیروں کی زنجیر کی ایک مثال ہے: ازگرکلاس کیلکولیٹر: ڈیف __init __ (خود ، قیمت): خود۔ویلیو = ویلیو ڈیف شامل کریں (خود ، x): سیلف۔ ویلیو += ایکس ریٹرن سیلف ڈی ای ایف گھٹاؤ (خود ، x): خود۔ ویلیو -= ایکس ریٹرن سیلف ڈیف ضرب (خود ، x): سیلف۔ ویلیو *= ایکس ریٹرنسیلف ڈیف ڈویژن (خود ، x): سیلف۔ ویلیو /= ایکس ریٹرن سیلفکلک = کیلکولیٹر (10) نتیجہ = کیلک.اڈڈ (5)# پرنٹس 4.5 ان مثال کے طور پر ، کیلکولیٹر کلاس میں کسی قدر کو شامل کرنے ، گھٹانے ، ضرب لگانے اور تقسیم کرنے کے طریقے ہیں۔ہر طریقہ کار کیلکولیٹر آبجیکٹ کو خود لوٹاتا ہے ، جو طریقوں کو ایک ساتھ جکڑے جانے کی اجازت دیتا ہے۔کیلکولیٹر کلاس کا ایک شے 10 کی ابتدائی قیمت کے ساتھ تخلیق کیا گیا ہے ، اور اس کے طریقوں کو 5 شامل کرنے کے لئے ایک ساتھ جکڑا ہوا ہے ، 2 سے ضرب لگائیں ، 3 کو گھٹائیں ، اور 4 سے تقسیم کریں۔طریقہ زنجیر"
    },
    {
        "Question": "وراثت سے زیادہ ساخت کے تصور کی وضاحت کریں اور اس کے فوائد کی عکاسی کرنے والی ایک مثال پیش کریں۔",
        "Answer": "وراثت سے زیادہ ساخت آبجیکٹ پر مبنی پروگرامنگ میں ایک ڈیزائن کا اصول ہے جو کلاس 123456 کا خاندانی درخت بنانے کے بجائے مختلف اجزاء سے باہر کلاس بنانے کی حمایت کرتا ہے۔خیال یہ ہے کہ ایسی کلاسیں بنائیں جو دوسرے طبقوں پر مشتمل ہوں جو کلاسوں کے مابین مشترکات کو تلاش کرنے کی کوشش کرنے اور وراثت 123456 کا درجہ بندی پیدا کرنے کی بجائے مخصوص فعالیت فراہم کرتی ہیں۔مرکب اعلی لچک فراہم کرتا ہے اور بزنس ڈومین کلاسز 123456 کی تعمیر کے لئے زیادہ قدرتی ہے۔مثال کے طور پر ، ایکسلریٹر پیڈل اور ایک اسٹیئرنگ وہیل بہت کم عام خصلتوں کا اشتراک کرتے ہیں ، پھر بھی دونوں CAR123456 میں اہم اجزاء ہیں۔وہ کیا کرسکتے ہیں اور کار کو فائدہ پہنچانے کے لئے ان کا استعمال کس طرح کیا جاسکتا ہے اس کی آسانی سے کمپوزیشن 123456 کے ذریعے بیان کیا جاتا ہے۔ وراثت سے زیادہ مرکب کے فوائد میں سے ایک یہ ہے کہ یہ ان طریقوں کی درخواست میں زیادہ لچک فراہم کرتا ہے جو متعدد ذیلی طبقے کے منظرنامے 2 کے ساتھ مفید ہے۔دوسرا فائدہ یہ ہے کہ یہ کسی اڈے یا والدین کی کلاس 3 سے وراثت میں ملنے کے بجائے دوسری اقسام کی اشیاء کو ملا کر پیچیدہ اقسام کی تخلیق کو قابل بناتا ہے۔مرکب بہتر جانچ کا دائرہ بھی مہیا کرتا ہے ، کیونکہ یونٹ کی جانچ کی تشکیل میں آسان ہے کیونکہ ہم جانتے ہیں کہ ہم کسی اور کلاس 2 سے کیا تمام طریقے استعمال کر رہے ہیں۔ یہاں ازگر میں وراثت سے زیادہ ساخت کی ایک مثال ہے: ازگر کلاس انجن: ڈیف اسٹارٹ (خود): پرنٹ (پرنٹ (\"پرنٹ (\"انجن شروع ہوا \") کلاس کار: Def __init __ (خود): سیلف۔ انجین = انجن () ڈیف اسٹارٹ (خود): self.engine.start () کار = کار () کار۔ اسٹارٹ () # پرنٹس\" انجن شروع ہوا \"اس مثال کے طور پر ، انجن کی کلاس ایک انجن کی نمائندگی کرتی ہے ، اور کار کلاس ایک کار کی نمائندگی کرتی ہے۔کار کلاس میں ایک انجن وصف ہے جو انجن کلاس کی ایک مثال ہے۔کار کلاس کا آغاز کا طریقہ انجن کلاس کے آغاز کے طریقہ کار کو انجن وصف کے ذریعے کال کرتا ہے۔اس سے یہ ظاہر ہوتا ہے کہ کار کلاس کس طرح انجن کلاس پر مشتمل ہے ، اس سے وراثت میں اس کے بجائے۔یہ نقطہ نظر زیادہ لچک فراہم کرتا ہے ، کیونکہ کار کلاس دوسرے طبقوں پر مشتمل ہوسکتی ہے جو مخصوص فعالیت فراہم کرتی ہے ، بجائے انجن کی کلاس کے ذریعہ فراہم کردہ فعالیت تک محدود رہنے کی بجائے۔"
    },
    {
        "Question": "\"اعلی ترجیحی عنصر کی داخل ، حذف کرنے اور بازیافت کے طریقوں کے ساتھ ترجیحی قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "اعلی ترجیحی عنصر کے اندراج ، حذف کرنے ، اور بازیافت کے طریقوں کے ساتھ ترجیحی قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے کے لئے ، ہم قطار کا استعمال کرسکتے ہیں۔یہ طبقہ بائنری ہیپ کا استعمال کرتے ہوئے ترجیحی قطار کا اطلاق کرتا ہے ، جو اعلی ترجیحی عنصر 123 کی موثر اندراج ، حذف کرنے اور بازیافت کی اجازت دیتا ہے۔یہاں ایک مثال عمل ہے: پائیٹونیم پورٹ کوئو کلاس کی ترجیحی کیوئو: ڈیف __init __ (خود): سیلف۔ کیوئو = قطار۔ پرائیریٹی کیوئو () ڈیف داخل کریں (خود ، آئٹم ، ترجیح): سیلف ڈاٹ کیوئو.پوت ((ترجیحی ، آئٹم)) ڈیف ڈیلیٹ ((ترجیحی ، آئٹم))خود): reture.queue.get () [1] Def get_highest_priority (self): واپس کردیں۔. priorityqueue کلاس.ترجیحی کیو کلاس کا داخل کرنے کا طریقہ ایک شے اور ترجیح لیتا ہے اور قطار کے پوٹ طریقہ کا استعمال کرتے ہوئے انہیں ترجیحی قطار میں داخل کرتا ہے۔ترجیحی کیو کلاس کا حذف کرنے والا طریقہ قطار کے GET طریقہ کا استعمال کرتے ہوئے ترجیحی قطار سے اعلی ترجیحی آئٹم کو ہٹاتا ہے اور واپس کرتا ہے۔ترجیحی کیو کلاس کا GET_HIGEST_PRIOTY طریقہ ترجیحی قطار میں اعلی ترجیحی آئٹم کو اسے ہٹائے بغیر لوٹاتا ہے۔ یہاں ترجیحی کیو کی کلاس کو کس طرح استعمال کیا جائے: پائیٹونپ کیو = ترجیحی کیوئ () PQ.INSERT ('TASH1' ، 5) PQ.INSERT.) # پرنٹس \"ٹاسک 3\" پرنٹ (pq.delete ()) # پرنٹ \"ٹاسک 1\" اس مثال میں ، ایک ترجیحی چیز تشکیل دی جاتی ہے اور مختلف ترجیحات کے ساتھ ترجیحی قطار میں تین کام داخل کرنے کے لئے استعمال ہوتی ہے۔اس کے بعد ترجیحی طبقے کا GET_HIGEST_PRIOTY طریقہ استعمال کیا جاتا ہے پھر اسے ختم کیے بغیر اعلی ترجیحی کام کو بازیافت کرنے کے لئے استعمال کیا جاتا ہے ، جو 'ٹاسک 2' ہے۔اس کے بعد ترجیحی طبقے کی کلاس کا حذف کرنے کا طریقہ اعلی ترجیحی کام کو ہٹانے اور پرنٹ کرنے کے لئے استعمال کیا جاتا ہے ، جو 'ٹاسک 2' ہے۔اس عمل کو ترجیحی قطار میں باقی کاموں کے لئے دہرایا گیا ہے۔"
    },
    {
        "Question": "ازگر میں انٹرفیس کے تصور کی وضاحت کریں اور بتائیں کہ ان کا استعمال متعدد وراثت کے حصول کے لئے کس طرح کیا جاتا ہے۔",
        "Answer": "ازگر میں ، انٹرفیس زبان کی ایک بلٹ ان خصوصیت نہیں ہیں ، لیکن انہیں ABC ماڈیول 123 سے خلاصہ بیس کلاس (ABCs) کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ایک انٹرفیس خلاصہ طریقوں کا ایک مجموعہ ہے جو طرز عمل کے ایک سیٹ کی وضاحت کرتا ہے جسے ایک کلاس کو 123 پر عمل درآمد کرنا چاہئے۔ایک کلاس جو انٹرفیس کو نافذ کرتی ہے اسے انٹرفیس 123 میں بیان کردہ ہر طریقہ کار کے لئے عمل درآمد کرنا چاہئے۔انٹرفیس کا استعمال کسی ایک بیس کلاس 1423 سے ایک کلاس کو متعدد انٹرفیس کو نافذ کرنے اور وارث ہونے کی اجازت دے کر ازگر میں ایک سے زیادہ وراثت کے حصول کے لئے استعمال کیا جاتا ہے۔ یہاں تک کہ ازگر میں متعدد وراثت کے حصول کے لئے انٹرفیس استعمال کرنے کی ایک مثال ہے: پائیٹونیمپورٹ اے بی سی سی ایل اے ایس سی شکل (میٹاکلاس = اے بی سی۔ اے بی سی ایم ای ٹی اے):@abc.abstractmethod def ایریا (خود): پاسکلاس کا رنگ (میٹاکلاس = abc.abcmeta): @abc.abstractmethod def رنگ (خود): پاسکلاس اسکوائر (شکل ، رنگ): Def __init __ (خود ، پہلو ، رنگ): خود۔سائیڈ = سائیڈ سیلف۔ کالور_ ویلیو = کلر ڈیف ایریا (خود): خود واپس کریں۔25 پرنٹ (اسکوائر.کلر ()) # \"سرخ\" پرنٹس اس مثال میں ، شکل کی کلاس ایک شکل کی نمائندگی کرتی ہے ، رنگ کلاس ایک رنگ کی نمائندگی کرتا ہے ، اور مربع کلاس ایک مربع کی نمائندگی کرتا ہے۔شکل اور رنگ کی کلاسیں انٹرفیس ہیں جو بالترتیب علاقے اور رنگین طریقوں کی وضاحت کرتی ہیں۔مربع کلاس انٹرفیس دونوں کو نافذ کرتا ہے اور نہ ہی وراثت میں۔اسکوائر کلاس میں ایک رقبہ کا طریقہ ہے جو مربع کے رقبے کو لوٹاتا ہے اور ایک رنگین طریقہ جو مربع کا رنگ لوٹاتا ہے۔مربع کلاس کا ایک شے 5 کی لمبائی اور 'سرخ' کے رنگ کے ساتھ تخلیق کیا گیا ہے ، اور اس کے رقبے اور رنگین طریقوں کو متعدد وراثت کے حصول کے لئے انٹرفیس کے استعمال کا مظاہرہ کرنے کے لئے کہا جاتا ہے۔"
    },
    {
        "Question": "ازگر میں سپر () فنکشن کا مقصد کیا ہے؟اس کے استعمال کا مظاہرہ کرنے والی ایک مثال فراہم کریں۔",
        "Answer": "ازگر میں سپر () فنکشن کا استعمال والدین کی کلاسز 1234 کے طریقوں اور صفات تک رسائی اور تفویض کے لئے کیا جاتا ہے۔یہ واضح طور پر والدین کی کلاس کا حوالہ دینے کا ایک آسان طریقہ فراہم کرتا ہے اور ایک طبقے کو اسی درجہ بندی 234 میں دوسرے طبقے کے طریقوں اور خصوصیات تک رسائی حاصل کرنے کی اجازت دیتا ہے۔سپر () فنکشن عام طور پر بے کار کوڈ سے بچنے اور اسے 234 کو برقرار رکھنے کے لئے زیادہ منظم اور آسان بنانے کے لئے استعمال کیا جاتا ہے۔ سپر () فنکشن کو سبکلاس 1235 سے والدین کی کلاس میں کسی طریقہ کو کال کرنے کے لئے استعمال کیا جاتا ہے۔یہ اکثر والدین کی کلاس کی صفات 1235 کو شروع کرنے کے لئے __init__ کے طریقہ کار کے ساتھ مل کر استعمال کیا جاتا ہے۔سپر () فنکشن دو دلائل لیتا ہے: پہلا ذیلی طبقہ ہے جو اس طریقہ کار کو بلا رہا ہے ، اور دوسرا سبکلاس 1235 کی مثال ہے۔سپر () فنکشن ایک عارضی شے کو لوٹاتا ہے جو کلیدی لفظ کے ذریعہ پیرنٹ کلاس کے حوالے کی اجازت دیتا ہے۔ یہاں سپر () فنکشن کے استعمال کا مظاہرہ کرنے والی ایک مثال ہے: ازگر کلاس جانوروں: ڈیف __ __init __ (خود ، نام): سیلف۔ نام =نمکلاس ڈاگ (جانور): Def __init __ (خود ، نام ، نسل): سپر ()\"پرنٹ (ڈاگ بریڈ) # پرنٹس\" لیبراڈور \"اس مثال میں ، جانوروں کی کلاس کسی جانور کی نمائندگی کرتی ہے ، اور کتے کی کلاس کتے کی نمائندگی کرتی ہے۔کتے کی کلاس جانوروں کی کلاس سے وراثت میں ملتی ہے اور اس میں ایک اضافی وصف نسل ہوتی ہے۔کتے کی کلاس کا __init__ طریقہ نام وصف کو شروع کرنے کے لئے سپر () فنکشن کا استعمال کرتے ہوئے جانوروں کی کلاس کے __init__ طریقہ کو کہتے ہیں۔ڈاگ کلاس کا ایک شے 'فیڈو' کے نام اور 'لیبراڈور' کی نسل کے ساتھ تخلیق کیا گیا ہے ، اور اس کے نام اور نسل کی خصوصیات سپر () فنکشن کے استعمال کو ظاہر کرنے کے لئے چھپی ہوئی ہیں۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی ہوتی ہے جس میں داخل ، حذف کرنے اور کاموں کو ڈھیر کرنے کے طریقوں کے ساتھ۔\"",
        "Answer": "بائنری ہیپ ایک خاص ڈیٹا ڈھانچہ ہے جو بائنری درخت سے ملتا ہے اور اس کی ساخت 123 کی بنیاد پر زیادہ سے زیادہ یا منٹ عنصر حاصل کرنے کے لئے ڈیٹا کو موثر انداز میں ذخیرہ کرنے کے لئے استعمال ہوتا ہے۔یہ ایک مکمل بائنری درخت ہے جو ڈھیر کی پراپرٹی کو مطمئن کرتا ہے ، جہاں کوئی بھی نوڈ اپنے بچے نوڈ/س سے زیادہ ہوتا ہے اور جڑ نوڈ کی کلید دوسرے تمام نوڈس 42 میں سب سے بڑا ہوتا ہے۔ڈھیروں کی دو اہم اقسام ہیں: منھیپ اور میکسیپ 1۔ایک مینیپ میں ، ہر ذیلی ٹری کی جڑ سب سے چھوٹا عنصر ہوتا ہے ، جبکہ ایک میکسیپ میں ، ہر سب ٹری کی جڑ سب سے بڑا عنصر ہوتا ہے۔ ایک ازگر کلاس کو نافذ کرنے کے لئے جو بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے جس میں داخل ، حذف کرنے ، اور ہیپائف آپریشنز کے طریقوں کے ساتھ ہوتا ہے۔، ہم ازگر کے معیاری لائبریری 3 کے ذریعہ فراہم کردہ ہیپ کیو ماڈیول استعمال کرسکتے ہیں۔یہ ماڈیول لسٹس 3 پر ہیپ آپریشنز کے لئے افعال فراہم کرتا ہے۔یہاں ایک مثال عمل ہے: پائیتھونیمپورٹ ہیپکلاس بائنری ہیپ: ڈیف __init __ (خود): سیلف۔ ہیپ = [] ڈیف داخل کریں (خود ، آئٹم): ہیپ کیو۔ ہیپش (سیلف ۔ہپ ، آئٹم) ڈیف ڈیلیٹ (خود).بائنری ہیپ کلاس کا داخل کرنے کا طریقہ ہیپ کیو ماڈیول کے ہیپش فنکشن کا استعمال کرتے ہوئے بائنری ہیپ میں کسی شے کو داخل کرتا ہے۔بائنری ہیپ کلاس کا حذف کرنے والا طریقہ ہیپ کیو ماڈیول کے ہیپپپ فنکشن کا استعمال کرتے ہوئے بائنری ہیپ سے چھوٹی چھوٹی چیز کو ہٹاتا ہے اور واپس کرتا ہے۔بائنری ہیپ کلاس کا ہیپائیف طریقہ ان پٹ کے طور پر ایک فہرست لیتا ہے اور اسے بائنری ہیپ میں ہیپ کیو ماڈیول کے ہیپائف فنکشن کا استعمال کرتے ہوئے تبدیل کرتا ہے۔ اس کی ایک مثال ہے کہ بائنری ہیپ طبقے کو کس طرح استعمال کیا جائے: پائیٹونبھ = بائنری ہیپ () بی ایچ. INSERT (5) bh.insert (3) bh.insert (7) پرنٹ (bh.heap) # پرنٹس \"[3 ، 5 ، 7]\" پرنٹ (bh.delete ()) # پرنٹس \"3\" پرنٹ (bh.heap) #پرنٹس \"[5 ، 7]\" bh.heapify ([9 ، 1 ، 5 ، 3 ، 7]) پرنٹ (bh.heap) # پرنٹس \"[1 ، 3 ، 5 ، 9 ، 7]\" اس مثال میں ، aبائنری ہیپ آبجیکٹ بائنری ہیپ میں تین اشیاء داخل کرنے اور استعمال کرنے کے لئے استعمال ہوتا ہے۔اس کے بعد اندراج کے عمل کو ظاہر کرنے کے لئے بائنری ہیپ آبجیکٹ کا ڈھیر وصف پرنٹ کیا جاتا ہے۔اس کے بعد بائنری ہیپ کلاس کا حذف کرنے کا طریقہ بائنری ہیپ سے سب سے چھوٹی شے کو ہٹانے اور پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔اس کے بعد حذف کرنے کے عمل کو ظاہر کرنے کے لئے بائنری ہیپ آبجیکٹ کا ڈھیر وصف دوبارہ پرنٹ کیا جاتا ہے۔اس کے بعد بائنری ہیپ کلاس کا ہیپائیف طریقہ کسی فہرست کو بائنری ہیپ میں تبدیل کرنے کے لئے استعمال کیا جاتا ہے ، اور بائنری ہیپ آبجیکٹ کی ڈھیر کی انتساب کو ہیپیفائی آپریشن کا مظاہرہ کرنے کے لئے پرنٹ کیا جاتا ہے۔"
    },
    {
        "Question": "ازگر میں متعدد وراثت میں طریقہ ریزولوشن آرڈر (ایم آر او) کے تصور کی وضاحت کریں اور ایک مثال پیش کریں۔",
        "Answer": "میتھڈ ریزولوشن آرڈر (ایم آر او) ایک ایسا تصور ہے جو اس ترتیب کا تعین کرنے کے لئے ازگر ایک سے زیادہ وراثت میں استعمال ہوتا ہے جس میں کلاس 12345 کے درجہ بندی میں طریقوں کی تلاش کی جاتی ہے۔یہ وہ ترتیب ہے جس میں کلاس کے درجہ بندی میں ایک طریقہ تلاش کیا جاتا ہے اور خاص طور پر ازگر میں مفید ہے کیونکہ ازگر متعدد وراثت 12345 کی حمایت کرتا ہے۔ایم آر او وہ ترتیب ہے جس میں ازگر کلاسز 2 کے درجہ بندی میں ایک طریقہ تلاش کرتا ہے۔ایم آر او کا تعین رن ٹائم کے وقت ہوتا ہے اور اس ترتیب پر مبنی ہوتا ہے جس میں کلاسوں کو وراثت کی فہرست 2345 میں متعین کیا جاتا ہے۔ایم آر او نیچے سے اوپر اور بائیں سے دائیں 5 ہے۔اس کا مطلب یہ ہے کہ ، پہلے ، اس طریقہ کار کو آبجیکٹ کی کلاس میں تلاش کیا جاتا ہے۔اگر یہ نہیں ملا ہے تو ، اسے فوری سپر کلاس میں تلاش کیا جاتا ہے۔متعدد سپر کلاسوں کی صورت میں ، اس کو بائیں سے دائیں تلاش کیا جاتا ہے ، جس ترتیب سے ڈویلپر 5 کے ذریعہ اعلان کیا گیا تھا۔ یہاں ایک مثال ہے جو ازگر میں ایم آر او کے تصور کو ظاہر کرتا ہے: ازگر کلاس A: ڈیف طریقہ (خود): پرنٹ (پرنٹ (پرنٹ (پرنٹ (پرنٹ (خود)\"A.Method () کہا جاتا ہے\") کلاس B: DEF طریقہ (خود): پرنٹ (\"B.Method () کہا جاتا ہے\") کلاس C (A ، B): پاسک = C () C.Method () # پرنٹس \"A.Method () کہا جاتا ہے \"اس مثال میں ، کلاس میں ایک ایسا طریقہ ہے جو\" A.Method () نامی \"پرنٹ کرتا ہے ، بی کلاس کا ایک طریقہ ہے جو\" B.Method () کہا جاتا ہے \"پرنٹ کرتا ہے ، اور سی کلاس وراثت میں ہے۔اے اور بی دونوں سے سی کلاس کا ایک شے تیار کیا جاتا ہے ، اور اس کا طریقہ کہا جاتا ہے۔چونکہ اے سی کی وراثت کی فہرست میں B سے پہلے درج ہے ، لہذا A کا طریقہ کہا جاتا ہے ، اور \"A.Method () کہا جاتا ہے\" پرنٹ کیا جاتا ہے۔یہ ازگر میں متعدد وراثت میں ایم آر او کے تصور کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "وراثت کے سلسلے میں طریقہ کار کے تصور کو بیان کریں اور اس کے استعمال کو واضح کرنے والی ایک مثال فراہم کریں۔",
        "Answer": "طریقہ کار اوور رائڈنگ آبجیکٹ پر مبنی پروگرامنگ میں ایک تصور ہے جو ایک ذیلی طبقے یا بچوں کی کلاس کو کسی ایسے طریقہ کار پر ایک مخصوص نفاذ فراہم کرنے کی اجازت دیتا ہے جو پہلے ہی اس کے کسی سپر کلاس یا والدین کی کلاسز 12345 کے ذریعہ فراہم کیا جاتا ہے۔جب کسی ذیلی طبقے میں ایک ایسا طریقہ ہوتا ہے جو سپر کلاس کے کسی طریقہ کو اوور رائڈ کرتا ہے ، تو پھر اس حد سے زیادہ طریقہ کار کو واضح طور پر کسی ذیلی طبقے کے طریقہ کار کے اندر سے مطلوبہ الفاظ کا استعمال کرکے طلب کیا جاسکتا ہے۔سبکلاس اوور رائڈس میں نفاذ (اس کی جگہ) سپر کلاس میں عمل درآمد کو ایک ایسا طریقہ فراہم کرکے جس کا ایک ہی نام ، ایک ہی پیرامیٹرز یا دستخط ، اور والدین کی کلاس 12345 میں طریقہ کار کی طرح واپسی کی قسم ہے۔اس طریقہ کار کا ورژن جس کا استعمال کیا جاتا ہے اس کا تعین اس شے کے ذریعہ کیا جائے گا جو IT12345 کو استعمال کرنے کے لئے استعمال ہوتا ہے۔ یہاں ایک مثال ہے جو ازگر میں طریقہ کار کے استعمال کے استعمال کو ظاہر کرتی ہے: ازگر کلاس جانوروں: ڈیف اسپیک (خود): پرنٹ (\"جانور بولتا ہے\")کلاس ڈاگ (جانور): ڈیف اسپیک (خود): پرنٹ (\"ڈاگ بارکس\") کتا = کتا () ڈاگ۔ اسپیک () # پرنٹس \"ڈاگ بارکس\" اس مثال کے طور پر ، جانوروں کی کلاس میں ایک بولنے کا طریقہ ہے جو \"جانور پرنٹ کرتا ہے\"بولتا ہے \"، اور کتے کی کلاس جانوروں کی کلاس سے وراثت میں ملتی ہے اور اس کے اپنے نفاذ کے ساتھ بولنے کے طریقہ کار کو اوور رائڈ کرتی ہے جو\" ڈاگ بارکس \"پرنٹ کرتی ہے۔کتے کی کلاس کا ایک شے تیار کیا جاتا ہے ، اور اس کے بولنے کا طریقہ کہا جاتا ہے۔چونکہ ڈاگ کلاس جانوروں کی کلاس کے بولنے کے طریقہ کار کو زیر کرتا ہے ، لہذا کتے کی کلاس کے بولنے کا طریقہ کہا جاتا ہے ، اور \"ڈاگ بارکس\" پرنٹ کیا جاتا ہے۔یہ ازگر میں طریقہ کار کے تصور کو ظاہر کرتا ہے"
    },
    {
        "Question": "وراثت سے زیادہ مرکب کے اصولوں کی وضاحت کریں اور ایک حقیقی دنیا کا منظر پیش کریں جہاں مرکب زیادہ مناسب ہوگا۔",
        "Answer": "وراثت سے زیادہ ساخت آبجیکٹ پر مبنی پروگرامنگ کا ایک اصول ہے جس سے پتہ چلتا ہے کہ کلاسوں کو کسی اڈے یا والدین کی کلاس 123456 سے وراثت کی بجائے ان کی تشکیل کے ذریعہ پولیمورفک سلوک اور کوڈ دوبارہ استعمال کرنا چاہئے۔ساخت میں ، اشیاء کو ڈھیلے سے جوڑا جاتا ہے ، اس کا مطلب ہے کہ کلاس اور اشیاء کو کوڈ 2 کو توڑے بغیر آسانی سے تبدیل کیا جاسکتا ہے۔اس سے مرکب کو وراثت 23456 کے مقابلے میں زیادہ لچکدار اور برقرار رکھنے میں آسانی ہوتی ہے۔ساخت طبقاتی وراثت کا متبادل ہے جو مختلف مقاصد 2 کو پورا کرتا ہے۔اس سے ڈویلپرز کو ایسی کلاسیں بنانے کی اجازت ملتی ہے جو دوسرے طبقوں پر مشتمل ہوتے ہیں جو کلاسوں کے مابین مشترکات کو تلاش کرنے کی کوشش کرنے اور وراثت 123456 کا درجہ بندی پیدا کرنے کی بجائے مخصوص فعالیت فراہم کرتے ہیں۔ ایک حقیقی دنیا کا منظر نامہ جہاں مرکب زیادہ مناسب ہوگا کار ہے۔ایک کار مختلف اجزاء پر مشتمل ہے ، جیسے انجن ، پہیے ، بریک ، اور اسٹیئرنگ وہیل 123456۔ان اجزاء کا تعلق وراثت سے نہیں ہے ، بلکہ کمپوزیشن 123456 سے ہے۔ہر جزو مخصوص فعالیت فراہم کرتا ہے ، اور کار مطلوبہ طرز عمل کو حاصل کرنے کے لئے ان اجزاء پر مشتمل ہے ۔123456۔مثال کے طور پر ، انجن کار کو منتقل کرنے کی طاقت فراہم کرتا ہے ، پہیے رول کرنے کی صلاحیت فراہم کرتے ہیں ، بریک روکنے کی صلاحیت فراہم کرتے ہیں ، اور اسٹیئرنگ وہیل سمت 123456 کو تبدیل کرنے کی صلاحیت فراہم کرتا ہے۔ساخت کا استعمال کرکے ، کار کو آسانی سے انفرادی اجزاء کی جگہ یا اپ گریڈ کرکے اپنی مرضی کے مطابق اور برقرار رکھا جاسکتا ہے ، بجائے اس کے کہ CAR13456.1Wikeipedia3digitalocean4betterprogramming5javarevisededsided6geeksforgeeks کو CAR13456.1Wikeipedia2adservio3digitalocean4betterprogramming5javarevisededside"
    },
    {
        "Question": "\"بائنری سرچ ٹری کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور آرڈر ، پری آرڈر ، اور پوسٹ آرڈر ٹریورلز کے لئے طریقے فراہم کریں۔\"",
        "Answer": "بائنری سرچ ٹری کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے اور آرڈر ، پری آرڈر ، اور پوسٹ آرڈر ٹریورلز کے لئے طریقے فراہم کرنے کے ل we ، ہم بائنری سرچ ٹری میں ہر نوڈ کی نمائندگی کرنے کے لئے نوڈ کلاس اور بائنری سرچ ٹری کلاس کی نمائندگی کرنے کے لئے استعمال کرسکتے ہیں۔بائنری سرچ ٹری خود 1234۔یہاں ایک مثال عمل ہے: پائیٹونکلاس نوڈ: ڈیف __init __ (خود ، ویل): سیلف.وال = ویل سیلف۔ویل): اگر self.rot کوئی بھی نہیں ہے: self.root = نوڈ (ویل) اور: سیلف۔بائیں کوئی نہیں ہے: نوڈ.لفٹ = نوڈ (ویل) اور: سیلف ۔_ انرٹ (ویل ، نوڈ. لیفٹ) اور: اگر نوڈ. رائٹ کوئی نہیں ہے: نوڈ۔ رائٹ = نوڈ (ویل) اور: سیلف ۔_ انرٹ (ویل ، نوڈ. رائٹ) ڈیف انڈرڈر (خود): والس = [] سیلف ۔_ انڈرڈر (سیلف.روٹ ، والس) ریٹرن والز ڈیف _ انڈرڈر (سیلف ، نوڈ ، والس): اگر نوڈ کوئی نہیں ہے: سیلف۔) وال.ایپینڈ (نوڈ.وال) سیلف ۔_ انڈرڈر (نوڈ. رائٹ ، والس) ڈیف پری آرڈر (خود): والس = [] سیلف ۔_پری آرڈر (سیلف۔روٹ ، والس) ریٹرن والس ڈیف _ پری آرڈر (خود ، نوڈ ، والس): اگر نوڈ کوئی نہیں ہے: ویلز۔ اپینڈ (نوڈ.وال) سیلف ۔_پری آرڈر (نوڈ۔ لیفٹ ، ویلز) سیلف ۔_پری آرڈر (نوڈ۔ رائٹ ، والس) ڈیف پوسٹ آرڈر (خود): والس = [] سیلف۔.ROOT ، VALS) ریٹرن ویلز DEF _Postorder (سیلف ، نوڈ ، والس): اگر نوڈ کوئی نہیں ہے: سیلف ۔_پوسٹڈر (نوڈ۔ لیفٹ ، ویلز) سیلف۔) اس نفاذ میں ، نوڈ کلاس بائنری سرچ ٹری میں ہر نوڈ کی نمائندگی کرتا ہے ، اور بائنری سرچ ٹری کلاس بائنری سرچ ٹری کی نمائندگی کرتی ہے۔بائنری سرچ ٹری کلاس کے پاس ایک داخل کرنے کا طریقہ ہے جو بائنری سرچ ٹری میں ایک قدر داخل کرتا ہے ، اور _ انرٹ کا طریقہ جو داخل کرنے کے طریقہ کار کے لئے ایک مددگار طریقہ ہے ، اور ان آرڈر ، پری آرڈر ، اور پوسٹ آرڈر کے طریقے جو آرڈر ، پری آرڈر اور پوسٹ کو انجام دیتے ہیں۔بالترتیب بائنری سرچ ٹری کے آرڈر ٹرورس۔_ ان آرڈر ، _ پری آرڈر ، اور _ پوسٹ آرڈر کے طریقے بالترتیب انڈر ، پری آرڈر ، اور پوسٹ آرڈر کے طریقوں کے لئے مددگار طریقے ہیں۔ یہاں بائنری سرچ ٹری کلاس کو استعمال کرنے کی ایک مثال ہے: پائیتھنبسٹ = بائنری سرچ ٹری () بی ایس ٹی ایسٹ (5) بی ایس ٹی ایسٹ (5) بی ایس ٹی ایسٹ () ())3) bst.insert (7) bst.insert (1) bst.insert (9) پرنٹ (bst.inorder ()) # پرنٹس \"[1 ، 3 ، 5 ، 7 ، 7 ، 9]\" پرنٹ (bst.preorder ()) # پرنٹس \"[5 ، 3 ، 1 ، 7 ، 9]\" پرنٹ (bst.postorder ()) # پرنٹس \"[1 ، 3 ، 9 ، 7 ، 5]\" اس مثال میں ، بائنری سرچ ٹری آبجیکٹ تخلیق اور استعمال ہوتا ہےبائنری سرچ ٹری میں پانچ اقدار داخل کرنا۔اس کے بعد بائنری سرچ ٹری کلاس کے انڈر آرڈر ، پری آرڈر ، اور پوسٹ آرڈر کے طریقوں کا استعمال بالترتیب بائنری سرچ ٹری کے آرڈر ، پری آرڈر ، اور پوسٹ آرڈر ٹریورلز کو انجام دینے کے لئے کیا جاتا ہے ، اور اس کے نتیجے میں فہرستیں ان کے استعمال کو ظاہر کرنے کے لئے چھاپتی ہیں۔طریقے"
    },
    {
        "Question": "\"سافٹ ویئر کی نشوونما میں ڈیزائن کے نمونوں کے تصور کی وضاحت کریں اور تخلیقی ، ساختی اور طرز عمل کے ڈیزائن کے نمونے کی ایک مثال پیش کریں۔\"",
        "Answer": "سافٹ ویئر ڈیزائن 123456 میں پیدا ہونے والے عام مسائل کے ڈیزائن کے نمونے دوبارہ قابل استعمال حل ہیں۔وہ مخصوص ڈیزائن کے مسائل کو حل کرنے کے لئے ایک ثابت نقطہ نظر فراہم کرتے ہیں ، جس سے سافٹ ویئر تیار کرنا آسان ہوجاتا ہے جو فعال اور برقرار رکھنے والے 123456 دونوں ہی ہے۔ڈیزائن کے نمونوں کو باضابطہ بہترین طریقوں سے بنایا جاتا ہے جو پروگرام یا سسٹم 123456 کو ڈیزائن کرتے وقت پروگرامرز عام مسائل کو حل کرنے کے لئے استعمال کرسکتے ہیں۔وہ تیار شدہ ڈیزائن نہیں ہیں جو براہ راست ماخذ یا مشین کوڈ میں تبدیل ہوسکتے ہیں بلکہ کسی مسئلے کو حل کرنے کے لئے تفصیل یا ٹیمپلیٹس کو تبدیل کیا جاسکتا ہے جو بہت سے مختلف حالات 123456 میں استعمال کیا جاسکتا ہے۔سافٹ ویئر ڈویلپمنٹ میں ڈیزائن کے نمونوں کے دو اہم استعمال ہوتے ہیں: ایک معیاری اصطلاحات فراہم کرنے اور کسی خاص منظر نامے سے مخصوص ہونا۔ ڈیزائن کے نمونوں کی تین اہم اقسام ہیں: تخلیق ، ساختی اور طرز عمل 5۔یہاں ہر قسم کی ایک مثال ہے: تخلیقاتی ڈیزائن کا نمونہ: سنگلٹن پیٹرن سنگلٹن پیٹرن ایک تخلیقاتی ڈیزائن کا نمونہ ہے جو کسی کلاس کے انسٹیٹیوٹیشن کو کسی ایک مثال تک محدود رکھتا ہے اور اس مثال 45 تک عالمی رسائی فراہم کرتا ہے۔یہ نمونہ مفید ہے جب پورے پروگرام 45 میں کلاس کی صرف ایک مثال کی ضرورت ہو۔مثال کے طور پر ، ایک لاگر کلاس جو فائل میں پیغامات لاگ ان کرتی ہے اس کو سنگلٹن پیٹرن کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے تاکہ یہ یقینی بنایا جاسکے کہ لاگر کلاس کی صرف ایک مثال پوری پروگرام 45 میں تخلیق اور استعمال کی گئی ہے۔ سٹرکچرل ڈیزائن پیٹرن: اڈاپٹر پیٹرن کا نمونہ ایک ساختی ڈیزائن کا نمونہ ہے۔جو متضاد انٹرفیس کو ایک ساتھ کام کرنے کی اجازت دیتا ہے۔یہ نمونہ اس وقت مفید ہے جب کسی موجودہ طبقے کو نئے تناظر میں استعمال کرنے کی ضرورت ہوتی ہے لیکن اس کا انٹرفیس نئے سیاق و سباق 45 کے ذریعہ مطلوبہ انٹرفیس کے ساتھ مطابقت نہیں رکھتا ہے۔مثال کے طور پر ، ایک اڈاپٹر کو لیگیسی سسٹم کے انٹرفیس کو ایک نئے انٹرفیس میں تبدیل کرنے کے لئے استعمال کیا جاسکتا ہے جو ایک نئے سسٹم 45 کے ذریعہ درکار ہے۔اشیاء کے درمیان تاکہ جب ایک شے کی حالت بدل جائے تو ، اس کے تمام انحصار کو مطلع کیا جاتا ہے اور خود بخود 45 کو اپ ڈیٹ کیا جاتا ہے۔یہ نمونہ اس وقت مفید ہے جب متعلقہ اشیاء کے مابین مستقل مزاجی کو برقرار رکھنے کی ضرورت ہو تو ان کو مضبوطی سے جوڑ کر 45۔مثال کے طور پر ، اسٹاک مارکیٹ کی ایپلی کیشن اپنے صارفین کو مطلع کرنے کے لئے آبزرور پیٹرن کا استعمال کرسکتی ہے جب اسٹاک کی قیمت 45.1 ٹیوٹوریالس پوائنٹ 2wikepedia3gitconnected4netsolutions5freecodecamp6sourcemaking"
    },
    {
        "Question": "\"دو اسٹیکوں کا استعمال کرتے ہوئے قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں ، جس سے موثر انکیو اور ڈی کیو آپریشنز کو یقینی بنایا جاسکے۔\"",
        "Answer": "دو اسٹیکوں کا استعمال کرتے ہوئے قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم قطار 1234 کے طرز عمل کی تقلید کے لئے دو اسٹیکوں کے استعمال کے نقطہ نظر کو استعمال کرسکتے ہیں۔پہلا اسٹیک عناصر کو ختم کرنے کے لئے استعمال ہوتا ہے ، اور دوسرا اسٹیک عناصر 1234 کو ڈی کیوئ کرنے کے لئے استعمال ہوتا ہے۔جب کسی عنصر کو منسلک کیا جاتا ہے تو ، اسے پہلے اسٹیک پر دھکیل دیا جاتا ہے۔جب کسی عنصر کو ختم کیا جاتا ہے تو ، یہ دوسرے اسٹیک سے پاپ ہوتا ہے۔اگر دوسرا اسٹیک خالی ہے تو ، پہلے اسٹیک سے تمام عناصر کو پاپ اور دوسرے اسٹیک پر ریورس ترتیب میں دھکیل دیا جاتا ہے۔اس سے یہ یقینی بنتا ہے کہ عناصر کو اس ترتیب میں ڈیکویڈ کیا جاتا ہے جس میں وہ انکیوئڈ 1234 تھے۔ یہاں ایک مثال کے طور پر عمل درآمد ہے: پائیتھنکلاس قطار: ڈیف __init __ (خود): سیلف۔ اسٹیک 1 = [] self.stack2 = [] Def enqueue (خود ، ویل).عمل درآمد ، قطار کی کلاس میں قطار کے طرز عمل کی نقالی کرنے کے لئے دو اسٹیک ، اسٹیک 1 اور اسٹیک 2 ہیں۔قطار کلاس کا enqueue طریقہ اسٹیک 1 پر عنصر کو آگے بڑھاتا ہے۔قطار کلاس کا ڈیکو طریقہ اسٹیک 2 سے کسی عنصر کو پاپ کرتا ہے۔اگر اسٹیک 2 خالی ہے تو ، اسٹیک 1 کے تمام عناصر کو پاپ اور اسٹیک 2 پر ریورس ترتیب میں دھکیل دیا جاتا ہے۔اس سے یہ یقینی بنتا ہے کہ عناصر کو اس ترتیب سے تعبیر کیا جاتا ہے جس میں ان کی مدد کی جاتی تھی۔ یہاں قطار کی کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونق = قطار () Q.enqueue (1) Q.enqueue (2) Q.enqueue (3) پرنٹ (Q.dequeue ()) # پرنٹس \"1\" پرنٹ (Q.dequeue ()) # پرنٹس \"2\" Q.enqueue (4) پرنٹ (Q.dequeue ()) # پرنٹس \"3\" پرنٹ (Q.ڈی کیو ()) # پرنٹ \"4\" اس مثال میں ، ایک قطار آبجیکٹ تیار کی جاتی ہے اور اسے قطار میں تین اقدار کو تقویت دینے کے لئے استعمال کیا جاتا ہے۔اس کے بعد قطار آبجیکٹ کا ڈیکو طریقہ قطار سے پہلی دو اقدار کو کم کرنے کے لئے استعمال کیا جاتا ہے ، اور اس کے نتیجے میں اقدار پرنٹ ہوجاتے ہیں۔اس کے بعد ایک اور قدر کو قطار میں لگایا جاتا ہے ، اور قطار آبجیکٹ کا ڈیکیو طریقہ قطار سے باقی دو اقدار کو ختم کرنے کے لئے استعمال ہوتا ہے ، اور اس کے نتیجے میں اقدار پرنٹ ہوتے ہیں۔"
    },
    {
        "Question": "ازگر میں متعدد وراثت کے تصور کی وضاحت کریں اور اس سے وابستہ امکانی چیلنجوں اور حلوں پر تبادلہ خیال کریں۔",
        "Answer": "ایک سے زیادہ وراثت آبجیکٹ پر مبنی پروگرامنگ میں ایک خصوصیت ہے جو ایک کلاس کو ایک سے زیادہ بیس کلاس 123456 سے صفات اور طریقوں کے وارث ہونے کی اجازت دیتی ہے۔ازگر میں ، ایک سے زیادہ وراثت کی تائید کی جاتی ہے ، اور یہ کلاس تعریف میں متعدد بیس کلاسوں کی وضاحت کرکے کوما 13456 کے ذریعہ الگ کیا جاتا ہے۔جب ایک کلاس متعدد بیس کلاسوں سے وراثت میں ملتی ہے تو ، یہ تمام بیس کلاسز 123456 کی صفات اور طریقوں تک رسائی حاصل کرسکتا ہے۔تاہم ، متعدد وراثت پیچیدگی اور ابہام پیدا کرسکتی ہے ، خاص طور پر جب دو یا زیادہ بیس کلاسوں میں ایک ہی نام 123456 کے طریقے ہوتے ہیں۔یہ ہیرے کے مسئلے کے نام سے جانا جاتا ہے ، اور یہ غیر متوقع سلوک 123456 کا باعث بن سکتا ہے۔ متعدد وراثت سے وابستہ ممکنہ چیلنجوں میں شامل ہیں: ہیرے کا مسئلہ: جب دو یا زیادہ بیس کلاسوں میں ایک ہی نام کے طریقے ہوتے ہیں تو ، یہ ابہام پیدا کرسکتا ہے اور غیر متوقع سلوک 123456 کا باعث بن سکتا ہے۔اس مسئلے کو میتھڈ ریزولوشن آرڈر (ایم آر او) کا استعمال کرتے ہوئے حل کیا جاسکتا ہے ، جو اس ترتیب کا تعین کرتا ہے جس میں کلاسز 123456..complecity کے ایک درجہ بندی میں طریقے تلاش کیے جاتے ہیں: ایک سے زیادہ وراثت کوڈ میں پیچیدگی پیدا کرسکتی ہے ، خاص طور پر جب بہت سے بیس کلاسز 123456 موجود ہیں۔اس سے کوڈ کو سمجھنے اور برقرار رکھنے میں مشکل تر ہوسکتی ہے۔ایم آر او) کو اس ترتیب کے تعین کے لئے استعمال کیا جاسکتا ہے جس میں کلاسز 123456 کے درجہ بندی میں طریقوں کی تلاش کی جاتی ہے۔اس سے ہیرے کے مسئلے کو حل کیا جاسکتا ہے اور اس بات کو یقینی بنایا جاسکتا ہے کہ طریقوں کو صحیح ترتیب میں کہا جاتا ہے۔ تشکیل کا استعمال کرتے ہوئے: مرکب متعدد وراثت کا متبادل ہے جو کوڈ کو دوبارہ استعمال اور پولیمورفک سلوک 123456 حاصل کرنے کے لئے استعمال کیا جاسکتا ہے۔اس میں ایسی کلاسیں شامل ہیں جو دوسرے طبقوں پر مشتمل ہیں جو کلاسوں کے مابین مشترکات کو تلاش کرنے کی کوشش کرنے اور وراثت 123456 کا درجہ بندی پیدا کرنے کی بجائے مخصوص فعالیت فراہم کرتی ہیں۔متعدد وراثت 123456 کے ساتھ وابستہ۔ازگر میں ، انٹرفیس کو واضح طور پر اعلان نہیں کیا جاتا ہے ، لیکن کوئی بھی چیز جو مطلوبہ انٹرفیس کو نافذ کرتی ہے اسے کسی اور آبجیکٹ کی جگہ پر استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں انحصار انجیکشن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "انحصار انجیکشن آبجیکٹ پر مبنی پروگرامنگ میں ایک ڈیزائن کا نمونہ ہے جو اشیاء کو کسی بیرونی ماخذ کے ذریعہ فراہم کردہ ان کے انحصار کے ساتھ تخلیق کرنے کی اجازت دیتا ہے ، بجائے اس کے کہ وہ آبجیکٹ کے اندر پیدا ہوتا ہے۔انحصار انجیکشن کا ہدف یہ ہے کہ کسی کلاس کو اس کی انحصار سے آزاد بنایا جائے یا ڈھیلے ڈھیلے جوڑے ہوئے پروگرام 123456 بنانا ہے۔اس سے کوڈ کی دوبارہ استعمال کو بہتر بنانے میں مدد ملتی ہے ، جبکہ کسی کلاس کو تبدیل کرنے کی ضرورت کی تعدد ، کسی آبجیکٹ 13456 میں طریقوں یا متغیرات کا نمونہ بھی کم کرتا ہے۔انحصار انجیکشن اکثر ٹھوس سافٹ ویئر ڈیزائن اصولوں کے ساتھ کوڈ کو لائن رکھنے کے لئے استعمال کیا جاتا ہے۔ یہاں ازگر میں انحصار انجیکشن کی ایک مثال ہے: ازگرکلاس ای میل سینڈر: ڈیف بھیج_ ای میل (خود ، وصول کنندہ ، پیغام): پرنٹ (f \"{وصول کنندہ کو ای میل بھیجنا {وصول کنندہ)}: {پیغام} \") کلاس صارف: Def __init __ (خود ، نام ، ای میل_سینڈر): سیلف۔ نام = نام sellاس مثال میں ، ای میل سینڈر کلاس ایک ایسی خدمت کی نمائندگی کرتا ہے جو ای میل بھیجتا ہے ، اور صارف کلاس ایک ایسے کلائنٹ کی نمائندگی کرتا ہے جو ای میل سینڈر سروس پر منحصر ہوتا ہے۔صارف کلاس میں ایک ای میل_سینڈر وصف ہے جو ای میل سینڈر کلاس کی ایک مثال ہے۔صارف کی کلاس کے پاس ایک بھیج_ میل کا طریقہ بھی ہے جو صارف کے نام پر دیئے گئے پیغام کے ساتھ ای میل بھیجنے کے لئے ای میل_سینڈر وصف کا استعمال کرتا ہے۔صارف کی کلاس ایک انحصار کے طور پر منظور کردہ ای میل سینڈر کلاس کی ایک مثال کے ساتھ تیار کی گئی ہے ، جو صارف آبجیکٹ میں انجکشن لگائی جاتی ہے۔ اس کی ایک مثال ہے کہ انحصار انجیکشن کے ساتھ صارف کی کلاس کو کس طرح استعمال کیا جائے: پائیٹون میل_سینڈر = ای میل سینڈر () صارف = صارف (\"جان \"، ای میل_سینڈر) صارف.سینڈ_ ای میل (\" ہیلو ، ورلڈ! \") اس مثال میں ، ای میل سینڈر کلاس کی ایک مثال تیار کی گئی ہے اور صارف کلاس کی مثال بنانے کے لئے استعمال کیا گیا ہے۔اس کے بعد صارف کے آبجیکٹ کا بھیجنے والا طریقہ استعمال صارف کے نام پر ای میل بھیجنے کے لئے استعمال کیا جاتا ہے جس کے پیغام \"ہیلو ، دنیا!\"ای میل سینڈر سروس کا استعمال کرتے ہوئے۔یہ ازگر میں انحصار انجیکشن کے استعمال کو ظاہر کرتا ہے"
    },
    {
        "Question": "\"تھریڈ سے محفوظ سنگلٹن پیٹرن کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں ، اس بات کو یقینی بنائیں کہ کلاس کی صرف ایک مثال تشکیل دی جاسکے۔\"",
        "Answer": "تھریڈ سے محفوظ سنگلٹن پیٹرن کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے کے ل the ، اس بات کو یقینی بناتے ہوئے کہ کلاس کی صرف ایک مثال تشکیل دی جاسکے ، ہم اس بات کو یقینی بنانے کے لئے کسی تالے کے استعمال کے نقطہ نظر کو استعمال کرسکتے ہیں کہ صرف ایک دھاگہ کلاس 1234 کی مثال تشکیل دے سکتا ہے۔لاک کا استعمال ایک سے زیادہ دھاگوں کو بیک وقت 1234 کلاس کی متعدد مثالوں کو بنانے سے روکنے کے لئے کیا جاتا ہے۔یہاں ایک مثال عمل ہے: پائیتھونیمپورٹ تھریڈنگکلاس سنگلٹن: __instance = کوئی بھی نہیں __lock = تھریڈنگ۔ لاک () ڈیف __ new __ (CLS): اگر سی ایل ایس نہیں ہے۔ اگر سی ایل ایس نہیں ہے۔.__ نیا __ (سی ایل ایس) واپس سی ایل ایس ۔__ مثال کے طور پر ، اس پر عمل درآمد ، سنگلٹن کلاس تھریڈ سے محفوظ سنگلٹن پیٹرن کی نمائندگی کرتا ہے۔سنگلٹن کلاس کی __ انسٹینس وصف کلاس کی واحد مثال کو اسٹور کرنے کے لئے استعمال کیا جاتا ہے ، اور __ لاک وصف کو اس بات کا یقین کرنے کے لئے استعمال کیا جاتا ہے کہ صرف ایک دھاگہ کلاس کی مثال پیدا کرسکتا ہے۔سنگلٹن کلاس کا __new__ طریقہ کار کو ختم کردیا گیا ہے تاکہ یہ یقینی بنایا جاسکے کہ کلاس کی صرف ایک مثال تشکیل دی گئی ہے۔اگر __ انسٹینس وصف کوئی نہیں ہے تو ، __lock ایک ساتھ کلاس کے متعدد واقعات پیدا کرنے سے متعدد دھاگوں کو روکنے کے لئے استعمال کیا جاتا ہے۔اگر __ انسٹینس وصف ابھی بھی کوئی نہیں ہے تو ، کلاس کی ایک نئی مثال __instance انتساب میں تخلیق اور ذخیرہ کی گئی ہے۔ یہاں سنگلٹن کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: ازگر 1 = سنگلٹن () S2 = سنگلٹن () پرنٹ (S1 S1 ہے S2 ہے) # \"سچ\" پرنٹس اس مثال میں ، سنگلٹن کلاس کی دو مثالیں تشکیل دی گئیں ، اور ان کی شناخت کا موازنہ آئی ایس آپریٹر کا استعمال کرتے ہوئے کیا جاتا ہے۔چونکہ سنگلٹن کلاس ایک تھریڈ سیف سنگلٹن پیٹرن ہے ، لہذا کلاس کی صرف ایک مثال تخلیق کی گئی ہے ، اور S1 اور S2 کی شناخت ایک جیسی ہے۔یہ ازگر میں تھریڈ سیف سنگلٹن پیٹرن کے استعمال کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "ازگر میں اتلی کاپی اور گہری کاپی کے مابین پائے جانے والے اختلافات پر تبادلہ خیال کریں اور اس کی وضاحت کریں کہ ہر ایک کو استعمال کیا جانا چاہئے۔",
        "Answer": "ازگر میں ، کاپی کرنے والی اشیاء کو یا تو اتلی کاپی یا گہری کاپی 123456 کا استعمال کرتے ہوئے کیا جاسکتا ہے۔ان دونوں کے درمیان بنیادی فرق یہ ہے کہ اتلی کاپی ایک نئی شے کی تخلیق کرتی ہے اور اصل شے میں پائے جانے والے بچوں کی اشیاء کے حوالہ جات داخل کرتی ہے ، جبکہ گہری کاپی ایک نئی شے تیار کرتی ہے اور اسے اصل آبجیکٹ 123456 میں پائے جانے والے بچوں کی اشیاء کی کاپیاں کے ساتھ بار بار مقبول کرتی ہے۔اتلی کاپی اشیاء کو کاپی کرنے کا ایک تیز اور زیادہ میموری موثر طریقہ ہے ، لیکن اس سے صرف ایک نئی شے پیدا ہوتی ہے جس میں ایک سطح کی ایک سطح گہری 123456 ہے۔اس کا مطلب یہ ہے کہ اگر اصل شے میں تغیر پزیر اشیاء پر مشتمل ہے تو ، اتلی کاپی میں تغیر پزیر اشیاء میں کی جانے والی تبدیلیاں بھی اصل آبجیکٹ 123456 کو متاثر کرتی ہیں۔اتلی کاپی مفید ہے جب آپ کوئی نیا شے بنانا چاہتے ہیں جو اس کے کچھ ڈیٹا کو اصل آبجیکٹ 123456 کے ساتھ شیئر کرتا ہے۔اس کا مطلب یہ ہے کہ گہری کاپی میں تغیر پزیر اشیاء میں کی جانے والی تبدیلیاں اصل آبجیکٹ 123456 کو متاثر نہیں کریں گی۔گہری کاپی مفید ہے جب آپ کوئی نیا شے بنانا چاہتے ہیں جو اصل آبجیکٹ 123456 سے مکمل طور پر آزاد ہو۔ اس کے بعد ازگر میں اتلی کاپی اور گہری کاپی کی ایک مثال ہے: پائیٹونیمپورٹ کاپی# اتلی کاپی اوورجینل = [[1 ، 2 ، 3] ، [[[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]] shilow_copy = کاپی.کپی (اصل) shilow_copy [0] [0] = 0 پرنٹ (اصل) # پرنٹس \"[[0 ، 2 ، 3] ، [4 ، [4 ،5 ، 6] ، [7 ، 8 ، 9]] \"پرنٹ (اتلی_ کوپی) # پرنٹس\" [[[0 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]] \" # گہری کاپیورجینل= [[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]] گہری_کپی = کاپی۔ ڈپکپی (اصل) ڈیپ_کپی [0] [0] = 0 پرنٹ (اصل) # پرنٹس \"[[.7 ، 8 ، 9]]] \"اس مثال میں ، فہرستوں کی ایک فہرست اتلی کاپی اور گہری کاپی دونوں کا استعمال کرتے ہوئے بنائی گئی اور کاپی کی گئی ہے۔اتلی کاپی میں پہلی فہرست کا پہلا عنصر تبدیل کردیا گیا ہے ، اور اصل اور اتلی کاپی پرنٹ کی گئی ہے تاکہ یہ ظاہر کیا جاسکے کہ تبدیلی دونوں اشیاء کو متاثر کرتی ہے۔گہری کاپی میں پہلی فہرست کا پہلا عنصر بھی تبدیل کیا گیا ہے ، لیکن اصل اور گہری کاپی پرنٹ کی گئی ہے کہ یہ تبدیلی صرف گہری کاپی کو متاثر کرتی ہے۔"
    },
    {
        "Question": "فیکٹری کے طریقہ کار کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "فیکٹری کے طریقہ کار کا نمونہ ایک تخلیقاتی ڈیزائن کا نمونہ ہے جو ایک سپر کلاس میں اشیاء بنانے کے لئے ایک انٹرفیس مہیا کرتا ہے ، لیکن سبکلاس کو اس قسم کی اشیاء کو تبدیل کرنے کی اجازت دیتا ہے جو 123456 بنائے جائیں گے۔یہ نمونہ مفید ہے جب ایسی اشیاء بنانے کی ضرورت ہو جو مشترکہ انٹرفیس کا اشتراک کریں ، لیکن تخلیق کرنے والی مخصوص قسم کی چیز کا تعین رن ٹائم 123456 پر کیا جاتا ہے۔فیکٹری کے طریقہ کار کو سپر کلاس میں فیکٹری کے طریقہ کار کی وضاحت کرکے نافذ کیا جاتا ہے جو پیرامیٹر یا کنفیگریشن 123456 کے ذریعہ طے شدہ قسم کے کسی شے کو واپس کرتا ہے۔اس کے بعد فیکٹری کے طریقہ کار کو ذیلی طبقات میں زیربحث لایا جاتا ہے تاکہ ذیلی کلاس 123456 کے ذریعہ مطلوبہ مخصوص قسم کی اشیاء پیدا کی جاسکیں۔ یہاں ازگر میں فیکٹری کے طریقہ کار کے نمونے کا ایک مثال ہے: ازگرکلاس جانور: ڈیف اسپیک (خود): پاسکلاس ڈاگ (جانور)بولیں (خود): واپس \"ووف!\" کلاس بلی (جانور): ڈیف اسپیک (خود): واپس \"میانو!ایلف اینیمل_ ٹائپ == \"بلی\": ریٹرن بلی () اور: ویلیئر ایرر (\"غلط جانوروں کی قسم\") فیکٹری = جانوروں کی فیکٹری () کتا = فیکٹری۔ کریٹ_انیمل (\"کتا\") بلی = فیکٹری۔dog.speak ()) # پرنٹ \"WOOF!\" پرنٹ (بلی.س اسپیک ()) # پرنٹ \"میو!\" اس مثال میں ، جانوروں کی کلاس ایک ایسی سپر کلاس کی نمائندگی کرتی ہے جو جانوروں کو بنانے کے لئے ایک مشترکہ انٹرفیس کی وضاحت کرتی ہے۔کتے اور بلی کی کلاسیں ذیلی طبقات کی نمائندگی کرتی ہیں جو بالترتیب کتوں اور بلیوں کو بنانے کے لئے جانوروں کی کلاس کے بولنے کے طریقہ کار کو زیر کرتی ہیں۔جانوروں کی فیکٹری کلاس ایک ایسی فیکٹری کی نمائندگی کرتی ہے جو پیرامیٹر یا ترتیب پر مبنی جانوروں کو تخلیق کرتی ہے۔جانوروں کی فیکٹری کلاس کا تخلیق_انیمل طریقہ ایک جانوروں کی قسم کا پیرامیٹر لیتا ہے اور پیرامیٹر کے ذریعہ مخصوص قسم کا ایک شے لوٹاتا ہے۔تخلیق_انیمل طریقہ بالترتیب کتوں اور بلیوں کو بنانے کے لئے جانوروں کی فیکٹری کلاس کے ذیلی طبقات میں زیر اثر ہے۔اس کے بعد جانوروں کی فیکٹری کلاس کو کتا اور بلی بنانے کے لئے استعمال کیا جاتا ہے ، اور ان کے بولنے کے طریقوں کو ازگر میں فیکٹری کے طریقہ کار کے استعمال کو ظاہر کرنے کے لئے کہا جاتا ہے۔"
    },
    {
        "Question": "\"سرکلر سے منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور اندراج ، حذف کرنے اور ٹریورسل کے طریقے فراہم کریں۔\"",
        "Answer": "ایک سرکلر منسلک فہرست ایک قسم کی منسلک فہرست ہے جس میں پہلے اور آخری نوڈس ایک دوسرے سے منسلک ہوتے ہیں تاکہ سرکل 123456 تشکیل دیا جاسکے۔سرکلر سے منسلک فہرستوں کی دو اقسام ہیں: سرکلر اکیلے لنکڈ لسٹ اور سرکلر دوگنا منسلک فہرست 123456۔ایک سرکلر واحد منسلک فہرست میں ، فہرست کے آخری نوڈ میں لسٹ 123456 کے پہلے نوڈ کا پوائنٹر ہوتا ہے۔ایک سرکلر دوگنا منسلک فہرست میں ، دو لگاتار دو عناصر پچھلے اور اگلے پوائنٹر کے ذریعہ منسلک یا منسلک ہوتے ہیں ، اور آخری نوڈ اگلے پوائنٹر کے ذریعہ پہلے نوڈ کی طرف اشارہ کرتے ہیں ، اور پہلا نوڈ آخری نوڈ کی طرف اشارہ کرتے ہیں جو پچھلے پوائنٹر 123456 کے ذریعہ ہوتا ہے۔ازگر میں ایک سرکلر واحد منسلک فہرست کا ایک مثال ہے: ازگر کلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ = نونیکلاس سرکلر لنکڈ لسٹ: ڈیف __init __ (خود)خود ، اعداد و شمار): نیا_نوڈ = نوڈ (ڈیٹا) اگر سیلف۔ ہیڈ کوئی نہیں ہے: سیلف۔ہیڈ = نیا_نوڈ نیا_نوڈ. نیکسٹ = سیل۔ ہیڈ اور: موجودہ = سیلف ہیڈ جبکہ موجودہ۔.next موجودہ۔ نیکسٹ = new_node new_node.next = self.head def ڈیلیٹ (خود ، ڈیٹا): اگر سیلف ہیڈ کوئی نہیں ہے: واپس الیف سیلف ہیڈ ڈاٹ ڈیٹا == ڈیٹا: موجودہ = سیلف۔= self.head: موجودہ = موجودہ۔ نیکسٹ کرنٹ۔ نیکسٹ = سیلف ہیڈ.نیکسٹ سیلف۔ ہیڈ = سیل۔ ہیڈ. نیکسٹ۔موجودہ موجودہ = موجودہ۔ نیکسٹ اگر موجودہ۔ ڈیٹا == اعداد و شمار: prev.next = موجودہ۔ نیکسٹ موجودہ = کرنٹ۔ نیکسٹ ڈیف ٹراورس (خود): اگر سیلف۔ ہیڈ کوئی نہیں ہے: واپسی کرنٹ = سیلف ہیڈ پرنٹ (کرنٹ ڈاٹ ڈیٹا، اختتام = \"\") جبکہ موجودہ۔ نیکسٹ! = سیلف ہیڈ: کرنٹ = کرنٹ۔ نیکسٹ پرنٹ (کرنٹ.ڈیٹا ، اینڈ = \"\") پرنٹ () اس نفاذ میں ، نوڈ کلاس سرکلر لنکڈ فہرست میں نوڈ کی نمائندگی کرتا ہے۔، اور سرکلر لنکڈ لسٹ کلاس سرکلر منسلک فہرست کی نمائندگی کرتی ہے۔سرکلر لنکڈ لسٹ کلاس کا داخل کرنے کا طریقہ سرکلر منسلک فہرست میں ایک نیا نوڈ داخل کرنے کے لئے استعمال ہوتا ہے۔اگر فہرست کا سربراہ کوئی نہیں ہے تو ، نیا نوڈ سر بن جاتا ہے ، اور اس کی اگلی وصف خود ہی سیٹ ہے۔بصورت دیگر ، فہرست کے آخر میں نیا نوڈ داخل کیا جاتا ہے ، اور اس کی اگلی وصف سر پر سیٹ ہے۔سرکلر لنکڈ لسٹ کلاس کا حذف کرنے کا طریقہ سرکلر لنکڈ فہرست سے نوڈ کو حذف کرنے کے لئے استعمال کیا جاتا ہے۔اگر فہرست کا سربراہ نوڈ کو حذف کرنے کا ہے تو ، سر کو اگلے نوڈ میں اپ ڈیٹ کردیا جاتا ہے ، اور آخری نوڈ کی اگلی وصف نئے سر پر سیٹ ہے۔بصورت دیگر ، نوڈ کو موجودہ نوڈ کی اگلی وصف کو موجودہ نوڈ کے اگلے وصف میں اپ ڈیٹ کرکے حذف کردیا گیا ہے۔سرکلر لنکڈ لسٹ کلاس کا عبور طریقہ سرکلر منسلک فہرست کو عبور کرنے اور اس کے مندرجات کو پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔ اس کی ایک مثال ہے کہ سرکلر لنکڈ لسٹ کلاس کو کس طرح استعمال کیا جائے: پائیتھونکلسٹ = سرکلر لنک لسٹ () کلسٹ.نسرٹ (1) Clist.insert (2) Clist.INSERT (3) clist.insert (4) Clist.travers () # پرنٹس \"1 2 3 4\" Clist.delete (3) Clist.travers () # پرنٹس \"1 2 4\" اس مثال میں ، ایک سرکلر سے منسلک فہرستسرکلر لنکڈ لسٹ کلاس کا استعمال کرتے ہوئے تخلیق کیا گیا ہے ، اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے چار نوڈس فہرست میں داخل کردیئے گئے ہیں۔اس کے بعد فہرست کے مندرجات کو عبور کرنے کے طریقہ کار کا استعمال کرتے ہوئے پرنٹ کیا جاتا ہے۔اس کے بعد ڈیٹا ویلیو 3 کے ساتھ نوڈ کو حذف کرنے کے طریقہ کار کا استعمال کرتے ہوئے فہرست سے حذف کردیا جاتا ہے ، اور فہرست کے مندرجات کو ٹراورس طریقہ کا استعمال کرتے ہوئے ایک بار پھر پرنٹ کیا جاتا ہے۔"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں آبزرور پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "آبزرور پیٹرن سافٹ ویئر انجینئرنگ میں ایک ڈیزائن کا نمونہ ہے جو اشیاء کے مابین ایک سے زیادہ انحصار کی وضاحت کرتا ہے ، جہاں ایک شے (مضمون) میں تبدیلی خود بخود دیگر تمام اشیاء (مبصرین) کو مطلع اور اپ ڈیٹ کرتی ہے جو آئی ٹی 123456 پر منحصر ہے۔آبزرور پیٹرن ایک طرز عمل کا نمونہ ہے جو لچکدار اور دوبارہ قابل استعمال آبجیکٹ پر مبنی سافٹ ویئر کو ڈیزائن کرنے کے لئے استعمال ہوتا ہے ، جس سے ایسی اشیاء ملتی ہیں جن پر عمل درآمد ، تبدیلی ، جانچ اور دوبارہ استعمال کرنے میں آسانی ہوتی ہے۔مبصرین کا نمونہ ان حالات میں مفید ہے جہاں کسی شے کو انحصار کرنے والی اشیاء کیا ہیں یا جب کسی شے میں تبدیلی کو دوسروں کو تبدیل کرنے کی ضرورت ہوتی ہے اس کے بارے میں قیاس آرائیاں کرنے کے بغیر کسی شے کو دیگر اشیاء کو مطلع کرنے کے قابل ہونا چاہئے ، اور آپ نہیں جانتے کہ کتنی اشیاء کو تبدیل کرنے کی ضرورت ہے۔.یہ ازگر میں آبزرور پیٹرن کا ایک مثال عمل ہے: ازگرکلاس مضمون: Def __init __ (خود): self.observers = [] Def register_observer (سیلف ، آبزرور): self.observers.append (مبصرین) Def hemt_observer (خود ، مبصر): sell.observers.remove (مبصرین) DEF نوٹیفائی_بسورز (خود ، ڈیٹا = کوئی بھی نہیں): خود میں مشاہدہ کرنے والے کے لئے: آبزرور. اپ ڈیٹ (ڈیٹا) کلاس آبزرور: ڈی ای ایف اپ ڈیٹ (خود ، ڈیٹا): پاس کلاس کنکریٹو سرور (آبزرور):ڈیف اپ ڈیٹ (خود ، ڈیٹا): پرنٹ (ایف \"موصولہ ڈیٹا: {ڈیٹا}\") موضوع = مضمون () مشاہدہ کرنے والا = کنکریٹو ایورور () سبجیکٹ.ریگسٹر_بسرور (مبصر) سبجیکٹ۔ notify_observers (\"ہیلو ، ورلڈ!\") اس عمل میں اس عمل میں، سبجیکٹ کلاس اس مضمون کی نمائندگی کرتا ہے جو مبصرین کی فہرست کو برقرار رکھتا ہے اور انہیں کسی بھی ریاست کی تبدیلیوں سے آگاہ کرتا ہے۔آبزرور کلاس مبصر کی نمائندگی کرتا ہے جسے ریاستی تبدیلیوں کے بارے میں مطلع کیا جاتا ہے۔کنکریٹو بشر کلاس مبصر کے ٹھوس نفاذ کی نمائندگی کرتا ہے جو موصولہ ڈیٹا کو پرنٹ کرتا ہے۔مضمون کلاس کا رجسٹر_بسرور طریقہ اس مضمون کے ساتھ مبصرین کو رجسٹر کرنے کے لئے استعمال ہوتا ہے۔مضمون سے ہٹانے والے کا طریقہ استعمال کیا جاتا ہے اس مضمون سے کسی مبصر کو دور کرنے کے لئے استعمال کیا جاتا ہے۔مضمون کی کلاس کے نوٹیفائی_بسورز کا طریقہ کسی بھی ریاست کی تبدیلیوں کے تمام مبصرین کو مطلع کرنے کے لئے استعمال کیا جاتا ہے۔موصولہ ڈیٹا کو پرنٹ کرنے کے لئے کنکریٹو بشر کلاس میں آبزرور کلاس کا اپ ڈیٹ طریقہ کار کو ختم کردیا گیا ہے۔اس کے بعد سبجیکٹ کلاس کا استعمال مبصرین کو رجسٹر کرنے ، ریاست کی تبدیلی کے مبصر کو مطلع کرنے ، اور موصولہ اعداد و شمار پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔ یہاں ایک مثال ہے کہ ازگر میں آبزرور پیٹرن کو کس طرح استعمال کیا جائے: پائیتھنسوبیکجیکٹ = مضمون () آبزرور 1 = کنکریٹو سروور () آبزرورور 2= ConcreteObServer () subject.register_observer (آبزرور 1) سبجیکٹ۔ ریگسٹر_بسرور (آبزرورور 2) سبجیکٹ۔ notify_observers (\"ہیلو ، ورلڈ!\") سبجیکٹ۔ ریمو_بسروور (آبزرور 2) اس مثال میں (\"گوڈی ، ورلڈ!\")سبجیکٹ کلاس کا استعمال کرتے ہوئے تخلیق کیا گیا ہے ، اور دو مبصرین رجسٹر_بسرور طریقہ کا استعمال کرتے ہوئے اس مضمون کے ساتھ رجسٹرڈ ہیں۔اس کے بعد اس موضوع کا استعمال نوٹیفائی_بروزر کے طریقہ کار کا استعمال کرتے ہوئے کسی ریاست کی تبدیلی کے تمام مبصرین کو مطلع کرنے کے لئے کیا جاتا ہے ، اور موصولہ ڈیٹا دونوں مبصرین کے ذریعہ پرنٹ کیا جاتا ہے۔اس کے بعد مبصرین میں سے ایک کو ہٹانے_بسرور کے طریقہ کار کا استعمال کرتے ہوئے اس موضوع سے ہٹا دیا جاتا ہے ، اور اس موضوع کو نوٹیفائی_بروزر کے طریقہ کار کا استعمال کرتے ہوئے کسی اور ریاست کی تبدیلی کے باقی مبصرین کو مطلع کرنے کے لئے استعمال کیا جاتا ہے ، اور موصولہ اعداد و شمار باقی مبصرین کے ذریعہ چھاپے جاتے ہیں۔"
    },
    {
        "Question": "ازگر میں انٹرفیس کے مقابلے میں خلاصہ کلاس استعمال کرنے کے فوائد اور خرابیوں پر تبادلہ خیال کریں۔",
        "Answer": "ازگر میں تجریدی کلاس کے استعمال کے فوائد: ایک تجریدی کلاس متعلقہ کلاسوں کے ایک گروپ کے لئے ایک مشترکہ انٹرفیس مہیا کرسکتی ہے ، جس سے کوڈ 12345 کا انتظام اور برقرار رکھنا آسان ہوجاتا ہے۔ تجریدی کلاس اس کے ذیلی طبقات کے لئے پہلے سے طے شدہ طرز عمل کی وضاحت کرسکتی ہے ، کوڈ کی نقل کو کم کرسکتی ہے اور بہتر ہوسکتی ہے۔کوڈ دوبارہ استعمال 12345. ایک تجریدی کلاس اپنے ذیلی طبقات پر کچھ قواعد اور رکاوٹوں کو نافذ کرسکتی ہے ، اس بات کو یقینی بناتی ہے کہ وہ کسی خاص ڈیزائن یا آرکیٹیکچر 12345 پر عمل پیرا ہوں۔حالات 12345. ایک تجریدی کلاس کسی انٹرفیس کے مقابلے میں زیادہ پیچیدہ اور سمجھنا مشکل ہوسکتا ہے ، خاص طور پر اگر اس میں بہت سے طریقے اور اوصاف 12345 ہیں۔ تجریدی کلاس کلاسوں کے مابین سخت جوڑے پیدا کرسکتی ہے ، جو کوڈ کو کم لچکدار اور مشکل بنا سکتی ہے۔ازگر میں ایک انٹرفیس کا استعمال: ایک انٹرفیس ان طریقوں اور اوصاف کی ایک واضح اور جامع تعریف فراہم کرسکتا ہے جس پر کسی طبقے کو نافذ کرنا چاہئے ، جس سے کوڈ 145 کو سمجھنے اور استعمال کرنا آسان ہوجاتا ہے۔ ایک انٹرفیس کسی بھی طبقے کے ذریعہ نافذ کیا جاسکتا ہے ، قطع نظر اس کے وراثت کے درجہ بندی سے قطع نظر۔، اسے خلاصہ کلاس 145 کے مقابلے میں زیادہ لچکدار اور موافقت پذیر بنانا۔ ایک انٹرفیس کلاسوں کے مابین کسی خاص طرز عمل یا معاہدے کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے ، اس بات کو یقینی بناتے ہوئے کہ وہ کسی خاص ڈیزائن یا آرکیٹیکچر 145 پر عمل پیرا ہوں۔اس کے طریقوں کے لئے کوئی بھی ڈیفالٹ سلوک یا عمل درآمد ، جو کوڈ کی نقل اور کم کوڈ ریوس 145 کا باعث بن سکتا ہے۔ ایک انٹرفیس ایک تجریدی کلاس سے کم اظہار ہوسکتا ہے ، خاص طور پر اگر یہ صرف کچھ طریقوں اور اوصاف کی وضاحت کرتا ہے ۔145. ایک انٹرفیس کلاسوں کے مابین سخت جوڑے پیدا کرسکتا ہے، جو کوڈ کو کم لچکدار اور ترمیم کرنے کے لئے مشکل بنا سکتا ہے۔اگر متعلقہ طبقات کے کسی گروپ کے لئے مشترکہ انٹرفیس فراہم کرنے یا ذیلی طبقات پر کچھ قواعد اور رکاوٹوں کو نافذ کرنے کی ضرورت ہے تو ، ایک تجریدی طبقہ زیادہ مناسب ہوسکتا ہے۔اگر ان طریقوں اور اوصاف کی واضح اور جامع تعریف فراہم کرنے کی ضرورت ہے جس پر کسی کلاس کو نافذ کرنا چاہئے یا اس بات کو یقینی بنانا ہے کہ کلاسز کسی خاص ڈیزائن یا فن تعمیر پر عمل پیرا ہوں تو ، ایک انٹرفیس زیادہ مناسب ہوسکتا ہے۔"
    },
    {
        "Question": "\"ایک کم سے کم عمر طبقے کو نافذ کریں جو ایک کم سے کم HEAP کا استعمال کرتے ہوئے ترجیحی قطار کی نمائندگی کرتے ہیں اور اعلی ترجیحی عنصر کی اندراج ، حذف کرنے اور بازیافت کے طریقے فراہم کرتے ہیں۔\"",
        "Answer": "کم سے کم HEAP کا استعمال کرتے ہوئے ترجیحی قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم Python1234 میں ہیپ کیو ماڈیول کا استعمال کرسکتے ہیں۔ہیپ کیو ماڈیول ہیپ ڈیٹا ڈھانچے کو بنانے اور جوڑنے کے ل functions افعال مہیا کرتا ہے ، جو ترجیحی قطار کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے۔ایک منٹ میں ، سب سے چھوٹا عنصر ہمیشہ سب سے اوپر ہوتا ہے ، اور کسی عنصر کی ترجیح کا تعین اس کی قیمت 12354 کے ذریعہ کیا جاتا ہے۔ اس کی مثال ہے کہ ازگر میں ایک کم سے کم کا استعمال کرتے ہوئے ترجیحی قطار کا ایک مثال عمل ہے: پائیٹونیمپورٹ ہیپقکلاس کی ترجیحی کیو: ڈیف __init__(خود): self.elements = [] Def is_empty (خود): ریٹرن لین (سیلف ایلیمنٹس) == 0 ڈیف داخل کریں (خود ، آئٹم ، ترجیح): ہیپ کیو.ہپش (سیلف.ایلیمنٹس ، (ترجیح ، آئٹم))ڈیف ڈیلیٹ (خود): ریٹرن ہیپ کیو۔ ہیپپپ (سیلف ایلیمنٹس) [1] ڈیف جھانکنے (خود): خود کو لوٹائیں۔ترجیحی کلاس کا __init__ طریقہ ڈھیر کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔ترجیحی طبقے کی کلاس کا IS_EMPTY طریقہ یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا ڈھیر خالی ہے یا نہیں۔ترجیحی طبقے کی داخلہ کا طریقہ استعمال کسی دیئے گئے ترجیح کے ساتھ ڈھیر میں کسی شے کو داخل کرنے کے لئے استعمال کیا جاتا ہے۔ترجیحی کوکیو کلاس کے حذف کرنے کا طریقہ استعمال شدہ کو ڈھیر سے اعلی ترجیح کے ساتھ حذف کرنے کے لئے استعمال کیا جاتا ہے۔ترجیحی کیو کلاس کا جھانکنے والا طریقہ استعمال کیے بغیر ہیپ سے اعلی ترجیح کے ساتھ اس شے کو بازیافت کرنے کے لئے استعمال کیا جاتا ہے۔ یہاں ترجیحی کیو کلاس کو کس طرح استعمال کیا جائے: پائیٹونپق = ترجیحی کیوئو () پی کیو Insert (\"ٹاسک 1\" ،3) PQ.INSERT (\"ٹاسک 2\" ، 1) PQ.INSERT (\"ٹاسک 3\" ، 2) پرنٹ (PQ.Peek ()) # پرنٹس \"ٹاسک 2\" پرنٹ (PQ.Delete ()) # پرنٹس \"ٹاسک\" ٹاسک2 \"پرنٹ (pq.peek ()) # پرنٹس\" ٹاسک 3 \"اس مثال میں ، ترجیحی قطار کو ترجیحی کیو کلاس کا استعمال کرتے ہوئے تشکیل دیا جاتا ہے ، اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے مختلف ترجیحات کے ساتھ تین کاموں کو قطار میں داخل کیا جاتا ہے۔اعلی ترجیح والی شے کو PEEK کے طریقہ کار کا استعمال کرتے ہوئے قطار سے بازیافت کیا جاتا ہے ، اور اعلی ترجیح والی شے کو حذف کرنے کے طریقہ کار کا استعمال کرتے ہوئے قطار سے حذف کردیا جاتا ہے۔نئی اعلی ترجیح والی شے کو جھانکنے کے طریقہ کار کا استعمال کرتے ہوئے قطار سے بازیافت کیا جاتا ہے۔اس سے ازگر میں ایک کم سے کم ہیپ کا استعمال کرتے ہوئے ترجیحی قطار کے استعمال کا مظاہرہ ہوتا ہے۔"
    },
    {
        "Question": "ازگر میں ڈیکوریٹر پیٹرن کے تصور کی وضاحت کریں اور اس کے استعمال کو ظاہر کرنے والی ایک مثال پیش کریں۔",
        "Answer": "ڈیکوریٹر پیٹرن ازگر میں ایک ڈیزائن کا نمونہ ہے جو ایک ہی کلاس 12345 سے دیگر اشیاء کے طرز عمل کو متاثر کیے بغیر ، متحرک طور پر کسی فرد کی شے میں سلوک کو شامل کرنے کی اجازت دیتا ہے۔ڈیکوریٹر پیٹرن ایک ساختی نمونہ ہے جو کسی شے کی فعالیت کو اس کے نفاذ 12345 کو تبدیل کیے بغیر بڑھانے کے لئے استعمال ہوتا ہے۔ڈیکوریٹر کا نمونہ مفید ہے جب رن ٹائم کے وقت کسی شے میں نئی فعالیت شامل کرنے کی ضرورت ہو ، اس کے موجودہ طرز عمل میں ترمیم کیے بغیر 12345۔ ڈیکوریٹر پیٹرن کو ایک ایسا ڈیکوریٹر کلاس تشکیل دے کر نافذ کیا جاتا ہے جو اصل شے کو لپیٹتا ہے اور آئی ٹی 12345 میں نئی فعالیت کو شامل کرتا ہے۔ڈیکوریٹر کلاس میں اصل شے کی طرح انٹرفیس ہوتا ہے ، لہذا اسے اسی طرح استعمال کیا جاسکتا ہے جیسے اصل آبجیکٹ 12345۔ڈیکوریٹر کلاس میں اصل شے کا حوالہ بھی ہوتا ہے ، لہذا یہ کسی بھی غیر ترمیم شدہ طرز عمل کو اصل آبجیکٹ 12345 پر دے سکتا ہے۔ اس کی مثال ازگر میں ڈیکوریٹر پیٹرن کی ایک مثال ہے: پائیتھنکلاس جزو: ڈیف آپریشن (خود): پاس کلاس کنکریٹیکومپرینٹ (اجزاء): DEF آپریشن (خود): واپس \"CONCRETECOMPOINTOR\" کلاس ڈیکوریٹر (جزو): DEF __INIT __ (خود ، اجزاء): سیلف۔ڈیف آپریشن (): واپسی f \"concretedecoratora ({self._compointe.operation ()})\" کلاس کنکریٹڈیکورٹرب (ڈیکوریٹر): ڈیف آپریشن (خود): ریٹرن f \"Concretedecoratorb ({self.component.operation ()})\"اجزاء = کنکریٹیکومیپینٹ () سجاوٹ_ا = کنکریٹڈیکوریٹرا (جزو) سجاوٹ_ب = کنکریٹڈیکورٹر بی (ڈیکوریٹر_ا) پرنٹ (ڈیکوریٹر_ب.ایپریشن ()) # پرنٹس \"اصل تصورات (کنکریٹیکورٹوریٹا) (اجزاء کی حیثیت سے)\"سجا ہواکنکریٹکمپینٹ کلاس اصل شے کے ٹھوس نفاذ کی نمائندگی کرتا ہے۔ڈیکوریٹر کلاس ڈیکوریٹر کی نمائندگی کرتا ہے جو اصل شے کو لپیٹتا ہے اور اس میں نئی فعالیت شامل کرتا ہے۔کنکریٹڈیکوریٹرا اور کنکریٹڈیکورٹر بی کلاس سجاوٹ کے ٹھوس نفاذ کی نمائندگی کرتے ہیں جو اصل شے میں نئی فعالیت کو شامل کرتے ہیں۔کنکریٹ کے جزو کا نام واپس کرنے کے لئے جزو کلاس کے آپریشن کا طریقہ کار کنکریٹکمپینٹ کلاس میں اوورڈ کیا گیا ہے۔ڈیکوریٹر کلاس کے آپریشن کا طریقہ کار کو اصل شے کے ساتھ تفویض کرنے کے لئے اوورڈ کیا گیا ہے۔اصل شے میں نئی فعالیت کو شامل کرنے کے لئے کنکریٹڈیکورٹرا اور کنکریٹڈیکورٹر بی کلاسوں کے آپریشن کا طریقہ کار کو ختم کردیا گیا ہے۔اس کے بعد کانٹریٹکمپینٹ آبجیکٹ کو دو سجاوٹوں سے سجایا گیا ہے ، اور بیرونی سجاوٹ کے آپریشن کے طریقہ کار کو پائیتھن میں ڈیکوریٹر پیٹرن کے استعمال کو ظاہر کرنے کے لئے کہا جاتا ہے۔"
    },
    {
        "Question": "ازگر میں فنکشن اوورلوڈنگ کے تصور کی وضاحت کریں اور اس پر تبادلہ خیال کریں کہ یہ کس طرح دیگر پروگرامنگ زبانوں سے مختلف ہے۔",
        "Answer": "فنکشن اوورلوڈنگ ایک پروگرامنگ تصور ہے جس میں متعدد افعال میں ایک ہی نام ہوسکتا ہے لیکن مختلف پیرامیٹرز 1234۔فنکشن اوورلوڈنگ کا استعمال کسی فنکشن کے مختلف نفاذ فراہم کرنے کے لئے کیا جاتا ہے جس کی بنیاد یا IT1234 کو دیئے گئے پیرامیٹرز کی قسم یا قسم کی بنیاد پر ہے۔تاہم ، ازگر میں فنکشن اوورلوڈنگ کی تائید نہیں کی جاتی ہے کیونکہ ازگر کے پاس طریقہ کار پیرامیٹرز 1234 کے لئے ڈیٹا کی قسم نہیں ہوتی ہے۔ڈیکوریٹر پیٹرن ایک ہی کلاس 56 سے دیگر اشیاء کے طرز عمل کو متاثر کیے بغیر ، متحرک طور پر کسی فرد کی شے میں سلوک کو شامل کرنے کی اجازت دیتا ہے۔سجاوٹ کا نمونہ کسی شے کی نفاذ کو تبدیل کیے بغیر بڑھانے کے لئے استعمال کیا جاتا ہے۔ یہاں ازگر میں ڈیکوریٹر پیٹرن کی ایک مثال ہے: پائیتھنڈف اوورلوڈ (ایف این): ڈیف ریپر (*آرگس): اگر لین (آرگس) == 1: ریٹرن ایف این (آرگس [0]) ایلف لین (آرگس) == 2: ریٹرن ایف این (آرگس [0] ، آرگس [1]) دوسری: ویلیو ایرر کو بڑھاؤ (\"دلائل کی غلط تعداد\") ریٹرن ریپر@اوورلوڈ ڈیف ایریا (لمبائی (لمبائی)، چوڑائی): واپسی کی لمبائی * چوڑائی@اوورلوڈ ڈیف ایریا (رداس): واپسی 3.14 * رداس * رداس پرنٹ (ایریا (2)) # پرنٹس \"12.56\" پرنٹ (ایریا (2 ، 3)) # پرنٹس \"6\" اس عمل میں ، اس عمل میں ،اوورلوڈ فنکشن ایریا فنکشن کو اوورلوڈ کرنے کے لئے سجاوٹ کے طور پر استعمال ہوتا ہے۔اوورلوڈ فنکشن ایک دلیل کے طور پر ایک فنکشن لیتا ہے اور ایک نیا فنکشن لوٹاتا ہے جو اس کو دیئے گئے دلائل کی تعداد کی جانچ پڑتال کرتا ہے اور اصل فنکشن کے مناسب نفاذ کو کہتے ہیں۔@اوور لوڈ ڈیکوریٹر کو اوورلوڈ فنکشن کو علاقے کے فنکشن میں لاگو کرنے کے لئے استعمال کیا جاتا ہے۔اس کے بعد اس علاقے کے فنکشن کو دو نفاذ کے ساتھ اوورلوڈ کیا جاتا ہے: ایک جو دو دلائل لیتا ہے جس میں مستطیل کی لمبائی اور وسعت کی نمائندگی ہوتی ہے اور اس علاقے کو لوٹاتا ہے ، اور دوسرا جو دائرے کا عددی رداس لیتا ہے اور اس علاقے کو واپس کرتا ہے۔اس کے بعد ایریا فنکشن کو مختلف دلائل کے ساتھ بلایا جاتا ہے تاکہ ازگر میں ڈیکوریٹر پیٹرن کا استعمال کرتے ہوئے فنکشن اوورلوڈنگ کے استعمال کا مظاہرہ کیا جاسکے۔"
    },
    {
        "Question": "ہدایت شدہ وزن والے گراف کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور ڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کریں۔",
        "Answer": "ہدایت والے وزن والے گراف کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور ڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کرنے کے ل we ، ہم پیتھون 123456 میں ہیپ کیو ماڈیول کا استعمال کرسکتے ہیں۔ڈجکسٹرا کا الگورتھم ایک مقبول الگورتھم ہے جو گراف 56 میں دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتا ہے۔الگورتھم وزٹ شدہ نوڈس کا ایک سیٹ اور غیر منحصر نوڈس کا ایک سیٹ برقرار رکھنے اور ماخذ نوڈ سے ہر غیر منحصر نوڈ 56 تک کم سے کم فاصلہ طے کرکے کام کرتا ہے۔اس کے بعد الگورتھم کم سے کم فاصلے کے ساتھ غیر منحصر نوڈ کا انتخاب کرتا ہے اور اسے وزٹ شدہ سیٹ میں شامل کرتا ہے۔اس کے بعد الگورتھم نئے دورے والے نوڈ کے پڑوسی نوڈس کے فاصلے کو اپ ڈیٹ کرتا ہے ، اگر نیا فاصلہ موجودہ فاصلے 56 سے کم ہے۔اس عمل کو اس وقت تک دہرایا جاتا ہے جب تک کہ منزل کا نوڈ پہنچ نہ جائے یا تمام نوڈس کا دورہ کیا جائے۔ یہاں تک کہ ازگر میں ہدایت شدہ وزن والے گراف اور ڈجکسٹرا کے الگورتھم کا ایک مثال عمل ہے: پائیٹونیمپورٹ ہیپق کلاس گراف: ڈیف __init __ (خود): سیلف. نوڈس = سیٹ ()self.edges = {} def add_node (خود ، قدر): self.nodes.add (ویلیو) سیلف. ای ڈی جی ایس [ویلیو] = {} ڈیف ایڈ_ج (سیلف ، سے_نوڈ ، ٹو_نوڈ ، وزن): سیلف ڈاٹ ایڈجز [منجانب_نوڈ] [to_node] = وزن Def DijkStra (خود ، start_node): فاصلوں = {نوڈ: فلوٹ ('inf') نوڈ کے لئے نوڈ کے لئے۔ نوڈس} فاصلوں [اسٹارٹ_نوڈ] = 0 قطار = [(0 ، اسٹارٹ_نوڈ)] قطار کے دوران: موجودہ_ڈیسٹنس ،موجودہ_نوڈ = ہیپ کیو.اپپپ (قطار) اگر موجودہ_ڈسٹنس> فاصلوں [موجودہ_نوڈ]: پڑوسی کے لئے جاری رکھیں ، خود میں وزن [موجودہ_نوڈ]= فاصلہ ہیپ کیو۔ ہیپش (قطار ، (فاصلہ ، پڑوسی)) ریٹرن ڈسٹنسن اس نفاذ ، گراف کلاس ہدایت شدہ وزن والے گراف کی نمائندگی کرتا ہے۔گراف کلاس کا ADD_NODE طریقہ گراف میں نوڈ شامل کرنے کے لئے استعمال ہوتا ہے۔گراف کلاس کا ADD_EDGE طریقہ استعمال شدہ وزن کے ساتھ دو نوڈس کے درمیان ایک کنارے شامل کرنے کے لئے استعمال ہوتا ہے۔گراف کلاس کا ڈجکسٹرا طریقہ استعمال کیا جاتا ہے تاکہ دیئے گئے اسٹارٹ نوڈ سے ڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے گراف میں موجود دیگر تمام نوڈس تک مختصر ترین راستہ تلاش کیا جاسکے۔ڈجکسٹرا کا طریقہ گراف میں شروع ہونے والے نوڈ سے لے کر ہر نوڈ تک فاصلوں کی لغت کو برقرار رکھتا ہے۔ڈجکسٹرا کا طریقہ نوڈس کی ترجیحی قطار کو بھی دیکھنے کے لئے برقرار رکھتا ہے ، جس کو اسٹارٹ نوڈ سے ان کے فاصلے سے ترتیب دیا جاتا ہے۔ڈجکسٹرا کا طریقہ پھر تکراری طور پر ترجیحی قطار سے کم سے کم فاصلے کے ساتھ نوڈ کا انتخاب کرتا ہے اور اس کے ہمسایہ نوڈس کے فاصلے کو اپ ڈیٹ کرتا ہے اگر موجودہ فاصلے سے نیا فاصلہ چھوٹا ہو۔ اس کی ایک مثال ہے کہ گراف کلاس اور ڈجکسٹرا کے الگورتھم کو کس طرح استعمال کیا جائے۔پائیتھنوگراف = گراف () گراف.اڈ_نوڈ (\"اے\") گراف.اڈ_نوڈ (\"بی\") گراف.اڈی_نوڈ (\"سی\") گراف.اڈی_نوڈ (\"ڈی\") گراف.اڈی_ج (\"اے\" ، \"بی\" ، 1) گراف.اڈی_ج (\"بی\" ، \"سی\" ، 2) گراف.اڈی_ج (\"سی\" ، \"ڈی\" ، 3) گراف۔ ایڈ_ج (\"اے\" ، \"ڈی\" ، 10) فاصلوں = گراف.ڈیجکسٹرا (\"a \") پرنٹ (فاصلے) # پرنٹس\" {'a': 0 ، 'b': 1 ، 'C': 3 ، 'D': 6} \"اس مثال میں ، گراف کلاس کا استعمال کرتے ہوئے ایک ہدایت والا وزن والا گراف تشکیل دیا گیا ہے۔، اور ADD_NODE طریقہ کا استعمال کرتے ہوئے گراف میں چار نوڈس شامل کیے جاتے ہیں۔اس کے بعد چار کناروں کو ADD_EDGE کے طریقہ کار کا استعمال کرتے ہوئے گراف میں شامل کیا جاتا ہے ، جس کا وزن 1 ، 2 ، 3 ، اور 10 ہے۔ گراف میں موجود دیگر تمام نوڈس میں اسٹارٹ نوڈ \"A\" سے مختصر ترین راستہ اس کے بعد ڈجکسٹرا کے طریقہ کار کا استعمال کرتے ہوئے حساب کیا جاتا ہے ،اور فاصلوں کو ازگر میں ڈیجکسٹرا کے الگورتھم کے استعمال کا مظاہرہ کرنے کے لئے پرنٹ کیا گیا ہے۔"
    },
    {
        "Question": "ازگر میں ہم آہنگی کے تصور پر تبادلہ خیال کریں اور ہم آہنگی پر عملدرآمد کے لئے دھاگوں اور عمل کے استعمال کی مثالیں فراہم کریں۔",
        "Answer": "ازگر میں ہم آہنگی سے مراد متعدد کاموں یا عمل کو بیک وقت 123456 پر عمل درآمد کرنے کی صلاحیت ہے۔ہم آہنگی ایک قدرتی رجحان ہے کیونکہ بہت سارے واقعات کسی بھی وقت 1 میں بیک وقت پیش آتے ہیں۔پروگرامنگ کے معاملے میں ، ہم آہنگی اس وقت ہوتی ہے جب دو کام عملدرآمد 1 میں اوورلپ ہوجاتے ہیں۔ہم آہنگی پروگرامنگ کے ساتھ ، ایپلی کیشنز اور سافٹ ویئر سسٹم کی کارکردگی کو بہتر بنایا جاسکتا ہے کیونکہ ہم بیک وقت درخواستوں سے نمٹ سکتے ہیں بجائے اس کے کہ پچھلے ایک کو مکمل ہونے کا انتظار کریں۔ہم آہنگی میں متعدد ملازمتوں کو ایک ہی مشترکہ وسائل ، جیسے ڈسک ، نیٹ ورک ، یا ایک ہی سی پی یو کور 2 تک موڑ لینے کی اجازت دینا شامل ہے۔دوسری طرف ، ہم آہنگی ہارڈ ویئر وسائل 2 کے استعمال کو زیادہ سے زیادہ کرنے کے بارے میں ہے۔اگر متعدد سی پی یو کور موجود ہیں تو ، ہم آہنگی کے عمل یا دھاگوں کو شروع کرنے کی اجازت دیتا ہے جو ان تمام کورز 2 کا استعمال کرتے ہیں۔دھاگے عمل سے زیادہ ہلکے ہیں اور اسی میموری کی جگہ 356 کا اشتراک کرتے ہیں۔تھریڈنگ I/O- پابند کاموں کے لئے موزوں ہے ، جیسے نیٹ ورک کی درخواستیں اور فائل آپریشنز ، جہاں رکاوٹ I/O آپریشن کا انتظار کر رہی ہے 3566. ملٹی پروسیسنگ: ملٹی پروسیسنگ ازگر 456 میں بچوں کے نئے عمل کو تخلیق اور انتظام کرنے کی اجازت دیتی ہے۔ہر عمل پروگرام کی ایک الگ مثال ہے ، جس کی اپنی میموری کی جگہ اور وسائل 456 ہیں۔ملٹی پروسیسنگ سی پی یو سے منسلک کاموں کے ل suitable موزوں ہے ، جیسے ریاضی کی گنتی اور تصویری پروسیسنگ ، جہاں رکاوٹ سی پی یو کا استعمال 456.asyncio ہے: اسینسو ایک لائبریری ہے جو ازگر 6 میں غیر متزلزل کوڈ لکھنے کے لئے ٹول فراہم کرتی ہے۔اسینسو کوڈ لکھنے کی اجازت دیتا ہے جو مرکزی دھاگے کو مسدود کیے بغیر I/O آپریشن انجام دے سکتا ہے ، جس سے دوسرے کاموں کو اس دوران 6 میں عمل میں لایا جاسکتا ہے۔Asyncio I/O- پابند کاموں کے لئے موزوں ہے ، تھریڈنگ 6 کی طرح۔ یہاں تک کہ ازگر میں ہم آہنگی کے لئے دھاگوں اور عمل کو استعمال کرنے کی ایک مثال ہے: پائیتھونیمپورٹ تھریڈنگ امپورٹ ملٹی پروسیسنگ ڈیف گنتی (N): I IN RAND (N) کے لئے: پرنٹ (I)# تھریڈسٹ 1 = تھریڈنگ کا استعمال کرتے ہوئے۔ملٹی پروسیسنگ.پروسیس (ٹارگٹ = گنتی ، آرگس = (5 ،)) p2 = ملٹی پروسیسنگ۔ پروسیس (ہدف = گنتی ، آرگس = (5 ،)) p1.start () p2.start () اس مثال میں ، گنتی کا فنکشن ہےنمبر 0 سے N پرنٹ کرنے کی وضاحت کی گئی ہے۔اس کے بعد دو دھاگے اور دو عمل 5 کی دلیل کے ساتھ گنتی کے فنکشن کو انجام دینے کے لئے بنائے جاتے ہیں۔ تھریڈز تھریڈنگ ماڈیول سے تھریڈ کلاس کا استعمال کرتے ہوئے تیار کیے جاتے ہیں ، اور ملٹی پروسیسنگ ماڈیول سے پروسیس کلاس کا استعمال کرتے ہوئے عمل تخلیق کیے جاتے ہیں۔اس کے بعد دھاگے اور عمل شروع کرنے کے طریقہ کار کا استعمال کرتے ہوئے شروع کردیئے جاتے ہیں۔اس سے ازگر میں ہم آہنگی کے لئے دھاگوں اور عمل کے استعمال کا مظاہرہ ہوتا ہے۔"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں ریاستی پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "ریاستی نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو کسی شے کو اپنے طرز عمل کو تبدیل کرنے کی اجازت دیتا ہے جب اس کی داخلی ریاست 12345 تبدیل ہوتی ہے۔ریاستی پیٹرن ریاست سے متعلق طرز عمل کو الگ الگ ریاستی طبقات میں نکالتا ہے اور اصل شے کو اپنے 5 پر عمل کرنے کی بجائے اس کام کو ان طبقات کی مثال کے طور پر تفویض کرنے پر مجبور کرتا ہے۔ریاستی نمونہ اس وقت مفید ہے جب کسی شے کا طرز عمل اس کی ریاست پر منحصر ہوتا ہے اور ریاستوں کی تعداد بڑی ہوتی ہے یا جب ریاست کی منتقلی پیچیدہ ہوتی ہے ۔12345۔ یہاں ازگر میں ریاستی پیٹرن کا ایک مثال ہے: ازگر کلاس ریاست: ڈیف ہینڈل (خود): پاسکلاسکنکریٹ اسٹیٹیا (ریاست): ڈیف ہینڈل (خود): واپسی \"کنکریٹ اسٹیٹیا\" کلاس کنکریٹ اسٹیٹ بی (ریاست): ڈیف ہینڈل (خود): واپسی \"کنکریٹ اسٹیٹ بی\" کلاس سیاق و سباق: DEF __INIT __ (خود): self.state = concretestatea () def change_state () def change_state ()خود ، ریاست): self.state = state Def درخواست (خود)پرنٹ (سیاق و سباق۔سیاق و سباق کی کلاس اس شے کی نمائندگی کرتی ہے جو اس کی ریاست کی بنیاد پر اپنے طرز عمل کو تبدیل کرتی ہے۔سیاق و سباق کی کلاس میں موجودہ حالت کا حوالہ ہے ، جو ابتدائی طور پر کنکریٹ اسٹیٹیا پر مقرر کیا گیا ہے۔سیاق و سباق کی کلاس کا تبدیلی_اسٹیٹ طریقہ استعمال کی حالت کو تبدیل کرنے کے لئے استعمال ہوتا ہے۔سیاق و سباق کی کلاس کی درخواست کا طریقہ کار موجودہ حالت میں کام کے حوالے کرنے اور نتیجہ کو واپس کرنے کے لئے استعمال ہوتا ہے۔اس کے بعد سیاق و سباق کی کلاس کو موجودہ حالت کی درخواست کرنے ، ریاست کو کنکریٹ اسٹیٹب میں تبدیل کرنے ، اور نئی ریاست سے درخواست کرنے کے لئے استعمال کیا جاتا ہے کہ وہ ازگر میں ریاستی پیٹرن کے استعمال کو ظاہر کریں۔ٹرانزیشن اور کوڈ میں مشروط بیانات کی تعداد کو کم کرنا۔"
    },
    {
        "Question": "\"ایک ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور اندراج ، حذف کرنے اور تلاش کرنے کے طریقے فراہم کریں۔\"",
        "Answer": "ٹرائی (سابقہ درخت) کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور اندراج ، حذف کرنے اور تلاش کے طریقے فراہم کرنے کے ل we ، ہم پائیٹون 12 میں پائگٹری ماڈیول سے ٹری کلاس استعمال کرسکتے ہیں۔ٹری کلاس ٹری ڈیٹا ڈھانچے کا تیز اور موثر نفاذ فراہم کرتی ہے ، جو تاروں کے ذخیرہ کرنے اور موثر پریفکس پر مبنی تلاشی 12345 کو انجام دینے کے لئے استعمال ہوتی ہے۔ یہاں ٹری کلاس کا استعمال کرتے ہوئے ازگر میں ٹری ڈیٹا ڈھانچے کا ایک مثال ہے: ازگر پائیگٹریامپورٹ ٹرائکلاس پریفیکسٹری: ڈیف __ __init __ (خود): self.trie = trie () Def داخل کریں (خود ، لفظ): self.trie [لفظ] = سچ def ڈیلیٹ (خود ، لفظ)(خود ، سابقہ): واپس [key کی کلید کی کلید۔\") پرنٹ (درخت۔ سرچ (\" A \")) # پرنٹس\" ['ایپل'] \"ٹری ڈیلیٹ (\" چیری \") پرنٹ (درخت۔ سرچ (\" سی \")) # پرنٹس\" [] \"اس عمل میں، پریفیکسٹری کلاس ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔پریفیکسٹری کلاس کا __init__ طریقہ ٹری کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔پریفیکسٹری کلاس کا داخل کرنے کا طریقہ ٹرائی میں ایک لفظ داخل کرنے کے لئے استعمال ہوتا ہے۔پریفیکسٹری کلاس کا حذف کرنے کا طریقہ ٹرائی سے کسی لفظ کو حذف کرنے کے لئے استعمال ہوتا ہے۔پریفیکسٹری کلاس کے تلاش کا طریقہ استعمال شدہ ٹری میں موجود تمام الفاظ کی تلاش کے لئے استعمال کیا جاتا ہے جو کسی دیئے گئے سابقہ سے شروع ہوتا ہے۔پائگٹری ماڈیول کی ٹری کلاس کا استعمال ٹری ڈیٹا ڈھانچے کو نافذ کرنے کے لئے کیا جاتا ہے۔ یہاں پریفکسٹری کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیٹونٹری = پریفیکسٹری () ٹری.نسرٹ (\"ایپل\") درخت (\"کیلے\") درخت.INSERT (\"چیری\") پرنٹ (درخت.سارچ (\"A\")) # پرنٹس \"['ایپل']\" ٹری.ڈیلیٹ (\"چیری\") پرنٹ (درخت۔ سرچ (\"سی\")) # پرنٹس \"[] \"اس مثال میں ، پریفکسٹری کلاس کا استعمال کرتے ہوئے ایک ٹری ڈیٹا ڈھانچہ تشکیل دیا گیا ہے ، اور تین الفاظ داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ٹرائی میں داخل کردیئے گئے ہیں۔اس کے بعد تلاش کے طریقہ کار کا استعمال ٹری میں موجود تمام الفاظ کی تلاش کے لئے کیا جاتا ہے جو \"A\" کے سابقہ سے شروع ہوتا ہے ، اور نتیجہ پرنٹ ہوتا ہے۔اس کے بعد حذف کرنے کا طریقہ ٹری سے \"چیری\" کے لفظ کو حذف کرنے کے لئے استعمال کیا جاتا ہے ، اور تلاش کے طریقہ کار کو \"سی\" کے سابقہ سے شروع ہونے والے ٹری میں موجود تمام الفاظ کی تلاش کے لئے دوبارہ استعمال کیا جاتا ہے ، اور اس کا نتیجہ پرنٹ کیا جاتا ہے۔یہ ازگر میں ٹری ڈیٹا ڈھانچے کے استعمال کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "ازگر میں ورچوئل طریقوں کے تصور کی وضاحت کریں اور اس پر تبادلہ خیال کریں کہ وہ کس طرح پولیمورفزم میں شراکت کرتے ہیں۔",
        "Answer": "ازگر میں ورچوئل طریقے ایسے طریقے ہیں جن کو ذیلی طبقات کے ذریعہ ایک مختلف عمل درآمد 12345 فراہم کرنے کے لئے زیر کیا جاسکتا ہے۔ورچوئل طریقے آبجیکٹ پر مبنی پروگرامنگ کی ایک اہم خصوصیت ہیں اور پولیمورفزم میں شراکت کرتے ہیں ، جس سے مختلف طبقات کی اشیاء کو علاج کرنے کی اجازت ملتی ہے جیسے وہ ایک ہی کلاس 12345 کے ہوں۔پولیمورفزم مفید ہے کیونکہ اس سے کوڈ لکھنے کی اجازت ملتی ہے جو مختلف کلاسوں کی اشیاء کے ساتھ کام کرسکتی ہے ، جب تک کہ وہ ایک ہی طریقوں کو نافذ کریں ۔12345.in ازگر میں ، تمام طریقے ڈیفالٹ کے لحاظ سے ورچوئل ہیں ، اس کا مطلب یہ ہے کہ وہ سبکلاسس 345 کے ذریعہ زیر اثر ہوسکتے ہیں۔ازگر میں ایک طریقہ ورچوئل بنانے کے ل the ، ورچوئل کلیدی لفظ کی ضرورت نہیں ہے ، کیونکہ یہ کچھ دیگر پروگرامنگ زبانوں میں ہے جیسے C ++ 345۔اس کے بجائے ، ذیلی طبقات ایک مختلف عمل کو فراہم کرنے کے طریقہ کار کو آسانی سے اوور رائڈ کرسکتے ہیں۔Def Make_sound (خود): پرنٹ (\"ڈاگ بارکس\") کلاس بلی (جانور): Def Make_sound (خود): پرنٹ (\"بلی میئو\") Def Make_animal_sound (جانور): جانور.میک_ساؤنڈ () جانور = جانور ()کتا = کتا () بلی = بلی () میک_انیمل_ساؤنڈ (جانور) # پرنٹس \"جانور ایک آواز بناتا ہے\" میک_انیمل_ساؤنڈ (کتے) # پرنٹ کرتا ہے \"ڈاگ بارکس\" میک_انیمل_ساؤنڈ (بلی) # پرنٹ \"بلی میوز\" ، اس مثال میں ،جانوروں کی کلاس کسی جانور کی نمائندگی کرتی ہے ، اور میک_ساؤنڈ طریقہ اس آواز کی نمائندگی کرتا ہے جو جانور بناتا ہے۔کتا اور بلی کی کلاسیں جانوروں کی کلاس کے ذیلی طبقات ہیں اور مختلف عمل درآمد کے ل make میک_ساؤنڈ طریقہ کو اوور رائڈ کرتی ہیں۔میک_انیمل_ساؤنڈ فنکشن ایک جانوروں کی شے کو دلیل کے طور پر لیتا ہے اور اس کے میک_ساؤنڈ طریقہ کو کال کرتا ہے ، جو ازگر میں ورچوئل طریقوں اور پولیمورفزم کے استعمال کو ظاہر کرتا ہے۔کوڈ"
    },
    {
        "Question": "ٹیسٹ سے چلنے والی ترقی (ٹی ڈی ڈی) کے اصولوں پر تبادلہ خیال کریں اور بتائیں کہ اس سے سافٹ ویئر ڈویلپمنٹ منصوبوں کو کس طرح فائدہ ہوسکتا ہے۔",
        "Answer": "ٹیسٹ سے چلنے والی ترقی (ٹی ڈی ڈی) ایک سافٹ ویئر ڈویلپمنٹ پریکٹس ہے جو اصل کوڈ 123 لکھنے سے پہلے تحریری ٹیسٹوں پر زور دیتا ہے۔ٹی ڈی ڈی کے اصولوں میں شامل ہیں: پہلے ٹیسٹ لکھیں: کسی بھی کوڈ کو لکھنے سے پہلے ، ایک ٹیسٹ لکھیں جو ناکام ہوجائے گا۔اس سے یہ یقینی بنتا ہے کہ ٹیسٹ دراصل کسی چیز کی جانچ کر رہا ہے اور یہ کہ کوڈ کو ٹیسٹ پاس کرنے کے لئے لکھا جائے گا۔ ٹیسٹ کو ناکام کرنے کے لئے کافی کوڈ لکھیں: ٹیسٹ کو ناکام بنانے کے لئے درکار کوڈ کی کم سے کم رقم لکھیں۔اس سے یہ یقینی بنتا ہے کہ ٹیسٹ دراصل جانچ کر رہا ہے کہ اس کی جانچ کرنا ہے۔اس عمل کو اس وقت تک دہرائیں جب تک کہ ٹیسٹ پاس نہ ہوجائے اور کوڈ مکمل ہوجائے۔ یہ جانچ کے بارے میں ہے ، چشمی لکھنے کے بارے میں نہیں: ٹی ڈی ڈی کی توجہ کوڈ کی جانچ پر ہے ، تحریری وضاحتیں یا دستاویزات پر نہیں۔ سافٹ ویئر ڈویلپمنٹ پروجیکٹس میں ٹی ڈی ڈی کے فوائد میں شامل ہیں: پرعزمٹیم: ٹی ڈی ڈی ڈویلپرز کو اپنے کوڈ کے لئے ٹیسٹ لکھنے کی ترغیب دیتی ہے ، جس کی وجہ سے ایک زیادہ پرعزم ٹیم ہوسکتی ہے جو کوڈ 3 کے معیار میں لگائی جاتی ہے۔ بیٹر کوڈ کوالٹی: ٹی ڈی ڈی بہتر کوڈ کے معیار کا باعث بن سکتا ہے کیونکہ اس سے یہ یقینی بنتا ہے کہ کوڈ کا مکمل تجربہ کیا جائے۔اور یہ کہ ہر ممکن غلطیاں اور غلطیاں مدنظر رکھی جاتی ہیں۔ فائر ڈویلپمنٹ: ٹی ڈی ڈی تیزی سے ترقی کا باعث بن سکتی ہے کیونکہ اس سے ترقیاتی عمل میں ابتدائی غلطیوں کو پکڑنے میں مدد ملتی ہے ، جس سے بعد میں ان کو ٹھیک کرنے کے لئے درکار وقت اور کوشش کو کم کیا جاسکتا ہے۔ڈویلپرز اور ٹیسٹرز کے مابین کیونکہ یہ کوڈ 3 کے بارے میں ایک مشترکہ زبان اور تفہیم فراہم کرتا ہے۔ بیٹر دستاویزات: ٹی ڈی ڈی بہتر دستاویزات کا باعث بن سکتی ہے کیونکہ ٹیسٹ کوڈ 3 کے لئے دستاویزات کی ایک شکل کے طور پر کام کرتے ہیں۔ اس کی ایک مثال ہے کہ ٹی ڈی ڈی کو ازگر میں کس طرح استعمال کیا جاسکتا ہے۔: پائیتھونیمپورٹ یونٹیسٹ ڈیف ایڈ (ا ، بی): واپس A + BClass testadd (unitest.testcase): Def Test_add (خود): self.assertequal (شامل کریں (2 ، 3) ، 5) self.assertequal (شامل کریں (0 ، 0).اس کے بعد ایک ٹیسٹ کیس کی وضاحت یونٹسٹ ماڈیول کا استعمال کرتے ہوئے کی جاتی ہے ، جو مختلف آدانوں اور متوقع نتائج کے ساتھ ADD فنکشن کی جانچ کرتا ہے۔غیر منقولہ ماڈیول ازگر میں ٹیسٹ لکھنے اور چلانے کے لئے ایک فریم ورک مہیا کرتا ہے۔اگر __name__ == '__main__': جب اسکرپٹ پر عمل درآمد ہوتا ہے تو بلاک ٹیسٹ کیس چلانے کے لئے استعمال ہوتا ہے۔یہ ازگر میں ٹی ڈی ڈی کے استعمال کو ظاہر کرتا ہے"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جو سرکلر بفر (رنگ بفر) کی نمائندگی کرتے ہیں جس کے طریقوں کے ساتھ انکیو ، ڈی کیوئو اور سائز کے کاموں کے طریقوں کے ساتھ۔\"",
        "Answer": "ایک ازگر کلاس کو نافذ کرنے کے لئے جو سرکلر بفر (رنگ بفر) کی نمائندگی کرتے ہیں جس کے طریقوں کے ساتھ انکیو ، ڈی کیوئو ، اور سائز کے کاموں کے طریقوں کے ساتھ ، ہم پائیٹون 123456 میں پیگٹری ماڈیول سے سرکلر بفر کلاس استعمال کرسکتے ہیں۔ایک سرکلر بفر ایک مقررہ سائز کا ڈیٹا ڈھانچہ ہے جو عام طور پر ریئل ٹائم سافٹ ویئر ایپلی کیشنز میں استعمال ہوتا ہے تاکہ پہلے سے طے شدہ عناصر 256 کو ذخیرہ کیا جاسکے۔سرکلر بفر کو ایک رنگ کے طور پر نافذ کیا جاتا ہے ، جہاں بفر مکمل ہونے پر قدیم عنصر کے ذریعہ سب سے قدیم عنصر اوور رائٹ کیا جاتا ہے۔ یہاں سرکلر بفر کلاس کا استعمال کرتے ہوئے ازگر میں سرکلر بفر کی ایک مثال ہے: پائیتھنکلاس سرکلر بفر: ڈیف __init __ (خود ، زیادہ سے زیادہ_سائز): سیلف۔ بفر = [کوئی نہیں] * زیادہ سے زیادہ_سائز سیل۔ ہیڈ = 0 سیلف۔اوور فلاورر (\"سرکلر بفر بھرا ہوا ہے ، آئٹم کو ختم کرنے سے قاصر ہے\") سیلف۔بفر [سیلف۔ ٹیل] = آئٹم سیلف۔اگر self.size == 0: indexerror کو بڑھاؤ (\"سرکلر بفر خالی ہے ، آئٹم کو ختم کرنے سے قاصر ہے\") آئٹم = خود+ 1) ٪ سیلف۔ میکس_سائز سیلف۔ سائز -= 1 ریٹرن آئٹم ڈیف سائز (خود): خود کو لوٹائیں۔ اس پر عمل درآمد ، سرکلر بفر کلاس ایک سرکلر بفر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔سرکلر بفر کلاس کا __init__ طریقہ زیادہ سے زیادہ سائز کے ساتھ بفر کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔سرکلر بفر کلاس کا enqueue طریقہ بفر میں کسی شے کو شامل کرنے کے لئے استعمال ہوتا ہے۔سرکلر بفر کلاس کا ڈیکو طریقہ بفر سے کسی شے کو ہٹانے کے لئے استعمال ہوتا ہے۔سرکلر بفر کلاس کا سائز کا طریقہ بفر کے موجودہ سائز کو واپس کرنے کے لئے استعمال کیا جاتا ہے۔ یہاں سرکلر بفر کلاس استعمال کرنے کی ایک مثال ہے: پائیٹونبفر = سرکلر بفر (3) بفر۔ انکیو (1) بفر.نکیو (2) بفر۔enqueue (3) پرنٹ (بفر.سائز ()) # پرنٹس \"3\" بفر.نکیو (4) پرنٹ (بفر.ڈیکیو ()) # پرنٹس \"2\" پرنٹ (بفر.ڈیکیو ()) # پرنٹس \"3\" پرنٹ.انکیو طریقہ کا استعمال کرتے ہوئے بفر کو ، اور بفر کا سائز چھاپتا ہے۔اس کے بعد ایک چوتھی شے کو بفر میں شامل کیا جاتا ہے ، جس کی وجہ سے سب سے قدیم شے کو اوور رائٹ کیا جاتا ہے۔اس کے بعد سب سے قدیم تین اشیاء کو بفر سے ڈی کیو کے طریقہ کار کا استعمال کرتے ہوئے ہٹا دیا جاتا ہے ، اور بفر کا سائز چھاپ جاتا ہے۔یہ ازگر میں سرکلر بفر کے استعمال کا مظاہرہ کرتا ہے۔"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں اڈاپٹر پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "اڈاپٹر پیٹرن ایک ساختی ڈیزائن کا نمونہ ہے جو متضاد انٹرفیس کو ایک ساتھ کام کرنے کی اجازت دیتا ہے 123456۔اڈاپٹر کا نمونہ اس وقت مفید ہے جب دو کلاسوں میں متضاد انٹرفیس ہوں ، لیکن انہیں مشترکہ مقصد 123456 کے حصول کے لئے مل کر کام کرنے کی ضرورت ہے۔اڈاپٹر کا نمونہ ایک ریپر کلاس تشکیل دے کر کام کرتا ہے جو ایک کلاس کے انٹرفیس کو دوسرے کلاس 123456 کے انٹرفیس کے مطابق بناتا ہے۔ اس کے بعد ازگر میں اڈاپٹر پیٹرن کا ایک مثال عمل ہے: ازگر کلاس یورپی ساکٹ انٹرفیس: ڈیف وولٹیج (خود): پاس ڈیف لائیو (خود): پاس ڈیف غیر جانبدار (خود): پاسکلاس یو ایس ایسکٹ: ڈیف وولٹیج (خود): واپسی 120 ڈیف لائیو (خود): واپسی 1 ڈیف غیر جانبدار (خود): ریٹرن -1 کلاس اڈاپٹر (یورپی ساکٹ انٹرفیس): ڈیف __init __ (خود ، ساکٹ): خود ، خود ، ساکٹ): خود.socket = ساکٹ ڈیف وولٹیج (خود): واپس لوٹائیں۔ ساکٹ۔ وولٹیج () ڈیف لائیو (خود)): پرنٹ (\"وولٹیج:\" ، یوروپی_ساکٹ۔ وولٹیج ()) پرنٹ (\"لائیو:\" ، یورپی_ساکٹ.لائیو ()) پرنٹ (\"غیر جانبدار:\" ، یوروپی_ساکٹ۔ نیوٹرل ()) یو ایس اے_ساکٹ = یو ایس ایسکٹ () اڈاپٹر = اڈاپٹر (اڈاپٹر = اڈاپٹر ()USA_SOCTE) کنیکٹ (اڈاپٹر) اس مثال میں ، یورپی ساکٹ انٹرفیس کلاس ایک یورپی ساکٹ انٹرفیس کی نمائندگی کرتا ہے ، اور یو ایس اے ایس ایساکٹ کلاس یو ایس اے ساکٹ انٹرفیس کی نمائندگی کرتا ہے۔اڈاپٹر کلاس یو ایس ایسکٹ کلاس کے انٹرفیس کو یورپی ساکٹ انٹرفیس کلاس کے انٹرفیس میں ڈھال لیتی ہے۔کنیکٹ فنکشن ایک ایسی شے لیتا ہے جو یورپی ساکٹ انٹرفیس کو نافذ کرتا ہے اور اس کے وولٹیج ، رواں اور غیر جانبدار اقدار کو پرنٹ کرتا ہے۔اس کے بعد یو ایس ایسکٹ آبجیکٹ کو اڈاپٹر کلاس کا استعمال کرتے ہوئے یورپی ساکٹ انٹرفیس کے مطابق ڈھال لیا جاتا ہے ، اور کنیکٹ فنکشن کو موافقت پذیر آبجیکٹ کے ساتھ کہا جاتا ہے۔یہ ازگر میں اڈاپٹر پیٹرن کے استعمال کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "ازگر میں میٹاکلاسس کے تصور کی وضاحت کریں اور ایک عملی استعمال کا معاملہ فراہم کریں جہاں میٹاکلاسس کا اطلاق کیا جاسکتا ہے۔",
        "Answer": "ازگر میں میٹاکلاسس کلاس ہیں جو دوسرے کلاسز 123456 کے طرز عمل کی وضاحت کرتی ہیں۔ازگر میں ، ہر چیز ایک شے ہے ، بشمول کلاس 123456۔میٹاکلاس ایک کلاس ہے جو اس بات کی وضاحت کرتی ہے کہ کلاس کو کس طرح تخلیق کیا جانا چاہئے ، اس طرح کہ ایک کلاس اس بات کی وضاحت کرتا ہے کہ کسی شے کو کس طرح 123456 برتاؤ کرنا چاہئے۔میٹاکلاس کو کلاسوں کے طرز عمل کو اپنی مرضی کے مطابق بنانے کے لئے استعمال کیا جاتا ہے ، جیسے نئے طریقوں یا اوصاف کو شامل کرنا ، طبقے کے درجہ بندی میں ترمیم کرنا ، یا کلاس کو تبدیل کرنے کے طریقے کو انسٹینٹ کیا جاتا ہے۔قسم): _Instances = {} def __call __ (cls ، *args ، ** Kwargs): اگر Cls cls میں نہیں ہے__آنسٹینس: cls._instances [cls] = سپر ()._INSTANCES [CLS] کلاس مائکلاس (میٹاکلاس = سنگلٹن): اس مثال کے طور پر ، سنگلٹن کلاس ایک میٹاکلاس ہے جو اس بات کو یقینی بناتا ہے کہ کلاس کی صرف ایک ہی مثال تخلیق ہوئی ہے۔سنگلٹن کلاس کا __call__ طریقہ یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا کلاس کی کوئی مثال پہلے ہی تشکیل دی گئی ہے۔اگر کوئی مثال نہیں بنائی گئی ہے تو ، سپر () .__ کال__ طریقہ کا استعمال کرتے ہوئے ایک نئی مثال تیار کی گئی ہے۔اس کے بعد مائکلاس کلاس کی تعریف سنگلٹن میٹاکلاس کے ساتھ کی گئی ہے ، اس بات کو یقینی بناتے ہوئے کہ کلاس کی صرف ایک مثال تشکیل دی گئی ہے۔ اس کے علاوہ ، میٹاکلاسس ازگر کی ایک طاقتور خصوصیت ہے جو طبقاتی طرز عمل کو تخصیص کی اجازت دیتی ہے اور مختلف ڈیزائن نمونوں اور پروگرامنگ تکنیکوں کو نافذ کرنے کے لئے استعمال کی جاسکتی ہے۔.1stackoverflow2geeksforgeeks3realpython4sentry5Itnext6datacamp"
    },
    {
        "Question": "ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور ٹوپولوجیکل چھانٹنے کے طریقے فراہم کریں۔",
        "Answer": "ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور ٹوپولوجیکل چھانٹنے کے طریقے فراہم کرنے کے ل we ، ہم ازگر 1 میں نیٹ ورک ایکس ماڈیول استعمال کرسکتے ہیں۔نیٹ ورک ایکس ماڈیول ڈی اے جی ڈیٹا ڈھانچے کا تیز اور موثر نفاذ فراہم کرتا ہے ، جو نوڈس اور کناروں کے ذخیرہ کرنے اور موثر ٹوپولوجیکل چھانٹنے کے لئے استعمال ہوتا ہے۔ یہاں نیٹ ورک ایکس ماڈیول کا استعمال کرتے ہوئے ازگر میں ڈی اے جی ڈیٹا ڈھانچے کا ایک مثال ہے: پائیٹونیمپورٹ نیٹ ورک ایکس۔جیسا کہ nxclass DAG: Def __init __ (خود): سیلف گراف = nx.digraph () Def add_edge (خود ، u ، v): سیلف گراف.اڈ گراف.اڈی_ج (یو ، وی) ڈیف ٹوپولوجیکل_سورٹ (خود): واپسی کی فہرست (این ایکس۔ٹوپولوجیکل_سورٹ (سیلف گراف)) اس نفاذ میں ، ڈی اے جی کلاس ڈی اے جی ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔ڈی اے جی کلاس کا __init__ طریقہ ڈی اے جی کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔ڈی اے جی کلاس کے ADD_EDGE طریقہ کا استعمال ڈی اے جی میں ایک کنارے شامل کرنے کے لئے کیا جاتا ہے۔ڈی اے جی کلاس کا ٹوپولوجیکل_سورٹ طریقہ ڈی اے جی پر ٹوپولوجیکل چھانٹنے کو انجام دینے اور ترتیب شدہ نوڈس کو واپس کرنے کے لئے استعمال ہوتا ہے۔ یہاں ڈی اے جی کلاس کو استعمال کرنے کی ایک مثال ہے: پائیتھونڈگ = ڈی اے جی () ڈی اے جی۔ ایڈ_ج ('اے' ، 'بی' ') dag.add_edge ('b' ، 'c') dag.add_edge ('c' ، 'd') dag.add_edge ('d' ، 'e') dag.add_edge ('e' ، 'f') پرنٹ.، اور پانچ کناروں کو ADD_EDGE کے طریقہ کار کا استعمال کرتے ہوئے ڈی اے جی میں شامل کیا جاتا ہے۔اس کے بعد ٹوپولوجیکل_سورٹ کا طریقہ ڈی اے جی پر ٹوپولوجیکل چھانٹنے کو انجام دینے اور چھانٹے ہوئے نوڈس کو واپس کرنے کے لئے استعمال کیا جاتا ہے ، جو چھپی ہوئی ہیں۔یہ ازگر میں ڈی اے جی ڈیٹا ڈھانچے کے استعمال کو ظاہر کرتا ہے۔ اوورال ، نیٹ ورک ایکس ماڈیول ازگر میں ڈی اے جی ڈیٹا ڈھانچے کا ایک موثر اور آسان استعمال عمل درآمد فراہم کرتا ہے ، جس میں مختلف ایپلی کیشنز کے لئے استعمال کیا جاسکتا ہے ، بشمول ٹوپولوجیکل چھانٹ رہا ہے۔"
    },
    {
        "Question": "پہلو پر مبنی پروگرامنگ (اے او پی) کے تصور پر تبادلہ خیال کریں اور اس کو ازگر میں کس طرح لاگو کیا جاسکتا ہے۔",
        "Answer": "پہلو پر مبنی پروگرامنگ (اے او پی) ایک پروگرامنگ پیراڈیم ہے جو ڈویلپرز کو کراس کٹنگ کے خدشات ، جیسے لاگنگ ، سیکیورٹی ، اور کارکردگی کی نگرانی کو ماڈیولرائز کرنے کی اجازت دیتا ہے ، جس کو الگ الگ ماڈیولز میں شامل کیا جاتا ہے جسے پہلوؤں 123456 کہتے ہیں۔اے او پی مفید ہے جب کوئی تشویش کسی پروگرام کے متعدد حصوں کو متاثر کرتی ہے اور روایتی آبجیکٹ پر مبنی پروگرامنگ تکنیک 123456 کا استعمال کرتے ہوئے ماڈیولرائز نہیں کی جاسکتی ہے۔اے او پی خدشات کو الگ الگ ماڈیولز میں الگ کرکے اور پھر انہیں رن ٹائم 123456.in ازگر میں کوڈ میں باندھ کر کام کرتا ہے ، اے او پی کو مختلف تکنیکوں کا استعمال کرتے ہوئے استعمال کیا جاسکتا ہے ، بشمول سجاوٹ ، میٹاکلاسس ، اور لائبریری 123456۔سجاوٹ ازگر میں اے او پی کو نافذ کرنے کا ایک عام طریقہ ہے ، جہاں کسی فنکشن یا طریقہ کار 245 کے طرز عمل میں ترمیم کرنے کے لئے ایک ڈیکوریٹر فنکشن استعمال کیا جاتا ہے۔میٹاکلاسس کو ازگر میں اے او پی کو نافذ کرنے کے لئے بھی استعمال کیا جاسکتا ہے ، جہاں کلاس 136 کے طرز عمل میں ترمیم کرنے کے لئے میٹاکلاس کا استعمال کیا جاتا ہے۔لائبریریاں ، جیسے B3J0F.AOP ، orsinium-labs/AOP ، اور موسم بہار کے ازگر ، زیادہ جدید AOP خصوصیات مہیا کرتے ہیں ، جیسے متحرک بنائی اور پوائنٹ کٹ کے اظہار 136. یہاں ازگر میں AOP کو نافذ کرنے کے لئے سجاوٹ کا استعمال کرنے کی ایک مثال ہے: پائیٹنڈف لاگ (فنک): ڈیف ریپر (*آرگس ، ** KWARGS): پرنٹ (f \"کال کرنا {فنک.a ، b): a + bprint (شامل کریں (2 ، 3)) # پرنٹس \"کالنگ شامل کریں args (2 ، 3) اور Kwargs {}\" # \"5\" کے ساتھ اس مثال میں ، ایک لاگ ڈیکوریٹر فنکشن کی وضاحت کی گئی ہے کہ پرنٹ کرتا ہے۔کسی فنکشن کو کال کرنے سے پہلے اور اس کے بعد ایک لاگ پیغام۔اس کے بعد ADD فنکشن کی وضاحت اور لاگ ڈیکوریٹر فنکشن کے ساتھ سجایا جاتا ہے۔جب ADD فنکشن کو بلایا جاتا ہے تو ، لاگ ان پیغام کو اس سے پہلے اور اس کے بعد پرنٹ کیا جاتا ہے ، جس سے ازگر میں AOP کو نافذ کرنے کے لئے سجاوٹ کاروں کے استعمال کا مظاہرہ ہوتا ہے۔کوڈ کی برقرار رکھنے اور دوبارہ استعمال کی صلاحیت"
    },
    {
        "Question": "ازگر میں یادداشت کے تصور کی وضاحت کریں اور تکرار کرنے والے افعال کو بہتر بنانے کے لئے میموائزیشن کے استعمال کی ایک مثال پیش کریں۔",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو کمپیوٹر سائنس میں استعمال کی جاتی ہے تاکہ مہنگے فنکشن کالز کے نتائج کو اسٹور کرکے اور کیشڈ نتائج کو واپس کرکے حساب کو تیز کیا جاسکے جب اسی ان پٹ کو دوبارہ 123456 کہا جاتا ہے۔میمورائزیشن کا استعمال ازگر میں تکرار کرنے والے افعال کو بہتر بنانے کے لئے کیا جاسکتا ہے ، جو کمپیوٹیشنل مہنگا اور وقت استعمال کرنے والی 123456 ہوسکتا ہے۔پچھلی فنکشن کالز کے نتائج کو حاصل کرنے سے ، یادداشت غیر ضروری فنکشن کالز سے بچ سکتی ہے اور ایک تکرار فنکشن 123456 کے نتائج کی گنتی کے لئے درکار وقت اور کوشش کو کم کرسکتی ہے۔لائبریریز 123456۔کسٹم کوڈ میں ڈیٹا ڈھانچہ بنانا شامل ہے ، جیسے لغت ، کیشے کی حیثیت سے کام کرنے اور پچھلے فنکشن کالز 123456 کے نتائج کو اسٹور کرنے کے لئے۔فنکشن ڈیکوریٹرز کو ازگر میں میمورائزیشن کو نافذ کرنے کے لئے بھی استعمال کیا جاسکتا ہے ، جہاں کسی فنکشن کے طرز عمل میں ترمیم کرنے اور اس کے نتائج 245 کے کیشنے کے لئے ایک ڈیکوریٹر فنکشن استعمال کیا جاتا ہے۔لائبریریاں ، جیسے فنکٹولس۔ ایل آر یو_کیچ ، بلٹ ان میموزائزیشن کی خصوصیات مہیا کرتی ہیں جو فنکشن کالز 136 کے نتائج کو کیش کرنے کے لئے استعمال کی جاسکتی ہیں۔ یہاں ازگر میں ایک بار بار بار چلنے والی تقریب کو بہتر بنانے کے لئے میمورائزیشن کا استعمال کرنے کی ایک مثال ہے: پائیتھنڈف فبوناکی (این ، کیشے = {}): اگر n میں کیشے میں: واپس کیش [n] اگر n == 0: نتیجہ = 0 ایلف این == 1: نتیجہ = 1 اور: نتیجہ = فبوناکی (N-1) + فبونیکی (N-2) کیشے [n] = نتائج کی واپسی کا نتیجہ (فبوناکی (10)) # پرنٹس \"55\" اس مثال میں ، ایک فبونیکی فنکشن کی وضاحت کی گئی ہے جو تکرار کا استعمال کرتے ہوئے فبوناکی ترتیب میں NTH نمبر کا حساب لگاتا ہے۔فنکشن پچھلے فنکشن کالوں کے نتائج کو کیش کرنے کے لئے میمورائزیشن کا استعمال کرتا ہے اور غیر ضروری فنکشن کالز سے بچتا ہے۔کیشے کی لغت کو پچھلی فنکشن کالز کے نتائج کو ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے ، اور اگر n میں کیشے میں: بیان کی جانچ پڑتال کے لئے استعمال کیا جاتا ہے تو یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا نتیجہ پہلے ہی کیچ ہوچکا ہے۔اگر نتیجہ پہلے ہی کیچ ہوچکا ہے تو ، یہ کیشے سے واپس آجاتا ہے۔بصورت دیگر ، فنکشن تکرار کا استعمال کرتے ہوئے نتیجہ کا حساب لگاتا ہے اور مستقبل کے استعمال کے لئے کیشے کی لغت میں نتیجہ کیچ کرتا ہے۔یہ ازگر میں ایک تکرار کرنے والے فنکشن کو بہتر بنانے کے لئے یادداشت کے استعمال کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "\"فائلوں اور ڈائریکٹریز بنانے ، ڈھانچے کو نیویگیٹ کرنے ، اور فائلوں کی تلاش کے طریقوں کے ساتھ فائل سسٹم کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "فائلوں اور ڈائریکٹریز بنانے ، ڈھانچے کو نیویگیٹ کرنے ، اور فائلوں کی تلاش کے طریقوں کے ساتھ فائل سسٹم کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم ازگر میں بلٹ ان ماڈیولز ، جیسے OS اور شیل 123456 استعمال کرسکتے ہیں۔یہ ماڈیول فائل سسٹم کے ساتھ بات چیت کے ل various مختلف طریقے مہیا کرتے ہیں ، بشمول فائلیں اور ڈائریکٹریز بنانے اور حذف کرنا ، ڈائریکٹری کے ڈھانچے کو نیویگیٹ کرنا ، اور فائلوں کو تلاش کرنا۔ یہاں OS اور شیل ماڈیولز کا استعمال کرتے ہوئے ازگر میں فائل سسٹم کلاس کا ایک مثال ہے: پائیٹونیمپورٹOsimport شلکلاس فائل سسٹم: Def __init __ (خود ، جڑ): self.root = روٹ ڈیف تخلیق_فائل (خود ، راستہ): کھلی (os.path.join (self.root ، راستہ) ، 'W') کے ساتھ F: پاس DefCreate_directory (خود ، راستہ): OS.Makedirs (OS.Path.join (self.root ، Path)) Def نیویگیٹ (سیلف ، راہ): OS.CHDIR (OS.Path.join (self.root ، راستہ)) Defتلاش (خود ، نام): روٹ ، ڈیرس ، OS.walk (self.root) میں فائلوں کے لئے میچز = [])) ریٹرن میچز ڈیف ڈیلیٹ_فائل (خود ، راستہ): os.remove (os.path.join (self.root ، path)) Def ڈیلیٹ_ڈ ڈائرکٹری (خود ، راستہ): shil.rmtree (os.path.join (self.rot، راستہ)) اس نفاذ میں ، فائل سسٹم کلاس فائل سسٹم کی نمائندگی کرتا ہے۔فائل سسٹم کلاس کا __init__ طریقہ فائل سسٹم کو روٹ ڈائرکٹری کے ساتھ شروع کرنے کے لئے استعمال کیا جاتا ہے۔فائل سسٹم کلاس کا تخلیق_فائل طریقہ کسی دیئے ہوئے راستے پر فائل بنانے کے لئے استعمال ہوتا ہے۔فائل سسٹم کلاس کا تخلیق_ ڈائرکٹری طریقہ کسی دیئے ہوئے راستے پر ڈائریکٹری بنانے کے لئے استعمال ہوتا ہے۔فائل سسٹم کلاس کا نیویگیٹ طریقہ کسی دیئے ہوئے راستے پر تشریف لے جانے کے لئے استعمال ہوتا ہے۔فائل سسٹم کلاس کی تلاش کا طریقہ کسی دیئے ہوئے نام کے ساتھ فائلوں کی تلاش کے لئے استعمال ہوتا ہے۔فائل سسٹم کلاس کا ڈیلیٹ_فائل طریقہ کسی دیئے ہوئے راستے پر فائل کو حذف کرنے کے لئے استعمال ہوتا ہے۔فائل سسٹم کلاس کا ڈیلیٹ_ ڈائرکٹری طریقہ کسی دیئے گئے راستے پر کسی ڈائرکٹری کو حذف کرنے کے لئے استعمال ہوتا ہے۔ یہاں فائل سسٹم کلاس کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیٹونفس = فائل سسٹم ('/راستہ/سے/جڑ') fs.create_file ('فائل۔txt ') fs.create_directory (' dir ') fs.navagate (' dir ') fs.create_file (' فائل 2.txt ') fs.navigate (' .. ') پرنٹ (fs.search (' فائل ')) #پرنٹس \"اس مثال میں ، فائل سسٹم کلاس کا استعمال کرتے ہوئے ایک فائل سسٹم تشکیل دیا جاتا ہے جس کی روٹ ڈائریکٹری/راہ/سے/جڑ ہوتی ہے۔اس کے بعد بالترتیب تخلیق_فائل اور تخلیق_ ڈائرکٹری طریقوں کا استعمال کرتے ہوئے ایک فائل اور ڈائریکٹری بنائی جاتی ہے۔فائل سسٹم کو نیویگیٹ کے طریقہ کار کا استعمال کرتے ہوئے ڈائریکٹری میں نیویگیٹ کیا جاتا ہے ، اور ایک اور فائل بنائی جاتی ہے۔اس کے بعد فائل سسٹم کو روٹ ڈائرکٹری میں واپس بھیج دیا جاتا ہے ، اور نام فائل والی فائلوں کے لئے تلاش کی جاتی ہے۔تلاش کے نتائج پرنٹ ہیں۔اس کے بعد فائل اور ڈائرکٹری کو حذف کرنے اور حذف کرنے والے طریقوں کو بالترتیب حذف کردیا جاتا ہے۔یہ ازگر میں فائل سسٹم کلاس کے استعمال کو ظاہر کرتا ہے۔ اوورال ، او ایس اور شیل ماڈیولز ازگر میں فائل سسٹم کے ساتھ بات چیت کے لئے ایک طاقتور اور آسان استعمال انٹرفیس مہیا کرتے ہیں ، جو مختلف فائل سسٹم آپریشنز اور ایپلی کیشنز کو نافذ کرنے کے لئے استعمال ہوسکتے ہیں۔نمبر"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں کمانڈ پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "کمانڈ پیٹرن ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو کسی عمل کی درخواست کو اس چیز سے الگ کرتا ہے جو ایکشن 123456 انجام دیتا ہے۔کمانڈ کا نمونہ مفید ہے جب کسی نظام کو غیر قابل عمل آپریشنز ، لاگنگ ، یا درخواستوں کی درخواستوں کو قطار میں مدد کرنے کی ضرورت ہوتی ہے۔کمانڈ پیٹرن کسی شے کی حیثیت سے کسی درخواست کو سمیٹ کر کام کرتا ہے ، جس میں ایکشن 123456 کو انجام دینے کے لئے ضروری تمام معلومات شامل ہیں۔اس کے بعد اس آبجیکٹ کو آس پاس منتقل کیا جاسکتا ہے اور بعد میں اس کو پھانسی دی جاسکتی ہے ، یا اسے بعد میں استعمال کرنے کے لئے محفوظ کیا جاسکتا ہے ۔123456۔ یہاں ازگر میں کمانڈ پیٹرن کی ایک مثال ہے: ازگر کلاس کمانڈ: ڈی ای ایف ایگزیکٹو (خود): پاسکلاس ایڈکومنڈ (کمانڈ):def __init __ (خود ، وصول کنندہ ، قدر): سیلف.رییسیور = وصول کنندہ خود۔ ویلیو = ویلیو ڈیف پر عملدرآمد (خود): سیلف ریسیور.اڈ (خود) کلاس وصول کنندہ: Def __init __ (خود): سیلف۔ ویلیو = 0ڈیف ایڈ (خود ، قدر): سیلف۔ ویلیو += ویلیوکلاس انویکر: ڈیف __init __ (خود): سیلف کامینڈز = [] ڈیف ایڈ_کومنڈ (خود ، کمانڈ): سیلف ڈاٹ کامینڈس۔ اے پی پی ای ڈی (کمانڈ) ڈی ای ایف ایگزیکٹو_کومنڈس (خود):خود کمانڈ میں کمانڈ کے لئے: کمانڈ۔ ایکسیکوٹ () وصول کنندہ = وصول کنندہ () ADD_COMMAND = ADDCOMMAND (وصول کنندہ ، 5) انویکر = انویکر () انویکر.ایڈ_کمنڈ (ADD_COMMAND) INVOKER.EXECUTE_COMMANDS () پرنٹ (وصول کنندہ۔ ویلیو) # پرنٹس \"5 \"اس مثال میں ، کمانڈ کلاس کی وضاحت کی گئی ہے جو کمانڈ آبجیکٹ کی نمائندگی کرتی ہے۔اس کے بعد ایڈکمنڈ کلاس کی وضاحت کی گئی ہے ، جو کمانڈ کلاس کا ایک ذیلی طبقہ ہے اور وصول کنندہ آبجیکٹ میں قدر شامل کرنے کے لئے کمانڈ کی نمائندگی کرتا ہے۔وصول کنندہ کلاس کی وضاحت کی گئی ہے ، جو اس شے کی نمائندگی کرتی ہے جو عمل کو انجام دیتی ہے۔انوکر کلاس کی وضاحت کی گئی ہے ، جو کمانڈز کو ذخیرہ کرنے اور اس پر عمل درآمد کے لئے ذمہ دار ہے۔وصول کنندہ کلاس کی ایک مثال تشکیل دی گئی ہے ، اور ایڈکمنڈ کلاس کی ایک مثال وصول کنندہ آبجیکٹ اور 5 کی قدر کے ساتھ تشکیل دی گئی ہے۔اس کے بعد وصول کنندہ آبجیکٹ کی قدر پرنٹ کی جاتی ہے ، جو ازگر میں کمانڈ پیٹرن کے استعمال کا مظاہرہ کرتی ہے۔درخواستوں کے ل und غیر قابل آپریشنز ، لاگنگ ، یا قطار کے ل useful مفید"
    },
    {
        "Question": "\"ملٹی تھریڈڈ ازگر پروگراموں میں ہم آہنگی پر قابو پانے کے طریقہ کار کے تصور پر تبادلہ خیال کریں اور تالے ، سیمفورس اور حالت کے متغیر جیسے موازنہ اور اس کے برعکس نقطہ نظر کا موازنہ کریں۔\"",
        "Answer": "ہم آہنگی پر قابو پانے کے طریقہ کار کو ملٹی تھریڈڈ ازگر پروگراموں میں استعمال کیا جاتا ہے تاکہ یہ یقینی بنایا جاسکے کہ ایک سے زیادہ تھریڈز محفوظ اور موثر انداز میں مشترکہ وسائل تک رسائی حاصل کرسکتے ہیں۔یہ میکانزم نسل کے حالات ، ڈیڈ لاکس اور دیگر ہم وقت سازی کے امور کو روکنے کے لئے استعمال ہوتے ہیں جو پیدا ہوسکتے ہیں جب متعدد تھریڈز مشترکہ وسائل کو بیک وقت رسائی حاصل کرتے ہیں۔ازگر میں استعمال ہونے والے کچھ عام ہم آہنگی پر قابو پانے کے طریقہ کار میں شامل ہیں: تالے: تالے استعمال کیے جاتے ہیں تاکہ یہ یقینی بنایا جاسکے کہ صرف ایک دھاگہ ایک وقت میں مشترکہ وسائل تک رسائی حاصل کرسکتا ہے۔جب کوئی دھاگہ لاک حاصل کرتا ہے تو ، دوسرے تمام دھاگے اس وقت تک مسدود ہوجاتے ہیں جب تک کہ تالا جاری نہ ہوجائے۔تالے کو نسل کے حالات کو روکنے اور اس بات کو یقینی بنانے کے لئے استعمال کیا جاسکتا ہے کہ مشترکہ وسائل کو محفوظ اور مستقل انداز میں حاصل کیا جاتا ہے ۔سمافورس: سیمیفورز مشترکہ وسائل تک رسائی کو کنٹرول کرنے کے لئے استعمال کیے جاتے ہیں جو تھریڈز کی تعداد کو بیک وقت محدود کرسکتے ہیں۔سیمفورز کو وسائل کی تھکن کو روکنے اور اس بات کو یقینی بنانے کے لئے استعمال کیا جاسکتا ہے کہ مشترکہ وسائل کو کنٹرول اور موثر انداز میں حاصل کیا جائے۔ کنڈیشن متغیرات: جب مشترکہ وسائل تک رسائی کے لئے دستیاب ہو تو سگنل تھریڈز کے لئے حالت متغیرات کا استعمال کیا جاتا ہے۔مشترکہ وسائل دستیاب ہونے تک تھریڈز کو روکنے کے لئے مشترکہ وسائل دستیاب ہونے تک تھریڈز کو مسدود کردیا جاتا ہے۔0 سیلف لاک = تھریڈنگ۔ لاک () ڈیف انکریمنٹ (خود): خود کے ساتھ= [تھریڈنگ۔ تھریڈ (ٹارگٹ = ورکر) تھریڈز میں تھریڈ کے لئے رینج (10)] کے لئے: دھاگوں میں دھاگوں میں تھریڈ۔ اسٹارٹ () دھاگوں میں دھاگوں کے لئے: تھریڈ.جوئن () پرنٹ (کاؤنٹر.الیو) # پرنٹس \"1000000\" inاس مثال کے طور پر ، ایک کاؤنٹر کلاس کی وضاحت کی گئی ہے جو مشترکہ وسائل کی نمائندگی کرتی ہے۔کاؤنٹر کلاس کے اضافے کا طریقہ ایک تالے کا استعمال کرتے ہوئے تھریڈ سے محفوظ انداز میں کاؤنٹر کی قیمت کو بڑھانے کے لئے استعمال ہوتا ہے۔اس کے بعد دس دھاگے بنائے جاتے ہیں ، جن میں سے ہر ایک کاؤنٹر کلاس 100000 بار کے اضافے کے طریقہ کار کو کہتے ہیں۔اس کے بعد دھاگوں کو شروع اور شامل کیا جاتا ہے ، اور کاؤنٹر کی آخری قیمت پرنٹ کی جاتی ہے ، جس سے یہ ظاہر ہوتا ہے کہ ازگر میں ہم آہنگی کے کنٹرول کو نافذ کرنے کے لئے تالے کے استعمال کا مظاہرہ کرتے ہیں۔محفوظ اور موثر انداز۔تالے ، سیمفورز ، اور حالت کے متغیر کچھ عام ہم آہنگی پر قابو پانے والے میکانزم ہیں جو ازگر میں استعمال ہوتے ہیں ، ہر ایک کو اپنے فوائد اور نقصانات ہوتے ہیں۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں کنٹرول (IOC) اور انحصار انجیکشن (DI) کے الٹا کے تصور کی وضاحت کریں اور بتائیں کہ وہ کس طرح کوڈ برقرار رکھنے اور جانچ کو بہتر بناتے ہیں۔",
        "Answer": "کنٹرول کا الٹا (IOC) آبجیکٹ پر مبنی پروگرامنگ میں ایک ڈیزائن کا اصول ہے جو پروگرام 123456 کو بنانے والی اشیاء سے کسی پروگرام کے کنٹرول فلو کو الگ کرتا ہے۔آئی او سی کا استعمال آبجیکٹ کے مابین جوڑے کو کم کرکے اور پروگرام 123456 کے باقی حصوں کو متاثر کیے بغیر اشیاء کو تبدیل کرنا یا اس میں ترمیم کرنا آسان بنا کر کوڈ کی دیکھ بھال اور جانچ کو بہتر بنانے کے لئے استعمال کیا جاتا ہے۔انحصار انجیکشن (ڈی آئی) آئی او سی کا ایک مخصوص نفاذ ہے جس میں کسی شے میں انحصار انجیکشن کرنا شامل ہوتا ہے بجائے اس کے کہ اس چیز کو اپنی انحصار 123456 بنائے۔ڈی آئی کا استعمال کوڈ برقرار رکھنے اور جانچ کی صلاحیت کو بہتر بنانے کے لئے استعمال کیا جاتا ہے تاکہ بقیہ پروگرام 123456 کو متاثر کیے بغیر انحصار کو تبدیل کیا جاسکے۔محفوظ اور موثر انداز میں۔یہ میکانزم نسل کے حالات ، ڈیڈ لاکس اور دیگر ہم وقت سازی کے امور کو روکنے کے لئے استعمال ہوتے ہیں جو پیدا ہوسکتے ہیں جب متعدد تھریڈز مشترکہ وسائل کو بیک وقت 123456 تک رسائی حاصل کرتے ہیں۔تالے کا استعمال اس بات کو یقینی بنانے کے لئے کیا جاتا ہے کہ صرف ایک دھاگہ ایک وقت میں مشترکہ وسائل تک رسائی حاصل کرسکتا ہے ، سیمیفورس کو مشترکہ وسائل تک رسائی کو کنٹرول کرنے کے لئے استعمال کیا جاتا ہے جو تھریڈز کی تعداد کو بیک وقت محدود کرسکتے ہیں ، اور حالت کے متغیرات کا استعمال دھاگوں کے اشارے کے لئے کیا جاتا ہے جب تھریڈز کا استعمال کیا جاتا ہے۔ایک مشترکہ وسائل رسائی 123456 کے لئے دستیاب ہے۔پروگرام.ہم آہنگی پر قابو پانے کے طریقہ کار ، جیسے تالے ، سیمفورس اور حالت متغیرات ، ملٹی تھریڈڈ ازگر پروگراموں میں استعمال ہوتے ہیں تاکہ یہ یقینی بنایا جاسکے کہ مشترکہ وسائل کو محفوظ اور موثر انداز میں حاصل کیا جاتا ہے۔"
    },
    {
        "Question": "ہدایت شدہ گراف کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور بیل مین فورڈ الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کریں۔",
        "Answer": "ہدایت شدہ گراف کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور بیل مین فورڈ الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کرنے کے ل we ، ہم پائیٹون 12 میں نیٹ ورک ایکس ماڈیول استعمال کرسکتے ہیں۔نیٹ ورک ایکس ماڈیول ہدایت شدہ گراف ڈیٹا ڈھانچے کا ایک تیز اور موثر نفاذ فراہم کرتا ہے ، جو نوڈس اور کناروں کے ذخیرہ کرنے اور موثر مختصر ترین راستہ الگورتھمز 12 کو انجام دینے کے لئے استعمال ہوتا ہے۔ یہاں نیٹ ورک ایکس ماڈیول کا استعمال کرتے ہوئے ازگر میں ہدایت شدہ گراف ڈیٹا ڈھانچے کا ایک مثال عمل ہے۔: Pythonimport نیٹ ورک ایکس بطور Nxclass ہدایت نامہ: Def __init __ (self): self.graph = nx.digraph () def add_edge (خود ، u ، V ، وزن): self.graph.add_edge (u ، v ، وزن = وزن) Def مختصر ترین_پاتھ.ہدایت نامہ کلاس کا __init__ طریقہ ہدایت شدہ گراف کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔ہدایت نامہ کلاس کا ADD_EDGE طریقہ استعمال شدہ وزن کے ساتھ ہدایت والے گراف میں ایک کنارے شامل کرنے کے لئے استعمال ہوتا ہے۔ڈائریکٹ گراف کلاس کا مختصر ترین_پاتھ طریقہ ہدایت شدہ گراف پر بیل مین فورڈ الگورتھم کو انجام دینے اور کسی ماخذ اور ہدف نوڈ کے درمیان مختصر ترین راستہ واپس کرنے کے لئے استعمال کیا جاتا ہے۔ ڈائریکٹ گراف کلاس کو کس طرح استعمال کیا جائے: ازگرگراف = ہدایت نامہ () گراف.add_edge ('a' ، 'b' ، 1) گراف.اڈ_ج ('b' ، 'c' ، 2) گراف.ڈی_ج ('c' ، 'd' ، 3) گراف.اڈی_ج ('d' ، 'e '، 4) پرنٹ (گراف.شورٹسٹ_پاتھ (' a '،' e ')) # پرنٹس \"[' a '،' b '،' c '،' d '،' e ']\" اس مثال میں ، aہدایت شدہ گراف ڈیٹا کا ڈھانچہ ڈائریکٹ گراف کلاس کا استعمال کرتے ہوئے تشکیل دیا گیا ہے ، اور چار کناروں کو ADD_EDGE کے طریقہ کار کا استعمال کرتے ہوئے ہدایت والے گراف میں شامل کیا جاتا ہے۔اس کے بعد مختصر_پاتھ کا طریقہ کار ہدایت والے گراف پر بیل مین فورڈ الگورتھم کو انجام دینے اور کسی ماخذ اور ہدف نوڈ کے درمیان مختصر ترین راستہ واپس کرنے کے لئے استعمال کیا جاتا ہے ، جو طباعت شدہ ہے۔اس سے بیل مین فورڈ الگورتھم کے ساتھ ازگر میں ہدایت شدہ گراف ڈیٹا ڈھانچے کا استعمال ظاہر ہوتا ہے۔ نیٹ ورک ایکس ماڈیول ازگر میں ہدایت نامہ گراف ڈیٹا ڈھانچے کا ایک موثر اور آسان استعمال عمل درآمد فراہم کرتا ہے ، جسے مختلف ایپلی کیشنز کے لئے استعمال کیا جاسکتا ہے۔، بشمول مختصر ترین راستہ الگورتھم"
    },
    {
        "Question": "ازگر میں عدم استحکام کے تصور پر تبادلہ خیال کریں اور اس کے فوائد کو ہم آہنگی اور تقسیم شدہ نظاموں میں بیان کریں۔",
        "Answer": "ازگر میں عدم استحکام سے مراد ان اشیاء کی جائیداد ہے جن میں 12 بنائے جانے کے بعد ان میں ترمیم نہیں کی جاسکتی ہے۔غیر منقولہ اشیاء تک رسائی میں تیزی سے ہوتا ہے اور اسے تبدیل کرنا مہنگا ہوتا ہے کیونکہ اس میں کاپی 2 کی تشکیل شامل ہوتی ہے۔اس کے برعکس ، تغیر پزیر اشیاء کو 12 بنانے کے بعد تبدیل کیا جاسکتا ہے۔عدم استحکام مختلف حساس کاموں کو بہت سارے مفید ایپلی کیشنز کی پیش کش کرتا ہے جو ہم نیٹ ورک پر مبنی ماحول میں کرتے ہیں جہاں ہم متوازی پروسیسنگ 1 کی اجازت دیتے ہیں۔جب متعدد دھاگے یا عمل مشترکہ وسائل کو بیک وقت 34 تک رسائی حاصل کرتے ہیں۔غیر منقولہ اشیاء کو تالے یا دیگر ہم وقت سازی کے طریقہ کار کی ضرورت کے بغیر دھاگوں یا عمل کے مابین محفوظ طریقے سے شیئر کیا جاسکتا ہے ، جو کارکردگی کو بہتر بناسکتے ہیں اور کوڈ 34 کی پیچیدگی کو کم کرسکتے ہیں۔ انحصار انجیکشن (ڈی آئی) کنٹرول (IOC) کا ایک مخصوص نفاذ ہے جس میں شامل ہوتا ہے۔کسی شے میں انحصار انجیکشن لگانے کے بجائے کسی شے کو اپنی انحصار 134256 پیدا کرنے کی بجائے۔ڈی آئی کا استعمال باقی پروگرام 134256 کو متاثر کیے بغیر انحصار کو تبدیل کرنے یا اس میں ترمیم کرنا آسان بنا کر کوڈ برقرار رکھنے اور جانچ کی صلاحیت کو بہتر بنانے کے لئے کیا جاتا ہے۔ہم آہنگی اور تقسیم شدہ نظاموں میں ، ڈی آئی کو تھریڈز یا عمل میں ناقابل تسخیر اشیاء کو انجیکشن دینے کے لئے استعمال کیا جاسکتا ہے ، جو ہم وقت سازی کے امور کے امکانات کو کم کرسکتا ہے اور کارکردگی کو بہتر بنا سکتا ہے۔ہم آہنگی اور تقسیم شدہ نظاموں میں کارکردگی۔غیر منقولہ اشیاء کا استعمال کرکے اور انحصار کو انجیکشن لگانے سے ، ڈویلپرز ہم وقت سازی کے امور کے امکانات کو کم کرسکتے ہیں اور ان کے کوڈ کی کارکردگی کو بہتر بنا سکتے ہیں۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جو سرکلر قطار کی نمائندگی کرتے ہیں جس کے طریقوں کے ساتھ انکیو ، ڈی کیوئو ، اور اس بات کا تعین کرنا کہ قطار بھری ہوئی ہے یا خالی ہے یا نہیں۔\"",
        "Answer": "ایک سرکلر قطار ایک اعداد و شمار کا ڈھانچہ ہے جو پہلے ، پہلی آؤٹ بنیاد پر کام کرتا ہے ، لیکن شکل میں سرکلر ہے ، اس کا مطلب یہ ہے کہ آخری پوزیشن کے بعد قطار میں اگلی پوزیشن پہلی پوزیشن 12345 ہے۔ازگر میں ایک فہرست کا استعمال کرتے ہوئے ایک سرکلر قطار نافذ کی جاسکتی ہے ، اور یہ مختلف ایپلی کیشنز ، جیسے کمپیوٹر آرکیٹیکچر ، ڈسک ڈرائیور ، ویڈیو بفرنگ ، اور پرنٹر جاب شیڈولنگ 12345 میں کارآمد ہے۔ یہاں ازگر میں سرکلر قطار کا ایک مثال ہے: پائیتھونکلاس سرکلر کویو.is_full (خود): واپسی (سیلف۔ ٹیل + 1) ٪ سیلف۔is_empty (): self.head = 0 self.tail = 0 self.queue [self.tail] = ڈیٹا اور: سیلف۔ڈیٹا ڈیف ڈی کیوئو (خود): اگر سیلف۔ آئی ایس_پٹی (): پرنٹ (\"سرکلر قطار خالی ہے\") الیف سیلف۔ ہیڈ == سیلف۔self.tail = -1 ریٹرن ڈیٹا ورنہ: ڈیٹا = سیلف۔ کیوئو [سیلف ہیڈ] سیلف۔ ہیڈ = (سیلف ۔ہیڈ + 1) ٪ خود۔سرکلر کیو کلاس کا __init__ طریقہ استعمال شدہ سائز کے ساتھ سرکلر قطار کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔سرکلر کیو کلاس کا is_empty طریقہ اس بات کا تعین کرنے کے لئے استعمال کیا جاتا ہے کہ آیا سرکلر قطار خالی ہے یا نہیں۔سرکلر کیو کلاس کا آئی ایس_فل طریقہ اس بات کا تعین کرنے کے لئے استعمال کیا جاتا ہے کہ آیا سرکلر قطار بھری ہوئی ہے یا نہیں۔سرکلر کیو کلاس کا enqueue طریقہ سرکلر قطار میں عنصر شامل کرنے کے لئے استعمال ہوتا ہے۔سرکلر کیوئیو کلاس کا ڈیکیو طریقہ سرکلر قطار سے کسی عنصر کو ہٹانے کے لئے استعمال کیا جاتا ہے۔ یہاں سرکلر کیو کلاس کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیٹونک کیو = سرکلر کیوئ (5) سی کیو. اینکیو (1) CQ.Enqueue (2) سی کیو۔enqueue (3) cq.enqueue (4) cq.enqueue (5) cq.enqueue (6) # پرنٹس \"سرکلر قطار مکمل ہے\" پرنٹ (cq.dequeue ()) # پرنٹس \"1\" پرنٹ (cq.dequeue (cq.dequeue ()) # پرنٹس \"2\" cq.enqueue (6) cq.enqueue (7) پرنٹ (cq.dequeue ()) # پرنٹس \"3\" پرنٹ (cq.dequeue ()) # پرنٹس \"4\" پرنٹ (cq.dequeue()) # پرنٹ \"5\" پرنٹ (cq.dequeue ()) # پرنٹس \"6\" پرنٹ (cq.dequeue ()) # پرنٹس \"7\" پرنٹ (cq.dequeue ()) # پرنٹس \"سرکلر قطار خالی ہے\"اس مثال میں ، سرکلر کیو کلاس کا استعمال کرتے ہوئے ایک سرکلر قطار تیار کی گئی ہے جس کا سائز 5 ہے۔ اس کے بعد پانچ عناصر کو انکیو کے طریقہ کار کا استعمال کرتے ہوئے سرکلر قطار میں شامل کیا جاتا ہے۔سرکلر قطار میں چھٹا عنصر شامل کرنے کی کوشش کی گئی ہے ، جو ایک پیغام پرنٹ کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ سرکلر قطار بھری ہوئی ہے۔اس کے بعد چار عناصر کو ڈی کیو کے طریقہ کار کا استعمال کرتے ہوئے سرکلر قطار سے ہٹا دیا جاتا ہے ، اور دو اور عناصر کو سرکلر قطار میں شامل کیا جاتا ہے۔اس کے بعد باقی عناصر کو ڈی کیو کے طریقہ کار کا استعمال کرتے ہوئے سرکلر قطار سے ہٹا دیا جاتا ہے ، اور ایک پیغام جس سے یہ ظاہر ہوتا ہے کہ سرکلر قطار خالی ہے پرنٹ ہے۔یہ ازگر میں سرکلر قطار کے استعمال کو ظاہر کرتا ہے۔"
    },
    {
        "Question": "\"معاہدے کے ذریعہ ڈیزائن کے تصور کی وضاحت کریں اور اس کی ایک مثال پیش کریں کہ کس طرح پیشگی حالت ، پوسٹ کنڈیشنس اور حملہ آوروں کو ازگر میں نافذ کیا جاسکتا ہے۔\"",
        "Answer": "معاہدہ کے ذریعہ ڈیزائن ایک سافٹ ویئر ڈویلپمنٹ کا طریقہ کار ہے جس میں فراہم کنندہ اور اجزاء 123456 کے مؤکلوں کے مابین معاہدہ استعمال کرتے ہوئے سافٹ ویئر کے اجزاء کے طرز عمل کی وضاحت شامل ہے۔معاہدہ جزو کی پیشگی شرط ، پوسٹ کنڈیشنز اور حملہ آوروں کی وضاحت کرتا ہے ، جو اس بات کو یقینی بنانے کے لئے استعمال ہوتے ہیں کہ جزو صحیح اور مستقل طور پر 123456 کے ساتھ برتاؤ کرتا ہے۔پیشگی شرطیں ایسی شرائط ہیں جو جزو کو انجام دینے سے پہلے ہی درست ہونی چاہئیں ، پوسٹ کنڈیشنس ایسے حالات ہیں جو جزو کے عمل کے بعد درست ہونا ضروری ہیں ، اور حملہ آورین ایسی حالتیں ہیں جو جزو سے پہلے اور اس کے بعد درست ہونا ضروری ہیں۔حملہ آوروں کا استعمال کرتے ہوئے حملہ آوروں کو نافذ کیا جاسکتا ہے۔دعوے وہ بیانات ہیں جو چیک کرتے ہیں کہ آیا کوئی شرط درست ہے یا نہیں اور اگر کوئی حالت غلط ہے تو اس میں کوئی استثنا بڑھاتا ہے۔پیشگی شرائط کو جانچنے کے ذریعہ نافذ کیا جاسکتا ہے کہ آیا کسی فنکشن کا ان پٹ اسسٹیشن 123456 کا استعمال کرتے ہوئے مطلوبہ شرائط کو پورا کرتا ہے۔پوسٹ کنڈیشن کو جانچنے کے ذریعہ نافذ کیا جاسکتا ہے کہ آیا کسی فنکشن کی آؤٹ پٹ estrisons123456 کا استعمال کرتے ہوئے مطلوبہ شرائط کو پورا کرتی ہے۔حملہ آوروں کو یہ جانچنے کے ذریعہ نافذ کیا جاسکتا ہے کہ آیا کسی شے کی حالت دعوی 123456 کا استعمال کرتے ہوئے مطلوبہ شرائط کو پورا کرتی ہے۔ اس کی ایک مثال ہے کہ کس طرح پیشگی حالت ، پوسٹ کنڈیشنس ، اور حملہ آوروں کو ازگر میں دعووں کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے: پائیٹونکلاس اسٹیک: ڈیف __init __ (خود): خود۔آئٹمز = [] Def is_empty (self): ریٹرن لین (self.items) == 0 Def Push (خود ، آئٹم): پر زور دیں آئٹم کوئی بھی نہیں ہے ، \"آئٹم کوئی نہیں ہوسکتا ہے۔(خود): خود پر زور دیں۔ IS_EMPTY () ، \"اسٹیک خالی ہے\" سیلف ڈاٹ آئٹمز.پوپ () ڈیف ٹاپ (خود): خود پر زور نہ دیں۔ IS_EMPTY () ، \"اسٹیک خالی ہے۔1] ڈیف __len __ (خود): ریٹرن لین (سیلف۔ آئٹمز) ڈیف __str __ (خود): ریٹرن ایس ٹی آر (سیلف۔ آئٹمز) اسٹیک = اسٹیک () اسٹیک () پش (1) اسٹیک.پش (2) اسٹیک.پش (3 (3)) لین (اسٹیک) == 3 پر زور دیں ، \"لمبائی 3 ہونا چاہئے\" اسٹیک ۔پپ () == 3 ، \"ٹاپ آئٹم 3 ہونا چاہئے\".top () == 2 ، \"ٹاپ آئٹم 2 ہونا چاہئے\" پر زور دیں لین (اسٹیک) == 2 ، \"لمبائی 2\" اسٹیک ہونا چاہئے۔ پش (کوئی بھی نہیں) # اس مثال میں \"آئٹم نہیں\" ایک استثنا کو بڑھاتا ہے ، اس مثال میں ،ایک اسٹیک کلاس کی وضاحت کی گئی ہے جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔پیشگی شرائط کو پش کے طریقہ کار میں یہ چیک کرکے نافذ کیا جاتا ہے کہ آیا ان پٹ کوئی نہیں ہے یا نہیں۔پوسٹ کنڈیشن کو پاپ اور اعلی طریقوں میں یہ چیک کرکے نافذ کیا جاتا ہے کہ آیا اسٹیک خالی نہیں ہے یا نہیں۔حملہ آوروں کو اسٹیک کی لمبائی اور تار کی نمائندگی کی جانچ کرکے __len__ اور __str__ طریقوں میں نافذ کیا جاتا ہے۔ان شرائط کو نافذ کرنے کے لئے دعوے کا استعمال کیا جاتا ہے ، اور اگر حالات مطمئن نہیں ہوتے ہیں تو مستثنیات کو بڑھایا جاتا ہے۔اس سے ازگر میں پیشگی شرائط ، پوسٹ کنڈیشنس اور حملہ آوروں کو نافذ کرنے کے دعووں کے استعمال کا مظاہرہ ہوتا ہے۔ اوورال ، معاہدہ کے ذریعہ ڈیزائن ازگر میں سافٹ ویئر ڈویلپمنٹ کا ایک مفید طریقہ ہے جو سافٹ ویئر کے اجزاء کی درستگی اور مستقل مزاجی کو بہتر بنا سکتا ہے۔پیشگی شرائط ، پوسٹ کنڈیشنز ، اور حملہ آوروں کو ازگر میں دعووں کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے ، جو اس بات کو یقینی بنانے میں مدد فراہم کرسکتا ہے کہ سافٹ ویئر کے اجزاء صحیح اور مستقل طور پر برتاؤ کریں۔"
    },
    {
        "Question": "سست تشخیص کے تصور کی وضاحت کریں اور ازگر میں اس کے استعمال کی ایک مثال پیش کریں۔",
        "Answer": "سست تشخیص ایک پروگرامنگ کی حکمت عملی ہے جو اظہار کی تشخیص میں تاخیر کرتی ہے جب تک کہ اس کی قیمت کو 1234 کی ضرورت نہ ہو۔اس حکمت عملی کو اکثر ان افعال کے ساتھ مل کر استعمال کیا جاتا ہے جو اشیاء کے مجموعے تیار کرتے ہیں ، اور اس میں میموری کے انتظام اور فنکشن رن ٹائم 1234 کے لئے کارکردگی کے اہم مضمرات ہوسکتے ہیں۔ازگر میں ، جنریٹرز کا استعمال کرتے ہوئے سست تشخیص کو نافذ کیا جاسکتا ہے ، جو ایسے افعال کی طرح کام کرتے ہیں جو کسی قدر کو لوٹاتے ہیں لیکن جنریٹر 12 کو یکے بعد دیگرے کالوں پر اقدار کی جانشینی کو واپس کرنے کے لئے اپنی داخلی حالت کو یاد رکھیں۔جنریٹرز فنکشن پر مبنی ریٹرن کی ورڈ 12 کے بجائے کسی قدر کو آؤٹ پٹ کرنے کے لئے پیداوار کے مطلوبہ الفاظ کا استعمال کرتے ہیں۔ یہاں ازگر میں سست تشخیص کا استعمال کرنے کی ایک مثال ہے: پائیتھونڈف فبونیکی (): A ، B = 0 ، 1 جبکہ سچ: A A ، B = حاصل کریںB ، A + BFIB = fibonacci () I IN RAND (10) کے لئے: پرنٹ (اگلا (FIB)) اس مثال میں ، ایک جنریٹر فنکشن Fibonacci کی وضاحت کی گئی ہے جو Fibonacci ترتیب پیدا کرتی ہے۔پیداوار کی مطلوبہ الفاظ کو A کی قیمت کو آؤٹ پٹ کرنے کے لئے استعمال کیا جاتا ہے ، اور جنریٹر کی داخلی حالت کو ترتیب میں اگلی قیمت پیدا کرنے کے لئے اپ ڈیٹ کیا جاتا ہے۔اس کے بعد ایف آئی بی جنریٹر فبونیکی فنکشن کا استعمال کرتے ہوئے تخلیق کیا جاتا ہے ، اور ترتیب کی پہلی 10 اقدار اگلے فنکشن کا استعمال کرتے ہوئے پرنٹ کی جاتی ہیں۔اس سے جنریٹرز کا استعمال کرتے ہوئے ازگر میں سست تشخیص کے استعمال کو ظاہر ہوتا ہے۔جنریٹرز سست تشخیص کو نافذ کرنے کے لئے ازگر میں ایک طاقتور ٹول ہیں ، اور ان کا استعمال اشیاء کے ذخیرے کو موثر انداز میں اور کم سے کم میموری کے استعمال کے ساتھ تیار کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوز کا تعین کرنے کے طریقوں کے ساتھ میٹرکس کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوز کا تعین کرنے کے طریقوں کے ساتھ میٹرکس کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم پائیتھون 123456 میں نمی ماڈیول کا استعمال کرسکتے ہیں۔نیمپی ماڈیول میٹرکس اور میٹرکس آپریشنز کا ایک تیز اور موثر نفاذ فراہم کرتا ہے ، جو نمبروں کے ذخیرے کو ذخیرہ کرنے اور موثر میٹرکس آپریشنز 123456 انجام دینے کے لئے استعمال ہوتا ہے۔ یہاں نیپی ماڈیول کا استعمال کرتے ہوئے ازگر میں میٹرکس کلاس کا نفاذ ہے: پیتھونیمپورٹ نیپکاس مٹکس: Def __init __ (خود ، ڈیٹا): self.data = np.array (ڈیٹا) Def __str __ (خود): ریٹرن str (self.data) def __add __ (خود ، دوسرے)) ڈیف __mul __ (خود ، دوسرے): واپسی میٹرکس (np.dot (self.data ، other.data)) Def transpose (self): ریٹرن میٹرکس (self.data.transpose ()) اس عمل میں ، میٹرکس کلاس نمائندگی کرتا ہےایک میٹرکس ڈیٹا ڈھانچہ۔میٹرکس کلاس کا __init__ طریقہ ایک دیئے گئے ڈیٹا کے ساتھ میٹرکس کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔میٹرکس کلاس کا __str__ طریقہ میٹرکس کی سٹرنگ نمائندگی واپس کرنے کے لئے استعمال کیا جاتا ہے۔میٹرکس کلاس کا __add__ طریقہ دو میٹرکس کے مابین میٹرکس کے اضافے کو انجام دینے کے لئے استعمال کیا جاتا ہے۔میٹرکس کلاس کا __mul__ طریقہ دو میٹرکس کے مابین میٹرکس ضرب انجام دینے کے لئے استعمال ہوتا ہے۔میٹرکس کلاس کا ٹرانسپوز طریقہ میٹرکس پر ٹرانسپوز آپریشن انجام دینے کے لئے استعمال کیا جاتا ہے۔ یہاں میٹرکس کلاس کو کس طرح استعمال کیا جائے اس کی ایک مثال ہے: پائیٹونم 1 = میٹرکس ([[1 ، 2] ، [3 ، 4]]) ایم 2 =میٹرکس ([[5 ، 6] ، [7 ، 8]]) پرنٹ (ایم 1) # پرنٹس \"[[1 2] \\ n [3 4]]\" پرنٹ (ایم 2) # پرنٹس \"[[5 6] \\ n.پرنٹ (M1.transpose ()) # پرنٹس \"[[1 3] \\ n [2 4]]\" اس مثال میں ، میٹرکس کلاس کا استعمال کرتے ہوئے دو میٹرک M1 اور M2 تخلیق کیے گئے ہیں ، اور ان کی تار کی نمائندگی چھپی ہوئی ہے۔اس کے بعد میٹرکس کے اضافے اور ضرب کو بالترتیب + اور * آپریٹرز کا استعمال کرتے ہوئے انجام دیا جاتا ہے ، اور نتائج پرنٹ ہوتے ہیں۔اس کے بعد ٹرانسپوز آپریشن ٹرانسپوز کے طریقہ کار کا استعمال کرتے ہوئے M1 پر انجام دیا جاتا ہے ، اور اس کا نتیجہ پرنٹ ہوتا ہے۔یہ ازگر میں میٹرکس کلاس کے استعمال کو ظاہر کرتا ہے جس میں میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوز آپریشنز ہیں۔مختلف ایپلی کیشنز ، جن میں لکیری الجبرا اور مشین لرننگ شامل ہیں"
    },
    {
        "Question": "پہلو پر مبنی پروگرامنگ (اے او پی) کے تصور پر تبادلہ خیال کریں اور یہ کس طرح ازگر کی ایپلی کیشنز میں کراس کٹنگ کے خدشات کو دور کرنے کے لئے لاگو کیا جاسکتا ہے۔",
        "Answer": "پہلو پر مبنی پروگرامنگ (اے او پی) ایک پروگرامنگ پیراڈیم ہے جس کا مقصد سافٹ ویئر ڈویلپمنٹ 123456 میں کراس کٹنگ کے خدشات کو دور کرنا ہے۔کراس کٹنگ کے خدشات خصوصیات یا تقاضے ہیں جو سافٹ ویئر سسٹم کے متعدد حصوں کو متاثر کرتے ہیں ، جیسے لاگنگ ، سیکیورٹی ، اور غلطی سے ہینڈلنگ 123456۔اے او پی ان خدشات کو پروگرام کی مرکزی منطق سے الگ کرتا ہے اور ان کو الگ الگ ماڈیولز میں شامل کرتا ہے جسے پہلوؤں 123456 کہتے ہیں۔پہلوؤں کا اطلاق پروگرام کے متعدد حصوں پر کیا جاسکتا ہے جس کا استعمال کرتے ہوئے ایک تکنیک کا استعمال کیا جاسکتا ہے ، جو مخصوص پوائنٹس 123456 پر مرکزی پروگرام کوڈ میں پہلو کوڈ داخل کرتا ہے۔ڈیکوریٹرز ازگر کی ایک بلٹ ان خصوصیت ہیں جو افعال اور کلاسز 245 کے طرز عمل میں ترمیم کرنے کے لئے استعمال کی جاسکتی ہیں۔میٹاکلاسس ازگر کی ایک خصوصیت ہے جو مخصوص طرز عمل 125 کے ساتھ کسٹم کلاس بنانے کی اجازت دیتی ہے۔لائبریریاں ، جیسے B3J0F.AOP اور orsinium-labs/AOP ، Python13 میں AOP کا زیادہ جامع نفاذ فراہم کرتی ہیں۔ یہاں ازگر میں AOP کو نافذ کرنے کے لئے سجاوٹ کا استعمال کرنے کی ایک مثال ہے: Pythondef Log (Func): Def ریپر ( *آرگس ، **KWARGS): پرنٹ (f \"کالنگ فنکشن {func .__ name__}\") ریٹرن فنک (*آرگس ، ** Kwargs) ریٹرن ریپر@لاگ ڈیف شامل کریں (a ، b): a + bprint واپس کریں (شامل کریں (1 ، 2))# پرنٹس \"کالنگ فنکشن ایڈ\" اور \"3\" اس مثال میں ، ایک لاگ ڈیکوریٹر کی وضاحت کی گئی ہے جو کسی فنکشن کے نفاذ سے پہلے اور اس کے بعد کوئی پیغام پرنٹ کرتا ہے۔اس کے بعد لاگ ڈیکوریٹر کو @ نحو کا استعمال کرتے ہوئے ADD فنکشن پر لاگو کیا جاتا ہے ، جو لاگنگ پیغامات کو شامل کرنے کے لئے ADD فنکشن کے طرز عمل میں ترمیم کرتا ہے۔اس کے بعد ADD فنکشن کو دو دلائل کے ساتھ بلایا جاتا ہے ، اور لاگنگ پیغامات اور فنکشن کا نتیجہ پرنٹ کیا جاتا ہے۔یہ ازگر میں اے او پی کو نافذ کرنے کے لئے سجاوٹ کے استعمال کو ظاہر کرتا ہے۔سجاوٹ ، میٹاکلاسس ، اور لائبریریوں کو ازگر میں اے او پی کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے ، اور وہ سافٹ ویئر سسٹم کی ماڈیولریٹی ، برقرار رکھنے اور توسیع کو بہتر بنانے میں مدد کرسکتے ہیں۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں ٹیمپلیٹ کے طریقہ کار کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "ٹیمپلیٹ کے طریقہ کار کا نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو بیس کلاس میں الگورتھم کے کنکال کی وضاحت کرتا ہے اور ذیلی طبقات کو اس کی مجموعی ڈھانچے 123456 کو تبدیل کیے بغیر الگورتھم کے کچھ مراحل کو اوور رائڈ کرنے کی اجازت دیتا ہے۔ٹیمپلیٹ کے طریقہ کار کا نمونہ ایک عام الگورتھم بنانے کے لئے مفید ہے جسے مخصوص استعمال کے معاملات میں سبکلاسس 123456 کے ذریعہ اپنی مرضی کے مطابق بنایا جاسکتا ہے۔ٹیمپلیٹ کے طریقہ کار کو ایک تجریدی بیس کلاس کا استعمال کرتے ہوئے نافذ کیا جاتا ہے جو مجموعی طور پر الگورتھم اور کنکریٹ کے ذیلی طبقات کی وضاحت کرتا ہے جو الگورتھم 123456 کے مخصوص اقدامات کو نافذ کرتے ہیں۔): ڈیف ایگزیکٹو (خود): سیلف.ایسپ 1 () سیلف.سٹیپ 2 () سیلف.سٹیپ 3 () @abc.abstractmethod def step1 (self): پاس @abc.abstractmethod def step2 (خود)مرحلہ 3 (): پاسکلاس کونسٹریٹیلگوریتھم 1 (الگورتھم): ڈیف مرحلہ 1 (خود): پرنٹ (\"کانکریٹیلگوریتھم 1: مرحلہ 1\") ڈی ای ایف مرحلہ 2 (خود): پرنٹ (\"کانکریٹیلگوریتھم 1: مرحلہ 2\") ڈی ای ایف 3 (خود): پرنٹ (پرنٹ (\"پرنٹ (\"۔CONCRETEALGORITHM1: مرحلہ 3 \") کلاس CONCRETEALGORITHM2 (الگورتھم): DEF مرحلہ 1 (خود): پرنٹ (\" CONCRETEALGORITHM2: مرحلہ 1 \") DEF مرحلہ 2 (خود): پرنٹ (\" CONCRETEALGORITHM2: مرحلہ 2 \") DEF مرحلہ 3 (خود پرنٹ (خود)\"کنکریٹیلگوریتھم 2: مرحلہ 3\") الگوریتھم 1 = کانکریٹیلگوریتھم 1 () الگوریتھم 1۔ٹیکسیٹ () الگوریتھم 2 = کونٹیلگوریتھم 2 () الگوریتھم 2۔ٹیکسیکیٹ () اس مثال کے طور پر ، ایک خلاصہ بیس کلاس الگوریتھ کی نمائندگی کی گئی ہے۔الگورتھم کلاس کے عملدرآمد کا طریقہ تین قدموں کو ترتیب سے کال کرکے الگورتھم کو عملی جامہ پہنانے کے لئے استعمال ہوتا ہے۔الگورتھم کلاس کے مرحلہ 1 ، مرحلہ 2 ، اور مرحلہ 3 کے طریقے خلاصہ طریقے ہیں جن کو کنکریٹ کے ذیلی طبقات کے ذریعہ نافذ کرنا ضروری ہے۔دو کنکریٹ سبکلاسز کنکریٹیلگوریتھم 1 اور کنکریٹیلگوریتھم 2 کی وضاحت کی گئی ہے جو الگورتھم کے مخصوص اقدامات کو نافذ کرتے ہیں۔اس کے بعد ہر کنکریٹ کے ذیلی طبقے پر عمل کرنے کا طریقہ طلب کیا جاتا ہے تاکہ اس ذیلی طبقے کے ذریعہ نافذ کردہ مخصوص اقدامات کے ساتھ الگورتھم کو عملی جامہ پہنایا جاسکے۔اس سے ازگر میں ٹیمپلیٹ کے طریقہ کار کے استعمال کو ظاہر ہوتا ہے۔ٹیمپلیٹ کے طریقہ کار کا نمونہ مجموعی الگورتھم کو اپنے مخصوص اقدامات سے الگ کرکے سافٹ ویئر سسٹم کی ماڈیولریٹی ، برقرار رکھنے اور توسیع کو بہتر بنانے میں مدد کرسکتا ہے۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جو سرکلر دوگنا منسلک فہرست کی نمائندگی کرتا ہے اور اندراج ، حذف کرنے اور ٹراورسل کے طریقے فراہم کرتا ہے۔\"",
        "Answer": "دوگنا منسلک فہرست کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے اور اندراج ، حذف کرنے اور ٹریورسل کے طریقے فراہم کرنے کے ل we ، ہم سانفاؤنڈری ویب سائٹ 1 سے سرکولارڈبل لنکڈ لسٹ کلاس استعمال کرسکتے ہیں۔سرکلرڈبللی لنکڈ لسٹ کلاس ایک سرکلر دوگنا منسلک فہرست کے اعداد و شمار کے ڈھانچے کا ایک تیز اور موثر نفاذ فراہم کرتی ہے ، جو نوڈس کے ذخیرہ کرنے اور موثر آپریشنز کو انجام دینے کے لئے استعمال ہوتی ہے۔: پائیتھونکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹا = ڈیٹا سیلف۔ نیکسٹ = کوئی بھی نہیں۔ خود نہیں۔نوڈ (ڈیٹا) اگر self.first کوئی بھی نہیں ہے: self.first = new_node new_node.next = new_node new_node.prev = new_nod.prev = آخری آخری۔ نیکسٹ = new_node sellورنہ: آخری = self.first.prev new_node.next = self.first self.first.prev = new_node new_node.prev = آخری آخری۔ نیکسٹ = new_node def ہٹائیں (خود ، نوڈ): اگر خود نہیں ہے: واپسی کوئی نہیں ہے: اگر واپسی نہیں ہے توself.first == نوڈ: اگر self.first.next == self.first: self.first = کوئی اور نہیں: آخری = self.first.prev self.first = self.first.next self.first.prev = آخری آخری.next = self.first else: prev = node.prev next = node.next prev.next = اگلا. prev = prev def display (self): اگر sellپرنٹ (کرنٹ ڈاٹ ڈیٹا) موجودہ = موجودہ۔ نیکسٹ اگر موجودہ == سیلف۔ فرسٹ: اس عمل کو توڑنے کے بعد ، نوڈ کلاس سرکلر ڈبل سے منسلک فہرست کے اعداد و شمار کے ڈھانچے میں ایک نوڈ کی نمائندگی کرتی ہے۔سرکولارڈبل لنکڈ لسٹ کلاس سرکلر دوگنا منسلک فہرست کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے۔سرکلر ڈویل لنکڈ لسٹ کلاس کا __init__ طریقہ سرکلر دوگنا لنکڈ فہرست کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔سرکولارڈبللی لنکڈ لسٹ کلاس کا INSERT_AT_BEG طریقہ فہرست کے آغاز میں نوڈ داخل کرنے کے لئے استعمال ہوتا ہے۔سرکولرڈوبلی لنکڈ لسٹ کلاس کا داخل_ایٹ_ینڈ طریقہ فہرست کے آخر میں نوڈ داخل کرنے کے لئے استعمال ہوتا ہے۔سرکولارڈبللی لنکڈ لسٹ کلاس کا ہٹانے کا طریقہ فہرست سے نوڈ کو ہٹانے کے لئے استعمال کیا جاتا ہے۔سرکولارڈبل لنکڈ لسٹ کلاس کے ڈسپلے کا طریقہ فہرست کو عبور کرنے اور ہر نوڈ کے ڈیٹا کو پرنٹ کرنے کے لئے استعمال کیا جاتا ہے۔ یہاں سرکلرڈوبلی لنکڈ لسٹ کلاس کو استعمال کرنے کی ایک مثال ہے: پائیتھونک ڈیل = سرکلرڈول لنکڈ لسٹ () CDLL.INSERT_BEG (1) CDLL.INSET_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_AT_Tcdll.insert_at_end (3) cdll.insert_at_end (4) cdll.display () # پرنٹس \"2 1 3 4\" cdll.remove (cdll.first.next) cdll.display () # پرنٹس \"2 3 4\" اس مثال میں، سرکلر دوگنا لنکڈ لسٹ لسٹ لنک لنک لسٹ کلاس کا استعمال کرتے ہوئے تیار کیا جاتا ہے ، اور نوڈس داخل_ٹ_بیگ اور داخل_ایٹ_ینڈ طریقوں کا استعمال کرتے ہوئے فہرست کے آغاز اور اختتام پر داخل کیا جاتا ہے۔اس کے بعد ہر نوڈ کے ڈیٹا کو فہرست میں پرنٹ کرنے کے لئے ڈسپلے کا طریقہ کہا جاتا ہے۔اس کے بعد ایک نوڈ کو ہٹانے کے طریقہ کار کا استعمال کرتے ہوئے فہرست سے ہٹا دیا جاتا ہے ، اور تازہ ترین فہرست کو پرنٹ کرنے کے لئے ڈسپلے کا طریقہ دوبارہ بلایا جاتا ہے۔اس سے یہ ظاہر ہوتا ہے کہ اندراج ، حذف کرنے ، اور ٹریورسل آپریشنز کے ساتھ ازگر میں سرکلر دوگنا منسلک فہرست کے استعمال کو ظاہر کیا جاتا ہے۔، ویڈیو بفرنگ ، اور پرنٹر جاب شیڈولنگ 1SANFOUNDRY"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں وزیٹر پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "زائرین کا نمونہ سافٹ ویئر ڈیزائن میں طرز عمل کے ڈیزائن کا نمونہ ہے جو ڈھانچے 123456 میں ترمیم کیے بغیر موجودہ آبجیکٹ ڈھانچے میں نئی کارروائیوں کو شامل کرنے کی اجازت دیتا ہے۔زائرین کا نمونہ الگورتھم کو آبجیکٹ کے ڈھانچے سے الگ کرتا ہے ، جس کی وجہ سے کلاس 123456 کو تبدیل کیے بغیر آبجیکٹ کے ڈھانچے میں نئی کارروائیوں کو شامل کرنا ممکن ہوجاتا ہے۔زائرین کا نمونہ دو اہم اجزاء کا استعمال کرتے ہوئے نافذ کیا جاتا ہے: وزیٹر اور عنصر 123456۔وزیٹر ایک انٹرفیس یا تجریدی کلاس ہے جو عنصر آبجیکٹ 123456 پر انجام دینے والی کارروائیوں کی وضاحت کرتا ہے۔عنصر ایک انٹرفیس یا تجریدی طبقے کی وضاحت کرتا ہے جو ایک وزٹرز آبجیکٹ کو قبول کرتا ہے اور وزٹر آبجیکٹ 123456 پر مناسب طریقہ کو کال کرتا ہے۔ یہاں ازگر میں وزیٹر پیٹرن کا ایک مثال ہے: ازگریمپورٹ اے بی سی سی ایل اے ایس سی عنصر (میٹاکلاس = اے بی سی۔ اے بی سی ایم ای ٹی اے۔): @abc.abstractmethod def قبول کریں (خود ، وزٹر): پاسکلاس کنکریٹیلیمنٹا (عنصر): ڈیف قبول کریں (خود ، وزٹر): وزٹر.ویسیٹ_کونکریٹ_ایلیمنٹ_ا (سیلف) ڈیف آپریشن_ا (خود): پاسکلاس کنکریٹیلیمنٹ بی (عنصر): ڈیف قبول (خود قبول (خود قبول).: پاسکلاس کا concretevisitor1 (ملاحظہ کرنے والا): Def وزٹ_کونکریٹ_یلیمنٹ_ا (خود ، عنصر): عنصر.اپریشن_ا () ڈیف وزٹ_کنسٹریٹ_یلیمنٹ_ب (خود ، عنصر): عنصر.اپریشن_ب () کلاس کنکریٹ ویسٹر 2 (وزٹر).۔دو کنکریٹ عناصر کنکریٹیلیمنٹا اور کنکریٹیلیمنٹ بی کی وضاحت کی گئی ہے جو عنصر انٹرفیس اور قبول طریقہ کو نافذ کرتے ہیں۔دو کنکریٹ زائرین کونسٹریٹ ویزیٹر 1 اور کنکریٹ ویزیٹر 2 کی وضاحت کی گئی ہے جو وزٹر انٹرفیس اور وزٹ_کنسکریٹ_ایلیمنٹ_ا اور وزٹ_کونکریٹ_یلیمنٹ_بی طریقوں کو نافذ کرتے ہیں۔اس کے بعد عناصر کی فہرست اور زائرین کی فہرست بنائی جاتی ہے ، اور ہر ایک ملاحظہ کرنے والے کے ساتھ ہر عنصر پر قبول کرنے کا طریقہ طلب کیا جاتا ہے۔اس سے ازگر میں زائرین کے نمونے کے استعمال کو ظاہر ہوتا ہے۔وزٹرز کا نمونہ الگورتھم کو آبجیکٹ ڈھانچے سے الگ کرکے سافٹ ویئر سسٹم کی ماڈیولریٹی ، برقرار رکھنے اور توسیع کو بہتر بنانے میں مدد کرسکتا ہے۔"
    },
    {
        "Question": "رد عمل کے پروگرامنگ کے اصولوں پر تبادلہ خیال کریں اور یہ کہ ان کو کس طرح ازگر میں RXPY جیسی لائبریریوں کا استعمال کیا جاسکتا ہے۔",
        "Answer": "رد عمل پروگرامنگ ایک پروگرامنگ نمونہ ہے جو غیر متزلزل ڈیٹا اسٹریمز اور ان اسٹریمز 123456 کے ذریعے تبدیلیوں کے پھیلاؤ پر مرکوز ہے۔رد عمل پروگرامنگ کچھ اہم اصولوں پر مبنی ہے ، بشمول مشاہدہ کرنے والے ، مبصرین/صارفین ، اور مضامین 123456۔مشاہدہ کرنے والے اعداد و شمار کے ایک سلسلے کی نمائندگی کرتے ہیں جس کا مشاہدہ کیا جاسکتا ہے ، جب اعداد و شمار میں تبدیلی آتی ہے تو مبصرین/صارفین کو مطلع کیا جاتا ہے ، اور مضامین ایک مشاہدہ کرنے والے اور ایک مبصر 123456 دونوں کے طور پر کام کرتے ہیں۔ری ایکٹو پروگرامنگ غیر متزلزل ڈیٹا اسٹریمز ، واقعہ پر مبنی پروگراموں ، اور ڈیٹا اسٹریمز 123456 کے متوازی پروسیسنگ کے ل useful مفید ہے۔آر ایکس پی وائی پیتھون 3456 میں مشاہدہ کرنے والے مجموعوں اور پائپ ایبل استفسار آپریٹرز کا استعمال کرتے ہوئے غیر متزلزل اور واقعہ پر مبنی پروگراموں کو تحریر کرنے کے لئے ایک لائبریری ہے۔RXPY رد عمل کے پروگرامنگ کے ساتھ کام کرنے کے لئے مشاہدہ کرنے والوں کا استعمال کرتا ہے جو غیر متزلزل ڈیٹا کالز ، کال بیکس ، اور ایونٹ پر مبنی پروگراموں 4 سے متعلق ہے۔آر ایکس پی وائی ریاضی ، تبدیلی ، فلٹرنگ ، افادیت ، مشروط ، غلطی سے نمٹنے ، اور ان زمروں میں شامل ہونے والے قسموں میں آپریٹرز کا ایک بہت بڑا ذخیرہ پیش کرتا ہے جو رد عمل پروگرامنگ 4 کے ساتھ استعمال ہونے پر زندگی کو آسان بناتا ہے۔RXPY کو طاقتور رد عمل کی ایپلی کیشنز کی تعمیر اور مختلف پلیٹ فارمز 5 پر تعینات کرنے کے لئے استعمال کیا جاسکتا ہے۔ یہاں ازگر میں رد عمل پروگرامنگ کو نافذ کرنے کے لئے RXPY استعمال کرنے کی ایک مثال ہے: ازگرفوم RX درآمد مشاہدہ شدہ پرنٹ_نمبر (X): پرنٹ (\"موصولہ: {}\". فارمیٹ (فارمیٹ (فارمیٹ (فارمیٹ (\"x)) xs = مشاہدہ کرنے والا۔اس کے بعد سبسکرائب کرنے کا طریقہ کار پرنٹ_نمبر کے ساتھ مشاہدہ کرنے والے پر بلایا جاتا ہے جو موصولہ قیمت کو پرنٹ کرتا ہے۔قابل مشاہدہ رینج میں موجود اقدار کو خارج کرتا ہے ، اور ہر قیمت کے لئے پرنٹ_نمبر فنکشن بلایا جاتا ہے۔یہ ازگر میں رد عمل پروگرامنگ کو نافذ کرنے کے لئے RXPY کے استعمال کو ظاہر کرتا ہے۔RXPY جیسی لائبریریاں ازگر میں رد عمل پروگرامنگ کا ایک جامع عمل درآمد کرتی ہیں ، جو سافٹ ویئر سسٹم کی کارکردگی ، ماڈیولریٹی اور برقرار رکھنے میں مدد کرسکتی ہیں۔"
    },
    {
        "Question": "\"بائنری من میکس کے ڈھیر کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور اندراج ، حذف کرنے ، اور کم سے کم اور زیادہ سے زیادہ عناصر کی تلاش کے طریقے فراہم کریں۔\"",
        "Answer": "بائنری من میکس کے ڈھیر کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے اور اندراج ، حذف کرنے ، اور کم سے کم اور زیادہ سے زیادہ عناصر کی تلاش کے طریقے فراہم کرنے کے ل we ، ہم ازگر 123 میں ہیپ کیو ماڈیول کا استعمال کرسکتے ہیں۔ہیپ کیو ماڈیول ہیپس اور ہیپ کی کارروائیوں کا ایک تیز اور موثر عمل درآمد فراہم کرتا ہے ، جو عناصر کے ذخیرہ کرنے اور موثر ہیپ آپریشنز 123 کو انجام دینے کے لئے استعمال ہوتا ہے۔ یہاں ہیپ کیو ماڈیول کا استعمال کرتے ہوئے ازگر میں بائنری من میکس ہیپ ڈیٹا ڈھانچے کا ایک مثال ہے۔پائیتھونیمپورٹ ہیپقکلاس بائنری مینماکس ایچ ای اے پی: ڈیف __init __ (خود): سیلف۔ ہیپ = [] ڈیف داخل کریں (خود ، قدر): ہیپ کیو۔ ہیپش (سیلف۔ ہیپ ، ویلیو) ڈیف ڈیلیٹ_مین (خود)Find_min (خود): واپس لوٹیں۔ ہیپ [0] Def find_max (خود): واپسی میکس (سیلف۔ ہیپ) ڈیف ڈیلیٹ_میکس (خود): زیادہ سے زیادہ_ index = sell.POP (MAX_INDEX) اس نفاذ میں ، بائنری منیمیکس ہیپ کلاس بائنری من میکس ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔بائنری مینماکسہپ کلاس کا __init__ طریقہ ڈھیر کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔بائنری مینماکسہپ کلاس کا داخل کرنے کا طریقہ ڈھیر میں ایک قدر داخل کرنے کے لئے استعمال ہوتا ہے۔بائنری مینماکسہپ کلاس کا حذف_من طریقہ ڈھیر سے کم سے کم قیمت کو حذف کرنے کے لئے استعمال کیا جاتا ہے۔بائنری مینماکسہپ کلاس کا Find_min طریقہ ڈھیر میں کم سے کم قیمت تلاش کرنے کے لئے استعمال کیا جاتا ہے۔بائنری مینماکسہپ کلاس کا Find_max طریقہ ڈھیر میں زیادہ سے زیادہ قیمت تلاش کرنے کے لئے استعمال کیا جاتا ہے۔بائنری مینماکس ہیڈ کلاس کا حذف کریں۔.\"3\" ہیپ.ڈیلیٹ_میکس () پرنٹ (ہیپ.فند_میکس ()) # پرنٹس \"5\" اس مثال میں ، بائنری من میکس ہیپ بائنری مینماکسہپ کلاس کا استعمال کرتے ہوئے تخلیق کیا جاتا ہے ، اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے قدروں کو ڈھیر میں داخل کیا جاتا ہے۔اس کے بعد ڈھیر میں بالترتیب کم سے کم اور زیادہ سے زیادہ اقدار تلاش کرنے کے لئے Find_min اور find_max طریقوں کو بلایا جاتا ہے۔اس کے بعد حذف کریں_من اور حذف کریں_میکس طریقوں کو بالترتیب ڈھیر سے کم سے کم اور زیادہ سے زیادہ اقدار کو حذف کرنے کے لئے بلایا جاتا ہے ، اور ڈھیر میں ہونے والی تبدیلیوں کی تصدیق کے لئے Find_min اور find_max طریقوں کو دوبارہ بلایا جاتا ہے۔اس سے ازگر میں بائنری من میکس ڈھیر کے استعمال کو ظاہر کرتا ہے جس میں اندراج ، حذف کرنے ، اور کم سے کم اور زیادہ سے زیادہ عنصر کی کارروائیوں کی تلاش ہوتی ہے۔، جو مختلف ایپلی کیشنز کے لئے استعمال کیا جاسکتا ہے ، بشمول چھانٹ رہا ہے ، گراف الگورتھم ، اور ترجیحی قطاریں۔"
    },
    {
        "Question": "ازگر میں طریقہ سجاوٹ کے تصور کی وضاحت کریں اور اس کی مثالیں فراہم کریں کہ ان کو طریقوں میں طرز عمل کو شامل کرنے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "طریقہ کار ڈیکوریٹرز اس کے ماخذ کوڈ 123456 کو تبدیل کیے بغیر ازگر میں کسی فنکشن یا طریقہ کار کے طرز عمل میں ترمیم کرنے یا بڑھانے کا ایک طریقہ ہے۔سجاوٹ خود ایسے کام ہیں جو دوسرے افعال یا طریقوں کو لپیٹنے کے لئے استعمال ہوسکتے ہیں ، ان میں 123456 میں کچھ اضافی فعالیت شامل کرتے ہیں۔ایک ڈیکوریٹر ایک فنکشن یا طریقہ کار کو ان پٹ کے طور پر لیتا ہے اور کسی اور فنکشن یا طریقہ کار کو آؤٹ پٹ کے طور پر لوٹاتا ہے ، جو اصل فنکشن یا طریقہ کار کی جگہ پر استعمال کیا جاسکتا ہے ، جس میں ڈیکوریٹر 123456 کے ذریعہ فراہم کردہ کوئی اضافی فعالیت ہے۔ڈیکوریٹرز کو لاگنگ ، ٹائمنگ ، کیچنگ ، اور توثیق 123456 جیسے کاموں کے لئے استعمال کیا جاسکتا ہے۔ یہاں ازگر میں کسی طریقہ کار میں طرز عمل کو شامل کرنے کے لئے طریقہ کار کو استعمال کرنے کی ایک مثال ہے: پائیتھنڈف مائی_ ڈیکوریٹر (فنک): ڈیف ریپر (*آرگس ، ** کوورگس): پرنٹ (\"فنکشن سے پہلے کہا جاتا ہے۔\") نتیجہ = فنک (*آرگس ، ** کوورگس) پرنٹ (\"فنکشن کے بعد کہا جاتا ہے۔\") ریٹرن ریٹرن ریٹرن ریپرکلاس مائکلاس: @my_decorator def my_method (خود ، x ، x ،Y): واپسی x + YOBJ = MyClass () پرنٹ (Obj.my_method (1 ، 2)) # پرنٹس \"فنکشن کو کہا جانے سے پہلے۔\" ، \"فنکشن کے نام سے پکارنے کے بعد۔\" ، اور اس مثال میں \"3\" ،ایک طریقہ کار ڈیکوریٹر my_decorator کی وضاحت کی گئی ہے جو کسی طریقہ پر عمل درآمد سے پہلے اور اس کے بعد ایک پیغام پرنٹ کرتا ہے۔اس کے بعد my_decorator سجاوٹ @ Syntax کا استعمال کرتے ہوئے MyClass کلاس کے My_method طریقہ پر لاگو ہوتا ہے ، جو لاگنگ پیغامات کو شامل کرنے کے لئے My_method کے طریقہ کار کے طرز عمل میں ترمیم کرتا ہے۔اس کے بعد مائکلاس کلاس کی ایک مثال بنائی گئی ہے ، اور میرا_میتھوڈ طریقہ دو دلائل کے ساتھ بلایا جاتا ہے ، اور لاگنگ پیغامات اور اس طریقہ کار کا نتیجہ پرنٹ کیا جاتا ہے۔اس سے کسی طریقہ کار میں طرز عمل کو شامل کرنے کے لئے ازگر میں ایک طریقہ کار ڈیکوریٹر کے استعمال کو ظاہر ہوتا ہے۔ اس کے علاوہ ، طریقہ کار سجاوٹ ازگر میں ایک مفید خصوصیت ہے جو اس کے ماخذ کوڈ کو تبدیل کیے بغیر کسی فنکشن یا طریقہ کار کے طرز عمل میں ترمیم کرنے یا بڑھانے کے لئے استعمال کی جاسکتی ہے۔طریقہ کار ڈیکوریٹرز اضافی فعالیت کو اصل فنکشن یا طریقہ کار سے الگ کرکے سافٹ ویئر سسٹم کی ماڈیولریٹی ، برقرار رکھنے اور توسیع کو بہتر بنانے میں مدد کرسکتے ہیں۔"
    },
    {
        "Question": "ازگر میں متوازی پروسیسنگ کے تصور پر تبادلہ خیال کریں اور یہ بتائیں کہ کس طرح ملٹی پروسیسنگ اور ملٹی تھریڈنگ کو استعمال کیا جاسکتا ہے۔",
        "Answer": "متوازی پروسیسنگ ایک پروگرامنگ تکنیک ہے جو متعدد کاموں کو کمپیوٹر سسٹم میں بیک وقت ایک سے زیادہ پروسیسرز یا کوریس 123456 کے ساتھ عمل میں لانے کی اجازت دیتی ہے۔متوازی پروسیسنگ کاموں کے پروسیسنگ کے مجموعی وقت کو کم کرکے اور ڈیٹا 123456 کے ان پٹ کو بڑھا کر سافٹ ویئر سسٹم کی کارکردگی اور کارکردگی کو بہتر بنانے میں مدد کرسکتی ہے۔ازگر میں ، متوازی پروسیسنگ کو دو اہم تکنیکوں کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے: ملٹی پروسیسنگ اور ملٹی تھریڈنگ 123456. ملٹی پروسیسنگ: ملٹی پروسیسنگ ایک ایسی تکنیک ہے جس میں متوازی طور پر متعدد عمل چلانا شامل ہے ، جس میں ہر ایک اپنی میموری کی جگہ اور پائیٹن انٹرپریٹر 123456 ہے۔ازگر میں ملٹی پروسیسنگ ماڈیول متعدد عملوں کو بنانے اور ان کا نظم و نسق کرنے کا ایک آسان اور موثر طریقہ فراہم کرتا ہے ، اور اسے سی پی یو سے منسلک کمپیوٹرز ، I/O پابند کاموں ، اور نیٹ ورک سے منسلک آپریشنز 123456 جیسے کاموں کے لئے استعمال کیا جاسکتا ہے۔ملٹی پروسیسنگ ماڈیول عمل ، تالاب ، اور قطار 123456 جیسے عمل کو تخلیق کرنے اور ان کے انتظام کے ل various مختلف کلاسوں اور افعال کو مہیا کرتا ہے۔ ملٹی تھریڈنگ: ملٹی تھریڈنگ ایک ایسی تکنیک ہے جس میں ایک ہی عمل کے اندر متوازی طور پر متعدد دھاگے چلانا شامل ہے ، اسی میموری کی جگہ اور پائیٹن انٹرپریٹر 123456 کا اشتراک کرنا ہے۔ازگر میں تھریڈنگ ماڈیول متعدد دھاگوں کو بنانے اور ان کا نظم کرنے کا ایک آسان اور موثر طریقہ فراہم کرتا ہے ، اور یہ I/O پابند کاموں اور نیٹ ورک سے منسلک آپریشنز 123456 کے متوازی کاموں کے لئے استعمال کیا جاسکتا ہے۔تھریڈنگ ماڈیول تھریڈ ، لاک ، اور سیمفور 123456 جیسے دھاگوں کی تشکیل اور انتظام کے ل various مختلف کلاسوں اور افعال کو مہیا کرتا ہے۔ یہاں متوازی پروسیسنگ کو نافذ کرنے کے لئے ازگر میں ملٹی پروسیسنگ ماڈیول کو استعمال کرنے کی ایک مثال ہے: پائیتھونیمپورٹ ملٹی پروسیسنگ ڈیف اسکوائر (X): واپسی X * XIF__name__ == '__main__': ملٹی پروسیسنگ.پول () کے ساتھ پول کے طور پر: نتیجہ = پول۔ میپ (مربع ، رینج (10)) پرنٹ (نتیجہ) اس مثال میں ، مربع فنکشن کو کسی تعداد کے مربع کی گنتی کے لئے بیان کیا گیا ہے۔اس کے بعد ملٹی پروسیسنگ۔ پول کلاس کو کارکنوں کے عمل کا ایک تالاب بنانے کے لئے استعمال کیا جاتا ہے ، اور نقشہ کا طریقہ متوازی طور پر متعدد تعداد میں مربع فنکشن کو لاگو کرنے کے لئے استعمال کیا جاتا ہے۔اس کے بعد گنتی کا نتیجہ کنسول پر چھپا جاتا ہے۔یہ متوازی پروسیسنگ کو نافذ کرنے کے لئے ازگر میں ملٹی پروسیسنگ ماڈیول کے استعمال کو ظاہر کرتا ہے۔ اوورال ، متوازی پروسیسنگ ازگر میں ایک مفید تکنیک ہے جسے سافٹ ویئر سسٹم کی کارکردگی اور کارکردگی کو بہتر بنانے کے لئے استعمال کیا جاسکتا ہے۔ملٹی پروسیسنگ اور تھریڈنگ ماڈیولز ازگر میں متوازی پروسیسنگ کو نافذ کرنے کے لئے آسان اور موثر طریقے مہیا کرتے ہیں ، جو مختلف کاموں جیسے سی پی یو سے منسلک کمپیوٹیشن ، I/O- پابند کاموں ، اور نیٹ ورک سے منسلک آپریشنز کے لئے استعمال ہوسکتے ہیں۔"
    },
    {
        "Question": "ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے طریقے فراہم کریں۔",
        "Answer": "ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے اور کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے طریقے فراہم کرنے کے ل we ، ہم 1234 میں بیان کردہ الگورتھم کو استعمال کرسکتے ہیں۔الگورتھم گراف سے آنے والے کناروں کے بغیر بار بار نوڈس کو ہٹا کر اور ان کے سبکدوش ہونے والے کناروں کو ہٹانے کے ساتھ ساتھ ان کو ٹاپولوجیکل آرڈر میں شامل کرکے کام کرتا ہے۔اگر گراف میں ایک سائیکل ہے تو ، الگورتھم ایک ٹاپولوجیکل آرڈر تیار نہیں کر سکے گا۔ یہاں ایک ازگر کلاس کا ایک مثال ہے جو ڈی اے جی کی نمائندگی کرتا ہے اور کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے لئے ایک طریقہ فراہم کرتا ہے: ازگر کلاس ڈی اے جی: ڈیف __init __ (خود).: in_degree = {نوڈ: 0 نوڈ کے لئے سیل۔ گراف} نوڈ میں نوڈ کے لئے۔ گراف میں: خود پڑوسی کے لئے۔۔== 0: قطار.ایپینڈ (پڑوسی) اگر لین (ٹاپ_آرڈر)! = لین (سیلف گراف): ویلیو ایرر (\"گراف میں کم از کم ایک سائیکل ہے\") ریٹرن ٹاپ_ورڈرین اس عمل کو ، ڈی اے جی کلاس ہدایت شدہ ایسائکلک گراف ڈیٹا کی نمائندگی کرتا ہے۔ساخت.ڈی اے جی کلاس کا __init__ طریقہ گراف کو شروع کرنے کے لئے استعمال کیا جاتا ہے۔ڈی اے جی کلاس کا ADD_EDGE طریقہ گراف میں دو نوڈس کے درمیان ایک کنارے شامل کرنے کے لئے استعمال ہوتا ہے۔ڈی اے جی کلاس کا ٹاپولوجیکل_سورٹ طریقہ کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹ رہا ہے۔IN_DEGERE لغت ہر نوڈ کے آنے والے کناروں کو ٹریک رکھنے کے لئے استعمال کیا جاتا ہے ، اور قطار میں آنے والے کناروں کے نوڈس کو ذخیرہ کرنے کے لئے استعمال کیا جاتا ہے۔جبکہ لوپ کا استعمال بار بار گراف سے آنے والے کناروں کے بغیر نوڈس کو دور کرنے اور ان کے سبکدوش ہونے والے کناروں کو ہٹانے کے ساتھ ساتھ ان کو ٹاپولوجیکل آرڈر میں شامل کرنے کے لئے استعمال کیا جاتا ہے۔اگر گراف میں ایک سائیکل ہے تو ، ایک ویلیئرر اٹھایا جاتا ہے۔ یہاں ڈی اے جی کلاس کو کس طرح استعمال کرنے کی ایک مثال ہے: پائیتھونگگ = ڈی اے جی () ڈی اے جی۔ ایڈ_ج ('اے' ، 'بی') ڈی اے جی۔ ایڈ_ج ('اے' ، '،'c ') dag.add_edge (' b '،' d ') dag.add_edge (' c '،' d ') dag.add_edge (' d '،' e ') پرنٹ (dag.topological_sort ()) # پرنٹس \"['a' ، 'B' ، 'C' ، 'D' ، 'E'] \"اس مثال میں ، ڈی اے جی کلاس کا استعمال کرتے ہوئے ایک ڈی اے جی تشکیل دیا گیا ہے ، اور ADD_EDGE کے طریقہ کار کا استعمال کرتے ہوئے گراف میں کناروں کو شامل کیا جاتا ہے۔اس کے بعد ٹوپولوجیکل_سورٹ کے طریقہ کار کو کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹاپولوجیکل چھانٹنے کے لئے کہا جاتا ہے ، اور اس کا نتیجہ کنسول پر چھاپتا ہے۔اس سے کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے ساتھ ازگر میں ڈی اے جی کے استعمال کا مظاہرہ ہوتا ہے۔ کاہن کا الگورتھم ازگر میں ہدایت شدہ ایسائکلک گراف پر ٹوپولوجیکل چھانٹنے کا ایک آسان اور موثر طریقہ ہے۔ڈی اے جی کلاس ازگر میں ڈی اے جی کی نمائندگی کرنے اور ان میں ہیرا پھیری کرنے کا ایک آسان طریقہ مہیا کرتی ہے ، اور ٹوپولوجیکل_سورٹ کا طریقہ گراف میں نوڈس کے ٹوپولوجیکل آرڈر حاصل کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں ثالثی کے نمونے کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "ثالثی کا نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو کسی پروگرام کے اجزاء کے مابین جوڑے کو کم کرتا ہے جس سے وہ خصوصی ثالثی آبجیکٹ 123456 کے ذریعے بالواسطہ بات چیت کرتے ہیں۔ثالثی کا نمونہ دو یا زیادہ اجزاء کے مابین ایک تجریدی تخلیق کرتا ہے جو اس کے بعد نظام کو سمجھنے اور انتظام کرنے میں آسان بناتا ہے۔ثالثی کا نمونہ مشترکہ اشیاء کے استعمال کی حوصلہ افزائی کرتا ہے جو اب مرکزی طور پر انتظام اور مطابقت پذیر ہوسکتے ہیں۔ثالثی کا نمونہ اس کی کلاسوں اور عمل کے مابین کئی سے زیادہ تعامل کے ساتھ ایک ڈھانچے کی جگہ لے لیتا ہے ، جس میں ایک سے زیادہ مرکزی ڈھانچہ ہوتا ہے جہاں انٹرفیس کئی سے زیادہ ڈھانچے کے تمام طریقوں کی حمایت کرتا ہے ، لیکن اس کے بجائے ثالثی کے جزو کے ذریعہ 1.یہ ازگر میں ثالثی کے نمونے کی ایک مثال عمل ہے: پائیٹونکلاس ثالث: Def __init __ (خود): سیلف ڈاٹ کامپوننٹ = [] ڈیف رجسٹر (خود ، جزو): سیلف ڈاٹ کامپینٹ (جزو) ڈیف مطلع (خود ، بھیجنے والا)): خود میں جزو کے لئے۔) ڈیف موصول (خود ، بھیجنے والا): پرنٹ (f \"موصولہ پیغام سے {مرسل}\") ثالثی = ثالثی () اجزاء 1 = اجزاء (ثالثی) اجزاء 2 = اجزاء (ثالثی) اجزاء 3 = اجزاء (ثالثی) ثالثی۔ رجسٹر (اجزاء 1)ثالثی۔ رجسٹر (اجزاء 2) ثالثی۔ رجسٹر (اجزاء 3) اجزاء۔جزو کلاس ان اجزاء کی نمائندگی کرتا ہے جو ثالث کے ذریعہ ایک دوسرے کے ساتھ بات چیت کرتے ہیں۔ثالثی کلاس کا رجسٹر طریقہ ثالث کے ساتھ کسی جز کو رجسٹر کرنے کے لئے استعمال ہوتا ہے۔ثالث کلاس کا مطلع کرنے والا طریقہ مرسل کے علاوہ تمام اجزاء کو مطلع کرنے کے لئے استعمال ہوتا ہے۔اجزاء کی کلاس کا بھیجنے کا طریقہ ثالث کو پیغام بھیجنے کے لئے استعمال ہوتا ہے۔اجزاء کی کلاس کا وصول کرنے کا طریقہ کسی دوسرے جزو سے پیغام وصول کرنے کے لئے استعمال ہوتا ہے۔ اس کی ایک مثال ہے کہ ثالثی اور اجزاء کی کلاسوں کو کس طرح استعمال کیا جائے: پائیٹون میڈیمیٹر = ثالث () اجزاء 1 = اجزاء (ثالث) اجزاء 2 = اجزاء (ثالث) اجزاء 3 =اجزاء (ثالث) ثالث۔ رجسٹر (اجزاء 1) ثالثی۔ رجسٹر (اجزاء 2) ثالثی۔ رجسٹر (اجزاء 3) اجزاء 1.Send () اس مثال میں ، ثالثی کلاس کا استعمال کرتے ہوئے ایک ثالثی آبجیکٹ تشکیل دیا جاتا ہے ، اور اجزاء کی کلاس کا استعمال کرتے ہوئے تین اجزاء تخلیق کیے جاتے ہیں۔اس کے بعد اجزاء رجسٹر کے طریقہ کار کا استعمال کرتے ہوئے ثالث کے ساتھ رجسٹرڈ ہوتے ہیں۔اس کے بعد بھیجنے کے طریقہ کار کو اجزاء 1 پر ثالث کو پیغام بھیجنے کے لئے بلایا جاتا ہے ، جو اس کے بعد دوسرے اجزاء کو ثالث کے ذریعہ موصول ہوتا ہے۔ اس کے علاوہ ، ثالثی کا نمونہ ازگر میں ایک مفید ڈیزائن نمونہ ہے جو اجزاء کے مابین جوڑے کو کم کرنے کے لئے استعمال کیا جاسکتا ہے۔ایک خاص ثالثی شے کے ذریعہ انہیں بالواسطہ بات چیت کرنے کے ذریعہ ایک پروگرام۔ثالثی کا نمونہ اجزاء سے مواصلات کی منطق کو الگ کرکے سافٹ ویئر سسٹم کی ماڈیولریٹی ، برقرار رکھنے اور توسیع کو بہتر بنانے میں مدد کرسکتا ہے۔"
    },
    {
        "Question": "ڈومین سے چلنے والے ڈیزائن (ڈی ڈی ڈی) کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ ان کو مضبوط اور برقرار رکھنے والے سافٹ ویئر سسٹم کی تعمیر کے لئے کس طرح لاگو کیا جاسکتا ہے۔",
        "Answer": "ڈومین سے چلنے والا ڈیزائن (ڈی ڈی ڈی) ایک سافٹ ویئر ڈیزائن نقطہ نظر ہے جو اس ڈومین کے ماہرین 123456 کے ان پٹ کے مطابق کسی ڈومین سے ملنے کے لئے ماڈلنگ سافٹ ویئر پر مرکوز ہے۔ڈی ڈی ڈی کا مقصد سافٹ ویئر کے متعلقہ ٹکڑوں کو ہمیشہ تیار ہونے والے ماڈل 23456 میں جوڑ کر پیچیدہ ایپلی کیشنز کی تخلیق کو آسان بنانا ہے۔ڈی ڈی ڈی کے اصولوں کا اطلاق ڈومین کے ماہرین ، صارفین اور ڈویلپرز کے ذریعہ مشترکہ زبان کو فروغ دے کر مضبوط اور برقرار رکھنے والے سافٹ ویئر سسٹم کی تعمیر کے لئے کیا جاسکتا ہے۔ہر جگہ زبان ڈومین ماڈل میں اور نظام کی ضروریات کو بیان کرنے کے لئے استعمال کی جاتی ہے 123456۔ہر جگہ زبان ڈی ڈی ڈی کے ایک ستونوں میں سے ایک ہے جو دوسرے اصولوں کے ساتھ ہے جیسے: بنیادی ڈومین پر فوکس کریں: ڈی ڈی ڈی سافٹ ویئر کے بنیادی ڈومین پر مرکوز ہے ، جو نظام کا سب سے اہم اور پیچیدہ حصہ ہے۔بنیادی ڈومین وہ جگہ ہے جہاں سافٹ ویئر کی کاروباری قیمت رہتی ہے ، اور یہ ترقی کی کوشش کی بنیادی توجہ کا مرکز ہونا چاہئے۔باہمی تعاون کے ساتھ ڈیزائن اس بات کو یقینی بنانے میں مدد کرتا ہے کہ سافٹ ویئر ڈومین اور اس کے صارفین کی ضروریات کو پورا کرتا ہے۔سیاق و سباق کو یقینی بنانے میں مدد ملتی ہے کہ سافٹ ویئر کو ہم آہنگی اور ڈھیلے ڈھیلے ملوث اجزاء میں ترتیب دیا گیا ہے جس کو آسانی سے برقرار رکھا جاسکتا ہے اور 23456 کو بڑھایا جاسکتا ہے۔ اس کی ایک مثال ہے کہ ایک مضبوط اور برقرار رکھنے والے سافٹ ویئر سسٹم کی تعمیر کے لئے ڈی ڈی ڈی کا اطلاق کس طرح کیا جاسکتا ہے: پائیٹونکلاس آرڈر: ڈیف __INIT __ (خود ، ، خود ، ، خود ، خود ، خود ،کسٹمر ، آئٹمز): سیلف۔ کسٹومر = کسٹمر سیلف۔ آئٹمز = آئٹمزکلاس کسٹمر: ڈیف __init __ (خود ، نام ، ای میل): سیلف۔ نام = نام خود۔ ای میل = ای میل کلاس آرسروس: ڈیف __ __init __ (خود ، آرڈر_ ریپوزٹری ، ای میل_سروس): خود).order_repository = order_repository self.email_service = ای میل_سروائس ڈیف پلیس_آرڈر (سیلف ، کسٹمر_ نام ، کسٹمر_ ای میل ، آئٹمز): کسٹمر = کسٹمر = کسٹمر (کسٹمر_ نام ، کسٹمر_ ای میل) آرڈر = آرڈر (کسٹمر ، آئٹمز) سیل. آرڈر_ ریپوسیٹری۔۔آرڈر کلاس ایک آرڈر کی نمائندگی کرتا ہے ، اور کسٹمر کلاس کسی صارف کی نمائندگی کرتا ہے۔آرڈر سروس کلاس صارفین کو تصدیقی ای میل بھیجنے کے لئے آرڈرز اور ای میل سروس کو بچانے کے لئے ایک ذخیرہ استعمال کرتی ہے۔آرڈرسروائس کلاس کا پلیس_ورڈر طریقہ کسٹمر کی معلومات اور اشیاء کو ان پٹ کے طور پر لیتا ہے ، ایک صارف اور آرڈر بناتا ہے ، ذخیرہ کا استعمال کرتے ہوئے آرڈر کو محفوظ کرتا ہے ، اور ای میل سروس کا استعمال کرتے ہوئے تصدیقی ای میل بھیجتا ہے۔ہر جگہ زبان کو ڈومین اشیاء اور ان کے تعلقات کو بیان کرنے کے لئے استعمال کیا جاتا ہے ، اور بنیادی ڈومین اس بات پر مرکوز ہے کہ سافٹ ویئر ڈومین اور اس کے صارفین کی ضروریات کو پورا کرے۔ڈومین کے ذریعہ مشترکہ مشترکہ زبان کو فروغ دے کر مضبوط اور برقرار رکھنے والے سافٹ ویئر سسٹم بنائیں"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں سرکلر بفر کی نمائندگی ہوتی ہے جس میں انکیو ، ڈی کیوئو ، اور اس بات کا تعین کرنے کے طریقوں کے ساتھ بفر مکمل یا خالی ہے ، ایک مقررہ سائز کی صف کا استعمال کرتے ہوئے۔\"",
        "Answer": "یہاں ایک ازگر کلاس ہے جو سرکلر بفر کی نمائندگی کرتی ہے جس میں انکیو ، ڈی کیوئو ، اور اس بات کا تعین کرنے کے طریقوں کے ساتھ بفر مکمل یا خالی ہے ، ایک مقررہ سائز کی صف کا استعمال کرتے ہوئے: پائیٹونکلاس سرکلر بفر: ڈیف __init __ (خود ، سائز).بفر = [کوئی نہیں] * سائز سیلف۔ ہیڈ = 0 سیلف۔ ٹیل = 0 سیلف ۔فل = غلط ڈیف آئی ایس_پٹی (خود): واپس نہ کریں۔ خود نہیں۔self.full def enqueue (خود ، آئٹم): self.buffer [self.tail] = آئٹم سیلف۔سچ خود1) self self خود۔یہ بفر کو کسی بھی قدر کے ساتھ شروع کرتا ہے ، سر اور ٹیل پوائنٹرز کو 0 پر سیٹ کرتا ہے ، اور مکمل پرچم کو غلط پر سیٹ کرتا ہے۔ اگر بفر خالی یا مکمل ہے تو ، آئی ایس_پٹی اور آئی ایس_فل طریقوں سے بالترتیب درست لوٹ آتا ہے۔انکیو کا طریقہ بفر میں کسی شے کو شامل کرتا ہے اور ٹیل پوائنٹر کو اپ ڈیٹ کرتا ہے۔اگر بفر بھرا ہوا ہے تو ، یہ سب سے قدیم شے کو اوور رائٹ کرنے کے لئے ہیڈ پوائنٹر کو اپ ڈیٹ کرتا ہے۔ڈی کیو کا طریقہ بفر سے سب سے قدیم آئٹم کو ہٹاتا ہے اور لوٹاتا ہے اور ہیڈ پوائنٹر کو اپ ڈیٹ کرتا ہے۔ سرکلر بفر کلاس کا ایک مثال استعمال: پائیٹون سی بی = سرکلر بفر (5) پرنٹ (سی بی۔ آئس_پیٹ ()) # ٹروپنٹ (سی بی۔ آئی ایس_فل ()))# falsecb.enqueue (1) cb.enqueue (2) cb.enqueue (3) cb.enqueue (4) cb.enqueue (5) پرنٹ (cb.is_empty ()) # غلط پرنٹ (cb.is_full ()) # truecb.enqueue (6) پرنٹ (cb.dequeue ()) # 2 پرنٹ (cb.dequeue ()) # 3cb.enqueue (7) cb.enqueue (8) پرنٹ (cb.dequeue ()) # 4 پرنٹ (cb.dequeue (cb.dequeue ()) # 5 پرنٹ (cb.dequeue ()) # 6 پرنٹ (cb.dequeue ()) # 7 پرنٹ (cb.dequeue ()) # 8 پرنٹ (cb.is_empty ()) # ٹروپنٹ (cb.is_full ()) # فالسیس مثال5 کے سائز کے ساتھ ایک سرکلر بفر آبجیکٹ تیار کرتا ہے ، 5 آئٹمز ، ڈیکوز 5 آئٹمز ، اور چیک کرتا ہے کہ اگر بفر خالی یا مختلف نکات پر بھرا ہوا ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں حکمت عملی کے طرز کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "حکمت عملی کا نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو مؤکل کو مخصوص کام کو مکمل کرنے کے لئے مختلف الگورتھم یا طریقہ کار میں سے انتخاب کرنے کی اجازت دیتا ہے۔جب بیرونی وسائل تک رسائی حاصل کی جاتی ہے تو اس طرز کا بنیادی مقصد لچک کو بہتر بنانا ہے۔حکمت عملی کا نمونہ الگورتھم کے ایک خاندان کی وضاحت کرتا ہے ، ہر ایک کو گھیرے میں لے جاتا ہے ، اور رن ٹائم 12 میں ان کو تبادلہ خیال کرتا ہے۔ حکمت عملی کا نمونہ تین اہم اجزاء پر مشتمل ہے: سیاق و سباق ، حکمت عملی انٹرفیس ، اور ٹھوس حکمت عملی۔سیاق و سباق وہ چیز ہے جو اس پر عملدرآمد کے لئے ٹھوس حکمت عملی حاصل کرتی ہے۔حکمت عملی کا انٹرفیس ان طریقوں کی وضاحت کرتا ہے جن کو ٹھوس حکمت عملیوں پر عمل درآمد کرنا چاہئے۔ٹھوس حکمت عملی مختلف الگورتھم ہیں جو حکمت عملی انٹرفیس 3 کو نافذ کرتی ہیں۔ یہاں ازگر میں حکمت عملی کے نمونے کی ایک مثال ہے: ازگر کلاس سیاق و سباق: ڈیف __init __ (خود ، حکمت عملی): خود .strategy = حکمت عملی ڈیف پر عملدرآمد (خود ، ڈیٹا): واپسیself.strategy.execute (ڈیٹا) کلاس حکمت عملی: DEF پر عملدرآمد (خود ، ڈیٹا): پاسکلاس کنکریٹسٹریگیا (حکمت عملی): ڈی ای ایف پر عملدرآمد (خود ، ڈیٹا): ریٹرن ترتیب (ڈیٹا) کلاس کنکریٹ اسٹریٹ جی ای بی (حکمت عملی): ڈی ای ایف پر عملدرآمد (خود ، ڈیٹا): واپسی الٹ (ترتیب شدہ (ڈیٹا)) ڈیٹا = [3 ، 1 ، 4 ، 1 ، 5 ، 9 ، 2 ، 6 ، 5 ، 3 ، 5] سیاق و سباق = سیاق و سباق (کنکریٹسٹریگیا ()) نتیجہ = سیاق و سباق۔) پرنٹ (نتیجہ) # [1 ، 1 ، 2 ، 3 ، 3 ، 4 ، 5 ، 5 ، 5 ، 6 ، 9] سیاق و سباق = سیاق و سباق (CONCRETESTRATEGYB ()) نتیجہ = سیاق و سباق.Execute_strategy (ڈیٹا) پرنٹ (نتیجہ) (نتیجہ) #[9 ، 6 ، 5 ، 5 ، 5 ، 4 ، 3 ، 3 ، 2 ، 1 ، 1] اس مثال میں ، سیاق و سباق کی کلاس اپنے کنسٹرکٹر میں ٹھوس حکمت عملی حاصل کرتی ہے اور اسے ایک مثال کے متغیر میں اسٹور کرتی ہے۔سیاق و سباق کی کلاس کا پھانسی_اسٹریج طریقہ ٹھوس حکمت عملی کے عملدرآمد کے طریقہ کار کو کال کرتا ہے اور اس کا نتیجہ لوٹاتا ہے۔ حکمت عملی کی کلاس اس انٹرفیس کی وضاحت کرتی ہے جس کو کنکریٹ کی حکمت عملیوں کو نافذ کرنا ہوگا۔کنکریٹسٹریگیا اور کنکریٹسٹریگیب کلاسز دو مختلف الگورتھم ہیں جو حکمت عملی کے انٹرفیس کو نافذ کرتی ہیں۔کنکریٹسٹریگیا کلاس ان پٹ ڈیٹا کو چڑھتے ہوئے ترتیب میں ترتیب دیتی ہے ، جبکہ کنکریٹ اسٹری جی ای بی کلاس ان پٹ ڈیٹا کو نزول ترتیب میں ترتیب دیتی ہے۔ ڈیٹا لسٹ ان پٹ ڈیٹا ہے جو حکمت عملی کے نمونہ کا استعمال کرتے ہوئے ترتیب دی جائے گی۔سیاق و سباق کی کلاس کو مختلف ٹھوس حکمت عملیوں کے ساتھ دو بار فوری بنایا گیا ہے ، اور ایک دلیل کے طور پر ڈیٹا لسٹ کے ساتھ پھانسی_اسٹریٹی طریقہ کو بلایا جاتا ہے۔دو مختلف حکمت عملیوں کے نتائج کنسول پر چھاپے گئے ہیں۔ اس مثال سے یہ ظاہر ہوتا ہے کہ رن ٹائم میں مختلف الگورتھم کے مابین کلائنٹ کوڈ کو تبدیل کیے بغیر حکمت عملی کے نمونے کو کس طرح استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "تقسیم شدہ نظاموں میں غلطی رواداری کے تصور پر تبادلہ خیال کریں اور کس طرح نقل اور اتفاق رائے سے الگورتھم جیسی تکنیکوں کو ازگر میں استعمال کیا جاسکتا ہے۔",
        "Answer": "فالٹ رواداری تقسیم شدہ نظاموں میں ایک اہم تصور ہے جو غلطیوں یا ناکامیوں کی موجودگی میں بھی کسی نظام کی کام کو جاری رکھنے کی صلاحیت سے مراد ہے۔تقسیم شدہ نظاموں میں غلطی رواداری ضروری ہے کیونکہ وہ متعدد باہم منسلک اجزاء پر مشتمل ہیں جو خدمت فراہم کرنے کے لئے مل کر کام کرتے ہیں۔یہ اجزاء اکثر جغرافیائی طور پر منتشر ہوتے ہیں اور مختلف ہارڈ ویئر اور سافٹ ویئر پلیٹ فارمز پر چلاتے ہیں ، جس کی وجہ سے وہ مرکزی نظام 1 کے مقابلے میں غلطیوں اور ناکامیوں کا زیادہ حساس ہوجاتے ہیں۔ غلطی رواداری کے بغیر ، تقسیم شدہ نظام ٹائم ٹائم ، ڈیٹا میں کمی اور کارکردگی کی کمی کا شکار ہیں ، جو مالی کا باعث بن سکتے ہیں۔نقصانات ، ساکھ کا نقصان ، اور کسٹمر ٹرسٹ کا نقصان۔لہذا ، کسی بھی تقسیم شدہ نظام کے لئے غلطی رواداری ایک کلیدی ضرورت ہے جس کا مقصد ایک قابل اعتماد سروس 1 فراہم کرنا ہے۔ متعدد تکنیکیں ہیں جن کو تقسیم شدہ نظاموں میں غلطی رواداری کے حصول کے لئے استعمال کیا جاسکتا ہے ، بشمول نقل اور اتفاق رائے الگورتھم۔نقل میں ڈیٹا یا خدمات کی متعدد کاپیاں بنانا اور سسٹم میں مختلف نوڈس میں تقسیم کرنا شامل ہے۔اگر ایک نوڈ ناکام ہوجاتا ہے تو ، دوسرا نوڈ اقتدار سنبھال سکتا ہے اور خدمت کی فراہمی جاری رکھ سکتا ہے۔دوسری طرف ، اتفاق رائے الگورتھم کا استعمال اس بات کو یقینی بنانے کے لئے کیا جاتا ہے کہ سسٹم میں موجود تمام نوڈس کسی خاص ریاست یا فیصلے پر متفق ہوں۔اس سے عدم مطابقتوں کو روکنے میں مدد مل سکتی ہے اور یہ یقینی بن سکتا ہے کہ یہ نظام غلطیوں کی موجودگی میں بھی کام کرتا رہتا ہے۔مثال کے طور پر ، رافٹ لائبریری بیڑے کے اتفاق رائے الگورتھم کا ایک ازگر کا نفاذ ہے جسے غلطی سے روادار تقسیم شدہ نظاموں کی تعمیر کے لئے استعمال کیا جاسکتا ہے۔رے فریم ورک ایک اور ازگر لائبریری ہے جو غلطی رواداری کی خصوصیات فراہم کرتی ہے جیسے خودکار غلطی کی بازیابی اور نوڈ کی ناکامی کا پتہ لگانے 4۔مزید برآں ، پیٹورچ میں ڈسٹری بیوٹڈٹاپرالیل ماڈیول غلطی رواداری کی خصوصیات مہیا کرتا ہے جیسے چیک پوائنٹنگ ، جو ریاست کو پچھلے چوکی 5 سے ریاست کو بحال کرکے ناکامیوں سے بازیافت کرنے کی اجازت دیتا ہے۔غلطیوں یا ناکامیوں کی موجودگی میں بھی کام کرنا۔نقل اور اتفاق رائے سے الگورتھم جیسی تکنیکوں کو غلطی رواداری کے حصول کے لئے استعمال کیا جاسکتا ہے ، اور ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو ان تکنیکوں کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "ہدایت والے وزن والے گراف کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور فلائیڈ وارشل الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو ہدایت شدہ وزن والے گراف کی نمائندگی کرتی ہے اور فلائیڈ وارشل الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کرتی ہے: پائیتھونکلاس گراف: ڈیف __ __init __ (خود ، نمبر_ورٹیس): سیل .نوم_ورٹیس = نمبر_ورٹیسس سیلف۔ ایڈج_میٹرکس = [[فلوٹ (فلوٹ (''inf ')] * رینج (num_vertices)] کے لئے num_vertices] میں رینج (num_vertices) کے لئے: self.adj_matrix [i] [i] = 0 def add_edge (خود ، i ، j ، وزن): self.adj_matrix [i] [j] = وزن Def floyd_warshall (self): K کے لئے K کے لئے dist = self.adj_matrix (self.num_vertices): in range (sell.num_vertices): J میں J میں (self.num_vertices): ڈسٹ [ڈسٹر] [j] = منٹ (ڈسٹرکٹ [i] [j] ، ڈسٹ [i] [k] + ڈسٹ [k] [j]) ریٹرن ڈسٹرکٹ گراف کلاس میں ایک __init__ طریقہ ہے جو عمودی کی تعداد کی وضاحت کرنے کے لئے ایک نمبر_ورٹیس پیرامیٹر لیتا ہے۔گراف میںیہ فلوٹ ('INF') اقدار کے ساتھ ملحقہ میٹرکس کی ابتدا کرتا ہے اور اخترن عناصر کو 0. پر سیٹ کرتا ہے۔ ADD_EDGE کا طریقہ ایک مخصوص وزن کے ساتھ گراف میں ایک کنارے کا اضافہ کرتا ہے۔یہ ملحقہ میٹرکس میں اسی اندراج کو اپ ڈیٹ کرتا ہے۔ فلائیڈ_ورشل کا طریقہ فلائیڈ وارشل الگورتھم کا استعمال کرتے ہوئے گراف میں عمودی کے تمام جوڑے کے درمیان مختصر ترین راستہ تلاش کرتا ہے۔یہ ملحقہ میٹرکس کے ساتھ فاصلے کے میٹرکس کی ابتدا کرتا ہے اور ہر ممکن انٹرمیڈیٹ چوڑائیوں پر غور کرکے اسے تکرار سے اپ ڈیٹ کرتا ہے۔ گراف کلاس کا ایک مثال استعمال ہے: پائیتھونگ = گراف (4) g.add_edge (0 ، 1 ، 5) g.add_edge (0، 2 ، 3) g.add_edge (1 ، 2 ، 1) g.add_edge (2 ، 3 ، 2) g.add_edge (1 ، 3 ، 6) ڈسٹر4 عمودی کے ساتھ گراف آبجیکٹ اور وزن کے ساتھ 5 کناروں کا اضافہ کرتا ہے۔اس کے بعد یہ فلائیڈ_ورشل کے طریقہ کار کو کال کرتا ہے تاکہ تمام جوڑے کے درمیان مختصر ترین راستہ تلاش کیا جاسکے اور اس کے نتیجے میں فاصلے کے میٹرکس کو کنسول پر پرنٹ کیا جائے۔ اس مثال کی پیداوار یہ ہے: [[0 ، 5 ، 3 ، 5] ، [انف ، 0 ، 1، 6] ، [INF ، INF ، 0 ، 2] ، [INF ، INF ، INF ، 0]] یہ آؤٹ پٹ گراف میں موجود تمام جوڑے کے درمیان کم سے کم فاصلہ ظاہر کرتا ہے۔مثال کے طور پر ، ورٹیکس 0 اور ورٹیکس 3 کے درمیان کم سے کم فاصلہ 5.1favtutor2scaler3leetcode4programiz5sanfoundry ہے"
    },
    {
        "Question": "رد عمل کے سلسلے کے تصور کی وضاحت کریں اور یہ کہ ان کو کس طرح ازگر میں Asyncio جیسے لائبریریوں کا استعمال کیا جاسکتا ہے۔",
        "Answer": "رد عمل کے سلسلے ایک پروگرامنگ نمونہ ہے جو اعداد و شمار کے سلسلے کو رد عمل اور متضاد انداز میں پروسیسنگ کی اجازت دیتا ہے۔رد عمل کے سلسلے کو بڑی مقدار میں ڈیٹا کو سنبھالنے اور ڈیٹا پر کارروائی کرنے کا ایک طریقہ مہیا کرنے کے لئے ڈیزائن کیا گیا ہے ، بجائے اس کے کہ IT1 پر کارروائی کرنے سے پہلے تمام اعداد و شمار کے دستیاب ہونے کا انتظار کریں۔ایسینسیو ازگر کے معیاری لائبریری کا متضاد فریم ورک ہے جو نیٹ ورک کنیکشن 2 کے ساتھ کام کرنے کے لئے اعلی سطحی ASYNC/انتظار کرنے کے لئے تیار قدیم فراہم کرتا ہے۔aioractive asyncio کے لئے ایک متضاد اور رد عمل والا ازگر لائبریری ہے جو Async کا استعمال کرتے ہیں اور اس کا انتظار کرتے ہیں جو اظہار فنکشنل لائبریری پر بنایا گیا ہے اور قدرتی طور پر ازگر کی زبان 3 کے ساتھ مل جاتا ہے۔الگورتھم کو چھوٹے چھوٹے کاموں میں توڑ دیا جاسکتا ہے جسے asyncio لائبریری کا استعمال کرتے ہوئے سنجیدگی سے عمل میں لایا جاسکتا ہے۔asyncio لائبریری ان کاموں کو بیک وقت اور غیر مسدود انداز میں انجام دینے کا ایک طریقہ مہیا کرتی ہے ، جو الگورتھم 4 کی کارکردگی کو بہتر بنا سکتی ہے۔ یہاں فلائیڈ وارشل الگورتھم کا ایک مثال ہے جس کا استعمال پیتھون میں Asyncio: Pythonimport asyncioclass گراف: Def __iinit__.] = 0 ڈیف ایڈ_ج (خود ، I ، J ، وزن): sell[] میں رینج (سیلف.نوم_ورٹیسس) کے لئے: رینج میں جے کے لئے (سیلف ڈاٹ اینوم_ورٹیسس): ٹاسکس.ایپینڈ (asyncio.create_task (self.update_distance (Dist ، i ، i ، j ، k))) asyncio.gather (**ٹاسکس) ڈسٹ ایسینک ڈیف اپ ڈیٹ_ڈسٹینس (خود ، ضلع ، آئی ، جے ، کے) کی واپسی: اگر ڈسٹرکٹ [i] [j]> ڈسٹ [i] [k] + ڈسٹ [K] [j]: ڈسٹ [i] [j] = ڈسٹرکٹ [i] [k] + ڈسٹ [k] [j] اس نفاذ میں ، فلائیڈ_ورشال کا طریقہ ایک متضاد طریقہ ہے جو اپ ڈیٹ_ ڈسٹینس کے طریقہ کار کو بیک وقت انجام دینے کے لئے اسینسیو لائبریری کا استعمال کرتا ہے۔اپ ڈیٹ_ ڈسٹنس کا طریقہ فاصلہ میٹرکس کو متنازعہ طور پر اپ ڈیٹ کرتا ہے اگر کوئی چھوٹا راستہ مل جاتا ہے۔ یہاں گراف کلاس کا ایک مثال استعمال ہوتا ہے: پائیٹونگ = گراف (4) جی.اڈ_ج (0 ، 1 ، 5) جی.اڈڈ_ج (0 ، 2 ، 3)g.add_edge (1 ، 2 ، 1) g.add_edge (2 ، 3 ، 2) g.add_edge (1 ، 3 ، 6) ڈسٹ = asyncio.run (g.floyd_warshall ()) پرنٹ (ڈسٹرکٹ) یہ مثال ایک تخلیق کرتی ہے4 عمودی کے ساتھ گراف آبجیکٹ اور وزن کے ساتھ 5 کناروں کا اضافہ کرتا ہے۔اس کے بعد یہ فلائیڈ_ورشل کے طریقہ کار کو کال کرتا ہے تاکہ تمام جوڑے کے درمیان مختصر ترین راستہ تلاش کیا جاسکے اور اس کے نتیجے میں فاصلے کے میٹرکس کو کنسول پر پرنٹ کیا جائے۔ اس مثال کی پیداوار یہ ہے: [[0 ، 5 ، 3 ، 5] ، [انف ، 0 ، 1، 6] ، [INF ، INF ، 0 ، 2] ، [INF ، INF ، INF ، 0]] یہ آؤٹ پٹ گراف میں موجود تمام جوڑے کے درمیان کم سے کم فاصلہ ظاہر کرتا ہے۔مثال کے طور پر ، ورٹیکس 0 اور ورٹیکس 3 کے درمیان کم سے کم فاصلہ 5.1Medium2python3github4packtpub ہے"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں ترجمان کے نمونے کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "مترجم کا نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو زبان کے گرائمر یا تاثرات کا اندازہ کرنے کا ایک طریقہ فراہم کرتا ہے۔یہ گرائمر کی نمائندگی کے ساتھ ساتھ ایک موکل کے لئے گرائمر کی ترجمانی کرنے کے لئے ایک ترجمان کی بھی وضاحت کرتا ہے۔ترجمان کا نمونہ کسی زبان کے لئے گرائمیکل نمائندگی کی وضاحت کے لئے استعمال ہوتا ہے اور اس گرائمر 12 سے نمٹنے کے لئے ایک ترجمان فراہم کرتا ہے۔ ترجمان کا نمونہ کسی زبان میں جملے کی جانچ کے مسئلے کو حل کرنے کے لئے استعمال ہوتا ہے۔اس میں ایک اظہار انٹرفیس کو نافذ کرنا شامل ہے جو کسی خاص سیاق و سباق کی ترجمانی کرنے کا طریقہ بتاتا ہے۔اس نمونہ کو ایس کیو ایل پارسنگ ، علامت پروسیسنگ انجنوں ، اور دیگر ایپلی کیشنز 2 میں استعمال کیا جاتا ہے۔ یہاں ازگر میں مترجم کے نمونے کی ایک مثال عمل ہے: ازگر کلاس اظہار: ڈیف کی تشریح (خود ، سیاق و سباق): پاسکلاس نمبر (اظہار): ڈیف __ __init __ (خود ، ، خود ،نمبر): سیلف۔ نمبر = نمبر ڈیف کی تشریح (خود ، سیاق و سباق): واپسی سیلف ۔نبرکلاس پلس (اظہار): ڈیف __init __ (خود ، بائیں ، دائیں): سیلف۔ لیفٹ = بائیں سیلف۔ رائٹ = دائیں ڈیف کی تشریح (خود ،سیاق و سباق میں واپس کریں۔خود ، سیاق و سباق): خود کو واپس کریں۔تعداد ، پلس ، اور مائنس کلاسز اظہار طبقے کے ٹھوس نفاذ ہیں جو بالترتیب تعداد ، اضافے اور گھٹاؤ کی نمائندگی کرتے ہیں۔ ہر کنکریٹ کلاس کی تشریح کا طریقہ ایک سیاق و سباق کا پیرامیٹر لیتا ہے جو ترجمان کی موجودہ حالت کی نمائندگی کرتا ہے۔نمبر کلاس آسانی سے اس کی نمائندگی کرتا ہے جس کی نمائندگی کرتا ہے۔پلس اور مائنس کلاسز بار بار اپنے بائیں اور دائیں اوپریینڈز کی تشریح کے طریقہ کار کو کہتے ہیں اور مناسب آپریشن انجام دیتے ہیں۔ یہاں اظہار کی کلاسوں کا ایک مثال استعمال: پائیٹونکونٹیکسٹ = {} اظہار = پلس (نمبر (1) ، مائنس (نمبر (2)، نمبر (3))) نتیجہ = اظہار۔ انٹرپریٹ (سیاق و سباق) پرنٹ (نتیجہ) # 0 اس مثال سے ایک سیاق و سباق کی لغت اور ایک اظہار پیدا ہوتا ہے جو اظہار کی نمائندگی کرتا ہے \"1 + (2 - 3)\"۔اظہار کی تشریح کے طریقہ کار کو ایک دلیل کے طور پر سیاق و سباق کی لغت کے ساتھ کہا جاتا ہے ، اور اس کا نتیجہ کنسول پر چھپا جاتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: 0 اس آؤٹ پٹ سے پتہ چلتا ہے کہ \"1 + (2 - 3)\" 0.1 کا جائزہ لیتا ہے۔ویکیپیڈیا 2 جیکفورجیکس"
    },
    {
        "Question": "واقعہ سے چلنے والے فن تعمیر (ای ڈی اے) کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ ان کو کس طرح ازگر میں جیانگو اور فلاسک جیسے فریم ورک کا استعمال کیا جاسکتا ہے۔",
        "Answer": "واقعہ سے چلنے والا فن تعمیر (ای ڈی اے) ایک سافٹ ویئر ڈیزائن کا نمونہ ہے جو واقعات کے آس پاس ایپلی کیشنز کو تشکیل دیتا ہے ، جو معنی خیز واقعات ہیں جو نظام کے اندر پیش آتے ہیں۔ای ڈی اے اس خیال پر مبنی ہے کہ کسی بھی درخواست کے طرز عمل کو کسی مرکزی کنٹرولر یا پہلے سے طے شدہ قواعد کے ایک سیٹ کے بجائے واقعات کے ذریعہ چلایا جانا چاہئے۔ای ڈی اے کے اصولوں میں شامل ہیں: ڈیکپلنگ: ای ڈی اے کسی درخواست کے اجزاء کے مابین ڈھیلے جوڑے کو فروغ دیتا ہے ، جس کی مدد سے وہ ترقی ، تعینات اور آزادانہ طور پر اسکیل کرنے کی اجازت دیتے ہیں۔اس سے اطلاق کو برقرار رکھنے میں مزید لچکدار اور آسان ہوجاتا ہے۔ اسینچروونی: ای ڈی اے فطری طور پر متضاد ہے ، اس کا مطلب ہے کہ واقعات پر آزادانہ اور بیک وقت عملدرآمد کیا جاسکتا ہے۔اس سے بہتر کارکردگی اور اسکیل ایبلٹی کے ساتھ ساتھ اعداد و شمار کی بڑی مقدار کو سنبھالنے کی صلاحیت کی بھی اجازت ملتی ہے۔ ایونٹ سے چلنے والی پروسیسنگ: ای ڈی اے مرکزی کنٹرولر کے ذریعہ ان پر کارروائی کا انتظار کرنے کے بجائے پروسیسنگ کے واقعات پر توجہ مرکوز کرتا ہے۔اس سے تیز رفتار ردعمل کے اوقات اور سسٹم وسائل کے زیادہ موثر استعمال کی اجازت ملتی ہے۔ ازگر میں ، ای ڈی اے کو جیانگو اور فلاسک جیسے فریم ورک کا استعمال کرتے ہوئے لاگو کیا جاسکتا ہے ، جو ایونٹ سے چلنے والی ایپلی کیشنز کی تعمیر کے لئے مدد فراہم کرتے ہیں۔یہاں کچھ طریقے ہیں جن کو ای ڈی اے کو ان فریم ورک کا استعمال کرتے ہوئے استعمال کیا جاسکتا ہے: میسج بروکرز کا استعمال کرتے ہوئے: ربیٹ ایم کیو اور اپاچی کافکا جیسے میسج بروکرز کو ای ڈی اے کو ازگر کی ایپلی کیشنز میں نافذ کرنے کے لئے استعمال کیا جاسکتا ہے۔یہ بروکرز ایپلیکیشن کے مختلف اجزاء کے ذریعہ واقعات کو شائع کرنے اور استعمال کرنے کی اجازت دیتے ہیں ، جو غیر متزلزل پروسیسنگ اور ڈیکپلنگ کو قابل بناتا ہے۔ واقعہ سے چلنے والے فریم ورک کا استعمال کرتے ہوئے: فلاسک اور جیانگو جیسے ازگر کے فریم ورک ایونٹ سے چلنے والی ایپلی کیشنز کی تعمیر کے لئے معاونت فراہم کرتے ہیں۔یہ فریم ورک ڈویلپرز کو ایونٹ کے ہینڈلرز کی وضاحت کرنے کی اجازت دیتے ہیں جو مخصوص واقعات کا جواب دیتے ہیں ، جو سسٹم کے اندر صارف کے اعمال یا دیگر واقعات کے ذریعہ متحرک ہوسکتے ہیں۔کارکردگی اور اسکیل ایبلٹی میں بہتری کو فعال کریں۔یہ CQRs (کمانڈ استفسار کی ذمہ داری الگ الگ کرنے) جیسی تکنیکوں کا استعمال کرتے ہوئے حاصل کیا جاسکتا ہے ، جو کسی ایپلی کیشن کے پڑھنے اور لکھنے والے ماڈل کو الگ کرتا ہے۔جیانگو اور فلاسک جیسے فریم ورک کا استعمال کرکے ، ازگر ڈویلپرز ایونٹ سے چلنے والی ایپلی کیشنز تیار کرسکتے ہیں جو جدید ، تقسیم شدہ فن تعمیرات کے مطابق ہیں۔"
    },
    {
        "Question": "بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور عناصر کو شامل کرنے اور ممبرشپ کی جانچ پڑتال کے طریقے فراہم کریں۔",
        "Answer": "یہاں ایک ازگر کی کلاس ہے جو بلوم فلٹر کی نمائندگی کرتی ہے اور عناصر کو شامل کرنے اور ممبرشپ کی جانچ پڑتال کے طریقے فراہم کرتی ہے: پائیتھونیمپورٹ ایم ایم ایچ 3 فریم بٹلری امپورٹ بٹلریکلاس بلومفلٹر: ڈیف __init __ (خود ، سائز ، ہیش_کاؤنٹ): سیلف۔ بٹ_آرائی = بٹیرے (سائز) خود_ریری۔0) خود= 1 def __ contains __ (خود ، آئٹم): رینج میں Iکلاس کے پاس ایک __init__ طریقہ ہے جو تھوڑا سا سرنی کے سائز کی وضاحت کرنے کے لئے ایک سائز کا پیرامیٹر لیتا ہے اور استعمال کرنے کے لئے ہیش افعال کی تعداد کی وضاحت کرنے کے لئے ہیش_ کاؤنٹ پیرامیٹر کی وضاحت کرتا ہے۔یہ 0 اقدار کے ساتھ بٹ سرنی کی ابتدا کرتا ہے۔ ADD طریقہ ہیش فنکشن کا استعمال کرتے ہوئے بٹ سرنی میں اسی بٹس کو ترتیب دے کر بلوم فلٹر میں ایک عنصر کو شامل کرتا ہے۔بٹ سرنی میں متعلقہ تمام بٹس سیٹ ہیں۔اگر بٹس میں سے کوئی بھی سیٹ نہیں ہے تو ، عنصر یقینی طور پر بلوم فلٹر کا ممبر نہیں ہے۔اگر تمام بٹس مرتب کیے گئے ہیں تو ، عنصر شاید بلوم فلٹر کا ممبر ہے۔ بلوم فلٹر کلاس کا ایک مثال استعمال: پائیتھنبف = بلومفلٹر (100 ، 3) بی ایف۔ ایڈ (\"ہیلو\") بی ایف۔ ایڈ (\"دنیا\" \") پرنٹ (BF میں \"ہیلو\") # ٹروپنٹ (\"BF میں ورلڈ\") # ٹروپنٹ (BF میں \"فو\") # فالسیتیس مثال 100 اور 3 ہیش افعال کے سائز کے ساتھ ایک بلوم فلٹر آبجیکٹ تیار کرتا ہے۔اس سے بلوم فلٹر میں عناصر \"ہیلو\" اور \"ورلڈ\" شامل ہوتا ہے اور اگر \"ہیلو\" ، \"ورلڈ\" ، اور \"فو\" __contains__ طریقہ کا استعمال کرتے ہوئے بلوم فلٹر کے ممبر ہیں۔ظاہر کرتا ہے کہ \"ہیلو\" اور \"ورلڈ\" بلوم فلٹر کے ممبر ہیں ، جبکہ \"فو\" نہیں ہے۔تاہم ، یہ نوٹ کرنا ضروری ہے کہ بلوم فلٹرز غلط مثبت پیدا کرسکتے ہیں ، اس کا مطلب یہ ہے کہ ایک عنصر جو حقیقت میں بلوم فلٹر کے ممبر نہیں ہوتا ہے اسے غلط طور پر ممبر کے طور پر شناخت کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"ازگر میں ہم آہنگی کے ماڈلز ، جیسے دھاگوں ، عمل اور کوروٹائنز کے تصور کی وضاحت کریں اور ان کے تجارتی تعلقات پر تبادلہ خیال کریں۔\"",
        "Answer": "ہم آہنگی کے ماڈل ان مختلف طریقوں کا حوالہ دیتے ہیں جن میں ایک پروگرام میں متعدد کاموں کو بیک وقت عمل میں لایا جاسکتا ہے۔ازگر میں ، بہت سے ہم آہنگی کے ماڈل دستیاب ہیں ، جن میں شامل ہیں: دھاگے: دھاگے پر عمل درآمد کے ہلکے وزن والے یونٹ ہیں جو ایک ہی میموری کی جگہ کا اشتراک کرتے ہیں۔وہ I/O پابند کاموں کے لئے کارآمد ہیں ، جہاں پروگرام اپنا زیادہ تر وقت ان پٹ/آؤٹ پٹ آپریشنوں کے مکمل ہونے کے منتظر صرف کرتا ہے۔وہ سی پی یو سے منسلک کاموں کے ل useful کارآمد ہیں ، جہاں پروگرام اپنا زیادہ تر وقت گنتی کرنے میں صرف کرتا ہے۔ کوروٹائنز: کوروٹائن تھریڈز کی طرح ہیں ، لیکن وہ باہمی تعاون کے ساتھ طے شدہ ہیں ، اس کا مطلب یہ ہے کہ وہ رضاکارانہ طور پر دیگر کوروٹائنوں پر کنٹرول حاصل کرتے ہیں۔وہ I/O پابند کاموں کے ل useful مفید ہیں جن کے لئے اعلی درجے کی ہم آہنگی کی ضرورت ہوتی ہے۔ ان ہم آہنگی کے ماڈلز میں سے ہر ایک کی کارکردگی ، پیچیدگی اور استعمال میں آسانی کے معاملے میں اپنی تجارتی تعلقات ہیں۔یہاں ہر ماڈل کے کچھ تجارتی تعلقات ہیں: دھاگے: دھاگے استعمال میں آسان ہیں اور ہم آہنگی کے حصول کا ایک آسان طریقہ فراہم کرتے ہیں۔تاہم ، ان کو ڈیبگ کرنا مشکل ہوسکتا ہے اور وہ نسل کے حالات اور ڈیڈ لاکس جیسے معاملات میں مبتلا ہوسکتے ہیں۔تاہم ، وہ تھریڈز کے مقابلے میں زیادہ پیچیدہ ہیں اور بین پروسیس مواصلات کی وجہ سے کارکردگی کے اوور ہیڈ سے دوچار ہوسکتے ہیں۔ کوروٹائنز: کوروٹائنز ہم آہنگی کے حصول کے لئے ہلکا پھلکا طریقہ فراہم کرتی ہیں اور یہ دھاگوں سے زیادہ موثر ہوسکتی ہیں۔تاہم ، انہیں ایونٹ لوپ کے محتاط انتظام کی ضرورت ہوتی ہے اور ڈیبگ کرنا مشکل ہوسکتا ہے۔ جیانگو اور فلاسک جیسے فریم ورک ازگر میں ہم آہنگی کے ماڈلز کے لئے مدد فراہم کرتے ہیں۔مثال کے طور پر ، جیانگو ASYNC اور مطلوبہ الفاظ کا انتظار کرنے والے متضاد خیالات کے لئے معاونت فراہم کرتا ہے ، جبکہ فلاسک ASYNC اور ASYNCIO لائبریری اور Asyncio لائبریری کا استعمال کرتے ہوئے غیر متزلزل درخواست ہینڈلرز کے لئے مدد فراہم کرتا ہے۔ایک پروگرام میںازگر کئی ہم آہنگی کے ماڈل مہیا کرتا ہے ، جن میں تھریڈز ، عمل اور کوروٹائن شامل ہیں ، ہر ایک کی کارکردگی ، پیچیدگی اور استعمال میں آسانی کے لحاظ سے اپنی تجارت کے ساتھ۔جیانگو اور فلاسک جیسے فریم ورک ازگر میں ہم آہنگی کے ماڈلز کے لئے مدد فراہم کرتے ہیں ، جس سے ہم آہنگی اور توسیع پذیر ایپلی کیشنز کی تعمیر آسان ہوجاتی ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں پل پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "پل پیٹرن ایک ساختی ڈیزائن کا نمونہ ہے جو تجرید کو نفاذ سے الگ کرتا ہے۔یہ دونوں کو آزادانہ طور پر مختلف ہونے کی اجازت دیتا ہے اور اس کے نفاذ سے تجریدی کو ڈیکپل کرنے کا ایک طریقہ فراہم کرتا ہے تاکہ ان دونوں کو آزادانہ طور پر تبدیل کیا جاسکے۔پل کا نمونہ مفید ہے جب آپ کسی تجرید اور اس کے نفاذ کے مابین مستقل پابند ہونے سے بچنا چاہتے ہیں ، یا جب آپ متعدد تجریدوں کے درمیان عمل درآمد کرنا چاہتے ہیں۔خود ، رداس): پاسکلاس ویکٹورینڈر (رینڈرر): ڈیف رینڈر_سکل (خود ، رداس): پرنٹ (ایف \"رداس {رداس کا ایک دائرہ ڈرائنگ {رداس} ویکٹر رینڈرر کا استعمال کرتے ہوئے\") کلاس راسٹرینڈر (رینڈرر): ڈیف رینڈر_سکل (خود ، رداس):پرنٹ (ایف \"رداس کا دائرہ ڈرائنگ {رداس} راسٹر رینڈرر کا استعمال کرتے ہوئے\") کلاس شکل: ڈیف __ __init __ (خود ، پیش کرنے والا): سیلف رینڈرر = رینڈرر ڈیف ڈرا (خود)(شکل): ڈیف __init __ (خود ، پیش کرنے والا ، رداس): سپر (): self.radius *= فیکٹرین اس مثال کے طور پر ، رینڈر کلاس ایک تجریدی کلاس ہے جو رینڈر_ سرکل کے طریقہ کار کی وضاحت کرتی ہے۔ویکٹورینڈر اور راسٹرینڈر کلاسز رینڈر کلاس کے ٹھوس نفاذ ہیں جو بالترتیب ویکٹر اور راسٹر گرافکس کا استعمال کرتے ہوئے حلقوں کو پیش کرتے ہیں۔ شکل کی کلاس ایک تجریدی کلاس ہے جو ڈرا اور سائز کا سائز کی وضاحت کرتی ہے۔سرکل کلاس شکل کلاس کا ٹھوس عمل ہے جو ایک مخصوص رداس کے ساتھ دائرے کی نمائندگی کرتا ہے۔دائرے کو پیش کرنے کے لئے استعمال کرنے کے لئے رینڈرر کی وضاحت کرنے کے لئے یہ اپنے کنسٹرکٹر میں ایک رینڈر پیرامیٹر لیتا ہے۔ حلقہ کلاس کا ایک مثال استعمال: پائیتھون ویکٹر_سکل = سرکل (ویکورینڈر () ، 5) ویکٹر_سکل۔ ڈریو () ویکٹر_سکل۔.draw () راسٹر_سکل = سرکل (راسٹرینڈر () ، 10) راسٹر_سکل۔ ڈریو () راسٹر_س سرکل.ریسائز (3) راسٹر_سکل۔ ڈرا () یہ مثال مختلف پیش کنندگان اور ریڈی کے ساتھ دو دائرے کی اشیاء تخلیق کرتی ہے۔یہ ہر دائرے کے قرعہ اندازی کے طریقہ کار کو مخصوص رینڈر کا استعمال کرتے ہوئے پیش کرنے کے لئے کہتے ہیں اور پھر دائرے کا سائز تبدیل کرنے کے لئے سائز کا سائز کا طریقہ کہتے ہیں۔اس کے بعد اس نے دوبارہ سائز والے دائرے کو پیش کرنے کے لئے ایک بار پھر قرعہ اندازی کا طریقہ قرار دیا ہے۔راسٹر رینڈریرتس آؤٹ پٹ کا استعمال کرتے ہوئے یہ ظاہر ہوتا ہے کہ حلقے مخصوص رینڈر کا استعمال کرتے ہوئے پیش کیے جاتے ہیں اور رینڈر کو متاثر کیے بغیر اس کا سائز تبدیل کیا جاسکتا ہے۔"
    },
    {
        "Question": "مسلسل انضمام اور مستقل تعیناتی (CI/CD) کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ ازگر منصوبوں میں جینکنز یا گٹ لیب جیسے ٹولز کا استعمال کرتے ہوئے ان کا اطلاق کیسے کیا جاسکتا ہے۔",
        "Answer": "مسلسل انضمام (CI) اور مسلسل تعیناتی (CD) سافٹ ویئر انجینئرنگ کے طریق کار ہیں جن کا مقصد سافٹ ویئر کی تعمیر ، جانچ اور تعیناتی کے عمل کو خود کار بنانا ہے۔جدید سافٹ ویئر ڈویلپمنٹ ٹیموں کے لئے یہ مشقیں ضروری ہیں کیونکہ وہ اس بات کو یقینی بنانے میں مدد کرتے ہیں کہ سافٹ ویئر کو تیزی سے ، قابل اعتماد اور اعلی معیار کے ساتھ پہنچایا جاتا ہے۔یہاں CI/CD کے کچھ اصول ہیں: بار بار کوڈ انضمام: ڈویلپرز اپنے کوڈ کو بار بار ورژن کنٹرول ریپوزٹری میں داخل کرتے ہیں ، اکثر ، اس بات کو یقینی بنانے کے لئے کہ نقائص اور دیگر سافٹ ویئر کے معیار کے امور کی جلد شناخت کی جاتی ہے۔ آٹومیٹیڈ ٹیسٹنگ: کوڈبیس پر خودکار ٹیسٹ چلائے جاتے ہیں۔اس بات کو یقینی بنانے کے لئے کہ یہ مطلوبہ معیار کے معیار پر پورا اترتا ہے۔اس میں یونٹ ٹیسٹ ، انضمام کے ٹیسٹ ، اور قبولیت ٹیسٹ شامل ہیں۔ مشترکہ ترسیل: منتخب کردہ ماحول میں سافٹ ویئر کی فراہمی کو خودکار کرنے کا عمل ، بشمول پیداوار ، ترقی ، اور جانچ کے ماحول۔یہ تعمیر ، ٹیسٹ ، اور تعیناتی کے عمل کو خود کار طریقے سے انجام دے کر کیا جاتا ہے۔ مشترکہ تعیناتی: سافٹ ویئر کو خود بخود پروڈکشن ماحول میں جانچنے اور منظور ہونے کے بعد خود بخود تعینات کرنے کا عمل سی آئی/سی ڈی طریقوں سے فائدہ اٹھا سکتا ہے ، اور بہت سارے ٹولز دستیاب ہیں۔ان کو نافذ کرنے کے لئے ، بشمول جینکنز ، گٹ لیب ، اور سیمفور۔یہ ٹولز بلڈ ، ٹیسٹ اور تعیناتی کے عمل کو خود کار بنانے کا ایک طریقہ فراہم کرتے ہیں ، جس سے سافٹ ویئر کو جلدی اور اعلی معیار کے ساتھ فراہم کرنا آسان ہوجاتا ہے۔یہ کچھ طریقے ہیں جن کو ازگر پروجیکٹس میں استعمال کیا جاسکتا ہے: خودکار جانچ: ازگر پروجیکٹس خود کار طریقے سے جانچ کے ل p ، پیٹسیسٹ ، یونٹسٹ ، اور کوریج جیسے ٹولز استعمال کرسکتے ہیں۔جانچ کے عمل کو خود کار بنانے کے لئے ان ٹولز کو جینکنز اور گٹ لیب جیسے سی آئی/سی ڈی ٹولز کے ساتھ مربوط کیا جاسکتا ہے۔اس سے یہ یقینی بنتا ہے کہ کوڈ کو کثرت سے مربوط کیا جاتا ہے اور اس نقائص کی جلد شناخت ہوجاتی ہے۔ تعی .ن کی تعیناتی: جینکنز اور گٹ لیب جیسے سی ڈی ٹولز تعیناتی کے عمل کو خود کار بنانے کے لئے استعمال کیے جاسکتے ہیں۔اس سے یہ یقینی بنتا ہے کہ سافٹ ویئر کو تیزی سے اور قابل اعتماد طریقے سے پیداواری ماحول کو پہنچایا جاتا ہے۔ خلاصہ میں ، جدید سافٹ ویئر ڈویلپمنٹ ٹیموں کے لئے سی آئی/سی ڈی کے طریق کار ضروری ہیں ، اور ازگر پروجیکٹس ان سے فائدہ اٹھاسکتے ہیں۔جینکنز اور گٹلاب جیسے ٹولز بلڈ ، ٹیسٹ اور تعیناتی کے عمل کو خود کار بنانے کا ایک طریقہ فراہم کرتے ہیں ، جس سے سافٹ ویئر کو جلدی اور اعلی معیار کے ساتھ فراہم کرنا آسان ہوجاتا ہے۔"
    },
    {
        "Question": "بائنری اسپیس پارٹیشننگ (بی ایس پی) کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور خلائی تقسیم اور قریبی پڑوسی کی تلاش کے طریقے فراہم کریں۔",
        "Answer": "بائنری اسپیس پارٹیشننگ (بی ایس پی) ایک ایسی تکنیک ہے جو کمپیوٹر گرافکس اور الگورتھمک جیومیٹری میں استعمال ہوتی ہے تاکہ کسی جگہ کو چھوٹے حصوں میں تقسیم کیا جاسکے۔بی ایس پی کو ہائپرپلینز کو بطور پارٹیشن استعمال کرتے ہوئے دو محدب سیٹوں میں جگہ کو متنازعہ طور پر تقسیم کرکے نافذ کیا جاتا ہے۔ذیلی تقسیم کا یہ عمل بی ایس پی ٹری 123 کے نام سے جانا جاتا درخت کے اعداد و شمار کے ڈھانچے کی شکل میں جگہ کے اندر موجود اشیاء کی نمائندگی کو جنم دیتا ہے۔ یہاں ازگر میں بی ایس پی کے درخت کی ایک مثال ہے: ازگر کلاس نوڈ: ڈیف __init __ (خود ، نقطہ ،بائیں = کوئی نہیں ، کوئی بھی نہیں): سیلف پوائنٹ = پوائنٹ خود۔): اگر پوائنٹس نہیں ہیں تو: کوئی بھی نہیں مڈ = لین (پوائنٹس) // 2 بائیں = سیلف۔ بلڈ_ٹری (پوائنٹس [: وسط]) دائیں = سیلف۔ بلڈ_ٹری (پوائنٹس [مڈ+1:]) واپسی نوڈ (پوائنٹس [مڈ]، بائیں ، دائیں) ڈیف قریب ترین_نیگبر (خود ، نقطہ): سیلف۔best_dist dist = self.distance (node.Point ، نقطہ) اگر ڈسٹ <best_dist: best_dist = ڈسٹ بیسٹ_نوڈ = نوڈ اگر node.left and node.left.Point [0]> = نقطہ [0] - Best_dist: best_node ، best_dist =سیلف۔بیسٹ_نوڈ ، بیسٹ_ڈیسٹ ڈیف فاصلہ (خود ، پی 1 ، پی 2) واپساس مثال کے طور پر ، نوڈ کلاس بی ایس پی کے درخت میں ایک نوڈ کی نمائندگی کرتی ہے ، جس میں ایک نقطہ اور اس کے بائیں اور دائیں بچوں کا حوالہ ہوتا ہے۔بی ایس پی کلاس بی ایس پی کے درخت کی نمائندگی کرتا ہے اور درخت کی تعمیر اور کسی دیئے گئے نقطہ کے قریب ترین پڑوسی کو تلاش کرنے کے طریقے مہیا کرتا ہے۔ بلڈ_ٹری کا طریقہ بی ایس پی کے درخت کو درخت کی جڑ کے وسط نقطہ کے وسط نقطہ کو درخت کی جڑ کے طور پر منتخب کرکے بار بار تعمیر کرتا ہے۔بائیں اور دائیں سبٹریز۔ قریب ترین_جیببر کا طریقہ درخت کو بار بار عبور کرکے اور موجودہ نوڈ اور ہدف نقطہ کے درمیان فاصلہ چیک کرکے کسی دیئے گئے نقطہ کا قریب ترین پڑوسی پایا جاتا ہے۔_nearrest_neighber طریقہ ایک مددگار طریقہ ہے جو بار بار چلنے والے ٹریورسل کو انجام دیتا ہے۔ یہاں بی ایس پی کلاس کا ایک مثال استعمال ہے: ازگر پوائنٹ = [(1 ، 2) ، (3 ، 4) ، (5 ، 6) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8) ، (7 ، 8)9 ، 10)] بی ایس پی = بی ایس پی (پوائنٹس) قریب ترین = bsp.nearrest_neigbor ((4 ، 5)) پرنٹ (قریب ترین۔ پوائنٹ) # (3 ، 4) یہ مثال پوائنٹس کی ایک فہرست بناتی ہے اور ان سے بی ایس پی کے درخت کی تشکیل کرتی ہے۔بی ایس پی کلاس۔اس کے بعد اس کو قریب ترین پڑوسی (4 ، 5) قریبی_نیگبر کے طریقہ کار کا استعمال کرتے ہوئے مل جاتا ہے اور اس کا نتیجہ کنسول پر پرنٹ کرتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: (3 ، 4) اس آؤٹ پٹ سے ظاہر ہوتا ہے کہ نقطہ کا قریب ترین پڑوسی (4، 5) نقطہ ہے (3 ، 4)"
    },
    {
        "Question": "ازگر میں میٹاپروگرامنگ کے تصور کی وضاحت کریں اور میٹاکلاس یا سجاوٹ کرنے والوں کی ایک مثال پیش کریں۔",
        "Answer": "میٹاپروگرامنگ ایک پروگرامنگ تکنیک ہے جو کسی پروگرام کو رن ٹائم کے وقت اپنا کوڈ میں ترمیم کرنے یا پیدا کرنے کی اجازت دیتی ہے۔ازگر میں ، میٹاکلاس یا ڈیکوریٹرز کا استعمال کرتے ہوئے میٹاپروگرامنگ حاصل کی جاسکتی ہے۔میٹاکلاسس کلاسز ہیں جو دوسرے طبقوں کے طرز عمل کی وضاحت کرتے ہیں ، جبکہ سجاوٹ ایسے افعال ہیں جو دوسرے افعال یا کلاس 123 کے طرز عمل میں ترمیم کرتے ہیں۔*آرگس ، ** کوورگس): اگر سی ایل ایس سی ایل ایس میں نہیں ہے۔: اس مثال کے طور پر ، سنگلٹن میٹاکلاس کی وضاحت اس بات کو یقینی بنانے کے لئے کی گئی ہے کہ کلاس کی صرف ایک مثال تشکیل دی گئی ہے۔میٹاکلاس کا __Call__ طریقہ یہ جاننے کے لئے اوورراڈ ہے کہ آیا کلاس کی کوئی مثال پہلے ہی تشکیل دی گئی ہے۔اگر کوئی مثال نہیں بنائی گئی ہے تو ، ایک نئی مثال تخلیق کی گئی ہے اور _ انسٹینس ڈکشنری میں محفوظ ہے۔ مائکلاس کلاس کی تعریف سنگلٹن میٹاکلاس کے ساتھ سنگلٹن سے میٹاکلاس وصف ترتیب دے کر کی گئی ہے۔اس سے یہ یقینی بنتا ہے کہ مائکلاس کلاس کی صرف ایک مثال تشکیل دی گئی ہے۔ یہاں ازگر میں ایک سجاوٹ کی مثال ہے: پیتھونڈف میموئز (فنک): کیشے = {} ڈیف ریپر (*آرگس): اگر آرگس کیشے میں نہیں ہیں: کیشے [آرگس]= فنک (*آرگس) واپس کیشے [آرگس] ریٹرن ریپر@میموئزائزف فبونیکی (این): اگر ن <2: ریٹرن این ریٹرن فیبونیکی (این -1) + فبونیکی (این-2) اس مثال میں ، میموزائز ڈیکوریٹر کی وضاحت کی گئی ہے۔fibonacci فنکشن کے نتائج کو کیش کرنے کے لئے.ریپر فنکشن کی وضاحت میموئز فنکشن کے اندر کی گئی ہے تاکہ ہر دلائل کے ہر سیٹ کے لئے فبونیکی فنکشن کے نتائج کو کیش کیا جاسکے۔ فبونیکی فنکشن کو فنکشن کی تعریف کے اوپر @میمومائز ڈیکوریٹر رکھ کر میموئز ڈیکوریٹر کے ساتھ سجایا گیا ہے۔اس سے یہ یقینی بنتا ہے کہ فبونیکی فنکشن کے نتائج دلائل کے ہر سیٹ کے لئے کیشے ہوئے ہیں۔ خلاصہ میں ، میٹاپروگرامنگ ایک طاقتور تکنیک ہے جو کسی پروگرام کو رن ٹائم کے وقت اپنا کوڈ میں ترمیم کرنے یا پیدا کرنے کی اجازت دیتی ہے۔ازگر میں ، میٹاکلاس یا ڈیکوریٹرز کا استعمال کرتے ہوئے میٹاپروگرامنگ حاصل کی جاسکتی ہے۔میٹاکلاسس کلاسز ہیں جو دوسرے طبقوں کے طرز عمل کی وضاحت کرتی ہیں ، جبکہ سجاوٹ کار وہ کام ہیں جو دوسرے افعال یا کلاسوں کے طرز عمل میں ترمیم کرتے ہیں۔میٹاپروگرامنگ کو زیادہ لچکدار اور متحرک پروگرام بنانے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور گہرائی سے پہلے تلاش (ڈی ایف ایس) کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے طریقے فراہم کریں۔",
        "Answer": "ٹوپولوجیکل چھانٹنا ایک ایسی تکنیک ہے جو ہدایت والے ایسائکلک گراف (ڈی اے جی) کے عمودی کو اس طرح آرڈر کرنے کے لئے استعمال ہوتی ہے کہ ہر ہدایت شدہ ایج یووی کے لئے ، ورٹیکس یو آرڈر میں وی سے پہلے آتا ہے۔یہ آرڈر بہت سے ایپلی کیشنز میں کارآمد ہے جیسے ٹاسک شیڈولنگ ، انسٹرکشن شیڈولنگ ، اور ڈیٹا سیریلائزیشن۔ٹوپولوجیکل چھنٹائی دونوں گہرائی سے پہلے تلاش (ڈی ایف ایس) اور چوڑائی کی پہلی تلاش (بی ایف ایس) الگورتھمز 123456 کا استعمال کرتے ہوئے کی جاسکتی ہے۔ یہاں ازگر میں ڈی ایف ایس کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کی ایک مثال ہے: پائیٹونکلاس ڈی اے جی: ڈیف __init __ (خود)}} ڈیف ایڈ_ج (خود ، یو ، وی): اگر آپ سیلف گراف میں نہیں ہیں: سیلف گراف [u] = [] سیلف گراف [u] .append (v) ڈیف ٹوپولوجیکل_سورٹ (خود): ملاحظہ کریں = سیٹ (سیٹ () اسٹیک = [] ڈیف ڈی ایف ایس (نوڈ): ملاحظہ کیا گیا۔ ایڈڈ (نوڈ) میں پڑوسی میں خود۔سیلف گراف میں: اگر نوڈ نہیں ملاحظہ کریں: ڈی ایف ایس (نوڈ) ریٹرن اسٹیک [::-1] اس مثال میں ، ڈی اے جی کلاس ہدایت شدہ ایسائکلک گراف کی نمائندگی کرتی ہے اور ڈی ایف ایس کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے ل to ایک طریقہ ٹوپولوجیکل_سورٹ فراہم کرتی ہے۔ADD_EDGE کا طریقہ گراف میں کناروں کو شامل کرنے کے لئے استعمال کیا جاتا ہے۔ ٹوپولوجیکل_سورٹ کا طریقہ گراف میں ہر نوڈ پر ڈی ایف ایس انجام دیتا ہے اور نوڈس کو ان کے آخری اوقات کے الٹ ترتیب میں اسٹیک میں شامل کرتا ہے۔اس کے بعد اسٹیک کو ٹوپولوجیکل آرڈرنگ حاصل کرنے کے لئے الٹ دیا جاتا ہے۔ یہاں ڈی اے جی کلاس کا ایک مثال استعمال: ازگرگراف = ڈی اے جی () گراف.اڈ_ج (5 ، 2) گراف.اڈی_ج (5 ، 0) گراف۔ ایڈ_ج (4 ، 0) گراف.add_edge (4 ، 1) گراف.اڈی_ج (2 ، 3) گراف.اڈی_ج (3 ، 1) پرنٹ (گراف.ٹوپولوجیکل_سورٹ ()) # [5 ، 4 ، 2 ، 3 ، 1 ، 0] یہ مثال ایک ڈی اے جی تشکیل دیتی ہےچھ نوڈس اور چھ کناروں کے ساتھ اور ٹوپولوجیکل_سورٹ کے طریقہ کار کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹ رہا ہے۔اس مثال کی پیداوار []] [4] [2] [3] [1] [0] ہے ، جو گراف کے ٹاپولوجیکل آرڈر کی نمائندگی کرتا ہے۔"
    },
    {
        "Question": "ازگر میں ہم آہنگی اور ہم آہنگی کے تصور پر تبادلہ خیال کریں اور ان کے مابین اختلافات کی وضاحت کریں۔",
        "Answer": "ہم آہنگی اور ہم آہنگی دو تصورات ہیں جو اکثر ایک دوسرے کے ساتھ استعمال ہوتے ہیں ، لیکن پروگرامنگ کے تناظر میں ان کے مختلف معنی ہوتے ہیں۔ازگر میں ، مختلف تکنیکوں ، جیسے تھریڈنگ ، ملٹی پروسیسنگ اور کوروٹائنز کا استعمال کرتے ہوئے ہم آہنگی اور ہم آہنگی حاصل کی جاسکتی ہے۔یہاں ازگر میں ہم آہنگی اور ہم آہنگی کے مابین اختلافات ہیں: ہم آہنگی: ایک سے زیادہ کاموں یا عمل کو بیک وقت سنبھالنے کے پروگرام کی صلاحیت سے مراد ہے۔ ایک ہی وقت میں متعدد کاموں کو پیشرفت کرنے کی اجازت دیتا ہے ، لیکن ضروری نہیں کہ بیک وقت۔ متعدد ملازمتوں کو لینے کی اجازت دیتا ہے۔اسی مشترکہ وسائل تک رسائی حاصل کرنے کا رخ ، جیسے ڈسک ، نیٹ ورک ، یا ایک ہی سی پی یو کور۔ تھریڈنگ اور کوروٹائنز جیسی تکنیکوں کا استعمال کرتے ہوئے حاصل کیا جاسکتا ہے۔ یہ I/O- پابند کاموں کے لئے مفید ہے ، جہاں پروگرام اپنا زیادہ تر وقت ان پٹ کے انتظار میں صرف کرتا ہے/آؤٹ پٹ آپریشن مکمل کرنے کے لئے۔ متوازل ازم: ایک ساتھ متعدد کاموں یا عمل کو بیک وقت انجام دینے کے پروگرام کی صلاحیت سے مراد ہے۔ ہارڈ ویئر وسائل کے استعمال کو زیادہ سے زیادہ استعمال کرنے کے بارے میں متعدد کاموں کو آزادانہ طور پر تقسیم شدہ وسائل پر ساتھ ساتھ چلانے کے لئے کئی کاموں کی اجازت دیتا ہے۔CPU سے منسلک کاموں کے ل useful مفید تکنیکوں کا استعمال کرتے ہوئے حاصل کیا جائے۔ہم آہنگی میں متعدد ملازمتوں کو ایک ہی مشترکہ وسائل تک رسائی حاصل کرنے کی اجازت شامل ہے ، جبکہ ہم آہنگی متعدد کاموں کو آزادانہ طور پر تقسیم شدہ وسائل کے ساتھ ساتھ ساتھ چلنے کی اجازت دینے کے بارے میں ہے۔ازگر ہم آہنگی اور ہم آہنگی دونوں کے لئے میکانزم مہیا کرتا ہے ، ہر ایک اپنے نحو اور استعمال کے معاملات کے ساتھ۔"
    },
    {
        "Question": "بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور عناصر کو شامل کرنے اور کم غلط مثبت شرح کے ساتھ ممبرشپ کی جانچ پڑتال کے طریقے فراہم کریں۔",
        "Answer": "ایک بلوم فلٹر ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو یہ جانچنے کے لئے استعمال ہوتا ہے کہ آیا عنصر کسی سیٹ کا ممبر ہے یا نہیں۔یہ ایک خلائی موثر ڈیٹا ڈھانچہ ہے جو من مانی طور پر بڑی تعداد میں عناصر کے ساتھ سیٹ کی نمائندگی کرسکتا ہے۔تاہم ، جو قیمت ہم کارکردگی کے ل pay ادا کرتے ہیں وہ یہ ہے کہ یہ فطرت میں امکانی ہے ، مطلب یہ ہے کہ اس کے کچھ غلط مثبت نتائج برآمد ہوسکتے ہیں۔جھوٹے مثبت اس وقت پائے جاتے ہیں جب فلٹر ہمیں بتاتا ہے کہ عنصر سیٹ کا ممبر ہوتا ہے ، لیکن ایسا نہیں ہے۔دوسری طرف ، جھوٹے منفی اس وقت پائے جاتے ہیں جب فلٹر ہمیں بتاتا ہے کہ عنصر سیٹ کا ممبر نہیں ہوتا ہے ، لیکن ایسا ہوتا ہے۔بلوم فلٹرز کبھی بھی غلط منفی نتائج پیدا نہیں کرتے ہیں۔ کم غلط مثبت شرح کے ساتھ ازگر میں بلوم فلٹر کو نافذ کرنے کے لئے ، ہم PYPI پر دستیاب بلوم فلٹر پیکیج کا استعمال کرسکتے ہیں۔بلوم فلٹر پیکیج سے بلومفلٹر کلاس کا ایک مثال استعمال ہے: ازگر سے بلوم_فلٹر امپورٹ بلوم فلٹر بلوم = بلوم فلٹر (میکس_ ای ایلیمنٹ = 1000 ، غلطی_ریٹ = 0.01) بلوم.اڈڈ (\"ہیلو\") بلوم ڈاٹ (\"دنیا\") پرنٹ (\"ہیلو) پرنٹ (\" ہیلو \")\"بلوم میں) # ٹروپنٹ (\" ورلڈ \"بلوم میں) # ٹروپنٹ (\" فو \"بلوم میں) # فالستھیس مثال میں زیادہ سے زیادہ 1000 عناصر اور 0.01 کی غلطی کی شرح کے ساتھ بلوم فلٹر آبجیکٹ تیار کرتا ہے۔اس سے بلوم فلٹر میں عناصر \"ہیلو\" اور \"ورلڈ\" شامل ہوتا ہے اور اگر \"ہیلو\" ، \"ورلڈ\" ، اور \"فو\" بلوم فلٹر کے ممبر ہیں تو ان آپریٹر کا استعمال کرتے ہوئے۔ظاہر کرتا ہے کہ \"ہیلو\" اور \"ورلڈ\" بلوم فلٹر کے ممبر ہیں ، جبکہ \"فو\" نہیں ہے۔بلوم فلٹر کی غلطی کی شرح 0.01 پر سیٹ کی گئی ہے ، جس کا مطلب ہے کہ غلط مثبت نتائج کا 1 ٪ امکان موجود ہے۔غلط مثبت شرح کو کم کرنے کے ل we ، ہم بلوم فلٹر کے سائز کو بڑھا سکتے ہیں یا فلٹر میں داخل کردہ عناصر کی تعداد کو کم کرسکتے ہیں۔"
    },
    {
        "Question": "\"ازگر میں ڈیزائن کے نمونوں کے تصور کی وضاحت کریں اور سنگلٹن ، فیکٹری ، اور مبصرین کے نمونوں کی مثالیں پیش کریں۔\"",
        "Answer": "سافٹ ویئر کی نشوونما میں پیدا ہونے والے عام مسائل کے ڈیزائن کے نمونے دوبارہ قابل استعمال حل ہیں۔وہ مخصوص ڈیزائن کے مسائل کو حل کرنے کے لئے ایک بلیو پرنٹ فراہم کرتے ہیں ، جس سے ڈویلپرز کو زیادہ موثر ، برقرار رکھنے اور لچکدار سافٹ ویئر بنانے کی اجازت ملتی ہے۔ڈیزائن کے نمونے زبان-اگنوسٹک ہیں ، لیکن اس جواب میں ، ہم ازگر میں ڈیزائن کے تین مقبول نمونوں کو نافذ کرنے پر توجہ دیں گے: سنگلٹن ، فیکٹری ، اور مبصرین کے نمونے۔ یہاں سنگلٹن ، فیکٹری ، اور مبصرین کی مختصر وضاحتیں ہیں: سنگلٹن پیٹرن: سنگلٹن پیٹرن:سنگلٹن پیٹرن ایک تخلیقی ڈیزائن کا نمونہ ہے جو یقینی بناتا ہے کہ کلاس میں صرف ایک مثال موجود ہے اور اس مثال تک رسائی کا عالمی نقطہ فراہم کرتا ہے۔یہ نمونہ مفید ہے جب ہمیں یہ یقینی بنانا ہوگا کہ کسی طبقے کی صرف ایک مثال تشکیل دی جائے ، جیسے جب ہم مشترکہ وسائل تک رسائی کو کنٹرول کرنا چاہتے ہیں یا عالمی ریاست کو برقرار رکھنا چاہتے ہیں۔ فیکٹری پیٹرن: فیکٹری کا نمونہ ایک تخلیقاتی ڈیزائن کا نمونہ ہے جو فراہم کرتا ہے۔ایک سپر کلاس میں اشیاء بنانے کے لئے ایک انٹرفیس ، لیکن ذیلی طبقات کو اس قسم کی اشیاء کو تبدیل کرنے کی اجازت دیتا ہے جو تخلیق کیا جائے گا۔یہ نمونہ اس وقت مفید ہے جب ہم آبجیکٹ کی عین مطابق طبقے کی وضاحت کیے بغیر اشیاء بنانا چاہتے ہیں جو تشکیل دیئے جائیں گے۔ اوزرور پیٹرن: آبزرور پیٹرن ایک طرز عمل کا ڈیزائن ہے جو اشیاء کے مابین ایک سے زیادہ انحصار کی وضاحت کرتا ہے ، تاکہ جب ایک شے جب ایک شےتبدیلیاں بیان کرتی ہیں ، اس کے تمام منحصر افراد کو خود بخود مطلع کیا جاتا ہے اور اپ ڈیٹ ہوجاتا ہے۔یہ نمونہ اس وقت مفید ہے جب ہم متعلقہ اشیاء کے مابین مستقل مزاجی کو برقرار رکھنا چاہتے ہیں۔ یہاں ازگر میں سنگلٹن ، فیکٹری ، اور مبصرین کے نمونوں کی مثالیں ہیں: سنگلٹن پیٹرن: ہم میٹاکلاس کا استعمال کرتے ہوئے ازگر میں سنگلٹن پیٹرن کو نافذ کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پیتھونکلاس سنگلٹن (قسم): _ انسٹینس = {} def __call __ (cls ، *args ، ** Kwargs): اگر cls cls._Instances میں نہیں ہے: cls._instances [cls] = سپر ()، ** KWARGS) واپسی سی ایل ایس۔فیکٹری فنکشن کا استعمال کرتے ہوئے۔یہاں ایک مثال ہے: پائیٹونکلاس ڈاگ: ڈیف __ __init __ (خود ، نام): سیلف ڈاٹ نام = نامیف تخلیق_ڈوگ (نام): ریٹرن ڈاگ (نام) ڈاگ 1 = تخلیق_ڈوگ (\"فیڈو\") ڈاگ 2 = تخلیق_ڈوگ (\"ریٹ\") اس مثال میں ، اس مثال میں ،تخلیق_ڈوگ فنکشن ایک فیکٹری فنکشن ہے جو کتے کی کلاس کی مثال پیدا کرتا ہے۔ اوزرور پیٹرن: ہم آر ایکس پیکیج سے مشاہدہ کرنے اور مبصر کلاسوں کا استعمال کرتے ہوئے ازگر میں آبزرور پیٹرن کو نافذ کرسکتے ہیں۔یہاں ایک مثال یہ ہے: ازگر کے آر ایکس درآمد کے قابل مشاہدہ ، مبصرین ، مائیو بشر (آبزرور): ڈیف آن_ نیکسٹ (سیلف ، ویلیو): پرنٹ (ایف \"موصولہ: {ویلیو}\") ڈیف آن_کمپلٹڈ (خود): پرنٹ (\"کیا\") ڈیف آن_رور (خود، غلطی): پرنٹ (ایف \"غلطی: {غلطی}\") ماخذ = مشاہدہ کرنے والا۔اقدار جو اسے موصول ہوتی ہیں۔ماخذ آبجیکٹ ایک قابل مشاہدہ ہے جو اقدار 1 ، 2 ، اور 3 کو خارج کرتا ہے۔ سبسکرائب کا طریقہ ماخذ کو قابل مشاہدہ کے لئے مائوبسرور آبجیکٹ کو سبسکرائب کرنے کے لئے استعمال ہوتا ہے۔جب ماخذ قابل مشاہدہ اقدار کو خارج کرتا ہے تو ، مائوبسرور آبجیکٹ انہیں کنسول پر پرنٹ کرتا ہے۔"
    },
    {
        "Question": "ازگر میں کچرے کے جمع کرنے کے تصور کی وضاحت کریں اور میموری کے انتظام کے لئے استعمال ہونے والی مختلف حکمت عملیوں کی وضاحت کریں۔",
        "Answer": "کوڑا کرکٹ جمع کرنے سے میموری کے انتظام کی ایک تکنیک ہے جو پروگرامنگ زبانوں میں خود بخود میموری کو دوبارہ دعوی کرنے کے لئے استعمال ہوتی ہے جو اب استعمال میں نہیں ہے۔ازگر میں ، میموری کی مختص اور ڈیل لوکیشن خود کار طریقے سے ہوتی ہے ، اور ازگر کے ترجمان میں ایک بلٹ ان کچرا جمع کرنے والا ہوتا ہے جو خود بخود ایک ازگر پروگرام میں میموری کی مختص اور اشیاء کے ل det ڈیل لوکیشن کا انتظام کرتا ہے۔کچرا جمع کرنے والا میموری کا پتہ لگانے اور آزاد کرنے کے لئے ذمہ دار ہے جو اب پروگرام کے ذریعہ استعمال نہیں ہوتا ہے اور یہ ازگر کے میموری مینجمنٹ سسٹم 123456 کا ایک اہم حصہ ہے۔حوالہ گنتی کسی شے کے حوالوں کی تعداد پر نظر رکھنے کا عمل ہے۔جب کسی شے کے حوالہ کی گنتی صفر پر گر جاتی ہے تو ، اب اس کی ضرورت نہیں ہوتی ہے اور اسے محفوظ طریقے سے میموری سے ہٹایا جاسکتا ہے۔تاہم ، میموری مینجمنٹ کے تمام معاملات کو سنبھالنے کے لئے تنہا حوالہ گنتی کافی نہیں ہے ، لہذا ازگر میں کچرے کے جمع کرنے والے کو بھی استعمال کیا جاتا ہے جو سرکلر حوالوں کا پتہ لگاسکتا ہے اور اسے آزاد کرسکتا ہے۔کچرے کے جمع کرنے والے کو دو طریقوں سے ازگر میں نافذ کیا جاتا ہے: حوالہ گنتی اور نسل سازی۔جب کسی شے کی حوالہ گنتی 0 تک پہنچ جاتی ہے تو ، ریفرنس گنتی کچرا جمع کرنے کے الگورتھم فوری طور پر اس چیز کو صاف کردیتے ہیں۔نسل کے کوڑے دان کا مجموعہ ایک زیادہ نفیس الگورتھم ہے جو ڈھیر کو نسلوں میں تقسیم کرتا ہے اور ان کی عمر 123456 پر مبنی اشیاء کو جمع کرتا ہے۔ خلاصہ میں ، ازگر کا کوڑا کرکٹ جمع کرنے والا ایک بلٹ ان خصوصیت ہے جو خود بخود میموری کی مختص اور کسی پائیٹون پروگرام میں آبجیکٹ کے لئے ڈیل لوکیشن کا انتظام کرتی ہے۔اس میں میموری مختص کرنے کے لئے دو حکمت عملی استعمال کی گئی ہیں: حوالہ گنتی اور کوڑا کرکٹ جمع کرنا۔حوالہ گنتی کسی شے کے حوالے سے حوالوں کی تعداد پر نظر رکھنے کا عمل ہے ، جبکہ کچرا جمع کرنا جب پروگرام کی ضرورت نہیں ہے تو مختص میموری کی بحالی یا رہائی کا عمل ہے۔کچرا جمع کرنے والا میموری کا پتہ لگانے اور آزاد کرنے کے لئے ذمہ دار ہے جو اب پروگرام کے ذریعہ استعمال نہیں ہوتا ہے اور یہ ازگر کے میموری مینجمنٹ سسٹم کا ایک اہم حصہ ہے۔"
    },
    {
        "Question": "ایک لاحقہ درخت کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور موثر تزئین کی تلاش کے لئے طریقے فراہم کریں۔",
        "Answer": "ایک لاحقہ درخت کی نمائندگی کرنے اور موثر اسٹریٹنگ تلاش کے طریقے فراہم کرنے والے ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم PYPI پر دستیاب لاحقہ لاحقہ لاحقہ لاحقہ لاحقہ کلاس استعمال کرسکتے ہیں۔یہاں لاحقہ کلاس کا ایک مثال استعمال ہے: ازگر سے لاحقہ_ٹری امپورٹ لاحقہ لاحقہ، لاحقہ کلاس \"کیلے\" کے تار کے لئے لاحقہ درخت بنانے کے لئے استعمال ہوتا ہے۔تلاش کا طریقہ لاحقہ درخت میں \"انا\" اور \"فو\" کو تلاش کرنے کے لئے استعمال کیا جاتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: ٹری فالسٹی آؤٹ پٹ سے پتہ چلتا ہے کہ \"انا\" \"کیلے\" کا ایک ذخیرہ ہے ، جبکہ \"فو\" نہیں ہے.یہ لاحقہ کلاس لاحقہ درختوں کے ساتھ کام کرنے کے ل several کئی دوسرے طریقے مہیا کرتا ہے ، جیسے داخل کریں ، ہٹائیں ، اور گنتی کریں۔ان طریقوں کا استعمال لاحقہ درخت میں ترمیم کرنے اور درختوں میں سبسٹرنگز کے واقعات کو گننے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ یہ ہے کہ ، ایک لاحقہ درخت ایک ایسا ڈیٹا ڈھانچہ ہے جو تار میں سبسٹرانگز کو موثر انداز میں تلاش کرنے کے لئے استعمال ہوتا ہے۔ازگر کئی پیکیج مہیا کرتا ہے ، جیسے لاحقہ ، جو لاحقہ درختوں کو نافذ کرتے ہیں اور موثر اسٹرنگ تلاش کے لئے طریقے مہیا کرتے ہیں۔ان پیکیجوں کا استعمال ایک لاحقہ درخت کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور موثر اسٹرنگ تلاش کے لئے طریقے فراہم کرنے کے لئے کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"ازگر میں رد عمل پروگرامنگ اور رد عمل کی توسیع (RX) کے اصولوں پر تبادلہ خیال کریں ، اور یہ بتائیں کہ وہ واقعہ سے چلنے والے نظام کو کس طرح آسان بناتے ہیں۔\"",
        "Answer": "رد عمل پروگرامنگ ایک پروگرامنگ نمونہ ہے جو غیر متزلزل ڈیٹا اسٹریمز اور ایونٹ پر مبنی پروگراموں سے متعلق ہے۔ری ایکٹو پروگرامنگ ریئل ٹائم کمپیوٹیشنل مہنگے واقعات کو سنبھالنے کے لئے مفید ہے جو صارف کے لئے انتہائی انٹرایکٹو تجربہ کو اہل بناتے ہیں۔رد عمل پروگرامنگ آبزرور پیٹرن پر مبنی ہے ، جہاں ایک مشاہدہ کرنے والا شے اپنے مبصرین کو مطلع کرتا ہے جب اس کی ریاست تبدیل ہوتی ہے۔ری ایکٹو ایکسٹینشنز (آر ایکس) لائبریری کا استعمال کرتے ہوئے ری ایکٹو پروگرامنگ کا اطلاق کیا جاتا ہے ، جو پائیٹون 123456 میں قابل تعزیرات اور ایونٹ پر مبنی پروگراموں کو مشاہدہ کرنے والے ذخیرے اور پائپ ایبل استفسار آپریٹرز کا استعمال کرتے ہوئے آپریٹرز کا ایک سیٹ فراہم کرتا ہے۔ازگر میں: غیر متزلزل اور واقعہ پر مبنی پروگرامنگ: رد عمل پروگرامنگ غیر متزلزل ڈیٹا اسٹریمز اور ایونٹ پر مبنی پروگراموں سے متعلق ہے۔یہ ڈویلپرز کو مشاہدات کے ساتھ غیر متزلزل ڈیٹا اسٹریمز کی نمائندگی کرنے ، آپریٹرز کا استعمال کرتے ہوئے غیر متزلزل ڈیٹا اسٹریمز سے استفسار کرنے ، اور شیڈولرز کا استعمال کرتے ہوئے ڈیٹا/ایونٹ اسٹریمز میں ہم آہنگی کو پیرامیٹرائز کرنے کی اجازت دیتا ہے۔ڈیٹا حاصل کرنے کے لئے.مشاہدہ کرنے والے اور مبصرین رد عمل پروگرامنگ کے بلڈنگ بلاکس ہیں۔ آپریٹرز: آپریٹرز ایسے کام ہوتے ہیں جو مشاہدات کو تبدیل ، فلٹر یا یکجا کرتے ہیں۔آپریٹرز ڈویلپرز کو سادہ بلڈنگ بلاک کا استعمال کرتے ہوئے پیچیدہ غیر متزلزل اور واقعہ پر مبنی پروگرام تحریر کرنے کی اجازت دیتے ہیں۔ شیڈولرز: شیڈولرز ایسی چیزیں ہیں جو مشاہدات کی ہم آہنگی کو کنٹرول کرتی ہیں۔شیڈولرز ڈویلپرز کو کارکردگی اور وسائل کے استعمال کو بہتر بنانے کے لئے مشاہدہ کرنے والوں کی ہم آہنگی کو پیرامیٹرائز کرنے کی اجازت دیتے ہیں۔ خلاصہ میں ، رد عمل پروگرامنگ ایک پروگرامنگ نمونہ ہے جو غیر متزلزل ڈیٹا اسٹریمز اور ایونٹ پر مبنی پروگراموں سے متعلق ہے۔ری ایکٹیو ایکسٹینشنز (آر ایکس) لائبریری کا استعمال کرتے ہوئے ری ایکٹو پروگرامنگ کا اطلاق کیا جاتا ہے ، جو ازگر میں مشاہدہ کرنے والے مجموعوں اور پائپ ایبل استفسار آپریٹرز کا استعمال کرتے ہوئے غیر سنجیدہ اور واقعہ پر مبنی پروگراموں کو کمپوز کرنے کے لئے آپریٹرز کا ایک سیٹ فراہم کرتا ہے۔ری ایکٹو پروگرامنگ ریئل ٹائم کمپیوٹیشنل مہنگے واقعات کو سنبھالنے کے لئے مفید ہے جو صارف کے لئے انتہائی انٹرایکٹو تجربہ کو اہل بناتے ہیں۔رد عمل پروگرامنگ آبزرور پیٹرن پر مبنی ہے ، جہاں ایک مشاہدہ کرنے والا شے اپنے مبصرین کو مطلع کرتا ہے جب اس کی ریاست تبدیل ہوتی ہے۔"
    },
    {
        "Question": "ڈیٹا بیس میں ہم آہنگی کے کنٹرول کے تصور کی وضاحت کریں اور الگ تھلگ سطح اور ان کے تجارتی تعلقات پر تبادلہ خیال کریں۔",
        "Answer": "ڈیٹا بیس میں ہم آہنگی کا کنٹرول ایک ڈیٹا بیس میں مشترکہ وسائل تک رسائی کا انتظام کرنے کا عمل ہے تاکہ یہ یقینی بنایا جاسکے کہ لین دین کو صحیح اور مستقل انداز میں انجام دیا جائے۔ڈیٹا بیس میں ہم آہنگی کا کنٹرول اہم ہے کیونکہ ایک سے زیادہ لین دین بیک وقت عمل میں لایا جاسکتا ہے ، اور اگر ان کا صحیح انتظام نہیں کیا جاتا ہے تو ، وہ ایک دوسرے کے ساتھ مداخلت کرسکتے ہیں اور ڈیٹا بیس میں تضادات کا سبب بن سکتے ہیں۔یہاں الگ تھلگ کی مختلف سطحیں اور ان کے تجارتی تعلقات ہیں: غیر منقولہ پڑھیں: یہ تنہائی کی سطح لین دین کو دوسرے لین دین سے غیرمعمولی ڈیٹا پڑھنے کی اجازت دیتی ہے۔یہ سطح اعلی سطح کی ہم آہنگی فراہم کرتی ہے بلکہ اعداد و شمار کی مستقل مزاجی کی نچلی سطح کو بھی فراہم کرتی ہے۔یہ سطح غیر معمولی پڑھنے کے مقابلے میں اعداد و شمار کی مستقل مزاجی کی اعلی سطح فراہم کرتی ہے لیکن اس کے نتیجے میں زیادہ مسدود اور کم ہم آہنگی پیدا ہوسکتی ہے۔ قابل عمل پڑھیں: یہ تنہائی کی سطح اس بات کو یقینی بناتی ہے کہ لین دین ڈیٹا بیس کا مستقل سنیپ شاٹ دیکھتا ہے ، چاہے دوسرے لین دین اعداد و شمار میں ترمیم کر رہے ہوں۔یہ سطح پڑھنے کے ارتکاب کے مقابلے میں اعداد و شمار کی مستقل مزاجی کی اعلی سطح فراہم کرتی ہے لیکن اس کے نتیجے میں زیادہ مسدود اور کم ہم آہنگی پیدا ہوسکتی ہے۔ سیریلائز ایبل: یہ تنہائی کی سطح اس بات کو یقینی بناتی ہے کہ لین دین کو سیریلائزنگ ترتیب میں عمل میں لایا جائے ، جس کا مطلب ہے کہ بیک وقت متعدد لین دین کو انجام دینے کا نتیجہ ایک ہی ہے۔جیسا کہ ان کو سیریللی طور پر پھانسی دے رہے ہیں۔یہ سطح اعداد و شمار کی مستقل مزاجی کی اعلی سطح فراہم کرتی ہے لیکن اس کے نتیجے میں زیادہ مسدود اور کم ہم آہنگی پیدا ہوسکتی ہے۔ خلاصہ میں ، ہم آہنگی کا کنٹرول ایک ڈیٹا بیس میں مشترکہ وسائل تک رسائی کا انتظام کرنے کا عمل ہے تاکہ یہ یقینی بنایا جاسکے کہ لین دین کو صحیح اور مستقل طور پر عمل میں لایا جائے۔مختلف تنہائی کی سطح اعداد و شمار میں مستقل مزاجی اور ہم آہنگی کے مابین مختلف تجارتی تعلقات مہیا کرتی ہے۔کسی دیئے گئے درخواست کے ل the مناسب تنہائی کی سطح کا انتخاب کرنا ضروری ہے تاکہ یہ یقینی بنایا جاسکے کہ ڈیٹا بیس مستقل اور موثر ہے۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں خود توازن بائنری تلاش کے درخت کی نمائندگی کی جائے ، جیسے اے وی ایل کا درخت یا سرخ رنگ کا درخت۔\"",
        "Answer": "بائنری تلاش کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے کے ل we ، ہم PYPI پر دستیاب خود توازن بائنری سرچ ٹری پیکیج کا استعمال کرسکتے ہیں۔یہاں ایس بی بی ایس ٹی کلاس کا ایک مثال استعمال ہے: ازالہ خود_بلانسنگ_بائنری_سرچ_ٹری درآمد sbbsttree = sbbsttree = sbbsttree () درخت. insert (5) درخت. insert (3) insert (7) درخت (7) درخت (2) درخت (4) درخت. insert(6) ٹری.نسرٹ (8) پرنٹ (درخت.چارچ (5)) # ٹروپنٹ (درخت۔ سرچ (9)) # فالین اس مثال کے طور پر ، ایس بی بی ایس ٹی کلاس کو خود توازن بائنری سرچ ٹری بنانے کے لئے استعمال کیا جاتا ہے۔داخل کرنے کا طریقہ درخت میں عناصر داخل کرنے کے لئے استعمال ہوتا ہے ، اور درخت میں عناصر کی تلاش کے لئے تلاش کا طریقہ استعمال کیا جاتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: ٹریفلستھیس آؤٹ پٹ سے پتہ چلتا ہے کہ عنصر 5 درخت میں موجود ہے ، جبکہ عنصر 9ایسا نہیں ہے۔ خود توازن بائنری سرچ ٹری پیکیج خود توازن بائنری تلاش کے درختوں کے ساتھ کام کرنے کے ل several کئی دوسرے طریقے مہیا کرتا ہے ، جیسے حذف ، کم سے کم ، زیادہ سے زیادہ اور پیشرو۔ان طریقوں کا استعمال درخت میں ترمیم کرنے اور درختوں میں عناصر کے کم سے کم ، زیادہ سے زیادہ اور پیشرو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ یہ کہ ایک خود توازن بائنری تلاش کا درخت ایک بائنری سرچ درخت ہے جو خود بخود کم اونچائی اور موثر کو برقرار رکھنے کے لئے خود کو متوازن کرتا ہے۔تلاش کے اوقاتازگر کئی پیکیج مہیا کرتا ہے ، جیسے خود توازن بائنری سرچ ٹری ، جو خود توازن بائنری تلاش کے درختوں کو نافذ کرتے ہیں اور درخت کی موثر تلاش اور ترمیم کے طریقے فراہم کرتے ہیں۔ان پیکیجوں کا استعمال ایک ازگر کلاس کو نافذ کرنے کے لئے کیا جاسکتا ہے جس میں بائنری تلاش کے درخت کی نمائندگی ہوتی ہے۔"
    },
    {
        "Question": "\"فلاسک-دی یا پیینجیکٹ جیسے ازگر میں کنٹرول (IOC) کنٹینرز اور انحصار انجیکشن (DI) فریم ورک کے الٹا کے تصور کی وضاحت کریں۔\"",
        "Answer": "کنٹرول کا الٹا (IOC) کنٹینرز اور انحصار انجیکشن (DI) فریم ورک ایسے تصورات ہیں جو ماڈیولر اور برقرار رکھنے والے سافٹ ویئر سسٹم کی ترقی کو آسان بناتے ہیں۔ازگر میں ، بہت سے آئی او سی کنٹینرز اور ڈی آئی فریم ورک دستیاب ہیں جو ان تصورات کو نافذ کرنے کے لئے استعمال ہوسکتے ہیں۔ازگر میں آئی او سی کنٹینرز اور ڈی آئی فریم ورک کے بارے میں سمجھنے کے لئے یہاں کچھ کلیدی نکات ہیں: آئی او سی کنٹینر سافٹ ویئر کے اجزاء ہیں جو اشیاء کی زندگی اور ان کی انحصار کا انتظام کرتے ہیں۔وہ باقی ایپلی کیشن سے اشیاء کی تخلیق اور نظم و نسق کو ڈوپل کرنے کا ایک طریقہ فراہم کرتے ہیں۔ ڈی آئی فریم ورک ایک قسم کا آئی او سی کنٹینر ہے جو رن ٹائم کے وقت اشیاء میں انحصار انجیکشن لگانے کا ایک طریقہ فراہم کرتا ہے۔وہ ڈویلپرز کو کنفیگریشن فائل یا کوڈ میں کسی شے کی انحصار کی وضاحت کرنے کی اجازت دیتے ہیں ، اور ڈی آئی فریم ورک انحصار بنانے اور انجیکشن لگانے کا خیال رکھتا ہے۔ ڈی آئی فریم ورک اجزاء کے مابین جوڑے کو کم کرکے اور سافٹ ویئر سسٹم کی لچک اور برقرار رکھنے میں نمایاں طور پر بہتری لاسکتے ہیں۔سسٹم کو جانچنے اور اس میں ترمیم کرنا آسان ہے۔ ازگر کے لئے دستیاب کئی ڈی فریم ورک دستیاب ہیں ، جیسے فلاسک ڈی ، پیینجیکٹ ، اور انحصار انجیکٹر۔یہ فریم ورک انحصار کی تشکیل اور انجیکشن کے ل different مختلف خصوصیات اور نحو مہیا کرتے ہیں۔ ازگر میں ڈی فریم ورک کا استعمال اتنا عام نہیں ہے جتنا دوسری زبانوں میں جاوا یا. نیٹ جیسے ، لیکن یہ مقبولیت حاصل کررہا ہے کیونکہ ڈویلپرز ڈیکپلنگ انحصار کے فوائد کو پہچانتے ہیں اور امتحان کو بہتر بناتے ہیں۔. خلاصہ میں ، آئی او سی کنٹینرز اور ڈی آئی فریم ورک ایسے تصورات ہیں جو ماڈیولر اور برقرار رکھنے والے سافٹ ویئر سسٹم کی ترقی کو آسان بناتے ہیں۔ازگر میں ، بہت سے ڈی آئی فریم ورک دستیاب ہیں جو ان تصورات کو نافذ کرنے اور سافٹ ویئر سسٹم کی لچک اور برقرار رکھنے کو بہتر بنانے کے لئے استعمال ہوسکتے ہیں۔"
    },
    {
        "Question": "\"ازگر میں ڈیٹا سیریلائزیشن اور ڈیسیریلائزیشن کے اصولوں پر تبادلہ خیال کریں ، اور JSON ، XML ، اور پروٹوکول بفر جیسے مختلف فارمیٹس کا موازنہ کریں۔\"",
        "Answer": "سیریلائزیشن اور ڈیسیریلائزیشن پروگرامنگ میں دو اہم تصورات ہیں جو اشیاء کو آسانی سے ذخیرہ کرنے ، منتقل کرنے اور دوبارہ تشکیل دینے کی اجازت دیتے ہیں۔سیریلائزیشن سے مراد ڈیٹا آبجیکٹ کو کسی فارمیٹ میں تبدیل کرنے کے عمل سے مراد ہے جو ہمیں ڈیٹا کو اسٹور کرنے یا منتقل کرنے کی اجازت دیتا ہے اور پھر جب ڈیسیریلائزیشن کے الٹ عمل کو استعمال کرتے ہوئے ضرورت ہو تو اس چیز کو دوبارہ بنائیں۔ازگر میں ، اعداد و شمار کے سیریلائزیشن کے لئے متعدد فارمیٹس ہیں ، جیسے JSON ، XML ، HDF5 ، اور ازگر کے اچار ، مختلف مقاصد 12345.json (جاوا اسکرپٹ آبجیکٹ نوٹیشن) ڈیٹا کے تبادلے کے لئے وسیع پیمانے پر استعمال شدہ شکل ہے۔یہ انسانی پڑھنے کے قابل اور زبان سے آزاد ہے ، اور یہ XML سے ہلکا ہے۔JSON ماڈیول کا استعمال کرتے ہوئے ، ہم متعدد معیاری ازگر کی اقسام جیسے بول ، ڈکٹ ، انٹ ، فلوٹ ، لسٹ ، سٹرنگ ، ٹیوپل ، کوئی بھی نہیں ، وغیرہ کو سیریلائز اور ڈیسیریلائز کرسکتے ہیں۔XML ڈیٹا ایکسچینج کے لئے ایک اور وسیع پیمانے پر استعمال شدہ شکل ہے۔یہ ایک مارک اپ زبان ہے جو انسانی پڑھنے کے قابل اور خود ساختہ ہے۔XML کو پیچیدہ ڈیٹا ڈھانچے کی نمائندگی کرنے کے لئے استعمال کیا جاسکتا ہے اور اکثر ویب خدمات اور API میں استعمال ہوتا ہے۔ازگر XML کے ساتھ کام کرنے کے ل several کئی لائبریریاں مہیا کرتا ہے ، جیسے عنصر ٹری اور LXML1.Python کا اچار ماڈیول سیریلائزیشن اور ازگر اشیاء کی ڈیسیریلائزیشن کے لئے ایک بہتر انتخاب ہے۔اگر ہمیں انسانی پڑھنے کے قابل فارمیٹ کی ضرورت نہیں ہے یا اگر ہمیں کسٹم آبجیکٹ کو سیریلائز کرنے کی ضرورت ہے تو پھر اچار کے ماڈیول کو استعمال کرنے کی سفارش کی جاتی ہے۔اچار کا ماڈیول ازگر کے معیاری لائبریری کا ایک حصہ ہے اور سیریلائز (اچار) اور ڈیسیریلائز (انپکلنگ) ازگر اشیاء کے لئے طریقوں کو نافذ کرتا ہے۔اچار کا انٹرفیس چار طریقے مہیا کرتا ہے: ڈمپ ، ڈمپ ، بوجھ اور بوجھ۔ڈمپ () کا طریقہ کھلی فائل (فائل نما آبجیکٹ) پر سیریلائز کرتا ہے۔ڈمپ () کا طریقہ ایک تار کو سیریلائز کرتا ہے۔بوجھ () کا طریقہ کھلی فائل نما آبجیکٹ 24 سے ڈیسیریلائز کرتا ہے۔ پروٹوکول بفرز گوگل کے ذریعہ تیار کردہ زبان-اگنوسٹک بائنری سیریلائزیشن فارمیٹ ہے۔پروٹوکول بفرز کو XML اور JSON سے چھوٹا ، تیز ، اور آسان بنانے کے لئے ڈیزائن کیا گیا ہے۔پروٹوکول بفرز اکثر اعلی کارکردگی والے نظاموں میں استعمال ہوتے ہیں جہاں کارکردگی اہم ہوتی ہے ، جیسے تقسیم شدہ نظام اور موبائل ایپلی کیشنز۔ازگر پروٹوبوف نامی ایک لائبریری مہیا کرتا ہے جسے پروٹوکول بفرز 1 میں سیریلائز اور ڈیسیریلائز کرنے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ میں ، سیریلائزیشن اور ڈیسیریلائزیشن پروگرامنگ میں اہم تصورات ہیں جو مختلف نظاموں کے مابین اشیاء کو آسانی سے ذخیرہ کرنے اور منتقل کرنے کی اجازت دیتے ہیں۔ازگر میں ، مختلف مقاصد کے لئے اعداد و شمار کو سیریلائزیشن ، جیسے JSON ، XML ، HDF5 ، اور ازگر کے اچار کے لئے متعدد فارمیٹس ہیں۔JSON اور XML ڈیٹا ایکسچینج کے لئے بڑے پیمانے پر فارمیٹس استعمال کیے جاتے ہیں ، جبکہ ازگر کا اچار کا ماڈیول سیریلائزیشن اور ازگر اشیاء کی ڈیسیریلائزیشن کے لئے ایک بہتر انتخاب ہے۔پروٹوکول بفرز کو XML اور JSON سے چھوٹا ، تیز اور آسان بنانے کے لئے ڈیزائن کیا گیا ہے اور اکثر اعلی کارکردگی والے نظاموں میں استعمال کیا جاتا ہے جہاں کارکردگی اہم ہے۔"
    },
    {
        "Question": "ہدایت شدہ گراف کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور ترجن کے الگورتھم کا استعمال کرتے ہوئے مضبوطی سے منسلک اجزاء تلاش کرنے کے طریقے فراہم کریں۔",
        "Answer": "ایک ہدایت نامہ کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے اور ترجان کے الگورتھم کا استعمال کرتے ہوئے مضبوطی سے منسلک اجزاء تلاش کرنے کے طریقے فراہم کرنے کے ل we ، ہم PYPI پر دستیاب ترجن پیکیج کا استعمال کرسکتے ہیں۔یہاں ترجن طبقے کا ایک مثال استعمال ہے: ازگر سے ترجان درآمد ترجان گراف = {0: [1] ، 1: [2] ، 2: [0 ، 3] ، 3: [4] ، 4: [5 ، 7] ، 5.ایک ہدایت نامہ گراف بنانے اور ترجن کے الگورتھم کا استعمال کرتے ہوئے اس کے مضبوطی سے منسلک اجزاء تلاش کرنے کے لئے استعمال کیا جاتا ہے۔گراف کے مضبوطی سے منسلک اجزاء کو تلاش کرنے کے لئے سختی سے_کونیکیٹڈ_کمپینٹینٹس کا طریقہ استعمال کیا جاتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: [[4 ، 5 ، 6] ، [7 ، 8 ، 9] ، [0 ، 1 ، 2] ، [3]] اس آؤٹ پٹ سے پتہ چلتا ہے کہ گراف کے مضبوطی سے جڑے ہوئے اجزاء [4] [5] [6] ، [7] [7] [8] [9] ، [0] [1] [2] ، اور [1] ہیں۔ ترجنپیکیج ہدایت والے گرافوں کے ساتھ کام کرنے کے لئے کئی دوسرے طریقے مہیا کرتا ہے ، جیسے ADD_NODE ، ADD_EDGE ، ہٹائیں_نوڈ ، اور ہٹ_ج۔ان طریقوں کو گراف میں ترمیم کرنے اور اس کے مضبوطی سے منسلک اجزاء کو تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ میں ، ترجان کا الگورتھم ہدایت شدہ گراف میں مضبوطی سے منسلک اجزاء تلاش کرنے کے لئے ایک مقبول الگورتھم ہے۔ازگر کئی پیکیج مہیا کرتا ہے ، جیسے ترجن ، جو ترجن کے الگورتھم کو نافذ کرتے ہیں اور ہدایت شدہ گراف کے مضبوطی سے منسلک اجزاء تلاش کرنے کے طریقے مہیا کرتے ہیں۔ان پیکیجوں کو ہدایت شدہ گراف کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور ترجان کے الگورتھم کا استعمال کرتے ہوئے مضبوطی سے منسلک اجزاء تلاش کرنے کے طریقے فراہم کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"ازگر میں فنکشنل پروگرامنگ کے تصور کی وضاحت کریں اور اعلی آرڈر کے افعال ، لیمبڈا کے تاثرات ، اور نقشہ/کم/فلٹر آپریشنز کی مثالیں فراہم کریں۔\"",
        "Answer": "فنکشنل پروگرامنگ ایک پروگرامنگ نمونہ ہے جو خالص افعال کے استعمال پر زور دیتا ہے ، جو ایسے افعال ہیں جو مکمل طور پر ان کے آدانوں پر مبنی آؤٹ پٹ تیار کرتے ہیں اور ان کے کوئی مضر اثرات نہیں ہوتے ہیں۔ازگر میں ، اعلی آرڈر کے افعال ، لیمبڈا اظہار ، اور نقشہ/کم/فلٹر آپریشنز کا استعمال کرتے ہوئے فنکشنل پروگرامنگ حاصل کی جاسکتی ہے۔ ہائیڈر آرڈر کے افعال ایسے کام ہوتے ہیں جو دوسرے کاموں کو دلائل کے طور پر لیتے ہیں یا واپسی کے افعال کو نتائج کے طور پر لیتے ہیں۔وہ فنکشنل پروگرامنگ کی ایک اہم خصوصیت ہیں اور زیادہ لچکدار اور دوبارہ قابل استعمال کوڈ بنانے کے لئے استعمال کی جاسکتی ہیں۔ازگر میں ایک اعلی آرڈر فنکشن کی ایک مثال یہ ہے: پیتھونڈف اپلیٹ_ٹوائس (فنک ، آرگ): ریٹرن فنک (فنک (آرگ)) ڈیف ایڈ_فائیو (ایکس): واپسی ایکس + 5 پرنٹ (اطلاق_ٹوائس (ایڈ_فائیو ، 10)) # 20 میں اس مثال، applay_twice فنکشن ایک اعلی آرڈر کا فنکشن ہے جو فنکشن فنک اور دلیل آرگ لیتا ہے ، اور دو بار آرگ پر فنک کا اطلاق کرتا ہے۔add_five فنکشن ایک سادہ فنکشن ہے جو اس کی دلیل میں 5 کا اضافہ کرتا ہے۔اس مثال کی پیداوار 20 ہے ، جو 10 بار 10 پر ADD_FIVE کا اطلاق کرنے کا نتیجہ ہے۔ لامبڈا اظہار گمنام افعال ہیں جن کی ان لائن کی وضاحت کی جاسکتی ہے۔وہ چھوٹے ، ایک وقتی استعمال کے افعال پیدا کرنے کے لئے کارآمد ہیں۔یہاں ازگر میں لیمبڈا اظہار کی ایک مثال ہے: پائیتھوناڈڈ_فائیو = لیمبڈا ایکس: ایکس + 5 پرنٹ (ایڈ_فائیو (10)) # 15 اس مثال کے طور پر ، لیمبڈا کی ورڈ کو ایک چھوٹی سی تقریب کی وضاحت کے لئے استعمال کیا جاتا ہے جو اس کی دلیل میں 5 کو شامل کرتا ہے۔اس کے بعد add_five متغیر کو اس لیمبڈا اظہار کے لئے تفویض کیا جاتا ہے ، اور لیمبڈا اظہار کو 10 کی دلیل کے ساتھ کہا جاتا ہے۔بطور فہرست یا ٹپلس۔وہ فنکشنل انداز میں ڈیٹا کو تبدیل کرنے ، مجموعی کرنے یا فلٹر کرنے کے لئے استعمال ہوتے ہیں۔ازگر میں نقشہ ، کم کرنے اور فلٹر کے استعمال کی ایک مثال یہ ہے: پائیتھنونمبرز = [1 ، 2 ، 3 ، 4 ، 5] چوکوں = فہرست (نقشہ (لیمبڈا ایکس: ایکس ** 2 ، نمبر)) پرنٹ (اسکوائرز) # [1 ، 4 ، 9 ، 16 ، 25] پروڈکٹ = کم کریں (لیمبڈا ایکس ، وائی: ایکس*وائی ، نمبرز) پرنٹ (پروڈکٹ) # 120 ایونس = فہرست (فلٹر (لیمبڈا ایکس: ایکس ٪ 2 == 0 ، نمبر)) پرنٹ.کم فنکشن لیمبڈا اظہار کو لاگو کرنے کے لئے استعمال کیا جاتا ہے جو نمبروں کی فہرست میں موجود تمام نمبروں کو ایک ساتھ بڑھاتا ہے۔فلٹر فنکشن لیمبڈا اظہار کو لاگو کرنے کے لئے استعمال ہوتا ہے جو نمبروں کی فہرست میں موجود تمام عجیب نمبروں کو فلٹر کرتا ہے۔اس مثال کے آؤٹ پٹ ہر آپریشن کے نتائج کو ظاہر کرتا ہے۔ خلاصہ میں ، فنکشنل پروگرامنگ ایک پروگرامنگ نمونہ ہے جو خالص افعال کے استعمال پر زور دیتا ہے ، جو ایسے افعال ہیں جو مکمل طور پر ان کے آدانوں پر مبنی آؤٹ پٹ تیار کرتے ہیں اور ان کے کوئی ضمنی اثرات نہیں ہوتے ہیں۔ازگر میں ، اعلی آرڈر کے افعال ، لیمبڈا اظہار ، اور نقشہ/کم/فلٹر آپریشنز کا استعمال کرتے ہوئے فنکشنل پروگرامنگ حاصل کی جاسکتی ہے۔یہ خصوصیات زیادہ لچکدار اور دوبارہ قابل استعمال کوڈ کی اجازت دیتی ہیں جس کے بارے میں استدلال اور جانچ کرنا آسان ہے۔"
    },
    {
        "Question": "\"ازگر میں واقعہ کی سورسنگ اور سی کیو آر ایس (کمانڈ استفسار کی ذمہ داری کو الگ کرنے) کے تصور کی وضاحت کریں ، اور یہ بتائیں کہ وہ سسٹم اسکیل ایبلٹی اور آڈیٹیبلٹی کو کس طرح بہتر بناسکتے ہیں۔\"",
        "Answer": "ایونٹ سورسنگ ایک سافٹ ویئر ڈیزائن کا نمونہ ہے جس میں ایپلیکیشن کی ریاست میں تمام تبدیلیوں کو واقعات کی ترتیب کے طور پر اسٹور کرنا شامل ہے۔اس نمونہ کو لائبریریوں جیسے واقعات سورسنگ 12 کا استعمال کرتے ہوئے ازگر میں نافذ کیا جاسکتا ہے۔ایونٹ کی سورسنگ کے بارے میں سمجھنے کے لئے کچھ اہم نکات یہ ہیں: واقعات کسی درخواست کی حالت میں تبدیلیوں کے ناقابل تسخیر ریکارڈ ہیں۔وہ اس حقیقت کی نمائندگی کرتے ہیں جو واقع ہوا ہے اور اسے تبدیل نہیں کیا جاسکتا ہے۔ ایونٹ سورسنگ میں تمام واقعات کو ایک ترتیب میں رکھنا شامل ہے ، بجائے اس کے کہ درخواست کی موجودہ حالت کی بجائے۔اس سے ایپلیکیشن کو کسی بھی موقع پر واقعات کو دوبارہ چلانے کے ذریعہ دوبارہ تشکیل دینے کی اجازت ملتی ہے۔ ایونٹ سورسنگ پروگراموں کی اسکیل ایبلٹی اور آڈیٹیبلٹی کو بہتر انداز میں نقل و حرکت اور تقسیم کی اجازت دے کر ، اور درخواست کی حالت میں تمام تبدیلیوں کا مکمل آڈٹ ٹریل فراہم کرکے سسٹم اسکیل ایبلٹی اور آڈیٹیبلٹی کو بہتر بنا سکتا ہے۔کمانڈ استفسار کی ذمہ داری علیحدگی (سی کیو آر ایس) ایک اور سافٹ ویئر ڈیزائن کا نمونہ ہے جس میں سوالات کو سنبھالنے کی ذمہ داری (جو درخواست کی حالت کو بازیافت کرتے ہیں) کی ذمہ داری سے کمانڈ (جو درخواست کی حالت کو تبدیل کرتے ہیں) کو سنبھالنے کی ذمہ داری کو الگ کرنا شامل ہے۔اس نمونہ کو جیانگو-سی کیو آر ایس 3 جیسی لائبریریوں کا استعمال کرتے ہوئے ازگر میں نافذ کیا جاسکتا ہے۔CQRs کے بارے میں سمجھنے کے لئے یہاں کچھ کلیدی نکات ہیں: CQRS میں پڑھنے والے ماڈل (جو کمانڈز کو سنبھالتا ہے) کو پڑھنے والے ماڈل (جو سوالات کو سنبھالتا ہے) سے الگ کرنا شامل ہے۔اس سے پڑھنے اور لکھنے کے کاموں کو زیادہ موثر طریقے سے ہینڈل کرنے کی اجازت ملتی ہے ، کیونکہ انہیں الگ سے بہتر بنایا جاسکتا ہے۔ سی کیو آرز پڑھنے اور لکھنے کے کاموں کو زیادہ موثر ہینڈل کرنے کی اجازت دے کر ، اور اس کے لئے مختلف ڈیٹا اسٹورز کے استعمال کی اجازت دے کر سسٹم اسکیل ایبلٹی اور کارکردگی کو بہتر بناسکتے ہیں۔پڑھیں اور لکھیں ماڈل۔ایونٹ سورسنگ میں واقعات کی ترتیب کے طور پر کسی ایپلی کیشن کی ریاست میں تمام تبدیلیوں کو اسٹور کرنا شامل ہے ، جبکہ سی کیو آر ایس میں سوالات کو سنبھالنے کی ذمہ داری سے کمانڈوں کو سنبھالنے کی ذمہ داری کو الگ کرنا شامل ہے۔دونوں نمونوں کو لائبریریوں جیسے واقعات سورسنگ اور جیانگو-سی کیو آرز کا استعمال کرتے ہوئے ازگر میں نافذ کیا جاسکتا ہے۔"
    },
    {
        "Question": "ایک لاحقہ سرنی کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور موثر تزئین کی تلاش اور پیٹرن مماثلت کے لئے طریقے فراہم کریں۔",
        "Answer": "ایک لاحقہ سرنی کی نمائندگی کرنے والے ایک ازگر کلاس کو نافذ کرنے اور موثر اسٹرنگ سرچ اور پیٹرن مماثلت کے طریقے فراہم کرنے کے ل we ، ہم PYPI پر دستیاب لاحقہ_رای پیکیج کا استعمال کرسکتے ہیں۔یہاں لاحقہ کلاس کا ایک مثال استعمال ہے: پائیٹون سے لاحقہ_رای امپورٹ اسفکسرری ٹیکسٹ = \"کیلے\" لاحقہ_رای = لاحقہ (متن) پرنٹ (لاحقہ_ارری۔) # [1 ، 3] اس مثال میں ، \"کیلے\" کے تار کے لئے لاحقہ سرنی بنانے کے لئے لاحقہ کلاس کا استعمال کیا جاتا ہے۔تلاش کے طریقہ کار کو لاحقہ سرنی میں \"عنا\" کی تلاش کے لئے استعمال کیا جاتا ہے ، اور پیٹرن_مچنگ کا طریقہ لاحقہ سرنی میں پیٹرن کے تمام واقعات کو تلاش کرنے کے لئے استعمال کیا جاتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: [1 ، 3] [1 ، 3] اس آؤٹ پٹ سے پتہ چلتا ہے کہ \"انا\" \"کیلے\" کا ایک ذخیرہ ہے اور لاحقہ سرنی میں 1 اور 3 پوزیشنوں پر پایا جاتا ہے۔اسی طرح ، نمونہ \"ایک\" لاحقہ سرنی میں پوزیشن 1 اور 3 پر ہوتا ہے۔ لاحقہ_ اری پیکیج لاحقہ سرنیوں کے ساتھ کام کرنے کے لئے کئی دوسرے طریقے مہیا کرتا ہے ، جیسے get_suffix_array ، get_lcp_array ، اور get_suffix_tree۔ان طریقوں کا استعمال لاحقہ سرنی ، سب سے طویل عام پریفکس سرنی ، اور متن کے لاحقہ درخت کو بازیافت کرنے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ یہ ہے کہ ، ایک لاحقہ سرنی ایک ایسا ڈیٹا ڈھانچہ ہے جو کسی تار میں سبسٹرنگز کو موثر انداز میں تلاش کرنے کے لئے استعمال ہوتا ہے۔ازگر کئی پیکیج مہیا کرتا ہے ، جیسے لاحقہ_یری ، جو لاحقہ سرنیوں کو نافذ کرتے ہیں اور موثر اسٹرنگ سرچ اور پیٹرن مماثلت کے لئے طریقے مہیا کرتے ہیں۔ان پیکیجوں کا استعمال ایک لاحقہ سرنی کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور موثر اسٹرنگ تلاش اور پیٹرن مماثل کے لئے طریقے فراہم کرنے کے لئے کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"سافٹ ویئر ٹیسٹنگ کے اصولوں اور جانچ کے مختلف اصولوں پر تبادلہ خیال کریں ، جیسے یونٹ ٹیسٹنگ ، انضمام کی جانچ ، اور سسٹم ٹیسٹنگ۔\"",
        "Answer": "سافٹ ویئر کی جانچ کسی سافٹ ویئر ایپلی کیشن یا سسٹم کی جانچ کرنے کا عمل ہے تاکہ یہ یقینی بنایا جاسکے کہ یہ مخصوص ضروریات کو پورا کرتا ہے اور توقع کے مطابق کام کرتا ہے۔سافٹ ویئر ٹیسٹنگ کے متعدد اصول ہیں ، بشمول ابتدائی جانچ ، مکمل جانچ ناممکن ہے ، اور ٹیسٹنگ نقائص کی موجودگی کو ظاہر کرتی ہے۔سافٹ ویئر ایپلی کیشنز کی جانچ کے لئے مختلف قسم کے ٹیسٹنگ کے نقطہ نظر کا استعمال کیا جاسکتا ہے ، بشمول: یونٹ ٹیسٹنگ: اس قسم کی جانچ سافٹ ویئر ڈیزائن کی سب سے چھوٹی یونٹ ، جیسے انفرادی افعال یا طریقوں پر مرکوز ہے۔یہ اکثر پروگرامر کے ذریعہ نمونہ ان پٹ کا استعمال کرتے ہوئے اور اس سے متعلقہ نتائج کا مشاہدہ کرتے ہوئے کیا جاتا ہے۔ انٹیگریشن ٹیسٹنگ: اس قسم کی جانچ کی تصدیق ہوتی ہے کہ مختلف ماڈیول یا خدمات جو کسی ایپلی کیشن کے ذریعہ استعمال ہوتی ہیں وہ مل کر کام کرتی ہیں۔مثال کے طور پر ، یہ ڈیٹا بیس کے ساتھ تعامل کی جانچ کر سکتا ہے یا اس بات کو یقینی بنا سکتا ہے کہ مائکروسروائسز توقع کے مطابق مل کر کام کریں۔ سسٹم کی جانچ: اس قسم کی جانچ جانچ کے لئے فعال اور غیر فعال دونوں ضروریات کا اندازہ کرتی ہے۔یہ اجزاء کی مجموعی تعامل کی جانچ کرتا ہے اور اس میں بوجھ ، کارکردگی ، وشوسنییتا ، اور سیکیورٹی ٹیسٹنگ شامل ہے۔ قبولیت کی جانچ: اس قسم کی جانچ کی جانچ پڑتال کرتی ہے کہ آیا اس کی فراہمی کے مطابق کسی تصریح یا معاہدے کی ضروریات پوری ہوتی ہیں۔موکل کے ذریعہ یہ یقینی بنانے کے لئے کیا جاتا ہے کہ خصوصیات ان کی ضروریات کے مطابق ہیں جو ان کی فہرست میں ہیں۔ ایس ایم او سی ای ٹیسٹنگ: اس قسم کی جانچ ایک تیز اور اتلی امتحان ہے جو جانچ پڑتال کرتا ہے کہ آیا سافٹ ویئر کی ایپلی کیشن مزید جانچ کے ساتھ آگے بڑھنے کے لئے کافی مستحکم ہے یا نہیں۔اس قسم کی جانچ اس بات کو یقینی بنانے کے لئے کی جاتی ہے کہ سافٹ ویئر ایپلی کیشن میں تبدیلیاں نئے کیڑے یا مسائل کو متعارف نہیں کرواتی ہیں۔ کارکردگی کی جانچ: اس قسم کی جانچ مختلف حالتوں کے تحت سافٹ ویئر ایپلی کیشن کی کارکردگی کا اندازہ کرنے کے لئے کی جاتی ہے ، جیسے اعلی بوجھ یا تناؤ۔سیکیورٹی ٹیسٹنگ: اس قسم کی جانچ سافٹ ویئر ایپلی کیشن کی حفاظت کا اندازہ کرنے اور کسی بھی کمزوریوں یا کمزوریوں کی نشاندہی کرنے کے لئے کی جاتی ہے۔ خلاصہ یہ کہ سافٹ ویئر کی جانچ سافٹ ویئر کی ترقی میں ایک اہم عمل ہے جو اس بات کو یقینی بناتا ہے کہ سافٹ ویئر کی ایپلی کیشن مخصوص ضروریات کو پورا کرے اور توقع کے مطابق کام کرے۔سافٹ ویئر ایپلی کیشنز کی جانچ کے لئے مختلف قسم کی جانچ کے طریقوں کا استعمال کیا جاسکتا ہے ، جس میں یونٹ ٹیسٹنگ ، انضمام کی جانچ ، سسٹم ٹیسٹنگ ، قبولیت کی جانچ ، دھواں کی جانچ ، ریگریشن ٹیسٹنگ ، کارکردگی کی جانچ ، اور سیکیورٹی ٹیسٹنگ شامل ہیں۔ہر قسم کی جانچ کے نقطہ نظر کا اپنا مقصد ہوتا ہے اور سافٹ ویئر ایپلی کیشن میں مختلف قسم کے مسائل یا کیڑے کی نشاندہی کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"تقسیم شدہ نظاموں کے تصور کی وضاحت کریں اور ازگر میں مستقل مزاجی ، دستیابی ، اور تقسیم رواداری (سی اے پی تھیوریم) کے چیلنجوں پر تبادلہ خیال کریں۔\"",
        "Answer": "تقسیم شدہ نظام کمپیوٹر سسٹم ہیں جو متعدد باہم مربوط کمپیوٹرز پر مشتمل ہیں جو مشترکہ مقصد کے حصول کے لئے ایک دوسرے کے ساتھ بات چیت اور ہم آہنگی کرتے ہیں۔کیپ تھیوریم ایک ایسا تصور ہے جو تقسیم شدہ نظاموں کی تعمیر کے چیلنجوں کو بیان کرتا ہے جو مستقل ، دستیاب اور تقسیم کو روادار ہیں۔کیپ تھیوریم کے مطابق ، تقسیم شدہ نظام میں بیک وقت ان تینوں پراپرٹیز کو حاصل کرنا ناممکن ہے۔اس کے بجائے ، ڈیزائنرز کو یہ انتخاب کرنا ہوگا کہ سسٹم کی مخصوص تقاضوں کی بنیاد پر ترجیح دینے کے لئے کون سی دو خصوصیات کو ترجیح دیں۔ یہاں ازگر میں کیپ تھیوریم اور تقسیم شدہ نظاموں کے بارے میں سمجھنے کے لئے کچھ اہم نکات ہیں: مستقل مزاجی سے اس ضرورت کا مطلب ہے کہ تقسیم شدہ نظام میں موجود تمام نوڈس دیکھیں۔ایک ہی وقت میں ایک ہی ڈیٹا.مستقل مزاجی کا حصول کسی تقسیم شدہ نظام میں چیلنج ہوسکتا ہے کیونکہ نیٹ ورک میں تاخیر یا ناکامیوں کی وجہ سے نوڈس کے اعداد و شمار کے مختلف نظریات ہوسکتے ہیں۔ دستیابی سے مراد اس ضرورت سے مراد ہے کہ تقسیم شدہ نظام ناکامیوں یا نیٹ ورک پارٹیشنوں کے باوجود بھی آپریشنل اور ذمہ دار رہتا ہے۔تقسیم شدہ نظام میں دستیابی کا حصول چیلنج ہوسکتا ہے کیونکہ نیٹ ورک کے مسائل کی وجہ سے نوڈس ناکام یا ناقابل رسائی ہوسکتے ہیں۔ پارٹیشن رواداری سے مراد اس ضرورت سے مراد ہے کہ جب تقسیم شدہ نظام کام کرتا رہتا ہے یہاں تک کہ جب نیٹ ورک پارٹیشنز پائے جاتے ہیں۔تقسیم شدہ نظام میں تقسیم رواداری کا حصول مشکل ہوسکتا ہے کیونکہ نیٹ ورک کے مسائل کی وجہ سے نوڈس ایک دوسرے سے الگ تھلگ ہوسکتے ہیں۔ مختلف قسم کی جانچ کے نقطہ نظر کو تقسیم شدہ نظاموں کی جانچ کے لئے استعمال کیا جاسکتا ہے ، جس میں یونٹ ٹیسٹنگ ، انضمام کی جانچ ، سسٹم کی جانچ ، قبولیت کی جانچ ، دھواں شامل ہے۔جانچ ، رجعت ٹیسٹنگ ، کارکردگی کی جانچ ، اور سیکیورٹی ٹیسٹنگ۔ خلاصہ میں ، تقسیم شدہ نظام کمپیوٹر سسٹم ہیں جو ایک سے زیادہ باہم مربوط کمپیوٹرز پر مشتمل ہیں جو مشترکہ مقصد کے حصول کے لئے ایک دوسرے کے ساتھ بات چیت اور ہم آہنگی کرتے ہیں۔کیپ تھیوریم تقسیم شدہ نظاموں کی تعمیر کے چیلنجوں کی وضاحت کرتا ہے جو مستقل ، دستیاب اور تقسیم روادار ہیں۔ازگر کئی لائبریریوں اور فریم ورک مہیا کرتا ہے ، جیسے پائرو 4 اور اجوائن ، جو تقسیم شدہ نظاموں کی تعمیر کے لئے استعمال ہوسکتے ہیں۔جانچ تقسیم شدہ نظاموں کی تعمیر کا ایک اہم حصہ ہے ، اور مختلف قسم کے ٹیسٹنگ کے نقطہ نظر کو تقسیم شدہ نظاموں کی جانچ کے لئے استعمال کیا جاسکتا ہے ، جس میں یونٹ ٹیسٹنگ ، انضمام کی جانچ ، سسٹم کی جانچ ، قبولیت کی جانچ ، دھواں کی جانچ ، ریگریشن ٹیسٹنگ ، کارکردگی کی جانچ ، اور سیکیورٹی ٹیسٹنگ شامل ہیں۔1DSSTREAM2HACKERNOON 3TOWARDASDATASCIENCE 4MYGREATLEARNNING5 ہیکرنون"
    },
    {
        "Question": "\"اسکیپ لسٹ کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور اوسط کیس کے موثر وقت کی پیچیدگی کے ساتھ داخل ، حذف کرنے اور تلاش کے طریقے فراہم کریں۔\"",
        "Answer": "اسکیپ لسٹ کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے اور اوسط کیس کے موثر وقت کی پیچیدگی کے ساتھ اندراج ، حذف کرنے ، اور تلاش کے طریقے فراہم کرنے کے ل we ، ہم PYPI پر دستیاب اسکیپ_ لسٹ پیکیج کا استعمال کرسکتے ہیں۔یہاں اسکیپلسٹ کلاس کا ایک مثال استعمال ہے: پائیٹونفرم اسکیپ_ لسٹ درآمد اسکیپلسٹسکیپ_ لسٹ = اسکیپلسٹ () اسکیپ_ لسٹ.نسرٹ (1) اسکیپ_ لسٹ.نسرٹ (2) اسکیپ_لسٹ.نسٹ (3) پرنٹ (اسکیپ_لسٹ.سرچ (2)) # ٹریسکپپ_لیسٹ۔) پرنٹ (اسکیپ_ لسٹ.سارچ (2)) # فلاح و بہبود اس مثال کے طور پر ، اسکیپلسٹ کلاس کو اسکیپ لسٹ بنانے اور اس میں تین عناصر داخل کرنے کے لئے استعمال کیا جاتا ہے۔تلاش کے طریقہ کار کو اسکیپ لسٹ میں عنصر 2 کی تلاش کے لئے استعمال کیا جاتا ہے ، اور ڈیلیٹ کا طریقہ عنصر 2 کو اسکیپ لسٹ سے حذف کرنے کے لئے استعمال کیا جاتا ہے۔ اس مثال کی پیداوار یہ ہے کہ: ٹری فالسٹی آؤٹ پٹ سے پتہ چلتا ہے کہ عنصر 2 میں موجود ہےاس کو حذف کرنے سے پہلے اس کی فہرست چھوڑ دیں ، اور اسے حذف کرنے کے بعد غیر حاضر ہوں۔ اسکیپ_ لسٹ پیکیج اسکیپ لسٹوں کے ساتھ کام کرنے کے ل several کئی دوسرے طریقے مہیا کرتا ہے ، جیسے گیٹ ، سیٹ ، اور اس پر مشتمل ہے۔ان طریقوں کو اسکیپ لسٹ میں عناصر کی موجودگی ، ترمیم کرنے اور جانچنے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ یہ کہ اسکیپ لسٹ ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو موثر تلاش ، اندراج اور ہٹانے کے کاموں کی اجازت دیتا ہے۔ازگر کئی پیکیج مہیا کرتا ہے ، جیسے اسکیپ_ لسٹ ، جو اسکیپ لسٹوں کو نافذ کرتے ہیں اور موثر اضافے ، حذف کرنے ، اور موثر اوسطا وقت کی پیچیدگی کے ساتھ تلاش کے طریقے مہیا کرتے ہیں۔ان پیکیجوں کو اسکیپ لسٹ کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے اور موثر اضافے ، حذف کرنے ، اور موثر اوسط کیس ٹائم پیچیدگی کے ساتھ تلاش کرنے کے طریقے فراہم کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "سافٹ ویئر ریفیکٹرنگ کے تصور کی وضاحت کریں اور ازگر میں کوڈ کی بو اور ریفیکٹرنگ تکنیک کی مثالیں فراہم کریں۔",
        "Answer": "سافٹ ویئر ریفیکٹرنگ کوڈ کے معیار کو بہتر بنانے کا عمل ہے جس کو اس کی فعالیت کو تبدیل کیے بغیر اسے زیادہ پڑھنے کے قابل ، برقرار رکھنے اور موثر بنا دیا گیا ہے۔ریفیکٹرنگ سافٹ ویئر ڈویلپمنٹ کا ایک لازمی حصہ ہے جو کوڈ کے معیار کو بہتر بنانے اور تکنیکی قرض کو کم کرنے میں مدد کرتا ہے۔ازگر میں کوڈ کی بو اور ریفیکٹرنگ کی تکنیک کی کچھ مثالیں یہ ہیں: لمبے طریقے: لمبے طریقوں کو پڑھنا اور سمجھنا مشکل ہے۔ریفیکٹر لمبے طریقوں کے ل we ، ہم نچوڑ کے طریقہ کار کو ریفیکٹرنگ تکنیک کا استعمال کرتے ہیں تاکہ انہیں چھوٹے ، زیادہ قابل انتظام طریقوں میں توڑ ڈالیں۔ متناسب کوڈ: ڈپلیکیٹ کوڈ ناقص ڈیزائن کی علامت ہے اور بحالی کے مسائل کا باعث بن سکتا ہے۔ریفیکٹر ڈپلیکیٹ کوڈ کے ل we ، ہم دوبارہ استعمال کے قابل کوڈ بنانے کے لئے نچوڑ کا طریقہ کار یا نکالنے والے کلاس ریفیکٹرنگ تکنیک کا استعمال کرسکتے ہیں۔ کلاسز کو وسیع کلاس: بڑی کلاسوں کو برقرار رکھنا مشکل ہے اور کارکردگی کے مسائل کا باعث بن سکتے ہیں۔ریفیکٹر بڑی کلاسوں کے ل we ، ہم ایکسٹریکٹ کلاس یا ایکسٹریکٹ انٹرفیس ریفیکٹرنگ تکنیک کو چھوٹے ، زیادہ قابل انتظام کلاسوں میں توڑنے کے لئے استعمال کرسکتے ہیں۔ریفیکٹر غیر موثر الگورتھم کے ل we ، ہم تبدیل الگورتھم کو استعمال کرسکتے ہیں یا ان کی کارکردگی کو بہتر بنانے کے لئے پیرامیٹر آبجیکٹ ریفیکٹرنگ کی تکنیک کو متعارف کراسکتے ہیں۔ پیتھون کئی ٹولز اور لائبریری فراہم کرتا ہے جو ریفیکٹرنگ کے لئے استعمال ہوسکتے ہیں ، جیسے پائچرم ، باؤلر اور رسی۔یہ ٹولز ڈویلپرز کو ان کے کوڈ کے معیار کو بہتر بنانے میں مدد کے لئے خودکار ریفیکٹرنگ ، کوڈ تجزیہ ، اور کوڈ نیویگیشن جیسی خصوصیات مہیا کرتے ہیں۔ خلاصہ یہ ہے کہ سافٹ ویئر ریفیکٹرنگ کوڈ کے معیار کو بہتر بنانے کا عمل ہے جس کو مزید پڑھنے کے قابل ، برقرار رکھنے اور موثر بنا کر اسے بہتر بنایا جائے۔اس کی فعالیت کو تبدیل کرنا۔ازگر متعدد ٹولز اور لائبریریوں کو مہیا کرتا ہے جو ریفیکٹرنگ کے لئے استعمال ہوسکتے ہیں ، اور کوڈ کے معیار کو بہتر بنانے کے لئے کوڈ کی بو اور ریفیکٹرنگ کی متعدد تکنیکیں ہیں جو استعمال کی جاسکتی ہیں۔مستقل طور پر ریفیکٹرنگ کوڈ کے ذریعہ ، ڈویلپرز تکنیکی قرض کو کم کرسکتے ہیں اور اپنے سافٹ ویئر ایپلی کیشنز کے معیار کو بہتر بنا سکتے ہیں۔"
    },
    {
        "Question": "ڈومین سے متعلق مخصوص زبانوں (DSLs) کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ ان کو PYDSL یا ANTLR جیسی لائبریریوں کا استعمال کرتے ہوئے ازگر میں کیسے نافذ کیا جاسکتا ہے۔",
        "Answer": "ڈومین سے متعلق زبانیں (DSLs) پروگرامنگ کی زبانیں ہیں جو ایک مخصوص ڈومین میں مسائل کو حل کرنے کے لئے تیار کی گئیں ہیں۔ڈی ایس ایل کو ایک مخصوص طبقے کی پریشانیوں اور فیلڈ یا ڈومین سے تصورات اور قواعد استعمال کرنے کے لئے بہتر بنایا جاتا ہے۔ازگر جیسی عمومی مقصد کی زبانوں کے مقابلے میں ، ڈی ایس ایل کم نفیس ہیں اور اکثر غیر روایتی پروگرامرز استعمال کرنے کا ارادہ رکھتے ہیں جو ڈی ایس ایل کے لئے تیار کردہ ڈومین میں روانی رکھتے ہیں۔ڈی ایس ایل عام طور پر انڈسٹری کے پیشہ ور افراد کے ساتھ قریبی تعاون سے تخلیق کیا جاتا ہے جس کے لئے وہ بنائے جارہے ہیں۔ازگر میں ڈی ایس ایل کا نفاذ PYDSL یا antlr جیسے لائبریریوں کا استعمال کرتے ہوئے کیا جاسکتا ہے۔ یہاں ڈومین سے متعلق مخصوص زبانوں کے کچھ اصول ہیں اور ازگر میں کوڈ کی بو آ رہی ہیں اور ریفیکٹرنگ تکنیک کی مثالیں: DSLs کو ایک مخصوص ڈومین میں مسائل حل کرنے کے لئے ڈیزائن کیا گیا ہے اور اس ڈومین کے لئے بہتر بنایا گیا ہے اور اس ڈومین کے لئے بہتر بنایا گیا ہے۔.DSLs اس ڈومین سے تصورات اور قواعد کا استعمال کرتے ہیں جس کے لئے وہ ڈیزائن کیے گئے ہیں۔ ڈی ایس ایل عام مقاصد کی زبانوں سے کم پیچیدہ ہیں جیسے ازگر۔ ڈی ایس ایل کا مقصد اکثر غیر پروگرامرز کے ذریعہ استعمال کرنا ہوتا ہے جو ڈومین میں روانی رکھتے ہیں۔ ڈی ایس ایل کے لئے بنایا گیا ہے۔عام طور پر انڈسٹری کے پیشہ ور افراد کے ساتھ قریبی تعاون سے پیدا ہوتے ہیں جن کے لئے وہ بنائے جارہے ہیں۔ کوڈ کے مثال کے طور پر ازگر میں بدبو اور ریفیکٹرنگ تکنیک جو DSLs میں کوڈ کے معیار کو بہتر بنانے کے لئے استعمال کی جاسکتی ہیں: لمبے طریقے: لمبے طریقے مشکل ہیں۔پڑھیں اور سمجھیں۔ریفیکٹر لمبے طریقوں کے ل we ، ہم نچوڑ کے طریقہ کار کو ریفیکٹرنگ تکنیک کا استعمال کرتے ہیں تاکہ انہیں چھوٹے ، زیادہ قابل انتظام طریقوں میں توڑ ڈالیں۔ متناسب کوڈ: ڈپلیکیٹ کوڈ ناقص ڈیزائن کی علامت ہے اور بحالی کے مسائل کا باعث بن سکتا ہے۔ریفیکٹر ڈپلیکیٹ کوڈ کے ل we ، ہم دوبارہ استعمال کے قابل کوڈ بنانے کے لئے نچوڑ کا طریقہ کار یا نکالنے والے کلاس ریفیکٹرنگ تکنیک کا استعمال کرسکتے ہیں۔ کلاسز کو وسیع کلاس: بڑی کلاسوں کو برقرار رکھنا مشکل ہے اور کارکردگی کے مسائل کا باعث بن سکتے ہیں۔ریفیکٹر بڑی کلاسوں کے ل we ، ہم ایکسٹریکٹ کلاس یا ایکسٹریکٹ انٹرفیس ریفیکٹرنگ تکنیک کو چھوٹے ، زیادہ قابل انتظام کلاسوں میں توڑنے کے لئے استعمال کرسکتے ہیں۔ریفیکٹر ناکارہ الگورتھم کے ل we ، ہم ان کی کارکردگی کو بہتر بنانے کے لئے تبدیل الگورتھم کا استعمال کرسکتے ہیں یا پیرامیٹر آبجیکٹ ریفیکٹرنگ کی تکنیک کو متعارف کراسکتے ہیں۔ پیتھون کئی ٹولز اور لائبریری فراہم کرتا ہے جو DSLs کو نافذ کرنے کے لئے استعمال ہوسکتے ہیں ، جیسے PYDSL اور ANTLR۔یہ ٹولز ڈویلپرز کو اپنے کوڈ کے معیار کو بہتر بنانے میں مدد کے لئے خودکار ریفیکٹرنگ ، کوڈ تجزیہ ، اور کوڈ نیویگیشن جیسی خصوصیات مہیا کرتے ہیں۔ خلاصہ میں ، ڈومین سے متعلق مخصوص زبانیں پروگرامنگ زبانیں ہیں جو ایک مخصوص ڈومین میں مسائل کو حل کرنے کے لئے تیار کی گئیں ہیں۔ازگر میں DSLs کو نافذ کرنا PYDSL یا ANTLR جیسی لائبریریوں کا استعمال کرتے ہوئے کیا جاسکتا ہے۔ایکسٹریکٹ طریقہ ، ایکسٹریکٹ کلاس ، اور الگورتھم کو تبدیل کرنے والی تکنیکوں کا استعمال کرتے ہوئے مستقل طور پر ریفیکٹرنگ کوڈ کے ذریعہ ، ڈویلپرز تکنیکی قرض کو کم کرسکتے ہیں اور اپنے DSLs.1quansight2marktechpost3dbader4dev5ksu کے معیار کو بہتر بنا سکتے ہیں۔"
    },
    {
        "Question": "\"میسج کی قطار کے تصور کی وضاحت کریں اور ازگر میں نمونوں کو شائع کریں ، اور اس پر تبادلہ خیال کریں کہ ان کو غیر متزلزل مواصلات اور واقعہ سے چلنے والے فن تعمیر کے لئے کس طرح استعمال کیا جاسکتا ہے۔\"",
        "Answer": "میسج کی قطاریں اور شائع سبسکرائب پیٹرن دو عام نمونے ہیں جو تقسیم شدہ نظاموں میں استعمال ہوتے ہیں تاکہ متضاد مواصلات اور واقعہ سے چلنے والے فن تعمیر کو قابل بنائیں۔یہاں ہر ایک کی ایک مختصر وضاحت ہے: میسج کی قطاریں: پیغام کی قطاریں بھیجنے والے کو ڈیکپل کرنے اور کسی پیغام کو وصول کرنے کا ایک طریقہ ہے۔کسی وصول کنندہ کو براہ راست پیغام بھیجنے کے بجائے ، بھیجنے والا پیغام کو قطار پر رکھتا ہے ، اور وصول کنندہ تیار ہونے پر پیغام کو قطار سے بازیافت کرتا ہے۔اس سے تقسیم شدہ نظام کے اجزاء کے مابین غیر متزلزل مواصلات کی اجازت ملتی ہے۔ پبلش سبسکرائب پیٹرن: شائع کریں سبسکرائب کرنے والے نمونے متعدد صارفین کو پیغامات نشر کرنے کا ایک طریقہ ہیں۔اس طرز میں ، پبلشر مختلف زمروں میں پیغامات تیار کرتے ہیں ، اور صارفین مختلف قسموں کے پیغامات استعمال کرتے ہیں جن کی وہ سبسکرائب کی جاتی ہے۔پوائنٹ ٹو پوائنٹ میسجنگ کے برعکس ، ایک پیغام صرف اس صورت میں حذف ہوجائے گا جب اس کو زمرہ میں تمام صارفین کے ذریعہ کھایا جائے۔ پیتھون کئی لائبریریوں اور فریم ورک مہیا کرتا ہے جو میسج کی قطار کو نافذ کرنے اور شائع کرنے کے لئے استعمال کیا جاسکتا ہے ، جیسے پائیڈس ایل ، اینٹ ایل آر ،اور ربیٹ ایم کیو۔یہ لائبریریاں ڈویلپرز کو اپنے کوڈ کے معیار کو بہتر بنانے میں مدد کے لئے خودکار ریفیکٹرنگ ، کوڈ تجزیہ ، اور کوڈ نیویگیشن جیسی خصوصیات مہیا کرتی ہیں۔ خلاصہ ، پیغام کی قطاریں اور شائع سبسکرائب پیٹرن تقسیم شدہ نظاموں میں استعمال ہونے والے دو عام نمونے ہیں تاکہ متضاد مواصلات اور واقعہ کو قابل بنائیں۔کارفرما فن تعمیر۔ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو میسج کی قطار کو نافذ کرنے اور شائع کرنے والے نمونوں کو شائع کرنے کے لئے استعمال کیا جاسکتا ہے ، جیسے PYDSL ، ANTLR ، اور RABITMQ۔ان نمونوں اور لائبریریوں کا استعمال کرکے ، ڈویلپرز زیادہ توسیع پزیر اور لچکدار تقسیم شدہ نظام تیار کرسکتے ہیں۔"
    },
    {
        "Question": "ریڈکس ٹری کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور موثر سٹرنگ پریفکس تلاش اور بازیافت کے لئے طریقے فراہم کریں۔",
        "Answer": "ریڈکس ٹری کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور موثر سٹرنگ پریفکس تلاش اور بازیافت کے طریقے فراہم کرنے کے ل we ، ہم PYPI پر ٹری پیکیج میں دستیاب ٹری کلاس کا استعمال کرسکتے ہیں۔یہاں ٹری کلاس کا ایک مثال استعمال ہے: ازگر سے ٹری امپورٹ ٹرائٹرری = ٹری () ٹری۔ انرٹ (\"ایپل\") ٹری.سرٹ (\"کیلے\") ٹرائی.سرٹ (\"اورنج\") پرنٹ (ٹری۔ سرچ (\"ایپ\")) # ٹروپنٹ (ٹری۔ سرچ (\"ناشپاتیاں\")) # فالس پرنٹ (ٹری.پری فکسس (\"اے\")) # ['ایپل'] اس مثال میں ، ٹری کلاس کو ریڈکس ٹری بنانے اور تین عناصر داخل کرنے کے لئے استعمال کیا جاتا ہے۔اس میں.تلاش کا طریقہ ٹرائی میں موجود \"ایپ\" کی تلاش کے لئے استعمال کیا جاتا ہے ، اور خطوط \"A\" کے ساتھ شروع ہونے والے تمام سابقوں کو بازیافت کرنے کے لئے پریفکس کا طریقہ استعمال کیا جاتا ہے۔ اس مثال کی آؤٹ پٹ یہ ہے: ٹری فالس ['ایپل']آؤٹ پٹ سے پتہ چلتا ہے کہ ٹری میں \"ایپ\" کا سابقہ موجود ہے ، ٹری میں سابقہ \"ناشپاتیاں\" موجود نہیں ہے ، اور واحد سابقہ جو \"A\" \"ایپل\" ہے۔ ٹری پیکیج کئی دوسرے طریقے مہیا کرتا ہے۔ریڈکس کی کوششوں کے ساتھ کام کرنے کے لئے ، جیسے حذف ، اشیاء اور چابیاں۔ان طریقوں کا استعمال ٹری سے عناصر کو حذف کرنے ، ٹری میں موجود تمام عناصر کو بازیافت کرنے ، اور ٹری میں تمام چابیاں بازیافت کرنے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ میں ، ایک ریڈکس ٹری ایک اعداد و شمار کا ڈھانچہ ہے جو تاروں کے ایک سیٹ میں سابقہ سابقہ تلاش کرنے کے لئے استعمال ہوتا ہے۔ازگر کئی پیکیج مہیا کرتا ہے ، جیسے ٹری ، جو ریڈکس کی کوششوں کو نافذ کرتا ہے اور موثر سٹرنگ پریفکس تلاش اور بازیافت کے لئے طریقے مہیا کرتا ہے۔ان پیکیجوں کو ریڈکس ٹری کی نمائندگی کرنے والے ازگر کلاس کو نافذ کرنے اور موثر سٹرنگ پریفکس تلاش اور بازیافت کے طریقے فراہم کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "ڈیٹا کمپریشن کے تصور کی وضاحت کریں اور ازگر میں ہف مین کوڈنگ یا لیمپل زیو ویلچ (LZW) جیسے کمپریشن الگورتھم کی مثالیں فراہم کریں۔",
        "Answer": "ڈیٹا کمپریشن اسٹوریج کی جگہ اور ٹرانسمیشن کے وقت کو بچانے کے ل data ڈیٹا کے سائز کو کم کرنے کا عمل ہے۔ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو ڈیٹا کمپریشن کے لئے استعمال ہوسکتے ہیں ، جیسے ZLIB ، GZIP ، BZIP2 ، LZMA ، اور ٹارفائل۔یہاں کمپریشن الگورتھم کی کچھ مثالیں ہیں جو ازگر میں استعمال کی جاسکتی ہیں: ہف مین کوڈنگ: ہف مین کوڈنگ ایک بے نقصان ڈیٹا کمپریشن الگورتھم ہے جو پیغام میں علامتوں کی نمائندگی کرنے کے لئے متغیر لمبائی کے کوڈز کا استعمال کرتا ہے۔جتنی بار ایک علامت ہوتی ہے ، اس کا کوڈ جتنا چھوٹا ہو گا۔ لیمپل زیو ویلچ (ایل زیڈ ڈبلیو): ایل زیڈ ڈبلیو ایک لچکدار ڈیٹا کمپریشن الگورتھم ہے جو مختصر کوڈز کے ساتھ پیغام میں بار بار نمونوں کو تبدیل کرنے کے لئے لغت کا استعمال کرتا ہے۔لغت متحرک طور پر تعمیر کی گئی ہے کیونکہ پیغام کو کمپریس کیا جاتا ہے ، اور یہ ڈیکمپریشن کے دوران پیغام کو ڈی کوڈ کرنے کے لئے استعمال ہوتا ہے۔ اریٹمیٹک انکوڈنگ: ریاضی کا انکوڈنگ ایک لازوال ڈیٹا کمپریشن الگورتھم ہے جو کسی پیغام کی نمائندگی کرنے کے لئے ایک جزوی نمبر استعمال کرتا ہے۔جزوی نمبر میسج میں اس کی فریکوئنسی کی بنیاد پر پیغام کو سبینٹرولز میں تقسیم کرکے اور ہر سبینٹروول کو ایک امکان تفویض کرکے تیار کیا جاتا ہے۔یہ لائبریریاں خودکار ریفیکٹرنگ ، کوڈ تجزیہ ، اور کوڈ نیویگیشن جیسی خصوصیات مہیا کرتی ہیں تاکہ ڈویلپرز کو ان کے کوڈ کے معیار کو بہتر بنانے میں مدد ملے۔ خلاصہ میں ، ڈیٹا کمپریشن اسٹوریج کی جگہ اور ٹرانسمیشن کے وقت کو بچانے کے لئے ڈیٹا کے سائز کو کم کرنے کا عمل ہے۔ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو ڈیٹا کمپریشن کے لئے استعمال ہوسکتے ہیں ، جیسے ZLIB ، GZIP ، BZIP2 ، LZMA ، اور ٹارفائل۔بہت سے کمپریشن الگورتھم ہیں جو ازگر میں استعمال ہوسکتے ہیں ، جیسے ہف مین کوڈنگ ، لیمپل زیو ویلچ (ایل زیڈ ڈبلیو) ، اور ریاضی انکوڈنگ۔ان الگورتھم اور لائبریریوں کا استعمال کرکے ، ڈویلپرز زیادہ موثر اور توسیع پزیر سافٹ ویئر ایپلی کیشنز تیار کرسکتے ہیں۔"
    },
    {
        "Question": "\"تقسیم شدہ نظاموں میں غلطی رواداری اور غلطی سے نمٹنے کے اصولوں پر تبادلہ خیال کریں ، اور ازگر میں فالتو پن ، نقل ، اور غلطی کی بازیابی جیسی تکنیک کی وضاحت کریں۔\"",
        "Answer": "فالٹ رواداری اور غلطی سے نمٹنا تقسیم شدہ نظاموں میں اہم تصورات ہیں ، جو ایک سے زیادہ باہم منسلک اجزاء پر مشتمل ہیں جو خدمت فراہم کرنے کے لئے مل کر کام کرتے ہیں۔تقسیم شدہ نظاموں میں غلطی رواداری اور غلطی سے نمٹنے کے کچھ اصول یہ ہیں: غلطی رواداری کسی نظام کی اہلیت ہے جو ایک یا زیادہ اجزاء ناکام ہوجاتی ہے یہاں تک کہ ایک سسٹم میں غلطیوں سے پتہ لگانے اور بازیافت کرنے کا عمل ہے۔کسی سسٹم کے اہم اجزاء کی نقل کے ذریعہ غلطی رواداری کو حاصل کرنے کے لئے استعمال ہونے والی ایک تکنیک۔ ریپلیکیشن ایک ایسی تکنیک ہے جو کسی سسٹم میں مختلف نوڈس میں ڈیٹا یا خدمات کی متعدد کاپیاں بنا کر غلطی رواداری کو حاصل کرنے کے لئے استعمال کی جاتی ہے۔ ایرر کی بازیابی ایک نظام کو اے میں بحال کرنے کا عمل ہے۔ناکامی یا غلطی کے بعد فنکشنل ریاست۔یہ لائبریریاں ڈویلپرز کو اپنے کوڈ کے معیار کو بہتر بنانے میں مدد کے لئے خودکار ریفیکٹرنگ ، کوڈ تجزیہ ، اور کوڈ نیویگیشن جیسی خصوصیات مہیا کرتی ہیں۔ خلاصہ میں ، غلطی رواداری اور غلطی سے نمٹنے کے نظام میں اہم تصورات ہیں ، جو ایک سے زیادہ باہم منسلک اجزاء پر مشتمل ہیں جو مل کر کام کرتے ہیں۔ایک خدمت فراہم کرنے کے لئے.ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو تقسیم شدہ نظاموں میں غلطی رواداری اور غلطی سے نمٹنے کے لئے استعمال کیا جاسکتا ہے ، جیسے PYDSL ، ANTLR ، اور RABITMQ۔ان تکنیکوں اور لائبریریوں کا استعمال کرکے ، ڈویلپرز زیادہ قابل اعتماد اور لچکدار تقسیم شدہ نظام تیار کرسکتے ہیں۔"
    },
    {
        "Question": "\"ازگر میں سافٹ ویئر پروفائلنگ اور کارکردگی کی اصلاح کے تصور کی وضاحت کریں ، اور رکاوٹوں کی نشاندہی کرنے کے لئے CProfile یا میموری_پروفیلر جیسے ٹولز پر تبادلہ خیال کریں۔\"",
        "Answer": "سافٹ ویئر پروفائلنگ میں رکاوٹوں اور بہتری کے شعبوں کی نشاندہی کرنے کے لئے کسی پروگرام کی کارکردگی کا تجزیہ کرنے کا عمل ہے۔پروفائلنگ کارکردگی کی اصلاح کا ایک لازمی حصہ ہے ، جس کا مقصد کسی پروگرام کی رفتار اور کارکردگی کو بہتر بنانا ہے۔ازگر متعدد ٹولز اور لائبریریوں کو مہیا کرتا ہے جو پروفائلنگ اور کارکردگی کی اصلاح کے لئے استعمال ہوسکتے ہیں ، جیسے CProfile اور memery_profiler. یہاں ازگر میں سافٹ ویئر پروفائلنگ اور کارکردگی کی اصلاح کے کچھ اصول ہیں: پروفائلنگ میں رکاوٹوں کی نشاندہی کرنے کے لئے کسی پروگرام کی کارکردگی کا تجزیہ کرنے کا عمل اور پروفائلنگ ہے۔بہتری کے شعبے۔ کارکردگی کی اصلاح کسی پروگرام کی رفتار اور کارکردگی کو بہتر بنانے کا عمل ہے۔ بوٹلینیکس کوڈ کے ایسے حصے ہیں جو اکثر کثرت سے عملدرآمد کرتے ہیں اور سب سے زیادہ عملدرآمد کی گنتی کرتے ہیں۔پروفائلرز۔ ٹیکنیکس جیسے فالتو پن ، نقل ، اور غلطی کی بازیابی کو تقسیم شدہ نظاموں میں غلطی رواداری اور غلطی سے نمٹنے کے لئے استعمال کیا جاسکتا ہے۔یہ لائبریریاں ڈویلپرز کو اپنے کوڈ کے معیار کو بہتر بنانے میں مدد کے لئے خودکار ریفیکٹرنگ ، کوڈ تجزیہ ، اور کوڈ نیویگیشن جیسی خصوصیات مہیا کرتی ہیں۔ خلاصہ میں ، سافٹ ویئر پروفائلنگ رکاوٹوں اور بہتری کے شعبوں کی نشاندہی کرنے کے لئے کسی پروگرام کی کارکردگی کا تجزیہ کرنے کا عمل ہے۔ازگر متعدد ٹولز اور لائبریریوں کو مہیا کرتا ہے جو پروفائلنگ اور کارکردگی کی اصلاح کے لئے استعمال ہوسکتے ہیں ، جیسے CProfile اور میموری_پروفیلر۔ان ٹولز اور تکنیک جیسے فالتو پن ، نقل ، اور غلطی کی بازیابی کا استعمال کرکے ، ڈویلپرز اپنے سافٹ ویئر ایپلی کیشنز کی رفتار ، کارکردگی اور غلطی رواداری کو بہتر بناسکتے ہیں۔"
    },
    {
        "Question": "ایک محدود اسٹیٹ مشین (ایف ایس ایم) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور ریاستوں کے مابین منتقلی اور واقعات کو سنبھالنے کے طریقے فراہم کریں۔",
        "Answer": "ایک محدود اسٹیٹ مشین (ایف ایس ایم) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے اور ریاستوں کے درمیان منتقلی اور واقعات کو سنبھالنے کے طریقے فراہم کرنے کے ل we ، ہم PYPI پر دستیاب FSM پیکیج کا استعمال کرسکتے ہیں۔یہاں بائن اسٹیٹیٹیمچین کلاس کا ایک مثال استعمال ہے: ازگر ایف ایس ایم امپورٹ فائنلسٹیٹیٹیمچینیکلاس مائی ایف ایس ایم (بائنیٹ اسٹیٹ میچین): ڈیف __init __ (خود): سپر ()۔.# state1fsm.handle_event (\"ایونٹ 1\") پرنٹ (fsm.current_state ()) # state2fsm.handle_event (\"ایونٹ 2\") پرنٹ (fsm.current_state ()) # اسٹیٹ 1 ان مثال کے طور پر ، ایک فائنسٹیٹیٹیمچین کلاس کو ایک فائنسٹیٹیٹ میچین کلاس بنانے کے لئے استعمال کیا جاتا ہے۔دو ریاستوں اور دو ٹرانزیشن کے ساتھ۔موجودہ_سٹیٹ طریقہ FSM کی موجودہ حالت کو بازیافت کرنے کے لئے استعمال کیا جاتا ہے ، اور ان پٹ ایونٹ کی بنیاد پر ریاستوں کے مابین منتقلی کے لئے ہینڈل_ ایونٹ کا طریقہ استعمال کیا جاتا ہے۔ اس مثال کی آؤٹ پٹ یہ ہے کہ: اسٹیٹ 1 اسٹیٹ 2 اسٹیٹ 1 اس آؤٹ پٹ سے پتہ چلتا ہے کہ ایف ایس ایم ٹرانزیشن سے ریاست 1 سے ریاست 2 میں منتقلی ہوتی ہے۔سنبھالا جاتا ہے ، اور اسٹیٹ 2 سے اسٹیٹ 1 تک جب ایونٹ 2 کو سنبھالا جاتا ہے۔ ایف ایس ایم پیکیج محدود ریاستی مشینوں کے ساتھ کام کرنے کے لئے کئی دوسرے طریقے مہیا کرتا ہے ، جیسے ADD_STATE ، ADD_TRANSITION ، اور SET_START_STATE۔ان طریقوں کا استعمال ایف ایس ایم میں ریاستوں اور ٹرانزیشن کو شامل کرنے اور اسٹارٹ اسٹیٹ کو ترتیب دینے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ یہ کہ ایک محدود ریاست مشین حساب کتاب کا ایک ریاضی کا نمونہ ہے جو ایک ترتیب منطق کا نمونہ بناتا ہے۔ازگر متعدد پیکیجز مہیا کرتا ہے ، جیسے ایف ایس ایم ، جو محدود ریاستی مشینوں کو نافذ کرتے ہیں اور ریاستوں اور ہینڈلنگ ایونٹس کے مابین منتقلی کے طریقے مہیا کرتے ہیں۔ان پیکیجوں کو ایک محدود ریاستی مشین کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے اور ریاستوں کے مابین منتقلی اور واقعات کو سنبھالنے کے طریقے فراہم کرنے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"بڑے ڈیٹا پروسیسنگ کے ل data ڈیٹا ڈھانچے کے تصور کی وضاحت کریں ، جیسے بلوم فلٹرز ، ہائپرلوگلاگ ، یا گنتی من خاکہ ، اور ازگر میں ان کی درخواستوں پر تبادلہ خیال کریں۔\"",
        "Answer": "بگ ڈیٹا پروسیسنگ کے لئے ڈیٹا ڈھانچے خصوصی ڈیٹا ڈھانچے ہیں جو ڈیٹا کی بڑی مقدار کو موثر انداز میں سنبھالنے کے لئے ڈیزائن کیے گئے ہیں۔یہ ڈیٹا ڈھانچے بڑے ڈیٹا پروسیسنگ ایپلی کیشنز میں بڑے ڈیٹاسیٹس کو ذخیرہ کرنے ، منظم کرنے اور ان میں ہیرا پھیری کرنے کے لئے استعمال کیے جاتے ہیں۔یہاں بڑے ڈیٹا پروسیسنگ کے لئے ڈیٹا ڈھانچے کی کچھ مثالیں اور ازگر میں ان کی ایپلی کیشنز: بلوم فلٹرز: بلوم فلٹرز امکانی اعداد و شمار کے ڈھانچے ہیں جو جانچنے کے لئے استعمال ہوتے ہیں کہ آیا عنصر کسی سیٹ کا ممبر ہے یا نہیں۔وہ ڈیٹا کی مقدار کو کم کرنے کے لئے بڑے ڈیٹا پروسیسنگ ایپلی کیشنز میں استعمال ہوتے ہیں جس پر غیر متعلقہ ڈیٹا کو فلٹر کرکے کارروائی کرنے کی ضرورت ہوتی ہے۔ازگر بلوم فلٹرز کو نافذ کرنے کے لئے متعدد لائبریریاں مہیا کرتا ہے ، جیسے پائی بلومفلٹرم میپ اور بٹیرے۔ ہائیپرلوگلاگ: ہائپرلوگلاگ ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو کسی سیٹ کی کارڈنیلٹی کا اندازہ لگانے کے لئے استعمال ہوتا ہے۔یہ بڑے ڈیٹاسیٹس کے سائز کا اندازہ لگانے کے لئے بڑے ڈیٹا پروسیسنگ ایپلی کیشنز میں استعمال ہوتا ہے۔ازگر ہائپرلوگلاگ کو نافذ کرنے کے لئے متعدد لائبریریوں کو مہیا کرتا ہے ، جیسے ڈیٹا اسکیٹچ اور ہائپرلوگلاگ۔ کاؤنٹ-منڈ اسکیچ: کاؤنٹ-منڈ اسکیچ ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو کسی سیٹ میں عناصر کی تعدد کا اندازہ لگانے کے لئے استعمال ہوتا ہے۔یہ بڑے ڈیٹاسیٹس میں عناصر کی موجودگی کو گننے کے لئے بڑے ڈیٹا پروسیسنگ ایپلی کیشنز میں استعمال ہوتا ہے۔ازگر گنتی کے منکی خاکے کو نافذ کرنے کے لئے متعدد لائبریریوں کو مہیا کرتا ہے ، جیسے سی ایم اسکیچ اور کاؤنٹی مینسکیچ۔ پیتھون کئی لائبریریوں اور فریم ورک مہیا کرتا ہے جو بڑے ڈیٹا پروسیسنگ کے لئے استعمال ہوسکتے ہیں ، جیسے پییسپارک ، ڈاسک ، اور اپاچی بیم۔یہ لائبریریاں تقسیم شدہ کمپیوٹنگ ، متوازی پروسیسنگ ، اور ڈیٹا اسٹریمنگ جیسی خصوصیات مہیا کرتی ہیں تاکہ ڈویلپرز کو بڑے ڈیٹاسیٹس پر موثر انداز میں عملدرآمد کرنے میں مدد ملے۔ خلاصہ میں ، بڑے ڈیٹا پروسیسنگ کے لئے ڈیٹا ڈھانچے خصوصی ڈیٹا ڈھانچے ہیں جو ڈیٹا کی بڑی مقدار کو موثر انداز میں سنبھالنے کے لئے ڈیزائن کیے گئے ہیں۔ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو ان ڈیٹا ڈھانچے کو نافذ کرنے اور بڑے ڈیٹاسیٹس کو موثر انداز میں پروسیس کرنے کے لئے استعمال کیا جاسکتا ہے۔ان ڈیٹا ڈھانچے اور لائبریریوں کا استعمال کرکے ، ڈویلپرز زیادہ موثر اور توسیع پذیر بگ ڈیٹا پروسیسنگ ایپلی کیشنز کی تشکیل کرسکتے ہیں۔"
    },
    {
        "Question": "رد عمل مائکروسروائسز فن تعمیر کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ فاسٹ پی آئی یا کوارٹ جیسے فریم ورک کو کس طرح ازگر میں توسیع پزیر اور لچکدار نظام کی تعمیر کے لئے استعمال کیا جاسکتا ہے۔",
        "Answer": "رد عمل مائکروسروائسز فن تعمیر تقسیم شدہ نظاموں کی تعمیر کا ایک نقطہ نظر ہے جو ردعمل ، لچک اور لچک پر زور دیتا ہے۔یہاں رد عمل مائکروسروائسز فن تعمیر کے کچھ اصول ہیں: جوابدہ: اگر ممکن ہو تو نظام بروقت جواب دیتا ہے۔ردعمل استعمال اور افادیت کا سنگ بنیاد ہے ، لیکن اس سے بھی زیادہ ، ردعمل کا مطلب یہ ہے کہ مسائل کا جلد پتہ چل سکتا ہے اور مؤثر طریقے سے نمٹا جاسکتا ہے۔رد عمل کے نظام ان پٹ کی خدمت کے لئے مختص وسائل کو بڑھا یا کم کرکے ان پٹ ریٹ میں تبدیلیوں پر رد عمل ظاہر کرسکتے ہیں۔اس سے ایسے ڈیزائن کا مطلب ہے جس میں کوئی تنازعہ کے نکات یا مرکزی رکاوٹیں نہیں ہیں ، جس کے نتیجے میں اجزاء کو تیز کرنے یا نقل کرنے اور ان کے درمیان ان پٹ تقسیم کرنے کی صلاحیت ہوتی ہے۔کارفرما: رد عمل کے نظام اجزاء کے مابین ایک حدود کو قائم کرنے کے لئے غیر متزلزل پیغام پر انحصار کرتے ہیں جو ڈھیلے جوڑے ، تنہائی ، اور مقام کی شفافیت کو یقینی بناتا ہے۔یہ فریم ورک ڈویلپرز کو توسیع پذیر اور لچکدار نظاموں کی تعمیر میں مدد کے لئے اسینکرونس پروگرامنگ ، واقعہ سے چلنے والے فن تعمیر ، اور پیغام گزرنے جیسی خصوصیات فراہم کرتے ہیں۔ خلاصہ یہ ہے کہ ، رد عمل مائکرو سروسز فن تعمیر تقسیم شدہ نظاموں کی تعمیر کا ایک نقطہ نظر ہے جو ردعمل ، لچک اور لچکدار پر زور دیتا ہے۔ازگر کئی فریم ورک مہیا کرتا ہے ، جیسے فاسٹپی اور کوارٹ ، جو رد عمل مائکروسروائسز کی تعمیر کے لئے استعمال کیا جاسکتا ہے۔ان فریم ورک کا استعمال کرکے اور رد عمل مائکروسروائسز فن تعمیر کے اصولوں پر عمل کرتے ہوئے ، ڈویلپرز زیادہ موثر اور توسیع پذیر تقسیم شدہ نظام تشکیل دے سکتے ہیں۔"
    },
    {
        "Question": "\"ایک امکانی اعداد و شمار کے ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں ، جیسے بلوم فلٹر ، ہائپرلوگلاگ ، یا گنتی کے منکی خاکہ ، اور موثر اندازے کے مطابق سیٹ ممبرشپ کے سوالات کے لئے طریقے فراہم کریں۔\"",
        "Answer": "امکانی اعداد و شمار کے ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کرنے کے ل ، ، جیسے بلوم فلٹر ، ہائپرلوگلاگ ، یا گنتی منکی خاکہ ، اور موثر اندازا set سیٹ ممبرشپ کے استفسارات کے طریقے فراہم کرنے کے ل we ، ہم PYPI پر دستیاب پائپروبیبل لائبریری کا استعمال کرسکتے ہیں۔بلوم فلٹر کلاس کا ایک مثال استعمال ہے: ازگر کے امکانی امکانات بلومفلٹر بی ایف = بلومفلٹر (EST_ELEMENTS = 1000 ، false_positive_rate = 0.01) bf.add (\"ایپل\") bf.add (\"کیلے\") bf.add (\"سنتری\") پرنٹ (\"سنتری\") پرنٹBF میں \"ایپل\") # ٹروپنٹ (\"ناشپاتیاں\" BF میں) # فالین اس مثال کے طور پر ، بلوم فلٹر کلاس ایک تخمینہ شدہ 1000 عناصر اور 0.01 کی غلط مثبت شرح کے ساتھ بلوم فلٹر بنانے کے لئے استعمال ہوتا ہے۔بلوم فلٹر میں تین عناصر شامل کیے جاتے ہیں ، اور ان آپریٹر کو سیٹ ممبرشپ کے لئے جانچنے کے لئے استعمال کیا جاتا ہے۔ اس مثال کی آؤٹ پٹ یہ ہے کہ: ٹری فالسٹی آؤٹ پٹ سے پتہ چلتا ہے کہ بلوم فلٹر سیٹ کے ممبر کی حیثیت سے \"ایپل\" کو صحیح طور پر شناخت کرتا ہے اور \"ناشپاتیاں\"جیسا کہ سیٹ کا ممبر نہیں ہے۔ پیپروبیبلز لائبریری امکانی اعداد و شمار کے ڈھانچے ، جیسے ہائپرلوگلاگ اور کاؤنٹی مینسکیچ کو نافذ کرنے کے لئے کئی دیگر کلاسیں مہیا کرتی ہے۔ان کلاسوں کو کسی سیٹ کی کارڈنیلٹی کا اندازہ لگانے اور ایک سیٹ میں عناصر کی موجودگی کو بالترتیب گننے کے لئے استعمال کیا جاسکتا ہے۔ خلاصہ میں ، امکانی اعداد و شمار کے ڈھانچے اعداد و شمار کے ڈھانچے ہیں جو عین مطابق جوابات کے بجائے کسی بڑے ڈیٹاسیٹ کے بارے میں سوالات کے بارے میں لگ بھگ جوابات فراہم کرتے ہیں۔ازگر متعدد لائبریریوں اور فریم ورک مہیا کرتا ہے جو امکانی اعداد و شمار کے ڈھانچے ، جیسے پائپوبیبلز کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے۔ان لائبریریوں اور کلاسوں جیسے بلوم فلٹر ، ہائپرلوگلاگ ، اور کاؤنٹی مینسکیچ کا استعمال کرکے ، ڈویلپرز بڑے ڈیٹاسیٹس پر تقریبا سیٹ ممبرشپ کے سوالات کو موثر انداز میں انجام دے سکتے ہیں۔"
    }
]