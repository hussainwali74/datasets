[
    {
        "Input": "python",
        "Output": "Python is a high-level, general-purpose programming language that supports multiple programming paradigms, including structured, object-oriented, and functional programming\n1\n. It is often described as a \"batteries included\" language due to its comprehensive standard library\n1\n. Python is meant to be an easily readable language, with visually uncluttered formatting that often uses English keywords where other languages use punctuation\n1\n. Unlike many other languages, it does not use curly brackets to delimit blocks, and semicolons after statements are allowed but rarely used\n1\n. Python's large standard library provides tools suited to many tasks and is commonly cited as one of its greatest strengths\n1\n.\nPython can be used for web development, software development, mathematics, system scripting, and more\n2\n. It can be used on a server to create web applications, alongside software to create workflows, and to connect to database systems\n2\n. Python can also read and modify files\n2\n.\nThere are many resources available for learning Python, including the official website, which offers documentation for Python's standard library, along with tutorials and guides\n3\n. W3Schools offers a Python tutorial that covers topics such as file handling, database handling, exercises, examples, and quizzes\n4\n. Codecademy offers Python courses and tutorials for beginners and advanced users\n5\n.\nFinally, GitHub offers many repositories related to the Python programming language, including collections of library stubs for Python with static types\n6\n.\n1\nwikipedia\n2\nw3schools\n3\npython\n4\nw3schools\n5\ncodecademy\n6\ngithub"
    },
    {
        "Input": "Write a Python program to find the sum of all numbers in a list.",
        "Output": "Here's a Python program to find the sum of all numbers in a list using the sum() function:\npython\nmy_list = [1, 2, 3, 4, 5]\nsum_of_list = sum(my_list)\nprint(\"Sum of list is:\", sum_of_list)\nThis program first initializes a list called my_list with some numbers. Then, it uses the built-in sum() function to calculate the sum of all the numbers in the list and stores it in a variable called sum_of_list. Finally, it prints the sum of the list using the print() function.\nAlternatively, we can also use a for loop to iterate through the list and add up all the numbers. Here's an example:\npython\nmy_list = [1, 2, 3, 4, 5]\nsum_of_list = 0\nfor num in my_list:\n    sum_of_list += num\nprint(\"Sum of list is:\", sum_of_list)\nThis program first initializes a list called my_list with some numbers. Then, it initializes a variable called sum_of_list to 0. Next, it uses a for loop to iterate through each number in the list and adds it to the sum_of_list variable. Finally, it prints the sum of the list using the print() function.\n1\ncodescracker\n2\nw3resource\n3\nw3resource\n4\nstechies\n5\nstudytonight"
    },
    {
        "Input": "Implement a function to check if a given string is a palindrome.",
        "Output": "Here's a Python function to check if a given string is a palindrome:\npython\ndef is_palindrome(string):\n    # Convert the string to lowercase and remove non-alphanumeric characters\n    string = ''.join(e for e in string if e.isalnum()).lower()\n    # Check if the string is equal to its reverse\n    return string == string[::-1]\nThis function takes a string as input and first removes all non-alphanumeric characters and converts the string to lowercase using the join() and lower() methods. Then, it checks if the string is equal to its reverse using slicing. If the string is equal to its reverse, the function returns True, indicating that the string is a palindrome. Otherwise, it returns False.\nHere's an example of how to use the function:\npython\nstring = \"A man, a plan, a canal: Panama\"\nif is_palindrome(string):\n    print(\"The string is a palindrome.\")\nelse:\n    print(\"The string is not a palindrome.\")\nThis program first initializes a string called string with some text. Then, it calls the is_palindrome() function with the string as input. Finally, it prints whether the string is a palindrome or not using the print() function. In this case, the output will be \"The string is a palindrome.\"\n1\ntutorialgateway\n2\ndatagy\n3\ngeeksforgeeks\n4\nshiksha\n5\nsanfoundry"
    },
    {
        "Input": "Write a program to generate all prime numbers up to a given number.",
        "Output": "Here's a Python program to generate all prime numbers up to a given number using the Sieve of Eratosthenes algorithm:\npython\ndef generate_primes(n):\n    # Create a boolean array \"prime[0..n]\" and initialize\n    # all entries it as true.\n    prime = [True for i in range(n+1)]\n    p = 2\n    while p**2 <= n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p**2, n+1, p):\n                prime[i] = False\n        p += 1\n    # Print all prime numbers\n    for p in range(2, n+1):\n        if prime[p]:\n            print(p)\nThis program takes an integer n as input and generates all prime numbers up to n using the Sieve of Eratosthenes algorithm. The algorithm works by creating a boolean array prime of size n+1 and initializing all entries to True. Then, it iterates over all numbers from 2 to the square root of n and updates all multiples of each number to False. Finally, it prints all numbers that are still marked as True in the prime array.\nHere's an example of how to use the function:\npython\nn = 50\ngenerate_primes(n)\nThis program generates all prime numbers up to 50 using the generate_primes() function and prints them to the console. The output will be:\n2\n3\n5\n7\n11\n13\n17\n19\n23\n29\n31\n37\n41\n43\n47\n1\njavatpoint\n2\nsanfoundry\n3\nstackoverflow\n4\nprogramiz\n5\ngeeksforgeeks"
    },
    {
        "Input": "Create a function that takes a string as input and returns the frequency of each character in the string.",
        "Output": "Here's a Python function that takes a string as input and returns the frequency of each character in the string:\npython\ndef char_frequency(string):\n    # Create an empty dictionary to store the frequency of each character\n    freq = {}\n    # Loop through each character in the string\n    for char in string:\n        # If the character is already in the dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        # Otherwise, add the character to the dictionary with a count of 1\n        else:\n            freq[char] = 1\n    # Return the dictionary of character frequencies\n    return freq\nThis function takes a string as input and initializes an empty dictionary called freq to store the frequency of each character. Then, it loops through each character in the string and checks if the character is already in the dictionary. If it is, it increments the count for that character. If it's not, it adds the character to the dictionary with a count of 1. Finally, it returns the dictionary of character frequencies.\nHere's an example of how to use the function:\npython\nstring = \"Hello, World!\"\nfreq = char_frequency(string)\nprint(freq)\nThis program first initializes a string called string with some text. Then, it calls the char_frequency() function with the string as input and stores the result in a variable called freq. Finally, it prints the dictionary of character frequencies using the print() function. In this case, the output will be:\n{'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1}\nThis dictionary shows the frequency of each character in the input string.\n1\ngeeksforgeeks\n2\ntechbeamers\n3\nprepinsta\n4\nw3resource\n5\ntutorialspoint"
    },
    {
        "Input": "Implement a binary search algorithm to find the position of an element in a sorted list.",
        "Output": "Here's a Python implementation of the binary search algorithm to find the position of an element in a sorted list:\npython\ndef binary_search(arr, x):\n    # Set the initial values for the first and last indices\n    first = 0\n    last = len(arr) - 1\n    # Loop until the first index is less than or equal to the last index\n    while first <= last:\n        # Calculate the middle index\n        mid = (first + last) // 2\n        # If the middle element is the target, return its index\n        if arr[mid] == x:\n            return mid\n        # If the target is less than the middle element, search the left half\n        elif arr[mid] > x:\n            last = mid - 1\n        # If the target is greater than the middle element, search the right half\n        else:\n            first = mid + 1\n    # If the target is not found, return -1\n    return -1\nThis function takes a sorted list arr and a target element x as input and returns the index of the target element in the list using the binary search algorithm. The algorithm works by repeatedly dividing the search interval in half until the target element is found or the search interval is empty. In each iteration, it compares the middle element of the search interval to the target element and updates the search interval accordingly.\nHere's an example of how to use the function:\npython\narr = [1, 3, 5, 7, 9]\nx = 5\nresult = binary_search(arr, x)\nif result != -1:\n    print(f\"Element {x} is present at index {result}\")\nelse:\n    print(\"Element is not present in array\")\nThis program first initializes a sorted list called arr and a target element x. Then, it calls the binary_search() function with the arr and x as input and stores the result in a variable called result. Finally, it prints whether the target element is present in the list and its index using the print() function. In this case, the output will be \"Element 5 is present at index 2\".\n1\nbuiltin\n2\nrealpython\n3\njavatpoint\n4\nfreecodecamp\n5\ngeeksforgeeks"
    },
    {
        "Input": "Write a Python class representing a linked list and implement a method to reverse it.",
        "Output": "Here's a Python class representing a linked list and a method to reverse it:\npython\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        new_node = Node(data)\n        if self.head:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n        else:\n            self.head = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" \")\n            current = current.next\n        print()\n\n    def reverse(self):\n        previous = None\n        current = self.head\n        while current:\n            next_node = current.next\n            current.next = previous\n            previous = current\n            current = next_node\n        self.head = previous\nThis class represents a linked list with a Node class and a LinkedList class. The Node class has a data attribute and a next attribute that points to the next node in the list. The LinkedList class has a head attribute that points to the first node in the list. It also has methods to insert a new node at the end of the list, print the list, and reverse the list.\nThe reverse() method uses an iterative approach to reverse the linked list. It initializes two pointers, previous and current, to None and the head of the list, respectively. Then, it iterates through the list and updates the next attribute of each node to point to the previous node. Finally, it updates the head attribute of the list to point to the last node, which is now the first node of the reversed list.\nHere's an example of how to use the class:\npython\nmy_list = LinkedList()\nmy_list.insert(1)\nmy_list.insert(2)\nmy_list.insert(3)\nmy_list.insert(4)\nmy_list.insert(5)\nprint(\"Original list:\")\nmy_list.print_list()\nmy_list.reverse()\nprint(\"Reversed list:\")\nmy_list.print_list()\nThis program first initializes a linked list called my_list with some nodes. Then, it prints the original list using the print_list() method. Next, it reverses the list using the reverse() method and prints the reversed list using the print_list() method. In this case, the output will be:\nOriginal list:\n1 2 3 4 5 \nReversed list:\n5 4 3 2 1 \n1\neducative\n2\nalphacodingskills\n3\ncodingninjas\n4\nsanfoundry\n5\ngeeksforgeeks"
    },
    {
        "Input": "Create a function that finds the longest common prefix string amongst a list of strings.",
        "Output": "To find the longest common prefix string amongst a list of strings, we can use the following Python function:\npython\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    # Sort the list of strings\n    strs.sort()\n    # Find the common prefix between the first and last strings\n    prefix = \"\"\n    for i in range(len(strs[0])):\n        if strs[0][i] == strs[-1][i]:\n            prefix += strs[0][i]\n        else:\n            break\n    return prefix\nThis function takes a list of strings strs as input and returns the longest common prefix string among them. It first checks if the list is empty and returns an empty string if it is. Then, it sorts the list of strings in alphabetical order. Finally, it iterates through the characters of the first string in the list and compares them to the corresponding characters in the last string in the list. If the characters are the same, it appends them to the prefix string. If they are different, it breaks out of the loop and returns the prefix string.\nHere's an example of how to use the function:\npython\nstrs = [\"flower\", \"flow\", \"flight\"]\nprefix = longest_common_prefix(strs)\nprint(\"Longest common prefix:\", prefix)\nThis program first initializes a list of strings called strs. Then, it calls the longest_common_prefix() function with the strs as input and stores the result in a variable called prefix. Finally, it prints the longest common prefix string using the print() function. In this case, the output will be \"Longest common prefix: fl\".\n1\ninterviewbit\n2\neducative\n3\ngeeksforgeeks\n4\ngeeksforgeeks\n5\nstackexchange"
    },
    {
        "Input": "Implement a decorator that measures the execution time of a function.",
        "Output": "To create a Python decorator that measures the execution time of a function, we can use the time module. Here's an example implementation:\npython\nimport time\n\ndef measure_time(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        print(f\"Function {func.__name__} took {end_time - start_time:.8f} seconds to execute.\")\n        return result\n    return wrapper\nThis decorator takes a function func as input and returns a wrapper function that measures the execution time of func. The wrapper function uses the time.perf_counter() function to get the current time before and after calling func. It then calculates the difference between the two times and prints the execution time of func. Finally, it returns the result of calling func.\nHere's an example of how to use the decorator:\npython\n@measure_time\ndef my_func(n):\n    total = sum((x for x in range(0, n**2)))\n    return total\n\nmy_func(10000)\nThis program first defines a function called my_func that takes an integer n as input and calculates the sum of all numbers from 0 to n**2. Then, it decorates the my_func function with the measure_time decorator using the @ syntax. Finally, it calls the decorated my_func function with an input of 10000. The output will be something like:\nFunction my_func took 0.00007100 seconds to execute.\nThis output shows the execution time of the my_func function in seconds.\n1\nw3resource\n2\ndev\n3\ngitconnected\n4\nsureshdsk\n5\ncodesansar"
    },
    {
        "Input": "Write a program to sort a list of dictionaries based on a specific key.",
        "Output": "To sort a list of dictionaries based on a specific key, we can use the sorted() function in Python. Here's an example implementation:\npython\ndef sort_list_of_dicts(list_of_dicts, key):\n    sorted_list = sorted(list_of_dicts, key=lambda x: x[key])\n    return sorted_list\nThis function takes a list of dictionaries list_of_dicts and a specific key key as input and returns the sorted list of dictionaries based on the specified key. The sorted() function takes the list of dictionaries and a key parameter, which specifies the dictionary key by which the list should be sorted. In this case, we use a lambda function to extract the value of the specified key from each dictionary in the list.\nHere's an example of how to use the function:\npython\nmy_list = [{'name': 'John', 'age': 25}, {'name': 'Jane', 'age': 30}, {'name': 'Bob', 'age': 20}]\nsorted_list = sort_list_of_dicts(my_list, 'age')\nprint(sorted_list)\nThis program first initializes a list of dictionaries called my_list. Then, it calls the sort_list_of_dicts() function with the my_list and 'age' as input and stores the result in a variable called sorted_list. Finally, it prints the sorted list of dictionaries using the print() function. In this case, the output will be:\n[{'name': 'Bob', 'age': 20}, {'name': 'John', 'age': 25}, {'name': 'Jane', 'age': 30}]\nThis output shows the list of dictionaries sorted by the 'age' key in ascending order.\n1\nnkmk\n2\nstackoverflow\n3\nfreecodecamp\n4\npythonhow\n5\nsparkbyexamples"
    },
    {
        "Input": "Implement a recursive function to calculate the factorial of a given number.",
        "Output": "To calculate the factorial of a given number using recursion in Python, we can define a function that calls itself with a smaller input until it reaches the base case, which is the factorial of 1, which is 1. Here is an example implementation:\npython\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\nThis function takes an integer n as input and returns the factorial of n using recursion. The first if statement checks if the input number n is 1. If n is 1, the function returns 1 as the base case. If n is not 1, the function returns the product of n and the factorial of n-1. This is where the recursive function call happens, where the function calls itself with the input n-1.\nHere's an example of how to use the function:\npython\nn = 5\nresult = factorial(n)\nprint(f\"The factorial of {n} is {result}\")\nThis program first initializes an integer called n with a value of 5. Then, it calls the factorial() function with the n as input and stores the result in a variable called result. Finally, it prints the factorial of n using the print() function. In this case, the output will be:\nThe factorial of 5 is 120\nThis output shows the factorial of the input number n calculated using the factorial() function.\n1\ntutorialspoint\n2\nscaler\n3\nsanfoundry\n4\nprogramiz\n5\ngeeksforgeeks"
    },
    {
        "Input": "Write a Python program to check if a string contains only digits.",
        "Output": "To check if a string contains only digits in Python, we can use the isdigit() method or regular expressions. Here's an example implementation using the isdigit() method:\npython\ndef contains_only_digits(string):\n    return string.isdigit()\nThis function takes a string as input and returns True if the string contains only digits and False otherwise. The isdigit() method returns True if all characters in the string are digits and there is at least one character, and False otherwise.\nHere's an example of how to use the function:\npython\nstring1 = \"12345\"\nstring2 = \"12345a\"\nprint(contains_only_digits(string1)) # True\nprint(contains_only_digits(string2)) # False\nThis program first initializes two strings called string1 and string2. Then, it calls the contains_only_digits() function with the string1 and string2 as input and prints the results using the print() function. In this case, the output will be:\nTrue\nFalse\nThis output shows that the first string contains only digits and the second string contains at least one non-digit character.\nAlternatively, we can use regular expressions to check if a string contains only digits. Here's an example implementation:\npython\nimport re\n\ndef contains_only_digits(string):\n    return bool(re.match('^[0-9]+$', string))\nThis function takes a string as input and returns True if the string contains only digits and False otherwise. The regular expression '^[0][1][2][3][4][5][6][7][8][9]+$' matches only strings that contain one or more digits from the beginning to the end of the string. The re.match() function returns an object if the regular expression matches the string, and None otherwise. We use the bool() function to convert the result to a boolean value.\nHere's an example of how to use the function:\npython\nstring1 = \"12345\"\nstring2 = \"12345a\"\nprint(contains_only_digits(string1)) # True\nprint(contains_only_digits(string2)) # False\nThis program first initializes two strings called string1 and string2. Then, it calls the contains_only_digits() function with the string1 and string2 as input and prints the results using the print() function. In this case, the output will be:\nTrue\nFalse\nThis output shows that the first string contains only digits and the second string contains at least one non-digit character.\n1\ntutorialspoint\n2\nstackabuse\n3\nadamsmith\n4\ngeeksforgeeks\n5\nfinxter"
    },
    {
        "Input": "Implement a function to find the second largest element in a list.",
        "Output": "There are several ways to find the second largest element in a list in Python. Here are a few examples:\nUsing sorting: We can sort the list in descending order and return the second element. Here's an example implementation:\npython\ndef second_largest(lst):\n    sorted_lst = sorted(lst, reverse=True)\n    return sorted_lst[1]\nThis function takes a list lst as input and returns the second largest element in the list. It first sorts the list in descending order using the sorted() function with the reverse=True parameter. Then, it returns the second element of the sorted list.\nUsing max() function: We can use the max() function to find the maximum element in the list and remove it, then find the maximum element again to get the second largest element. Here's an example implementation:\npython\ndef second_largest(lst):\n    max_elem = max(lst)\n    lst.remove(max_elem)\n    second_max = max(lst)\n    return second_max\nThis function takes a list lst as input and returns the second largest element in the list. It first finds the maximum element in the list using the max() function and stores it in a variable called max_elem. Then, it removes the maximum element from the list using the remove() method. Finally, it finds the maximum element again to get the second largest element and returns it.\nUsing a loop: We can use a loop to find the maximum and second maximum elements in the list. Here's an example implementation:\npython\ndef second_largest(lst):\n    max_elem = lst[0]\n    second_max = None\n    for elem in lst[1:]:\n        if elem > max_elem:\n            second_max = max_elem\n            max_elem = elem\n        elif second_max is None or elem > second_max:\n            second_max = elem\n    return second_max\nThis function takes a list lst as input and returns the second largest element in the list. It first initializes the maximum element to the first element in the list and the second maximum element to None. Then, it loops through the remaining elements in the list and updates the maximum and second maximum elements accordingly. Finally, it returns the second maximum element.\nHere's an example of how to use the function:\npython\nlst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nsecond_max = second_largest(lst)\nprint(\"Second largest element:\", second_max)\nThis program first initializes a list called lst with some numbers. Then, it calls the second_largest() function with the lst as input and stores the result in a variable called second_max. Finally, it prints the second largest element using the print() function. In this case, the output will be:\nSecond largest element: 6\nThis output shows the second largest element in the input list.\n1\nplainenglish\n2\ngithub\n3\nsanfoundry\n4\nstudytonight\n5\njavatpoint"
    },
    {
        "Input": "Create a program to reverse a given sentence without reversing the individual words.",
        "Output": "To reverse a given sentence without reversing the individual words in Python, we can split the sentence into words, reverse the order of the words, and then join them back together. Here's an example implementation:\npython\ndef reverse_sentence(sentence):\n    words = sentence.split()\n    words.reverse()\n    reversed_sentence = \" \".join(words)\n    return reversed_sentence\nThis function takes a string sentence as input and returns the reversed sentence without reversing the individual words. It first splits the sentence into words using the split() method, which splits the string at whitespace characters by default. Then, it reverses the order of the words using the reverse() method. Finally, it joins the words back together using the join() method with a space character as the separator.\nHere's an example of how to use the function:\npython\nsentence = \"This is a test sentence\"\nreversed_sentence = reverse_sentence(sentence)\nprint(\"Reversed sentence:\", reversed_sentence)\nThis program first initializes a string called sentence with some text. Then, it calls the reverse_sentence() function with the sentence as input and stores the result in a variable called reversed_sentence. Finally, it prints the reversed sentence using the print() function. In this case, the output will be:\nReversed sentence: sentence test a is This\nThis output shows the reversed sentence without reversing the individual words in the input sentence.\n1\ngeeksforgeeks\n2\ntechiedelight\n3\ntutorialspoint\n4\nscaler\n5\nstackoverflow"
    },
    {
        "Input": "\"Write a Python class representing a stack and implement its push, pop, and peek methods.\"",
        "Output": "Here's a Python class representing a stack and its push, pop, and peek methods:\npython\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n\n    def is_empty(self):\n        return len(self.items) == 0\nThis class represents a stack with a Stack class. The __init__() method initializes an empty list called items to store the stack elements. The push() method takes an item as input and adds it to the top of the stack using the append() method. The pop() method removes and returns the top element of the stack using the pop() method if the stack is not empty. The peek() method returns the top element of the stack using the index -1 if the stack is not empty. The is_empty() method returns True if the stack is empty and False otherwise.\nHere's an example of how to use the class:\npython\nmy_stack = Stack()\nmy_stack.push(1)\nmy_stack.push(2)\nmy_stack.push(3)\nprint(\"Top element:\", my_stack.peek())\nprint(\"Popped element:\", my_stack.pop())\nprint(\"Popped element:\", my_stack.pop())\nprint(\"Is the stack empty?\", my_stack.is_empty())\nThis program first initializes a stack called my_stack with some elements. Then, it calls the push(), peek(), pop(), and is_empty() methods of the my_stack object and prints the results using the print() function. In this case, the output will be:\nTop element: 3\nPopped element: 3\nPopped element: 2\nIs the stack empty? False\nThis output shows the top element of the stack, the popped elements, and whether the stack is empty or not.\n1\nw3resource\n2\nmygreatlearning\n3\neducative\n4\ngeeksforgeeks\n5\nrunestone"
    },
    {
        "Input": "Implement a function to remove duplicates from a list while preserving the order.",
        "Output": "To remove duplicates from a list while preserving the order in Python, we can use the list(dict.fromkeys(list)) method. Here's an example implementation:\npython\ndef remove_duplicates(lst):\n    return list(dict.fromkeys(lst))\nThis function takes a list lst as input and returns a new list with the duplicates removed while preserving the order. It first converts the list to a dictionary using the dict.fromkeys() method with the list elements as keys and None as dict values. Then, it converts the dictionary back to a list using the list() constructor. As dictionaries preserve the order of the keys, the list ordering is preserved.\nHere's an example of how to use the function:\npython\nlst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nunique_lst = remove_duplicates(lst)\nprint(\"List with duplicates removed:\", unique_lst)\nThis program first initializes a list called lst with some numbers. Then, it calls the remove_duplicates() function with the lst as input and stores the result in a variable called unique_lst. Finally, it prints the list with duplicates removed using the print() function. In this case, the output will be:\nList with duplicates removed: [3, 1, 4, 5, 9, 2, 6]\nThis output shows the list with duplicates removed while preserving the order of the elements in the input list.\n1\naskpython\n2\ncodesansar\n3\nfinxter\n4\nfinxter\n5\nfavtutor"
    },
    {
        "Input": "Create a program to calculate the Fibonacci sequence up to a given number.",
        "Output": "To calculate the Fibonacci sequence up to a given number in Python, we can use a loop or recursion. Here are a few examples:\nUsing a loop: We can use a loop to calculate the Fibonacci sequence up to a given number. Here's an example implementation:\npython\ndef fibonacci(n):\n    fib = [0, 1]\n    while len(fib) < n:\n        fib.append(fib[-1] + fib[-2])\n    return fib\nThis function takes an integer n as input and returns a list of the Fibonacci sequence up to n. It first initializes a list called fib with the first two Fibonacci numbers. Then, it uses a while loop to calculate the next Fibonacci numbers by adding the last two numbers in the list. Finally, it returns the list of Fibonacci numbers.\nHere's an example of how to use the function:\npython\nn = 10\nfib_seq = fibonacci(n)\nprint(\"Fibonacci sequence up to\", n, \":\", fib_seq)\nThis program first initializes an integer called n with a value of 10. Then, it calls the fibonacci() function with the n as input and stores the result in a variable called fib_seq. Finally, it prints the Fibonacci sequence up to n using the print() function. In this case, the output will be:\nFibonacci sequence up to 10 : [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nThis output shows the Fibonacci sequence up to the input number n calculated using the fibonacci() function.\nUsing recursion: We can use recursion to calculate the Fibonacci sequence up to a given number. Here's an example implementation:\npython\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\nThis function takes an integer n as input and returns the nth number in the Fibonacci sequence using recursion. It first checks if the input number n is 0 or 1. If n is 0 or 1, the function returns n. If n is greater than 1, the function returns the sum of the n-1th and n-2th numbers in the Fibonacci sequence. This is where the recursive function call happens, where the function calls itself with the input n-1 and n-2.\nHere's an example of how to use the function:\npython\nn = 10\nfib_seq = [fibonacci(i) for i in range(n)]\nprint(\"Fibonacci sequence up to\", n, \":\", fib_seq)\nThis program first initializes an integer called n with a value of 10. Then, it calls the fibonacci() function with each integer from 0 to n-1 as input using a list comprehension and stores the result in a variable called fib_seq. Finally, it prints the Fibonacci sequence up to n using the print() function. In this case, the output will be:\nFibonacci sequence up to 10 : [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nThis output shows the Fibonacci sequence up to the input number n calculated using the fibonacci() function with recursion.\n1\nprogramiz\n2\neducative\n3\njavatpoint\n4\ngeeksforgeeks\n5\nscaler"
    },
    {
        "Input": "Write a Python class representing a binary tree and implement a method to calculate its height.",
        "Output": "To represent a binary tree in Python and calculate its height, we can define a TreeNode class to represent each node in the tree and a Tree class to represent the entire tree. Here's an example implementation:\npython\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Tree:\n    def __init__(self):\n        self.root = None\n\n    def height(self, node):\n        if node is None:\n            return 0\n        else:\n            left_height = self.height(node.left)\n            right_height = self.height(node.right)\n            return max(left_height, right_height) + 1\nThis implementation defines a TreeNode class with a value, a left child, and a right child. It also defines a Tree class with a root node. The height() method takes a node as input and returns the height of the subtree rooted at that node. It first checks if the node is None. If it is, the method returns 0. Otherwise, it recursively calculates the height of the left and right subtrees and returns the maximum height plus 1.\nHere's an example of how to use the classes:\npython\n# Create a binary tree\ntree = Tree()\ntree.root = TreeNode(1)\ntree.root.left = TreeNode(2)\ntree.root.right = TreeNode(3)\ntree.root.left.left = TreeNode(4)\ntree.root.left.right = TreeNode(5)\n\n# Calculate the height of the tree\nheight = tree.height(tree.root)\nprint(\"Height of the tree:\", height)\nThis program first creates a binary tree with 5 nodes using the Tree and TreeNode classes. Then, it calls the height() method of the Tree object with the root node as input and stores the result in a variable called height. Finally, it prints the height of the tree using the print() function. In this case, the output will be:\nHeight of the tree: 3\nThis output shows the height of the binary tree calculated using the height() method of the Tree object.\n1\nfavtutor\n2\nstackoverflow\n3\npythonforbeginners\n4\njavatpoint\n5\nyoutube"
    },
    {
        "Input": "Implement a function to find the median of a list of numbers.",
        "Output": "There are several ways to find the median of a list of numbers in Python. Here are a few examples:\nUsing the statistics module: We can use the statistics.median() function from the statistics module to find the median of a list of numbers. Here's an example implementation:\npython\nimport statistics\n\ndef find_median(lst):\n    return statistics.median(lst)\nThis function takes a list lst as input and returns the median of the list using the statistics.median() function.\nHere's an example of how to use the function:\npython\nlst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nmedian = find_median(lst)\nprint(\"Median of the list:\", median)\nThis program first initializes a list called lst with some numbers. Then, it calls the find_median() function with the lst as input and stores the result in a variable called median. Finally, it prints the median of the list using the print() function. In this case, the output will be:\nMedian of the list: 5\nThis output shows the median of the input list calculated using the find_median() function.\nUsing the numpy module: We can use the numpy.median() function from the numpy module to find the median of a list of numbers. Here's an example implementation:\npython\nimport numpy as np\n\ndef find_median(lst):\n    return np.median(lst)\nThis function takes a list lst as input and returns the median of the list using the numpy.median() function.\nHere's an example of how to use the function:\npython\nlst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nmedian = find_median(lst)\nprint(\"Median of the list:\", median)\nThis program first initializes a list called lst with some numbers. Then, it calls the find_median() function with the lst as input and stores the result in a variable called median. Finally, it prints the median of the list using the print() function. In this case, the output will be:\nMedian of the list: 5.0\nThis output shows the median of the input list calculated using the find_median() function.\nUsing a custom function: We can write our own function to find the median of a list of numbers. Here's an example implementation:\npython\ndef find_median(lst):\n    n = len(lst)\n    s = sorted(lst)\n    if n % 2 == 0:\n        return (s[n//2-1] + s[n//2]) / 2\n    else:\n        return s[n//2]\nThis function takes a list lst as input and returns the median of the list. It first calculates the length of the list and sorts the list using the sorted() function. Then, it checks if the length of the list is even or odd. If it's even, it returns the average of the middle two numbers. If it's odd, it returns the middle number.\nHere's an example of how to use the function:\npython\nlst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nmedian = find_median(lst)\nprint(\"Median of the list:\", median)\nThis program first initializes a list called lst with some numbers. Then, it calls the find_median() function with the lst as input and stores the result in a variable called median. Finally, it prints the median of the list using the print() function. In this case, the output will be:\nMedian of the list: 5\nThis output shows the median of the input list calculated using the find_median() function.\n1\ngeeksforgeeks\n2\nw3resource\n3\nstackoverflow\n4\ndatascienceparichay\n5\nfinxter"
    },
    {
        "Input": "Write a program to count the occurrences of each word in a given text file.",
        "Output": "To count the occurrences of each word in a given text file in Python, we can read the file, split each line into words, and use a dictionary to count the occurrences of each word. Here's an example implementation:\npython\ndef count_words(filename):\n    word_count = {}\n    with open(filename, 'r') as f:\n        for line in f:\n            words = line.split()\n            for word in words:\n                if word in word_count:\n                    word_count[word] += 1\n                else:\n                    word_count[word] = 1\n    return word_count\nThis function takes a filename as input and returns a dictionary with the count of occurrences of each word in the file. It first initializes an empty dictionary called word_count. Then, it opens the file using the open() function and reads each line in the file. It splits each line into words using the split() method and loops through each word. If the word is already in the word_count dictionary, it increments the count. Otherwise, it adds the word to the dictionary with a count of 1. Finally, it returns the word_count dictionary.\nHere's an example of how to use the function:\npython\nfilename = \"example.txt\"\nword_count = count_words(filename)\nprint(\"Occurrences of each word:\")\nfor word, count in word_count.items():\n    print(word, \":\", count)\nThis program first initializes a string called filename with the name of the file to count the occurrences of each word. Then, it calls the count_words() function with the filename as input and stores the result in a variable called word_count. Finally, it prints the occurrences of each word in the file using the print() function. In this case, the output will be:\nOccurrences of each word:\nThis : 1\nis : 2\nan : 1\nexample : 1\nfile : 2\nto : 1\ncount : 1\nthe : 2\noccurrences : 1\nof : 1\neach : 1\nword : 1\nThis output shows the occurrences of each word in the input file calculated using the count_words() function.\n1\nsanfoundry\n2\npythonexamples\n3\netutorialspoint\n4\ngeeksforgeeks\n5\nstackoverflow"
    },
    {
        "Input": "Create a function that checks if two strings are anagrams of each other.",
        "Output": "There are several ways to check if two strings are anagrams of each other in Python. Here are a few examples:\nUsing a dictionary: We can use a dictionary to count the frequency of each character in the strings. We can create two dictionaries, one for each string, and count the number of times each character appears in the string. If the dictionaries are equal, then the two original strings are anagrams. Here's an example implementation:\npython\ndef is_anagram(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    dict1 = {}\n    dict2 = {}\n    for char in str1:\n        if char in dict1:\n            dict1[char] += 1\n        else:\n            dict1[char] = 1\n    for char in str2:\n        if char in dict2:\n            dict2[char] += 1\n        else:\n            dict2[char] = 1\n    return dict1 == dict2\nThis function takes two strings str1 and str2 as input and returns True if they are anagrams of each other and False otherwise. It first checks if the lengths of the two strings are equal. Then, it creates two dictionaries dict1 and dict2 to count the frequency of each character in the two strings. It loops through each character in the two strings and increments the count in the corresponding dictionary. Finally, it returns True if the two dictionaries are equal and False otherwise.\nHere's an example of how to use the function:\npython\nstr1 = \"anagram\"\nstr2 = \"nagaram\"\nprint(is_anagram(str1, str2))  # True\n\nstr1 = \"hello\"\nstr2 = \"world\"\nprint(is_anagram(str1, str2))  # False\nThis program first initializes two strings called str1 and str2 with some text. Then, it calls the is_anagram() function with the str1 and str2 as input and prints the result using the print() function. In this case, the output will be:\nTrue\nFalse\nThis output shows whether the two input strings are anagrams of each other or not.\nUsing sorted() function: We can use the sorted() function to sort both strings and compare them. If the sorted strings are equal, then the two original strings are anagrams. Here's an example implementation:\npython\ndef is_anagram(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    sorted_str1 = sorted(str1)\n    sorted_str2 = sorted(str2)\n    return sorted_str1 == sorted_str2\nThis function takes two strings str1 and str2 as input and returns True if they are anagrams of each other and False otherwise. It first checks if the lengths of the two strings are equal. Then, it sorts both strings using the sorted() function and returns True if the sorted strings are equal and False otherwise.\nHere's an example of how to use the function:\npython\nstr1 = \"anagram\"\nstr2 = \"nagaram\"\nprint(is_anagram(str1, str2))  # True\n\nstr1 = \"hello\"\nstr2 = \"world\"\nprint(is_anagram(str1, str2))  # False\nThis program first initializes two strings called str1 and str2 with some text. Then, it calls the is_anagram() function with the str1 and str2 as input and prints the result using the print() function. In this case, the output will be:\nTrue\nFalse\nThis output shows whether the two input strings are anagrams of each other or not.\n1\ngeekbits\n2\nprogramiz\n3\ngeeksforgeeks\n4\nsanfoundry\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a recursive function to calculate the sum of digits in a positive integer.",
        "Output": "Here's an example implementation of a recursive function in Python to calculate the sum of digits in a positive integer:\npython\ndef sum_of_digits(n):\n    if n < 10:\n        return n\n    else:\n        return n % 10 + sum_of_digits(n // 10)\nThis function takes a positive integer n as input and returns the sum of its digits using recursion. It first checks if the input number n is less than 10. If n is less than 10, the function returns n. Otherwise, it returns the sum of the last digit of n and the result of calling the function recursively with the remaining digits of n.\nHere's an example of how to use the function:\npython\nn = 12345\nsum = sum_of_digits(n)\nprint(\"Sum of digits in\", n, \":\", sum)\nThis program first initializes an integer called n with a value of 12345. Then, it calls the sum_of_digits() function with the n as input and stores the result in a variable called sum. Finally, it prints the sum of the digits in n using the print() function. In this case, the output will be:\nSum of digits in 12345 : 15\nThis output shows the sum of the digits in the input number n calculated using the sum_of_digits() function.\n1\nwebrewrite\n2\nsanfoundry\n3\nsanfoundry\n4\ngeeksforgeeks\n5\nstackoverflow"
    },
    {
        "Input": "Write a program to find the largest continuous sum in a given list of integers.",
        "Output": "To find the largest continuous sum in a given list of integers in Python, we can use the Kadane's algorithm. Here's an example implementation:\npython\ndef max_subarray_sum(lst):\n    max_sum = lst[0]\n    current_sum = lst[0]\n    for i in range(1, len(lst)):\n        current_sum = max(lst[i], current_sum + lst[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\nThis function takes a list lst as input and returns the largest continuous sum in the list using Kadane's algorithm. It first initializes two variables max_sum and current_sum to the first element of the list. Then, it loops through the rest of the list and calculates the maximum sum of the subarray ending at the current index using the formula current_sum = max(lst[i], current_sum + lst[i]). It also updates the max_sum variable with the maximum sum seen so far. Finally, it returns the max_sum variable.\nHere's an example of how to use the function:\npython\nlst = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nmax_sum = max_subarray_sum(lst)\nprint(\"Largest continuous sum in the list:\", max_sum)\nThis program first initializes a list called lst with some integers. Then, it calls the max_subarray_sum() function with the lst as input and stores the result in a variable called max_sum. Finally, it prints the largest continuous sum in the list using the print() function. In this case, the output will be:\nLargest continuous sum in the list: 6\nThis output shows the largest continuous sum in the input list calculated using the max_subarray_sum() function.\n1\nstackoverflow\n2\nleetcode\n3\ngeeksforgeeks\n4\ninterviewbit\n5\nstudytonight"
    },
    {
        "Input": "Create a Python class representing a queue and implement its enqueue and dequeue methods.",
        "Output": "Here's an example implementation of a Python class representing a queue with its enqueue and dequeue methods:\npython\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n        else:\n            raise IndexError(\"Cannot dequeue from an empty queue.\")\n\n    def is_empty(self):\n        return len(self.items) == 0\nThis implementation defines a Queue class with an __init__() method to initialize an empty list called items, an enqueue() method to add an item to the end of the queue, a dequeue() method to remove and return the item at the front of the queue, and an is_empty() method to check if the queue is empty.\nThe dequeue() method checks if the queue is empty before dequeuing an item. If the queue is empty, it raises an IndexError with an appropriate error message.\nHere's an example of how to use the Queue class:\npython\nqueue = Queue()\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\nprint(queue.dequeue())  # 1\nprint(queue.dequeue())  # 2\nprint(queue.is_empty())  # False\nprint(queue.dequeue())  # 3\nprint(queue.is_empty())  # True\nThis program first creates an instance of the Queue class called queue. Then, it enqueues three items into the queue using the enqueue() method and dequeues them using the dequeue() method. Finally, it checks if the queue is empty using the is_empty() method. In this case, the output will be:\n1\n2\nFalse\n3\nTrue\nThis output shows the enqueue and dequeue operations performed on the queue object using the Queue class.\n1\nw3resource\n2\neducative\n3\nsimplilearn\n4\nsection\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function that checks if a given number is a prime number.",
        "Output": "To check if a given number is a prime number in Python, we can use several approaches. Here are a few examples:\nUsing a loop: We can use a loop to check if a number is prime by looping through all numbers in the range (2, n-1). If we find a factor that divides n evenly without a remainder, we can immediately conclude that the number is not prime. If we loop through the entire range of numbers from 2 all the way up to n – 1 without finding a number that divides n evenly, then the number is prime. Here's an example implementation:\npython\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\nThis function takes an integer n as input and returns True if it is a prime number and False otherwise. It first checks if the input number n is less than 2. If n is less than 2, the function returns False. Otherwise, it loops through all numbers in the range (2, n) and checks if any of them divides n evenly without a remainder. If it finds a factor that divides n evenly, it returns False. Otherwise, it returns True.\nHere's an example of how to use the function:\npython\nn = 17\nprint(is_prime(n))  # True\n\nn = 20\nprint(is_prime(n))  # False\nThis program first initializes an integer called n with a value of 17 and 20. Then, it calls the is_prime() function with the n as input and prints the result using the print() function. In this case, the output will be:\nTrue\nFalse\nThis output shows whether the input number is a prime number or not calculated using the is_prime() function.\nUsing the sympy module: We can use the sympy.isprime() function from the sympy module to check if a number is prime or not. Here's an example implementation:\npython\nfrom sympy import isprime\n\ndef is_prime(n):\n    return isprime(n)\nThis function takes an integer n as input and returns True if it is a prime number and False otherwise using the sympy.isprime() function.\nHere's an example of how to use the function:\npython\nn = 17\nprint(is_prime(n))  # True\n\nn = 20\nprint(is_prime(n))  # False\nThis program first initializes an integer called n with a value of 17 and 20. Then, it calls the is_prime() function with the n as input and prints the result using the print() function. In this case, the output will be:\nTrue\nFalse\nThis output shows whether the input number is a prime number or not calculated using the is_prime() function from the sympy module.\nBoth implementations are valid and can be used to check if a given number is a prime number in Python.\n1\ngeekflare\n2\ngeeksforgeeks\n3\nyoutube\n4\nprogramiz\n5\nbeginnersbook"
    },
    {
        "Input": "Write a program to convert a decimal number to its binary representation.",
        "Output": "To convert a decimal number to its binary representation in Python, we can use several approaches. Here are a few examples:\nUsing the format() function: We can use the format() function with the 'b' format specifier to convert a decimal number to its binary representation. Here's an example implementation:\npython\ndef decimal_to_binary(n):\n    return format(n, 'b')\nThis function takes an integer n as input and returns its binary representation using the format() function with the 'b' format specifier.\nHere's an example of how to use the function:\npython\nn = 10\nbinary = decimal_to_binary(n)\nprint(\"Binary representation of\", n, \":\", binary)\nThis program first initializes an integer called n with a value of 10. Then, it calls the decimal_to_binary() function with the n as input and stores the result in a variable called binary. Finally, it prints the binary representation of n using the print() function. In this case, the output will be:\nBinary representation of 10 : 1010\nThis output shows the binary representation of the input number n calculated using the decimal_to_binary() function.\nUsing the bin() function: We can use the bin() function to convert a decimal number to its binary representation. Here's an example implementation:\npython\ndef decimal_to_binary(n):\n    return bin(n)[2:]\nThis function takes an integer n as input and returns its binary representation using the bin() function.\nHere's an example of how to use the function:\npython\nn = 10\nbinary = decimal_to_binary(n)\nprint(\"Binary representation of\", n, \":\", binary)\nThis program first initializes an integer called n with a value of 10. Then, it calls the decimal_to_binary() function with the n as input and stores the result in a variable called binary. Finally, it prints the binary representation of n using the print() function. In this case, the output will be:\nBinary representation of 10 : 1010\nThis output shows the binary representation of the input number n calculated using the decimal_to_binary() function.\nBoth implementations are valid and can be used to convert a decimal number to its binary representation in Python.\n1\ngeeksforgeeks\n2\nscaler\n3\nyoutube\n4\ncodescracker\n5\nprogramiz"
    },
    {
        "Input": "Create a function that rotates a list to the right by a given number of steps.",
        "Output": "There are several ways to rotate a list to the right by a given number of steps in Python. Here are a few examples:\nUsing slicing: We can use slicing to rotate a list to the right by a given number of steps. We can split the list into two parts at the index len(lst) - k, where k is the number of steps to rotate the list. Then, we can concatenate the second part with the first part to get the rotated list. Here's an example implementation:\npython\ndef rotate_right(lst, k):\n    n = len(lst)\n    k = k % n\n    return lst[n-k:] + lst[:n-k]\nThis function takes a list lst and an integer k as input and returns the list rotated to the right by k steps using slicing. It first calculates the length of the list n and the effective number of steps k by taking the modulus of k with n. Then, it splits the list into two parts at the index n-k using slicing and concatenates the second part with the first part to get the rotated list.\nHere's an example of how to use the function:\npython\nlst = [1, 2, 3, 4, 5]\nk = 2\nrotated_lst = rotate_right(lst, k)\nprint(\"Original list:\", lst)\nprint(\"Rotated list:\", rotated_lst)\nThis program first initializes a list called lst with some integers and an integer called k with a value of 2. Then, it calls the rotate_right() function with the lst and k as input and stores the result in a variable called rotated_lst. Finally, it prints the original and rotated lists using the print() function. In this case, the output will be:\nOriginal list: [1, 2, 3, 4, 5]\nRotated list: [4, 5, 1, 2, 3]\nThis output shows the original and rotated lists calculated using the rotate_right() function.\nUsing a loop: We can use a loop to rotate a list to the right by a given number of steps. We can loop through the list k times and move the last element of the list to the front of the list in each iteration. Here's an example implementation:\npython\ndef rotate_right(lst, k):\n    n = len(lst)\n    k = k % n\n    for i in range(k):\n        lst.insert(0, lst.pop())\n    return lst\nThis function takes a list lst and an integer k as input and returns the list rotated to the right by k steps using a loop. It first calculates the length of the list n and the effective number of steps k by taking the modulus of k with n. Then, it loops through the list k times and moves the last element of the list to the front of the list in each iteration using the insert() and pop() methods.\nHere's an example of how to use the function:\npython\nlst = [1, 2, 3, 4, 5]\nk = 2\nrotated_lst = rotate_right(lst, k)\nprint(\"Original list:\", lst)\nprint(\"Rotated list:\", rotated_lst)\nThis program first initializes a list called lst with some integers and an integer called k with a value of 2. Then, it calls the rotate_right() function with the lst and k as input and stores the result in a variable called rotated_lst. Finally, it prints the original and rotated lists using the print() function. In this case, the output will be:\nOriginal list: [1, 2, 3, 4, 5]\nRotated list: [4, 5, 1, 2, 3]\nThis output shows the original and rotated lists calculated using the rotate_right() function.\nBoth implementations are valid and can be used to rotate a list to the right by a given number of steps in Python.\n1\nstudytonight\n2\ngeeksforgeeks\n3\naskpython\n4\ntutorialgateway\n5\ntutorialspoint"
    },
    {
        "Input": "Implement a recursive function to calculate the factorial of a given number.",
        "Output": "Here's an example implementation of a recursive function in Python to calculate the factorial of a given number:\npython\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\nThis function takes a positive integer n as input and returns its factorial using recursion. It first checks if the input number n is equal to 0. If n is equal to 0, the function returns 1. Otherwise, it returns the product of n and the result of calling the function recursively with n-1.\nHere's an example of how to use the function:\npython\nn = 5\nfact = factorial(n)\nprint(\"Factorial of\", n, \":\", fact)\nThis program first initializes an integer called n with a value of 5. Then, it calls the factorial() function with the n as input and stores the result in a variable called fact. Finally, it prints the factorial of n using the print() function. In this case, the output will be:\nFactorial of 5 : 120\nThis output shows the factorial of the input number n calculated using the factorial() function.\nNote that the recursive function can be slow for large values of n due to the repeated function calls. In such cases, it is better to use an iterative approach or memoization to calculate the factorial.\n1\nyoutube\n2\ntutorialspoint\n3\nprogramiz\n4\nscaler\n5\njavatpoint"
    },
    {
        "Input": "Write a Python class representing a graph and implement a method to perform a depth-first search.",
        "Output": "Here's an example implementation of a Python class representing a graph and a method to perform a depth-first search:\npython\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, u, v):\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def dfs(self, start, visited=None):\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        print(start)\n        for next in self.graph[start] - visited:\n            self.dfs(next, visited)\n\n# Example usage\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\nprint(\"Depth First Traversal (starting from vertex 2):\")\ng.dfs(2)\nThis implementation defines a Graph class with an __init__() method to initialize an empty dictionary called graph, an add_edge() method to add an edge to the graph, and a dfs() method to perform a depth-first search starting from a given vertex.\nThe dfs() method takes a starting vertex start and a set of visited vertices visited as input and performs a depth-first search on the graph starting from the start vertex. It first checks if the visited set is None. If it is, it initializes it to an empty set. Then, it adds the start vertex to the visited set and prints it. Finally, it loops through the neighbors of the start vertex that have not been visited yet and recursively calls the dfs() method on each neighbor.\nHere's an example of how to use the Graph class:\npython\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\nprint(\"Depth First Traversal (starting from vertex 2):\")\ng.dfs(2)\nThis program first creates an instance of the Graph class called g. Then, it adds some edges to the graph using the add_edge() method. Finally, it performs a depth-first search starting from vertex 2 using the dfs() method and prints the result using the print() function. In this case, the output will be:\nDepth First Traversal (starting from vertex 2):\n2\n0\n1\n3\nThis output shows the vertices visited during the depth-first search starting from vertex 2 in the graph.\n1\ngeeksforgeeks\n2\njavatpoint\n3\nlikegeeks\n4\nstackabuse\n5\nprogramiz"
    },
    {
        "Input": "Create a program to find the common elements between two lists.",
        "Output": "Here's an example Python program to find the common elements between two lists:\npython\ndef find_common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_elements = set1.intersection(set2)\n    return list(common_elements)\nThis function takes two lists list1 and list2 as input and returns a list of their common elements. It first converts both lists into sets using the set() function. Then, it uses the intersection() method to find the common elements between the two sets. Finally, it converts the resulting set back to a list using the list() function.\nHere's an example of how to use the function:\npython\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [3, 4, 5, 6, 7]\ncommon_elements = find_common_elements(list1, list2)\nprint(\"Common elements between\", list1, \"and\", list2, \":\", common_elements)\nThis program first initializes two lists called list1 and list2 with some integers. Then, it calls the find_common_elements() function with list1 and list2 as input and stores the result in a variable called common_elements. Finally, it prints the common elements between list1 and list2 using the print() function. In this case, the output will be:\nCommon elements between [1, 2, 3, 4, 5] and [3, 4, 5, 6, 7] : [3, 4, 5]\nThis output shows the common elements between the input lists calculated using the find_common_elements() function.\nThere are several other ways to find the common elements between two lists in Python, including using loops, list comprehensions, and built-in functions like filter().\n1\ntutorjoes\n2\njava2blog\n3\ncodespeedy\n4\ngeeksforgeeks\n5\nstackoverflow"
    },
    {
        "Input": "Implement a function that checks if a string is a valid email address.",
        "Output": "To check if a string is a valid email address in Python, we can use several approaches. Here are a few examples:\nUsing regular expressions: We can use regular expressions to validate the format of an email address. We can use the re module in Python to match a regular expression pattern against a string. Here's an example implementation:\npython\nimport re\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\nThis function takes a string email as input and returns True if it is a valid email address and False otherwise using regular expressions. It first defines a regular expression pattern that matches the format of a valid email address. Then, it uses the re.match() function to match the pattern against the input string and returns True if there is a match and False otherwise.\nHere's an example of how to use the function:\npython\nemail = 'example@example.com'\nvalid = is_valid_email(email)\nprint(\"Is\", email, \"a valid email address?\", valid)\nThis program first initializes a string called email with a value of 'example@example.com'. Then, it calls the is_valid_email() function with the email as input and stores the result in a variable called valid. Finally, it prints whether email is a valid email address using the print() function. In this case, the output will be:\nIs example@example.com a valid email address? True\nThis output shows whether the input string is a valid email address or not calculated using the is_valid_email() function with regular expressions.\nUsing third-party libraries: We can use third-party libraries like email-validator to validate email addresses. Here's an example implementation:\npython\nfrom email_validator import validate_email, EmailNotValidError\n\ndef is_valid_email(email):\n    try:\n        valid = validate_email(email)\n        email = valid.email\n        return True\n    except EmailNotValidError:\n        return False\nThis function takes a string email as input and returns True if it is a valid email address and False otherwise using the email-validator library. It first uses the validate_email() function to validate the email address and returns True if it is valid. If the email address is not valid, it raises an EmailNotValidError exception, which is caught by the except block and returns False.\nHere's an example of how to use the function:\npython\nemail = 'example@example.com'\nvalid = is_valid_email(email)\nprint(\"Is\", email, \"a valid email address?\", valid)\nThis program first initializes a string called email with a value of 'example@example.com'. Then, it calls the is_valid_email() function with the email as input and stores the result in a variable called valid. Finally, it prints whether email is a valid email address using the print() function. In this case, the output will be:\nIs example@example.com a valid email address? True\nThis output shows whether the input string is a valid email address or not calculated using the is_valid_email() function with the email-validator library.\nBoth implementations are valid and can be used to check if a string is a valid email address in Python.\n1\ngeeksforgeeks\n2\nstackabuse\n3\nstackoverflow\n4\nalixaprodev\n5\npypi"
    },
    {
        "Input": "Write a program to find the missing number in a given list of integers.",
        "Output": "To find the missing number in a given list of integers in Python, we can use several approaches. Here are a few examples:\nUsing the set() function: We can use the set() function to find the missing number in a list of integers. We can first convert the list to a set and then create another set containing all the integers from the minimum to the maximum value in the list. Finally, we can find the difference between the two sets to get the missing number. Here's an example implementation:\npython\ndef find_missing_number(lst):\n    n = len(lst) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(lst)\n    return expected_sum - actual_sum\nThis function takes a list lst as input and returns the missing number in the list. It first calculates the expected sum of the integers from 1 to n, where n is the length of the list plus one, using the formula n * (n + 1) // 2. Then, it calculates the actual sum of the integers in the list using the sum() function. Finally, it returns the difference between the expected sum and the actual sum, which is the missing number.\nHere's an example of how to use the function:\npython\nlst = [1, 2, 3, 4, 6, 7, 8, 9, 10]\nmissing_number = find_missing_number(lst)\nprint(\"Missing number in\", lst, \":\", missing_number)\nThis program first initializes a list called lst with some integers. Then, it calls the find_missing_number() function with the lst as input and stores the result in a variable called missing_number. Finally, it prints the missing number in the list using the print() function. In this case, the output will be:\nMissing number in [1, 2, 3, 4, 6, 7, 8, 9, 10] : 5\nThis output shows the missing number in the input list calculated using the find_missing_number() function.\nUsing the numpy library: We can use the numpy library to find the missing number in a list of integers. We can first create an array containing all the integers from 1 to n, where n is the length of the list plus one, using the numpy.arange() function. Then, we can use the numpy.setdiff1d() function to find the difference between the expected array and the actual list to get the missing number. Here's an example implementation:\npython\nimport numpy as np\n\ndef find_missing_number(lst):\n    n = len(lst) + 1\n    expected_nums = np.arange(1, n)\n    missing_nums = np.setdiff1d(expected_nums, lst)\n    return missing_nums[0]\nThis function takes a list lst as input and returns the missing number in the list using the numpy library. It first calculates the expected array containing all the integers from 1 to n, where n is the length of the list plus one, using the numpy.arange() function. Then, it uses the numpy.setdiff1d() function to find the difference between the expected array and the actual list to get the missing number.\nHere's an example of how to use the function:\npython\nlst = [1, 2, 3, 4, 6, 7, 8, 9, 10]\nmissing_number = find_missing_number(lst)\nprint(\"Missing number in\", lst, \":\", missing_number)\nThis program first initializes a list called lst with some integers. Then, it calls the find_missing_number() function with the lst as input and stores the result in a variable called missing_number. Finally, it prints the missing number in the list using the print() function. In this case, the output will be:\nMissing number in [1, 2, 3, 4, 6, 7, 8, 9, 10] : 5\nThis output shows the missing number in the input list calculated using the find_missing_number() function with the numpy library.\nBoth implementations are valid and can be used to find the missing number in a given list of integers in Python.\n1\nstatisticsglobe\n2\ngeeksforgeeks\n3\nw3resource\n4\ntutorialspoint\n5\ndjangocentral"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid palindrome, ignoring non-alphanumeric characters.\"",
        "Output": "One way to check if a given string is a valid palindrome, ignoring non-alphanumeric characters, is to first remove all non-alphanumeric characters from the string and then check if the resulting string is a palindrome. Here's an example implementation in Python:\npython\ndef is_valid_palindrome(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    s = ''.join(c for c in s if c.isalnum()).lower()\n    # Check if the resulting string is a palindrome\n    return s == s[::-1]\nThis function takes a string s as input and returns True if it is a valid palindrome, ignoring non-alphanumeric characters, and False otherwise. It first removes all non-alphanumeric characters from the string using a list comprehension and the isalnum() method, and then converts the resulting string to lowercase. Finally, it checks if the resulting string is a palindrome by comparing it to its reverse using the slicing operator [::-1].\nHere's an example of how to use the function:\npython\ns = \"A man, a plan, a canal: Panama\"\nvalid = is_valid_palindrome(s)\nprint(\"Is\", s, \"a valid palindrome?\", valid)\nThis program first initializes a string called s with a value of \"A man, a plan, a canal: Panama\". Then, it calls the is_valid_palindrome() function with the s as input and stores the result in a variable called valid. Finally, it prints whether s is a valid palindrome using the print() function. In this case, the output will be:\nIs A man, a plan, a canal: Panama a valid palindrome? True\nThis output shows whether the input string is a valid palindrome, ignoring non-alphanumeric characters, calculated using the is_valid_palindrome() function.\nNote that there are other ways to check if a string is a valid palindrome, ignoring non-alphanumeric characters, such as using regular expressions or iterating through the string with two pointers.\n1\nleetcode\n2\nprepfortech\n3\npearsoncmg\n4\nlearncodingfast\n5\nstackoverflow"
    },
    {
        "Input": "Create a Python class representing a queue and implement its size and is_empty methods.",
        "Output": "To create a Python class representing a queue and implement its size and is_empty methods, we can use the following implementation:\npython\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n\n    def is_empty(self):\n        return len(self.items) == 0\nThis implementation defines a Queue class with an __init__() method to initialize an empty list called items, an enqueue() method to add an item to the end of the queue, a dequeue() method to remove and return the first item in the queue, a size() method to return the number of items in the queue, and an is_empty() method to check if the queue is empty.\nThe size() method simply returns the length of the items list using the len() function. The is_empty() method checks if the length of the items list is equal to 0 and returns True if it is, and False otherwise.\nHere's an example of how to use the Queue class:\npython\nq = Queue()\nprint(\"Is the queue empty?\", q.is_empty())\nq.enqueue(1)\nq.enqueue(2)\nq.enqueue(3)\nprint(\"Size of the queue:\", q.size())\nprint(\"Is the queue empty?\", q.is_empty())\nq.dequeue()\nprint(\"Size of the queue:\", q.size())\nThis program first creates an instance of the Queue class called q. Then, it checks if the queue is empty using the is_empty() method and prints the result using the print() function. Next, it adds some items to the queue using the enqueue() method. Then, it gets the size of the queue using the size() method and prints the result using the print() function. Finally, it removes an item from the queue using the dequeue() method and gets the size of the queue again using the size() method and prints the result using the print() function. In this case, the output will be:\nIs the queue empty? True\nSize of the queue: 3\nIs the queue empty? False\nSize of the queue: 2\nThis output shows the size of the queue and whether it is empty or not calculated using the Queue class.\n1\ngeekflare\n2\ntechiedelight\n3\nw3resource\n4\nsection\n5\neducative"
    },
    {
        "Input": "Write a program to check if two strings are rotations of each other.",
        "Output": "To check if two strings are rotations of each other in Python, we can use several approaches. Here are a few examples:\nUsing concatenation: We can concatenate the first string with itself and then check if the second string is a substring of the concatenated string. Here's an example implementation:\npython\ndef are_rotations(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    temp = s1 + s1\n    if s2 in temp:\n        return True\n    else:\n        return False\nThis function takes two strings s1 and s2 as input and returns True if they are rotations of each other and False otherwise. It first checks if the lengths of the two strings are equal. If they are not equal, it returns False. Then, it concatenates the first string with itself to create a temporary string called temp. Finally, it checks if the second string is a substring of the temp string using the in operator and returns True if it is, and False otherwise.\nHere's an example of how to use the function:\npython\ns1 = \"ABCD\"\ns2 = \"CDAB\"\nvalid = are_rotations(s1, s2)\nprint(\"Are\", s1, \"and\", s2, \"rotations of each other?\", valid)\nThis program first initializes two strings called s1 and s2 with some values. Then, it calls the are_rotations() function with s1 and s2 as input and stores the result in a variable called valid. Finally, it prints whether s1 and s2 are rotations of each other using the print() function. In this case, the output will be:\nAre ABCD and CDAB rotations of each other? True\nThis output shows whether the two input strings are rotations of each other calculated using the are_rotations() function.\nUsing slicing: We can slice the first string into two parts at a certain index and then check if the second string is equal to the concatenation of the second part and the first part of the first string. Here's an example implementation:\npython\ndef are_rotations(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    for i in range(len(s1)):\n        if s1[i:] + s1[:i] == s2:\n            return True\n    return False\nThis function takes two strings s1 and s2 as input and returns True if they are rotations of each other and False otherwise. It first checks if the lengths of the two strings are equal. If they are not equal, it returns False. Then, it loops through the indices of the first string using a for loop and checks if the concatenation of the second part and the first part of the first string is equal to the second string. If it is, it returns True. If the loop completes without finding a match, it returns False.\nHere's an example of how to use the function:\npython\ns1 = \"ABCD\"\ns2 = \"CDAB\"\nvalid = are_rotations(s1, s2)\nprint(\"Are\", s1, \"and\", s2, \"rotations of each other?\", valid)\nThis program first initializes two strings called s1 and s2 with some values. Then, it calls the are_rotations() function with s1 and s2 as input and stores the result in a variable called valid. Finally, it prints whether s1 and s2 are rotations of each other using the print() function. In this case, the output will be:\nAre ABCD and CDAB rotations of each other? True\nThis output shows whether the two input strings are rotations of each other calculated using the are_rotations() function.\nBoth implementations are valid and can be used to check if two strings are rotations of each other in Python.\n1\ngeeksforgeeks\n2\ntutorialspoint\n3\nstackoverflow\n4\ncodesdope\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to calculate the power of a number using recursion.",
        "Output": "Here's an example implementation of a Python function to calculate the power of a number using recursion:\npython\ndef power(base, exponent):\n    if exponent == 0:\n        return 1\n    elif exponent == 1:\n        return base\n    else:\n        return base * power(base, exponent - 1)\nThis function takes two arguments base and exponent and returns the value of base raised to the power of exponent using recursion. It first checks if the exponent is 0 and returns 1 if it is. Then, it checks if the exponent is 1 and returns the base if it is. Finally, if the exponent is greater than 1, it multiplies the base by the result of calling the power() function recursively with the base and the exponent minus 1.\nHere's an example of how to use the function:\npython\nbase = 2\nexponent = 5\nresult = power(base, exponent)\nprint(base, \"raised to the power of\", exponent, \"is\", result)\nThis program first initializes two variables called base and exponent with some values. Then, it calls the power() function with base and exponent as input and stores the result in a variable called result. Finally, it prints the result using the print() function. In this case, the output will be:\n2 raised to the power of 5 is 32\nThis output shows the result of raising the base to the exponent calculated using the power() function.\nThere are several other ways to calculate the power of a number using recursion in Python, including using the numpy library or using a binary approach.\n1\ntutorialspoint\n2\ncodespeedy\n3\nstackoverflow\n4\nprepinsta\n5\nincludehelp"
    },
    {
        "Input": "Create a program to remove all duplicates from a string.",
        "Output": "There are several ways to remove all duplicates from a string in Python. Here are a few examples:\nUsing an ordered dictionary: We can use an ordered dictionary to remove duplicates from a string while preserving the order of the characters. Here's an example implementation:\npython\nfrom collections import OrderedDict\n\ndef remove_duplicates(s):\n    return ''.join(OrderedDict.fromkeys(s))\nThis function takes a string s as input and returns a new string with all duplicates removed while preserving the order of the characters. It first creates an ordered dictionary from the string using the OrderedDict.fromkeys() method, which removes duplicates while preserving the order of the characters. Then, it converts the ordered dictionary back to a string using the join() method.\nHere's an example of how to use the function:\npython\ns = \"hello world\"\nresult = remove_duplicates(s)\nprint(\"String with duplicates removed:\", result)\nThis program first initializes a string called s with a value of \"hello world\". Then, it calls the remove_duplicates() function with s as input and stores the result in a variable called result. Finally, it prints the resulting string with duplicates removed using the print() function. In this case, the output will be:\nString with duplicates removed: helo wrd\nThis output shows the resulting string with duplicates removed calculated using the remove_duplicates() function.\nUsing a set: We can use a set to remove duplicates from a string, but this method does not preserve the order of the characters. Here's an example implementation:\npython\ndef remove_duplicates(s):\n    return ''.join(set(s))\nThis function takes a string s as input and returns a new string with all duplicates removed. It first creates a set from the string using the set() method, which removes duplicates but does not preserve the order of the characters. Then, it converts the set back to a string using the join() method.\nHere's an example of how to use the function:\npython\ns = \"hello world\"\nresult = remove_duplicates(s)\nprint(\"String with duplicates removed:\", result)\nThis program first initializes a string called s with a value of \"hello world\". Then, it calls the remove_duplicates() function with s as input and stores the result in a variable called result. Finally, it prints the resulting string with duplicates removed using the print() function. In this case, the output will be:\nString with duplicates removed: dehlorw \nThis output shows the resulting string with duplicates removed calculated using the remove_duplicates() function with a set.\nBoth implementations are valid and can be used to remove all duplicates from a string in Python.\n1\nstudytonight\n2\ngeeksforgeeks\n3\ntutorialspoint\n4\nfavtutor\n5\ngeeksforgeeks"
    },
    {
        "Input": "Write a Python class representing a binary search tree and implement a method to insert a node.",
        "Output": "To create a Python class representing a binary search tree and implement a method to insert a node, we can use the following implementation:\npython\nclass Node:\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, data):\n        if self.root is None:\n            self.root = Node(data)\n        else:\n            self._insert(data, self.root)\n\n    def _insert(self, data, current_node):\n        if data < current_node.data:\n            if current_node.left is None:\n                current_node.left = Node(data)\n            else:\n                self._insert(data, current_node.left)\n        elif data > current_node.data:\n            if current_node.right is None:\n                current_node.right = Node(data)\n            else:\n                self._insert(data, current_node.right)\n        else:\n            print(\"Value already exists in the tree.\")\nThis implementation defines a Node class with a constructor that initializes the left and right child nodes and the data of the node. It also defines a BinarySearchTree class with a constructor that initializes the root node of the tree to None. The BinarySearchTree class also has an insert() method that takes a value as input and inserts it into the tree.\nThe insert() method first checks if the root node is None. If it is, it creates a new node with the input value and sets it as the root node. If the root node is not None, it calls the _insert() method with the input value and the root node as input. The _insert() method recursively traverses the tree to find the correct position to insert the new node based on the value of the node. If the value already exists in the tree, it prints a message indicating that the value already exists.\nHere's an example of how to use the BinarySearchTree class:\npython\nbst = BinarySearchTree()\nbst.insert(5)\nbst.insert(3)\nbst.insert(7)\nbst.insert(2)\nbst.insert(4)\nbst.insert(6)\nbst.insert(8)\nThis program first creates an instance of the BinarySearchTree class called bst. Then, it inserts some values into the tree using the insert() method. In this case, the output will be:\nValue already exists in the tree.\nThis output shows that the value 5 already exists in the tree and was not inserted again.\nNote that this implementation is just one way to create a binary search tree and insert a node into it. There are other ways to implement a binary search tree, such as using an iterative approach or implementing additional methods for searching and deleting nodes.\n1\nmedium\n2\nstackoverflow\n3\nlog2base2\n4\naskpython\n5\nscaler"
    },
    {
        "Input": "Implement a function to find the longest substring without repeating characters in a given string.",
        "Output": "To find the longest substring without repeating characters in a given string in Python, we can use several approaches. Here are a few examples:\nUsing a sliding window approach: We can use a sliding window approach to find the longest substring without repeating characters in a given string. We can use two pointers, start and end, to represent the start and end of the current substring, and a set to keep track of the characters in the current substring. We can move the end pointer to the right until we find a repeating character, and then move the start pointer to the right until we remove the repeating character from the set. We can repeat this process until we reach the end of the string. Here's an example implementation:\npython\ndef longest_substring(s):\n    start = 0\n    end = 0\n    max_length = 0\n    chars = set()\n    while end < len(s):\n        if s[end] not in chars:\n            chars.add(s[end])\n            end += 1\n            max_length = max(max_length, end - start)\n        else:\n            chars.remove(s[start])\n            start += 1\n    return max_length\nThis function takes a string s as input and returns the length of the longest substring without repeating characters in the string using a sliding window approach. It first initializes the start and end pointers to 0, the max_length variable to 0, and the chars set to an empty set. Then, it loops through the string using a while loop and checks if the current character at the end pointer is in the chars set. If it is not, it adds the character to the set, moves the end pointer to the right, and updates the max_length variable if necessary. If it is, it removes the character at the start pointer from the set, moves the start pointer to the right, and repeats the process until the current character is not in the set. Finally, it returns the max_length variable.\nHere's an example of how to use the function:\npython\ns = \"abcabcbb\"\nresult = longest_substring(s)\nprint(\"Longest substring without repeating characters:\", result)\nThis program first initializes a string called s with a value of \"abcabcbb\". Then, it calls the longest_substring() function with s as input and stores the result in a variable called result. Finally, it prints the length of the longest substring without repeating characters using the print() function. In this case, the output will be:\nLongest substring without repeating characters: 3\nThis output shows the length of the longest substring without repeating characters calculated using the longest_substring() function.\nUsing a hash table: We can use a hash table to keep track of the last occurrence of each character in the string and the start of the current substring. We can loop through the string and update the hash table and the start of the current substring as necessary. Here's an example implementation:\npython\ndef longest_substring(s):\n    start = 0\n    max_length = 0\n    last_seen = {}\n    for end in range(len(s)):\n        if s[end] in last_seen and last_seen[s[end]] >= start:\n            start = last_seen[s[end]] + 1\n        last_seen[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    return max_length\nThis function takes a string s as input and returns the length of the longest substring without repeating characters in the string using a hash table. It first initializes the start variable to 0, the max_length variable to 0, and the last_seen hash table to an empty dictionary. Then, it loops through the string using a for loop and checks if the current character at the end index is in the last_seen hash table and if its last occurrence is after the start of the current substring. If it is, it updates the start of the current substring to the last occurrence of the character plus 1. Then, it updates the last_seen hash table with the current character and its index, and updates the max_length variable if necessary. Finally, it returns the max_length variable.\nHere's an example of how to use the function:\npython\ns = \"abcabcbb\"\nresult = longest_substring(s)\nprint(\"Longest substring without repeating characters:\", result)\nThis program first initializes a string called s with a value of \"abcabcbb\". Then, it calls the longest_substring() function with s as input and stores the result in a variable called result. Finally, it prints the length of the longest substring without repeating characters using the print() function. In this case, the output will be:\nLongest substring without repeating characters: 3\nThis output shows the length of the longest substring without repeating characters calculated using the longest_substring() function with a hash table.\nBoth implementations are valid and can be used to find the longest substring without repeating characters in a given string in Python.\n1\ntutorialspoint\n2\ncodedamn\n3\nenjoyalgorithms\n4\nyoutube\n5\ninterviewbit"
    },
    {
        "Input": "Create a program to reverse the order of words in a given sentence.",
        "Output": "To reverse the order of words in a given sentence in Python, we can use the following implementation:\npython\ndef reverse_sentence(sentence):\n    words = sentence.split()\n    reversed_words = words[::-1]\n    reversed_sentence = \" \".join(reversed_words)\n    return reversed_sentence\nThis implementation defines a function called reverse_sentence() that takes a string sentence as input and returns a new string with the order of words in the sentence reversed. It first splits the sentence into a list of words using the split() method, which splits the string at whitespace characters. Then, it reverses the order of the words in the list using the [::-1] slice operator. Finally, it joins the reversed list of words back into a string using the join() method with a space character as the separator.\nHere's an example of how to use the function:\npython\nsentence = \"This is a test sentence\"\nreversed_sentence = reverse_sentence(sentence)\nprint(\"Reversed sentence:\", reversed_sentence)\nThis program first initializes a string called sentence with a value of \"This is a test sentence\". Then, it calls the reverse_sentence() function with sentence as input and stores the result in a variable called reversed_sentence. Finally, it prints the resulting string with the order of words reversed using the print() function. In this case, the output will be:\nReversed sentence: sentence test a is This\nThis output shows the resulting string with the order of words reversed calculated using the reverse_sentence() function.\nNote that this implementation assumes that the words in the sentence are separated by whitespace characters. If the sentence contains punctuation or other non-alphanumeric characters, they will be included in the words and may affect the result. To handle this case, we can use regular expressions to split the sentence into words.\n1\ndjangocentral\n2\ngeeksforgeeks\n3\ngeeksforgeeks\n4\nstudytonight\n5\ntutorialspoint"
    },
    {
        "Input": "Write a function that returns the nth Fibonacci number using dynamic programming.",
        "Output": "To find the nth Fibonacci number using dynamic programming in Python, we can use the following implementation:\npython\ndef fibonacci(n):\n    fib_array = [0, 1]\n    for i in range(2, n + 1):\n        fib_array.append(fib_array[i - 1] + fib_array[i - 2])\n    return fib_array[n]\nThis implementation defines a function called fibonacci() that takes an integer n as input and returns the nth Fibonacci number using dynamic programming. It first initializes a list called fib_array with the first two Fibonacci numbers, 0 and 1. Then, it uses a for loop to append the remaining Fibonacci numbers to the list using the recurrence relation fib_array[i] = fib_array[i-1] + fib_array[i-2]. Finally, it returns the nth element of the list.\nHere's an example of how to use the function:\npython\nn = 10\nresult = fibonacci(n)\nprint(\"The\", n, \"th Fibonacci number is:\", result)\nThis program first initializes an integer called n with a value of 10. Then, it calls the fibonacci() function with n as input and stores the result in a variable called result. Finally, it prints the nth Fibonacci number using the print() function. In this case, the output will be:\nThe 10 th Fibonacci number is: 55\nThis output shows the nth Fibonacci number calculated using the fibonacci() function with dynamic programming.\nNote that this implementation has a time complexity of O(n) and an auxiliary space complexity of O(n), which is better than the recursive approach with a time complexity of O(2^n) and an auxiliary space complexity of O(n). There are also other approaches to finding the nth Fibonacci number using dynamic programming, such as using memoization or a bottom-up approach.\n1\ngeeksforgeeks\n2\neducative\n3\njavatpoint\n4\nsanfoundry\n5\nsanfoundry"
    },
    {
        "Input": "Implement a program to perform matrix multiplication.",
        "Output": "To perform matrix multiplication in Python, we can use several approaches. Here are a few examples:\nUsing nested loops: We can use nested loops to iterate through each row and column of the matrices and calculate the product of the corresponding elements. Here's an example implementation:\npython\ndef matrix_multiplication(X, Y):\n    result = []\n    for i in range(len(X)):\n        row = []\n        for j in range(len(Y[0])):\n            sum = 0\n            for k in range(len(Y)):\n                sum += X[i][k] * Y[k][j]\n            row.append(sum)\n        result.append(row)\n    return result\nThis function takes two matrices X and Y as input and returns their product using nested loops. It first initializes an empty list called result. Then, it uses three nested loops to iterate through each row and column of the matrices and calculate the product of the corresponding elements. It stores the result in a new list called row, which is appended to the result list. Finally, it returns the result list.\nHere's an example of how to use the function:\npython\nX = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nY = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\nresult = matrix_multiplication(X, Y)\nprint(\"Product of matrices X and Y:\", result)\nThis program first initializes two matrices called X and Y with some values. Then, it calls the matrix_multiplication() function with X and Y as input and stores the result in a variable called result. Finally, it prints the product of the matrices using the print() function. In this case, the output will be:\nProduct of matrices X and Y: [[30, 24, 18], [84, 69, 54], [138, 114, 90]]\nThis output shows the product of the matrices calculated using the matrix_multiplication() function with nested loops.\nUsing NumPy: We can use the NumPy library to perform matrix multiplication more efficiently. Here's an example implementation:\npython\nimport numpy as np\n\ndef matrix_multiplication(X, Y):\n    X = np.array(X)\n    Y = np.array(Y)\n    result = np.dot(X, Y)\n    return result.tolist()\nThis function takes two matrices X and Y as input and returns their product using NumPy. It first converts the matrices to NumPy arrays using the np.array() method. Then, it uses the np.dot() method to calculate the product of the matrices. Finally, it converts the result back to a list using the tolist() method.\nHere's an example of how to use the function:\npython\nX = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nY = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\nresult = matrix_multiplication(X, Y)\nprint(\"Product of matrices X and Y:\", result)\nThis program first initializes two matrices called X and Y with some values. Then, it calls the matrix_multiplication() function with X and Y as input and stores the result in a variable called result. Finally, it prints the product of the matrices using the print() function. In this case, the output will be:\nProduct of matrices X and Y: [[30, 24, 18], [84, 69, 54], [138, 114, 90]]\nThis output shows the product of the matrices calculated using the matrix_multiplication() function with NumPy.\nBoth implementations are valid and can be used to perform matrix multiplication in Python. The NumPy implementation is generally faster and more efficient for larger matrices.\n1\nprogramiz\n2\ngeeksforgeeks\n3\ngeeksforgeeks\n4\njavatpoint\n5\ngeekflare"
    },
    {
        "Input": "Create a Python class representing a stack and implement a method to check if it is empty.",
        "Output": "Here's an example implementation of a Python class representing a stack and implementing a method to check if it is empty:\npython\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\nThis implementation defines a Stack class with a constructor that initializes an empty list called items. The Stack class also has an is_empty() method that returns True if the stack is empty (i.e., the length of the items list is 0) and False otherwise.\nHere's an example of how to use the Stack class:\npython\nstack = Stack()\nprint(\"Is the stack empty?\", stack.is_empty())\nThis program first creates an instance of the Stack class called stack. Then, it calls the is_empty() method on the stack object and prints the result using the print() function. In this case, the output will be:\nIs the stack empty? True\nThis output shows that the is_empty() method correctly identifies that the stack is empty.\nNote that this implementation is just one way to create a stack and check if it is empty. There are other ways to implement a stack, such as using a linked list or implementing additional methods for pushing and popping elements.\n1\nmygreatlearning\n2\ncodecademy\n3\npythonforbeginners\n4\ngeeksforgeeks\n5\nrunestone"
    },
    {
        "Input": "Write a program to find the least common multiple (LCM) of two numbers.",
        "Output": "To find the least common multiple (LCM) of two numbers in Python, we can use several approaches. Here are a few examples:\nUsing the gcd function from the fractions module: We can use the gcd function from the fractions module to find the LCM of two numbers using the formula LCM(a,b) = (a * b) // gcd(a,b). Here's an example implementation:\npython\nfrom fractions import gcd\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\nThis function takes two integers a and b as input and returns their LCM using the gcd function from the fractions module. It uses the formula LCM(a,b) = (a * b) // gcd(a,b) to calculate the LCM.\nHere's an example of how to use the function:\npython\na = 12\nb = 14\nresult = lcm(a, b)\nprint(\"LCM of\", a, \"and\", b, \"is:\", result)\nThis program first initializes two integers called a and b with some values. Then, it calls the lcm() function with a and b as input and stores the result in a variable called result. Finally, it prints the LCM of the two numbers using the print() function. In this case, the output will be:\nLCM of 12 and 14 is: 84\nThis output shows the LCM of the two numbers calculated using the lcm() function with the gcd function from the fractions module.\nUsing a while loop: We can use a while loop to find the LCM of two numbers by iterating through all multiples of the larger number until we find a multiple that is also a multiple of the smaller number. Here's an example implementation:\npython\ndef lcm(a, b):\n    if a > b:\n        greater = a\n    else:\n        greater = b\n    while True:\n        if greater % a == 0 and greater % b == 0:\n            lcm = greater\n            break\n        greater += 1\n    return lcm\nThis function takes two integers a and b as input and returns their LCM using a while loop. It first checks which number is greater and initializes a variable called greater to that number. Then, it uses a while loop to iterate through all multiples of greater until it finds a multiple that is also a multiple of the smaller number. It stores the result in a variable called lcm and returns it.\nHere's an example of how to use the function:\npython\na = 12\nb = 14\nresult = lcm(a, b)\nprint(\"LCM of\", a, \"and\", b, \"is:\", result)\nThis program first initializes two integers called a and b with some values. Then, it calls the lcm() function with a and b as input and stores the result in a variable called result. Finally, it prints the LCM of the two numbers using the print() function. In this case, the output will be:\nLCM of 12 and 14 is: 84\nThis output shows the LCM of the two numbers calculated using the lcm() function with a while loop.\nBoth implementations are valid and can be used to find the LCM of two numbers in Python. The first implementation is more efficient and uses the gcd function from the fractions module, while the second implementation is simpler and uses a while loop.\n1\nw3resource\n2\nprogramiz\n3\nscaler\n4\nprepinsta\n5\njavatpoint"
    },
    {
        "Input": "Implement a function to check if a given string is a valid IPv4 address.",
        "Output": "To check if a given string is a valid IPv4 address in Python, we can use several approaches. Here are a few examples:\nUsing the ipaddress module: We can use the ipaddress module from the Python Standard Library to validate an IPv4 address. Here's an example implementation:\npython\nimport ipaddress\n\ndef is_valid_ipv4_address(address):\n    try:\n        ipaddress.IPv4Address(address)\n        return True\n    except ipaddress.AddressValueError:\n        return False\nThis function takes a string address as input and returns True if it is a valid IPv4 address and False otherwise. It uses the IPv4Address() method from the ipaddress module to validate the address. If the address is valid, the method returns an IPv4Address object, and the function returns True. If the address is not valid, the method raises an AddressValueError exception, and the function returns False.\nHere's an example of how to use the function:\npython\naddress = \"192.168.0.1\"\nresult = is_valid_ipv4_address(address)\nprint(\"Is\", address, \"a valid IPv4 address?\", result)\nThis program first initializes a string called address with a value of \"192.168.0.1\". Then, it calls the is_valid_ipv4_address() function with address as input and stores the result in a variable called result. Finally, it prints whether the address is a valid IPv4 address using the print() function. In this case, the output will be:\nIs 192.168.0.1 a valid IPv4 address? True\nThis output shows that the is_valid_ipv4_address() function correctly identifies that the address is a valid IPv4 address.\nUsing regular expressions: We can use regular expressions to validate an IPv4 address by checking if it matches the pattern of four decimal integers in the inclusive range 0–255, separated by dots. Here's an example implementation:\npython\nimport re\n\ndef is_valid_ipv4_address(address):\n    pattern = r\"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\"\n    return bool(re.match(pattern, address))\nThis function takes a string address as input and returns True if it is a valid IPv4 address and False otherwise. It uses a regular expression pattern to validate the address. The pattern matches four decimal integers in the inclusive range 0–255, separated by dots.\nHere's an example of how to use the function:\npython\naddress = \"192.168.0.1\"\nresult = is_valid_ipv4_address(address)\nprint(\"Is\", address, \"a valid IPv4 address?\", result)\nThis program first initializes a string called address with a value of \"192.168.0.1\". Then, it calls the is_valid_ipv4_address() function with address as input and stores the result in a variable called result. Finally, it prints whether the address is a valid IPv4 address using the print() function. In this case, the output will be:\nIs 192.168.0.1 a valid IPv4 address? True\nThis output shows that the is_valid_ipv4_address() function correctly identifies that the address is a valid IPv4 address.\nBoth implementations are valid and can be used to check if a given string is a valid IPv4 address in Python. The first implementation uses the ipaddress module from the Python Standard Library, while the second implementation uses regular expressions.\n1\nstackoverflow\n2\npython\n3\nw3resource\n4\ncodefather\n5\njavatpoint"
    },
    {
        "Input": "Create a program to find the largest prime factor of a given number.",
        "Output": "Here's an example implementation of a Python program to find the largest prime factor of a given number:\npython\nimport math\n\ndef largest_prime_factor(n):\n    max_prime_factor = 0\n    while n % 2 == 0:\n        max_prime_factor = 2\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime_factor = i\n            n = n / i\n    if n > 2:\n        max_prime_factor = n\n    return int(max_prime_factor)\nThis implementation defines a function called largest_prime_factor() that takes an integer n as input and returns the largest prime factor of n. It first initializes a variable called max_prime_factor to 0. Then, it uses a while loop to divide n by 2 until it is no longer divisible by 2, and updates max_prime_factor to 2. This step ensures that the function handles even numbers correctly. Next, it uses a for loop to iterate through all odd numbers from 3 to the square root of n, and divides n by each odd number until it is no longer divisible by that number. It updates max_prime_factor to the current number if it is a factor of n. Finally, it returns max_prime_factor as an integer.\nHere's an example of how to use the function:\npython\nn = 60\nresult = largest_prime_factor(n)\nprint(\"The largest prime factor of\", n, \"is:\", result)\nThis program first initializes an integer called n with a value of 60. Then, it calls the largest_prime_factor() function with n as input and stores the result in a variable called result. Finally, it prints the largest prime factor of n using the print() function. In this case, the output will be:\nThe largest prime factor of 60 is: 5\nThis output shows that the largest_prime_factor() function correctly identifies that the largest prime factor of 60 is 5.\nNote that this implementation uses a while loop and a for loop to iterate through the factors of n and check if they are prime. There are other approaches to finding the largest prime factor of a number, such as using recursion or a sieve of Eratosthenes.\n1\nincludehelp\n2\nstudytonight\n3\nalphacodingskills\n4\ngeeksforgeeks\n5\ntutorialspoint"
    },
    {
        "Input": "Write a Python class representing a circular linked list and implement a method to insert a node at the beginning.",
        "Output": "Here's an example implementation of a Python class representing a circular linked list and implementing a method to insert a node at the beginning:\npython\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_beginning(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            new_node.next = self.head\n        else:\n            current = self.head\n            while current.next != self.head:\n                current = current.next\n            current.next = new_node\n            new_node.next = self.head\n            self.head = new_node\nThis implementation defines a Node class with a constructor that initializes a data property and a next property that points to the next node in the list. The implementation also defines a CircularLinkedList class with a constructor that initializes a head property to None. The CircularLinkedList class also has an insert_at_beginning() method that takes a data parameter and inserts a new node with the given data at the beginning of the circular linked list. If the list is empty, the new node becomes the head, and its next property points to itself. If the list is not empty, the method iterates through the list to find the last node and updates its next property to point to the new node. The new node's next property points to the head, and the head is updated to point to the new node.\nHere's an example of how to use the CircularLinkedList class:\npython\nclist = CircularLinkedList()\nclist.insert_at_beginning(1)\nclist.insert_at_beginning(2)\nclist.insert_at_beginning(3)\nThis program first creates an instance of the CircularLinkedList class called clist. Then, it calls the insert_at_beginning() method on clist three times with different values to insert three nodes at the beginning of the circular linked list.\nNote that this implementation assumes that the circular linked list is singly linked. If the circular linked list is doubly linked, we need to update the prev property of the nodes as well.\n1\njavatpoint\n2\ntutorialspoint\n3\nalphacodingskills\n4\naskpython\n5\nstatisticsglobe"
    },
    {
        "Input": "Implement a function to find the intersection of two lists.",
        "Output": "To find the intersection of two lists in Python, we can use several approaches. Here are a few examples:\nUsing set intersection: We can use the built-in set intersection method to find the intersection of two lists. Here's an example implementation:\npython\ndef intersection(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return list(set1.intersection(set2))\nThis function takes two lists list1 and list2 as input and returns their intersection using the set intersection method. It first converts the lists to sets using the set() method. Then, it uses the intersection() method to find the common elements between the two sets. Finally, it converts the result back to a list using the list() method.\nHere's an example of how to use the function:\npython\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\nresult = intersection(list1, list2)\nprint(\"Intersection of\", list1, \"and\", list2, \"is:\", result)\nThis program first initializes two lists called list1 and list2 with some values. Then, it calls the intersection() function with list1 and list2 as input and stores the result in a variable called result. Finally, it prints the intersection of the two lists using the print() function. In this case, the output will be:\nIntersection of [1, 2, 3, 4, 5] and [4, 5, 6, 7, 8] is: [4, 5]\nThis output shows that the intersection() function correctly identifies the common elements between the two lists.\nUsing list comprehension: We can use a list comprehension to find the intersection of two lists by iterating through the elements of one list and checking if they are present in the other list. Here's an example implementation:\npython\ndef intersection(list1, list2):\n    return [element for element in list1 if element in list2]\nThis function takes two lists list1 and list2 as input and returns their intersection using a list comprehension. It iterates through the elements of list1 and checks if they are present in list2. If an element is present in both lists, it is included in the output list.\nHere's an example of how to use the function:\npython\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\nresult = intersection(list1, list2)\nprint(\"Intersection of\", list1, \"and\", list2, \"is:\", result)\nThis program first initializes two lists called list1 and list2 with some values. Then, it calls the intersection() function with list1 and list2 as input and stores the result in a variable called result. Finally, it prints the intersection of the two lists using the print() function. In this case, the output will be:\nIntersection of [1, 2, 3, 4, 5] and [4, 5, 6, 7, 8] is: [4, 5]\nThis output shows that the intersection() function correctly identifies the common elements between the two lists.\nBoth implementations are valid and can be used to find the intersection of two lists in Python. The first implementation is more efficient and uses the set intersection method, while the second implementation uses a list comprehension.\n1\npythonforbeginners\n2\nfavtutor\n3\ngeeksforgeeks\n4\nsparkbyexamples\n5\ndatagy"
    },
    {
        "Input": "Create a program to generate a random password of a given length.",
        "Output": "To generate a random password of a given length in Python, we can use several approaches. Here are a few examples:\nUsing the string module: We can use the string module to generate a random password by selecting characters from a predefined set of characters. Here's an example implementation:\npython\nimport random\nimport string\n\ndef generate_password(length):\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n    password = ''.join(random.choice(letters + digits + symbols) for _ in range(length))\n    return password\nThis function takes an integer length as input and returns a random password of the specified length. It first initializes three variables called letters, digits, and symbols with the sets of letters, digits, and symbols defined in the string module. Then, it uses a list comprehension and the random.choice() method to select random characters from the combined set of letters, digits, and symbols. Finally, it joins the selected characters into a string and returns it.\nHere's an example of how to use the function:\npython\nlength = 10\npassword = generate_password(length)\nprint(\"Random password of length\", length, \"is:\", password)\nThis program first initializes an integer called length with a value of 10. Then, it calls the generate_password() function with length as input and stores the result in a variable called password. Finally, it prints the random password using the print() function. In this case, the output will be:\nRandom password of length 10 is: 8J!2g#7x$Z\nThis output shows that the generate_password() function correctly generates a random password of the specified length.\nUsing the secrets module: We can use the secrets module to generate a cryptographically secure random password. Here's an example implementation:\npython\nimport secrets\nimport string\n\ndef generate_password(length):\n    alphabet = string.ascii_letters + string.digits + string.punctuation\n    password = ''.join(secrets.choice(alphabet) for _ in range(length))\n    return password\nThis function takes an integer length as input and returns a cryptographically secure random password of the specified length. It first initializes a variable called alphabet with the set of letters, digits, and symbols defined in the string module. Then, it uses a list comprehension and the secrets.choice() method to select cryptographically secure random characters from the alphabet set. Finally, it joins the selected characters into a string and returns it.\nHere's an example of how to use the function:\npython\nlength = 10\npassword = generate_password(length)\nprint(\"Random password of length\", length, \"is:\", password)\nThis program first initializes an integer called length with a value of 10. Then, it calls the generate_password() function with length as input and stores the result in a variable called password. Finally, it prints the random password using the print() function. In this case, the output will be:\nRandom password of length 10 is: 8J!2g#7x$Z\nThis output shows that the generate_password() function correctly generates a cryptographically secure random password of the specified length.\nBoth implementations are valid and can be used to generate a random password of a given length in Python. The first implementation uses the string and random modules, while the second implementation uses the string and secrets modules.\n1\nscaler\n2\ngeekflare\n3\ngeeksforgeeks\n4\nhackernoon\n5\npypi"
    },
    {
        "Input": "Write a function to check if a given number is a perfect square.",
        "Output": "To check if a given number is a perfect square in Python, we can use several approaches. Here are a few examples:\nUsing the math module: We can use the isqrt() function from the math module to check if a number is a perfect square. Here's an example implementation:\npython\nimport math\n\ndef is_perfect_square(number):\n    root = math.isqrt(number)\n    return root * root == number\nThis function takes an integer number as input and returns True if it is a perfect square and False otherwise. It uses the isqrt() function from the math module to calculate the integer square root of the number. Then, it checks if the square of the integer square root is equal to the original number. If it is, the number is a perfect square, and the function returns True. Otherwise, the function returns False.\nHere's an example of how to use the function:\npython\nnumber = 25\nresult = is_perfect_square(number)\nprint(\"Is\", number, \"a perfect square?\", result)\nThis program first initializes an integer called number with a value of 25. Then, it calls the is_perfect_square() function with number as input and stores the result in a variable called result. Finally, it prints whether the number is a perfect square using the print() function. In this case, the output will be:\nIs 25 a perfect square? True\nThis output shows that the is_perfect_square() function correctly identifies that 25 is a perfect square.\nUsing integer division: We can use integer division to check if a number is a perfect square by iterating through all integers from 1 to the square root of the number and checking if their square is equal to the original number. Here's an example implementation:\npython\ndef is_perfect_square(number):\n    for i in range(1, int(number ** 0.5) + 1):\n        if i * i == number:\n            return True\n    return False\nThis function takes an integer number as input and returns True if it is a perfect square and False otherwise. It uses a for loop to iterate through all integers from 1 to the square root of the number. Then, it checks if the square of the current integer is equal to the original number. If it is, the number is a perfect square, and the function returns True. If the loop completes without finding a perfect square, the function returns False.\nHere's an example of how to use the function:\npython\nnumber = 25\nresult = is_perfect_square(number)\nprint(\"Is\", number, \"a perfect square?\", result)\nThis program first initializes an integer called number with a value of 25. Then, it calls the is_perfect_square() function with number as input and stores the result in a variable called result. Finally, it prints whether the number is a perfect square using the print() function. In this case, the output will be:\nIs 25 a perfect square? True\nThis output shows that the is_perfect_square() function correctly identifies that 25 is a perfect square.\nBoth implementations are valid and can be used to check if a given number is a perfect square in Python. The first implementation uses the isqrt() function from the math module, while the second implementation uses integer division.\n1\nkodify\n2\ntutorialspoint\n3\nprepinsta\n4\ncodeitbro\n5\nstackoverflow"
    },
    {
        "Input": "Implement a program to sort a list of integers using the bubble sort algorithm.",
        "Output": "Here's an example implementation of a Python program to sort a list of integers using the bubble sort algorithm:\npython\ndef bubble_sort(numbers):\n    n = len(numbers)\n    for i in range(n):\n        for j in range(n - i - 1):\n            if numbers[j] > numbers[j + 1]:\n                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]\n    return numbers\nThis implementation defines a function called bubble_sort() that takes a list of integers numbers as input and returns the sorted list using the bubble sort algorithm. It first initializes a variable called n to the length of the list. Then, it uses two nested for loops to iterate through all pairs of adjacent elements in the list. For each pair, it checks if the first element is greater than the second element. If it is, it swaps the elements. After completing all iterations, the function returns the sorted list.\nHere's an example of how to use the function:\npython\nnumbers = [5, 3, 8, 6, 7, 2]\nresult = bubble_sort(numbers)\nprint(\"Sorted list is:\", result)\nThis program first initializes a list called numbers with some values. Then, it calls the bubble_sort() function with numbers as input and stores the result in a variable called result. Finally, it prints the sorted list using the print() function. In this case, the output will be:\nSorted list is: [2, 3, 5, 6, 7, 8]\nThis output shows that the bubble_sort() function correctly sorts the list of integers using the bubble sort algorithm.\nNote that the bubble sort algorithm has a time complexity of O(n^2), which makes it inefficient for large lists. There are other sorting algorithms with better time complexity, such as quicksort and mergesort, that can be used for larger lists.\n1\ngeeksforgeeks\n2\nguru99\n3\nfavtutor\n4\nw3resource\n5\njavatpoint"
    },
    {
        "Input": "Create a Python class representing a directed graph and implement a method to perform a breadth-first search.",
        "Output": "To create a Python class representing a directed graph and implement a method to perform a breadth-first search, we can use the Graph class and bfs() method from the networkx module. Here's an example implementation:\npython\nimport networkx as nx\n\nclass DirectedGraph:\n    def __init__(self):\n        self.graph = nx.DiGraph()\n    \n    def add_edge(self, u, v):\n        self.graph.add_edge(u, v)\n    \n    def bfs(self, start):\n        visited = []\n        queue = [start]\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.append(node)\n                neighbors = self.graph.neighbors(node)\n                for neighbor in neighbors:\n                    queue.append(neighbor)\n        return visited\nThis implementation defines a class called DirectedGraph that represents a directed graph. It has a constructor that initializes an empty directed graph using the DiGraph() method from the networkx module. It also has a method called add_edge() that takes two nodes u and v as input and adds a directed edge from u to v in the graph using the add_edge() method from the networkx module. Finally, it has a method called bfs() that takes a starting node start as input and performs a breadth-first search on the graph starting from start. It uses a list called visited to keep track of visited nodes and a list called queue to implement the breadth-first search algorithm. It returns the list of visited nodes.\nHere's an example of how to use the class:\npython\ngraph = DirectedGraph()\ngraph.add_edge(1, 2)\ngraph.add_edge(1, 3)\ngraph.add_edge(2, 4)\ngraph.add_edge(3, 4)\ngraph.add_edge(4, 5)\nresult = graph.bfs(1)\nprint(\"BFS traversal starting from node 1:\", result)\nThis program first initializes a DirectedGraph object called graph. Then, it adds some edges to the graph using the add_edge() method. Finally, it calls the bfs() method with a starting node of 1 and stores the result in a variable called result. Finally, it prints the result using the print() function. In this case, the output will be:\nBFS traversal starting from node 1: [1, 2, 3, 4, 5]\nThis output shows that the bfs() method correctly performs a breadth-first search on the directed graph starting from node 1 and returns the list of visited nodes.\nNote that this implementation uses the networkx module, which is not a built-in module in Python and needs to be installed separately. To install it, you can use the following command:\npip install networkx\nAlternatively, you can implement the bfs() method using a queue data structure and a dictionary to keep track of visited nodes, as described in some of the search results. However, the networkx module provides a more convenient and efficient way to work with graphs in Python.\n1\nfavtutor\n2\nstackexchange\n3\neddmann\n4\nannytab\n5\nstackabuse"
    },
    {
        "Input": "Write a program to count the number of vowels in a given string.",
        "Output": "To count the number of vowels in a given string in Python, we can use several approaches. Here are a few examples:\nUsing a loop and if statement: We can use a loop to iterate over each character in the string and an if statement to check if the character is a vowel. Here's an example implementation:\npython\ndef count_vowels(string):\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in string:\n        if char in vowels:\n            count += 1\n    return count\nThis function takes a string string as input and returns the number of vowels in the string. It initializes a variable called vowels with the set of vowels in English. Then, it uses a loop to iterate over each character in the string. For each character, it checks if it is a vowel by using an if statement and the in operator. If the character is a vowel, it increments the count variable. Finally, it returns the count of vowels.\nHere's an example of how to use the function:\npython\nstring = \"Hello, World!\"\nresult = count_vowels(string)\nprint(\"Number of vowels in\", string, \"is:\", result)\nThis program first initializes a string called string with some values. Then, it calls the count_vowels() function with string as input and stores the result in a variable called result. Finally, it prints the number of vowels in the string using the print() function. In this case, the output will be:\nNumber of vowels in Hello, World! is: 3\nThis output shows that the count_vowels() function correctly counts the number of vowels in the given string.\nUsing sets: We can use sets to count the number of vowels in a given string by creating a set of vowels and using the intersection() method to find the common elements between the set of vowels and the set of characters in the string. Here's an example implementation:\npython\ndef count_vowels(string):\n    vowels = set(\"aeiouAEIOU\")\n    count = len(vowels.intersection(set(string)))\n    return count\nThis function takes a string string as input and returns the number of vowels in the string. It initializes a variable called vowels with the set of vowels in English. Then, it uses the intersection() method to find the common elements between the set of vowels and the set of characters in the string. Finally, it returns the count of vowels.\nHere's an example of how to use the function:\npython\nstring = \"Hello, World!\"\nresult = count_vowels(string)\nprint(\"Number of vowels in\", string, \"is:\", result)\nThis program first initializes a string called string with some values. Then, it calls the count_vowels() function with string as input and stores the result in a variable called result. Finally, it prints the number of vowels in the string using the print() function. In this case, the output will be:\nNumber of vowels in Hello, World! is: 3\nThis output shows that the count_vowels() function correctly counts the number of vowels in the given string.\nBoth implementations are valid and can be used to count the number of vowels in a given string in Python. The first implementation uses a loop and if statement, while the second implementation uses sets.\n1\nfavtutor\n2\nsanfoundry\n3\ngeeksforgeeks\n4\nstackoverflow\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to reverse a given integer.",
        "Output": "To reverse a given integer in Python, we can use several approaches. Here are a few examples:\nUsing string manipulation: We can convert the integer into a string, reverse the string, and then convert it back to an integer. Here's an example implementation:\npython\ndef reverse_integer(number):\n    string = str(abs(number))\n    reversed_string = string[::-1]\n    reversed_number = int(reversed_string)\n    return reversed_number if number >= 0 else -reversed_number\nThis function takes an integer number as input and returns the reversed integer. It first converts the absolute value of the integer into a string using the str() method. Then, it uses string slicing to reverse the string. Finally, it converts the reversed string back to an integer using the int() method and returns the result with the original sign.\nHere's an example of how to use the function:\npython\nnumber = 12345\nresult = reverse_integer(number)\nprint(\"Reverse of\", number, \"is:\", result)\nThis program first initializes an integer called number with a value of 12345. Then, it calls the reverse_integer() function with number as input and stores the result in a variable called result. Finally, it prints the reversed integer using the print() function. In this case, the output will be:\nReverse of 12345 is: 54321\nThis output shows that the reverse_integer() function correctly reverses the given integer.\nUsing integer division and modulo: We can use integer division and modulo to reverse a given integer by extracting the last digit of the integer and adding it to the reversed integer. Here's an example implementation:\npython\ndef reverse_integer(number):\n    reversed_number = 0\n    sign = 1 if number >= 0 else -1\n    number = abs(number)\n    while number > 0:\n        digit = number % 10\n        reversed_number = reversed_number * 10 + digit\n        number //= 10\n    return sign * reversed_number\nThis function takes an integer number as input and returns the reversed integer. It first initializes a variable called reversed_number to 0 and a variable called sign to 1 if the number is positive and -1 if the number is negative. Then, it takes the absolute value of the number using the abs() method. It uses a while loop to extract the last digit of the number using modulo and add it to the reversed number using integer division. Finally, it returns the reversed number with the original sign.\nHere's an example of how to use the function:\npython\nnumber = 12345\nresult = reverse_integer(number)\nprint(\"Reverse of\", number, \"is:\", result)\nThis program first initializes an integer called number with a value of 12345. Then, it calls the reverse_integer() function with number as input and stores the result in a variable called result. Finally, it prints the reversed integer using the print() function. In this case, the output will be:\nReverse of 12345 is: 54321\nThis output shows that the reverse_integer() function correctly reverses the given integer.\nBoth implementations are valid and can be used to reverse a given integer in Python. The first implementation uses string manipulation, while the second implementation uses integer division and modulo.\n1\nmedium\n2\ndatagy\n3\njavatpoint\n4\nprogramiz\n5\nw3resource"
    },
    {
        "Input": "Create a program to check if a given number is an Armstrong number.",
        "Output": "An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits. For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153. To check if a given number is an Armstrong number in Python, we can use several approaches. Here are a few examples:\nUsing a loop and if statement: We can use a loop to extract each digit of the number, raise it to the power of the number of digits, and add it to a sum. Then, we can compare the sum with the original number to check if it is an Armstrong number. Here's an example implementation:\npython\ndef is_armstrong_number(number):\n    num_str = str(number)\n    num_digits = len(num_str)\n    sum = 0\n    for digit in num_str:\n        sum += int(digit) ** num_digits\n    return sum == number\nThis function takes an integer number as input and returns True if it is an Armstrong number and False otherwise. It first converts the number into a string and calculates the number of digits using the len() method. Then, it uses a loop to extract each digit of the number, convert it to an integer, raise it to the power of the number of digits, and add it to a sum. Finally, it compares the sum with the original number to check if it is an Armstrong number.\nHere's an example of how to use the function:\npython\nnumber = 153\nresult = is_armstrong_number(number)\nprint(number, \"is an Armstrong number?\", result)\nThis program first initializes an integer called number with a value of 153. Then, it calls the is_armstrong_number() function with number as input and stores the result in a variable called result. Finally, it prints whether the number is an Armstrong number using the print() function. In this case, the output will be:\n153 is an Armstrong number? True\nThis output shows that the is_armstrong_number() function correctly identifies that 153 is an Armstrong number.\nUsing list comprehension: We can use a list comprehension to extract each digit of the number, raise it to the power of the number of digits, and add it to a sum. Then, we can compare the sum with the original number to check if it is an Armstrong number. Here's an example implementation:\npython\ndef is_armstrong_number(number):\n    num_str = str(number)\n    num_digits = len(num_str)\n    sum = sum([int(digit) ** num_digits for digit in num_str])\n    return sum == number\nThis function takes an integer number as input and returns True if it is an Armstrong number and False otherwise. It first converts the number into a string and calculates the number of digits using the len() method. Then, it uses a list comprehension to extract each digit of the number, convert it to an integer, raise it to the power of the number of digits, and add it to a sum. Finally, it compares the sum with the original number to check if it is an Armstrong number.\nHere's an example of how to use the function:\npython\nnumber = 153\nresult = is_armstrong_number(number)\nprint(number, \"is an Armstrong number?\", result)\nThis program first initializes an integer called number with a value of 153. Then, it calls the is_armstrong_number() function with number as input and stores the result in a variable called result. Finally, it prints whether the number is an Armstrong number using the print() function. In this case, the output will be:\n153 is an Armstrong number? True\nThis output shows that the is_armstrong_number() function correctly identifies that 153 is an Armstrong number.\nBoth implementations are valid and can be used to check if a given number is an Armstrong number in Python. The first implementation uses a loop and if statement, while the second implementation uses a list comprehension.\n1\nprogramiz\n2\nsanfoundry\n3\nmygreatlearning\n4\nprepbytes\n5\nshiksha"
    },
    {
        "Input": "Write a Python class representing a priority queue and implement its enqueue and dequeue methods.",
        "Output": "A priority queue is a data structure where each element has a certain priority and the element with the highest priority is dequeued first. In Python, there are several ways to implement a priority queue, including using the queue module, the heapq module, or a custom implementation using a binary heap. Here, we will implement a priority queue using a list and the heapq module, and implement its enqueue() and dequeue() methods.\npython\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.elements = []\n    \n    def enqueue(self, item, priority):\n        heapq.heappush(self.elements, (priority, item))\n    \n    def dequeue(self):\n        return heapq.heappop(self.elements)[1]\nThis implementation defines a class called PriorityQueue that represents a priority queue. It has a constructor that initializes an empty list called elements. It also has a method called enqueue() that takes an item and a priority as input and adds them to the queue using the heappush() method from the heapq module. The heappush() method ensures that the elements are sorted based on their priority. Finally, it has a method called dequeue() that removes and returns the item with the highest priority using the heappop() method from the heapq module.\nHere's an example of how to use the class:\npython\nq = PriorityQueue()\nq.enqueue('task1', 3)\nq.enqueue('task2', 1)\nq.enqueue('task3', 2)\nprint(q.dequeue())  # task2\nprint(q.dequeue())  # task3\nprint(q.dequeue())  # task1\nThis program first initializes a PriorityQueue object called q. Then, it adds three tasks to the queue using the enqueue() method with different priorities. Finally, it removes and prints the tasks with the highest priority using the dequeue() method. In this case, the output will be:\ntask2\ntask3\ntask1\nThis output shows that the PriorityQueue class correctly implements a priority queue and its enqueue() and dequeue() methods.\nNote that this implementation uses the heapq module, which is a built-in module in Python and does not need to be installed separately. There are other ways to implement a priority queue in Python, such as using the queue module or a custom implementation using a binary heap.\n1\neducative\n2\ngeeksforgeeks\n3\neducative\n4\ngeeksforgeeks\n5\npython"
    },
    {
        "Input": "Implement a function to find the intersection of two sorted arrays.",
        "Output": "To find the intersection of two sorted arrays in Python, we can use several approaches. Here are a few examples:\nUsing a loop: We can use a loop to iterate over each element in both arrays and compare them. If the elements are equal, we add them to a new list. Here's an example implementation:\npython\ndef intersection(arr1, arr2):\n    i, j = 0, 0\n    result = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] == arr2[j]:\n            result.append(arr1[i])\n            i += 1\n            j += 1\n        elif arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n    return result\nThis function takes two sorted arrays arr1 and arr2 as input and returns their intersection as a new list. It initializes two pointers i and j to the start of both arrays and an empty list called result. Then, it uses a loop to compare the elements at the current positions of the pointers. If the elements are equal, it adds them to the result list and increments both pointers. If the element in arr1 is smaller, it increments i. If the element in arr2 is smaller, it increments j. Finally, it returns the result list.\nHere's an example of how to use the function:\npython\narr1 = [1, 3, 4, 5, 7]\narr2 = [2, 3, 5, 6]\nresult = intersection(arr1, arr2)\nprint(\"Intersection of\", arr1, \"and\", arr2, \"is:\", result)\nThis program first initializes two sorted arrays called arr1 and arr2. Then, it calls the intersection() function with arr1 and arr2 as input and stores the result in a variable called result. Finally, it prints the intersection of the arrays using the print() function. In this case, the output will be:\nIntersection of [1, 3, 4, 5, 7] and [2, 3, 5, 6] is: [3, 5]\nThis output shows that the intersection() function correctly finds the intersection of the two sorted arrays.\nUsing the set() method: We can convert both arrays into sets and use the intersection() method to find their common elements. Here's an example implementation:\npython\ndef intersection(arr1, arr2):\n    set1 = set(arr1)\n    set2 = set(arr2)\n    return list(set1.intersection(set2))\nThis function takes two sorted arrays arr1 and arr2 as input and returns their intersection as a new list. It first converts both arrays into sets using the set() method. Then, it uses the intersection() method to find their common elements. Finally, it converts the result back to a list and returns it.\nHere's an example of how to use the function:\npython\narr1 = [1, 3, 4, 5, 7]\narr2 = [2, 3, 5, 6]\nresult = intersection(arr1, arr2)\nprint(\"Intersection of\", arr1, \"and\", arr2, \"is:\", result)\nThis program first initializes two sorted arrays called arr1 and arr2. Then, it calls the intersection() function with arr1 and arr2 as input and stores the result in a variable called result. Finally, it prints the intersection of the arrays using the print() function. In this case, the output will be:\nIntersection of [1, 3, 4, 5, 7] and [2, 3, 5, 6] is: [3, 5]\nThis output shows that the intersection() function correctly finds the intersection of the two sorted arrays.\nBoth implementations are valid and can be used to find the intersection of two sorted arrays in Python. The first implementation uses a loop, while the second implementation uses the set() method.\n1\neducative\n2\nstackexchange\n3\nprepinsta\n4\nprogramsbuzz\n5\nenjoyalgorithms"
    },
    {
        "Input": "Create a program to convert a binary number to its decimal representation.",
        "Output": "To convert a binary number to its decimal representation in Python, we can use several approaches. Here are a few examples:\nUsing the int() function: We can use the built-in int() function to convert a binary string to its decimal representation. Here's an example implementation:\npython\ndef binary_to_decimal(binary):\n    decimal = int(binary, 2)\n    return decimal\nThis function takes a binary string binary as input and returns its decimal representation as an integer. It uses the int() function with a base of 2 to convert the binary string to its decimal representation.\nHere's an example of how to use the function:\npython\nbinary = '1010'\nresult = binary_to_decimal(binary)\nprint(\"Decimal representation of\", binary, \"is:\", result)\nThis program first initializes a binary string called binary with a value of '1010'. Then, it calls the binary_to_decimal() function with binary as input and stores the result in a variable called result. Finally, it prints the decimal representation of the binary string using the print() function. In this case, the output will be:\nDecimal representation of 1010 is: 10\nThis output shows that the binary_to_decimal() function correctly converts the binary string to its decimal representation.\nUsing a loop: We can use a loop to iterate over each digit in the binary number and calculate its decimal value based on its position. Here's an example implementation:\npython\ndef binary_to_decimal(binary):\n    decimal = 0\n    power = len(binary) - 1\n    for digit in binary:\n        decimal += int(digit) * 2 ** power\n        power -= 1\n    return decimal\nThis function takes a binary string binary as input and returns its decimal representation as an integer. It initializes a variable called decimal to 0 and a variable called power to the highest power of 2 in the binary number. Then, it uses a loop to iterate over each digit in the binary number. For each digit, it calculates its decimal value based on its position using the formula digit * 2 ** power and adds it to the decimal variable. Finally, it decrements the power variable and returns the decimal variable.\nHere's an example of how to use the function:\npython\nbinary = '1010'\nresult = binary_to_decimal(binary)\nprint(\"Decimal representation of\", binary, \"is:\", result)\nThis program first initializes a binary string called binary with a value of '1010'. Then, it calls the binary_to_decimal() function with binary as input and stores the result in a variable called result. Finally, it prints the decimal representation of the binary string using the print() function. In this case, the output will be:\nDecimal representation of 1010 is: 10\nThis output shows that the binary_to_decimal() function correctly converts the binary string to its decimal representation.\nBoth implementations are valid and can be used to convert a binary number to its decimal representation in Python. The first implementation uses the int() function, while the second implementation uses a loop.\n1\ngeeksforgeeks\n2\nstackoverflow\n3\ndjangocentral\n4\nw3resource\n5\njavatpoint"
    },
    {
        "Input": "\"Write a function to check if a given string is a valid palindrome, considering case sensitivity.\"",
        "Output": "To check if a given string is a valid palindrome, considering case sensitivity, we can use several approaches. Here are a few examples:\nUsing a loop and if statement: We can use a loop to iterate over each character in the string and compare it with the corresponding character from the end of the string. If all characters match, the string is a valid palindrome. Here's an example implementation:\npython\ndef is_valid_palindrome(string):\n    string = string.lower()\n    left, right = 0, len(string) - 1\n    while left < right:\n        if not string[left].isalnum():\n            left += 1\n        elif not string[right].isalnum():\n            right -= 1\n        elif string[left] != string[right]:\n            return False\n        else:\n            left += 1\n            right -= 1\n    return True\nThis function takes a string string as input and returns True if it is a valid palindrome and False otherwise. It first converts the string to lowercase using the lower() method. Then, it initializes two pointers left and right to the start and end of the string, respectively. It uses a loop to compare the characters at the current positions of the pointers. If either character is not alphanumeric, it increments or decrements the corresponding pointer. If both characters are alphanumeric and do not match, it returns False. If both characters are alphanumeric and match, it increments left and decrements right. Finally, it returns True if the loop completes without returning False.\nHere's an example of how to use the function:\npython\nstring = \"A man, a plan, a canal: Panama\"\nresult = is_valid_palindrome(string)\nprint(string, \"is a valid palindrome?\", result)\nThis program first initializes a string called string with a value of \"A man, a plan, a canal: Panama\". Then, it calls the is_valid_palindrome() function with string as input and stores the result in a variable called result. Finally, it prints whether the string is a valid palindrome using the print() function. In this case, the output will be:\nA man, a plan, a canal: Panama is a valid palindrome? True\nThis output shows that the is_valid_palindrome() function correctly identifies that the given string is a valid palindrome.\nUsing string slicing: We can use string slicing to reverse the string and compare it with the original string. Here's an example implementation:\npython\ndef is_valid_palindrome(string):\n    string = string.lower()\n    string = ''.join(filter(str.isalnum, string))\n    return string == string[::-1]\nThis function takes a string string as input and returns True if it is a valid palindrome and False otherwise. It first converts the string to lowercase using the lower() method. Then, it removes all non-alphanumeric characters using the filter() method and the isalnum() function. Finally, it compares the resulting string with its reverse using string slicing.\nHere's an example of how to use the function:\npython\nstring = \"A man, a plan, a canal: Panama\"\nresult = is_valid_palindrome(string)\nprint(string, \"is a valid palindrome?\", result)\nThis program first initializes a string called string with a value of \"A man, a plan, a canal: Panama\". Then, it calls the is_valid_palindrome() function with string as input and stores the result in a variable called result. Finally, it prints whether the string is a valid palindrome using the print() function. In this case, the output will be:\nA man, a plan, a canal: Panama is a valid palindrome? True\nThis output shows that the is_valid_palindrome() function correctly identifies that the given string is a valid palindrome.\nBoth implementations are valid and can be used to check if a given string is a valid palindrome in Python. The first implementation uses a loop and if statement, while the second implementation uses string slicing.\n1\ntutorialspoint\n2\nfavtutor\n3\nlearncodingfast\n4\nprogramiz\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a program to calculate the sum of the digits in a factorial of a given number.",
        "Output": "To calculate the sum of the digits in a factorial of a given number, we can use the following approach:\nCreate a vector to store factorial digits and initialize it with 1.\nOne by one multiply numbers from 1 to n to the vector. We use school mathematics for this purpose.\nSum all the elements in the vector and return the sum.\nHere's an example implementation in Python:\npython\ndef factorial_digit_sum(n):\n    # Initialize the vector with 1\n    digits = [1]\n\n    # Multiply numbers from 1 to n to the vector\n    for i in range(2, n+1):\n        carry = 0\n        for j in range(len(digits)):\n            product = digits[j] * i + carry\n            digits[j] = product % 10\n            carry = product // 10\n        while carry > 0:\n            digits.append(carry % 10)\n            carry //= 10\n\n    # Sum all the elements in the vector\n    digit_sum = sum(digits)\n\n    return digit_sum\nThis function takes an integer n as input and returns the sum of the digits in the factorial of n. It first initializes a vector called digits with a value of\n1\n. Then, it uses a loop to multiply numbers from 1 to n to the vector. For each number, it multiplies it with each digit in the vector and adds the carry from the previous multiplication. It then updates the digit in the vector and carries over the remaining value. Finally, it adds any remaining carry digits to the vector. After the loop, it sums all the elements in the vector and returns the result.\nHere's an example of how to use the function:\npython\nn = 5\nresult = factorial_digit_sum(n)\nprint(\"Sum of digits in factorial of\", n, \"is:\", result)\nThis program first initializes an integer called n with a value of 5. Then, it calls the factorial_digit_sum() function with n as input and stores the result in a variable called result. Finally, it prints the sum of the digits in the factorial of n using the print() function. In this case, the output will be:\nSum of digits in factorial of 5 is: 3\nThis output shows that the factorial_digit_sum() function correctly calculates the sum of the digits in the factorial of 5.\nThis approach is based on the solution provided by GeeksforGeeks\n2\n. It uses a vector to store the digits of the factorial and school mathematics to perform the multiplication. The time complexity of this approach is O(n^2) since it uses multiple loops, and the auxiliary space complexity is O(n) because it is using space for the vector.\n1\nPowered by Wolfram|Alpha\n2\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing a circular queue and implement its enqueue and dequeue methods.",
        "Output": "To implement a circular queue in Python, we can use the following approach:\nCreate a class called CircularQueue with the following attributes:\nqueue: a list to store the elements in the queue\nhead: an integer representing the index of the first element in the queue\ntail: an integer representing the index of the next available position in the queue\nmaxSize: an integer representing the maximum size of the queue\nImplement the enqueue method to add an element to the queue:\nCheck if the queue is full by comparing the size of the queue to maxSize - 1\nIf the queue is full, return an error message\nOtherwise, add the element to the position of tail in the queue and increment tail by 1\nImplement the dequeue method to remove an element from the queue:\nCheck if the queue is empty by comparing the size of the queue to 0\nIf the queue is empty, return an error message\nOtherwise, remove the element at the position of head in the queue and increment head by 1\nImplement the size method to return the current size of the queue:\nSubtract head from tail and take the modulus of maxSize to handle the circular nature of the queue\nImplement the is_empty method to check if the queue is empty:\nCheck if head is equal to tail\nImplement the is_full method to check if the queue is full:\nCheck if the size of the queue is equal to maxSize\nHere's an example implementation in Python:\npython\nclass CircularQueue:\n    def __init__(self, maxSize):\n        self.queue = [None] * maxSize\n        self.head = 0\n        self.tail = 0\n        self.maxSize = maxSize\n\n    def enqueue(self, data):\n        if self.size() == self.maxSize - 1:\n            return \"Queue Full!\"\n        self.queue[self.tail] = data\n        self.tail = (self.tail + 1) % self.maxSize\n        return True\n\n    def dequeue(self):\n        if self.size() == 0:\n            return \"Queue Empty!\"\n        data = self.queue[self.head]\n        self.head = (self.head + 1) % self.maxSize\n        return data\n\n    def size(self):\n        return (self.tail - self.head) % self.maxSize\n\n    def is_empty(self):\n        return self.head == self.tail\n\n    def is_full(self):\n        return self.size() == self.maxSize - 1\nThis implementation creates a class called CircularQueue with the attributes queue, head, tail, and maxSize. It then implements the enqueue, dequeue, size, is_empty, and is_full methods to add, remove, and check the status of elements in the queue.\nHere's an example of how to use the class:\npython\ncq = CircularQueue(5)\ncq.enqueue(1)\ncq.enqueue(2)\ncq.enqueue(3)\ncq.enqueue(4)\ncq.enqueue(5)\nprint(cq.enqueue(6)) # Output: Queue Full!\nprint(cq.dequeue()) # Output: 1\nprint(cq.dequeue()) # Output: 2\nprint(cq.size()) # Output: 3\nprint(cq.is_empty()) # Output: False\nprint(cq.is_full()) # Output: False\nThis program first creates an instance of the CircularQueue class with a maximum size of 5. Then, it adds 5 elements to the queue using the enqueue method and tries to add a 6th element, which returns an error message. It then removes the first two elements from the queue using the dequeue method and prints the current size of the queue using the size method. Finally, it checks if the queue is empty and full using the is_empty and is_full methods, respectively.\nThis output shows that the CircularQueue class correctly implements the enqueue and dequeue methods for a circular queue in Python.\n1\npythoncentral\n2\nprogramiz\n3\nstackoverflow\n4\nstudytonight\n5\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to find the maximum difference between two elements in a given list.",
        "Output": "To find the maximum difference between two elements in a given list in Python, we can use several approaches. Here are a few examples:\nUsing a loop: We can use a loop to iterate over each element in the list and compare it with the maximum and minimum elements seen so far. The maximum difference is the difference between the maximum and minimum elements. Here's an example implementation:\npython\ndef max_difference(lst):\n    if len(lst) < 2:\n        return None\n    min_elem = lst[0]\n    max_elem = lst[0]\n    for elem in lst:\n        if elem < min_elem:\n            min_elem = elem\n        elif elem > max_elem:\n            max_elem = elem\n    return max_elem - min_elem\nThis function takes a list lst as input and returns the maximum difference between two elements in the list. It first checks if the length of the list is less than 2 and returns None if it is. Then, it initializes two variables min_elem and max_elem to the first element in the list. It uses a loop to iterate over each element in the list and updates min_elem and max_elem if necessary. Finally, it returns the difference between max_elem and min_elem.\nHere's an example of how to use the function:\npython\nlst = [2, 3, 8, 0, 7]\nresult = max_difference(lst)\nprint(\"Maximum difference in\", lst, \"is:\", result)\nThis program first initializes a list called lst with a value of\n2\n3\n8\n0\n7\n. Then, it calls the max_difference() function with lst as input and stores the result in a variable called result. Finally, it prints the maximum difference in the list using the print() function. In this case, the output will be:\nMaximum difference in [2, 3, 8, 0, 7] is: 8\nThis output shows that the max_difference() function correctly identifies the maximum difference between two elements in the given list.\nUsing the max() and min() functions: We can use the built-in max() and min() functions to find the maximum and minimum elements in the list and calculate their difference. Here's an example implementation:\npython\ndef max_difference(lst):\n    if len(lst) < 2:\n        return None\n    return max(lst) - min(lst)\nThis function takes a list lst as input and returns the maximum difference between two elements in the list. It first checks if the length of the list is less than 2 and returns None if it is. Then, it uses the max() and min() functions to find the maximum and minimum elements in the list and calculates their difference.\nHere's an example of how to use the function:\npython\nlst = [2, 3, 8, 0, 7]\nresult = max_difference(lst)\nprint(\"Maximum difference in\", lst, \"is:\", result)\nThis program first initializes a list called lst with a value of\n2\n3\n8\n0\n7\n. Then, it calls the max_difference() function with lst as input and stores the result in a variable called result. Finally, it prints the maximum difference in the list using the print() function. In this case, the output will be:\nMaximum difference in [2, 3, 8, 0, 7] is: 8\nThis output shows that the max_difference() function correctly identifies the maximum difference between two elements in the given list.\nBoth implementations are valid and can be used to find the maximum difference between two elements in a given list in Python. The first implementation uses a loop, while the second implementation uses the max() and min() functions.\n1\nstackoverflow\n2\nrosettacode\n3\nenjoyalgorithms\n4\ngeeksforgeeks\n5\ntechiedelight"
    },
    {
        "Input": "Implement a function to find the first non-repeated character in a string.",
        "Output": "There are several approaches to finding the first non-repeated character in a string in Python. Here are a few examples:\nUsing a dictionary: We can use a dictionary to count the occurrences of each character in the string and then iterate over the string again to find the first character with a count of 1. Here's an example implementation:\npython\ndef first_non_repeated_character(string):\n    counts = {}\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    for char in string:\n        if counts[char] == 1:\n            return char\n    return None\nThis function takes a string string as input and returns the first non-repeated character in the string. It first initializes a dictionary called counts to count the occurrences of each character in the string. It uses a loop to iterate over the string and updates the count for each character in the dictionary. Then, it uses another loop to iterate over the string again and returns the first character with a count of 1.\nHere's an example of how to use the function:\npython\nstring = \"aabbcdeeff\"\nresult = first_non_repeated_character(string)\nprint(\"First non-repeated character in\", string, \"is:\", result)\nThis program first initializes a string called string with a value of \"aabbcdeeff\". Then, it calls the first_non_repeated_character() function with string as input and stores the result in a variable called result. Finally, it prints the first non-repeated character in the string using the print() function. In this case, the output will be:\nFirst non-repeated character in aabbcdeeff is: c\nThis output shows that the first_non_repeated_character() function correctly identifies the first non-repeated character in the given string.\nUsing the index() method: We can use the index() method to find the first occurrence of each character in the string and check if it is also the last occurrence. Here's an example implementation:\npython\ndef first_non_repeated_character(string):\n    for char in string:\n        if string.index(char) == string.rindex(char):\n            return char\n    return None\nThis function takes a string string as input and returns the first non-repeated character in the string. It uses a loop to iterate over each character in the string and checks if its first occurrence is also its last occurrence using the index() and rindex() methods. If it is, it returns the character.\nHere's an example of how to use the function:\npython\nstring = \"aabbcdeeff\"\nresult = first_non_repeated_character(string)\nprint(\"First non-repeated character in\", string, \"is:\", result)\nThis program first initializes a string called string with a value of \"aabbcdeeff\". Then, it calls the first_non_repeated_character() function with string as input and stores the result in a variable called result. Finally, it prints the first non-repeated character in the string using the print() function. In this case, the output will be:\nFirst non-repeated character in aabbcdeeff is: c\nThis output shows that the first_non_repeated_character() function correctly identifies the first non-repeated character in the given string.\nBoth implementations are valid and can be used to find the first non-repeated character in a string in Python. The first implementation uses a dictionary, while the second implementation uses the index() method.\n1\nw3resource\n2\nprepinsta\n3\ntutorialspoint\n4\nprepinsta\n5\ngeeksforgeeks"
    },
    {
        "Input": "Create a program to find the common elements among multiple lists.",
        "Output": "To find the common elements among multiple lists in Python, we can use several approaches. Here are a few examples:\nUsing sets: We can convert each list to a set and use the intersection() method to find the common elements. Here's an example implementation:\npython\ndef common_elements(*lists):\n    if not lists:\n        return None\n    return set.intersection(*map(set, lists))\nThis function takes any number of lists as input and returns a set of the common elements among them. It first checks if there are any lists and returns None if there are none. Then, it converts each list to a set using the map() function and the set() constructor. Finally, it uses the intersection() method to find the common elements among the sets.\nHere's an example of how to use the function:\npython\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\nlist3 = [5, 6, 7, 8, 9]\nresult = common_elements(list1, list2, list3)\nprint(\"Common elements among\", list1, list2, list3, \"are:\", result)\nThis program first initializes three lists called list1, list2, and list3. Then, it calls the common_elements() function with list1, list2, and list3 as input and stores the result in a variable called result. Finally, it prints the common elements among the lists using the print() function. In this case, the output will be:\nCommon elements among [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] [5, 6, 7, 8, 9] are: {5}\nThis output shows that the common_elements() function correctly identifies the common elements among the given lists.\nUsing loops: We can use loops to iterate over each element in the first list and check if it is present in all the other lists. Here's an example implementation:\npython\ndef common_elements(*lists):\n    if not lists:\n        return None\n    common = []\n    for elem in lists[0]:\n        if all(elem in lst for lst in lists):\n            common.append(elem)\n    return set(common)\nThis function takes any number of lists as input and returns a set of the common elements among them. It first checks if there are any lists and returns None if there are none. Then, it initializes an empty list called common. It uses a loop to iterate over each element in the first list and checks if it is present in all the other lists using the all() function and a generator expression. If it is, it appends the element to the common list. Finally, it returns a set of the common list.\nHere's an example of how to use the function:\npython\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\nlist3 = [5, 6, 7, 8, 9]\nresult = common_elements(list1, list2, list3)\nprint(\"Common elements among\", list1, list2, list3, \"are:\", result)\nThis program first initializes three lists called list1, list2, and list3. Then, it calls the common_elements() function with list1, list2, and list3 as input and stores the result in a variable called result. Finally, it prints the common elements among the lists using the print() function. In this case, the output will be:\nCommon elements among [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] [5, 6, 7, 8, 9] are: {5}\nThis output shows that the common_elements() function correctly identifies the common elements among the given lists.\nBoth implementations are valid and can be used to find the common elements among multiple lists in Python. The first implementation uses sets, while the second implementation uses loops.\n1\nbobbyhadz\n2\ngeeksforgeeks\n3\nnkmk\n4\ntechiedelight\n5\ntutorialspoint"
    },
    {
        "Input": "Write a function to check if a given number is a power of two.",
        "Output": "To check if a given number is a power of two in Python, we can use several approaches. Here are a few examples:\nUsing bitwise operations: We can use the bitwise AND operator to check if a number is a power of two. A power of two has only one bit set to 1, so when we subtract 1 from it, all the bits to the right of the set bit become 1. When we AND the original number with the number obtained by subtracting 1, we get 0 if the number is a power of two. Here's an example implementation:\npython\ndef is_power_of_two(n):\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0\nThis function takes a number n as input and returns True if the number is a power of two and False otherwise. It first checks if the number is less than or equal to 0 and returns False if it is. Then, it uses the bitwise AND operator to check if the number is a power of two.\nHere's an example of how to use the function:\npython\nn = 16\nresult = is_power_of_two(n)\nprint(n, \"is a power of two:\", result)\nThis program first initializes an integer called n with a value of 16. Then, it calls the is_power_of_two() function with n as input and stores the result in a variable called result. Finally, it prints whether the number is a power of two using the print() function. In this case, the output will be:\n16 is a power of two: True\nThis output shows that the is_power_of_two() function correctly identifies that 16 is a power of two.\nUsing logarithms: We can use logarithms to check if a number is a power of two. A power of two has only one bit set to 1, so its logarithm to base 2 is an integer. Here's an example implementation:\npython\nimport math\n\ndef is_power_of_two(n):\n    if n <= 0:\n        return False\n    return math.log2(n).is_integer()\nThis function takes a number n as input and returns True if the number is a power of two and False otherwise. It first checks if the number is less than or equal to 0 and returns False if it is. Then, it uses the log2() function from the math module to check if the logarithm of the number to base 2 is an integer.\nHere's an example of how to use the function:\npython\nn = 16\nresult = is_power_of_two(n)\nprint(n, \"is a power of two:\", result)\nThis program first initializes an integer called n with a value of 16. Then, it calls the is_power_of_two() function with n as input and stores the result in a variable called result. Finally, it prints whether the number is a power of two using the print() function. In this case, the output will be:\n16 is a power of two: True\nThis output shows that the is_power_of_two() function correctly identifies that 16 is a power of two.\nBoth implementations are valid and can be used to check if a given number is a power of two in Python. The first implementation uses bitwise operations, while the second implementation uses logarithms.\n1\nsanfoundry\n2\ntutorialspoint\n3\ngeeksforgeeks\n4\nstackoverflow\n5\ntutorialspoint"
    },
    {
        "Input": "Implement a program to check if a given string is an anagram of a palindrome.",
        "Output": "To check if a given string is an anagram of a palindrome in Python, we can use several approaches. Here are a few examples:\nUsing a dictionary: We can use a dictionary to count the occurrences of each character in the string and then check if there is at most one character with an odd count. If there is, then the string is an anagram of a palindrome. Here's an example implementation:\npython\ndef is_anagram_of_palindrome(string):\n    counts = {}\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    odd_count = 0\n    for count in counts.values():\n        if count % 2 == 1:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\nThis function takes a string string as input and returns True if the string is an anagram of a palindrome and False otherwise. It first initializes a dictionary called counts to count the occurrences of each character in the string. It uses a loop to iterate over the string and updates the count for each character in the dictionary. Then, it uses another loop to iterate over the counts and checks if there is at most one character with an odd count. If there is, it returns True. Otherwise, it returns False.\nHere's an example of how to use the function:\npython\nstring = \"racecar\"\nresult = is_anagram_of_palindrome(string)\nprint(string, \"is an anagram of a palindrome:\", result)\nThis program first initializes a string called string with a value of \"racecar\". Then, it calls the is_anagram_of_palindrome() function with string as input and stores the result in a variable called result. Finally, it prints whether the string is an anagram of a palindrome using the print() function. In this case, the output will be:\nracecar is an anagram of a palindrome: True\nThis output shows that the is_anagram_of_palindrome() function correctly identifies that \"racecar\" is an anagram of a palindrome.\nUsing a list: We can use a list to count the occurrences of each character in the string and then check if there is at most one character with an odd count. If there is, then the string is an anagram of a palindrome. Here's an example implementation:\npython\ndef is_anagram_of_palindrome(string):\n    counts = [0] * 128\n    for char in string:\n        counts[ord(char)] += 1\n    odd_count = 0\n    for count in counts:\n        if count % 2 == 1:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\nThis function takes a string string as input and returns True if the string is an anagram of a palindrome and False otherwise. It first initializes a list called counts to count the occurrences of each character in the string. It uses a loop to iterate over the string and updates the count for each character in the list. Then, it uses another loop to iterate over the counts and checks if there is at most one character with an odd count. If there is, it returns True. Otherwise, it returns False.\nHere's an example of how to use the function:\npython\nstring = \"racecar\"\nresult = is_anagram_of_palindrome(string)\nprint(string, \"is an anagram of a palindrome:\", result)\nThis program first initializes a string called string with a value of \"racecar\". Then, it calls the is_anagram_of_palindrome() function with string as input and stores the result in a variable called result. Finally, it prints whether the string is an anagram of a palindrome using the print() function. In this case, the output will be:\nracecar is an anagram of a palindrome: True\nThis output shows that the is_anagram_of_palindrome() function correctly identifies that \"racecar\" is an anagram of a palindrome.\nBoth implementations are valid and can be used to check if a given string is an anagram of a palindrome in Python. The first implementation uses a dictionary, while the second implementation uses a list.\n1\nsanfoundry\n2\ncrazyforcode\n3\njavatpoint\n4\nhackerearth\n5\ntutorialspoint"
    },
    {
        "Input": "Create a Python class representing a doubly linked list and implement a method to delete a node by value.",
        "Output": "Here's an example implementation of a Python class representing a doubly linked list and implementing a method to delete a node by value:\npython\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def delete_node(self, value):\n        if self.head is None:\n            return\n\n        current = self.head\n\n        while current is not None:\n            if current.data == value:\n                if current.prev is not None:\n                    current.prev.next = current.next\n                else:\n                    self.head = current.next\n\n                if current.next is not None:\n                    current.next.prev = current.prev\n\n                return\n\n            current = current.next\nThis implementation defines two classes: Node and DoublyLinkedList. The Node class represents a node in the doubly linked list and has three attributes: data, prev, and next. The DoublyLinkedList class represents the doubly linked list and has one attribute: head, which is the first node in the list.\nThe delete_node() method takes a value as input and deletes the first node in the list with that value. It first checks if the list is empty and returns if it is. Then, it uses a loop to iterate over each node in the list and checks if its data is equal to the input value. If it is, it updates the prev and next pointers of the adjacent nodes to remove the current node from the list.\nHere's an example of how to use the class:\npython\n# Create a doubly linked list\ndll = DoublyLinkedList()\ndll.head = Node(1)\ndll.head.next = Node(2)\ndll.head.next.prev = dll.head\ndll.head.next.next = Node(3)\ndll.head.next.next.prev = dll.head.next\n\n# Print the original list\nprint(\"Original list:\")\ncurrent = dll.head\nwhile current is not None:\n    print(current.data)\n    current = current.next\n\n# Delete a node by value\ndll.delete_node(2)\n\n# Print the updated list\nprint(\"Updated list:\")\ncurrent = dll.head\nwhile current is not None:\n    print(current.data)\n    current = current.next\nThis program first creates a doubly linked list with three nodes. Then, it prints the original list using a loop to iterate over each node and print its data. Next, it deletes the node with a value of 2 using the delete_node() method. Finally, it prints the updated list using a loop to iterate over each node and print its data. In this case, the output will be:\nOriginal list:\n1\n2\n3\nUpdated list:\n1\n3\nThis output shows that the delete_node() method correctly deletes the node with a value of 2 from the list.\n1\nw3resource\n2\nfavtutor\n3\nstackabuse\n4\nalphacodingskills\n5\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to sort a list of strings in lexicographic (dictionary) order.",
        "Output": "To sort a list of strings in lexicographic (dictionary) order in Python, we can use several approaches. Here are a few examples:\nUsing the sort() method: We can use the sort() method to sort a list of strings in lexicographic order. By default, the sort() method sorts the list in ascending order. Here's an example implementation:\npython\ndef sort_strings(strings):\n    strings.sort()\n    return strings\nThis function takes a list of strings strings as input and returns the sorted list in lexicographic order. It uses the sort() method to sort the list in place.\nHere's an example of how to use the function:\npython\nstrings = [\"banana\", \"apple\", \"cherry\", \"orange\"]\nresult = sort_strings(strings)\nprint(\"Sorted strings:\", result)\nThis program first initializes a list called strings with a value of [\"banana\", \"apple\", \"cherry\", \"orange\"]. Then, it calls the sort_strings() function with strings as input and stores the result in a variable called result. Finally, it prints the sorted list of strings using the print() function. In this case, the output will be:\nSorted strings: ['apple', 'banana', 'cherry', 'orange']\nThis output shows that the sort_strings() function correctly sorts the list of strings in lexicographic order.\nUsing the sorted() function: We can use the sorted() function to sort a list of strings in lexicographic order. The sorted() function returns a new sorted list and leaves the original list unchanged. Here's an example implementation:\npython\ndef sort_strings(strings):\n    return sorted(strings)\nThis function takes a list of strings strings as input and returns the sorted list in lexicographic order. It uses the sorted() function to sort the list.\nHere's an example of how to use the function:\npython\nstrings = [\"banana\", \"apple\", \"cherry\", \"orange\"]\nresult = sort_strings(strings)\nprint(\"Sorted strings:\", result)\nThis program first initializes a list called strings with a value of [\"banana\", \"apple\", \"cherry\", \"orange\"]. Then, it calls the sort_strings() function with strings as input and stores the result in a variable called result. Finally, it prints the sorted list of strings using the print() function. In this case, the output will be:\nSorted strings: ['apple', 'banana', 'cherry', 'orange']\nThis output shows that the sort_strings() function correctly sorts the list of strings in lexicographic order.\nBoth implementations are valid and can be used to sort a list of strings in lexicographic order in Python. The first implementation uses the sort() method, while the second implementation uses the sorted() function.\n1\npythonexamples\n2\ndevcubicle\n3\nw3resource\n4\nstackoverflow\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to convert a decimal number to a binary fraction.",
        "Output": "To convert a decimal number to a binary fraction in Python, we can use several approaches. Here are a few examples:\nUsing a custom function: We can use a custom function to convert a decimal number to a binary fraction. The function multiplies the decimal number by 2 and checks if the result is greater than or equal to 1. If it is, it adds 1 to the binary fraction and subtracts 1 from the decimal number. If it is not, it adds 0 to the binary fraction. It repeats this process until the decimal number becomes 0 or the binary fraction has the desired precision. Here's an example implementation:\npython\ndef decimal_to_binary_fraction(decimal, precision=10):\n    binary = \"\"\n    while decimal > 0 and len(binary) < precision:\n        decimal *= 2\n        if decimal >= 1:\n            binary += \"1\"\n            decimal -= 1\n        else:\n            binary += \"0\"\n    return binary\nThis function takes a decimal number decimal as input and an optional precision precision and returns a binary fraction as a string. It uses a loop to multiply the decimal number by 2 and add 1 or 0 to the binary fraction depending on whether the result is greater than or equal to 1. It repeats this process until the decimal number becomes 0 or the binary fraction has the desired precision.\nHere's an example of how to use the function:\npython\ndecimal = 0.625\nresult = decimal_to_binary_fraction(decimal)\nprint(\"Binary fraction of\", decimal, \"is:\", result)\nThis program first initializes a decimal number called decimal with a value of 0.625. Then, it calls the decimal_to_binary_fraction() function with decimal as input and stores the result in a variable called result. Finally, it prints the binary fraction using the print() function. In this case, the output will be:\nBinary fraction of 0.625 is: 101\nThis output shows that the decimal_to_binary_fraction() function correctly converts the decimal number to a binary fraction.\nUsing the decimal module: We can use the decimal module to convert a decimal number to a binary fraction. The decimal module provides a Decimal class that can represent decimal numbers with arbitrary precision. We can use the as_integer_ratio() method of the Decimal class to get the numerator and denominator of the fraction and then convert them to binary using the bin() function. Here's an example implementation:\npython\nfrom decimal import Decimal\n\ndef decimal_to_binary_fraction(decimal):\n    numerator, denominator = Decimal(decimal).as_integer_ratio()\n    binary_numerator = bin(numerator)[2:]\n    binary_denominator = bin(denominator)[2:]\n    return binary_numerator + \"/\" + binary_denominator\nThis function takes a decimal number decimal as input and returns a binary fraction as a string. It uses the Decimal class to get the numerator and denominator of the fraction and the bin() function to convert them to binary.\nHere's an example of how to use the function:\npython\ndecimal = 0.625\nresult = decimal_to_binary_fraction(decimal)\nprint(\"Binary fraction of\", decimal, \"is:\", result)\nThis program first initializes a decimal number called decimal with a value of 0.625. Then, it calls the decimal_to_binary_fraction() function with decimal as input and stores the result in a variable called result. Finally, it prints the binary fraction using the print() function. In this case, the output will be:\nBinary fraction of 0.625 is: 101/1000\nThis output shows that the decimal_to_binary_fraction() function correctly converts the decimal number to a binary fraction.\nBoth implementations are valid and can be used to convert a decimal number to a binary fraction in Python. The first implementation uses a custom function, while the second implementation uses the decimal module.\n1\ngithub\n2\nstackoverflow\n3\ncodespeedy\n4\ngeeksforgeeks\n5\nscaler"
    },
    {
        "Input": "Create a program to find the sum of the prime numbers up to a given number.",
        "Output": "To find the sum of prime numbers up to a given number in Python, we can use several approaches. Here are a few examples:\nUsing a loop: We can use a loop to iterate over each number up to the given number and check if it is a prime number. If it is, we add it to a running sum. Here's an example implementation:\npython\ndef sum_of_primes(n):\n    if n < 2:\n        return 0\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n    return sum(i for i in range(2, n + 1) if primes[i])\nThis function takes an integer n as input and returns the sum of all prime numbers up to n. It first checks if n is less than 2 and returns 0 if it is. Then, it initializes a list called primes with True values for each index up to n. It uses a loop to iterate over each number up to the square root of n and marks all its multiples as composite by setting their corresponding indices in the primes list to False. Finally, it uses another loop to iterate over each number up to n and adds it to a running sum if it is a prime number.\nHere's an example of how to use the function:\npython\nn = 50\nresult = sum_of_primes(n)\nprint(\"Sum of prime numbers up to\", n, \"is:\", result)\nThis program first initializes an integer called n with a value of 50. Then, it calls the sum_of_primes() function with n as input and stores the result in a variable called result. Finally, it prints the sum of prime numbers using the print() function. In this case, the output will be:\nSum of prime numbers up to 50 is: 328\nThis output shows that the sum_of_primes() function correctly identifies the sum of prime numbers up to 50.\nUsing the sympy module: We can use the sympy module to find the prime numbers up to the given number and then sum them. The sympy module provides a primerange() function that returns an iterator over the prime numbers in a given range. Here's an example implementation:\npython\nfrom sympy import primerange\n\ndef sum_of_primes(n):\n    return sum(primerange(2, n + 1))\nThis function takes an integer n as input and returns the sum of all prime numbers up to n. It uses the primerange() function from the sympy module to get an iterator over the prime numbers in the range [2, n + 1] and then sums them.\nHere's an example of how to use the function:\npython\nn = 50\nresult = sum_of_primes(n)\nprint(\"Sum of prime numbers up to\", n, \"is:\", result)\nThis program first initializes an integer called n with a value of 50. Then, it calls the sum_of_primes() function with n as input and stores the result in a variable called result. Finally, it prints the sum of prime numbers using the print() function. In this case, the output will be:\nSum of prime numbers up to 50 is: 328\nThis output shows that the sum_of_primes() function correctly identifies the sum of prime numbers up to 50.\nBoth implementations are valid and can be used to find the sum of prime numbers up to a given number in Python. The first implementation uses a loop, while the second implementation uses the sympy module.\n1\nstackoverflow\n2\nstudyfied\n3\nscaler\n4\ncopyassignment\n5\nincludehelp"
    },
    {
        "Input": "Write a Python class representing a hash table and implement methods to insert and retrieve key-value pairs.",
        "Output": "To create a Python class representing a hash table and implement methods to insert and retrieve key-value pairs, we can use several approaches. Here are a few examples:\nUsing separate chaining: We can use separate chaining to handle collisions in the hash table. Separate chaining is a technique where each bucket in the hash table is a linked list that stores all the key-value pairs that hash to the same index. Here's an example implementation:\npython\nclass HashTable:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.size = 0\n        self.buckets = [None] * self.capacity\n\n    def _hash(self, key):\n        hash_sum = 0\n        for i, c in enumerate(key):\n            hash_sum += (i + len(key)) ** ord(c)\n            hash_sum %= self.capacity\n        return hash_sum\n\n    def insert(self, key, value):\n        index = self._hash(key)\n        node = self.buckets[index]\n        while node is not None:\n            if node.key == key:\n                node.value = value\n                return\n            node = node.next\n        new_node = Node(key, value)\n        new_node.next = self.buckets[index]\n        self.buckets[index] = new_node\n        self.size += 1\n\n    def retrieve(self, key):\n        index = self._hash(key)\n        node = self.buckets[index]\n        while node is not None:\n            if node.key == key:\n                return node.value\n            node = node.next\n        return None\n\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\nThis implementation defines two classes: HashTable and Node. The HashTable class represents the hash table and has three attributes: capacity, size, and buckets. It also has two methods: _hash() and insert(). The _hash() method takes a key as input and returns the index in the hash table where the key-value pair should be stored. It uses a hash function to compute the hash value. The insert() method takes a key-value pair as input and inserts it into the hash table. It uses the _hash() method to compute the index and then uses separate chaining to handle collisions.\nThe Node class represents a node in the linked list and has three attributes: key, value, and next.\nHere's an example of how to use the class:\npython\n# Create a hash table\nht = HashTable()\n\n# Insert key-value pairs\nht.insert(\"apple\", 1)\nht.insert(\"banana\", 2)\nht.insert(\"cherry\", 3)\n\n# Retrieve values by key\nprint(ht.retrieve(\"apple\"))\nprint(ht.retrieve(\"banana\"))\nprint(ht.retrieve(\"cherry\"))\nThis program first creates a hash table called ht. Then, it inserts three key-value pairs into the hash table using the insert() method. Finally, it retrieves the values by key using the retrieve() method and prints them using the print() function. In this case, the output will be:\n1\n2\n3\nThis output shows that the HashTable class correctly inserts and retrieves key-value pairs.\nUsing Python's built-in dictionary: We can use Python's built-in dictionary to implement a hash table. A dictionary is a hash table that stores key-value pairs. Here's an example implementation:\npython\nclass HashTable:\n    def __init__(self):\n        self.table = {}\n\n    def insert(self, key, value):\n        self.table[key] = value\n\n    def retrieve(self, key):\n        return self.table.get(key, None)\nThis implementation defines a HashTable class that has one attribute: table, which is a dictionary that stores the key-value pairs. It also has two methods: insert() and retrieve(). The insert() method takes a key-value pair as input and inserts it into the dictionary. The retrieve() method takes a key as input and returns the corresponding value from the dictionary.\nHere's an example of how to use the class:\npython\n# Create a hash table\nht = HashTable()\n\n# Insert key-value pairs\nht.insert(\"apple\", 1)\nht.insert(\"banana\", 2)\nht.insert(\"cherry\", 3)\n\n# Retrieve values by key\nprint(ht.retrieve(\"apple\"))\nprint(ht.retrieve(\"banana\"))\nprint(ht.retrieve(\"cherry\"))\nThis program first creates a hash table called ht. Then, it inserts three key-value pairs into the hash table using the insert() method. Finally, it retrieves the values by key using the retrieve() method and prints them using the print() function. In this case, the output will be:\n1\n2\n3\nThis output shows that the HashTable class correctly inserts and retrieves key-value pairs using Python's built-in dictionary.\nBoth implementations are valid and can be used to create a Python class representing a hash table and implement methods to insert and retrieve key-value pairs. The first implementation uses separate chaining, while the second implementation uses Python's built-in dictionary.\n1\nmedium\n2\ngeeksforgeeks\n3\nchapagain\n4\nyoutube\n5\ntutorialspoint"
    },
    {
        "Input": "Implement a function to reverse a given string without using any built-in methods.",
        "Output": "Here's a function in Java to reverse a given string without using any built-in methods:\njava\npublic static String reverseString(String str) {\n    char[] charArray = str.toCharArray();\n    int left = 0;\n    int right = charArray.length - 1;\n    while (left < right) {\n        char temp = charArray[left];\n        charArray[left] = charArray[right];\n        charArray[right] = temp;\n        left++;\n        right--;\n    }\n    return new String(charArray);\n}\nThis function takes a string input and converts it to a character array. It then uses two pointers, left and right, to swap the characters at the beginning and end of the array, respectively. The pointers move towards each other until they meet in the middle of the array. Finally, the function returns the reversed string by creating a new string from the reversed character array\n1\n.\nFor example, the following Java code uses the reverseString() function to reverse a given string:\njava\nString str = \"hello world\";\nString reversedStr = reverseString(str);\nSystem.out.println(reversedStr);\nThis will output:\ndlrow olleh\n1\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to find the common elements between two sorted lists.",
        "Output": "Here's a Python program to find the common elements between two sorted lists:\npython\ndef common_elements(list1, list2):\n    i = 0\n    j = 0\n    result = []\n    while i < len(list1) and j < len(list2):\n        if list1[i] == list2[j]:\n            result.append(list1[i])\n            i += 1\n            j += 1\n        elif list1[i] < list2[j]:\n            i += 1\n        else:\n            j += 1\n    return result\nThis function takes two sorted lists as input and uses two pointers, i and j, to iterate through the lists. If the elements at the current positions of the pointers are equal, the function appends the element to a result list and increments both pointers. If the element in list1 is less than the element in list2, the function increments i. Otherwise, it increments j. The function returns the result list containing the common elements\n1\n.\nFor example, the following Python code uses the common_elements() function to find the common elements between two sorted lists:\npython\nlist1 = [1, 3, 4, 6, 7, 9]\nlist2 = [1, 2, 4, 5, 9, 10]\nresult = common_elements(list1, list2)\nprint(result)\nThis will output:\n[1, 4, 9]\n1\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing a binary min-heap and implement methods to insert and extract the minimum element.",
        "Output": "Here's a Python class representing a binary min-heap and its methods to insert and extract the minimum element:\npython\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._bubble_up(len(self.heap) - 1)\n\n    def extract_min(self):\n        if not self.heap:\n            return None\n        self._swap(0, len(self.heap) - 1)\n        min_value = self.heap.pop()\n        self._bubble_down(0)\n        return min_value\n\n    def _bubble_up(self, index):\n        parent_index = (index - 1) // 2\n        if parent_index < 0:\n            return\n        if self.heap[parent_index] > self.heap[index]:\n            self._swap(parent_index, index)\n            self._bubble_up(parent_index)\n\n    def _bubble_down(self, index):\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        min_index = index\n        if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[min_index]:\n            min_index = left_child_index\n        if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[min_index]:\n            min_index = right_child_index\n        if min_index != index:\n            self._swap(index, min_index)\n            self._bubble_down(min_index)\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\nThis class has an instance variable heap that stores the elements of the heap as a list. The insert() method takes a value and adds it to the end of the list, then bubbles it up to its correct position in the heap by repeatedly swapping it with its parent until the heap property is satisfied. The extract_min() method removes and returns the minimum element of the heap by swapping it with the last element of the list, removing the last element, and then bubbling down the new root element to its correct position in the heap by repeatedly swapping it with its smallest child until the heap property is satisfied. The _bubble_up() and _bubble_down() methods are helper methods that perform the swapping and bubbling operations. The _swap() method is another helper method that swaps two elements in the list\n1\n.\nFor example, the following Python code creates a MinHeap object, inserts some values, and extracts the minimum element:\npython\nheap = MinHeap()\nheap.insert(5)\nheap.insert(3)\nheap.insert(7)\nheap.insert(1)\nmin_value = heap.extract_min()\nprint(min_value)\nThis will output:\n1\n1\naskpython"
    },
    {
        "Input": "Implement a function to find the first non-repeating character in a string.",
        "Output": "Here's a Python function to find the first non-repeating character in a string:\npython\ndef first_non_repeating_char(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None\nThis function takes a string input and first creates a dictionary char_count to store the count of each character in the string. It then iterates through the string again and returns the first character that has a count of 1 in the char_count dictionary. If no such character is found, the function returns None\n1\n.\nFor example, the following Python code uses the first_non_repeating_char() function to find the first non-repeating character in a string:\npython\nstring = \"hello world\"\nresult = first_non_repeating_char(string)\nprint(result)\nThis will output:\n'h'\n1\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to check if a given string is a valid URL.",
        "Output": "To check if a given string is a valid URL, we can use regular expressions to match the string against a pattern that defines the structure of a valid URL. There are several ways to do this in Python, but one common approach is to use the re module to compile a regular expression pattern and then use the match() method to check if the string matches the pattern.\nHere's an example Python function that uses regular expressions to check if a given string is a valid URL:\npython\nimport re\n\ndef is_valid_url(url):\n    pattern = re.compile(r'^(?:http|https)://[\\w.-]+(?:\\.[\\w.-]+)+[\\w\\-._~:/?#[\\]@!$&\\'()*+,;=]+$')\n    return bool(pattern.match(url))\nThis function takes a string input url and uses the re.compile() method to compile a regular expression pattern that matches the structure of a valid URL. The pattern uses a combination of character classes, groups, and quantifiers to match the various components of a URL, including the scheme, domain, path, and query string. The function then uses the match() method to check if the input string matches the pattern, and returns a boolean value indicating whether the string is a valid URL or not.\nFor example, the following Python code uses the is_valid_url() function to check if a given string is a valid URL:\npython\nurl = \"https://www.google.com/search?q=python\"\nresult = is_valid_url(url)\nprint(result)\nThis will output:\nTrue\nNote that the regular expression pattern used in this example is not perfect and may not match all possible valid URLs. There are many variations in the structure of URLs, and some URLs may contain characters or components that are not covered by this pattern. However, this pattern should match most common URLs and can be easily adapted or extended to handle other cases as needed\n1\n2\n3\n.\n1\ncodingdeeply\n2\nmakeuseof\n3\npython"
    },
    {
        "Input": "Create a program to find the intersection of multiple sets.",
        "Output": "There are several ways to find the intersection of multiple sets in Python. One way is to use the intersection() method of the set class. Another way is to use the & operator. Here's an example program that demonstrates both methods:\npython\ndef intersect_sets(set_list):\n    # Using intersection() method\n    result = set_list[0].intersection(*set_list[1:])\n    # Using & operator\n    # result = set_list[0]\n    # for s in set_list[1:]:\n    #     result &= s\n    return result\nThis function takes a list of sets set_list and first uses the intersection() method to find the intersection of all the sets in the list. The * operator is used to unpack the list of sets as arguments to the intersection() method. Alternatively, the function can use the & operator to find the intersection by iterating through the sets in the list and taking the intersection with the previous result. The function returns the resulting set that contains the common elements of all the sets in the list.\nFor example, the following Python code uses the intersect_sets() function to find the intersection of multiple sets:\npython\nset1 = {1, 2, 3, 4, 5}\nset2 = {2, 3, 5, 7, 11}\nset3 = {3, 5, 8, 13}\nresult = intersect_sets([set1, set2, set3])\nprint(result)\nThis will output:\n{5, 3}\nNote that the intersect_sets() function assumes that the input list set_list contains at least one set. If the list is empty, the function will raise an error. Also, the function assumes that the sets in the list are not empty. If any set in the list is empty, the function will return an empty set as the intersection\n1\n2\n3\n.\n1\ngeeksforgeeks\n2\nprogramiz\n3\nfinxter"
    },
    {
        "Input": "Implement a function to check if a given number is a palindrome.",
        "Output": "To check if a given number is a palindrome, we can convert the number to a string and check if the string is equal to its reverse. There are several ways to do this in Python, including using loops, recursion, and one-liner solutions. Here are a few examples:\npython\n# Using loops\ndef is_palindrome(num):\n    num_str = str(num)\n    for i in range(len(num_str) // 2):\n        if num_str[i] != num_str[-i - 1]:\n            return False\n    return True\n\n# Using recursion\ndef is_palindrome(num):\n    num_str = str(num)\n    if len(num_str) <= 1:\n        return True\n    if num_str[0] != num_str[-1]:\n        return False\n    return is_palindrome(num_str[1:-1])\n\n# Using one-liner solution\ndef is_palindrome(num):\n    return str(num) == str(num)[::-1]\nAll three functions take a number input num and first convert it to a string using the str() function. The first function uses a loop to iterate through the string and compare the characters at opposite ends of the string. If any pair of characters does not match, the function returns False. If all pairs match, the function returns True. The second function uses recursion to check if the first and last characters of the string match, and then recursively checks the substring between them. If the length of the string is 0 or 1, the function returns True. The third function uses a one-liner solution that reverses the string using slicing and then compares it to the original string. If the two strings are equal, the function returns True. Otherwise, it returns False.\nFor example, the following Python code uses the is_palindrome() function to check if a given number is a palindrome:\npython\nnum = 12321\nresult = is_palindrome(num)\nprint(result)\nThis will output:\nTrue\nNote that the is_palindrome() function assumes that the input number num is a positive integer. If the input is negative or not an integer, the function may not work as expected. Also, the function assumes that the input number is not too large to be represented as a string. If the input number is too large, the function may raise an error\n1\n2\n3\n4\n5\n6\n.\n1\ngeeksforgeeks\n2\ntutorialspoint\n3\nupgrad\n4\ncodewithharry\n5\nedureka\n6\nprepinsta"
    },
    {
        "Input": "Write a Python class representing a circular queue and implement a method to check if it is full.",
        "Output": "Here's a Python class representing a circular queue and its method to check if it is full:\npython\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.items = [None] * capacity\n        self.max_queue = capacity\n        self.front = 0\n        self.back = self.max_queue - 1\n        self.count = 0\n\n    def enqueue(self, item):\n        if not self.is_full():\n            self.back = (self.back + 1) % self.max_queue\n            self.items[self.back] = item\n            self.count += 1\n\n    def dequeue(self):\n        if not self.is_empty():\n            item = self.items[self.front]\n            self.front = (self.front + 1) % self.max_queue\n            self.count -= 1\n            return item\n\n    def is_full(self):\n        return self.count == self.max_queue\n\n    def is_empty(self):\n        return self.count == 0\nThis class has an instance variable items that stores the elements of the circular queue as a list. The front and back variables are used to keep track of the indices of the first and last elements of the queue, respectively. The count variable keeps track of the number of elements in the queue. The enqueue() method takes an item and adds it to the back of the queue if the queue is not full. The dequeue() method removes and returns the front element of the queue if the queue is not empty. The is_full() method checks if the queue is full by comparing the count variable to the max_queue capacity. The is_empty() method checks if the queue is empty by comparing the count variable to 0.\nFor example, the following Python code creates a CircularQueue object, adds some items to the queue, and checks if the queue is full:\npython\nqueue = CircularQueue(5)\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\nqueue.enqueue(4)\nqueue.enqueue(5)\nresult = queue.is_full()\nprint(result)\nThis will output:\nTrue\nNote that the CircularQueue class assumes that the input capacity is a positive integer. If the input is negative or not an integer, the class may not work as expected. Also, the class assumes that the input capacity is not too large to create a list of that size. If the input capacity is too large, the class may raise an error\n1\n2\n.\n1\npythoncentral\n2\nstackoverflow"
    },
    {
        "Input": "Create a program to find the largest prime palindrome less than a given number.",
        "Output": "To find the largest prime palindrome less than a given number, we can use a combination of prime number and palindrome checks. One way to do this is to start from the given number and iterate downwards until we find a number that is both prime and a palindrome. Here's an example Python function that implements this approach:\npython\ndef largest_prime_palindrome(num):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    for i in range(num - 1, 1, -1):\n        if is_prime(i) and is_palindrome(i):\n            return i\n    return None\nThis function takes a number input num and first defines two helper functions is_prime() and is_palindrome() to check if a number is prime and a palindrome, respectively. The is_prime() function checks if a number is prime by iterating from 2 to the square root of the number and checking if any divisor divides the number evenly. The is_palindrome() function checks if a number is a palindrome by converting it to a string and comparing it to its reverse. The main function then iterates downwards from the input number and checks each number if it is both prime and a palindrome. If such a number is found, the function returns it. If no such number is found, the function returns None.\nFor example, the following Python code uses the largest_prime_palindrome() function to find the largest prime palindrome less than a given number:\npython\nnum = 1000\nresult = largest_prime_palindrome(num)\nprint(result)\nThis will output:\n929\nNote that the largest_prime_palindrome() function assumes that the input number num is a positive integer. If the input is negative or not an integer, the function may not work as expected. Also, the function assumes that the largest prime palindrome less than the input number exists. If no such number exists, the function will return None\n1\n2\n3\n.\n1\ngithub\n2\nstackoverflow\n3\nleetcode"
    },
    {
        "Input": "Implement a function to remove all occurrences of a specified element from a list.",
        "Output": "To remove all occurrences of a specified element from a list in Python, we can use the remove() method of the list class. The remove() method takes a single element as an argument and removes the first occurrence of that element from the list. If the element is not found in the list, the method raises a ValueError exception. To remove all occurrences of the element, we can use a loop to repeatedly call the remove() method until the element is no longer found in the list. Here's an example Python function that implements this approach:\npython\ndef remove_all(lst, elem):\n    while elem in lst:\n        lst.remove(elem)\nThis function takes a list input lst and an element input elem, and repeatedly calls the remove() method of the list until the element is no longer found in the list. Note that this function modifies the input list in place and does not return a new list.\nFor example, the following Python code uses the remove_all() function to remove all occurrences of a specified element from a list:\npython\nlst = [1, 2, 3, 2, 4, 2, 5]\nremove_all(lst, 2)\nprint(lst)\nThis will output:\n[1, 3, 4, 5]\nNote that the remove_all() function assumes that the input list lst is a valid list object. If the input is not a list or is None, the function may not work as expected. Also, the function assumes that the input element elem is a valid element of the list. If the element is not found in the list, the function will not raise an error but will simply exit the loop\n1\n2\n.\n1\nprogramiz\n2\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to calculate the sum of the digits of a given number until it becomes a single-digit number.",
        "Output": "Here's a Python function to calculate the sum of the digits of a given number until it becomes a single-digit number:\npython\ndef sum_digits(num):\n    while num >= 10:\n        num = sum(int(digit) for digit in str(num))\n    return num\nThis function takes a number input num and repeatedly sums the digits of the number until the result is a single-digit number. The function first checks if the input number is greater than or equal to 10. If it is, the function converts the number to a string using the str() function, iterates through the string using a generator expression, and converts each digit back to an integer using the int() function. The sum() function is then used to add up the digits, and the resulting sum is assigned back to the num variable. The loop continues until num is less than 10, at which point the function returns num.\nFor example, the following Python code uses the sum_digits() function to calculate the sum of the digits of a given number until it becomes a single-digit number:\npython\nnum = 12345\nresult = sum_digits(num)\nprint(result)\nThis will output:\n6\nNote that the sum_digits() function assumes that the input number num is a positive integer. If the input is negative or not an integer, the function may not work as expected. Also, the function assumes that the sum of the digits of the input number will eventually become a single-digit number. If the sum does not converge to a single-digit number, the function will enter an infinite loop\n1\n2\n3\n.\n1\ngeeksforgeeks\n2\njavatpoint\n3\ncodesansar"
    },
    {
        "Input": "Create a Python class representing a trie (prefix tree) and implement methods to insert and search for words.",
        "Output": "Here's a Python class representing a trie (prefix tree) and its methods to insert and search for words:\npython\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_word\nThis class has an instance variable root that stores the root node of the trie as a TrieNode object. The TrieNode class has an instance variable children that stores the child nodes of the current node as a dictionary, and an instance variable is_word that indicates whether the current node represents the end of a word. The Trie class has two methods: insert() and search(). The insert() method takes a word input and inserts it into the trie by iterating through the characters of the word and creating new nodes as needed. The search() method takes a word input and searches for it in the trie by iterating through the characters of the word and checking if each character is a child of the current node. If the end of the word is reached and the current node represents the end of a word, the method returns True. Otherwise, it returns False.\nFor example, the following Python code creates a Trie object, inserts some words, and searches for them:\npython\ntrie = Trie()\ntrie.insert(\"apple\")\ntrie.insert(\"banana\")\ntrie.insert(\"cherry\")\nresult1 = trie.search(\"apple\")\nresult2 = trie.search(\"orange\")\nprint(result1)\nprint(result2)\nThis will output:\nTrue\nFalse\nNote that the Trie class assumes that the input words are valid strings consisting of lowercase letters. If the input is not a string or contains uppercase letters or other characters, the class may not work as expected. Also, the class assumes that the input words do not contain leading or trailing spaces. If the input words contain spaces, the class may create unnecessary nodes in the trie\n1\n2\n3\n4\n5\n6\n.\n1\nstackoverflow\n2\naskpython\n3\nmedium\n4\ngeeksforgeeks\n5\ntutorialspoint\n6\nplainenglish"
    },
    {
        "Input": "Implement a function to check if a given string is an anagram of another string.",
        "Output": "To check if a given string is an anagram of another string, we can compare the sorted versions of the two strings. If the sorted versions are equal, then the two strings are anagrams of each other. Here's an example Python function that implements this approach:\npython\ndef is_anagram(str1, str2):\n    return sorted(str1) == sorted(str2)\nThis function takes two string inputs str1 and str2 and compares their sorted versions using the sorted() function. If the sorted versions are equal, the function returns True, indicating that the two strings are anagrams of each other. Otherwise, it returns False.\nFor example, the following Python code uses the is_anagram() function to check if a given string is an anagram of another string:\npython\nstr1 = \"listen\"\nstr2 = \"silent\"\nresult = is_anagram(str1, str2)\nprint(result)\nThis will output:\nTrue\nNote that the is_anagram() function assumes that the input strings str1 and str2 are valid strings consisting of lowercase letters. If the input is not a string or contains uppercase letters or other characters, the function may not work as expected. Also, the function assumes that the input strings have the same length. If the input strings have different lengths, the function will return False even if they are anagrams of each other\n1\n2\n3\n4\n5\n6\n.\n1\ntutorialspoint\n2\nprogramiz\n3\njavatpoint\n4\nbaeldung\n5\njavatpoint\n6\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to find the minimum number of coins needed to make a given amount of change.",
        "Output": "To find the minimum number of coins needed to make a given amount of change, we can use dynamic programming to solve the coin change problem. The coin change problem is a classic optimization problem that asks: given a set of coin denominations and a target amount of change, what is the minimum number of coins needed to make the change? Here's an example Python function that implements this approach:\npython\ndef min_coins(coins, target):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[target] if dp[target] != float('inf') else -1\nThis function takes a list of coin denominations coins and a target amount of change target, and uses dynamic programming to compute the minimum number of coins needed to make the change. The function first initializes a list dp of length target + 1 with infinity values, except for the first value which is set to 0. The dp list represents the minimum number of coins needed to make each amount of change from 0 to target. The function then iterates through each amount of change from 1 to target, and for each amount, iterates through each coin denomination and computes the minimum number of coins needed to make the change using the formula dp[i] = min(dp[i], dp[i - coin] + 1). The function returns the value of dp[target] if it is not infinity, indicating that the target amount of change can be made using the given coin denominations. Otherwise, it returns -1, indicating that the target amount of change cannot be made using the given coin denominations.\nFor example, the following Python code uses the min_coins() function to find the minimum number of coins needed to make a given amount of change:\npython\ncoins = [1, 5, 10, 25]\ntarget = 30\nresult = min_coins(coins, target)\nprint(result)\nThis will output:\n2\nNote that the min_coins() function assumes that the input coins list is a valid list of positive integers, and that the target input is a positive integer. If the input is not valid, the function may not work as expected. Also, the function assumes that the target amount of change can be made using the given coin denominations. If the target amount of change cannot be made, the function will return -1 even if there is a solution using other coin denominations\n1\n2\n3\n4\n5\n.\n1\nenjoyalgorithms\n2\ngeeksforgeeks\n3\neducative\n4\ncodingninjas\n5\nfavtutor"
    },
    {
        "Input": "Create a program to find the second smallest element in a list.",
        "Output": "There are several ways to find the second smallest element in a list in Python. Here are a few examples:\nMethod 1: Sort the list and return the second element\nOne way to find the second smallest element in a list is to sort the list in ascending order and return the second element. Here's an example Python function that implements this approach:\npython\ndef second_smallest(lst):\n    lst.sort()\n    return lst[1] if len(lst) > 1 else None\nThis function takes a list input lst, sorts the list using the sort() method of the list, and returns the second element of the sorted list using indexing. If the length of the list is less than 2, the function returns None.\nMethod 2: Find the minimum and second minimum elements using two variables\nAnother way to find the second smallest element in a list is to iterate through the list and keep track of the minimum and second minimum elements using two variables. Here's an example Python function that implements this approach:\npython\ndef second_smallest(lst):\n    if len(lst) < 2:\n        return None\n    min1 = min2 = float('inf')\n    for num in lst:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    return min2\nThis function takes a list input lst, first checks if the length of the list is less than 2, and initializes two variables min1 and min2 to infinity. The function then iterates through the list and updates min1 and min2 as needed. If a number is less than min1, min2 is updated to min1 and min1 is updated to the number. If a number is between min1 and min2, min2 is updated to the number. The function returns min2 as the second smallest element.\nMethod 3: Find the minimum and remove it, then find the new minimum\nA third way to find the second smallest element in a list is to find the minimum element, remove it from the list, and then find the new minimum element. Here's an example Python function that implements this approach:\npython\ndef second_smallest(lst):\n    if len(lst) < 2:\n        return None\n    min1 = min(lst)\n    lst.remove(min1)\n    min2 = min(lst)\n    return min2\nThis function takes a list input lst, first checks if the length of the list is less than 2, and finds the minimum element of the list using the min() function. The function then removes the minimum element from the list using the remove() method of the list, and finds the new minimum element using the min() function. The function returns the new minimum element as the second smallest element.\nFor example, the following Python code uses the second_smallest() function to find the second smallest element in a list:\npython\nlst = [5, 3, 1, 4, 2]\nresult = second_smallest(lst)\nprint(result)\nThis will output:\n2\nNote that the second_smallest() function assumes that the input list lst is a valid list object. If the input is not a list or is None, the function may not work as expected. Also, the function assumes that the input list has at least two elements. If the input list has fewer than two elements, the function will return None\n1\n2\n3\n4\n5\n.\n1\ngithub\n2\nprepinsta\n3\nstackoverflow\n4\nw3resource\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to perform matrix addition.",
        "Output": "To perform matrix addition in Python, we can use nested lists to represent matrices and iterate through each element of the matrices to add them together. Here's an example Python function that implements matrix addition:\npython\ndef matrix_addition(matrix1, matrix2):\n    if len(matrix1) != len(matrix2) or len(matrix1[0]) != len(matrix2[0]):\n        return None\n    result = []\n    for i in range(len(matrix1)):\n        row = []\n        for j in range(len(matrix1[0])):\n            row.append(matrix1[i][j] + matrix2[i][j])\n        result.append(row)\n    return result\nThis function takes two matrix inputs matrix1 and matrix2 as nested lists, and first checks if the dimensions of the matrices are the same. If the dimensions are not the same, the function returns None. Otherwise, the function initializes an empty list result to store the result of the matrix addition, and iterates through each element of the matrices using nested loops. For each element, the function adds the corresponding elements of the two matrices together and appends the result to a new row list. The row list is then appended to the result list. The function returns the result list as the sum of the two matrices.\nFor example, the following Python code uses the matrix_addition() function to add two matrices:\npython\nmatrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmatrix2 = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]\nresult = matrix_addition(matrix1, matrix2)\nprint(result)\nThis will output:\n[[10, 10, 10], [10, 10, 10], [10, 10, 10]]\nNote that the matrix_addition() function assumes that the input matrices matrix1 and matrix2 are valid nested lists of the same dimensions. If the input is not a nested list or the dimensions of the matrices are not the same, the function may not work as expected. Also, the function assumes that the input matrices have at least one row and one column. If the input matrices have zero rows or zero columns, the function will return an empty list\n1\n2\n3\n.\n1\nprogrammingsimplified\n2\nyoutube\n3\ngeeksforgeeks"
    },
    {
        "Input": "Write a Python class representing a hash set and implement methods to insert and remove elements.",
        "Output": "Here's a Python class representing a hash set and its methods to insert and remove elements:\npython\nclass HashSet:\n    def __init__(self):\n        self.hashset = set()\n\n    def insert(self, element):\n        self.hashset.add(element)\n\n    def remove(self, element):\n        self.hashset.discard(element)\nThis class has an instance variable hashset that stores the elements of the hash set as a set object. The HashSet class has two methods: insert() and remove(). The insert() method takes an element and adds it to the hash set using the add() method of the set. The remove() method takes an element and removes it from the hash set using the discard() method of the set.\nFor example, the following Python code creates a HashSet object, inserts some elements, and removes an element:\npython\nhashset = HashSet()\nhashset.insert(1)\nhashset.insert(2)\nhashset.insert(3)\nhashset.remove(2)\nprint(hashset.hashset)\nThis will output:\n{1, 3}\nNote that the HashSet class assumes that the input elements are hashable. If an element is not hashable, the class may not work as expected. Also, the class assumes that the input elements are not mutable. If a mutable object is added to the hash set and then modified, the hash set may become inconsistent\n1\n2\n3\n4\n.\n1\nstackoverflow\n2\naskpython\n3\ngeeksforgeeks\n4\ntutorialspoint"
    },
    {
        "Input": "Create a program to find the length of the longest increasing subarray in a given list of integers.",
        "Output": "To find the length of the longest increasing subarray in a given list of integers, we can use dynamic programming to solve the longest increasing subarray problem. The longest increasing subarray problem asks: given an array of integers, what is the length of the longest contiguous subarray such that every element in the subarray is strictly greater than its previous element in the same subarray? Here's an example Python function that implements this approach:\npython\ndef longest_increasing_subarray(lst):\n    if not lst:\n        return 0\n    max_len = 1\n    curr_len = 1\n    for i in range(1, len(lst)):\n        if lst[i] > lst[i-1]:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n    return max(max_len, curr_len)\nThis function takes a list input lst, first checks if the list is empty, and initializes two variables max_len and curr_len to 1. The function then iterates through the list using a loop and checks if each element is greater than its previous element. If it is, curr_len is incremented by 1. If it is not, max_len is updated to the maximum of max_len and curr_len, and curr_len is reset to 1. The function returns the maximum of max_len and curr_len as the length of the longest increasing subarray.\nFor example, the following Python code uses the longest_increasing_subarray() function to find the length of the longest increasing subarray in a given list of integers:\npython\nlst = [5, 6, 3, 5, 7, 8, 9, 1, 2]\nresult = longest_increasing_subarray(lst)\nprint(result)\nThis will output:\n5\nNote that the longest_increasing_subarray() function assumes that the input list lst is a valid list of integers. If the input is not a list or contains non-integer elements, the function may not work as expected. Also, the function assumes that the length of the input list is at least 1. If the input list is empty, the function will return 0\n1\n2\n.\n1\ngeeksforgeeks\n2\ngeeksforgeeks"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid palindrome, considering only alphanumeric characters.\"",
        "Output": "To check if a given string is a valid palindrome, considering only alphanumeric characters, we can use a regular expression to remove all non-alphanumeric characters from the string and then compare the resulting string to its reverse. Here's an example Python function that implements this approach:\npython\nimport re\n\ndef is_valid_palindrome(s):\n    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]\nThis function takes a string input s, uses the re.sub() function from the re module to remove all non-alphanumeric characters from the string, and converts the resulting string to lowercase. The function then compares the resulting string to its reverse using slicing and returns True if they are equal, indicating that the original string is a valid palindrome. Otherwise, the function returns False.\nFor example, the following Python code uses the is_valid_palindrome() function to check if a given string is a valid palindrome, considering only alphanumeric characters:\npython\ns = \"A man, a plan, a canal: Panama\"\nresult = is_valid_palindrome(s)\nprint(result)\nThis will output:\nTrue\nNote that the is_valid_palindrome() function assumes that the input string s is a valid string. If the input is not a string, the function may not work as expected. Also, the function assumes that the input string contains at least one alphanumeric character. If the input string contains no alphanumeric characters, the function will return True even if the string is not a valid palindrome\n1\n2\n3\n.\n1\nfavtutor\n2\nleetcode\n3\nlearncodingfast"
    },
    {
        "Input": "Write a program to generate all possible permutations of a given string.",
        "Output": "There are several ways to generate all possible permutations of a given string in Python. Here are a few examples:\nMethod 1: Using itertools.permutations()\nOne way to generate all possible permutations of a given string is to use the permutations() function from the itertools module. Here's an example Python function that implements this approach:\npython\nimport itertools\n\ndef all_permutations(s):\n    return list(itertools.permutations(s))\nThis function takes a string input s, uses the permutations() function from the itertools module to generate all possible permutations of the string, and returns the permutations as a list.\nMethod 2: Using recursion\nAnother way to generate all possible permutations of a given string is to use recursion. Here's an example Python function that implements this approach:\npython\ndef all_permutations(s):\n    if len(s) == 0:\n        return []\n    if len(s) == 1:\n        return [s]\n    result = []\n    for i in range(len(s)):\n        c = s[i]\n        remaining = s[:i] + s[i+1:]\n        for permutation in all_permutations(remaining):\n            result.append(c + permutation)\n    return result\nThis function takes a string input s, first checks if the length of the string is 0 or 1, and returns the string as a list if it is. Otherwise, the function initializes an empty list result to store the permutations, and iterates through each character of the string using a loop. For each character, the function recursively generates all permutations of the remaining characters using the same function, and appends the character to the beginning of each permutation. The function returns the list of permutations.\nFor example, the following Python code uses the all_permutations() function to generate all possible permutations of a given string:\npython\ns = \"abc\"\nresult = all_permutations(s)\nprint(result)\nThis will output:\n['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\nNote that the all_permutations() function assumes that the input string s is a valid string. If the input is not a string, the function may not work as expected. Also, the function assumes that the input string has at least one character. If the input string is empty, the function will return an empty list\n1\n2\n3\n4\n5\n6\n.\n1\ndatagy\n2\ntutorialspoint\n3\ntechbeamers\n4\ntechiedelight\n5\ngeeksforgeeks\n6\nprogramiz"
    },
    {
        "Input": "Create a Python class representing a circular linked list and implement a method to delete a node at a given position.",
        "Output": "Here's a Python class representing a circular linked list and its method to delete a node at a given position:\npython\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            new_node.next = self.head\n        else:\n            curr = self.head\n            while curr.next != self.head:\n                curr = curr.next\n            curr.next = new_node\n            new_node.next = self.head\n\n    def delete_at_position(self, position):\n        if self.head is None:\n            return\n        curr = self.head\n        prev = None\n        i = 1\n        while i < position:\n            prev = curr\n            curr = curr.next\n            i += 1\n            if curr == self.head:\n                return\n        if prev is None:\n            while curr.next != self.head:\n                curr = curr.next\n            curr.next = self.head.next\n            self.head = self.head.next\n        elif curr.next == self.head:\n            prev.next = self.head\n        else:\n            prev.next = curr.next\nThis class has a Node class that represents a node in the circular linked list, with two attributes: data and next. The CircularLinkedList class has an instance variable head that stores the head node of the circular linked list. The class has two methods: insert() and delete_at_position(). The insert() method takes a data input and inserts a new node with the data at the end of the circular linked list. The delete_at_position() method takes a position input and deletes the node at that position in the circular linked list.\nFor example, the following Python code creates a CircularLinkedList object, inserts some nodes, and deletes a node at a given position:\npython\ncll = CircularLinkedList()\ncll.insert(1)\ncll.insert(2)\ncll.insert(3)\ncll.insert(4)\ncll.delete_at_position(2)\nThis will delete the node at position 2 (counting from 1) in the circular linked list.\nNote that the CircularLinkedList class assumes that the input data is valid and that the input position is a positive integer. If the input is not valid, the class may not work as expected. Also, the class assumes that the input position is within the range of the circular linked list. If the input position is out of range, the function will not delete any node\n1\n2\n3\n4\n.\n1\ntutorialspoint\n2\ntutorialspoint\n3\njavatpoint\n4\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to find the majority element (appears more than n/2 times) in a list.",
        "Output": "To find the majority element (appears more than n/2 times) in a list, we can use several approaches. Here are a few examples:\nMethod 1: Using a dictionary to count occurrences\nOne way to find the majority element in a list is to use a dictionary to count the occurrences of each element in the list. Here's an example Python function that implements this approach:\npython\ndef majority_element(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num, count in counts.items():\n        if count > len(lst) / 2:\n            return num\n    return None\nThis function takes a list input lst, initializes a dictionary counts to store the counts of each element in the list, and iterates through each element of the list using a loop. For each element, the function checks if it is already in the counts dictionary, and if it is, increments its count by 1. If it is not, adds it to the dictionary with a count of 1. The function then iterates through the items of the counts dictionary and checks if any element has a count greater than len(lst) / 2, indicating that it is the majority element. If a majority element is found, the function returns it. Otherwise, the function returns None.\nMethod 2: Using sorting\nAnother way to find the majority element in a list is to sort the list and then check if the middle element is the majority element. Here's an example Python function that implements this approach:\npython\ndef majority_element(lst):\n    lst.sort()\n    mid = len(lst) // 2\n    if lst[mid] == lst[0]:\n        return lst[0]\n    elif lst[mid] == lst[-1]:\n        return lst[-1]\n    else:\n        return None\nThis function takes a list input lst, sorts the list using the sort() method of the list, and finds the middle element of the list using integer division. The function then checks if the middle element is equal to the first element of the list or the last element of the list. If it is, the function returns the middle element as the majority element. Otherwise, the function returns None.\nFor example, the following Python code uses the majority_element() function to find the majority element in a list:\npython\nlst = [2, 12, 2, 2, 2, 4, 2]\nresult = majority_element(lst)\nprint(result)\nThis will output:\n2\nNote that the majority_element() function assumes that the input list lst is a valid list of integers. If the input is not a list or contains non-integer elements, the function may not work as expected. Also, the function assumes that the input list has at least one element. If the input list is empty, the function will return None\n1\n2\n3\n4\n5\n.\n1\nenjoyalgorithms\n2\nstackoverflow\n3\nw3resource\n4\nleetcode\n5\neducative"
    },
    {
        "Input": "Write a program to calculate the sum of all even Fibonacci numbers up to a given limit.",
        "Output": "To calculate the sum of all even Fibonacci numbers up to a given limit, we can use a loop to generate the Fibonacci sequence and add up the even numbers. Here's an example Python function that implements this approach:\npython\ndef even_fibonacci_sum(limit):\n    a, b = 1, 2\n    total = 0\n    while a <= limit:\n        if a % 2 == 0:\n            total += a\n        a, b = b, a + b\n    return total\nThis function takes a limit input limit, initializes two variables a and b to 1 and 2 respectively, and initializes a variable total to 0. The function then enters a loop that generates the Fibonacci sequence by adding a and b together and swapping their values. For each value of a, the function checks if it is even using the modulo operator, and if it is, adds it to the total. The function continues the loop until a is greater than limit. Finally, the function returns the total as the sum of all even Fibonacci numbers up to the given limit.\nFor example, the following Python code uses the even_fibonacci_sum() function to calculate the sum of all even Fibonacci numbers up to a given limit:\npython\nlimit = 400\nresult = even_fibonacci_sum(limit)\nprint(result)\nThis will output:\n188\nNote that the even_fibonacci_sum() function assumes that the input limit is a positive integer. If the input is not a positive integer, the function may not work as expected. Also, the function assumes that the Fibonacci sequence starts with 1 and 2. If the sequence starts with different values, the function will not generate the correct sequence\n1\n2\n3\n4\n5\n6\n.\n1\ngeeksforgeeks\n2\nstackoverflow\n3\npythonsolver\n4\nstackexchange\n5\neducative\n6\nplainenglish"
    },
    {
        "Input": "Create a program to sort a list of strings using the insertion sort algorithm.",
        "Output": "Here's a Python program to sort a list of strings using the insertion sort algorithm:\npython\ndef insertion_sort(lst):\n    for i in range(1, len(lst)):\n        key = lst[i]\n        j = i - 1\n        while j >= 0 and len(key) < len(lst[j]):\n            lst[j + 1] = lst[j]\n            j -= 1\n        lst[j + 1] = key\n    return lst\nThis function takes a list input lst and implements the insertion sort algorithm to sort the list of strings in ascending order based on their lengths. The function iterates through each element of the list using a loop, starting from the second element. For each element, the function initializes a variable key to store the element, and a variable j to store the index of the previous element. The function then enters a loop that compares the length of the key to the length of the previous element, and shifts the previous element to the right if its length is greater than the length of the key. The function continues the loop until it finds the correct position for the key, and inserts it at that position. Finally, the function returns the sorted list.\nFor example, the following Python code uses the insertion_sort() function to sort a list of strings:\npython\nlst = ['apple', 'banana', 'pear', 'orange', 'kiwi']\nresult = insertion_sort(lst)\nprint(result)\nThis will output:\n['kiwi', 'pear', 'apple', 'banana', 'orange']\nNote that the insertion_sort() function assumes that the input list lst is a valid list of strings. If the input is not a list or contains non-string elements, the function may not work as expected. Also, the function assumes that the input list has at least one element. If the input list is empty, the function will return an empty list\n1\n2\n3\n.\n1\ndremendo\n2\nprogramiz\n3\njavatpoint"
    },
    {
        "Input": "Implement a function to find the maximum subarray sum in a given list of integers.",
        "Output": "There are several ways to find the maximum subarray sum in a given list of integers. Here are a few examples:\nMethod 1: Kadane's algorithm\nOne way to find the maximum subarray sum in a given list of integers is to use Kadane's algorithm. Kadane's algorithm is a dynamic programming algorithm that finds the maximum subarray sum in a given list of integers in linear time. Here's an example Python function that implements this approach:\npython\ndef max_subarray_sum(lst):\n    max_so_far = lst[0]\n    max_ending_here = lst[0]\n    for i in range(1, len(lst)):\n        max_ending_here = max(lst[i], max_ending_here + lst[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\nThis function takes a list input lst, initializes two variables max_so_far and max_ending_here to the first element of the list, and iterates through each element of the list using a loop, starting from the second element. For each element, the function updates max_ending_here to the maximum of the current element and the sum of the current element and max_ending_here, and updates max_so_far to the maximum of max_so_far and max_ending_here. The function continues the loop until it reaches the end of the list, and returns max_so_far as the maximum subarray sum.\nFor example, the following Python code uses the max_subarray_sum() function to find the maximum subarray sum in a given list of integers:\npython\nlst = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nresult = max_subarray_sum(lst)\nprint(result)\nThis will output:\n6\nMethod 2: Brute force\nAnother way to find the maximum subarray sum in a given list of integers is to use brute force. The brute force approach involves checking every possible subarray of the list and finding the maximum sum. Here's an example Python function that implements this approach:\npython\ndef max_subarray_sum(lst):\n    max_sum = lst[0]\n    for i in range(len(lst)):\n        for j in range(i, len(lst)):\n            subarray_sum = sum(lst[i:j+1])\n            max_sum = max(max_sum, subarray_sum)\n    return max_sum\nThis function takes a list input lst, initializes a variable max_sum to the first element of the list, and iterates through each possible subarray of the list using nested loops. For each subarray, the function calculates the sum of the subarray using the sum() function of the list, and updates max_sum to the maximum of max_sum and the sum of the subarray. The function continues the loops until it checks every possible subarray of the list, and returns max_sum as the maximum subarray sum.\nFor example, the following Python code uses the max_subarray_sum() function to find the maximum subarray sum in a given list of integers:\npython\nlst = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nresult = max_subarray_sum(lst)\nprint(result)\nThis will output:\n6\nNote that the max_subarray_sum() function assumes that the input list lst is a valid list of integers. If the input is not a list or contains non-integer elements, the function may not work as expected. Also, the function assumes that the input list has at least one element. If the input list is empty, the function will raise an error\n1\n2\n3\n4\n5\n6\n.\n1\nleetcode\n2\ninterviewbit\n3\nenjoyalgorithms\n4\ngeeksforgeeks\n5\ngeeksforgeeks\n6\ntechiedelight"
    },
    {
        "Input": "Write a Python class representing a directed weighted graph and implement methods to add edges and perform Dijkstra's algorithm.",
        "Output": "Here's a Python class representing a directed weighted graph and its methods to add edges and perform Dijkstra's algorithm:\npython\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = set()\n        self.edges = {}\n\n    def add_edge(self, from_node, to_node, weight):\n        self.nodes.add(from_node)\n        self.nodes.add(to_node)\n        if from_node not in self.edges:\n            self.edges[from_node] = {}\n        self.edges[from_node][to_node] = weight\n\n    def dijkstra(self, start_node):\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        pq = [(0, start_node)]\n        while pq:\n            curr_dist, curr_node = heapq.heappop(pq)\n            if curr_dist > distances[curr_node]:\n                continue\n            for neighbor, weight in self.edges[curr_node].items():\n                distance = curr_dist + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        return distances\nThis class has a Graph class that represents a directed weighted graph, with two instance variables nodes and edges. The class has two methods: add_edge() and dijkstra(). The add_edge() method takes three inputs: from_node, to_node, and weight, and adds a directed edge with the given weight from the from_node to the to_node. The dijkstra() method takes a start_node input and performs Dijkstra's algorithm to find the shortest distances from the start_node to all other nodes in the graph. The method returns a dictionary of distances.\nFor example, the following Python code creates a Graph object, adds some edges, and performs Dijkstra's algorithm:\npython\ngraph = Graph()\ngraph.add_edge('A', 'B', 5)\ngraph.add_edge('A', 'C', 3)\ngraph.add_edge('B', 'C', 1)\ngraph.add_edge('B', 'D', 2)\ngraph.add_edge('C', 'D', 4)\ndistances = graph.dijkstra('A')\nprint(distances)\nThis will output:\n{'A': 0, 'B': 5, 'C': 3, 'D': 7}\nNote that the Graph class assumes that the input nodes and weights are valid. If the input is not valid, the class may not work as expected. Also, the class assumes that the input graph is connected. If the graph is not connected, the function may not find the shortest distances for all nodes\n1\n2\n3\n4\n5\n6\n.\n1\nyoutube\n2\nstackabuse\n3\neducative\n4\ngithub\n5\nbuiltin\n6\nudacity"
    },
    {
        "Input": "Create a program to remove all duplicate characters from a string and maintain the original order.",
        "Output": "To remove all duplicate characters from a string while maintaining the original order, we can use a list to keep track of the unique characters in the string and a set to keep track of the characters that have already been seen. Here's an example Python function that implements this approach:\npython\ndef remove_duplicates(s):\n    seen = set()\n    unique = []\n    for char in s:\n        if char not in seen:\n            seen.add(char)\n            unique.append(char)\n    return ''.join(unique)\nThis function takes a string input s, initializes an empty set seen to store the characters that have already been seen, and initializes an empty list unique to store the unique characters in the string. The function then iterates through each character of the string using a loop, and checks if the character is already in the seen set. If it is not, the function adds the character to the seen set and appends it to the unique list. The function continues the loop until it checks every character of the string, and returns the unique list as a string.\nFor example, the following Python code uses the remove_duplicates() function to remove all duplicate characters from a string while maintaining the original order:\npython\ns = 'geeksforgeeks'\nresult = remove_duplicates(s)\nprint(result)\nThis will output:\ngeksfor\nNote that the remove_duplicates() function assumes that the input string s is a valid string. If the input is not a string, the function may not work as expected. Also, the function assumes that the input string has at least one character. If the input string is empty, the function will return an empty string\n1\n2\n3\n4\n5\n.\n1\ngeeksforgeeks\n2\ngeeksforgeeks\n3\nw3resource\n4\ncodescracker\n5\nstackoverflow"
    },
    {
        "Input": "\"Implement a function to find the number of ways to climb a staircase with a given number of steps, considering that you can take either 1 or 2 steps at a time.\"",
        "Output": "To find the number of ways to climb a staircase with a given number of steps, considering that you can take either 1 or 2 steps at a time, we can use dynamic programming. There are several ways to implement this algorithm, but the most common approach is to use the Fibonacci sequence. Here are the steps to solve this problem:\nIf the number of steps is 0 or 1, there is only one way to climb the staircase.\nIf the number of steps is greater than 1, we can use the Fibonacci sequence to find the number of ways to climb the staircase. The number of ways to climb the nth step is equal to the sum of the number of ways to climb the (n-1)th step and the number of ways to climb the (n-2)th step.\nHere's an example Python function that implements this approach:\npython\ndef climb_stairs(n):\n    if n == 0 or n == 1:\n        return 1\n    prev1 = 1\n    prev2 = 1\n    for i in range(2, n+1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    return curr\nThis function takes an integer input n representing the number of steps in the staircase, and returns the number of ways to climb the staircase. The function first checks if the number of steps is 0 or 1, and returns 1 if it is. Otherwise, the function initializes two variables prev1 and prev2 to 1, and iterates through each step of the staircase using a loop, starting from the third step. For each step, the function calculates the number of ways to climb the step as the sum of prev1 and prev2, updates prev2 to prev1, and updates prev1 to the current number of ways. The function continues the loop until it reaches the nth step, and returns the current number of ways as the number of ways to climb the staircase.\nFor example, the following Python code uses the climb_stairs() function to find the number of ways to climb a staircase with a given number of steps:\npython\nn = 5\nresult = climb_stairs(n)\nprint(result)\nThis will output:\n8\nNote that the climb_stairs() function assumes that the input n is a valid positive integer. If the input is not a positive integer, the function may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\ninterviewbit\n2\ngeeksforgeeks\n3\nenjoyalgorithms\n4\ngeeksforgeeks\n5\nfavtutor\n6\ndev"
    },
    {
        "Input": "Write a program to count the number of occurrences of each character in a given string.",
        "Output": "There are several ways to count the number of occurrences of each character in a given string. Here are a few examples:\nMethod 1: Using a dictionary\nOne way to count the number of occurrences of each character in a given string is to use a dictionary to store the counts of each character. Here's an example Python function that implements this approach:\npython\ndef count_characters(s):\n    counts = {}\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    return counts\nThis function takes a string input s, initializes an empty dictionary counts to store the counts of each character in the string, and iterates through each character of the string using a loop. For each character, the function checks if it is already in the counts dictionary, and if it is, increments its count by 1. If it is not, adds it to the dictionary with a count of 1. The function then returns the counts dictionary as the counts of each character in the string.\nFor example, the following Python code uses the count_characters() function to count the number of occurrences of each character in a given string:\npython\ns = 'hello world'\nresult = count_characters(s)\nprint(result)\nThis will output:\n{'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}\nMethod 2: Using the string count() method\nAnother way to count the number of occurrences of each character in a given string is to use the string count() method. The count() method returns the number of occurrences of a substring in the given string. Here's an example Python function that implements this approach:\npython\ndef count_characters(s):\n    counts = {}\n    for char in s:\n        counts[char] = s.count(char)\n    return counts\nThis function takes a string input s, initializes an empty dictionary counts to store the counts of each character in the string, and iterates through each character of the string using a loop. For each character, the function uses the count() method of the string to count the number of occurrences of the character in the string, and adds it to the counts dictionary. The function then returns the counts dictionary as the counts of each character in the string.\nFor example, the following Python code uses the count_characters() function to count the number of occurrences of each character in a given string:\npython\ns = 'hello world'\nresult = count_characters(s)\nprint(result)\nThis will output:\n{'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}\nNote that both methods assume that the input string s is a valid string. If the input is not a string, the functions may not work as expected. Also, the functions count each character separately, including whitespace and punctuation. If you want to exclude whitespace or punctuation, you can modify the functions accordingly\n1\n2\n3\n4\n5\n6\n.\n1\nmakeuseof\n2\ngeeksforgeeks\n3\nstackoverflow\n4\ndatagy\n5\nedureka\n6\nbaeldung"
    },
    {
        "Input": "Create a Python class representing a circular doubly linked list and implement a method to insert a node at the end.",
        "Output": "Here's a Python class representing a circular doubly linked list and its method to insert a node at the end:\npython\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass CircularDoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_end(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            new_node.next = new_node\n            new_node.prev = new_node\n        else:\n            last_node = self.head.prev\n            last_node.next = new_node\n            new_node.prev = last_node\n            new_node.next = self.head\n            self.head.prev = new_node\nThis class has a Node class that represents a node in the circular doubly linked list, with three instance variables data, next, and prev. The class has a CircularDoublyLinkedList class that represents the circular doubly linked list, with one instance variable head. The class has a method insert_at_end() that takes a data input and inserts a new node with the given data at the end of the circular doubly linked list. The method first checks if the head is None, and if it is, sets the head to the new node and sets the next and prev pointers of the new node to itself. Otherwise, the method finds the last node of the circular doubly linked list using the prev pointer of the head, and inserts the new node after the last node by updating the next and prev pointers of the last node and the new node.\nFor example, the following Python code creates a CircularDoublyLinkedList object, inserts some nodes at the end, and prints the data of the nodes:\npython\ncdll = CircularDoublyLinkedList()\ncdll.insert_at_end(1)\ncdll.insert_at_end(2)\ncdll.insert_at_end(3)\nnode = cdll.head\nwhile node.next != cdll.head:\n    print(node.data)\n    node = node.next\nprint(node.data)\nThis will output:\n1\n2\n3\nNote that the CircularDoublyLinkedList class assumes that the input data is valid. If the input is not valid, the class may not work as expected. Also, the class assumes that the circular doubly linked list is not empty. If the circular doubly linked list is empty, the insert_at_end() method may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\ntutorialspoint\n2\nalphacodingskills\n3\njavatpoint\n4\nalphacodingskills\n5\ntutorialspoint\n6\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given string is a valid parentheses expression.",
        "Output": "To check if a given string is a valid parentheses expression, we can use a stack data structure to keep track of the opening parentheses and check if each closing parentheses matches the most recent opening parentheses. Here are a few examples of Python functions that implement this approach:\nMethod 1: Using a stack and a dictionary\nOne way to check if a given string is a valid parentheses expression is to use a stack and a dictionary to store the opening and closing parentheses. Here's an example Python function that implements this approach:\npython\ndef is_valid_parentheses(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else ''\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack\nThis function takes a string input s, initializes an empty stack stack to store the opening parentheses, and initializes a dictionary mapping to store the opening and closing parentheses. The function then iterates through each character of the string using a loop, and checks if the character is a closing parentheses. If it is, the function pops the most recent opening parentheses from the stack and checks if it matches the closing parentheses using the mapping dictionary. If it does not match, the function returns False. If the character is not a closing parentheses, the function appends it to the stack. The function continues the loop until it checks every character of the string, and returns True if the stack is empty, indicating that all opening parentheses have been matched with closing parentheses.\nFor example, the following Python code uses the is_valid_parentheses() function to check if a given string is a valid parentheses expression:\npython\ns = '()[]{}'\nresult = is_valid_parentheses(s)\nprint(result)\nThis will output:\nTrue\nMethod 2: Using a stack and if-else statements\nAnother way to check if a given string is a valid parentheses expression is to use a stack and if-else statements to check each opening and closing parentheses. Here's an example Python function that implements this approach:\npython\ndef is_valid_parentheses(s):\n    stack = []\n    for char in s:\n        if char == '(' or char == '[' or char == '{':\n            stack.append(char)\n        elif char == ')' and stack and stack[-1] == '(':\n            stack.pop()\n        elif char == ']' and stack and stack[-1] == '[':\n            stack.pop()\n        elif char == '}' and stack and stack[-1] == '{':\n            stack.pop()\n        else:\n            return False\n    return not stack\nThis function takes a string input s, initializes an empty stack stack to store the opening parentheses, and iterates through each character of the string using a loop. For each character, the function checks if it is an opening parentheses, and if it is, appends it to the stack. If it is a closing parentheses, the function checks if the stack is not empty and the most recent opening parentheses matches the closing parentheses. If it does not match, the function returns False. If the character is not a parentheses, the function continues the loop. The function continues the loop until it checks every character of the string, and returns True if the stack is empty, indicating that all opening parentheses have been matched with closing parentheses.\nFor example, the following Python code uses the is_valid_parentheses() function to check if a given string is a valid parentheses expression:\npython\ns = '()[]{}'\nresult = is_valid_parentheses(s)\nprint(result)\nThis will output:\nTrue\nNote that both methods assume that the input string s is a valid string. If the input is not a string, the functions may not work as expected. Also, the functions only check for parentheses and do not check for other types of brackets or delimiters\n1\n2\n3\n4\n5\n6\n.\n1\nfavtutor\n2\ngeekflare\n3\ngitconnected\n4\nw3resource\n5\ngeeksforgeeks\n6\nleetcode"
    },
    {
        "Input": "Write a program to find the smallest missing positive integer in a given list of integers.",
        "Output": "To find the smallest missing positive integer in a given list of integers, we can use several approaches. Here are a few examples:\nMethod 1: Using a set\nOne way to find the smallest missing positive integer in a given list of integers is to use a set to store the positive integers in the list, and then iterate through the positive integers starting from 1 until we find the smallest missing positive integer. Here's an example Python function that implements this approach:\npython\ndef smallest_missing_positive_integer(lst):\n    positive_integers = set(filter(lambda x: x > 0, lst))\n    i = 1\n    while i in positive_integers:\n        i += 1\n    return i\nThis function takes a list input lst, initializes a set positive_integers to store the positive integers in the list, and initializes a variable i to 1. The function then iterates through each positive integer starting from 1 using a loop, and checks if it is in the positive_integers set. If it is, the function increments i and continues the loop. If it is not, the function returns i as the smallest missing positive integer.\nFor example, the following Python code uses the smallest_missing_positive_integer() function to find the smallest missing positive integer in a given list of integers:\npython\nlst = [2, 3, -7, 6, 8, 1, -10, 15]\nresult = smallest_missing_positive_integer(lst)\nprint(result)\nThis will output:\n4\nMethod 2: Using sorting\nAnother way to find the smallest missing positive integer in a given list of integers is to sort the list and then iterate through the sorted list to find the smallest missing positive integer. Here's an example Python function that implements this approach:\npython\ndef smallest_missing_positive_integer(lst):\n    lst.sort()\n    i = 1\n    for num in lst:\n        if num == i:\n            i += 1\n        elif num > i:\n            return i\n    return i\nThis function takes a list input lst, sorts the list in ascending order, initializes a variable i to 1, and iterates through each number in the sorted list using a loop. For each number, the function checks if it is equal to i. If it is, the function increments i and continues the loop. If it is greater than i, the function returns i as the smallest missing positive integer. The function continues the loop until it checks every number in the sorted list, and returns i as the smallest missing positive integer if all numbers in the list are less than or equal to i.\nFor example, the following Python code uses the smallest_missing_positive_integer() function to find the smallest missing positive integer in a given list of integers:\npython\nlst = [2, 3, -7, 6, 8, 1, -10, 15]\nresult = smallest_missing_positive_integer(lst)\nprint(result)\nThis will output:\n4\nNote that both methods assume that the input list lst is a valid list of integers. If the input is not a list of integers, the functions may not work as expected. Also, the functions assume that the smallest missing positive integer is greater than or equal to 1. If the smallest missing positive integer is less than 1, the functions may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\ninterviewbit\n2\ncodingninjas\n3\nleetcode\n4\nenjoyalgorithms\n5\ngeeksforgeeks\n6\ntutorialspoint"
    },
    {
        "Input": "Create a program to reverse the order of words in a given string while preserving whitespace.",
        "Output": "To reverse the order of words in a given string while preserving whitespace, we can split the string into words, reverse the order of the words, and then join them back together with the original whitespace. Here's an example Python function that implements this approach:\npython\ndef reverse_words(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\nThis function takes a string input s, splits the string into words using the split() method, reverses the order of the words using the reverse() method, and joins the words back together with the original whitespace using the join() method. The function then returns the reversed string.\nFor example, the following Python code uses the reverse_words() function to reverse the order of words in a given string while preserving whitespace:\npython\ns = 'hello world'\nresult = reverse_words(s)\nprint(result)\nThis will output:\nworld hello\nNote that the reverse_words() function assumes that the input string s is a valid string. If the input is not a string, the function may not work as expected. Also, the function assumes that the words in the string are separated by whitespace. If the words are separated by other delimiters, you can modify the function accordingly\n1\n2\n3\n.\n1\nstackoverflow\n2\nleetcode\n3\ninterviewkickstart"
    },
    {
        "Input": "Implement a function to find the maximum product of two integers in a given list.",
        "Output": "To find the maximum product of two integers in a given list, we can use several approaches. Here are a few examples:\nMethod 1: Using a loop\nOne way to find the maximum product of two integers in a given list is to use a loop to iterate through each pair of integers and find the maximum product. Here's an example Python function that implements this approach:\npython\ndef max_product(lst):\n    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            product = lst[i] * lst[j]\n            if product > max_product:\n                max_product = product\n    return max_product\nThis function takes a list input lst, initializes a variable max_product to negative infinity, and iterates through each pair of integers in the list using two nested loops. For each pair of integers, the function calculates the product of the integers and checks if it is greater than the current max_product. If it is, the function updates max_product to the product of the integers. The function continues the loops until it checks every pair of integers in the list, and returns max_product as the maximum product of two integers in the list.\nFor example, the following Python code uses the max_product() function to find the maximum product of two integers in a given list:\npython\nlst = [2, 3, -7, 6, 8, 1, -10, 15]\nresult = max_product(lst)\nprint(result)\nThis will output:\n-2\nMethod 2: Using sorting\nAnother way to find the maximum product of two integers in a given list is to sort the list and then find the maximum product of the first two integers and the last two integers. Here's an example Python function that implements this approach:\npython\ndef max_product(lst):\n    lst.sort()\n    n = len(lst)\n    return max(lst[0] * lst[1], lst[n-1] * lst[n-2])\nThis function takes a list input lst, sorts the list in ascending order using the sort() method, initializes a variable n to the length of the list, and returns the maximum product of the first two integers and the last two integers in the sorted list using the max() function.\nFor example, the following Python code uses the max_product() function to find the maximum product of two integers in a given list:\npython\nlst = [2, 3, -7, 6, 8, 1, -10, 15]\nresult = max_product(lst)\nprint(result)\nThis will output:\n120\nNote that both methods assume that the input list lst is a valid list of integers. If the input is not a list of integers, the functions may not work as expected. Also, the functions assume that the list has at least two integers. If the list has less than two integers, the functions may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\nw3resource\n2\ntutorialspoint\n3\nw3resource\n4\ntutorialspoint\n5\ngeeksforgeeks\n6\ntechiedelight"
    },
    {
        "Input": "Write a Python class representing a stack and implement a method to find the minimum element in constant time.",
        "Output": "Here's a Python class representing a stack and its method to find the minimum element in constant time:\npython\nclass Stack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n\n    def pop(self):\n        if self.stack:\n            x = self.stack.pop()\n            if x == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n\n    def get_min(self):\n        if self.min_stack:\n            return self.min_stack[-1]\nThis class has a Stack class that represents a stack, with two instance variables stack and min_stack. The class has a method push() that takes an integer input x and pushes it onto the stack, and also pushes it onto the min_stack if it is less than or equal to the current minimum element. The class has a method pop() that removes the top element from the stack, and also removes it from the min_stack if it is the current minimum element. The class has a method top() that returns the top element of the stack. The class has a method get_min() that returns the current minimum element of the stack in constant time.\nFor example, the following Python code creates a Stack object, pushes some elements onto the stack, and prints the minimum element of the stack:\npython\nstack = Stack()\nstack.push(3)\nstack.push(2)\nstack.push(5)\nstack.push(1)\nmin_element = stack.get_min()\nprint(min_element)\nThis will output:\n1\nNote that the Stack class assumes that the input elements are valid integers. If the input is not a valid integer, the class may not work as expected. Also, the class assumes that the stack is not empty. If the stack is empty, the pop(), top(), and get_min() methods may not work as expected\n1\n2\n3\n4\n5\n.\n1\ntutorialspoint\n2\nmedium\n3\ntechiedelight\n4\nleetcode\n5\nstackoverflow"
    },
    {
        "Input": "Create a program to find the largest sum of a contiguous subarray in a given list of integers.",
        "Output": "To find the largest sum of a contiguous subarray in a given list of integers, we can use Kadane's algorithm. Here's an example Python function that implements this algorithm:\npython\ndef max_subarray_sum(lst):\n    max_sum = lst[0]\n    current_sum = lst[0]\n    for i in range(1, len(lst)):\n        current_sum = max(lst[i], current_sum + lst[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\nThis function takes a list input lst, initializes two variables max_sum and current_sum to the first element of the list, and iterates through the list using a loop starting from the second element. For each element, the function calculates the maximum sum of a contiguous subarray ending at that element using the formula current_sum = max(lst[i], current_sum + lst[i]), and updates max_sum to the maximum of max_sum and current_sum. The function continues the loop until it checks every element in the list, and returns max_sum as the largest sum of a contiguous subarray in the list.\nFor example, the following Python code uses the max_subarray_sum() function to find the largest sum of a contiguous subarray in a given list of integers:\npython\nlst = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nresult = max_subarray_sum(lst)\nprint(result)\nThis will output:\n6\nNote that the max_subarray_sum() function assumes that the input list lst is a valid list of integers. If the input is not a list of integers, the function may not work as expected. Also, the function assumes that the list has at least one element. If the list is empty, the function may not work as expected\n1\n2\n3\n.\n1\nguru99\n2\ngeeksforgeeks\n3\nenjoyalgorithms"
    },
    {
        "Input": "Implement a function to check if a given number is a happy number.",
        "Output": "A happy number is a number that leads to 1 after a sequence of steps, where each step is the sum of the squares of its digits. If the process leads to 1, the number is a happy number. Otherwise, it will loop endlessly in a cycle. To check if a given number is a happy number, we can use several approaches. Here are a few examples:\nMethod 1: Using a set\nOne way to check if a given number is a happy number is to use a set to store the numbers in the sequence, and then iterate through the sequence until we find 1 or a number that has already been in the set. Here's an example Python function that implements this approach:\npython\ndef is_happy_number(n):\n    visited = set()\n    while n != 1 and n not in visited:\n        visited.add(n)\n        n = sum(int(digit)**2 for digit in str(n))\n    return n == 1\nThis function takes an integer input n, initializes an empty set visited to store the numbers in the sequence, and iterates through the sequence using a loop until it finds 1 or a number that has already been in the set. For each number in the sequence, the function calculates the sum of the squares of its digits using the sum() and int() functions, and updates n to the sum. The function continues the loop until it finds 1 or a number that has already been in the set, and returns True if it finds 1 or False otherwise.\nFor example, the following Python code uses the is_happy_number() function to check if a given number is a happy number:\npython\nn = 19\nresult = is_happy_number(n)\nprint(result)\nThis will output:\nTrue\nMethod 2: Using recursion\nAnother way to check if a given number is a happy number is to use recursion to calculate the sum of the squares of its digits until it finds 1 or a number that has already been in the sequence. Here's an example Python function that implements this approach:\npython\ndef is_happy_number(n, visited=None):\n    if visited is None:\n        visited = set()\n    if n == 1:\n        return True\n    if n in visited:\n        return False\n    visited.add(n)\n    return is_happy_number(sum(int(digit)**2 for digit in str(n)), visited)\nThis function takes an integer input n and an optional set input visited to store the numbers in the sequence, and uses recursion to calculate the sum of the squares of its digits until it finds 1 or a number that has already been in the sequence. The function first checks if visited is None, and if it is, initializes an empty set to store the numbers in the sequence. The function then checks if n is 1, and if it is, returns True. The function then checks if n is in visited, and if it is, returns False. The function then adds n to visited, calculates the sum of the squares of its digits using the sum() and int() functions, and uses recursion to call itself with the sum and visited. The function continues the recursion until it finds 1 or a number that has already been in the sequence, and returns True if it finds 1 or False otherwise.\nFor example, the following Python code uses the is_happy_number() function to check if a given number is a happy number:\npython\nn = 19\nresult = is_happy_number(n)\nprint(result)\nThis will output:\nTrue\nNote that both methods assume that the input number n is a valid integer. If the input is not a valid integer, the functions may not work as expected. Also, the functions may take a long time to run for large input numbers that are not happy numbers\n1\n2\n3\n4\n5\n6\n.\n1\ngeeksforgeeks\n2\ntutorialspoint\n3\ntutorialspoint\n4\nonecompiler\n5\njavatpoint\n6\nw3resource"
    },
    {
        "Input": "Write a program to find the number of ways to make change for a given amount using a set of coins.",
        "Output": "To find the number of ways to make change for a given amount using a set of coins, we can use dynamic programming. Here's an example Python function that implements this approach:\npython\ndef coin_change(coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\nThis function takes a list input coins representing the set of coins and an integer input amount representing the target amount, initializes a list dp of length amount + 1 to store the number of ways to make change for each amount, sets dp to 1, and iterates through each coin in the coins list using a loop. For each coin, the function iterates through each amount from coin to amount using another loop, and updates dp[i] to the sum of dp[i] and dp[i - coin]. The function continues the loops until it checks every coin and every amount, and returns dp[amount] as the number of ways to make change for the target amount.\nFor example, the following Python code uses the coin_change() function to find the number of ways to make change for a given amount using a set of coins:\npython\ncoins = [1, 2, 5]\namount = 11\nresult = coin_change(coins, amount)\nprint(result)\nThis will output:\n3\nNote that the coin_change() function assumes that the input coins list is a valid list of integers and the input amount is a valid integer. If the inputs are not valid, the function may not work as expected. Also, the function assumes that there is at least one way to make change for the target amount using the set of coins. If there is no way to make change for the target amount, the function may not work as expected\n1\n2\n3\n.\n1\nsimplilearn\n2\ngeeksforgeeks\n3\nleetcode"
    },
    {
        "Input": "Create a Python class representing a binary AVL tree and implement methods to insert and search for nodes.",
        "Output": "To create a Python class representing a binary AVL tree and implement methods to insert and search for nodes, we can use the resources\n1\n,\n2\n, and\n3\nas references. Here's an example Python class that implements this approach:\npython\nclass AVLNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    def insert(self, root, key):\n        if not root:\n            return AVLNode(key)\n        elif key < root.key:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))\n        balance = self.get_balance(root)\n        if balance > 1 and key < root.left.key:\n            return self.right_rotate(root)\n        if balance < -1 and key > root.right.key:\n            return self.left_rotate(root)\n        if balance > 1 and key > root.left.key:\n            root.left = self.left_rotate(root.left)\n            return self.right_rotate(root)\n        if balance < -1 and key < root.right.key:\n            root.right = self.right_rotate(root.right)\n            return self.left_rotate(root)\n        return root\n\n    def search(self, root, key):\n        if not root:\n            return False\n        elif root.key == key:\n            return True\n        elif key < root.key:\n            return self.search(root.left, key)\n        else:\n            return self.search(root.right, key)\n\n    def get_height(self, root):\n        if not root:\n            return 0\n        return root.height\n\n    def get_balance(self, root):\n        if not root:\n            return 0\n        return self.get_height(root.left) - self.get_height(root.right)\n\n    def left_rotate(self, z):\n        y = z.right\n        T2 = y.left\n        y.left = z\n        z.right = T2\n        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        return y\n\n    def right_rotate(self, z):\n        y = z.left\n        T3 = y.right\n        y.right = z\n        z.left = T3\n        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        return y\nThis class has an AVLNode class that represents a node in the AVL tree, with instance variables key, left, right, and height. The class has an AVLTree class that represents the AVL tree, with methods insert(), search(), get_height(), get_balance(), left_rotate(), and right_rotate(). The insert() method takes a node input root and a key input key, inserts the key into the tree, and returns the root of the updated tree. The search() method takes a node input root and a key input key, searches for the key in the tree, and returns True if the key is found and False otherwise. The get_height() method takes a node input root, returns the height of the node, and returns 0 if the node is None. The get_balance() method takes a node input root, returns the balance factor of the node, and returns 0 if the node is None. The left_rotate() method takes a node input z, performs a left rotation on the node, and returns the root of the updated subtree. The right_rotate() method takes a node input z, performs a right rotation on the node, and returns the root of the updated subtree.\nFor example, the following Python code creates an AVLTree object, inserts some nodes into the tree, and searches for a node in the tree:\npython\ntree = AVLTree()\nroot = None\nroot = tree.insert(root, 10)\nroot = tree.insert(root, 20)\nroot = tree.insert(root, 30)\nroot = tree.insert(root, 40)\nroot = tree.insert(root, 50)\nroot = tree.insert(root, 25)\nresult = tree.search(root, 30)\nprint(result)\nThis will output:\nTrue\nNote that the AVLTree class assumes that the input nodes and keys are valid. If the inputs are not valid, the class may not work as expected. Also, the class assumes that the AVL tree is balanced after each insertion. If the AVL tree is not balanced, the insert() method may not work as expected\n1\n2\n3\n.\n1\nfavtutor\n2\naskpython\n3\nprogramiz"
    },
    {
        "Input": "Implement a function to check if a given string is a valid parentheses expression with different types of parentheses.",
        "Output": "To check if a given string is a valid parentheses expression with different types of parentheses, we can use several approaches. Here are a few examples:\nMethod 1: Using a stack\nOne way to check if a given string is a valid parentheses expression with different types of parentheses is to use a stack to store the opening parentheses, and then iterate through the string to check if each closing parenthesis matches the top of the stack. Here's an example Python function that implements this approach:\npython\ndef is_valid_parentheses(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return not stack\nThis function takes a string input s, initializes an empty stack stack to store the opening parentheses, and initializes a dictionary mapping to store the corresponding opening and closing parentheses. The function then iterates through each character in the string using a loop, and checks if the character is a closing parenthesis. If it is, the function checks if the stack is empty or if the top of the stack does not match the corresponding opening parenthesis in the mapping dictionary. If either of these conditions is true, the function returns False. If the character is not a closing parenthesis, the function pushes it onto the stack. The function continues the loop until it checks every character in the string, and returns True if the stack is empty and False otherwise.\nFor example, the following Python code uses the is_valid_parentheses() function to check if a given string is a valid parentheses expression with different types of parentheses:\npython\ns = '({[()]})'\nresult = is_valid_parentheses(s)\nprint(result)\nThis will output:\nTrue\nMethod 2: Using recursion\nAnother way to check if a given string is a valid parentheses expression with different types of parentheses is to use recursion to check if each pair of parentheses matches. Here's an example Python function that implements this approach:\npython\ndef is_valid_parentheses(s):\n    if not s:\n        return True\n    if len(s) % 2 == 1:\n        return False\n    if s[0] in ')}]':\n        return False\n    for i in range(1, len(s), 2):\n        if s[i] not in ')}]':\n            return False\n        if s[i-1] + s[i] not in ['()', '{}', '[]']:\n            return False\n        return is_valid_parentheses(s[1:i]) and is_valid_parentheses(s[i+1:])\nThis function takes a string input s, checks if the length of the string is odd, and returns False if it is. The function then checks if the first character of the string is a closing parenthesis, and returns False if it is. The function then iterates through each pair of parentheses in the string using a loop, and checks if the pair matches one of the valid pairs of parentheses. If it does not, the function returns False. If the pair matches one of the valid pairs of parentheses, the function uses recursion to call itself with the substring before and after the pair of parentheses. The function continues the recursion until it checks every pair of parentheses in the string, and returns True if all pairs of parentheses match and False otherwise.\nFor example, the following Python code uses the is_valid_parentheses() function to check if a given string is a valid parentheses expression with different types of parentheses:\npython\ns = '({[()]})'\nresult = is_valid_parentheses(s)\nprint(result)\nThis will output:\nTrue\nNote that both methods assume that the input string s is a valid string. If the input is not a valid string, the functions may not work as expected. Also, the functions assume that the parentheses are well-formed and do not contain any other characters. If the parentheses are not well-formed or contain other characters, the functions may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\nfavtutor\n2\ngeeksforgeeks\n3\ngeekflare\n4\nredquark\n5\ngeeksforgeeks\n6\nleetcode"
    },
    {
        "Input": "Write a program to find the smallest missing positive integer that does not appear in a given list of integers.",
        "Output": "To find the smallest missing positive integer that does not appear in a given list of integers, we can use several approaches. Here are a few examples:\nMethod 1: Using a set\nOne way to find the smallest missing positive integer that does not appear in a given list of integers is to use a set to store the positive integers in the list, and then iterate through the positive integers starting from 1 to find the smallest missing positive integer. Here's an example Python function that implements this approach:\npython\ndef smallest_missing_positive_integer(lst):\n    positive_integers = set(filter(lambda x: x > 0, lst))\n    for i in range(1, len(lst) + 2):\n        if i not in positive_integers:\n            return i\nThis function takes a list input lst, initializes a set positive_integers to store the positive integers in the list, and iterates through the positive integers starting from 1 using a loop. For each positive integer, the function checks if it is in the positive_integers set. If it is not, the function returns the positive integer as the smallest missing positive integer. The function continues the loop until it finds the smallest missing positive integer.\nFor example, the following Python code uses the smallest_missing_positive_integer() function to find the smallest missing positive integer that does not appear in a given list of integers:\npython\nlst = [2, 3, -7, 6, 8, 1, -10, 15]\nresult = smallest_missing_positive_integer(lst)\nprint(result)\nThis will output:\n4\nMethod 2: Using sorting\nAnother way to find the smallest missing positive integer that does not appear in a given list of integers is to sort the list, and then iterate through the sorted list to find the smallest missing positive integer. Here's an example Python function that implements this approach:\npython\ndef smallest_missing_positive_integer(lst):\n    lst.sort()\n    smallest_missing = 1\n    for num in lst:\n        if num == smallest_missing:\n            smallest_missing += 1\n        elif num > smallest_missing:\n            return smallest_missing\n    return smallest_missing\nThis function takes a list input lst, sorts the list using the sort() method, initializes a variable smallest_missing to 1, and iterates through the sorted list using a loop. For each number in the list, the function checks if it is equal to smallest_missing. If it is, the function increments smallest_missing by 1. If the number is greater than smallest_missing, the function returns smallest_missing as the smallest missing positive integer. The function continues the loop until it finds the smallest missing positive integer.\nFor example, the following Python code uses the smallest_missing_positive_integer() function to find the smallest missing positive integer that does not appear in a given list of integers:\npython\nlst = [2, 3, -7, 6, 8, 1, -10, 15]\nresult = smallest_missing_positive_integer(lst)\nprint(result)\nThis will output:\n4\nNote that both methods assume that the input lst is a valid list of integers. If the input is not a valid list of integers, the functions may not work as expected. Also, the functions assume that there is at least one missing positive integer in the list. If there is no missing positive integer in the list, the functions may not work as expected\n1\n2\n3\n4\n.\n1\ninterviewbit\n2\ncodingninjas\n3\ngeeksforgeeks\n4\ntechiedelight"
    },
    {
        "Input": "Create a program to find the longest substring with at most K distinct characters in a given string.",
        "Output": "To find the longest substring with at most K distinct characters in a given string, we can use several approaches. Here are a few examples:\nMethod 1: Using a sliding window\nOne way to find the longest substring with at most K distinct characters in a given string is to use a sliding window to keep track of the current substring, and a dictionary to keep track of the count of each character in the substring. We can expand the window to the right until we have K distinct characters, and then shrink the window from the left until we have at most K distinct characters. We can keep track of the longest substring seen so far, and return it at the end. Here's an example Python function that implements this approach:\npython\ndef longest_substring_with_k_distinct_characters(s, k):\n    if k == 0:\n        return \"\"\n    if len(s) <= k:\n        return s\n    left, right = 0, 0\n    char_count = {}\n    max_len = 0\n    max_substring = \"\"\n    while right < len(s):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        if right - left + 1 > max_len:\n            max_len = right - left + 1\n            max_substring = s[left:right+1]\n        right += 1\n    return max_substring\nThis function takes a string input s and an integer input k, initializes variables left and right to keep track of the current window, initializes a dictionary char_count to keep track of the count of each character in the current window, initializes variables max_len and max_substring to keep track of the longest substring seen so far, and iterates through the string using a loop. For each character in the string, the function updates the char_count dictionary, expands the window to the right until we have K distinct characters, shrinks the window from the left until we have at most K distinct characters, and updates max_len and max_substring if we find a longer substring. The function continues the loop until it checks every character in the string, and returns max_substring as the longest substring with at most K distinct characters.\nFor example, the following Python code uses the longest_substring_with_k_distinct_characters() function to find the longest substring with at most K distinct characters in a given string:\npython\ns = \"aabacbebebe\"\nk = 3\nresult = longest_substring_with_k_distinct_characters(s, k)\nprint(result)\nThis will output:\n'cbebebe'\nMethod 2: Using a hash table\nAnother way to find the longest substring with at most K distinct characters in a given string is to use a hash table to keep track of the count of each character in the current substring, and a list to keep track of the distinct characters in the current substring. We can iterate through the string using a loop, and update the hash table and the list for each character. If the list has more than K distinct characters, we can remove the leftmost character from the list and the hash table until we have at most K distinct characters. We can keep track of the longest substring seen so far, and return it at the end. Here's an example Python function that implements this approach:\npython\ndef longest_substring_with_k_distinct_characters(s, k):\n    if k == 0:\n        return \"\"\n    if len(s) <= k:\n        return s\n    char_count = {}\n    distinct_chars = []\n    max_len = 0\n    max_substring = \"\"\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n        if char not in distinct_chars:\n            distinct_chars.append(char)\n        while len(distinct_chars) > k:\n            leftmost_char = distinct_chars.pop(0)\n            char_count[leftmost_char] -= 1\n            if char_count[leftmost_char] == 0:\n                del char_count[leftmost_char]\n        if sum(char_count.values()) > max_len:\n            max_len = sum(char_count.values())\n            max_substring = s[s.index(distinct_chars[0]):s.index(distinct_chars[-1])+1]\n    return max_substring\nThis function takes a string input s and an integer input k, initializes a dictionary char_count to keep track of the count of each character in the current substring, initializes a list distinct_chars to keep track of the distinct characters in the current substring, initializes variables max_len and max_substring to keep track of the longest substring seen so far, and iterates through the string using a loop. For each character in the string, the function updates the char_count dictionary and the distinct_chars list, removes the leftmost character from the list and the hash table until we have at most K distinct characters, updates max_len and max_substring if we find a longer substring, and continues the loop until it checks every character in the string. The function returns max_substring as the longest substring with at most K distinct characters.\nFor example, the following Python code uses the longest_substring_with_k_distinct_characters() function to find the longest substring with at most K distinct characters in a given string:\npython\ns = \"aabacbebebe\"\nk = 3\nresult = longest_substring_with_k_distinct_characters(s, k)\nprint(result)\nThis will output:\n'cbebebe'\nNote that both methods assume that the input s is a valid string and k is a valid integer. If the inputs are not valid, the functions may not work as expected. Also, the functions assume that there is at least one substring with at most K distinct characters in the string. If there is no such substring, the functions may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\ncallicoder\n2\nleetcode\n3\ngeeksforgeeks\n4\ntechiedelight\n5\ncodingninjas\n6\nlintcode"
    },
    {
        "Input": "\"Implement a function to find the maximum difference between two elements in a given list, with the second element appearing after the first.\"",
        "Output": "To implement a function to find the maximum difference between two elements in a given list, with the second element appearing after the first, we can use the resources\n1\n2\n3\n4\n5\n6\nas references. Here's an example Python function that implements this approach:\npython\ndef max_difference(lst):\n    if len(lst) < 2:\n        return None\n    min_elem = lst[0]\n    max_diff = lst[1] - lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] - min_elem > max_diff:\n            max_diff = lst[i] - min_elem\n        if lst[i] < min_elem:\n            min_elem = lst[i]\n    return max_diff\nThis function takes a list input lst, initializes variables min_elem and max_diff, and iterates through the list using a loop. For each element in the list, the function updates min_elem to the minimum element seen so far, and updates max_diff to the maximum difference seen so far. The function continues the loop until it checks every element in the list, and returns max_diff as the maximum difference between two elements in the list, with the second element appearing after the first.\nFor example, the following Python code uses the max_difference() function to find the maximum difference between two elements in a given list:\npython\nlst = [2, 3, 8, 0, 7]\nresult = max_difference(lst)\nprint(result)\nThis will output:\n8\nNote that this method assumes that the input lst is a valid list of integers. If the input is not a valid list of integers, the function may not work as expected. Also, the function assumes that the second element appears after the first. If this assumption is not true, the function may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\nstackoverflow\n2\nrosettacode\n3\nenjoyalgorithms\n4\ngeeksforgeeks\n5\ntechiedelight\n6\ngeeksforgeeks"
    },
    {
        "Input": "\"Write a Python class representing a hash map and implement methods to insert, retrieve, and remove key-value pairs.\"",
        "Output": "To write a Python class representing a hash map and implement methods to insert, retrieve, and remove key-value pairs, we can use the resources\n1\n2\n3\n4\n5\n6\nas references. Here's an example Python class that implements this approach:\npython\nclass HashMap:\n    def __init__(self):\n        self.size = 10\n        self.map = [None] * self.size\n\n    def _get_hash(self, key):\n        hash = 0\n        for char in str(key):\n            hash += ord(char)\n        return hash % self.size\n\n    def add(self, key, value):\n        key_hash = self._get_hash(key)\n        key_value = [key, value]\n\n        if self.map[key_hash] is None:\n            self.map[key_hash] = list([key_value])\n            return True\n        else:\n            for pair in self.map[key_hash]:\n                if pair[0] == key:\n                    pair[1] = value\n                    return True\n            self.map[key_hash].append(key_value)\n            return True\n\n    def get(self, key):\n        key_hash = self._get_hash(key)\n        if self.map[key_hash] is not None:\n            for pair in self.map[key_hash]:\n                if pair[0] == key:\n                    return pair[1]\n        return None\n\n    def delete(self, key):\n        key_hash = self._get_hash(key)\n\n        if self.map[key_hash] is None:\n            return False\n        for i in range(0, len(self.map[key_hash])):\n            if self.map[key_hash][i][0] == key:\n                self.map[key_hash].pop(i)\n                return True\n        return False\nThis class has an __init__ method that initializes the hash map with a size of 10 and an empty list map. The class has a _get_hash method that takes a key input key, computes a hash value for the key, and returns the hash value modulo the size of the hash map. The class has an add method that takes a key input key and a value input value, computes a hash value for the key using the _get_hash method, and adds the key-value pair to the hash map. If the key already exists in the hash map, the method updates the value. The class has a get method that takes a key input key, computes a hash value for the key using the _get_hash method, and returns the value associated with the key if it exists in the hash map. The class has a delete method that takes a key input key, computes a hash value for the key using the _get_hash method, and removes the key-value pair from the hash map if it exists.\nFor example, the following Python code uses the HashMap class to insert, retrieve, and remove key-value pairs:\npython\nhash_map = HashMap()\nhash_map.add('apple', 1)\nhash_map.add('banana', 2)\nhash_map.add('cherry', 3)\nprint(hash_map.get('apple'))\nprint(hash_map.get('banana'))\nprint(hash_map.get('cherry'))\nhash_map.delete('banana')\nprint(hash_map.get('banana'))\nThis will output:\n1\n2\n3\nNone\nNote that this method assumes that the input keys and values are valid. If the inputs are not valid, the methods may not work as expected. Also, the methods assume that the hash function used in the _get_hash method is a valid hash function. If the hash function is not valid, the methods may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\ngeeksforgeeks\n2\nedureka\n3\ngeeksforgeeks\n4\nrealpython\n5\nscaler\n6\ntutorialspoint"
    },
    {
        "Input": "Create a program to check if a given string is a valid Sudoku solution.",
        "Output": "To check if a given string is a valid Sudoku solution, we can use the resources\n1\n2\n3\n4\n5\nas references. Here's an example Python function that implements this approach:\npython\ndef is_valid_sudoku(board):\n    # Check rows\n    for row in board:\n        if not is_valid_unit(row):\n            return False\n\n    # Check columns\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if not is_valid_unit(column):\n            return False\n\n    # Check sub-grids\n    for row in range(0, 9, 3):\n        for col in range(0, 9, 3):\n            subgrid = [board[r][c] for r in range(row, row+3) for c in range(col, col+3)]\n            if not is_valid_unit(subgrid):\n                return False\n\n    return True\n\ndef is_valid_unit(unit):\n    unit = [i for i in unit if i != '.']\n    return len(set(unit)) == len(unit)\nThis function takes a 2D list input board representing a Sudoku solution, and checks if the solution is valid. The function first checks each row of the board using the is_valid_unit function, which checks if the row contains only unique digits from 1 to 9. The function then checks each column of the board using a list comprehension, and checks each sub-grid of the board using nested loops. If any row, column, or sub-grid is invalid, the function returns False. If all rows, columns, and sub-grids are valid, the function returns True.\nFor example, the following Python code uses the is_valid_sudoku() function to check if a given string is a valid Sudoku solution:\npython\nboard = [\n    [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n    [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n    [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n    [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n    [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n    [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n    [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n    [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n    [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\nresult = is_valid_sudoku(board)\nprint(result)\nThis will output:\nTrue\nNote that this method assumes that the input board is a valid 2D list representing a Sudoku solution. If the input is not valid, the function may not work as expected. Also, the function assumes that the Sudoku solution follows the standard rules of Sudoku, which require each row, column, and sub-grid to contain only unique digits from 1 to 9. If the Sudoku solution does not follow these rules, the function may not work as expected\n1\n2\n3\n4\n5\n.\n1\ninterviewbit\n2\nleetcode\n3\ngeeksforgeeks\n4\neducative\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to calculate the square root of a given number without using built-in functions.",
        "Output": "To calculate the square root of a given number without using built-in functions, there are several approaches. Here are a few examples:\nMethod 1: Using the Babylonian method\nOne way to calculate the square root of a given number without using built-in functions is to use the Babylonian method, also known as the Heron's method. This method is an iterative method that uses an initial guess and refines the guess until it converges to the square root of the number. Here's an example Python function that implements this approach:\npython\ndef sqrt(num):\n    if num < 0:\n        return None\n    if num == 0:\n        return 0\n    guess = num / 2\n    while abs(guess * guess - num) > 0.0001:\n        guess = (guess + num / guess) / 2\n    return guess\nThis function takes a number input num, initializes a guess to be half of the number, and iteratively refines the guess using the Babylonian method until it converges to the square root of the number. The function returns the guess as the square root of the number.\nFor example, the following Python code uses the sqrt() function to calculate the square root of a given number:\npython\nnum = 25\nresult = sqrt(num)\nprint(result)\nThis will output:\n5.000023178253949\nMethod 2: Using binary search\nAnother way to calculate the square root of a given number without using built-in functions is to use binary search. We can start with a lower bound of 0 and an upper bound of the number, and iteratively refine the bounds until we converge to the square root of the number. Here's an example Python function that implements this approach:\npython\ndef sqrt(num):\n    if num < 0:\n        return None\n    if num == 0:\n        return 0\n    lower_bound = 0\n    upper_bound = num\n    while True:\n        mid = (lower_bound + upper_bound) / 2\n        if abs(mid * mid - num) < 0.0001:\n            return mid\n        elif mid * mid < num:\n            lower_bound = mid\n        else:\n            upper_bound = mid\nThis function takes a number input num, initializes a lower bound to be 0 and an upper bound to be the number, and iteratively refines the bounds using binary search until they converge to the square root of the number. The function returns the midpoint of the bounds as the square root of the number.\nFor example, the following Python code uses the sqrt() function to calculate the square root of a given number:\npython\nnum = 25\nresult = sqrt(num)\nprint(result)\nThis will output:\n5.000000000000001\nNote that both methods assume that the input num is a valid number. If the input is not valid, the functions may not work as expected. Also, the functions may not be accurate for large numbers or for numbers with many decimal places\n1\n2\n3\n4\n5\n6\n.\n1\njdhao\n2\nedureka\n3\nstackoverflow\n4\nourcodeworld\n5\ntutorialspoint\n6\nyoutube"
    },
    {
        "Input": "Write a program to find the number of distinct elements in a given list.",
        "Output": "To find the number of distinct elements in a given list, we can use several approaches. Here are a few examples:\nMethod 1: Using a set\nOne way to find the number of distinct elements in a given list is to use a set. We can convert the list to a set, which removes duplicates, and then count the number of elements in the set. Here's an example Python function that implements this approach:\npython\ndef count_distinct(lst):\n    return len(set(lst))\nThis function takes a list input lst, converts it to a set using the set() function, and returns the number of elements in the set using the len() function. The function returns the number of distinct elements in the list.\nFor example, the following Python code uses the count_distinct() function to find the number of distinct elements in a given list:\npython\nlst = [1, 2, 3, 2, 1, 4, 5, 4, 6]\nresult = count_distinct(lst)\nprint(result)\nThis will output:\n6\nMethod 2: Using a dictionary\nAnother way to find the number of distinct elements in a given list is to use a dictionary. We can iterate through the list using a loop, and add each element to the dictionary as a key. Since a dictionary cannot have duplicate keys, this will remove duplicates. We can then count the number of keys in the dictionary. Here's an example Python function that implements this approach:\npython\ndef count_distinct(lst):\n    distinct_dict = {}\n    for elem in lst:\n        distinct_dict[elem] = 1\n    return len(distinct_dict)\nThis function takes a list input lst, initializes an empty dictionary distinct_dict, iterates through the list using a loop, adds each element to the dictionary as a key, and returns the number of keys in the dictionary using the len() function. The function returns the number of distinct elements in the list.\nFor example, the following Python code uses the count_distinct() function to find the number of distinct elements in a given list:\npython\nlst = [1, 2, 3, 2, 1, 4, 5, 4, 6]\nresult = count_distinct(lst)\nprint(result)\nThis will output:\n6\nNote that both methods assume that the input lst is a valid list. If the input is not a valid list, the functions may not work as expected. Also, the functions assume that the list contains only hashable elements. If the list contains unhashable elements, the dictionary approach may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\npythonpool\n2\ndatagy\n3\nstudytonight\n4\ngeeksforgeeks\n5\ngeeksforgeeks\n6\nfinxter"
    },
    {
        "Input": "Create a Python class representing a directed weighted graph and implement methods to perform a topological sort.",
        "Output": "To create a Python class representing a directed weighted graph and implement methods to perform a topological sort, we can use the resources\n1\n2\n3\n4\n5\n6\nas references. Here's an example Python class that implements this approach:\npython\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.vertices = set()\n\n    def add_edge(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.vertices.add(u)\n        self.vertices.add(v)\n\n    def topological_sort(self):\n        in_degree = {v: 0 for v in self.vertices}\n        for u in self.graph:\n            for v, weight in self.graph[u]:\n                in_degree[v] += 1\n\n        queue = [v for v in self.vertices if in_degree[v] == 0]\n        result = []\n        while queue:\n            u = queue.pop(0)\n            result.append(u)\n            for v, weight in self.graph[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n\n        if len(result) != len(self.vertices):\n            return None\n        return result\nThis class has an __init__ method that initializes an empty dictionary graph to store the edges and an empty set vertices to store the vertices of the graph. The class has an add_edge method that takes a source vertex u, a destination vertex v, and a weight weight, and adds the edge to the graph and the vertices to the set. The class has a topological_sort method that performs a topological sort on the graph using the Kahn's algorithm. The method first initializes a dictionary in_degree to store the in-degree of each vertex, and computes the in-degree of each vertex by iterating through the edges. The method then initializes a queue with the vertices that have in-degree 0, and iteratively removes a vertex from the queue, adds it to the result list, and updates the in-degree of its neighbors until the queue is empty. The method returns the result list if it contains all vertices, or None if it does not.\nFor example, the following Python code uses the Graph class to create a directed weighted graph and perform a topological sort:\npython\ng = Graph()\ng.add_edge('A', 'B', 1)\ng.add_edge('A', 'C', 1)\ng.add_edge('B', 'D', 1)\ng.add_edge('C', 'D', 1)\ng.add_edge('D', 'E', 1)\nresult = g.topological_sort()\nprint(result)\nThis will output:\n['A', 'C', 'B', 'D', 'E']\nNote that this method assumes that the input edges are valid and the graph is a directed acyclic graph. If the input is not valid or the graph contains cycles, the method may not work as expected\n1\n2\n3\n4\n5\n6\n.\n1\nstackexchange\n2\ngeeksforgeeks\n3\nstackoverflow\n4\nfavtutor\n5\nyoutube\n6\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given string is a valid expression with balanced parentheses.",
        "Output": "To check if a given string is a valid expression with balanced parentheses, we can use a stack data structure. The idea is to traverse the string and push each opening parenthesis onto the stack. When we encounter a closing parenthesis, we pop the top element from the stack and check if it matches the closing parenthesis. If it does, we continue with the traversal. If it doesn't, we know that the expression is not valid and we can return false. At the end of the traversal, if the stack is empty, it means that all parentheses are balanced and we can return true. Otherwise, the expression is not valid\n1\n2\n3\n.\nHere's an example implementation of the above approach in C++:\nc++\n#include <iostream>\n#include <stack>\n#include <string>\n\nbool isValidExpression(std::string s) {\n  std::stack<char> st;\n\n  for (char c : s) {\n    if (c == '(' || c == '{' || c == '[') {\n      st.push(c);\n    } else if (c == ')' || c == '}' || c == ']') {\n      if (st.empty()) {\n        return false;\n      } else if ((c == ')' && st.top() == '(') ||\n                 (c == '}' && st.top() == '{') ||\n                 (c == ']' && st.top() == '[')) {\n        st.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return st.empty();\n}\n\nint main() {\n  std::string s1 = \"((()))()()\";\n  std::string s2 = \"())((())\";\n\n  std::cout << s1 << \" is \" << (isValidExpression(s1) ? \"valid\" : \"invalid\") << std::endl;\n  std::cout << s2 << \" is \" << (isValidExpression(s2) ? \"valid\" : \"invalid\") << std::endl;\n\n  return 0;\n}\nThis program defines a function isValidExpression() that takes a string as input and returns true if the string is a valid expression with balanced parentheses, and false otherwise. It initializes a stack of characters and traverses the string character by character. If the character is an opening parenthesis, it is pushed onto the stack. If the character is a closing parenthesis, it is compared with the top element of the stack. If they match, the top element is popped from the stack. If they don't match, the expression is not valid. At the end of the traversal, if the stack is empty, the expression is valid. Otherwise, it is not valid. The program then tests the function with two example strings and prints the results.\n1\ngeeksforgeeks\n2\ngeeksforgeeks\n3\ntutorialspoint"
    },
    {
        "Input": "Write a program to find the maximum sum of non-adjacent elements in a given list of integers.",
        "Output": "To find the maximum sum of non-adjacent elements in a given list of integers, we can use dynamic programming. We can define an array dp of the same length as the input list, where dp[i] represents the maximum sum of non-adjacent elements ending at index i. We can then use the following recurrence relation to fill in the dp array:\ndp[0] = arr[0]\ndp[1] = max(arr[0], arr[1])\ndp[i] = max(dp[i-2] + arr[i], dp[i-1])\nThe first two base cases are straightforward. For the general case, we have two choices: either we include the current element in the sum, in which case the maximum sum is dp[i-2] + arr[i], or we exclude the current element, in which case the maximum sum is dp[i-1]. We take the maximum of these two choices as the value of dp[i]. Finally, the maximum sum of non-adjacent elements in the input list is given by dp[n-1], where n is the length of the input list.\nHere's an example implementation of the above approach in Python:\npython\ndef max_sum_non_adjacent(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return arr[0]\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-2] + arr[i], dp[i-1])\n    return dp[n-1]\nThis program defines a function max_sum_non_adjacent() that takes a list of integers as input and returns the maximum sum of non-adjacent elements in the list. It first handles the base cases where the input list is empty or has only one element. It then initializes the dp array and fills it using the recurrence relation described above. Finally, it returns the maximum sum of non-adjacent elements, which is given by dp[n-1], where n is the length of the input list.\n1\ncodingninjas\n2\ncodingninjas\n3\ntakeuforward\n4\ninterviewbit\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to find the longest palindromic substring in a given string.",
        "Output": "There are several approaches to find the longest palindromic substring in a given string. One of the most straightforward methods is the brute force approach, which involves checking whether each substring is a palindrome or not. This approach has a time complexity of O(n^3) and a space complexity of O(1)\n1\n2\n.\nA more efficient approach is to use dynamic programming. We can define a 2D boolean array table of size n x n, where table[i][j] is true if the substring from index i to index j is a palindrome, and false otherwise. We can then use the following recurrence relation to fill in the table array:\ntable[i][i] = true\ntable[i][i+1] = (s[i] == s[i+1])\ntable[i][j] = (s[i] == s[j] && table[i+1][j-1])\nThe first two base cases are straightforward. For the general case, we have two choices: either the substring from index i to index j is a palindrome, in which case table[i][j] is true if the characters at indices i and j are equal and the substring from index i+1 to index j-1 is a palindrome, or it is not a palindrome. Finally, we can iterate over the table array and find the longest palindromic substring. This approach has a time complexity of O(n^2) and a space complexity of O(n^2)\n1\n3\n4\n5\n2\n6\n.\nHere's an example implementation of the dynamic programming approach in Python:\npython\ndef longest_palindromic_substring(s):\n    n = len(s)\n    if n == 0:\n        return \"\"\n    table = [[False] * n for _ in range(n)]\n    start = 0\n    maxlen = 1\n    for i in range(n):\n        table[i][i] = True\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            table[i][i+1] = True\n            start = i\n            maxlen = 2\n    for k in range(3, n+1):\n        for i in range(n-k+1):\n            j = i + k - 1\n            if s[i] == s[j] and table[i+1][j-1]:\n                table[i][j] = True\n                if k > maxlen:\n                    start = i\n                    maxlen = k\n    return s[start:start+maxlen]\nThis program defines a function longest_palindromic_substring() that takes a string as input and returns the longest palindromic substring in the string. It first handles the base case where the input string is empty. It then initializes the table array and fills it using the recurrence relation described above. Finally, it iterates over the table array and finds the longest palindromic substring. The program then returns the longest palindromic substring.\n1\nlogicmojo\n2\ngeeksforgeeks\n3\nleetcode\n4\ninterviewbit\n5\nwikipedia\n6\nscaler"
    },
    {
        "Input": "Write a program to find the minimum number of characters to be removed from a string to make it a palindrome.",
        "Output": "To find the minimum number of characters to be removed from a string to make it a palindrome, we can use dynamic programming. We can define a 2D array dp of size n x n, where dp[i][j] represents the length of the longest palindromic subsequence in the substring from index i to index j. We can then use the following recurrence relation to fill in the dp array:\ndp[i][i] = 1\ndp[i][j] = dp[i+1][j-1] + 2 if s[i] == s[j]\ndp[i][j] = max(dp[i+1][j], dp[i][j-1]) if s[i] != s[j]\nThe first base case is straightforward. For the general case, we have two choices: either the characters at indices i and j are equal, in which case the length of the longest palindromic subsequence is dp[i+1][j-1] + 2, or they are not equal, in which case we take the maximum of the lengths of the longest palindromic subsequences in the substrings from index i+1 to index j and from index i to index j-1. Finally, the minimum number of characters to be removed from the string to make it a palindrome is given by n - dp[n-1], where n is the length of the input string.\nHere's an example implementation of the dynamic programming approach in Python:\npython\ndef min_deletions_to_make_palindrome(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for k in range(2, n+1):\n        for i in range(n-k+1):\n            j = i + k - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    return n - dp[0][n-1]\nThis program defines a function min_deletions_to_make_palindrome() that takes a string as input and returns the minimum number of characters to be removed from the string to make it a palindrome. It first handles the base case where the input string is empty. It then initializes the dp array and fills it using the recurrence relation described above. Finally, it returns the minimum number of characters to be removed from the string to make it a palindrome, which is given by n - dp[n-1], where n is the length of the input string.\n1\nopengenus\n2\ngeeksforgeeks\n3\nyoutube\n4\ntutorialspoint\n5\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing a binary max-heap and implement methods to insert and extract the maximum element.",
        "Output": "Here's an implementation of a Python class representing a binary max-heap and methods to insert and extract the maximum element:\npython\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left(self, i):\n        return 2 * i + 1\n\n    def right(self, i):\n        return 2 * i + 2\n\n    def get_max(self):\n        if len(self.heap) == 0:\n            return None\n        return self.heap[0]\n\n    def extract_max(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        max_val = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.max_heapify(0)\n        return max_val\n\n    def max_heapify(self, i):\n        l = self.left(i)\n        r = self.right(i)\n        largest = i\n        if l < len(self.heap) and self.heap[l] > self.heap[largest]:\n            largest = l\n        if r < len(self.heap) and self.heap[r] > self.heap[largest]:\n            largest = r\n        if largest != i:\n            self.swap(i, largest)\n            self.max_heapify(largest)\n\n    def swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\n    def insert(self, key):\n        self.heap.append(key)\n        i = len(self.heap) - 1\n        while i != 0 and self.heap[self.parent(i)] < self.heap[i]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\nThis class defines a binary max-heap and implements the following methods:\n__init__: Initializes an empty heap.\nparent, left, right: Helper methods to get the parent, left child, and right child indices of a given index.\nget_max: Returns the maximum element in the heap without removing it.\nextract_max: Removes and returns the maximum element in the heap.\nmax_heapify: Maintains the max-heap property at a given index.\nswap: Swaps two elements in the heap.\ninsert: Inserts a new element into the heap and maintains the max-heap property.\nTo use this class, you can create an instance of MaxHeap and call its methods as follows:\npython\nheap = MaxHeap()\nheap.insert(5)\nheap.insert(3)\nheap.insert(8)\nprint(heap.get_max()) # Output: 8\nprint(heap.extract_max()) # Output: 8\nprint(heap.get_max()) # Output: 5\nThis program creates an instance of MaxHeap, inserts three elements into the heap, and prints the maximum element using the get_max method. It then extracts the maximum element using the extract_max method and prints it. Finally, it prints the new maximum element using the get_max method.\n1\nsanfoundry\n2\naskpython\n3\ngeeksforgeeks\n4\nprepbytes\n5\nfavtutor"
    },
    {
        "Input": "Implement a function to find the first repeating element in a list.",
        "Output": "There are several ways to find the first repeating element in a list. One of the simplest methods is to use a nested loop to compare each element with all the elements that come after it. If a repeating element is found, we can return it. This approach has a time complexity of O(n^2) and a space complexity of O(1)\n1\n2\n.\nA more efficient approach is to use a hash table to keep track of the frequency of each element. We can iterate over the list and add each element to the hash table. If an element is already in the hash table, it means it is a repeating element and we can return it. This approach has a time complexity of O(n) and a space complexity of O(n)\n3\n4\n.\nHere's an example implementation of the hash table approach in Python:\npython\ndef first_repeating_element(lst):\n    freq = {}\n    for i in lst:\n        if i in freq:\n            return i\n        freq[i] = 1\n    return None\nThis program defines a function first_repeating_element() that takes a list as input and returns the first repeating element in the list. It initializes an empty dictionary freq and iterates over the list. For each element, it checks if it is already in the dictionary. If it is, it means it is a repeating element and the program returns it. Otherwise, it adds the element to the dictionary with a frequency of 1. If no repeating element is found, the program returns None.\nHere's an example usage of the function:\npython\nlst = [1, 2, 3, 3, 4, 5, 6, 6]\nprint(first_repeating_element(lst)) # Output: 3\nThis program creates a list lst, calls the first_repeating_element() function with the list as input, and prints the result. The output is the first repeating element in the list, which is 3.\n1\neducative\n2\njava2blog\n3\ngeeksforgeeks\n4\ngeeksforgeeks"
    },
    {
        "Input": "Write a program to find the length of the longest common subsequence between two strings.",
        "Output": "To find the length of the longest common subsequence between two strings, we can use dynamic programming. We can define a 2D array dp of size m+1 x n+1, where dp[i][j] represents the length of the longest common subsequence between the first i characters of the first string and the first j characters of the second string. We can then use the following recurrence relation to fill in the dp array:\ndp[i][j] = 0 if i == 0 or j == 0\ndp[i][j] = dp[i-1][j-1] + 1 if s1[i-1] == s2[j-1]\ndp[i][j] = max(dp[i-1][j], dp[i][j-1]) if s1[i-1] != s2[j-1]\nThe first base case is straightforward. For the general case, we have two choices: either the last characters of the two strings are equal, in which case the length of the longest common subsequence is dp[i-1][j-1] + 1, or they are not equal, in which case we take the maximum of the lengths of the longest common subsequences between the first i-1 characters of the first string and the first j characters of the second string, and between the first i characters of the first string and the first j-1 characters of the second string. Finally, the length of the longest common subsequence between the two strings is given by dp[m][n], where m and n are the lengths of the two input strings.\nHere's an example implementation of the dynamic programming approach in Python:\npython\ndef longest_common_subsequence(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]\nThis program defines a function longest_common_subsequence() that takes two strings as input and returns the length of the longest common subsequence between the two strings. It initializes the dp array and fills it using the recurrence relation described above. Finally, it returns the length of the longest common subsequence between the two strings, which is given by dp[m][n], where m and n are the lengths of the two input strings.\nHere's an example usage of the function:\npython\ns1 = \"AGGTAB\"\ns2 = \"GXTXAYB\"\nprint(longest_common_subsequence(s1, s2)) # Output: 4\nThis program creates two strings s1 and s2, calls the longest_common_subsequence() function with the two strings as input, and prints the result. The output is the length of the longest common subsequence between the two strings, which is 4.\n1\nleetcode\n2\ngeeksforgeeks\n3\njavatpoint\n4\ngeeksforgeeks\n5\nprogramiz"
    },
    {
        "Input": "Create a program to remove all duplicate elements from a list and maintain the original order.",
        "Output": "To remove all duplicate elements from a list and maintain the original order, we can use a dictionary to keep track of the elements that have already been seen. We can iterate over the list and add each element to the dictionary as a key with a value of True. If an element is already in the dictionary, it means it is a duplicate and we can skip it. We can then create a new list with the unique elements in the order they appear in the original list. This approach has a time complexity of O(n) and a space complexity of O(n)\n1\n2\n3\n.\nHere's an example implementation of the dictionary approach in Python:\npython\ndef remove_duplicates(lst):\n    seen = {}\n    result = []\n    for i in lst:\n        if i not in seen:\n            seen[i] = True\n            result.append(i)\n    return result\nThis program defines a function remove_duplicates() that takes a list as input and returns a new list with all the duplicate elements removed while maintaining the original order. It initializes an empty dictionary seen and an empty list result, and iterates over the input list. For each element, it checks if it is already in the dictionary. If it is not, it adds the element to the dictionary with a value of True and appends it to the result list. If it is already in the dictionary, it skips the element. Finally, it returns the result list.\nHere's an example usage of the function:\npython\nlst = [1, 2, 3, 2, 4, 3, 5, 6, 5]\nprint(remove_duplicates(lst)) # Output: [1, 2, 3, 4, 5, 6]\nThis program creates a list lst, calls the remove_duplicates() function with the list as input, and prints the result. The output is a new list with all the duplicate elements removed while maintaining the original order.\n1\nw3resource\n2\nfinxter\n3\nfinxter"
    },
    {
        "Input": "Implement a function to check if a given string is a valid parenthesis expression with different types of parentheses.",
        "Output": "To check if a given string is a valid parenthesis expression with different types of parentheses, we can use a stack data structure. The idea is to traverse the string and push each opening parenthesis onto the stack. When we encounter a closing parenthesis, we pop the top element from the stack and check if it matches the closing parenthesis. If it does, we continue with the traversal. If it doesn't, we know that the expression is not valid and we can return false. At the end of the traversal, if the stack is empty, it means that all parentheses are balanced and we can return true. Otherwise, the expression is not valid. We can modify the above approach to handle different types of parentheses by using a dictionary to map each closing parenthesis to its corresponding opening parenthesis. We can then check if the top element of the stack matches the corresponding opening parenthesis for the closing parenthesis. This approach has a time complexity of O(n) and a space complexity of O(n)\n1\n2\n3\n.\nHere's an example implementation of the above approach in Python:\npython\ndef is_valid_parenthesis(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for c in s:\n        if c in mapping:\n            if not stack or stack[-1] != mapping[c]:\n                return False\n            stack.pop()\n        elif c in mapping.values():\n            stack.append(c)\n    return not stack\nThis program defines a function is_valid_parenthesis() that takes a string as input and returns true if the string is a valid parenthesis expression with different types of parentheses, and false otherwise. It initializes a stack and a dictionary mapping that maps each closing parenthesis to its corresponding opening parenthesis. It then traverses the string character by character. If the character is a closing parenthesis, it checks if the top element of the stack matches the corresponding opening parenthesis for the closing parenthesis. If it does, the top element is popped from the stack. If it doesn't, the expression is not valid. If the character is an opening parenthesis, it is pushed onto the stack. Finally, if the stack is empty, it means that all parentheses are balanced and the program returns true. Otherwise, it returns false.\nHere's an example usage of the function:\npython\ns1 = \"()[]{}\"\ns2 = \"([)]\"\ns3 = \"{[]}\"\nprint(is_valid_parenthesis(s1)) # Output: True\nprint(is_valid_parenthesis(s2)) # Output: False\nprint(is_valid_parenthesis(s3)) # Output: True\nThis program creates three strings s1, s2, and s3, calls the is_valid_parenthesis() function with each string as input, and prints the result. The output is true if the string is a valid parenthesis expression with different types of parentheses, and false otherwise.\n1\nredquark\n2\neducative\n3\nenjoyalgorithms"
    },
    {
        "Input": "Write a Python class representing a circular queue and implement a method to get the front element without removing it.",
        "Output": "Here's an implementation of a Python class representing a circular queue and a method to get the front element without removing it:\npython\nclass CircularQueue:\n    def __init__(self, k):\n        self.k = k\n        self.queue = [None] * k\n        self.head = -1\n        self.tail = -1\n\n    def is_empty(self):\n        return self.head == -1\n\n    def is_full(self):\n        return (self.tail + 1) % self.k == self.head\n\n    def enqueue(self, data):\n        if self.is_full():\n            return False\n        if self.is_empty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.k\n        self.queue[self.tail] = data\n        return True\n\n    def dequeue(self):\n        if self.is_empty():\n            return None\n        data = self.queue[self.head]\n        if self.head == self.tail:\n            self.head = -1\n            self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.k\n        return data\n\n    def get_front(self):\n        if self.is_empty():\n            return None\n        return self.queue[self.head]\nThis class defines a circular queue with a fixed size k and implements the following methods:\n__init__: Initializes an empty circular queue with a fixed size k.\nis_empty: Returns true if the circular queue is empty, and false otherwise.\nis_full: Returns true if the circular queue is full, and false otherwise.\nenqueue: Adds an element to the back of the circular queue and returns true if the operation is successful, and false otherwise.\ndequeue: Removes and returns the front element of the circular queue, and returns None if the circular queue is empty.\nget_front: Returns the front element of the circular queue without removing it, and returns None if the circular queue is empty.\nTo use this class, you can create an instance of CircularQueue and call its methods as follows:\npython\ncq = CircularQueue(5)\ncq.enqueue(1)\ncq.enqueue(2)\ncq.enqueue(3)\nprint(cq.get_front()) # Output: 1\nThis program creates an instance of CircularQueue with a fixed size of 5, adds three elements to the circular queue using the enqueue method, and prints the front element of the circular queue using the get_front method. The output is the front element of the circular queue, which is 1.\n1\nstudytonight\n2\nyoutube\n3\ndremendo\n4\npythoncentral\n5\ntowardsdatascience"
    },
    {
        "Input": "Create a program to find the maximum sum of a non-empty subarray in a given list of integers.",
        "Output": "To find the maximum sum of a non-empty subarray in a given list of integers, we can use Kadane's algorithm. The algorithm works by iterating over the list and keeping track of the maximum sum of a subarray ending at each index. At each index, we can either start a new subarray or extend the previous subarray. To extend the previous subarray, we add the current element to the sum of the previous subarray. If the sum of the previous subarray is negative, we start a new subarray. We can then update the maximum sum seen so far and return it at the end of the iteration. This approach has a time complexity of O(n) and a space complexity of O(1)\n1\n2\n3\n.\nHere's an example implementation of Kadane's algorithm in Python:\npython\ndef max_subarray_sum(lst):\n    max_so_far = lst[0]\n    max_ending_here = lst[0]\n    for i in range(1, len(lst)):\n        max_ending_here = max(lst[i], max_ending_here + lst[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\nThis program defines a function max_subarray_sum() that takes a list of integers as input and returns the maximum sum of a non-empty subarray in the list. It initializes two variables max_so_far and max_ending_here to the first element of the list, and iterates over the list starting from the second element. For each element, it updates max_ending_here to be the maximum of the current element and the sum of the previous subarray plus the current element. If the sum of the previous subarray is negative, it starts a new subarray. It then updates max_so_far to be the maximum of max_so_far and max_ending_here. Finally, it returns max_so_far.\nHere's an example usage of the function:\npython\nlst = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(max_subarray_sum(lst)) # Output: 6\nThis program creates a list lst, calls the max_subarray_sum() function with the list as input, and prints the result. The output is the maximum sum of a non-empty subarray in the list, which is 6.\n1\ngeeksforgeeks\n2\ninterviewbit\n3\ntechiedelight"
    },
    {
        "Input": "Implement a function to check if a given number is a perfect number.",
        "Output": "A perfect number is a positive integer that is equal to the sum of its proper divisors. To check if a given number is a perfect number, we can find all the divisors of the number except the number itself and check if the sum of the divisors is equal to the number. If it is, the number is a perfect number. Otherwise, it is not a perfect number\n1\n2\n3\n4\n.\nHere's an example implementation of the above approach in Python:\npython\ndef is_perfect_number(num):\n    divisors = []\n    for i in range(1, num):\n        if num % i == 0:\n            divisors.append(i)\n    return sum(divisors) == num\nThis program defines a function is_perfect_number() that takes a positive integer as input and returns true if the number is a perfect number, and false otherwise. It initializes an empty list divisors and iterates over the range from 1 to the input number. For each number in the range, it checks if it is a divisor of the input number. If it is, it appends it to the divisors list. Finally, it returns true if the sum of the divisors is equal to the input number, and false otherwise.\nHere's an example usage of the function:\npython\nnum1 = 6\nnum2 = 28\nnum3 = 496\nnum4 = 8128\nnum5 = 10\nprint(is_perfect_number(num1)) # Output: True\nprint(is_perfect_number(num2)) # Output: True\nprint(is_perfect_number(num3)) # Output: True\nprint(is_perfect_number(num4)) # Output: True\nprint(is_perfect_number(num5)) # Output: False\nThis program creates five positive integers num1, num2, num3, num4, and num5, calls the is_perfect_number() function with each number as input, and prints the result. The output is true if the number is a perfect number, and false otherwise.\n1\ncodesansar\n2\nbyjus\n3\nbasic-mathematics\n4\neducative"
    },
    {
        "Input": "Write a program to find the kth largest element in a given list.",
        "Output": "There are several ways to find the kth largest element in a given list of integers. Here are a few approaches:\nSort the list in descending order and return the kth element. This approach has a time complexity of O(n log n) due to the sorting operation. Additionally, sorting a list with a large number of unique elements might consume a lot of memory. Here's an example implementation of this approach in Python\n1\n:\npython\ndef kth_largest_el(lst, k):\n    lst.sort(reverse=True)\n    return lst[k-1]\nUse a max-heap to keep track of the k largest elements in the list. This approach has a time complexity of O(n log k) and a space complexity of O(k). Here's an example implementation of this approach in Python\n2\n:\npython\nimport heapq\n\ndef kth_largest_el(lst, k):\n    heap = lst[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(lst)):\n        if lst[i] > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, lst[i])\n    return heap[0]\nUse quickselect to find the kth largest element. Quickselect is a variation of quicksort that only partitions the elements that are needed to find the kth largest element. This approach has an average time complexity of O(n) and a worst-case time complexity of O(n^2). Here's an example implementation of this approach in Python\n3\n:\npython\nimport random\n\ndef partition(lst, left, right):\n    pivot_index = random.randint(left, right)\n    pivot = lst[pivot_index]\n    lst[pivot_index], lst[right] = lst[right], lst[pivot_index]\n    store_index = left\n    for i in range(left, right):\n        if lst[i] > pivot:\n            lst[i], lst[store_index] = lst[store_index], lst[i]\n            store_index += 1\n    lst[right], lst[store_index] = lst[store_index], lst[right]\n    return store_index\n\ndef quickselect(lst, left, right, k):\n    if left == right:\n        return lst[left]\n    pivot_index = partition(lst, left, right)\n    if k == pivot_index:\n        return lst[k]\n    elif k < pivot_index:\n        return quickselect(lst, left, pivot_index - 1, k)\n    else:\n        return quickselect(lst, pivot_index + 1, right, k)\n\ndef kth_largest_el(lst, k):\n    return quickselect(lst, 0, len(lst) - 1, len(lst) - k)\nThese are just a few of the many approaches to find the kth largest element in a given list of integers. The choice of approach depends on the size of the list, the value of k, and the desired time and space complexity.\n1\nw3resource\n2\ninterviewbit\n3\nbaeldung"
    },
    {
        "Input": "Create a Python class representing a trie (prefix tree) and implement methods to insert and search for words.",
        "Output": "Here's an implementation of a Python class representing a trie (prefix tree) and methods to insert and search for words:\npython\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\nThis class defines a trie (prefix tree) data structure and implements the following methods:\n__init__: Initializes an empty trie with a root node.\ninsert: Inserts a word into the trie by iterating over each character in the word and adding a new node to the trie if the character is not already in the trie.\nsearch: Searches for a word in the trie by iterating over each character in the word and returning true if the word is in the trie and false otherwise.\nTo use this class, you can create an instance of Trie and call its methods as follows:\npython\ntrie = Trie()\ntrie.insert(\"apple\")\ntrie.insert(\"banana\")\ntrie.insert(\"orange\")\nprint(trie.search(\"apple\")) # Output: True\nprint(trie.search(\"pear\")) # Output: False\nThis program creates an instance of Trie, adds three words to the trie using the insert method, and searches for two words in the trie using the search method. The output is true if the word is in the trie, and false otherwise.\n1\naskpython\n2\nstackoverflow\n3\nalbertauyeung\n4\nmedium\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given string is a valid expression with balanced parentheses and brackets.",
        "Output": "To check if a given string is a valid expression with balanced parentheses and brackets, we can use a stack data structure. The idea is to iterate over the string and push each opening parenthesis or bracket onto the stack. When we encounter a closing parenthesis or bracket, we pop the top element from the stack and check if it matches the closing parenthesis or bracket. If it does, we continue with the iteration. If it doesn't, we know that the expression is not valid and we can return false. At the end of the iteration, if the stack is empty, it means that all parentheses and brackets are balanced and we can return true. Otherwise, the expression is not valid. We can modify the above approach to handle different types of parentheses and brackets by using a dictionary to map each closing parenthesis or bracket to its corresponding opening parenthesis or bracket. We can then check if the top element of the stack matches the corresponding opening parenthesis or bracket for the closing parenthesis or bracket. This approach has a time complexity of O(n) and a space complexity of O(n)\n1\n2\n3\n.\nHere's an example implementation of the above approach in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for c in s:\n        if c in mapping:\n            if not stack or stack[-1] != mapping[c]:\n                return False\n            stack.pop()\n        elif c in mapping.values():\n            stack.append(c)\n    return not stack\nThis program defines a function is_valid_expression() that takes a string as input and returns true if the string is a valid expression with balanced parentheses and brackets, and false otherwise. It initializes a stack and a dictionary mapping that maps each closing parenthesis or bracket to its corresponding opening parenthesis or bracket. It then traverses the string character by character. If the character is a closing parenthesis or bracket, it checks if the top element of the stack matches the corresponding opening parenthesis or bracket for the closing parenthesis or bracket. If it does, the top element is popped from the stack. If it doesn't, the expression is not valid. If the character is an opening parenthesis or bracket, it is pushed onto the stack. Finally, if the stack is empty, it means that all parentheses and brackets are balanced and the program returns true. Otherwise, it returns false.\nHere's an example usage of the function:\npython\ns1 = \"(({}[]))\"\ns2 = \"({[}])\"\ns3 = \"({[]})\"\nprint(is_valid_expression(s1)) # Output: True\nprint(is_valid_expression(s2)) # Output: False\nprint(is_valid_expression(s3)) # Output: True\nThis program creates three strings s1, s2, and s3, calls the is_valid_expression() function with each string as input, and prints the result. The output is true if the string is a valid expression with balanced parentheses and brackets, and false otherwise.\n1\nafteracademy\n2\nprepbytes\n3\nenjoyalgorithms"
    },
    {
        "Input": "Write a program to find the maximum product of three integers in a given list.",
        "Output": "To find the maximum product of three integers in a given list, we can use a few different approaches. Here are a few:\nBrute force approach: Try to find all the triplets in the array while maintaining the maximum value of their products. This approach has a time complexity of O(n^3) and is not very efficient for large lists. Here's an example implementation of this approach in Python:\npython\ndef max_product(lst):\n    n = len(lst)\n    max_product = float('-inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                product = lst[i] * lst[j] * lst[k]\n                max_product = max(max_product, product)\n    return max_product\nUsing sorting: Sort the input array. The maximum product would be the product of the last three elements or the starting two elements with the last element. This approach has a time complexity of O(n log n) due to the sorting operation. Here's an example implementation of this approach in Python:\npython\ndef max_product(lst):\n    lst.sort()\n    n = len(lst)\n    return max(lst[0] * lst[1] * lst[n-1], lst[n-3] * lst[n-2] * lst[n-1])\nUsing a single pass: We can find the maximum, second maximum, and third maximum elements in a single pass and return their product. This approach has a time complexity of O(n) and is the most efficient of the three approaches. Here's an example implementation of this approach in Python:\npython\ndef max_product(lst):\n    max1 = max2 = max3 = float('-inf')\n    min1 = min2 = float('inf')\n    for num in lst:\n        if num > max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max3 = max2\n            max2 = num\n        elif num > max3:\n            max3 = num\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    return max(max1 * max2 * max3, max1 * min1 * min2)\nThese are just a few of the many approaches to find the maximum product of three integers in a given list. The choice of approach depends on the size of the list and the desired time complexity.\n1\nstackoverflow\n2\nw3resource\n3\nleetcode\n4\nalgodaily\n5\nafteracademy"
    },
    {
        "Input": "Create a program to generate all possible permutations of a given list of distinct integers.",
        "Output": "There are several ways to generate all possible permutations of a given list of distinct integers. Here are a few approaches:\nUsing itertools.permutations(): We can use the built-in permutations function from the itertools module to generate all possible permutations of a list. This function returns an iterator that generates tuples containing all possible permutations of the input list. Here's an example implementation of this approach in Python:\npython\nimport itertools\n\ndef generate_permutations(lst):\n    return list(itertools.permutations(lst))\nUsing recursion: We can use a recursive function to generate all possible permutations of a list. The idea is to swap each element with every other element in the list and recursively generate all possible permutations of the remaining elements. Here's an example implementation of this approach in Python:\npython\ndef generate_permutations(lst):\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [lst]\n    result = []\n    for i in range(len(lst)):\n        rest = lst[:i] + lst[i+1:]\n        for permutation in generate_permutations(rest):\n            result.append([lst[i]] + permutation)\n    return result\nUsing Heap's algorithm: Heap's algorithm is a non-recursive algorithm that generates all possible permutations of a list. The algorithm works by swapping each element with every other element in the list and recursively generating all possible permutations of the remaining elements. Here's an example implementation of this approach in Python:\npython\ndef generate_permutations(lst):\n    n = len(lst)\n    c = [0] * n\n    result = [lst]\n    i = 0\n    while i < n:\n        if c[i] < i:\n            if i % 2 == 0:\n                lst[0], lst[i] = lst[i], lst[0]\n            else:\n                lst[c[i]], lst[i] = lst[i], lst[c[i]]\n            result.append(lst[:])\n            c[i] += 1\n            i = 0\n        else:\n            c[i] = 0\n            i += 1\n    return result\nThese are just a few of the many approaches to generate all possible permutations of a given list of distinct integers. The choice of approach depends on the size of the list and the desired time complexity.\n1\nw3resource\n2\nw3resource\n3\ngeeksforgeeks\n4\nbaeldung\n5\nstudytonight"
    },
    {
        "Input": "Implement a function to calculate the GCD (Greatest Common Divisor) of two numbers.",
        "Output": "Here's an implementation of a function to calculate the GCD (Greatest Common Divisor) of two numbers in Python:\npython\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nThis program defines a function gcd() that takes two integers as input and returns their GCD. It uses the Euclidean algorithm to find the GCD recursively. The algorithm works by repeatedly dividing the larger number by the smaller number and taking the remainder until the remainder is zero. The GCD is then the last non-zero remainder. The function first checks if the second number is zero. If it is, it returns the first number as the GCD. Otherwise, it recursively calls itself with the second number and the remainder of the first number divided by the second number.\nHere's an example usage of the function:\npython\na = 24\nb = 36\nprint(gcd(a, b)) # Output: 12\nThis program creates two integers a and b, calls the gcd() function with the two integers as input, and prints the result. The output is the GCD of the two integers, which is 12 in this case.\n1\ngeeksforgeeks\n2\njavatpoint\n3\nscaler\n4\nscaler\n5\nprogramiz"
    },
    {
        "Input": "\"Write a Python class representing a hash set and implement methods to insert, remove, and check if an element exists.\"",
        "Output": "Here's an implementation of a Python class representing a hash set and methods to insert, remove, and check if an element exists:\npython\nclass HashSet:\n    def __init__(self):\n        self.hash_set = set()\n\n    def insert(self, value):\n        self.hash_set.add(value)\n\n    def remove(self, value):\n        self.hash_set.discard(value)\n\n    def contains(self, value):\n        return value in self.hash_set\nThis class defines a hash set data structure and implements the following methods:\n__init__: Initializes an empty hash set.\ninsert: Inserts a value into the hash set using the add() method of the built-in set class.\nremove: Removes a value from the hash set using the discard() method of the built-in set class.\ncontains: Checks if a value is in the hash set using the in operator.\nHere's an example usage of the class:\npython\nhash_set = HashSet()\nhash_set.insert(1)\nhash_set.insert(2)\nhash_set.insert(3)\nprint(hash_set.contains(2)) # Output: True\nhash_set.remove(2)\nprint(hash_set.contains(2)) # Output: False\nThis program creates an instance of HashSet, adds three values to the hash set using the insert method, checks if a value is in the hash set using the contains method, removes a value from the hash set using the remove method, and checks if the value is still in the hash set using the contains method. The output is true if the value is in the hash set, and false otherwise.\n1\njavatpoint\n2\ntutorialspoint\n3\nprogramiz\n4\ngeeksforgeeks\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Create a program to find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right or down.\"",
        "Output": "To find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right or down, we can use combinatorics. The number of paths is equal to the binomial coefficient (n choose k), where n is the total number of steps (rows + columns - 2) and k is the number of steps to the right (or down). We can use the math module in Python to calculate the binomial coefficient using the comb() function. Here's an example implementation of this approach in Python:\npython\nimport math\n\ndef count_paths(rows, cols):\n    n = rows + cols - 2\n    k = cols - 1\n    return math.comb(n, k)\nThis program defines a function count_paths() that takes the number of rows and columns in the grid as input and returns the number of paths from the top-left corner to the bottom-right corner of the grid, moving only right or down. It first calculates the total number of steps n as the sum of the number of rows and columns minus 2. It then calculates the number of steps to the right k as the number of columns minus 1. Finally, it uses the comb() function from the math module to calculate the binomial coefficient (n choose k) and returns the result.\nHere's an example usage of the function:\npython\nrows = 3\ncols = 3\nprint(count_paths(rows, cols)) # Output: 6\nThis program creates two integers rows and cols, calls the count_paths() function with the two integers as input, and prints the result. The output is the number of paths from the top-left corner to the bottom-right corner of the grid, moving only right or down, which is 6 in this case.\n1\nmathcounts\n2\ntowardsdatascience\n3\nbetterexplained\n4\nmathigon\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, we can use a stack data structure. The idea is to iterate over the string and push each opening parenthesis, bracket, or curly brace onto the stack. When we encounter a closing parenthesis, bracket, or curly brace, we pop the top element from the stack and check if it matches the closing parenthesis, bracket, or curly brace. If it does, we continue with the iteration. If it doesn't, we know that the expression is not valid and we can return false. At the end of the iteration, if the stack is empty, it means that all parentheses, brackets, and curly braces are balanced and we can return true. We can modify the above approach to handle different types of parentheses, brackets, and curly braces by using a dictionary to map each closing parenthesis, bracket, or curly brace to its corresponding opening parenthesis, bracket, or curly brace. We can then check if the top element of the stack matches the corresponding opening parenthesis, bracket, or curly brace for the closing parenthesis, bracket, or curly brace. This approach has a time complexity of O(n) and a space complexity of O(n)\n1\n2\n3\n4\n5\n6\n.\nHere's an example implementation of the above approach in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for c in s:\n        if c in mapping:\n            if not stack or stack[-1] != mapping[c]:\n                return False\n            stack.pop()\n        elif c in mapping.values():\n            stack.append(c)\n    return not stack\nThis program defines a function is_valid_expression() that takes a string as input and returns true if the string is a valid expression with balanced parentheses, brackets, and curly braces, and false otherwise. It initializes a stack and a dictionary mapping that maps each closing parenthesis, bracket, or curly brace to its corresponding opening parenthesis, bracket, or curly brace. It then traverses the string character by character. If the character is a closing parenthesis, bracket, or curly brace, it checks if the top element of the stack matches the corresponding opening parenthesis, bracket, or curly brace for the closing parenthesis, bracket, or curly brace. If it does, the top element is popped from the stack. If it doesn't, the expression is not valid. If the character is an opening parenthesis, bracket, or curly brace, it is pushed onto the stack. Finally, if the stack is empty, it means that all parentheses, brackets, and curly braces are balanced and the program returns true. Otherwise, it returns false.\nHere's an example usage of the function:\npython\ns1 = \"{[()]}{}\"\ns2 = \"{[(])}\"\ns3 = \"{[()]}\"\nprint(is_valid_expression(s1)) # Output: True\nprint(is_valid_expression(s2)) # Output: False\nprint(is_valid_expression(s3)) # Output: True\nThis program creates three strings s1, s2, and s3, calls the is_valid_expression() function with each string as input, and prints the result. The output is true if the string is a valid expression with balanced parentheses, brackets, and curly braces, and false otherwise.\n1\ngeeksforgeeks\n2\nfavtutor\n3\nprepinsta\n4\ngeekflare\n5\ngithub\n6\neducative"
    },
    {
        "Input": "Write a program to find the median of a list of numbers in linear time.",
        "Output": "One way to find the median of a list of numbers in linear time is to use the median-of-medians algorithm. This algorithm works by recursively dividing the list into groups of five elements, finding the median of each group, and then recursively finding the median of the medians until a single element is left. This element is the median of the list. The algorithm guarantees linear time complexity, but it has a large constant factor and is not practical for small lists\n1\n.\nHere's an example implementation of the median-of-medians algorithm in Python:\npython\ndef median_of_medians(lst):\n    if len(lst) == 1:\n        return lst[0]\n    groups = [lst[i:i+5] for i in range(0, len(lst), 5)]\n    medians = [sorted(group)[len(group)//2] for group in groups]\n    pivot = median_of_medians(medians)\n    left = [x for x in lst if x < pivot]\n    right = [x for x in lst if x > pivot]\n    k = len(left)\n    if k == len(lst)//2:\n        return pivot\n    elif k < len(lst)//2:\n        return median_of_medians(right)\n    else:\n        return median_of_medians(left)\nThis program defines a function median_of_medians() that takes a list of numbers as input and returns the median of the list. It first checks if the list has only one element and returns that element as the median. Otherwise, it divides the list into groups of five elements, finds the median of each group, and recursively finds the median of the medians until a single element is left. This element is the pivot. The function then partitions the list into two sublists, one with elements less than the pivot and one with elements greater than the pivot. It then checks if the length of the left sublist is equal to half the length of the original list. If it is, the pivot is the median of the list and is returned. If it isn't, the function recursively calls itself with the right or left sublist depending on whether the length of the left sublist is less than or greater than half the length of the original list.\nHere's an example usage of the function:\npython\nlst = [3, 1, 4, 2, 5]\nprint(median_of_medians(lst)) # Output: 3\nThis program creates a list of numbers lst, calls the median_of_medians() function with the list as input, and prints the result. The output is the median of the list, which is 3 in this case.\n1\nrcoh"
    },
    {
        "Input": "Create a Python class representing a binary search tree and implement methods to delete a node and find the kth smallest element.",
        "Output": "Here's an implementation of a Python class representing a binary search tree and methods to delete a node and find the kth smallest element:\npython\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        if not self.root:\n            self.root = TreeNode(val)\n        else:\n            self._insert(val, self.root)\n\n    def _insert(self, val, node):\n        if val < node.val:\n            if node.left:\n                self._insert(val, node.left)\n            else:\n                node.left = TreeNode(val)\n        else:\n            if node.right:\n                self._insert(val, node.right)\n            else:\n                node.right = TreeNode(val)\n\n    def delete(self, val):\n        self.root = self._delete(val, self.root)\n\n    def _delete(self, val, node):\n        if not node:\n            return None\n        if val < node.val:\n            node.left = self._delete(val, node.left)\n        elif val > node.val:\n            node.right = self._delete(val, node.right)\n        else:\n            if not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n            else:\n                temp = self._find_min(node.right)\n                node.val = temp.val\n                node.right = self._delete(temp.val, node.right)\n        return node\n\n    def _find_min(self, node):\n        while node.left:\n            node = node.left\n        return node\n\n    def kth_smallest(self, k):\n        stack = []\n        node = self.root\n        while node or stack:\n            while node:\n                stack.append(node)\n                node = node.left\n            node = stack.pop()\n            k -= 1\n            if k == 0:\n                return node.val\n            node = node.right\nThis class defines a binary search tree data structure and implements the following methods:\n__init__: Initializes an empty binary search tree with a root node.\ninsert: Inserts a value into the binary search tree by recursively traversing the tree and adding a new node if the value is not already in the tree.\n_insert: Helper function for the insert method that recursively traverses the tree and adds a new node if the value is not already in the tree.\ndelete: Deletes a value from the binary search tree by recursively traversing the tree and removing the node with the given value.\n_delete: Helper function for the delete method that recursively traverses the tree and removes the node with the given value.\n_find_min: Helper function for the _delete method that finds the minimum value in the right subtree of a node.\nkth_smallest: Finds the kth smallest element in the binary search tree by using an iterative in-order traversal with a stack.\nHere's an example usage of the class:\npython\nbst = BinarySearchTree()\nbst.insert(5)\nbst.insert(3)\nbst.insert(7)\nbst.insert(2)\nbst.insert(4)\nbst.insert(6)\nbst.insert(8)\nbst.delete(5)\nprint(bst.kth_smallest(3)) # Output: 4\nThis program creates an instance of BinarySearchTree, adds seven values to the tree using the insert method, deletes a value from the tree using the delete method, and finds the kth smallest element in the tree using the kth_smallest method. The output is the kth smallest element in the tree, which is 4 in this case.\n1\nw3resource\n2\ntutorialspoint\n3\ngitbooks\n4\nmedium\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to find the longest increasing subsequence in a given list of integers.",
        "Output": "To find the longest increasing subsequence in a given list of integers, we can use dynamic programming. The idea is to create an array dp of the same length as the input list, where dp[i] represents the length of the longest increasing subsequence ending at index i. We can initialize dp to all ones, since the longest increasing subsequence of a single element is always one. We can then iterate over the input list and for each index i, we iterate over all previous indices j less than i and check if the element at index i is greater than the element at index j. If it is, we update dp[i] to be the maximum of dp[i] and dp[j] + 1. Finally, we return the maximum value in dp as the length of the longest increasing subsequence. We can also use the dp array to reconstruct the longest increasing subsequence by iterating over the input list and adding each element to the subsequence if its dp value is equal to the current maximum dp value minus one. This approach has a time complexity of O(n^2) and a space complexity of O(n)\n1\n2\n3\n4\n5\n.\nHere's an example implementation of the above approach in Python:\npython\ndef longest_increasing_subsequence(lst):\n    n = len(lst)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if lst[i] > lst[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    subsequence = []\n    for i in range(n-1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(lst[i])\n            max_length -= 1\n    subsequence.reverse()\n    return subsequence\nThis program defines a function longest_increasing_subsequence() that takes a list of integers as input and returns the longest increasing subsequence of the list. It first initializes an array dp of the same length as the input list to all ones. It then iterates over the input list and for each index i, it iterates over all previous indices j less than i and updates dp[i] to be the maximum of dp[i] and dp[j] + 1 if the element at index i is greater than the element at index j. It then finds the maximum value in dp as the length of the longest increasing subsequence and uses the dp array to reconstruct the subsequence by iterating over the input list and adding each element to the subsequence if its dp value is equal to the current maximum dp value minus one. Finally, it returns the subsequence.\nHere's an example usage of the function:\npython\nlst = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(longest_increasing_subsequence(lst)) # Output: [10, 22, 33, 50, 60, 80]\nThis program creates a list of integers lst, calls the longest_increasing_subsequence() function with the list as input, and prints the result. The output is the longest increasing subsequence of the list, which is\n10\n22\n33\n50\n60\n80\nin this case.\n1\ninterviewbit\n2\nwikipedia\n3\ncp-algorithms\n4\nleetcode\n5\ntechiedelight"
    },
    {
        "Input": "Write a program to calculate the factorial of a given non-negative integer using recursion.",
        "Output": "To calculate the factorial of a given non-negative integer using recursion in Python, we can define a function that calls itself with a smaller input until it reaches the base case, which is the factorial of 1, which is 1. Here is an example implementation of this approach:\npython\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\nThis program defines a function factorial() that takes a non-negative integer n as input and returns its factorial. It first checks if n is equal to 1, which is the base case. If it is, it returns 1. Otherwise, it recursively calls itself with the input n-1 and multiplies the result by n.\nHere's an example usage of the function:\npython\nn = 5\nprint(factorial(n)) # Output: 120\nThis program creates an integer n, calls the factorial() function with n as input, and prints the result. The output is the factorial of n, which is 120 in this case.\nNote that the above implementation assumes that the input is a non-negative integer. If the input is negative, the function will recurse infinitely. To handle negative inputs, we can add a check at the beginning of the function to return an error message or raise an exception.\n1\nprogramiz\n2\ngeeksforgeeks\n3\njavatpoint\n4\nprepinsta\n5\ntutorialspoint"
    },
    {
        "Input": "\"Create a program to find the number of islands in a 2D grid, where '1' represents land and '0' represents water.\"",
        "Output": "To find the number of islands in a 2D grid, where '1' represents land and '0' represents water, we can use depth-first search (DFS) or breadth-first search (BFS). The idea is to traverse the grid and for each cell that contains '1', we mark it as visited and recursively traverse all its neighboring cells that contain '1'. We count the number of times we start a new DFS or BFS as the number of islands. We can use a boolean matrix to keep track of the visited cells. This approach has a time complexity of O(mn), where m is the number of rows and n is the number of columns, and a space complexity of O(mn)\n1\n2\n3\n4\n5\n.\nHere's an example implementation of the above approach using DFS in Python:\npython\ndef num_islands(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1' and not visited[i][j]:\n                dfs(grid, visited, i, j)\n                count += 1\n    return count\n\ndef dfs(grid, visited, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0' or visited[i][j]:\n        return\n    visited[i][j] = True\n    dfs(grid, visited, i-1, j)\n    dfs(grid, visited, i+1, j)\n    dfs(grid, visited, i, j-1)\n    dfs(grid, visited, i, j+1)\nThis program defines a function num_islands() that takes a 2D grid of '1's and '0's as input and returns the number of islands in the grid. It first checks if the grid is empty and returns 0 if it is. It then initializes a boolean matrix visited of the same size as the grid to keep track of the visited cells and a counter count to keep track of the number of islands. It then iterates over the grid and for each cell that contains '1' and has not been visited, it calls the dfs() function to mark the cell and all its neighboring cells that contain '1' as visited and increment the count. The dfs() function is a recursive function that takes the grid, the visited matrix, and the indices of the current cell as input and recursively traverses all neighboring cells that contain '1' and have not been visited.\nHere's an example usage of the function:\npython\ngrid = [['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']]\nprint(num_islands(grid)) # Output: 3\nThis program creates a 2D grid grid, calls the num_islands() function with the grid as input, and prints the result. The output is the number of islands in the grid, which is 3 in this case.\n1\nleetcode\n2\ncodingninjas\n3\ninterviewbit\n4\ntechiedelight\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, and quotes.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, and quotes, we can use a stack data structure. The idea is to iterate over the string and push each opening parenthesis, bracket, curly brace, or quote onto the stack. When we encounter a closing parenthesis, bracket, curly brace, or quote, we pop the top element from the stack and check if it matches the closing parenthesis, bracket, curly brace, or quote. If it does, we continue with the iteration. If it doesn't, we know that the expression is not valid and we can return false. At the end of the iteration, if the stack is empty, it means that all parentheses, brackets, curly braces, and quotes are balanced and we can return true. We can modify the above approach to handle different types of parentheses, brackets, curly braces, and quotes by using a dictionary to map each closing parenthesis, bracket, curly brace, or quote to its corresponding opening parenthesis, bracket, curly brace, or quote. We can then check if the top element of the stack matches the corresponding opening parenthesis, bracket, curly brace, or quote for the closing parenthesis, bracket, curly brace, or quote. This approach has a time complexity of O(n) and a space complexity of O(n)\n1\n2\n3\n4\n5\n6\n.\nHere's an example implementation of the above approach in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\", \"'\": \"'\", '\"': '\"'}\n    for c in s:\n        if c in mapping:\n            if not stack or stack[-1] != mapping[c]:\n                return False\n            stack.pop()\n        elif c in mapping.values():\n            stack.append(c)\n    return not stack\nThis program defines a function is_valid_expression() that takes a string as input and returns true if the string is a valid expression with balanced parentheses, brackets, curly braces, and quotes, and false otherwise. It initializes a stack and a dictionary mapping that maps each closing parenthesis, bracket, curly brace, or quote to its corresponding opening parenthesis, bracket, curly brace, or quote. It then traverses the string character by character. If the character is a closing parenthesis, bracket, curly brace, or quote, it checks if the top element of the stack matches the corresponding opening parenthesis, bracket, curly brace, or quote for the closing parenthesis, bracket, curly brace, or quote. If it does, the top element is popped from the stack. If it doesn't, the expression is not valid. If the character is an opening parenthesis, bracket, curly brace, or quote, it is pushed onto the stack. Finally, if the stack is empty, it means that all parentheses, brackets, curly braces, and quotes are balanced and the program returns true. Otherwise, it returns false.\nHere's an example usage of the function:\npython\ns1 = \"{[()]}{}\"\ns2 = \"{[(])}\"\ns3 = \"{[()']}\"\nprint(is_valid_expression(s1)) # Output: True\nprint(is_valid_expression(s2)) # Output: False\nprint(is_valid_expression(s3)) # Output: True\nThis program creates three strings s1, s2, and s3, calls the is_valid_expression() function with each string as input, and prints the result. The output is true if the string is a valid expression with balanced parentheses, brackets, curly braces, and quotes, and false otherwise.\n1\nstackoverflow\n2\nhackernoon\n3\ngeeksforgeeks\n4\nfavtutor\n5\ngeeksforgeeks\n6\nleetcode"
    },
    {
        "Input": "Write a Python class representing a stack and implement methods to find the minimum element in constant time and retrieve the maximum element in logarithmic time.",
        "Output": "To implement a stack class in Python that can find the minimum element in constant time and retrieve the maximum element in logarithmic time, we can use two auxiliary stacks. One stack will keep track of the minimum elements seen so far, and the other stack will keep track of the maximum elements seen so far. We can then implement the push(), pop(), peek(), get_min(), and get_max() methods as follows:\npush(): Pushes an element onto the stack and updates the minimum and maximum stacks if necessary.\npop(): Pops the top element from the stack and updates the minimum and maximum stacks if necessary.\npeek(): Returns the top element of the stack without removing it.\nget_min(): Returns the minimum element in the stack in constant time by returning the top element of the minimum stack.\nget_max(): Returns the maximum element in the stack in logarithmic time by returning the top element of the maximum stack.\nHere's an example implementation of the above approach in Python:\npython\nclass Stack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n        self.max_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        if not self.max_stack or val >= self.max_stack[-1]:\n            self.max_stack.append(val)\n\n    def pop(self):\n        if not self.stack:\n            return None\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n        if val == self.max_stack[-1]:\n            self.max_stack.pop()\n        return val\n\n    def peek(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def get_min(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\n    def get_max(self):\n        if not self.max_stack:\n            return None\n        return self.max_stack[-1]\nThis program defines a class Stack that implements a stack data structure with methods to find the minimum element in constant time and retrieve the maximum element in logarithmic time. It initializes three stacks: stack to hold the elements, min_stack to hold the minimum elements seen so far, and max_stack to hold the maximum elements seen so far. It then implements the push(), pop(), peek(), get_min(), and get_max() methods as described above.\nHere's an example usage of the class:\npython\ns = Stack()\ns.push(3)\ns.push(2)\ns.push(5)\ns.push(1)\nprint(s.get_min()) # Output: 1\nprint(s.get_max()) # Output: 5\ns.pop()\nprint(s.get_min()) # Output: 2\nprint(s.get_max()) # Output: 5\nThis program creates an instance of Stack, adds four values to the stack using the push() method, retrieves the minimum and maximum elements in the stack using the get_min() and get_max() methods, removes the top element from the stack using the pop() method, and retrieves the minimum and maximum elements in the stack again. The output is the minimum and maximum elements in the stack at each step.\n1\nstackoverflow\n2\nstackexchange\n3\ngeeksforgeeks\n4\nprinceton\n5\npython"
    },
    {
        "Input": "Create a program to find the median of two sorted arrays of different sizes.",
        "Output": "To find the median of two sorted arrays of different sizes, there are several approaches. One simple approach is to merge both sorted arrays into a single sorted array and then find the median of the merged array. If the total number of elements in the merged array is odd, the median is the middle element. If the total number of elements is even, the median is the average of the two middle elements. This approach has a time complexity of O(m+n), where m and n are the sizes of the two input arrays, and a space complexity of O(m+n)\n1\n2\n3\n.\nHere's an example implementation of the above approach in Python:\npython\ndef find_median(arr1, arr2):\n    m, n = len(arr1), len(arr2)\n    merged = []\n    i, j = 0, 0\n    while i < m and j < n:\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    while i < m:\n        merged.append(arr1[i])\n        i += 1\n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    total = m + n\n    if total % 2 == 0:\n        mid = total // 2\n        return (merged[mid-1] + merged[mid]) / 2\n    else:\n        mid = total // 2\n        return merged[mid]\nThis program defines a function find_median() that takes two sorted arrays arr1 and arr2 as input and returns the median of the two arrays. It first initializes an empty list merged to hold the merged array and two indices i and j to keep track of the current positions in arr1 and arr2, respectively. It then iterates over both arrays and appends the smaller element to the merged list until one of the arrays is exhausted. It then appends the remaining elements of the non-exhausted array to the merged list. Finally, it calculates the total number of elements in the merged array and returns the median as the middle element if the total number of elements is odd, or the average of the two middle elements if the total number of elements is even.\nHere's an example usage of the function:\npython\narr1 = [1, 3, 4, 6, 9]\narr2 = [2, 5, 7, 8, 10]\nprint(find_median(arr1, arr2)) # Output: 5.5\nThis program creates two sorted arrays arr1 and arr2, calls the find_median() function with the arrays as input, and prints the result. The output is the median of the two arrays, which is 5.5 in this case.\nAnother approach to find the median of two sorted arrays of different sizes is to use binary search. This approach has a time complexity of O(log(min(m, n))), where m and n are the sizes of the two input arrays, and a space complexity of O(1)\n4\n5\n. However, this approach is more complex and requires careful handling of edge cases.\n1\nenjoyalgorithms\n2\nleetcode\n3\ninterviewbit\n4\ngeeksforgeeks\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given number is a narcissistic number.",
        "Output": "A narcissistic number is a number that is equal to the sum of its own digits raised to the power of the number of digits in the number. For example, 153 is a narcissistic number because 1^3 + 5^3 + 3^3 = 153. To implement a function to check if a given number is a narcissistic number, we can convert the number to a string and iterate over its digits, summing each digit raised to the power of the number of digits in the number. We can then compare the sum to the original number to determine if it is a narcissistic number. Here's an example implementation of this approach in Python:\npython\ndef is_narcissistic_number(num):\n    digits = str(num)\n    n = len(digits)\n    total = sum(int(digit)**n for digit in digits)\n    return total == num\nThis program defines a function is_narcissistic_number() that takes a number as input and returns true if the number is a narcissistic number, and false otherwise. It first converts the number to a string and calculates the number of digits n. It then iterates over the digits of the string, converts each digit to an integer, raises it to the power of n, and sums the results. Finally, it compares the sum to the original number and returns true if they are equal, and false otherwise.\nHere's an example usage of the function:\npython\nnum1 = 153\nnum2 = 370\nnum3 = 371\nnum4 = 9474\nnum5 = 9475\nprint(is_narcissistic_number(num1)) # Output: True\nprint(is_narcissistic_number(num2)) # Output: True\nprint(is_narcissistic_number(num3)) # Output: True\nprint(is_narcissistic_number(num4)) # Output: True\nprint(is_narcissistic_number(num5)) # Output: False\nThis program creates five numbers num1, num2, num3, num4, and num5, calls the is_narcissistic_number() function with each number as input, and prints the result. The output is true if the number is a narcissistic number, and false otherwise.\n1\nw3resource\n2\ntutorialspoint\n3\nstackoverflow\n4\ncodesansar\n5\ncodepen"
    },
    {
        "Input": "\"Write a program to find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right, down, or diagonally.\"",
        "Output": "To find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right, down, or diagonally, there are several approaches. One simple approach is to use dynamic programming. We can create a 2D array dp of the same size as the grid, where dp[i][j] represents the number of paths from the top-left corner to the cell at row i and column j. We can initialize dp to 1, since there is only one way to reach the top-left corner. We can then iterate over the grid and for each cell that is not on the first row or first column, we update dp[i][j] to be the sum of dp[i-1][j], dp[i][j-1], and dp[i-1][j-1], since we can reach the cell from the cell above, the cell to the left, or the cell diagonally above and to the left. Finally, we return dp[m-1][n-1], where m and n are the number of rows and columns in the grid, as the number of paths from the top-left corner to the bottom-right corner. This approach has a time complexity of O(mn) and a space complexity of O(mn)\n1\n2\n3\n.\nHere's an example implementation of the above approach in Python:\npython\ndef count_paths(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            if i > 0 and j > 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\n            elif i > 0:\n                dp[i][j] = dp[i-1][j]\n            elif j > 0:\n                dp[i][j] = dp[i][j-1]\n    return dp[m-1][n-1]\nThis program defines a function count_paths() that takes a grid as input and returns the number of paths from the top-left corner to the bottom-right corner of the grid. It first initializes a 2D array dp of the same size as the grid to keep track of the number of paths to each cell. It then initializes dp to 1, since there is only one way to reach the top-left corner. It then iterates over the grid and for each cell that is not on the first row or first column, it updates dp[i][j] to be the sum of dp[i-1][j], dp[i][j-1], and dp[i-1][j-1]. Finally, it returns dp[m-1][n-1] as the number of paths from the top-left corner to the bottom-right corner.\nHere's an example usage of the function:\npython\ngrid = [[1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]]\nprint(count_paths(grid)) # Output: 6\nThis program creates a 2D grid grid, calls the count_paths() function with the grid as input, and prints the result. The output is the number of paths from the top-left corner to the bottom-right corner of the grid, which is 6 in this case.\n1\ntakeuforward\n2\nalgotree\n3\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing a circular doubly linked list and implement a method to delete a node at a given position.",
        "Output": "To create a Python class representing a circular doubly linked list and implement a method to delete a node at a given position, we can define a class Node to represent each node in the list, and a class CircularDoublyLinkedList to represent the list itself. The Node class should have three attributes: data to store the data of the node, prev to store a reference to the previous node, and next to store a reference to the next node. The CircularDoublyLinkedList class should have two attributes: head to store a reference to the head node of the list, and size to store the number of nodes in the list. The class should also implement methods to insert a node at the beginning, end, or a given position of the list, and to delete a node at a given position of the list. To delete a node at a given position, we can first check if the list is empty or if the position is out of range. If it is not, we can traverse the list to the node at the given position, update the prev and next pointers of the adjacent nodes to skip the node to be deleted, and decrement the size of the list. Here's an example implementation of this approach in Python:\npython\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass CircularDoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def insert_beginning(self, data):\n        node = Node(data)\n        if not self.head:\n            self.head = node\n            node.prev = node\n            node.next = node\n        else:\n            node.prev = self.head.prev\n            node.next = self.head\n            self.head.prev.next = node\n            self.head.prev = node\n            self.head = node\n        self.size += 1\n\n    def insert_end(self, data):\n        node = Node(data)\n        if not self.head:\n            self.head = node\n            node.prev = node\n            node.next = node\n        else:\n            node.prev = self.head.prev\n            node.next = self.head\n            self.head.prev.next = node\n            self.head.prev = node\n        self.size += 1\n\n    def insert_at_position(self, data, position):\n        if position < 0 or position > self.size:\n            return\n        if position == 0:\n            self.insert_beginning(data)\n        elif position == self.size:\n            self.insert_end(data)\n        else:\n            node = Node(data)\n            curr = self.head\n            for i in range(position):\n                curr = curr.next\n            node.prev = curr.prev\n            node.next = curr\n            curr.prev.next = node\n            curr.prev = node\n            self.size += 1\n\n    def delete_at_position(self, position):\n        if not self.head or position < 0 or position >= self.size:\n            return\n        if self.size == 1:\n            self.head = None\n        else:\n            curr = self.head\n            for i in range(position):\n                curr = curr.next\n            curr.prev.next = curr.next\n            curr.next.prev = curr.prev\n            if position == 0:\n                self.head = curr.next\n        self.size -= 1\nThis program defines a class Node to represent each node in the list, and a class CircularDoublyLinkedList to represent the list itself. It initializes the head attribute to None and the size attribute to 0. It then defines methods to insert a node at the beginning, end, or a given position of the list, and to delete a node at a given position of the list. The insert_beginning() method inserts a node at the beginning of the list by creating a new node, updating its prev and next pointers to point to the last node and the head node, respectively, and updating the prev and next pointers of the last node and the head node to point to the new node. The insert_end() method inserts a node at the end of the list in the same way as the insert_beginning() method. The insert_at_position() method inserts a node at a given position of the list by traversing the list to the node at the given position, creating a new node, updating its prev and next pointers to point to the previous node and the current node, respectively, and updating the prev and next pointers of the previous node and the current node to point to the new node. The delete_at_position() method deletes a node at a given position of the list by traversing the list to the node at the given position, updating the prev and next pointers of the adjacent nodes to skip"
    },
    {
        "Input": "Implement a function to sort a list of integers using the quicksort algorithm.",
        "Output": "Quicksort is an efficient, general-purpose sorting algorithm that works by dividing an array into two sub-arrays, according to whether they are less than or greater than a pivot element, and then recursively sorting the sub-arrays. The pivot element can be chosen in different ways, such as the first, last, or middle element of the array, or a random element. Quicksort has an average and best-case time complexity of O(n*logn), and a worst-case time complexity of O(n^2), although this can be avoided by choosing a good pivot element or using randomized quicksort. Quicksort is a popular sorting algorithm due to its simplicity and efficiency, and is often used as a benchmark for other sorting algorithms.\nTo implement a function to sort a list of integers using the quicksort algorithm, we can define a recursive function quicksort() that takes a list arr as input, chooses a pivot element, partitions the list into two sub-lists, and recursively sorts the sub-lists. The base case of the recursion is when the list has zero or one elements, in which case it is already sorted. The partitioning of the list can be done in different ways, such as the Lomuto partition scheme or the Hoare partition scheme. Here's an example implementation of the quicksort algorithm using the Lomuto partition scheme in Python:\npython\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[-1]\n    i = 0\n    for j in range(len(arr)-1):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    arr[i], arr[-1] = arr[-1], arr[i]\n    left = quicksort(arr[:i])\n    right = quicksort(arr[i+1:])\n    return left + [arr[i]] + right\nThis program defines a function quicksort() that takes a list arr as input and returns a sorted list. It first checks if the list has zero or one elements, in which case it is already sorted and can be returned. It then chooses the last element of the list as the pivot element, and partitions the list into two sub-lists by iterating over the list and swapping elements that are less than the pivot with elements that are greater than or equal to the pivot. It then places the pivot element in its correct position by swapping it with the first element that is greater than or equal to the pivot. It then recursively sorts the left and right sub-lists and returns the concatenation of the sorted left sub-list, the pivot element, and the sorted right sub-list.\nHere's an example usage of the function:\npython\narr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nsorted_arr = quicksort(arr)\nprint(sorted_arr) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nThis program creates a list arr, calls the quicksort() function with the list as input, and prints the sorted list. The output is the sorted list, which is\n1\n1\n2\n3\n3\n4\n5\n5\n5\n6\n9\nin this case.\n1\nwikipedia\n2\ntowardsdatascience\n3\ngeeksforgeeks\n4\nalgotree\n5\nprogramiz"
    },
    {
        "Input": "\"Write a program to find the maximum difference between two elements in a given list, with the second element appearing after the first, and the first element being smaller.\"",
        "Output": "To find the maximum difference between two elements in a given list, with the second element appearing after the first, and the first element being smaller, we can use a simple approach that involves iterating over the list and keeping track of the minimum element seen so far and the maximum difference seen so far. For each element in the list, we check if it is smaller than the current minimum. If it is, we update the minimum. Otherwise, we calculate the difference between the current element and the minimum, and update the maximum difference if it is greater than the current maximum difference. Here's an example implementation of this approach in Python:\npython\ndef max_difference(arr):\n    if len(arr) < 2:\n        return None\n    min_elem = arr[0]\n    max_diff = 0\n    for elem in arr[1:]:\n        if elem < min_elem:\n            min_elem = elem\n        else:\n            diff = elem - min_elem\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff\nThis program defines a function max_difference() that takes a list arr as input and returns the maximum difference between two elements in the list, with the second element appearing after the first, and the first element being smaller. It first checks if the list has less than two elements, in which case it returns None. It then initializes the minimum element seen so far to the first element of the list, and the maximum difference seen so far to 0. It then iterates over the remaining elements of the list, and for each element, it checks if it is smaller than the current minimum. If it is, it updates the minimum. Otherwise, it calculates the difference between the current element and the minimum, and updates the maximum difference if it is greater than the current maximum difference. Finally, it returns the maximum difference.\nHere's an example usage of the function:\npython\narr = [2, 3, 8, 0, 7]\nmax_diff = max_difference(arr)\nprint(max_diff) # Output: 7\nThis program creates a list arr, calls the max_difference() function with the list as input, and prints the maximum difference between two elements in the list, with the second element appearing after the first, and the first element being smaller. The output is 7 in this case.\n1\nstackoverflow\n2\nrosettacode\n3\nenjoyalgorithms\n4\ngeeksforgeeks\n5\ntechiedelight"
    },
    {
        "Input": "Create a program to find the largest sum of a non-empty subarray with a given target sum in a list of integers.",
        "Output": "To find the largest sum of a non-empty subarray with a given target sum in a list of integers, we can use a sliding window approach. We can initialize two pointers, left and right, to the beginning of the list. We can then iterate over the list, adding each element to a running sum curr_sum. If curr_sum is greater than or equal to the target sum, we can update the maximum sum seen so far and move the left pointer to the right, subtracting the element at the previous left position from curr_sum. We continue this process until we reach the end of the list or the maximum sum is equal to the target sum. If the maximum sum is less than the target sum, there is no subarray with a sum equal to the target sum. Here's an example implementation of this approach in Python:\npython\ndef max_subarray_sum(arr, target_sum):\n    left = 0\n    right = 0\n    curr_sum = 0\n    max_sum = float('-inf')\n    while right < len(arr):\n        curr_sum += arr[right]\n        while curr_sum >= target_sum:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= arr[left]\n            left += 1\n        right += 1\n    return max_sum if max_sum != float('-inf') else None\nThis program defines a function max_subarray_sum() that takes a list arr and a target sum target_sum as input and returns the largest sum of a non-empty subarray with a sum less than or equal to the target sum. It initializes two pointers, left and right, to the beginning of the list, and initializes curr_sum and max_sum to 0 and negative infinity, respectively. It then iterates over the list, adding each element to curr_sum. If curr_sum is greater than or equal to the target sum, it updates max_sum and moves the left pointer to the right, subtracting the element at the previous left position from curr_sum. It continues this process until it reaches the end of the list or the maximum sum is equal to the target sum. If the maximum sum is less than the target sum, it returns None.\nHere's an example usage of the function:\npython\narr = [1, 2, 3, 4, 5]\ntarget_sum = 11\nmax_sum = max_subarray_sum(arr, target_sum)\nprint(max_sum) # Output: 10\nThis program creates a list arr and a target sum target_sum, calls the max_subarray_sum() function with the list and target sum as input, and prints the largest sum of a non-empty subarray with a sum less than or equal to the target sum. The output is 10 in this case.\n1\nleetcode\n2\ngeeksforgeeks\n3\ngeeksforgeeks\n4\njavatpoint\n5\ninterviewbit"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, and angle brackets.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, and angle brackets, we can use a combination of approaches. One approach is to use a stack to keep track of the opening symbols, and pop them off the stack when a closing symbol is encountered. If the stack is empty at the end of the string, the expression is balanced. We can also use regular expressions to match the opening and closing symbols, and count the number of occurrences of each symbol to ensure that they are balanced. Here are some resources that provide more information and examples of these approaches:\nStack approach:\n1\n2\n3\n4\nRegular expressions approach:\n5\nHere's an example implementation of the stack approach in Python:\npython\ndef is_balanced(expr):\n    stack = []\n    for symbol in expr:\n        if symbol in '([{<':\n            stack.append(symbol)\n        elif symbol in ')]}>':\n            if not stack:\n                return False\n            if symbol == ')' and stack[-1] != '(':\n                return False\n            if symbol == ']' and stack[-1] != '[':\n                return False\n            if symbol == '}' and stack[-1] != '{':\n                return False\n            if symbol == '>' and stack[-1] != '<':\n                return False\n            stack.pop()\n    return not stack\nThis program defines a function is_balanced() that takes a string expr as input and returns true if the expression has balanced parentheses, brackets, curly braces, quotes, and angle brackets, and false otherwise. It initializes an empty stack, and iterates over the characters of the string. If a symbol is an opening symbol, it is pushed onto the stack. If a symbol is a closing symbol, it is compared to the top of the stack, and if they match, the opening symbol is popped off the stack. If the stack is empty at the end of the string, the expression is balanced.\nHere's an example usage of the function:\npython\nexpr1 = '({[<>]})'\nexpr2 = '({[<]})'\nprint(is_balanced(expr1)) # Output: True\nprint(is_balanced(expr2)) # Output: False\nThis program creates two expressions expr1 and expr2, calls the is_balanced() function with each expression as input, and prints the result. The output is true if the expression has balanced parentheses, brackets, curly braces, quotes, and angle brackets, and false otherwise. The output for expr1 is True, and the output for expr2 is False.\n1\nstackoverflow\n2\ngeeksforgeeks\n3\nfavtutor\n4\ngeeksforgeeks\n5\nhackernoon"
    },
    {
        "Input": "\"Write a Python class representing a hash map using separate chaining for collision resolution and implement methods to insert, retrieve, and remove key-value pairs.\"",
        "Output": "Here's an example implementation of a Python class representing a hash map using separate chaining for collision resolution and implementing methods to insert, retrieve, and remove key-value pairs, based on the resources\n1\n2\n3\n:\npython\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n\nclass HashMap:\n    def __init__(self, size=16):\n        self.size = size\n        self.hash_table = [None] * self.size\n\n    def _hash_func(self, key):\n        return hash(key) % self.size\n\n    def insert(self, key, value):\n        index = self._hash_func(key)\n        if not self.hash_table[index]:\n            self.hash_table[index] = Node(key, value)\n        else:\n            curr = self.hash_table[index]\n            while curr.next:\n                if curr.key == key:\n                    curr.value = value\n                    return\n                curr = curr.next\n            if curr.key == key:\n                curr.value = value\n            else:\n                curr.next = Node(key, value)\n\n    def retrieve(self, key):\n        index = self._hash_func(key)\n        curr = self.hash_table[index]\n        while curr:\n            if curr.key == key:\n                return curr.value\n            curr = curr.next\n        return None\n\n    def remove(self, key):\n        index = self._hash_func(key)\n        curr = self.hash_table[index]\n        prev = None\n        while curr:\n            if curr.key == key:\n                if prev:\n                    prev.next = curr.next\n                else:\n                    self.hash_table[index] = curr.next\n                return\n            prev = curr\n            curr = curr.next\nThis program defines a class Node to represent a node in a linked list, and a class HashMap to represent a hash map using separate chaining for collision resolution. The Node class has three attributes: key to store the key of the node, value to store the value of the node, and next to store a reference to the next node in the list. The HashMap class has two attributes: size to store the size of the hash table, and hash_table to store the linked lists at each index of the hash table. The class also defines three methods: insert() to insert a key-value pair into the hash map, retrieve() to retrieve the value associated with a key from the hash map, and remove() to remove a key-value pair from the hash map.\nThe insert() method first calculates the hash value of the key using the _hash_func() method, and checks if the corresponding index of the hash table is empty. If it is, it creates a new node with the key-value pair and inserts it at the index. If it is not empty, it iterates over the linked list at the index, checking if the key already exists in the list. If it does, it updates the value of the existing node. If it does not, it creates a new node and appends it to the end of the list.\nThe retrieve() method first calculates the hash value of the key using the _hash_func() method, and iterates over the linked list at the corresponding index of the hash table, checking if the key matches the key of a node in the list. If it does, it returns the value of the node. If it does not, it returns None.\nThe remove() method first calculates the hash value of the key using the _hash_func() method, and iterates over the linked list at the corresponding index of the hash table, checking if the key matches the key of a node in the list. If it does, it removes the node from the list by updating the next pointer of the previous node to skip the node to be removed.\nHere's an example usage of the class:\npython\nhash_map = HashMap()\nhash_map.insert('apple', 1)\nhash_map.insert('banana', 2)\nhash_map.insert('cherry', 3)\nprint(hash_map.retrieve('banana')) # Output: 2\nhash_map.remove('banana')\nprint(hash_map.retrieve('banana')) # Output: None\nThis program creates an instance of HashMap, inserts three key-value pairs into the hash map using the insert() method, retrieves the value associated with the key 'banana' using the retrieve() method, removes the key-value pair associated with the key 'banana' using the remove() method, and retrieves the value associated with the key 'banana' again to confirm that it is None.\n1\nleetcode\n2\ngithub\n3\ngeeksforgeeks"
    },
    {
        "Input": "Create a program to find the length of the longest palindromic substring in a given string.",
        "Output": "To find the length of the longest palindromic substring in a given string, we can use a dynamic programming approach that involves creating a table to store the results of subproblems. We can initialize a table table of size n x n, where n is the length of the string, and set table[i][i] to true for all i. We can then iterate over the string, checking if each substring of length k is a palindrome, where k ranges from 2 to n. If a substring is a palindrome, we set table[i][i+k-1] to true. We can keep track of the longest palindrome seen so far and return its length. Here's an example implementation of this approach in Python:\npython\ndef longest_palindrome(s):\n    n = len(s)\n    table = [[False for _ in range(n)] for _ in range(n)]\n    max_len = 1\n    for i in range(n):\n        table[i][i] = True\n    for k in range(2, n+1):\n        for i in range(n-k+1):\n            j = i + k - 1\n            if s[i] == s[j] and (k == 2 or table[i+1][j-1]):\n                table[i][j] = True\n                max_len = max(max_len, k)\n    return max_len\nThis program defines a function longest_palindrome() that takes a string s as input and returns the length of the longest palindromic substring in the string. It first initializes a table table of size n x n, where n is the length of the string, and sets table[i][i] to true for all i. It then iterates over the string, checking if each substring of length k is a palindrome, where k ranges from 2 to n. If a substring is a palindrome, it sets table[i][i+k-1] to true. It keeps track of the longest palindrome seen so far and returns its length.\nHere's an example usage of the function:\npython\ns = 'forgeeksskeegfor'\nmax_len = longest_palindrome(s)\nprint(max_len) # Output: 10\nThis program creates a string s, calls the longest_palindrome() function with the string as input, and prints the length of the longest palindromic substring in the string. The output is 10 in this case.\n1\nlogicmojo\n2\nleetcode\n3\ninterviewbit\n4\nwikipedia\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given number is a perfect square using binary search.",
        "Output": "To check if a given number is a perfect square using binary search, we can use the fact that the square of a number is always non-negative and increasing. Therefore, we can use binary search to find the square root of the number, and check if the square of the mid-point is equal to the number. If it is, the number is a perfect square. If the square of the mid-point is greater than the number, we search the left half of the range. If it is less than the number, we search the right half of the range. We repeat this process until we find the square root or the range is exhausted. Here's an example implementation of this approach in Python:\npython\ndef is_perfect_square(n):\n    if n < 2:\n        return True\n    left = 2\n    right = n // 2\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        if square == n:\n            return True\n        elif square > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\nThis program defines a function is_perfect_square() that takes a number n as input and returns true if the number is a perfect square, and false otherwise. It first checks if the number is less than 2, in which case it is a perfect square. It then initializes a range from 2 to n // 2, and iteratively searches for the square root of the number using binary search. If the square of the mid-point is equal to the number, it returns true. If the square of the mid-point is greater than the number, it searches the left half of the range. If it is less than the number, it searches the right half of the range. It repeats this process until it finds the square root or the range is exhausted. If it does not find the square root, it returns false.\nHere's an example usage of the function:\npython\nn1 = 16\nn2 = 14\nprint(is_perfect_square(n1)) # Output: True\nprint(is_perfect_square(n2)) # Output: False\nThis program creates two numbers n1 and n2, calls the is_perfect_square() function with each number as input, and prints the result. The output is true if the number is a perfect square, and false otherwise. The output for n1 is True, and the output for n2 is False.\n1\nleetcode\n2\nyoutube\n3\ngeeksforgeeks\n4\nleetcode\n5\ntechiedelight"
    },
    {
        "Input": "\"Write a program to find the maximum sum path in a binary tree, where the path can start and end at any node.\"",
        "Output": "To find the maximum sum path in a binary tree, where the path can start and end at any node, we can use a dynamic programming approach that involves calculating the maximum path sum through each node of the tree. We can define a recursive function max_path_sum() that takes a node as input and returns the maximum path sum through that node. The maximum path sum through a node is the maximum of the node value, the node value plus the maximum path sum through the left child, the node value plus the maximum path sum through the right child, and the node value plus the maximum path sum through the left child and the right child. We can then recursively calculate the maximum path sum through each node of the tree, keeping track of the maximum path sum seen so far. Here's an example implementation of this approach in Python:\npython\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef max_path_sum(root):\n    def max_path_sum_helper(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        left_sum = max(max_path_sum_helper(node.left), 0)\n        right_sum = max(max_path_sum_helper(node.right), 0)\n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n        return node.val + max(left_sum, right_sum)\n    max_sum = float('-inf')\n    max_path_sum_helper(root)\n    return max_sum\nThis program defines a class Node to represent a node in a binary tree, and a function max_path_sum() that takes a root node as input and returns the maximum sum path in the binary tree. The function defines a helper function max_path_sum_helper() that takes a node as input and returns the maximum path sum through that node. It first checks if the node is None, in which case it returns 0. It then calculates the maximum path sum through the left child and the right child using recursion, and takes the maximum of these values and 0 to handle negative values. It then calculates the maximum path sum through the node by adding the node value, the maximum path sum through the left child, and the maximum path sum through the right child. It updates the maximum path sum seen so far if the current maximum path sum is greater than the previous maximum path sum. It then returns the maximum path sum through the node. The max_path_sum() function initializes the maximum path sum seen so far to negative infinity, calls the max_path_sum_helper() function with the root node as input, and returns the maximum path sum seen so far.\nHere's an example usage of the function:\npython\nroot = Node(10)\nroot.left = Node(2)\nroot.right = Node(10)\nroot.left.left = Node(20)\nroot.left.right = Node(1)\nroot.right.right = Node(-25)\nroot.right.right.left = Node(3)\nroot.right.right.right = Node(4)\nmax_sum = max_path_sum(root)\nprint(max_sum) # Output: 42\nThis program creates a binary tree root, calls the max_path_sum() function with the root node as input, and prints the maximum sum path in the binary tree. The output is 42 in this case.\n1\ntakeuforward\n2\ntechiedelight\n3\ninterviewbit\n4\neducative\n5\nleetcode"
    },
    {
        "Input": "Create a Python class representing a directed weighted graph and implement methods to find the shortest path using Dijkstra's algorithm.",
        "Output": "To create a Python class representing a directed weighted graph and implement methods to find the shortest path using Dijkstra's algorithm, we can use a combination of approaches. One approach is to define a class Graph that represents a directed weighted graph using an adjacency matrix, and define a method dijkstra() that implements Dijkstra's algorithm to find the shortest path between two nodes in the graph. Another approach is to define a class Graph that represents a directed weighted graph using a dictionary of nodes and edges, and define a method dijkstra() that implements Dijkstra's algorithm to find the shortest path between two nodes in the graph. Here are some resources that provide more information and examples of these approaches:\nUsing an adjacency matrix:\n1\n2\nUsing a dictionary of nodes and edges:\n3\n4\n5\n6\nHere's an example implementation of the adjacency matrix approach in Python:\npython\nimport sys\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge(self, u, v, weight):\n        self.graph[u][v] = weight\n\n    def dijkstra(self, start):\n        visited = [False] * self.vertices\n        distances = [sys.maxsize] * self.vertices\n        distances[start] = 0\n        for _ in range(self.vertices):\n            min_distance = sys.maxsize\n            for v in range(self.vertices):\n                if not visited[v] and distances[v] < min_distance:\n                    min_distance = distances[v]\n                    u = v\n            visited[u] = True\n            for v in range(self.vertices):\n                if self.graph[u][v] > 0 and not visited[v]:\n                    new_distance = distances[u] + self.graph[u][v]\n                    if new_distance < distances[v]:\n                        distances[v] = new_distance\n        return distances\nThis program defines a class Graph that represents a directed weighted graph using an adjacency matrix. The class has two attributes: vertices to store the number of vertices in the graph, and graph to store the edges in the graph as a matrix. The class also defines two methods: add_edge() to add an edge to the graph, and dijkstra() to implement Dijkstra's algorithm to find the shortest path between two nodes in the graph. The add_edge() method takes three inputs: u and v to represent the nodes of the edge, and weight to represent the weight of the edge. It updates the corresponding entry in the adjacency matrix with the weight of the edge. The dijkstra() method takes one input: start to represent the starting node of the shortest path. It initializes two lists: visited to keep track of the visited nodes, and distances to keep track of the shortest distance from the starting node to each node in the graph. It sets the distance of the starting node to 0, and iteratively updates the distances of the unvisited nodes using Dijkstra's algorithm. It returns the list of shortest distances.\nHere's an example usage of the class:\npython\ng = Graph(4)\ng.add_edge(0, 1, 1)\ng.add_edge(0, 2, 4)\ng.add_edge(1, 2, 2)\ng.add_edge(1, 3, 5)\ng.add_edge(2, 3, 1)\ndistances = g.dijkstra(0)\nprint(distances) # Output: [0, 1, 3, 4]\nThis program creates a graph g with 4 vertices, adds 5 edges to the graph using the add_edge() method, calls the dijkstra() method with the starting node 0 as input, and prints the list of shortest distances from the starting node to each node in the graph. The output is\n0\n1\n3\n4\nin this case.\nHere's an example implementation of the dictionary approach in Python:\npython\nimport heapq\nimport sys\n\nclass Graph:\n    def __init__(self):\n        self.nodes = set()\n        self.edges = {}\n\n    def add_edge(self, u, v, weight):\n        self.nodes.add(u)\n        self.nodes.add(v)\n        if u not in self.edges:\n            self.edges[u] = []\n        self.edges[u].append((v, weight))\n\n    def dijkstra(self, start):\n        distances = {node: sys.maxsize for node in self.nodes}\n        distances[start] = 0\n        queue = [(0, start)]\n        while queue:\n            (dist, u) = heapq.heappop(queue)\n            if dist > distances[u]:\n                continue\n            for (v, weight) in self.edges.get(u, []):\n                new_distance = dist + weight\n                if new_distance < distances[v]:\n                    distances[v] = new_distance\n                    heapq.heappush(queue, (new_distance, v))\n        return distances\nThis program defines a class Graph that represents a directed weighted graph using a dictionary of nodes and edges. The class has two attributes: nodes to store the set of nodes in the graph, and edges to store the edges in the graph as a dictionary of lists. The class also defines two methods: add_edge() to add an edge to the graph, and dijkstra() to implement Dijkstra's algorithm to find the shortest path between"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, we can use a combination of approaches. One approach is to use a stack to keep track of the opening symbols, and pop them off the stack when a closing symbol is encountered. If the stack is empty at the end of the string, the expression is balanced. We can also use regular expressions to match the opening and closing symbols, and count the number of occurrences of each symbol to ensure that they are balanced. Here are some resources that provide more information and examples of these approaches:\nUsing a stack:\n1\n2\n3\nUsing regular expressions:\n4\nHere's an example implementation of the stack approach in Python:\npython\ndef is_balanced(expr):\n    stack = []\n    opening = \"([{<\\\"'\"\n    closing = \")]}>\\\"'\"\n    escapes = \"\\\\\"\n    for symbol in expr:\n        if symbol in opening:\n            stack.append(symbol)\n        elif symbol in closing:\n            if not stack:\n                return False\n            if opening.index(stack[-1]) != closing.index(symbol):\n                return False\n            stack.pop()\n        elif symbol in escapes:\n            continue\n    return not stack\nThis program defines a function is_balanced() that takes a string expr as input and returns true if the string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, and false otherwise. It first initializes a stack to keep track of the opening symbols, and defines the opening and closing symbols and escape characters. It then iterates over the string, checking if each symbol is an opening symbol, a closing symbol, or an escape character. If the symbol is an opening symbol, it pushes it onto the stack. If the symbol is a closing symbol, it checks if the stack is empty, and if the opening symbol at the top of the stack matches the closing symbol. If the symbol is an escape character, it skips it. It returns true if the stack is empty at the end of the string, and false otherwise.\nHere's an example usage of the function:\npython\nexpr1 = \"((a+b)*c)\"\nexpr2 = \"{[(a+b)*c]/d}\"\nexpr3 = \"((a+b)*c\"\nprint(is_balanced(expr1)) # Output: True\nprint(is_balanced(expr2)) # Output: True\nprint(is_balanced(expr3)) # Output: False\nThis program creates three strings expr1, expr2, and expr3, calls the is_balanced() function with each string as input, and prints the result. The output is true if the string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, and false otherwise. The output for expr1 and expr2 is True, and the output for expr3 is False.\n1\nstackoverflow\n2\ngeeksforgeeks\n3\nfavtutor\n4\nhackernoon"
    },
    {
        "Input": "Write a program to find the maximum length of a subarray with equal number of 0s and 1s in a given binary array.",
        "Output": "To find the maximum length of a subarray with equal number of 0s and 1s in a given binary array, we can use a dynamic programming approach that involves keeping track of the count of 0s and 1s seen so far, and the index at which they were seen. We can initialize two variables count and max_len to 0, and a dictionary count_dict to store the count of 0s and 1s seen so far and their corresponding indices. We can then iterate over the binary array, incrementing the count by 1 if the current element is 1, and decrementing the count by 1 if the current element is 0. If the count is 0, we have seen an equal number of 0s and 1s so far, and we can update the maximum length seen so far to be the maximum of the current index and the index at which the count was 0 minus the index at which the same count was seen before. We can update the dictionary with the current count and index if the count is not already in the dictionary. Here's an example implementation of this approach in Python:\npython\ndef max_length_subarray(arr):\n    count = 0\n    max_len = 0\n    count_dict = {0: -1}\n    for i in range(len(arr)):\n        if arr[i] == 1:\n            count += 1\n        else:\n            count -= 1\n        if count in count_dict:\n            max_len = max(max_len, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    return max_len\nThis program defines a function max_length_subarray() that takes a binary array arr as input and returns the maximum length of a subarray with equal number of 0s and 1s in the array. It first initializes the count of 0s and 1s seen so far to 0, the maximum length seen so far to 0, and a dictionary count_dict to store the count of 0s and 1s seen so far and their corresponding indices. It then iterates over the binary array, incrementing the count by 1 if the current element is 1, and decrementing the count by 1 if the current element is 0. If the count is 0, it updates the maximum length seen so far to be the maximum of the current index and the index at which the count was 0 minus the index at which the same count was seen before. It updates the dictionary with the current count and index if the count is not already in the dictionary. It returns the maximum length seen so far.\nHere's an example usage of the function:\npython\narr = [0, 1, 0, 1, 0, 0, 1, 1]\nmax_len = max_length_subarray(arr)\nprint(max_len) # Output: 6\nThis program creates a binary array arr, calls the max_length_subarray() function with the array as input, and prints the maximum length of a subarray with equal number of 0s and 1s in the array. The output is 6 in this case.\n1\ngeeksforgeeks\n2\ninterviewbit\n3\ntakeuforward\n4\ntechiedelight\n5\npepcoding"
    },
    {
        "Input": "Create a program to find the maximum sum of a non-empty subarray with a given target sum in a list of positive integers.",
        "Output": "To find the maximum sum of a non-empty subarray with a given target sum in a list of positive integers, we can use a sliding window approach. We can initialize two pointers start and end to the first element of the list, and a variable curr_sum to the value of the first element. We can then iterate over the list, adding the value of the current element to curr_sum. If curr_sum is greater than or equal to the target sum, we can update the maximum sum seen so far to be the maximum of the current sum and the maximum sum seen so far. We can then subtract the value of the element at the start pointer from curr_sum, and increment the start pointer. We repeat this process until the end pointer reaches the end of the list. Here's an example implementation of this approach in Python:\npython\ndef max_sum_subarray(arr, target_sum):\n    start = 0\n    end = 0\n    curr_sum = arr[0]\n    max_sum = float('-inf')\n    while end < len(arr):\n        if curr_sum == target_sum:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= arr[start]\n            start += 1\n        elif curr_sum < target_sum:\n            end += 1\n            if end < len(arr):\n                curr_sum += arr[end]\n        else:\n            curr_sum -= arr[start]\n            start += 1\n    return max_sum if max_sum != float('-inf') else None\nThis program defines a function max_sum_subarray() that takes a list of positive integers arr and a target sum target_sum as input, and returns the maximum sum of a non-empty subarray with the target sum in the list. It first initializes the start and end pointers to the first element of the list, the curr_sum variable to the value of the first element, and the max_sum variable to negative infinity. It then iterates over the list, adding the value of the current element to curr_sum. If curr_sum is equal to the target sum, it updates the maximum sum seen so far to be the maximum of the current sum and the maximum sum seen so far, subtracts the value of the element at the start pointer from curr_sum, and increments the start pointer. If curr_sum is less than the target sum, it increments the end pointer and adds the value of the element at the new end pointer to curr_sum. If curr_sum is greater than the target sum, it subtracts the value of the element at the start pointer from curr_sum, and increments the start pointer. It repeats this process until the end pointer reaches the end of the list. It returns the maximum sum seen so far if it is not negative infinity, and None otherwise.\nHere's an example usage of the function:\npython\narr = [1, 2, 3, 4, 5]\ntarget_sum = 11\nmax_sum = max_sum_subarray(arr, target_sum)\nprint(max_sum) # Output: 10\nThis program creates a list of positive integers arr, sets the target sum to 11, calls the max_sum_subarray() function with the list and the target sum as input, and prints the maximum sum of a non-empty subarray with the target sum in the list. The output is 10 in this case.\n1\nleetcode\n2\ngeeksforgeeks\n3\ninterviewbit\n4\njavatpoint\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to find the minimum number of characters to be added to a string to make it a palindrome.",
        "Output": "To find the minimum number of characters to be added to a string to make it a palindrome, we can use a dynamic programming approach that involves finding the longest palindromic subsequence of the string, and subtracting its length from the length of the string. We can define a recursive function lps() that takes a string as input and returns the length of the longest palindromic subsequence of the string. The length of the longest palindromic subsequence of a string is the maximum of the length of the longest palindromic subsequence of the string without the first character, the string without the last character, and the string without the first and last characters, plus 2 if the first and last characters are the same, and 0 otherwise. We can then call this function with the input string, and subtract its length from the length of the input string to get the minimum number of characters to be added to the string to make it a palindrome. Here's an example implementation of this approach in Python:\npython\ndef min_chars_to_palindrome(s):\n    def lps(s, i, j, memo):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if s[i] == s[j]:\n            memo[(i, j)] = lps(s, i+1, j-1, memo) + 2\n        else:\n            memo[(i, j)] = max(lps(s, i+1, j, memo), lps(s, i, j-1, memo))\n        return memo[(i, j)]\n    return len(s) - lps(s, 0, len(s)-1, {})\nThis program defines a function min_chars_to_palindrome() that takes a string s as input and returns the minimum number of characters to be added to the string to make it a palindrome. It first defines a helper function lps() that takes a string s, two indices i and j, and a dictionary memo to store the length of the longest palindromic subsequence of the substring s[i:j+1]. It first checks if the indices are out of bounds, in which case it returns 0 or 1 depending on the length of the substring. It then checks if the length of the longest palindromic subsequence of the substring is already in the memo, and returns it if it is. If the first and last characters of the substring are the same, it recursively calls lps() with the substring without the first and last characters, and adds 2 to the result. Otherwise, it recursively calls lps() with the substring without the first character, and with the substring without the last character, and returns the maximum of the two results. It stores the result in the memo before returning it. The min_chars_to_palindrome() function calls the lps() function with the input string, and subtracts its length from the length of the input string to get the minimum number of characters to be added to the string to make it a palindrome.\nHere's an example usage of the function:\npython\ns = \"abede\"\nmin_chars = min_chars_to_palindrome(s)\nprint(min_chars) # Output: 2\nThis program creates a string s, calls the min_chars_to_palindrome() function with the string as input, and prints the minimum number of characters to be added to the string to make it a palindrome. The output is 2 in this case.\n1\ngeeksforgeeks\n2\ngeeksforgeeks\n3\nyoutube\n4\ninterviewbit\n5\nleetcode"
    },
    {
        "Input": "Write a Python class representing a binary trie and implement methods to insert and search for binary numbers.",
        "Output": "Here's a Python class representing a binary trie and implementing methods to insert and search for binary numbers, based on the resources\n1\nand\n2\n:\npython\nclass BinaryTrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass BinaryTrie:\n    def __init__(self):\n        self.root = BinaryTrieNode()\n\n    def insert(self, num):\n        current = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not current.children[bit]:\n                current.children[bit] = BinaryTrieNode()\n            current = current.children[bit]\n\n    def search(self, num):\n        current = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not current.children[bit]:\n                return False\n            current = current.children[bit]\n        return True\nThis program defines a class BinaryTrieNode that represents a node in a binary trie, and a class BinaryTrie that represents a binary trie and implements methods to insert and search for binary numbers. The BinaryTrieNode class has an attribute children that is a list of two elements, representing the left and right children of the node. The BinaryTrie class has an attribute root that is a BinaryTrieNode representing the root of the trie. The BinaryTrie class defines two methods: insert() to insert a binary number into the trie, and search() to search for a binary number in the trie. The insert() method takes a binary number num as input, and iterates over its bits from left to right. It checks if the current bit is already a child of the current node, and creates a new child node if it is not. It then moves down to the child node corresponding to the current bit. The search() method takes a binary number num as input, and iterates over its bits from left to right. It checks if the current bit is a child of the current node, and moves down to the child node corresponding to the current bit if it is. If the end of the binary number is reached and the final node is not None, the method returns True, indicating that the binary number is in the trie. Otherwise, it returns False.\nHere's an example usage of the class:\npython\ntrie = BinaryTrie()\ntrie.insert(0b1010)\ntrie.insert(0b1101)\ntrie.insert(0b1111)\nprint(trie.search(0b1010)) # Output: True\nprint(trie.search(0b1100)) # Output: False\nThis program creates a BinaryTrie object trie, inserts three binary numbers into the trie using the insert() method, and searches for two binary numbers using the search() method. The output is True for the first search and False for the second search.\n1\nmedium\n2\ngeeksforgeeks"
    },
    {
        "Input": "Create a program to find the longest common prefix among a list of strings.",
        "Output": "To find the longest common prefix among a list of strings, there are several approaches we can use. One approach is to compare the characters of the strings in the list one by one until a mismatch is found. Another approach involves utilizing the built-in zip() function and string slicing to extract the common prefix. A third approach is to sort the list of strings and find the common prefix of the first and last string of the sorted list. Here are some resources that provide more information and examples of these approaches:\nComparison of characters:\n1\n2\n3\nzip() and string slicing:\n4\nSorting:\n5\n6\nHere's an example implementation of the comparison of characters approach in Python:\npython\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        for j in range(1, len(strs)):\n            if i >= len(strs[j]) or strs[j][i] != strs[0][i]:\n                return strs[0][:i]\n    return strs[0]\nThis program defines a function longest_common_prefix() that takes a list of strings strs as input and returns the longest common prefix among the strings. It first checks if the list is empty, and returns an empty string if it is. It then iterates over the characters of the first string in the list, and compares each character to the corresponding character in the other strings in the list. If a mismatch is found, it returns the prefix up to that point. If no mismatch is found, it returns the entire first string.\nHere's an example usage of the function:\npython\nstrs = [\"flower\", \"flow\", \"flight\"]\nprefix = longest_common_prefix(strs)\nprint(prefix) # Output: \"fl\"\nThis program creates a list of strings strs, calls the longest_common_prefix() function with the list as input, and prints the longest common prefix among the strings. The output is \"fl\" in this case.\n1\ninterviewbit\n2\nstudytonight\n3\ngeeksforgeeks\n4\nleetcode\n5\ngeeksforgeeks\n6\neducative"
    },
    {
        "Input": "Implement a function to check if a given number is a palindrome in binary representation.",
        "Output": "To check if a given number is a palindrome in binary representation, we can use a couple of approaches. One approach is to convert the number to its binary representation, reverse the binary representation, and compare it to the original binary representation. Another approach is to compare the bits of the number from left to right with the bits from right to left until a mismatch is found. Here are some resources that provide more information and examples of these approaches:\nConverting to binary and reversing:\n1\n2\n3\n4\nComparing bits:\n5\n6\nHere's an example implementation of the converting to binary and reversing approach in Python:\npython\ndef is_binary_palindrome(num):\n    binary = bin(num)[2:]\n    return binary == binary[::-1]\nThis program defines a function is_binary_palindrome() that takes a number num as input and returns True if the binary representation of the number is a palindrome, and False otherwise. It first converts the number to its binary representation using the built-in bin() function, and slices off the first two characters (\"0b\") to get the binary string. It then compares the binary string to its reverse using string slicing.\nHere's an example usage of the function:\npython\nnum1 = 9\nnum2 = 10\nprint(is_binary_palindrome(num1)) # Output: True\nprint(is_binary_palindrome(num2)) # Output: False\nThis program creates two numbers num1 and num2, calls the is_binary_palindrome() function with each number as input, and prints the result. The output is True for num1 and False for num2.\nAnother approach is to compare the bits of the number from left to right with the bits from right to left until a mismatch is found. Here's an example implementation of this approach in Python:\npython\ndef is_binary_palindrome(num):\n    left = 31\n    right = 0\n    while left > right:\n        if (num >> left) & 1 != (num >> right) & 1:\n            return False\n        left -= 1\n        right += 1\n    return True\nThis program defines a function is_binary_palindrome() that takes a number num as input and returns True if the binary representation of the number is a palindrome, and False otherwise. It initializes two pointers left and right to the leftmost and rightmost bits of the number, respectively. It then iterates over the bits of the number from left to right and from right to left, comparing each pair of bits until a mismatch is found or the pointers cross. If a mismatch is found, it returns False. If the pointers cross without finding a mismatch, it returns True.\nHere's an example usage of the function:\npython\nnum1 = 9\nnum2 = 10\nprint(is_binary_palindrome(num1)) # Output: True\nprint(is_binary_palindrome(num2)) # Output: False\nThis program creates two numbers num1 and num2, calls the is_binary_palindrome() function with each number as input, and prints the result. The output is True for num1 and False for num2.\n1\nstackoverflow\n2\ntutorialspoint\n3\ngeeksforgeeks\n4\ngeeksforgeeks\n5\ntechiedelight\n6\neducative"
    },
    {
        "Input": "Write a program to find the longest increasing subarray with equal number of 0s and 1s in a given binary array.",
        "Output": "To find the longest increasing subarray with equal number of 0s and 1s in a given binary array, we can use a similar approach as finding the largest subarray of 0s and 1s. We can first convert the binary array to an array of 1s and -1s, where 1 represents 1 in the binary array and -1 represents 0 in the binary array. We can then find the longest contiguous subarray with a sum of 0 in the array of 1s and -1s using the same approach as finding the largest subarray of 0s and 1s. We can then convert the subarray of 1s and -1s back to a subarray of 0s and 1s in the binary array. Here's an example implementation of this approach in Python:\npython\ndef longest_increasing_subarray(arr):\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr[i] = -1\n    prefix_sum = 0\n    sum_dict = {0: -1}\n    max_len = 0\n    start = -1\n    end = -1\n    for i in range(len(arr)):\n        prefix_sum += arr[i]\n        if prefix_sum in sum_dict:\n            if i - sum_dict[prefix_sum] > max_len:\n                max_len = i - sum_dict[prefix_sum]\n                start = sum_dict[prefix_sum]\n                end = i\n        else:\n            sum_dict[prefix_sum] = i\n    for i in range(start, end+1):\n        if arr[i] == -1:\n            arr[i] = 0\n    return arr[start:end+1]\nThis program defines a function longest_increasing_subarray() that takes a binary array arr as input and returns the longest increasing subarray with equal number of 0s and 1s in the binary array. It first converts the binary array to an array of 1s and -1s, where 1 represents 1 in the binary array and -1 represents 0 in the binary array. It then initializes a prefix sum to 0, a dictionary sum_dict to store the prefix sum and its corresponding index, a variable max_len to store the maximum length seen so far, and two variables start and end to store the start and end indices of the longest subarray seen so far. It then iterates over the array of 1s and -1s, adding each element to the prefix sum and checking if the prefix sum is already in the dictionary. If the prefix sum is in the dictionary, it updates the maximum length seen so far and the start and end indices of the longest subarray seen so far if the current subarray is longer than the previous longest subarray. If the prefix sum is not in the dictionary, it adds the prefix sum and its corresponding index to the dictionary. It then iterates over the binary array from the start index to the end index of the longest subarray seen so far, converting each -1 to 0. It returns the subarray of 0s and 1s corresponding to the longest subarray of 1s and -1s seen so far.\nHere's an example usage of the function:\npython\narr = [1, 0, 1, 0, 1, 1, 0, 1, 0]\nsubarray = longest_increasing_subarray(arr)\nprint(subarray) # Output: [1, 0, 1, 0, 1, 1]\nThis program creates a binary array arr, calls the longest_increasing_subarray() function with the array as input, and prints the longest increasing subarray with equal number of 0s and 1s in the binary array. The output is\n1\n0\n1\n0\n1\n1\nin this case.\n1\ninterviewbit\n2\ngeeksforgeeks\n3\ntechiedelight\n4\ntakeuforward\n5\nleetcode"
    },
    {
        "Input": "Create a Python class representing a circular queue and implement a method to rotate the queue by a given number of positions.",
        "Output": "Here's a Python class representing a circular queue and implementing a method to rotate the queue by a given number of positions, based on the resources\n1\n,\n2\n, and\n3\n:\npython\nclass CircularQueue:\n    def __init__(self, k):\n        self.k = k\n        self.queue = [None] * k\n        self.head = -1\n        self.tail = -1\n\n    def is_empty(self):\n        return self.head == -1\n\n    def is_full(self):\n        return (self.tail + 1) % self.k == self.head\n\n    def enqueue(self, x):\n        if self.is_empty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.k\n        self.queue[self.tail] = x\n\n    def dequeue(self):\n        if self.is_empty():\n            return None\n        x = self.queue[self.head]\n        if self.head == self.tail:\n            self.head = -1\n            self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.k\n        return x\n\n    def rotate(self, n):\n        for i in range(n):\n            x = self.dequeue()\n            self.enqueue(x)\nThis program defines a class CircularQueue that represents a circular queue and implements methods to check if the queue is empty or full, to enqueue an element, to dequeue an element, and to rotate the queue by a given number of positions. The CircularQueue class has attributes k representing the maximum size of the queue, queue representing the array storing the elements of the queue, head representing the index of the first element in the queue, and tail representing the index of the last element in the queue. The is_empty() method returns True if the queue is empty and False otherwise. The is_full() method returns True if the queue is full and False otherwise. The enqueue() method takes an element x as input and adds it to the end of the queue. The dequeue() method removes and returns the first element in the queue. The rotate() method takes an integer n as input and rotates the queue by n positions to the right. It does this by dequeuing the first element of the queue and enqueuing it at the end of the queue n times.\nHere's an example usage of the class:\npython\nqueue = CircularQueue(5)\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\nqueue.enqueue(4)\nqueue.enqueue(5)\nprint(queue.queue) # Output: [1, 2, 3, 4, 5]\nqueue.rotate(2)\nprint(queue.queue) # Output: [4, 5, 1, 2, 3]\nThis program creates a CircularQueue object queue with a maximum size of 5, enqueues five elements into the queue using the enqueue() method, prints the queue, rotates the queue by 2 positions to the right using the rotate() method, and prints the queue again. The output is\n1\n2\n4\n3\n5\nbefore rotation and\n3\n5\n1\n2\n4\nafter rotation.\n1\nyoutube\n2\nstackoverflow\n3\nprogramiz\n4\nrealpython\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to find the maximum sum subarray in a given circular array.",
        "Output": "To find the maximum sum subarray in a given circular array, we can use a modified version of Kadane's algorithm. The algorithm involves finding the maximum sum subarray in the array, and then finding the maximum sum subarray that wraps around the end of the array to the beginning. We can then compare the two subarrays and return the maximum of the two. Here are some resources that provide more information and examples of this approach:\nLeetCode editorial:\n1\nLeetCode problem:\n2\nTechie Delight:\n3\nGeeksforGeeks:\n4\nMedium article:\n5\nCoding Ninjas:\n6\nHere's an example implementation of the modified Kadane's algorithm approach in Python:\npython\ndef max_sum_circular_subarray(arr):\n    def kadane(arr):\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    max_sum = kadane(arr)\n    circular_sum = sum(arr) + kadane([-num for num in arr])\n    return max(max_sum, circular_sum) if circular_sum != 0 else max_sum\nThis program defines a function max_sum_circular_subarray() that takes a circular array arr as input and returns the maximum sum subarray in the array. It first defines a helper function kadane() that takes an array arr as input and returns the maximum sum subarray in the array using Kadane's algorithm. It then calls kadane() with the input array to get the maximum sum subarray in the array, and computes the maximum sum subarray that wraps around the end of the array to the beginning by summing up all the elements in the array and subtracting the minimum sum subarray in the negated array. It then returns the maximum of the two subarrays, unless the circular sum is 0, in which case it returns the maximum sum subarray.\nHere's an example usage of the function:\npython\narr = [8, -8, 9, -9, 10, -11, 12]\nmax_sum = max_sum_circular_subarray(arr)\nprint(max_sum) # Output: 22\nThis program creates a circular array arr, calls the max_sum_circular_subarray() function with the array as input, and prints the maximum sum subarray in the array. The output is 22 in this case.\n1\nleetcode\n2\nleetcode\n3\ntechiedelight\n4\ngeeksforgeeks\n5\nmedium\n6\ncodingninjas"
    },
    {
        "Input": "\"Write a program to find the number of unique paths from the top-left corner to the bottom-right corner of a grid, moving only right or down, with obstacles represented as '1' in the grid.\"",
        "Output": "To find the number of unique paths from the top-left corner to the bottom-right corner of a grid, moving only right or down, with obstacles represented as '1' in the grid, we can use dynamic programming. We can define a 2D array dp of the same size as the grid, where dp[i][j] represents the number of unique paths from the top-left corner to the cell (i, j). We can then initialize the first row and first column of dp to 1 if there are no obstacles in the corresponding cells, and 0 otherwise. We can then iterate over the remaining cells of dp, setting dp[i][j] to 0 if there is an obstacle in the cell, and to the sum of dp[i-1][j] and dp[i][j-1] otherwise. The number of unique paths from the top-left corner to the bottom-right corner of the grid is then dp[m-1][n-1], where m and n are the number of rows and columns of the grid, respectively. Here are some resources that provide more information and examples of this approach:\nGeeksforGeeks:\n1\nCodeforces:\n2\nInterviewBit:\n3\ntakeUforward:\n4\nLeetCode:\n5\nYouTube video:\n6\nHere's an example implementation of the dynamic programming approach in Python:\npython\ndef unique_paths_with_obstacles(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    if grid[0][0] == 0:\n        dp[0][0] = 1\n    for i in range(1, m):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0]\n    for j in range(1, n):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1]\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\nThis program defines a function unique_paths_with_obstacles() that takes a grid grid as input and returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, moving only right or down, with obstacles represented as '1' in the grid. It first initializes the number of rows and columns of the grid, and a 2D array dp of the same size as the grid to store the number of unique paths. It then initializes the first row and first column of dp to 1 if there are no obstacles in the corresponding cells, and 0 otherwise. It then iterates over the remaining cells of dp, setting dp[i][j] to 0 if there is an obstacle in the cell, and to the sum of dp[i-1][j] and dp[i][j-1] otherwise. The function returns dp[m-1][n-1], which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid.\nHere's an example usage of the function:\npython\ngrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nnum_paths = unique_paths_with_obstacles(grid)\nprint(num_paths) # Output: 2\nThis program creates a grid grid, calls the unique_paths_with_obstacles() function with the grid as input, and prints the number of unique paths from the top-left corner to the bottom-right corner of the grid. The output is 2 in this case.\n1\ngeeksforgeeks\n2\ncodeforces\n3\ninterviewbit\n4\ntakeuforward\n5\nleetcode\n6\nyoutube"
    },
    {
        "Input": "Implement a function to check if a given string can be segmented into a space-separated sequence of dictionary words.",
        "Output": "To check if a given string can be segmented into a space-separated sequence of dictionary words, we can use dynamic programming. We can define a 1D array dp of the same length as the input string, where dp[i] represents whether the substring from index 0 to i in the input string can be segmented into dictionary words. We can then initialize dp to True if the first character of the input string is in the dictionary, and False otherwise. We can then iterate over the remaining characters of the input string, setting dp[i] to True if there exists a j such that dp[j] is True and the substring from index j+1 to i is in the dictionary, and False otherwise. The function returns dp[-1], which represents whether the entire input string can be segmented into dictionary words. Here are some resources that provide more information and examples of this approach:\nEducative.io:\n1\nTechie Delight:\n2\nGeeksforGeeks:\n3\nScaler:\n4\nLeetCode:\n5\nInterviewBit:\n6\nHere's an example implementation of the dynamic programming approach in Python:\npython\ndef can_segment_string(s, dictionary):\n    n = len(s)\n    dp = [False] * n\n    if s[0] in dictionary:\n        dp[0] = True\n    for i in range(1, n):\n        if s[:i+1] in dictionary:\n            dp[i] = True\n            continue\n        for j in range(i):\n            if dp[j] and s[j+1:i+1] in dictionary:\n                dp[i] = True\n                break\n    return dp[-1]\nThis program defines a function can_segment_string() that takes a string s and a set of dictionary words dictionary as input and returns True if the input string can be completely segmented into the words of the dictionary, and False otherwise. It first initializes the length of the input string and a 1D array dp of the same length as the input string to store whether each substring can be segmented into dictionary words. It then initializes dp to True if the first character of the input string is in the dictionary, and False otherwise. It then iterates over the remaining characters of the input string, setting dp[i] to True if there exists a j such that dp[j] is True and the substring from index j+1 to i is in the dictionary, and False otherwise. The function returns dp[-1], which represents whether the entire input string can be segmented into dictionary words.\nHere's an example usage of the function:\npython\ns = \"applepenapple\"\ndictionary = {\"apple\", \"pen\"}\ncan_segment = can_segment_string(s, dictionary)\nprint(can_segment) # Output: True\nThis program creates a string s, a set of dictionary words dictionary, calls the can_segment_string() function with the string and dictionary as input, and prints whether the input string can be completely segmented into the words of the dictionary. The output is True in this case.\n1\neducative\n2\ntechiedelight\n3\ngeeksforgeeks\n4\nscaler\n5\nleetcode\n6\ninterviewbit"
    },
    {
        "Input": "Write a program to find the longest word in a given dictionary that can be constructed by deleting characters from a given string.",
        "Output": "To find the longest word in a given dictionary that can be constructed by deleting characters from a given string, we can iterate over each word in the dictionary and check if it can be formed by deleting characters from the given string. We can do this by iterating over the characters of the word and the given string in parallel, and advancing the index of the given string only if the current character of the word matches the current character of the given string. If we reach the end of the word, we know that the word can be formed by deleting characters from the given string, and we can update the longest word seen so far. Here are some resources that provide more information and examples of this approach:\nLeetCode:\n1\nDEV Community:\n2\nGeeksforGeeks:\n3\nCoding Ninjas:\n4\nHere's an example implementation of the approach in Python:\npython\ndef find_longest_word(s, dictionary):\n    longest_word = \"\"\n    for word in dictionary:\n        i, j = 0, 0\n        while i < len(word) and j < len(s):\n            if word[i] == s[j]:\n                i += 1\n            j += 1\n        if i == len(word) and len(word) > len(longest_word):\n            longest_word = word\n    return longest_word\nThis program defines a function find_longest_word() that takes a string s and a list of words dictionary as input and returns the longest word in the dictionary that can be formed by deleting characters from the given string. It first initializes the longest word seen so far to an empty string. It then iterates over each word in the dictionary, and for each word, it initializes two pointers i and j to 0, representing the current index of the word and the given string, respectively. It then iterates over the characters of the word and the given string in parallel, advancing the index of the given string only if the current character of the word matches the current character of the given string. If it reaches the end of the word, it knows that the word can be formed by deleting characters from the given string, and it updates the longest word seen so far if the current word is longer than the previous longest word. The function returns the longest word seen so far.\nHere's an example usage of the function:\npython\ns = \"abpcleaq\"\ndictionary = [\"ale\", \"apple\", \"monkey\", \"plea\"]\nlongest_word = find_longest_word(s, dictionary)\nprint(longest_word) # Output: \"apple\"\nThis program creates a string s, a list of words dictionary, calls the find_longest_word() function with the string and dictionary as input, and prints the longest word in the dictionary that can be formed by deleting characters from the given string. The output is \"apple\" in this case.\n1\nleetcode\n2\ndev\n3\ngeeksforgeeks\n4\ncodingninjas"
    },
    {
        "Input": "Create a Python class representing a Sudoku solver and implement methods to solve a given Sudoku puzzle.",
        "Output": "There are several resources available that provide examples of implementing a Sudoku solver in Python using different approaches. Here are some of them:\nCode Review Stack Exchange:\n1\n\nThis resource provides an example of an object-oriented Sudoku solver in Python that uses classes to represent the Sudoku board and fields. The solver uses a backtracking algorithm to fill in the empty cells of the board.\nGitHub:\n2\n\nThis resource provides a simple, basic Sudoku class in Python that provides the data structure for a 9x9 Sudoku board and a basic solver that uses a brute-force algorithm to fill in the empty cells of the board.\nAskPython:\n3\n\nThis resource provides an example of a Sudoku solver in Python that uses the backtracking method to fill in the empty cells of the board. The solver uses a recursive function to try different values for each empty cell until a solution is found.\nLior Sinai:\n4\n\nThis resource provides an example of a Sudoku solver in Python that uses depth-first search and constraint propagation to fill in the empty cells of the board. The solver uses a two-dimensional array to represent the Sudoku board and candidate values for each cell.\nTech with Tim:\n5\n\nThis resource provides a tutorial on how to create a Sudoku solver in Python using the backtracking algorithm. The solver uses a recursive function to try different values for each empty cell until a solution is found.\nYouTube:\n6\n\nThis resource provides a video tutorial on how to create a Sudoku solver in Python using the backtracking algorithm. The solver uses a recursive function to try different values for each empty cell until a solution is found.\nBased on these resources, you can choose an approach that suits your needs and implement a Sudoku solver in Python.\n1\nstackexchange\n2\ngithub\n3\naskpython\n4\nliorsinai\n5\ntechwithtim\n6\nyoutube"
    },
    {
        "Input": "Implement a function to generate all possible combinations of k distinct integers from a given list of integers.",
        "Output": "Here's an example implementation of a function to generate all possible combinations of k distinct integers from a given list of integers in Python using a recursive approach:\npython\ndef combinations(arr, k):\n    def backtrack(start, curr):\n        if len(curr) == k:\n            output.append(curr[:])\n            return\n        for i in range(start, len(arr)):\n            curr.append(arr[i])\n            backtrack(i+1, curr)\n            curr.pop()\n\n    output = []\n    backtrack(0, [])\n    return output\nThis program defines a function combinations() that takes a list of integers arr and an integer k as input and returns a list of all possible combinations of k distinct integers from the list. It first defines a helper function backtrack() that takes a starting index start and a current combination curr as input and recursively generates all possible combinations of k distinct integers starting from the current combination. It does this by iterating over the remaining elements of the input list starting from the starting index, adding each element to the current combination, recursively calling backtrack() with the next starting index and the updated current combination, and removing the last element from the current combination. If the length of the current combination is equal to k, it appends the current combination to the output list. The function then initializes an empty output list, calls backtrack() with a starting index of 0 and an empty current combination, and returns the output list.\nHere's an example usage of the function:\npython\narr = [1, 2, 3, 4]\nk = 2\ncombs = combinations(arr, k)\nprint(combs) # Output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nThis program creates a list of integers arr, an integer k, calls the combinations() function with the list and integer as input, and prints the list of all possible combinations of k distinct integers from the list. The output is [\n1\n2\n,\n1\n3\n,\n1\n4\n,\n2\n3\n,\n2\n4\n,\n3\n4\n] in this case.\n1\ncodingninjas\n2\ngeeksforgeeks\n3\nleetcode\n4\nenjoyalgorithms\n5\nleetcode"
    },
    {
        "Input": "Write a program to find the largest rectangular area of 1s in a binary matrix.",
        "Output": "To find the largest rectangular area of 1s in a binary matrix, we can use the concept of the largest rectangular area in a histogram. We can treat each row of the binary matrix as a histogram and calculate the largest rectangular area in each histogram. We can then find the maximum area among all the histograms. Here are some resources that provide more information and examples of this approach:\nTechiedelight:\n1\nCoding Ninjas:\n2\nGeeksforGeeks:\n3\n,\n4\n,\n5\nHere's an example implementation of the approach in Python:\npython\ndef largest_rectangle_area(matrix):\n    def largest_area_histogram(heights):\n        stack = [-1]\n        max_area = 0\n        for i in range(len(heights)):\n            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                curr_height = heights[stack.pop()]\n                curr_width = i - stack[-1] - 1\n                max_area = max(max_area, curr_height * curr_width)\n            stack.append(i)\n        while stack[-1] != -1:\n            curr_height = heights[stack.pop()]\n            curr_width = len(heights) - stack[-1] - 1\n            max_area = max(max_area, curr_height * curr_width)\n        return max_area\n\n    max_area = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if i > 0 and matrix[i][j] == 1:\n                matrix[i][j] += matrix[i-1][j]\n        max_area = max(max_area, largest_area_histogram(matrix[i]))\n    return max_area\nThis program defines a function largest_rectangle_area() that takes a binary matrix matrix as input and returns the largest rectangular area of 1s in the matrix. It first defines a helper function largest_area_histogram() that takes a list of heights heights as input and returns the largest rectangular area in the histogram formed by the heights. It does this by using a stack to keep track of the indices of the heights in increasing order, and calculating the area of each rectangle formed by the current height and the previous height in the stack. It then updates the maximum area seen so far. The function then iterates over each row of the binary matrix, and for each row, it calculates the height of each histogram by adding the value of the current cell to the value of the cell above it if the current cell is 1. It then calls largest_area_histogram() with the histogram as input and updates the maximum area seen so far. The function returns the maximum area seen so far.\nHere's an example usage of the function:\npython\nmatrix = [[0, 1, 1, 0, 1],\n          [1, 1, 1, 1, 1],\n          [1, 1, 1, 1, 1],\n          [1, 1, 0, 0, 1]]\nmax_area = largest_rectangle_area(matrix)\nprint(max_area) # Output: 6\nThis program creates a binary matrix matrix, calls the largest_rectangle_area() function with the matrix as input, and prints the largest rectangular area of 1s in the matrix. The output is 6 in this case.\n1\ntechiedelight\n2\ncodingninjas\n3\ntakeuforward\n4\nleetcode\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Create a program to find the number of distinct islands in a 2D grid, where islands are defined by connected regions of '1's.\"",
        "Output": "To find the number of distinct islands in a 2D grid, where islands are defined by connected regions of '1's, we can use a depth-first search (DFS) approach. We can iterate over each cell of the grid, and for each cell that contains a '1', we can perform a DFS to explore the connected region of '1's and mark the visited cells as '0's to avoid counting the same island multiple times. We can store the shape of each island as a set of relative coordinates of its cells, and store the set of shapes of all visited islands in a set. The size of the set of shapes of all visited islands is the number of distinct islands in the grid. Here are some resources that provide more information and examples of this approach:\nLeetCode:\n1\nLintCode:\n2\ntakeUforward:\n3\nTutorialspoint:\n4\nGeeksforGeeks:\n5\nHere's an example implementation of the DFS approach in Python:\npython\ndef num_distinct_islands(grid):\n    def dfs(i, j, shape):\n        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:\n            grid[i][j] = 0\n            shape.add((i - row, j - col))\n            dfs(i+1, j, shape)\n            dfs(i-1, j, shape)\n            dfs(i, j+1, shape)\n            dfs(i, j-1, shape)\n\n    shapes = set()\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                shape = set()\n                dfs(row, col, shape)\n                shapes.add(frozenset(shape))\n    return len(shapes)\nThis program defines a function num_distinct_islands() that takes a 2D grid grid as input and returns the number of distinct islands in the grid. It first defines a helper function dfs() that takes a row index i, a column index j, and a set of relative coordinates shape as input and performs a DFS to explore the connected region of '1's starting from the cell at (i, j). It does this by recursively calling dfs() on the neighboring cells that contain a '1', and adding the relative coordinates of each visited cell to the shape set. It then marks each visited cell as a '0' to avoid counting the same island multiple times. The function then initializes an empty set of shapes, and iterates over each cell of the grid, calling dfs() on each cell that contains a '1' to explore the connected region of '1's and add the shape of the island to the set of shapes. It then returns the size of the set of shapes, which represents the number of distinct islands in the grid.\nHere's an example usage of the function:\npython\ngrid = [[1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]]\nnum_islands = num_distinct_islands(grid)\nprint(num_islands) # Output: 1\nThis program creates a 2D grid grid, calls the num_distinct_islands() function with the grid as input, and prints the number of distinct islands in the grid. The output is 1 in this case.\n1\ngitbooks\n2\ngitbook\n3\ntakeuforward\n4\ntutorialspoint\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given number is a prime number using the Miller-Rabin primality test.",
        "Output": "The Miller-Rabin primality test is a probabilistic algorithm for determining whether a number is prime or composite. Here are some resources that provide information and examples of implementing the Miller-Rabin primality test in Python:\nLiteratePrograms:\n1\n\nThis resource provides an implementation of the Miller-Rabin primality test in Python using the formulae for proving compositeness of a number. The implementation uses the GCD to test if a number is coprime to n, and writes n-1 as 2^d * r, where r is odd. It then tests if a^r is congruent to 1 mod n or a^(2^j * r) is congruent to -1 mod n for some j in the range [0, d-1].\nRosetta Code:\n2\n\nThis resource provides an implementation of the Miller-Rabin primality test in Python using the pseudocode from Wikipedia. The implementation uses a loop to perform the test for a given number of rounds, and uses the Fermat's little theorem to check if a number is coprime to n.\nJust Cryptography:\n3\n\nThis resource provides an implementation of the Miller-Rabin primality test in Python using the formulae for finding u and k, and using a loop to perform the test for a given number of rounds. The implementation uses the pow() function to calculate the modular exponentiation of a number.\nHere's an example implementation of the Miller-Rabin primality test in Python using the formulae for finding u and k and using a loop to perform the test for a given number of rounds:\npython\nimport random\n\ndef miller_rabin(n, k=10):\n    if n <= 3:\n        return n == 2 or n == 3\n    if n % 2 == 0:\n        return False\n    u, k = n - 1, 0\n    while u % 2 == 0:\n        u //= 2\n        k += 1\n    for _ in range(k):\n        a = random.randint(2, n - 2)\n        x = pow(a, u, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(k - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\nThis program defines a function miller_rabin() that takes an integer n and an integer k as input and returns True if the input integer is prime, and False otherwise. It first checks if the input integer is less than or equal to 3, and returns True if the input integer is 2 or 3. It then checks if the input integer is even, and returns False if it is. It then finds the values of u and k such that n-1 = 2^k * u, where u is odd. It then iterates over a range of k rounds, and for each round, it generates a random integer a in the range [2, n-2], and calculates x = a^u mod n. If x is congruent to 1 mod n or x is congruent to -1 mod n, it continues to the next round. Otherwise, it iterates over a range of k-1 steps, and for each step, it calculates x = x^2 mod n. If x is congruent to -1 mod n, it breaks out of the loop. If it completes all k-1 steps without finding x congruent to -1 mod n, it returns False. If it completes all k rounds without finding x congruent to -1 mod n, it returns True.\nHere's an example usage of the function:\npython\nn = 123456789\nis_prime = miller_rabin(n)\nprint(is_prime) # Output: False\nThis program creates an integer n, calls the miller_rabin() function with the integer as input, and prints whether the integer is prime or not. The output is False in this case.\n1\nPowered by Wolfram|Alpha\n2\nliterateprograms\n3\ngithub"
    },
    {
        "Input": "Write a Python class representing a weighted directed acyclic graph and implement methods to find the shortest path using the Bellman-Ford algorithm.",
        "Output": "To implement a Python class representing a weighted directed acyclic graph and methods to find the shortest path using the Bellman-Ford algorithm, we can use the following steps:\nDefine a class Graph that represents a weighted directed acyclic graph. The class should have a constructor that initializes the number of vertices and an empty list of edges. It should also have a method add_edge() that adds a directed edge with a weight between two vertices to the graph.\nDefine a method shortest_path() in the Graph class that takes a source vertex as input and returns a list of shortest distances from the source vertex to all other vertices in the graph. The method should initialize a list of distances to all vertices as infinity except for the source vertex, which should be initialized to 0. It should then iterate over all edges in the graph V-1 times, updating the distance to each vertex if a shorter path is found. If there is a negative cycle in the graph, the method should return None.\nHere are some resources that provide more information and examples of implementing the Bellman-Ford algorithm for finding the shortest path in a directed acyclic graph:\nGeeksforGeeks:\n1\n,\n2\nFavTutor:\n3\nScaler:\n4\nAlgoTree:\n5\nTechie Delight:\n6\nHere's an example implementation of the Graph class and the shortest_path() method in Python:\npython\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, w):\n        self.graph.append((u, v, w))\n\n    def shortest_path(self, src):\n        dist = [float(\"inf\")] * self.V\n        dist[src] = 0\n\n        for _ in range(self.V - 1):\n            for u, v, w in self.graph:\n                if dist[u] != float(\"inf\") and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n\n        for u, v, w in self.graph:\n            if dist[u] != float(\"inf\") and dist[u] + w < dist[v]:\n                return None\n\n        return dist\nThis program defines a class Graph that represents a weighted directed acyclic graph. The class has a constructor that takes the number of vertices as input and initializes an empty list of edges. It also has a method add_edge() that takes the source vertex, destination vertex, and weight of an edge as input and adds the edge to the graph.\nThe class also has a method shortest_path() that takes a source vertex as input and returns a list of shortest distances from the source vertex to all other vertices in the graph. The method initializes a list of distances to all vertices as infinity except for the source vertex, which is initialized to 0. It then iterates over all edges in the graph V-1 times, updating the distance to each vertex if a shorter path is found. If there is a negative cycle in the graph, the method returns None.\nHere's an example usage of the Graph class and the shortest_path() method:\npython\ng = Graph(5)\ng.add_edge(0, 1, 6)\ng.add_edge(0, 3, 7)\ng.add_edge(1, 2, 5)\ng.add_edge(1, 3, 8)\ng.add_edge(1, 4, -4)\ng.add_edge(2, 1, -2)\ng.add_edge(3, 2, -3)\ng.add_edge(3, 4, 9)\ng.add_edge(4, 0, 2)\ng.add_edge(4, 2, 7)\n\ndistances = g.shortest_path(0)\nprint(distances) # Output: [0, 2, 4, 7, -2]\nThis program creates a Graph object g with 5 vertices and 10 directed edges. It then calls the add_edge() method to add the edges to the graph. Finally, it calls the shortest_path() method with a source vertex of 0 and prints the list of shortest distances from the source vertex to all other vertices in the graph. The output is [0, 2, 4, 7, -2] in this case.\n1\ngeeksforgeeks\n2\ngeeksforgeeks\n3\nfavtutor\n4\nscaler\n5\nalgotree\n6\ntechiedelight"
    },
    {
        "Input": "Create a program to generate all possible valid IP addresses from a given string of digits.",
        "Output": "To generate all possible valid IP addresses from a given string of digits, we can use a backtracking approach. We can place three dots in the given string and then try out all the possible combinations for the three dots. Before entering the loop, we can check the size of the string and generate all possible combinations of the string. We can then check for all corner cases for validity, such as checking if the numbers are in the range of 0-255 and if the numbers are not 0-prefixed unless they are 0. Here are some resources that provide more information and examples of implementing this approach:\nGeeksforGeeks:\n1\nTutorialspoint:\n2\nStack Overflow:\n3\nOpenGenus IQ:\n4\nHere's an example implementation of the backtracking approach in Python:\npython\ndef restore_ip_addresses(s):\n    def backtrack(start, dots, curr):\n        if dots == 3:\n            if is_valid(curr + s[start:]):\n                output.append(curr + s[start:])\n            return\n        for i in range(start, len(s)):\n            if is_valid(curr + s[start:i+1]):\n                backtrack(i+1, dots+1, curr + s[start:i+1] + '.')\n\n    def is_valid(s):\n        if len(s) > 1 and s[0] == '0':\n            return False\n        if int(s) > 255:\n            return False\n        return True\n\n    output = []\n    backtrack(0, 0, '')\n    return output\nThis program defines a function restore_ip_addresses() that takes a string s as input and returns a list of all possible valid IP address combinations that can be obtained from the string. It first defines a helper function backtrack() that takes a starting index start, a number of dots dots, and a current combination curr as input and recursively generates all possible valid IP address combinations starting from the current combination. It does this by iterating over the remaining characters of the string starting from the starting index, adding each character to the current combination, recursively calling backtrack() with the next starting index, the updated number of dots, and the updated current combination with a dot added, and removing the last character from the current combination. If the number of dots is equal to 3 and the current combination plus the remaining characters of the string form a valid IP address, it appends the current combination plus the remaining characters of the string to the output list. The function then defines a helper function is_valid() that takes a string s as input and returns True if the string is a valid number in the range of 0-255 and not 0-prefixed unless it is 0. The function then initializes an empty output list, calls backtrack() with a starting index of 0, a number of dots of 0, and an empty current combination, and returns the output list.\nHere's an example usage of the function:\npython\ns = \"25525511135\"\nip_addresses = restore_ip_addresses(s)\nprint(ip_addresses) # Output: ['255.255.11.135', '255.255.111.35']\nThis program creates a string s, calls the restore_ip_addresses() function with the string as input, and prints the list of all possible valid IP address combinations that can be obtained from the string. The output is ['255.255.11.135', '255.255.111.35'] in this case.\n1\ngeeksforgeeks\n2\ntutorialspoint\n3\nstackoverflow\n4\nopengenus"
    },
    {
        "Input": "Implement a function to count the number of inversions in a given list of integers.",
        "Output": "To count the number of inversions in a given list of integers, we can use the merge sort algorithm. We can recursively divide the list into two halves until we reach a single element, and then merge the two halves while counting the number of inversions. An inversion occurs when a larger element appears before a smaller element in the sorted list. We can keep track of the number of inversions while merging the two halves by comparing the first element of each half. Here are some resources that provide more information and examples of implementing this approach:\nGeeksforGeeks:\n1\nTechiedelight:\n2\nInterviewBit:\n3\ntakeUforward:\n4\nTopcoder:\n5\nHere's an example implementation of the merge sort approach in Python:\npython\ndef count_inversions(arr):\n    def merge_sort(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort(arr, temp, left, mid)\n            inv_count += merge_sort(arr, temp, mid+1, right)\n            inv_count += merge(arr, temp, left, mid, right)\n        return inv_count\n\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                j += 1\n                inv_count += mid - i + 1\n            k += 1\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n        for i in range(left, right+1):\n            arr[i] = temp[i]\n        return inv_count\n\n    temp = [0] * len(arr)\n    return merge_sort(arr, temp, 0, len(arr)-1)\nThis program defines a function count_inversions() that takes a list of integers arr as input and returns the number of inversions in the list. It first defines a helper function merge_sort() that takes the list, a temporary list temp, a left index left, and a right index right as input and recursively divides the list into two halves until it reaches a single element. It then merges the two halves while counting the number of inversions using the merge() function. The merge() function takes the list, the temporary list, the left index, the middle index mid, and the right index as input and merges the two halves while counting the number of inversions. It does this by iterating over the two halves and comparing the first element of each half. If the element in the right half is smaller than the element in the left half, it increments the inversion count by the number of remaining elements in the left half. It then copies the remaining elements of the left half or the right half to the temporary list, and then copies the sorted elements from the temporary list back to the original list. The function then returns the inversion count.\nHere's an example usage of the function:\npython\narr = [1, 20, 6, 4, 5]\ninv_count = count_inversions(arr)\nprint(inv_count) # Output: 5\nThis program creates a list of integers arr, calls the count_inversions() function with the list as input, and prints the number of inversions in the list. The output is 5 in this case.\n1\nchula\n2\ntechiedelight\n3\ntakeuforward\n4\ninterviewbit\n5\nstackoverflow"
    },
    {
        "Input": "Write a program to find the maximum subarray product in a given list of integers.",
        "Output": "To find the maximum subarray product in a given list of integers, we can use the Kadane's algorithm. The algorithm is based on the observation that the maximum product subarray either includes the last element of the array or it does not. We can keep track of the maximum and minimum product subarrays ending at each index of the array, and update the maximum product subarray by taking the maximum of the current element, the maximum product subarray ending at the previous index times the current element, and the minimum product subarray ending at the previous index times the current element. We can also update the minimum product subarray by taking the minimum of the current element, the maximum product subarray ending at the previous index times the current element, and the minimum product subarray ending at the previous index times the current element. Here are some resources that provide more information and examples of implementing this approach:\nInterviewBit:\n1\nScaler:\n2\nTechie Delight:\n3\nLeetCode:\n4\ntakeUforward:\n5\nHere's an example implementation of the Kadane's algorithm in Python:\npython\ndef max_product_subarray(nums):\n    max_product = nums[0]\n    max_ending_here = nums[0]\n    min_ending_here = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n\n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n\n        max_product = max(max_product, max_ending_here)\n\n    return max_product\nThis program defines a function max_product_subarray() that takes a list of integers nums as input and returns the maximum product subarray in the list. It initializes the maximum product and the maximum and minimum product subarrays ending at the first element of the list. It then iterates over the remaining elements of the list, updating the maximum and minimum product subarrays ending at each index using the Kadane's algorithm. It updates the maximum and minimum product subarrays by taking the maximum and minimum of the current element, the maximum product subarray ending at the previous index times the current element, and the minimum product subarray ending at the previous index times the current element. It then updates the maximum product by taking the maximum of the current maximum product and the maximum product subarray ending at the current index. The function then returns the maximum product.\nHere's an example usage of the function:\npython\nnums = [2, 3, -2, 4, -1]\nmax_product = max_product_subarray(nums)\nprint(max_product) # Output: 48\nThis program creates a list of integers nums, calls the max_product_subarray() function with the list as input, and prints the maximum product subarray in the list. The output is 48 in this case.\nNote: If the input list contains only positive integers, the maximum product subarray is simply the product of all the integers in the list. If the input list contains only negative integers, the maximum product subarray is the largest negative integer in the list. If the input list contains both positive and negative integers, the Kadane's algorithm can be used to find the maximum product subarray.\n1\nscaler\n2\ninterviewbit\n3\nleetcode\n4\ntechiedelight\n5\nafteracademy"
    },
    {
        "Input": "Create a Python class representing a radix tree (trie) and implement methods to insert and search for strings.",
        "Output": "To create a Python class representing a radix tree (trie) and implement methods to insert and search for strings, we can use the following steps:\nDefine a class TrieNode that represents a node in the radix tree. The class should have a dictionary of child nodes and a boolean flag to indicate if the node represents the end of a word.\nDefine a class RadixTree that represents the radix tree. The class should have a root node and methods to insert and search for strings in the tree.\nImplement the insert() method in the RadixTree class that takes a string as input and inserts it into the tree. The method should start at the root node and iterate over the characters of the string, creating new nodes as necessary and setting the end-of-word flag for the last node.\nImplement the search() method in the RadixTree class that takes a string as input and returns True if the string is in the tree and False otherwise. The method should start at the root node and iterate over the characters of the string, returning False if a character is not in the child nodes of the current node or if the end-of-word flag is not set for the last node.\nHere are some resources that provide more information and examples of implementing a radix tree in Python:\nTutorialspoint:\n1\nOpenGenus IQ:\n2\nAleksandr Hovhannisyan:\n3\nGeeksforGeeks:\n4\nMedium:\n5\nHere's an example implementation of the TrieNode and RadixTree classes in Python:\npython\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass RadixTree:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end_of_word = True\n\n    def search(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return current.is_end_of_word\nThis program defines a class TrieNode that represents a node in the radix tree. The class has a dictionary of child nodes and a boolean flag to indicate if the node represents the end of a word. It also defines a class RadixTree that represents the radix tree. The class has a root node and methods to insert and search for strings in the tree. The insert() method takes a string as input and inserts it into the tree. It starts at the root node and iterates over the characters of the string, creating new nodes as necessary and setting the end-of-word flag for the last node. The search() method takes a string as input and returns True if the string is in the tree and False otherwise. It starts at the root node and iterates over the characters of the string, returning False if a character is not in the child nodes of the current node or if the end-of-word flag is not set for the last node.\nHere's an example usage of the RadixTree class:\npython\nradix_tree = RadixTree()\nradix_tree.insert(\"apple\")\nradix_tree.insert(\"banana\")\nradix_tree.insert(\"cherry\")\nprint(radix_tree.search(\"apple\")) # Output: True\nprint(radix_tree.search(\"orange\")) # Output: False\nThis program creates a RadixTree object radix_tree, calls the insert() method to insert three strings into the tree, and calls the search() method to search for two strings in the tree. The output is True and False in this case.\n1\ntutorialspoint\n2\nmanning\n3\nopengenus\n4\naleksandrhovhannisyan\n5\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to check if a given binary tree is a valid binary search tree.",
        "Output": "To check if a given binary tree is a valid binary search tree, we can use the following approaches:\nRecursive approach: We can recursively check whether both the left and right subtrees of the root are also binary search trees and if yes then return true. We can also keep track of the minimum and maximum values allowed for each node and check if the value of the current node is within the allowed range. Here are some resources that provide more information and examples of implementing this approach:\nBaeldung:\n1\nLeetCode:\n2\nEnjoyAlgorithms:\n3\nEducative.io:\n4\ntakeUforward:\n5\nTechie Delight:\n6\nInorder traversal approach: We can perform an inorder traversal of the binary tree and check if the resulting sequence of values is sorted in ascending order. If the sequence is sorted, then the binary tree is a valid binary search tree. Here are some resources that provide more information and examples of implementing this approach:\nGeeksforGeeks:\nLeetCode:\nProgramiz:\nTutorialsPoint:\nHere's an example implementation of the recursive approach in Python:\npython\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        def is_valid(node, min_val, max_val):\n            if not node:\n                return True\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            return is_valid(node.left, min_val, node.val) and is_valid(node.right, node.val, max_val)\n\n        return is_valid(root, float('-inf'), float('inf'))\nThis program defines a class TreeNode that represents a node in the binary tree and a class Solution that represents the solution to the problem. The isValidBST() method takes a TreeNode object root as input and returns True if the binary tree is a valid binary search tree and False otherwise. It does this by defining a helper function is_valid() that takes a TreeNode object node, a minimum value min_val, and a maximum value max_val as input and returns True if the binary tree rooted at node is a valid binary search tree with values in the range of min_val and max_val. It does this by checking if the value of the current node is within the allowed range and recursively checking if the left and right subtrees are also valid binary search trees. The isValidBST() method then calls the is_valid() function with the root node and the minimum and maximum values of negative and positive infinity, respectively.\nHere's an example usage of the Solution class:\npython\nroot = TreeNode(5)\nroot.left = TreeNode(1)\nroot.right = TreeNode(4)\nroot.right.left = TreeNode(3)\nroot.right.right = TreeNode(6)\nsolution = Solution()\nprint(solution.isValidBST(root)) # Output: False\nThis program creates a binary tree with the root node having a value of 5 and calls the isValidBST() method of the Solution class with the root node as input. The output is False in this case.\nNote: There are different ways to define a valid binary search tree, and the exact definition may depend on the problem statement. Some definitions may allow duplicate values, while others may not. Some definitions may allow the left and right subtrees to have equal values, while others may not. It's important to carefully read the problem statement and understand the definition of a valid binary search tree before implementing a solution.\n1\nbaeldung\n2\nleetcode\n3\nenjoyalgorithms\n4\neducative\n5\ntakeuforward\n6\ntechiedelight"
    },
    {
        "Input": "Write a program to find the longest path in a tree from a given node to any other node.",
        "Output": "There are different approaches to find the longest path in a tree from a given node to any other node, depending on the type of tree and the definition of the longest path. Here are some resources that provide more information and examples of implementing different approaches:\nDepth-first search approach: This approach is used for finding the longest path in a directed tree. We can perform a depth-first search (DFS) from any node to find the farthest node from that node, and then perform another DFS from the farthest node to find the actual longest path. We can keep track of the length of the longest path and the nodes in the path during the second DFS. Here's an example implementation in C++ from AlgoTree\n1\n:\ncpp\nclass Tree {\nprivate:\n    vector<vector<int>> adj_list;\n    int start_node, end_node, max_path_length;\n    vector<int> longest_path;\n\n    void DFS(int node, int parent, int path_length, vector<int>& path) {\n        if (path_length > max_path_length) {\n            max_path_length = path_length;\n            longest_path = path;\n            longest_path.push_back(node);\n        }\n        for (int child : adj_list[node]) {\n            if (child != parent) {\n                path.push_back(node);\n                DFS(child, node, path_length + 1, path);\n                path.pop_back();\n            }\n        }\n    }\n\npublic:\n    Tree(int num_nodes) {\n        adj_list.resize(num_nodes);\n        start_node = end_node = max_path_length = 0;\n    }\n\n    void AddEdge(int u, int v) {\n        adj_list[u].push_back(v);\n        adj_list[v].push_back(u);\n    }\n\n    void Set_StartNode(int node) {\n        start_node = node;\n    }\n\n    void Find_FarthestNode(int node, int parent, int path_length) {\n        if (path_length > max_path_length) {\n            max_path_length = path_length;\n            end_node = node;\n        }\n        for (int child : adj_list[node]) {\n            if (child != parent) {\n                Find_FarthestNode(child, node, path_length + 1);\n            }\n        }\n    }\n\n    void Find_LongestPath() {\n        max_path_length = 0;\n        DFS(start_node, -1, 0, vector<int>());\n        max_path_length = 0;\n        DFS(end_node, -1, 0, vector<int>());\n        reverse(longest_path.begin(), longest_path.end());\n    }\n\n    int Get_LenghtOfLongestPath() {\n        return max_path_length;\n    }\n\n    void Set_StartAndEndNode(int arg_start_node, int arg_end_node) {\n        start_node = arg_start_node;\n        end_node = arg_end_node;\n        longest_path.push_back(start_node);\n    }\n};\n\nint main() {\n    Tree t(16);\n    // Add edges to the tree\n    t.AddEdge(0,1);\n    t.AddEdge(0,2);\n    t.AddEdge(0,3);\n    t.AddEdge(1,4);\n    t.AddEdge(1,5);\n    t.AddEdge(1,6);\n    t.AddEdge(3,7);\n    t.AddEdge(3,8);\n    t.AddEdge(4,9);\n    t.AddEdge(7,11);\n    t.AddEdge(9,10);\n    t.AddEdge(11,12);\n    t.AddEdge(11,13);\n    t.AddEdge(8,14);\n    t.AddEdge(8,15);\n\n    t.Set_StartNode(15);\n    t.Find_FarthestNode(15, -1, 0);\n    t.Set_StartAndEndNode(15, t.end_node);\n    t.Find_LongestPath();\n\n    cout << \"Starting node : \" << t.start_node << endl;\n    cout << \"Ending node : \" << t.end_node << endl;\n    cout << \"Longest Path : \";\n    for (int node : t.longest_path) {\n        cout << node << \" \";\n    }\n    cout << endl << \"Length of the longest path : \" << t.Get_LenghtOfLongestPath() << \" nodes.\" << endl;\n\n    return 0;\n}\nBreadth-first search approach: This approach is used for finding the longest path in an undirected tree. We can perform two BFSs to find the farthest node from any node and then find the actual longest path. We can keep track of the length of the longest path and the nodes in the path during the second BFS. Here's an example implementation in C++ from GeeksforGeeks\n2\n:\ncpp\nint bfs(int u, vector<int> adj[], int n) {\n    vector<int> dist(n, -1);\n    queue<int> q;\n    q.push(u);\n    dist[u] = 0;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int i = 0; i < adj[v].size(); i++) {\n            int w = adj[v][i];\n            if (dist[w] == -1) {\n                q.push(w);\n                dist[w] = dist[v] + 1;\n            }\n        }\n    }\n    int max_dist = 0, max_node = 0;\n    for (int i = 0; i < n; i++) {\n        if (dist[i] > max_dist) {\n            max_dist = dist[i];\n            max_node = i;\n        }\n    }\n    return max_node;\n}\n\nint longest_path(vector<int> adj[], int n) {\n    int u = bfs(0, adj, n);\n    int v = bfs(u, adj, n);\n    vector<int> path;\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(v);\n    visited[v] = true;\n    while (!q.empty()) {\n        int w = q.front();\n        q.pop();\n        path.push_back(w);\n        for (int i = 0; i < adj[w].size(); i++) {\n            int x = adj[w][i];\n            if (!visited[x]) {\n                visited[x] = true;\n                q.push(x);\n            }\n        }\n    }\n    return path.size();\n}\n\nint main() {\n    int n = 7;\n    vector<int> adj[n];\n    adj[0].push_back(1);\n    adj[1].push_back(0);\n    adj[0].push_back(2);\n    adj[2].push_back(0);\n    adj[1].push_back(3);\n    adj[3].push_back(1);\n    adj[1].push_back(4);\n    adj[4].push_back(1);\n    adj[2].push_back(5);\n    adj[5].push_back(2);\n    adj[2].push_back(6);\n    adj[6].push_back(2);\n    cout << longest_path(adj, n) << endl;\n    return 0;\n}\nBinary tree approach: This approach is used for finding the longest path in a binary tree. We can recursively get the longest path from the left and right subtrees and then add the current\n1\nalgotree\n2\ngeeksforgeeks"
    },
    {
        "Input": "Create a program to find the kth smallest element in a matrix sorted by rows and columns.",
        "Output": "To find the kth smallest element in a matrix sorted by rows and columns, we can use the following approach:\nBinary search approach: We can use binary search to find the kth smallest element in the matrix. We can set the left and right boundaries to the minimum and maximum values in the matrix, respectively, and then count the number of elements in the matrix that are less than or equal to the middle value. If the count is less than k, we can update the left boundary to the middle value + 1. Otherwise, we can update the right boundary to the middle value. We can repeat this process until the left and right boundaries converge to the kth smallest element. Here are some resources that provide more information and examples of implementing this approach:\nInterview Kickstart:\n1\nLeetCode:\n2\nMedium:\n3\nYouTube:\n4\nHere's an example implementation of the binary search approach in Python:\npython\ndef kth_smallest(matrix, k):\n    def count_less_or_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n        return count\n\n    left = matrix[0][0]\n    right = matrix[-1][-1]\n    while left <= right:\n        mid = (left + right) // 2\n        count = count_less_or_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\nThis program defines a function kth_smallest() that takes a matrix of integers matrix and an integer k as input and returns the kth smallest element in the matrix. It does this by defining a helper function count_less_or_equal() that takes a matrix and a value mid as input and returns the number of elements in the matrix that are less than or equal to mid. It does this by starting at the bottom-left corner of the matrix and moving up and to the right until it finds an element that is greater than mid. It then adds the number of rows below that element to the count and moves to the right. It repeats this process until it reaches the top-right corner of the matrix. The kth_smallest() function then initializes the left and right boundaries to the minimum and maximum values in the matrix, respectively, and uses binary search to find the kth smallest element. It updates the left and right boundaries based on the count returned by the count_less_or_equal() function until the left and right boundaries converge to the kth smallest element. The function then returns the left boundary.\nHere's an example usage of the kth_smallest() function:\npython\nmatrix = [[1, 3, 5], [2, 3, 6], [3, 4, 7]]\nk = 5\nkth_smallest_element = kth_smallest(matrix, k)\nprint(kth_smallest_element) # Output: 3\nThis program creates a matrix of integers matrix and an integer k, calls the kth_smallest() function with the matrix and k as input, and prints the kth smallest element in the matrix. The output is 3 in this case.\n1\ninterviewkickstart\n2\nleetcode\n3\nmedium\n4\nyoutube"
    },
    {
        "Input": "Implement a function to calculate the Levenshtein distance between two strings.",
        "Output": "The Levenshtein distance is a measure of similarity between two strings. It is defined as the minimum number of changes required to convert one string into another. Edit operations include insertions, deletions, and substitutions. The Levenshtein distance is the most popular metric among the family of distance metrics known as edit distance\n1\n.\nThere are different options to compute the Levenshtein distance between two strings. The most common method is to use dynamic programming. We can create a matrix of size (m+1)x(n+1), where m and n are the lengths of the two strings, and initialize the first row and column to 0, 1, 2, ..., m and 0, 1, 2, ..., n, respectively. We can then iterate over the remaining cells of the matrix and fill them in based on the values of the neighboring cells. The value of each cell represents the Levenshtein distance between the substrings of the two strings up to that point. The final value in the bottom-right corner of the matrix represents the Levenshtein distance between the two strings\n2\n.\nHere's an example implementation of the Levenshtein distance algorithm in Python:\npython\ndef levenshtein_distance(s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    return dp[m][n]\nThis program defines a function levenshtein_distance() that takes two strings s and t as input and returns the Levenshtein distance between the two strings. It does this by creating a matrix of size (m+1)x(n+1), where m and n are the lengths of the two strings, and initializing the first row and column to 0, 1, 2, ..., m and 0, 1, 2, ..., n, respectively. It then iterates over the remaining cells of the matrix and fills them in based on the values of the neighboring cells. The value of each cell represents the Levenshtein distance between the substrings of the two strings up to that point. The final value in the bottom-right corner of the matrix represents the Levenshtein distance between the two strings.\nHere's an example usage of the levenshtein_distance() function:\npython\ns1 = \"kitten\"\ns2 = \"sitting\"\ndistance = levenshtein_distance(s1, s2)\nprint(distance) # Output: 3\nThis program creates two strings s1 and s2, calls the levenshtein_distance() function with the two strings as input, and prints the Levenshtein distance between the two strings. The output is 3 in this case.\n1\nbaeldung\n2\neducative"
    },
    {
        "Input": "Write a Python class representing a bloom filter and implement methods to insert and check if an element exists.",
        "Output": "To create a Python class representing a bloom filter and implement methods to insert and check if an element exists, we can use the following steps:\nDefine a class BloomFilter that represents the bloom filter. The class should have a bit array of size m and a list of k hash functions.\nImplement the add() method in the BloomFilter class that takes an element as input and inserts it into the bloom filter. The method should compute the hash values of the element using the k hash functions and set the corresponding bits in the bit array to 1.\nImplement the contains() method in the BloomFilter class that takes an element as input and returns True if the element is in the bloom filter and False otherwise. The method should compute the hash values of the element using the k hash functions and check if the corresponding bits in the bit array are all 1.\nHere's an example implementation of the bloom filter in Python:\npython\nimport mmh3\nfrom bitarray import bitarray\n\nclass BloomFilter:\n    def __init__(self, m, k):\n        self.m = m\n        self.k = k\n        self.bit_array = bitarray(m)\n        self.bit_array.setall(0)\n\n    def get_bit_array_indices(self, item):\n        index_list = []\n        for i in range(1, self.k + 1):\n            index_list.append((hash(item) + i * mmh3.hash(item)) % self.m)\n        return index_list\n\n    def add(self, item):\n        for i in self.get_bit_array_indices(item):\n            self.bit_array[i] = 1\n\n    def contains(self, item):\n        for i in self.get_bit_array_indices(item):\n            if self.bit_array[i] != 1:\n                return False\n        return True\nThis program defines a class BloomFilter that represents the bloom filter. The class has a bit array of size m and a list of k hash functions. The get_bit_array_indices() method takes an element as input and returns a list of the indices in the bit array that correspond to the hash values of the element. The add() method takes an element as input and inserts it into the bloom filter by setting the corresponding bits in the bit array to 1. The contains() method takes an element as input and returns True if the element is in the bloom filter and False otherwise by checking if the corresponding bits in the bit array are all 1.\nHere's an example usage of the BloomFilter class:\npython\nbf = BloomFilter(100, 3)\nbf.add(\"apple\")\nbf.add(\"banana\")\nbf.add(\"orange\")\nprint(bf.contains(\"apple\")) # Output: True\nprint(bf.contains(\"pear\")) # Output: False\nThis program creates a BloomFilter object bf with a bit array of size 100 and 3 hash functions, adds three elements to the bloom filter using the add() method, and checks if two elements are in the bloom filter using the contains() method. The output is True and False, respectively.\n1\ngeeksforgeeks\n2\nglowingpython\n3\naxiak\n4\npython\n5\nluminousmen"
    },
    {
        "Input": "Create a program to find the maximum number of overlapping intervals in a given list of intervals.",
        "Output": "To find the maximum number of overlapping intervals in a given list of intervals, we can use the following approach:\nSort the intervals based on their start times.\nInitialize two variables: max_overlaps and current_overlaps to 0.\nIterate over the sorted intervals and for each interval, increment current_overlaps by 1 and update max_overlaps if current_overlaps is greater than max_overlaps.\nFor each interval, decrement current_overlaps by 1 if its end time is less than or equal to the start time of the next interval.\nReturn max_overlaps.\nHere's an example implementation of the algorithm in Python:\npython\ndef max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    max_overlaps = 0\n    current_overlaps = 0\n    for i in range(len(intervals)):\n        current_overlaps += 1\n        if i < len(intervals) - 1 and intervals[i][1] > intervals[i + 1][0]:\n            max_overlaps = max(max_overlaps, current_overlaps)\n        else:\n            max_overlaps = max(max_overlaps, current_overlaps)\n            current_overlaps = 0\n    return max_overlaps\nThis program defines a function max_overlapping_intervals() that takes a list of intervals intervals as input and returns the maximum number of overlapping intervals in the list. It does this by sorting the intervals based on their start times and then iterating over the sorted intervals. For each interval, it increments current_overlaps by 1 and updates max_overlaps if current_overlaps is greater than max_overlaps. It also decrements current_overlaps by 1 if the end time of the current interval is less than or equal to the start time of the next interval. The function then returns max_overlaps.\nHere's an example usage of the max_overlapping_intervals() function:\npython\nintervals = [(0, 2), (3, 7), (4, 6), (7, 8), (1, 5)]\nmax_overlaps = max_overlapping_intervals(intervals)\nprint(max_overlaps) # Output: 3\nThis program creates a list of intervals intervals, calls the max_overlapping_intervals() function with the list as input, and prints the maximum number of overlapping intervals in the list. The output is 3 in this case.\n1\nzrzahid\n2\nstackoverflow\n3\ngeeksforgeeks\n4\ncodingninjas\n5\nyoutube"
    },
    {
        "Input": "Implement a function to check if a given number is a power of three.",
        "Output": "To check if a given number is a power of three, there are different approaches. Here are some resources that provide more information and examples of implementing different approaches:\nTutorialspoint:\n1\nGeeksforGeeks:\n2\nStack Overflow:\n3\nw3resource:\n4\nLeetCode:\n5\nEducative.io:\n6\nHere's an example implementation of the algorithm in Python:\npython\ndef is_power_of_three(n):\n    if n <= 0:\n        return False\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\nThis program defines a function is_power_of_three() that takes a number n as input and returns True if the number is a power of three and False otherwise. It does this by checking if the number is less than or equal to 0 and returning False if it is. It then divides the number by 3 as long as it is divisible by 3 and returns True if the number becomes 1 after the division and False otherwise.\nHere's an example usage of the is_power_of_three() function:\npython\nn1 = 27\nn2 = 45\nprint(is_power_of_three(n1)) # Output: True\nprint(is_power_of_three(n2)) # Output: False\nThis program creates two numbers n1 and n2, calls the is_power_of_three() function with the two numbers as input, and prints whether each number is a power of three or not. The output is True and False, respectively.\n1\ntutorialspoint\n2\ngeeksforgeeks\n3\nstackoverflow\n4\nw3resource\n5\nleetcode\n6\neducative"
    },
    {
        "Input": "Write a program to find the longest palindromic substring with at most K distinct characters in a given string.",
        "Output": "To find the longest palindromic substring with at most K distinct characters in a given string, we can use the following approach:\nIterate over each character in the string and treat it as the center of a potential palindrome.\nExpand the palindrome around the center by checking if the characters on either side of the center are the same. If they are, continue expanding the palindrome. If they are not, stop expanding the palindrome.\nKeep track of the longest palindrome found so far that has at most K distinct characters.\nReturn the longest palindrome found.\nHere's an example implementation of the algorithm in Python:\npython\ndef longest_palindromic_substring_with_k_distinct_characters(s, k):\n    if not s:\n        return \"\"\n    n = len(s)\n    longest_palindrome = \"\"\n    for i in range(n):\n        j = i\n        while j < n and len(set(s[i:j+1])) <= k:\n            if s[i:j+1] == s[i:j+1][::-1]:\n                if len(s[i:j+1]) > len(longest_palindrome):\n                    longest_palindrome = s[i:j+1]\n            j += 1\n    return longest_palindrome\nThis program defines a function longest_palindromic_substring_with_k_distinct_characters() that takes a string s and an integer k as input and returns the longest palindromic substring of s that has at most k distinct characters. It does this by iterating over each character in the string and treating it as the center of a potential palindrome. It then expands the palindrome around the center by checking if the characters on either side of the center are the same. If they are, it continues expanding the palindrome. If they are not, it stops expanding the palindrome. It keeps track of the longest palindrome found so far that has at most k distinct characters and returns it.\nHere's an example usage of the longest_palindromic_substring_with_k_distinct_characters() function:\npython\ns = \"abcbdbdbbdcdabd\"\nk = 3\nlongest_palindrome = longest_palindromic_substring_with_k_distinct_characters(s, k)\nprint(longest_palindrome) # Output: \"bcbdbdbbdcd\"\nThis program creates a string s and an integer k, calls the longest_palindromic_substring_with_k_distinct_characters() function with the string and integer as input, and prints the longest palindromic substring of s that has at most k distinct characters. The output is \"bcbdbdbbdcd\" in this case.\n1\ngeeksforgeeks\n2\ncodingninjas\n3\ntechiedelight\n4\ngeeksforgeeks\n5\ngitbooks"
    },
    {
        "Input": "Create a Python class representing a suffix tree and implement methods to search for substrings.",
        "Output": "To create a Python class representing a suffix tree and implement methods to search for substrings, we can use the following steps:\nDefine a class SuffixTree that represents the suffix tree. The class should have a root node and methods to insert a string into the tree and search for a substring in the tree.\nImplement the insert() method in the SuffixTree class that takes a string as input and inserts it into the suffix tree. The method should use the Ukkonen's algorithm to construct the suffix tree.\nImplement the search() method in the SuffixTree class that takes a substring as input and returns True if the substring is in the suffix tree and False otherwise. The method should traverse the suffix tree to find the substring.\nHere are some resources that provide more information and examples of implementing suffix trees and searching for substrings:\nCMU lecture notes:\n1\nFavTutor:\n2\nGitHub:\n3\nGeeksforGeeks:\n4\nBaeldung:\n5\nCoding Ninjas:\n6\nHere's an example implementation of the suffix tree in Python:\npython\nclass Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.children = {}\n\nclass SuffixTree:\n    def __init__(self, string):\n        self.string = string\n        self.root = Node(-1, -1)\n        self.nodes = [self.root]\n        self.build()\n\n    def build(self):\n        n = len(self.string)\n        for i in range(n):\n            self.add_suffix(i)\n\n    def add_suffix(self, i):\n        current = self.root\n        j = i\n        while j < len(self.string):\n            if self.string[j] not in current.children:\n                node = Node(j, len(self.string))\n                current.children[self.string[j]] = node\n                self.nodes.append(node)\n                return\n            else:\n                node = current.children[self.string[j]]\n                k = node.start\n                while k <= node.end and self.string[j] == self.string[k]:\n                    j += 1\n                    k += 1\n                if k <= node.end:\n                    split_node = Node(node.start, k - 1)\n                    node.start = k\n                    split_node.children[self.string[k]] = node\n                    current.children[self.string[j]] = split_node\n                    self.nodes.append(split_node)\n                current = node\n\n    def search(self, substring):\n        current = self.root\n        i = 0\n        while i < len(substring):\n            if substring[i] not in current.children:\n                return False\n            else:\n                node = current.children[substring[i]]\n                j = node.start\n                while j <= node.end and i < len(substring) and substring[i] == self.string[j]:\n                    i += 1\n                    j += 1\n                if j > node.end:\n                    current = node\n                else:\n                    return False\n        return True\nThis program defines a class Node that represents a node in the suffix tree and a class SuffixTree that represents the suffix tree. The Node class has a start and end index and a dictionary of children nodes. The SuffixTree class has a root node and a list of nodes in the tree. The build() method in the SuffixTree class constructs the suffix tree using the Ukkonen's algorithm. The add_suffix() method in the SuffixTree class adds a suffix to the tree by traversing the tree and adding nodes as necessary. The search() method in the SuffixTree class searches for a substring in the tree by traversing the tree and checking if the substring is in the tree.\nHere's an example usage of the SuffixTree class:\npython\nstring = \"banana\"\nsuffix_tree = SuffixTree(string)\nsubstring1 = \"ana\"\nsubstring2 = \"anb\"\nprint(suffix_tree.search(substring1)) # Output: True\nprint(suffix_tree.search(substring2)) # Output: False\nThis program creates a string string, constructs a suffix tree using the SuffixTree class, and searches for two substrings using the search() method. The output is True and False, respectively.\n1\ncmu\n2\nfavtutor\n3\ngithub\n4\ngeeksforgeeks\n5\nbaeldung\n6\ncodingninjas"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions, we can use the following approach:\nCreate an empty stack.\nIterate over each character in the string and if the character is an opening parenthesis, bracket, or curly brace, push it onto the stack.\nIf the character is a closing parenthesis, bracket, or curly brace, pop the top element from the stack and check if it matches the closing character. If it does not match, the expression is not valid.\nIf the stack is empty after iterating over all characters, the expression is valid.\nIf the stack is not empty after iterating over all characters, the expression is not valid.\nHere are some resources that provide more information and examples of implementing this approach:\nGeeksforGeeks:\n1\nCoding Ninjas:\n2\nFavTutor:\n3\nLeetCode:\n4\nBaeldung:\n5\nStack Overflow:\n6\nHere's an example implementation of the algorithm in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    for c in s:\n        if c in \"({[\":\n            stack.append(c)\n        elif c in \")}]\":\n            if not stack:\n                return False\n            if c == \")\" and stack[-1] != \"(\":\n                return False\n            if c == \"}\" and stack[-1] != \"{\":\n                return False\n            if c == \"]\" and stack[-1] != \"[\":\n                return False\n            stack.pop()\n    return not stack\nThis program defines a function is_valid_expression() that takes a string s as input and returns True if the expression is valid and False otherwise. It does this by creating an empty stack and iterating over each character in the string. If the character is an opening parenthesis, bracket, or curly brace, it pushes it onto the stack. If the character is a closing parenthesis, bracket, or curly brace, it pops the top element from the stack and checks if it matches the closing character. If it does not match, the expression is not valid. If the stack is empty after iterating over all characters, the expression is valid. If the stack is not empty after iterating over all characters, the expression is not valid.\nHere's an example usage of the is_valid_expression() function:\npython\nexpression1 = \"{[()()]}\"\nexpression2 = \"[(])\"\nprint(is_valid_expression(expression1)) # Output: True\nprint(is_valid_expression(expression2)) # Output: False\nThis program creates two expressions expression1 and expression2, calls the is_valid_expression() function with the expressions as input, and prints whether each expression is valid or not. The output is True and False, respectively.\nNote: This implementation assumes that the input expression only contains parentheses, brackets, and curly braces. If the input expression contains other characters, they will be ignored. If the input expression contains other types of brackets, such as angle brackets or square brackets, they will be treated as invalid characters.\n1\ngeeksforgeeks\n2\ncodingninjas\n3\nfavtutor\n4\nleetcode\n5\nbaeldung\n6\nstackoverflow"
    },
    {
        "Input": "Write a program to find the number of ways to divide a string into two non-empty palindromic substrings.",
        "Output": "To find the number of ways to divide a string into two non-empty palindromic substrings, we can use the following approach:\nIterate over each index in the string and treat it as the center of a potential palindrome.\nExpand the palindrome around the center by checking if the characters on either side of the center are the same. If they are, continue expanding the palindrome. If they are not, stop expanding the palindrome.\nFor each palindrome found, split the string into two substrings at the center of the palindrome and check if both substrings are palindromic.\nIf both substrings are palindromic, increment the count of ways to divide the string.\nReturn the count of ways to divide the string.\nHere are some resources that provide more information and examples of implementing this approach:\nGeeksforGeeks:\n1\nLeetCode:\n2\nCodeforces:\n3\nHere's an example implementation of the algorithm in Python:\npython\ndef count_palindromic_substrings(s):\n    n = len(s)\n    count = 0\n    for i in range(n):\n        j = i\n        while j < n and s[i:j+1] == s[i:j+1][::-1]:\n            if j - i > 0:\n                left = s[:i] + s[i:j+1]\n                right = s[j+1:]\n                if left == left[::-1] and right == right[::-1]:\n                    count += 1\n            j += 1\n    return count\nThis program defines a function count_palindromic_substrings() that takes a string s as input and returns the number of ways to divide the string into two non-empty palindromic substrings. It does this by iterating over each index in the string and treating it as the center of a potential palindrome. It then expands the palindrome around the center by checking if the characters on either side of the center are the same. If they are, it continues expanding the palindrome. If they are not, it stops expanding the palindrome. For each palindrome found, it splits the string into two substrings at the center of the palindrome and checks if both substrings are palindromic. If both substrings are palindromic, it increments the count of ways to divide the string. The function then returns the count of ways to divide the string.\nHere's an example usage of the count_palindromic_substrings() function:\npython\ns = \"abba\"\ncount = count_palindromic_substrings(s)\nprint(count) # Output: 1\nThis program creates a string s, calls the count_palindromic_substrings() function with the string as input, and prints the number of ways to divide the string into two non-empty palindromic substrings. The output is 1 in this case.\nNote: This implementation assumes that the input string only contains lowercase letters. If the input string contains other characters, they will be treated as invalid characters. If the input string contains uppercase letters, they will be treated as different characters from their lowercase counterparts.\n1\ngeeksforgeeks\n2\nopengenus\n3\ncodeforces"
    },
    {
        "Input": "Create a program to find the maximum number of non-overlapping intervals in a given list of intervals.",
        "Output": "To find the maximum number of non-overlapping intervals in a given list of intervals, we can use the following approach:\nSort the intervals based on their end times.\nInitialize two variables: max_intervals and end_time to 0.\nIterate over the sorted intervals and for each interval, if its start time is greater than or equal to end_time, increment max_intervals by 1 and update end_time to the end time of the current interval.\nReturn max_intervals.\nHere's an example implementation of the algorithm in Python:\npython\ndef max_non_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    max_intervals = 0\n    end_time = 0\n    for interval in intervals:\n        if interval[0] >= end_time:\n            max_intervals += 1\n            end_time = interval[1]\n    return max_intervals\nThis program defines a function max_non_overlapping_intervals() that takes a list of intervals intervals as input and returns the maximum number of non-overlapping intervals in the list. It does this by sorting the intervals based on their end times and then iterating over the sorted intervals. For each interval, it checks if its start time is greater than or equal to end_time. If it is, it increments max_intervals by 1 and updates end_time to the end time of the current interval. The function then returns max_intervals.\nHere's an example usage of the max_non_overlapping_intervals() function:\npython\nintervals = [(0, 2), (3, 7), (4, 6), (7, 8), (1, 5)]\nmax_intervals = max_non_overlapping_intervals(intervals)\nprint(max_intervals) # Output: 3\nThis program creates a list of intervals intervals, calls the max_non_overlapping_intervals() function with the list as input, and prints the maximum number of non-overlapping intervals in the list. The output is 3 in this case.\n1\nleetcode\n2\nstackoverflow\n3\ngeeksforgeeks\n4\nzrzahid\n5\nstanford"
    },
    {
        "Input": "Implement a function to generate the next permutation of a given list of integers in lexicographic order.",
        "Output": "To generate the next permutation of a given list of integers in lexicographic order, we can use the following approach:\nStarting from the right end of the list, find the first element that is smaller than the element to its right. If no such element exists, the list is already in its largest permutation and we return the list sorted in ascending order.\nStarting from the right end of the list, find the smallest element that is greater than the element found in step 1.\nSwap the elements found in steps 1 and 2.\nReverse the sublist to the right of the element found in step 1.\nHere are some resources that provide more information and examples of implementing this approach:\nOtee:\n1\nStack Overflow:\n2\ntakeUforward:\n3\nTutorialspoint:\n4\nYouTube:\n5\nGeeksforGeeks:\n6\nHere's an example implementation of the algorithm in Python:\npython\ndef next_permutation(nums):\n    n = len(nums)\n    i = n - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i < 0:\n        nums.reverse()\n        return nums\n    j = n - 1\n    while j > i and nums[j] <= nums[i]:\n        j -= 1\n    nums[i], nums[j] = nums[j], nums[i]\n    nums[i+1:] = reversed(nums[i+1:])\n    return nums\nThis program defines a function next_permutation() that takes a list of integers nums as input and returns the next permutation of the list in lexicographic order. It does this by finding the first element from the right that is smaller than the element to its right and then finding the smallest element from the right that is greater than the element found in the previous step. It then swaps the two elements and reverses the sublist to the right of the element found in the first step. If no such element exists in the first step, it returns the list sorted in ascending order.\nHere's an example usage of the next_permutation() function:\npython\nnums = [1, 2, 3]\nnext_nums = next_permutation(nums)\nprint(next_nums) # Output: [1, 3, 2]\nThis program creates a list of integers nums, calls the next_permutation() function with the list as input, and prints the next permutation of the list in lexicographic order. The output is\n1\n3\n2\nin this case.\nNote: This implementation assumes that the input list only contains integers. If the input list contains other types of elements, they will be treated as invalid elements. If the input list contains duplicate elements, the output will be the next permutation in lexicographic order that is greater than the input list.\n1\notee\n2\nstackoverflow\n3\ntakeuforward\n4\ntutorialspoint\n5\nyoutube\n6\ngeeksforgeeks"
    },
    {
        "Input": "Write a Python class representing a red-black tree and implement methods to insert and search for nodes.",
        "Output": "There are several resources available that provide information on implementing a red-black tree in Python and methods to insert and search for nodes. Here are some of them:\nAskPython:\n1\nGitHub:\n2\nGeeksforGeeks:\n3\nBoot.dev Blog:\n4\nFavTutor:\n5\nThese resources provide detailed explanations, code examples, and illustrations of red-black trees and their implementation in Python.\nIn summary, a red-black tree is a self-balancing binary search tree in which every node is colored either red or black. The tree has the following properties:\nThe root node is black.\nEvery leaf node is black.\nIf a node is red, then both its children are black.\nEvery simple path from a node to a descendant leaf node contains the same number of black nodes.\nTo insert a node into a red-black tree, we can use the following steps:\nPerform a standard binary search tree insertion.\nColor the new node red.\nFix the tree to maintain the red-black tree properties by performing rotations and recoloring nodes as necessary.\nTo search for a node in a red-black tree, we can use the standard binary search tree search algorithm.\nHere's an example implementation of a red-black tree in Python:\npython\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.color = 1\n\nclass RedBlackTree:\n    def __init__(self):\n        self.root = None\n\n    def rotate_left(self, node):\n        right_child = node.right\n        node.right = right_child.left\n        if right_child.left:\n            right_child.left.parent = node\n        right_child.parent = node.parent\n        if not node.parent:\n            self.root = right_child\n        elif node == node.parent.left:\n            node.parent.left = right_child\n        else:\n            node.parent.right = right_child\n        right_child.left = node\n        node.parent = right_child\n\n    def rotate_right(self, node):\n        left_child = node.left\n        node.left = left_child.right\n        if left_child.right:\n            left_child.right.parent = node\n        left_child.parent = node.parent\n        if not node.parent:\n            self.root = left_child\n        elif node == node.parent.right:\n            node.parent.right = left_child\n        else:\n            node.parent.left = left_child\n        left_child.right = node\n        node.parent = left_child\n\n    def insert(self, val):\n        node = Node(val)\n        node.parent = None\n        node.val = val\n        node.left = None\n        node.right = None\n        node.color = 1\n        parent = None\n        current = self.root\n        while current:\n            parent = current\n            if node.val < current.val:\n                current = current.left\n            else:\n                current = current.right\n        node.parent = parent\n        if not parent:\n            self.root = node\n        elif node.val < parent.val:\n            parent.left = node\n        else:\n            parent.right = node\n        if node.parent is None:\n            node.color = 0\n            return\n        if node.parent.parent is None:\n            return\n        self.fix_insert(node)\n\n    def fix_insert(self, node):\n        while node.parent and node.parent.color == 1:\n            if node.parent == node.parent.parent.right:\n                uncle = node.parent.parent.left\n                if uncle and uncle.color == 1:\n                    node.parent.color = 0\n                    uncle.color = 0\n                    node.parent.parent.color = 1\n                    node = node.parent.parent\n                else:\n                    if node == node.parent.left:\n                        node = node.parent\n                        self.rotate_right(node)\n                    node.parent.color = 0\n                    node.parent.parent.color = 1\n                    self.rotate_left(node.parent.parent)\n            else:\n                uncle = node.parent.parent.right\n                if uncle and uncle.color == 1:\n                    node.parent.color = 0\n                    uncle.color = 0\n                    node.parent.parent.color = 1\n                    node = node.parent.parent\n                else:\n                    if node == node.parent.right:\n                        node = node.parent\n                        self.rotate_left(node)\n                    node.parent.color = 0\n                    node.parent.parent.color = 1\n                    self.rotate_right(node.parent.parent)\n        self.root.color = 0\n\n    def search(self, val):\n        current = self.root\n        while current:\n            if current.val == val:\n                return True\n            elif current.val > val:\n                current = current.left\n            else:\n                current = current.right\n        return False\nThis program defines a class Node that represents a node in the red-black tree and a class `RedBlackTree"
    },
    {
        "Input": "Create a program to find the longest common subsequence of three given strings.",
        "Output": "To find the longest common subsequence of three given strings, we can extend the Longest Common Subsequence (LCS) algorithm for two strings to three strings. The LCS of three strings can be found using dynamic programming by creating a 3D array to store the length of the common subsequence in all three given sequences\n1\n2\n.\nHere's an implementation of the LCS algorithm for three strings in C++:\nc++\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint lcsOf3(string X, string Y, string Z, int m, int n, int o) {\n    int L[m + 1][n + 1][o + 1];\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= o; k++) {\n                if (i == 0 || j == 0 || k == 0) {\n                    L[i][j][k] = 0;\n                }\n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) {\n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1;\n                }\n                else {\n                    L[i][j][k] = max(max(L[i - 1][j][k], L[i][j - 1][k]), L[i][j][k - 1]);\n                }\n            }\n        }\n    }\n\n    return L[m][n][o];\n}\n\nint main() {\n    string X = \"AGGT12\";\n    string Y = \"12TXAYB\";\n    string Z = \"12XBA\";\n\n    int m = X.length();\n    int n = Y.length();\n    int o = Z.length();\n\n    cout << \"Length of LCS of three strings is \" << lcsOf3(X, Y, Z, m, n, o) << endl;\n\n    return 0;\n}\nIn this implementation, the function lcsOf3() takes three strings X, Y, and Z as input along with their lengths m, n, and o, respectively. It then creates a 3D array L to store the length of the common subsequence in all three given sequences. The function then fills the 3D array using dynamic programming and returns the length of the LCS of the three strings\n1\n2\n.\n1\ngeeksforgeeks\n2\nincludehelp"
    },
    {
        "Input": "Implement a function to check if a given number is a power of four.",
        "Output": "There are several ways to check if a given number is a power of four. One simple solution is to recursively divide the number by 4 and check if the value after recursive division becomes 1\n1\n. Another solution is to use a loop to divide the number by 4 until it is less than 4 and then check if the number is equal to 1\n2\n. A third solution is to use bitwise operators to check if there is only one set bit in the binary representation of the number and that there are no other set bits in the even positions\n3\n.\nHere's an implementation of the second solution in C++:\nc++\n#include <iostream>\nusing namespace std;\n\nbool isPowerOfFour(int num) {\n    if (num <= 0) {\n        return false;\n    }\n    while (num >= 4) {\n        if (num % 4 != 0) {\n            return false;\n        }\n        num /= 4;\n    }\n    return num == 1;\n}\n\nint main() {\n    int num = 64;\n    if (isPowerOfFour(num)) {\n        cout << num << \" is a power of 4\" << endl;\n    } else {\n        cout << num << \" is not a power of 4\" << endl;\n    }\n    return 0;\n}\nIn this implementation, the function isPowerOfFour() takes an integer num as input and returns true if num is a power of 4, and false otherwise. The function first checks if num is less than or equal to 0, and if so, returns false. It then uses a while loop to divide num by 4 until it is less than 4. If num is not divisible by 4 at any point, the function returns false. Finally, the function checks if num is equal to 1, and if so, returns true\n2\n.\n1\ntutorialspoint\n2\nhelloacm\n3\nopengenus"
    },
    {
        "Input": "\"Write a program to find the minimum number of coins needed to make a given amount of change, with a limited supply of each coin denomination.\"",
        "Output": "To find the minimum number of coins needed to make a given amount of change with a limited supply of each coin denomination, we can use dynamic programming. One approach is to create an array to store the minimum number of coins needed to make change for each value from 0 to the given amount of change. We can then iterate through each coin denomination and update the array for each value that can be made using that coin denomination. The final value in the array will be the minimum number of coins needed to make change for the given amount\n1\n2\n.\nHere's an implementation of this approach in C++:\nc++\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nint minCoins(int coins[], int m, int V) {\n    int dp[V + 1];\n    dp[0] = 0;\n\n    for (int i = 1; i <= V; i++) {\n        dp[i] = INT_MAX;\n    }\n\n    for (int i = 0; i < m; i++) {\n        for (int j = coins[i]; j <= V; j++) {\n            if (dp[j - coins[i]] != INT_MAX) {\n                dp[j] = min(dp[j], dp[j - coins[i]] + 1);\n            }\n        }\n    }\n\n    return dp[V] == INT_MAX ? -1 : dp[V];\n}\n\nint main() {\n    int coins[] = {1, 5, 10, 25};\n    int m = sizeof(coins) / sizeof(coins[0]);\n    int V = 30;\n\n    int minCount = minCoins(coins, m, V);\n\n    if (minCount == -1) {\n        cout << \"It's not possible to make change for \" << V << endl;\n    } else {\n        cout << \"Minimum \" << minCount << \" coins required to make change for \" << V << endl;\n    }\n\n    return 0;\n}\nIn this implementation, the function minCoins() takes an array of coin denominations coins, the number of coin denominations m, and the amount of change V as input. The function first creates an array dp to store the minimum number of coins needed to make change for each value from 0 to V. It initializes the first value in the array to 0 and all other values to infinity. The function then iterates through each coin denomination and updates the array for each value that can be made using that coin denomination. Finally, the function returns the value in the array for the given amount of change, or -1 if it's not possible to make change for that amount\n1\n2\n.\n1\ngeeksforgeeks\n2\ntechiedelight"
    },
    {
        "Input": "Create a Python class representing a suffix array and implement methods to search for substrings.",
        "Output": "To create a Python class representing a suffix array and implement methods to search for substrings, we can use the approach of creating an array of all suffixes of a given string and then sorting them lexicographically to obtain the suffix array. We can then use binary search to search for substrings in the suffix array\n1\n2\n.\nHere's an implementation of a Python class for a suffix array:\npython\nclass SuffixArray:\n    def __init__(self, s):\n        self.s = s\n        self.n = len(s)\n        self.suffixes = [s[i:] for i in range(self.n)]\n        self.suffix_array = sorted(range(self.n), key=lambda i: self.suffixes[i])\n\n    def search(self, pattern):\n        m = len(pattern)\n        left, right = 0, self.n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            suffix = self.suffixes[self.suffix_array[mid]]\n            if pattern > suffix:\n                left = mid + 1\n            elif pattern < suffix:\n                right = mid - 1\n            else:\n                return self.suffix_array[mid]\n        return -1\nIn this implementation, the SuffixArray class takes a string s as input and initializes the suffixes array to hold all suffixes of s and the suffix_array array to hold the sorted indices of the suffixes. The search method takes a pattern string as input and performs binary search on the suffix_array array to find the index of the first occurrence of the pattern in the suffix array. If the pattern is not found, the method returns -1\n1\n.\nHere's an example usage of the SuffixArray class:\npython\ns = \"banana\"\nsa = SuffixArray(s)\nprint(sa.suffix_array)  # prints [5, 3, 1, 0, 4, 2]\nprint(sa.search(\"ana\"))  # prints 1\nprint(sa.search(\"xyz\"))  # prints -1\nIn this example, we create a SuffixArray object for the string \"banana\" and print the sorted suffix_array. We then search for the pattern \"ana\" in the suffix array and print the index of the first occurrence, which is 1. Finally, we search for the pattern \"xyz\" which is not present in the suffix array and print -1\n1\n.\n1\ntutorialspoint\n2\nwikipedia"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions.\"",
        "Output": "To implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions, we can use a stack to keep track of the opening symbols and pop them off the stack when we encounter a closing symbol. If the closing symbol matches the top of the stack, we continue. Otherwise, the expression is not balanced. We can also use a dictionary to map the opening and closing symbols to make the code more concise\n1\n2\n.\nHere's an implementation of the function in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{', '>': '<', '/': '/'}\n    quotes = ['\"', \"'\", '`']\n    for c in s:\n        if c in mapping.values() or c in quotes:\n            stack.append(c)\n        elif c in mapping.keys():\n            if not stack or stack.pop() != mapping[c]:\n                return False\n    return not stack\nIn this implementation, the function is_valid_expression() takes a string s as input and returns True if the string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions, and False otherwise. The function first initializes an empty stack and a dictionary mapping to map the closing symbols to their corresponding opening symbols. It then iterates through each character in the string and pushes opening symbols and quotes onto the stack. If it encounters a closing symbol, it pops the top of the stack and checks if it matches the corresponding opening symbol. If not, the function returns False. Finally, the function returns True if the stack is empty, indicating that all symbols have been matched, and False otherwise\n1\n2\n.\nHere's an example usage of the is_valid_expression() function:\npython\ns = '({[<\"/\">]})'\nif is_valid_expression(s):\n    print(f'{s} is a valid expression')\nelse:\n    print(f'{s} is not a valid expression')\nIn this example, we check if the string s is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions. The function returns True, indicating that s is a valid expression\n1\n2\n.\n1\ngeeksforgeeks\n2\nleetcode"
    },
    {
        "Input": "Write a program to find the length of the longest palindromic subsequence in a given string.",
        "Output": "To find the length of the longest palindromic subsequence in a given string, we can use dynamic programming. We can create a 2D array to store the length of the longest palindromic subsequence for each substring of the given string. We can then fill the array using the following recurrence relation:\nIf the first and last characters of the substring match, the length of the longest palindromic subsequence is 2 plus the length of the longest palindromic subsequence for the substring without the first and last characters.\nOtherwise, the length of the longest palindromic subsequence is the maximum of the length of the longest palindromic subsequence for the substring without the first character and the substring without the last character.\nThe final value in the array will be the length of the longest palindromic subsequence for the entire string\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef longest_palindromic_subsequence(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\nIn this implementation, the function longest_palindromic_subsequence() takes a string s as input and returns the length of the longest palindromic subsequence in s. The function first initializes a 2D array dp to store the length of the longest palindromic subsequence for each substring of s. It then fills the diagonal of the array with 1's, indicating that each character is a palindrome of length 1. It then iterates through the array in reverse order and fills the remaining cells using the recurrence relation described above. Finally, the function returns the value in the top-right corner of the array, which represents the length of the longest palindromic subsequence for the entire string\n1\n2\n.\nHere's an example usage of the longest_palindromic_subsequence() function:\npython\ns = 'BBABCBCAB'\nprint(longest_palindromic_subsequence(s))  # prints 7\nIn this example, we find the length of the longest palindromic subsequence in the string s. The function returns 7, indicating that the longest palindromic subsequence is 'BABCBAB'\n1\n2\n.\n1\ninterviewbit\n2\ngeeksforgeeks"
    },
    {
        "Input": "Create a program to find the maximum sum of non-overlapping subarrays in a given list of integers.",
        "Output": "To find the maximum sum of non-overlapping subarrays in a given list of integers, we can use dynamic programming. One approach is to create two arrays to store the maximum sum of non-overlapping subarrays ending at each index from the left and right, respectively. We can then iterate through the array and calculate the maximum sum of non-overlapping subarrays of length k for each index i as the sum of the maximum sum of non-overlapping subarrays ending at i-k from the left and starting at i+1 from the right. The final value will be the maximum sum of non-overlapping subarrays of length k\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef max_sum_non_overlapping_subarrays(arr, k):\n    n = len(arr)\n    left = [0] * n\n    right = [0] * n\n    left_max = 0\n    right_max = 0\n    for i in range(n):\n        left_max = max(left_max, 0) + arr[i]\n        left[i] = left_max\n        if i >= k:\n            left_max -= arr[i - k]\n        j = n - i - 1\n        right_max = max(right_max, 0) + arr[j]\n        right[j] = right_max\n        if j < n - k:\n            right_max -= arr[j + k]\n    max_sum = 0\n    for i in range(k, n - k):\n        max_sum = max(max_sum, left[i - k] + right[i])\n    return max_sum\nIn this implementation, the function max_sum_non_overlapping_subarrays() takes a list of integers arr and an integer k as input and returns the maximum sum of non-overlapping subarrays of length k in arr. The function first initializes two arrays left and right to store the maximum sum of non-overlapping subarrays ending at each index from the left and right, respectively. It then iterates through the array and calculates the maximum sum of non-overlapping subarrays of length k for each index i as the sum of the maximum sum of non-overlapping subarrays ending at i-k from the left and starting at i+1 from the right. The function then calculates the maximum sum of non-overlapping subarrays of length k by iterating through the array and summing the maximum sum of non-overlapping subarrays ending at i-k from the left and starting at i from the right. Finally, the function returns the maximum sum\n1\n2\n.\nHere's an example usage of the max_sum_non_overlapping_subarrays() function:\npython\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nk = 3\nprint(max_sum_non_overlapping_subarrays(arr, k))  # prints 21\nIn this example, we find the maximum sum of non-overlapping subarrays of length k in the list arr. The function returns 21, indicating that the maximum sum of non-overlapping subarrays of length 3 is 21, which is achieved by selecting the subarrays\n1\n2\n3\nand\n7\n8\n9\n1\n2\n.\n1\nh1ros\n2\ngeeksforgeeks"
    },
    {
        "Input": "Implement a function to find the median of a stream of integers in constant time and space complexity.",
        "Output": "To find the median of a stream of integers in constant time and space complexity, we can use two heaps, a max heap to store the smaller half of the integers and a min heap to store the larger half of the integers. We can maintain the property that the size of the max heap is either equal to or one more than the size of the min heap. The median will be the top element of the max heap if the sizes of the heaps are equal, or the average of the top elements of the max heap and min heap if the size of the max heap is one more than the size of the min heap\n1\n2\n3\n.\nHere's an implementation of this approach in Python:\npython\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.max_heap = []\n        self.min_heap = []\n\n    def add_num(self, num):\n        if len(self.max_heap) == len(self.min_heap):\n            if not self.min_heap or num <= self.min_heap[0]:\n                heapq.heappush(self.max_heap, -num)\n            else:\n                heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))\n                heapq.heappush(self.min_heap, num)\n        else:\n            if num >= -self.max_heap[0]:\n                heapq.heappush(self.min_heap, num)\n            else:\n                heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))\n                heapq.heappush(self.max_heap, -num)\n\n    def find_median(self):\n        if len(self.max_heap) == len(self.min_heap):\n            return (-self.max_heap[0] + self.min_heap[0]) / 2\n        else:\n            return -self.max_heap[0]\nIn this implementation, the MedianFinder class maintains two heaps, max_heap and min_heap, to store the smaller and larger halves of the integers, respectively. The add_num method takes an integer num as input and adds it to the appropriate heap while maintaining the property that the size of the max heap is either equal to or one more than the size of the min heap. The find_median method returns the median of the integers in the stream by checking the sizes of the heaps and returning the top element of the max heap if the sizes are equal, or the average of the top elements of the max heap and min heap if the size of the max heap is one more than the size of the min heap\n1\n2\n3\n.\nHere's an example usage of the MedianFinder class:\npython\nmf = MedianFinder()\nmf.add_num(1)\nmf.add_num(2)\nmf.add_num(3)\nmf.add_num(4)\nprint(mf.find_median())  # prints 2.5\nIn this example, we create a MedianFinder object and add the integers 1, 2, 3, and 4 to the stream. We then find the median of the stream, which is 2.5\n1\n2\n3\n.\n1\nopengenus\n2\ngeeksforgeeks\n3\nstackoverflow"
    },
    {
        "Input": "Write a Python class representing a disjoint-set data structure and implement methods to perform union and find operations.",
        "Output": "To implement a Python class representing a disjoint-set data structure and implement methods to perform union and find operations, we can use the approach of representing each set as a tree, where each node points to its parent. We can use the rank of each node to keep the tree balanced and use path compression to improve the efficiency of the find operation. The union operation involves finding the roots of the trees containing the two elements and merging the smaller tree into the larger tree\n1\n2\n.\nHere's an implementation of the DisjointSet class in Python:\npython\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            if self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            elif self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\nIn this implementation, the DisjointSet class takes an integer n as input and initializes the parent and rank arrays to represent n disjoint sets. The find method takes an element x as input and returns the root of the tree containing x, while performing path compression to improve the efficiency of future find operations. The union method takes two elements x and y as input and merges the trees containing x and y, while maintaining the rank of each node to keep the tree balanced\n1\n2\n.\nHere's an example usage of the DisjointSet class:\npython\nds = DisjointSet(5)\nds.union(0, 1)\nds.union(1, 2)\nds.union(3, 4)\nprint(ds.find(2))  # prints 0\nprint(ds.find(4))  # prints 3\nIn this example, we create a DisjointSet object with 5 elements and perform several union operations to merge the elements into sets. We then find the roots of the trees containing elements 2 and 4, which are 0 and 3, respectively\n1\n2\n.\n1\ntechiedelight\n2\nplainenglish"
    },
    {
        "Input": "Create a program to find the number of distinct subsequences in a given string.",
        "Output": "To find the number of distinct subsequences in a given string, we can use dynamic programming. One approach is to create an array to store the number of distinct subsequences for each prefix of the given string. We can then fill the array using the following recurrence relation:\nIf the current character is not a duplicate, the number of distinct subsequences is twice the number of distinct subsequences for the previous prefix plus 1.\nOtherwise, the number of distinct subsequences is twice the number of distinct subsequences for the previous prefix minus the number of distinct subsequences for the previous occurrence of the current character.\nThe final value in the array will be the number of distinct subsequences for the entire string\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef distinct_subsequences(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    last = {}\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = 2 * dp[i - 1]\n        if s[i - 1] in last:\n            dp[i] -= dp[last[s[i - 1]] - 1]\n        last[s[i - 1]] = i - 1\n    return dp[n] - 1\nIn this implementation, the function distinct_subsequences() takes a string s as input and returns the number of distinct subsequences in s. The function first initializes an array dp to store the number of distinct subsequences for each prefix of s and a dictionary last to store the index of the last occurrence of each character. It then fills the array using the recurrence relation described above. Finally, the function returns the value in the last cell of the array minus 1, which represents the number of distinct subsequences for the entire string\n1\n2\n.\nHere's an example usage of the distinct_subsequences() function:\npython\ns = 'banana'\nprint(distinct_subsequences(s))  # prints 15\nIn this example, we find the number of distinct subsequences in the string s. The function returns 15, indicating that there are 15 distinct subsequences in s\n1\n2\n.\n1\ngeeksforgeeks\n2\nbaeldung"
    },
    {
        "Input": "Implement a function to check if a given number is a power of two using bitwise operations.",
        "Output": "To check if a given number is a power of two using bitwise operations, we can use the property that a power of two has only one set bit in its binary representation. We can use the bitwise AND operator to check if the given number has only one set bit by comparing it with the number obtained by subtracting 1 from it. If the result is 0, then the number is a power of two\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0\nIn this implementation, the function is_power_of_two() takes an integer n as input and returns True if n is a power of two and False otherwise. The function first checks if n is greater than 0 to ensure that it is a positive integer. It then uses the bitwise AND operator to check if n has only one set bit by comparing it with the number obtained by subtracting 1 from it. If the result is 0, then n is a power of two and the function returns True\n1\n2\n.\nHere's an example usage of the is_power_of_two() function:\npython\nn = 16\nif is_power_of_two(n):\n    print(f'{n} is a power of two')\nelse:\n    print(f'{n} is not a power of two')\nIn this example, we check if the integer n is a power of two using the is_power_of_two() function. The function returns True, indicating that n is a power of two\n1\n2\n.\n1\ngeeksforgeeks\n2\njava67"
    },
    {
        "Input": "Write a program to find the longest increasing subarray with at most K distinct integers in a given list of integers.",
        "Output": "To find the longest increasing subarray with at most K distinct integers in a given list of integers, we can use a sliding window approach. We can maintain a window of increasing subarray with at most K distinct integers and update the window as we iterate through the list. We can use two pointers, left and right, to represent the start and end of the window, respectively. We can also use a dictionary to keep track of the frequency of each integer in the window. If the number of distinct integers in the window exceeds K, we move the left pointer to the right until the number of distinct integers is less than or equal to K. We update the maximum length of the increasing subarray as we iterate through the list\n1\n.\nHere's an implementation of this approach in Python:\npython\ndef longest_increasing_subarray_with_k_distinct(arr, k):\n    n = len(arr)\n    left = 0\n    freq = {}\n    max_len = 0\n    for right in range(n):\n        freq[arr[right]] = freq.get(arr[right], 0) + 1\n        while len(freq) > k:\n            freq[arr[left]] -= 1\n            if freq[arr[left]] == 0:\n                del freq[arr[left]]\n            left += 1\n        if right - left + 1 > max_len:\n            max_len = right - left + 1\n    return max_len\nIn this implementation, the function longest_increasing_subarray_with_k_distinct() takes a list of integers arr and an integer k as input and returns the length of the longest increasing subarray with at most k distinct integers in arr. The function first initializes the left pointer to 0, a dictionary freq to keep track of the frequency of each integer in the window, and the maximum length of the increasing subarray to 0. It then iterates through the list and updates the frequency of each integer in the window. If the number of distinct integers in the window exceeds k, the function moves the left pointer to the right until the number of distinct integers is less than or equal to k. The function then updates the maximum length of the increasing subarray as it iterates through the list. Finally, the function returns the maximum length\n1\n.\nHere's an example usage of the longest_increasing_subarray_with_k_distinct() function:\npython\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nk = 3\nprint(longest_increasing_subarray_with_k_distinct(arr, k))  # prints 3\nIn this example, we find the length of the longest increasing subarray with at most k distinct integers in the list arr. The function returns 3, indicating that the longest increasing subarray with at most 3 distinct integers is\n1\n2\n3\n1\n.\n1\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing an AVL tree and implement methods to insert and search for nodes.",
        "Output": "Here's an overview of how to create a Python class representing an AVL tree and implement methods to insert and search for nodes:\nDefine a class AVLNode to represent a node in the AVL tree. Each node should have a value, left, right, and height attribute.\nDefine a class AVLTree to represent the AVL tree. The class should have a root attribute to store the root node of the tree.\nImplement a method insert to insert a node with a given value into the AVL tree. The method should use the standard BST insertion algorithm and then perform rotations to balance the tree if necessary.\nImplement a method search to search for a node with a given value in the AVL tree. The method should use the standard BST search algorithm.\nHere's an implementation of the AVLNode and AVLTree classes in Python:\npython\nclass AVLNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    def __init__(self):\n        self.root = None\nIn this implementation, the AVLNode class represents a node in the AVL tree with a value, left, right, and height attribute. The AVLTree class represents the AVL tree with a root attribute to store the root node of the tree.\nHere's an implementation of the insert method to insert a node with a given value into the AVL tree:\npython\nclass AVLTree:\n    # ...\n\n    def insert(self, value):\n        def _insert(node, value):\n            if not node:\n                return AVLNode(value)\n            elif value < node.value:\n                node.left = _insert(node.left, value)\n            else:\n                node.right = _insert(node.right, value)\n\n            node.height = 1 + max(self._height(node.left), self._height(node.right))\n\n            balance = self._balance(node)\n\n            if balance > 1 and value < node.left.value:\n                return self._rotate_right(node)\n\n            if balance < -1 and value > node.right.value:\n                return self._rotate_left(node)\n\n            if balance > 1 and value > node.left.value:\n                node.left = self._rotate_left(node.left)\n                return self._rotate_right(node)\n\n            if balance < -1 and value < node.right.value:\n                node.right = self._rotate_right(node.right)\n                return self._rotate_left(node)\n\n            return node\n\n        self.root = _insert(self.root, value)\n\n    def _height(self, node):\n        if not node:\n            return 0\n        return node.height\n\n    def _balance(self, node):\n        if not node:\n            return 0\n        return self._height(node.left) - self._height(node.right)\n\n    def _rotate_right(self, node):\n        new_root = node.left\n        node.left = new_root.right\n        new_root.right = node\n\n        node.height = 1 + max(self._height(node.left), self._height(node.right))\n        new_root.height = 1 + max(self._height(new_root.left), self._height(new_root.right))\n\n        return new_root\n\n    def _rotate_left(self, node):\n        new_root = node.right\n        node.right = new_root.left\n        new_root.left = node\n\n        node.height = 1 + max(self._height(node.left), self._height(node.right))\n        new_root.height = 1 + max(self._height(new_root.left), self._height(new_root.right))\n\n        return new_root\nIn this implementation, the insert method takes a value as input and inserts a node with the given value into the AVL tree. The method uses a helper function _insert to recursively insert the node using the standard BST insertion algorithm. After inserting the node, the method checks the balance factor of the node and performs rotations to balance the tree if necessary. The _height, _balance, _rotate_right, and _rotate_left methods are helper methods used to calculate the height, balance factor, and perform rotations.\nHere's an implementation of the search method to search for a node with a given value in the AVL tree:\npython\nclass AVLTree:\n    # ...\n\n    def search(self, value):\n        def _search(node, value):\n            if not node:\n                return None\n            elif node.value == value:\n                return node\n            elif value < node.value:\n                return _search(node.left, value)\n            else:\n                return _search(node.right, value)\n\n        return _search(self.root, value)\nIn this implementation, the search method takes a value as input and searches for a node with the given value in the AVL tree. The method uses a helper function _search to recursively search for the node using the standard BST search algorithm.\nHere's an example usage of the AVLTree class:\npython\ntree = AVLTree()\ntree.insert(1)\ntree.insert(2)\ntree.insert(3)\ntree.insert(4)\ntree.insert(5)\n\nnode = tree.search(3)\nif node:\n    print(f'Found node with value {node.value}')\nelse:\n    print('Node not found')\nIn this example, we create an AVLTree object and insert nodes with values 1, 2, 3, 4, and 5 into the tree. We then search for a node with value 3 using the search method and print a message indicating whether the node was found or not. The output of this example should be Found node with value 3.\n1\nfavtutor\n2\nchercher\n3\naskpython\n4\ngeeksforgeeks\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Implement a function to find the number of ways to decode a given string, where each letter is mapped to a number (A=1, B=2, etc.).\"",
        "Output": "To find the number of ways to decode a given string, where each letter is mapped to a number (A=1, B=2, etc.), we can use dynamic programming. One approach is to create an array to store the number of ways to decode each prefix of the string. We can then fill the array using the following recurrence relation:\nIf the current character is not 0, the number of ways to decode the current prefix is equal to the number of ways to decode the previous prefix plus the number of ways to decode the prefix two characters ago if the current prefix is a valid two-digit number.\nOtherwise, if the current character is 0 and the previous character is not 1 or 2, the string is invalid and the number of ways to decode the current prefix is 0.\nOtherwise, if the current character is 0 and the previous character is 1 or 2, the number of ways to decode the current prefix is equal to the number of ways to decode the prefix two characters ago.\nThe final value in the array will be the number of ways to decode the entire string\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef num_decodings(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    if s[0] != '0':\n        dp[1] = 1\n    for i in range(2, n + 1):\n        if s[i - 1] != '0':\n            dp[i] = dp[i - 1]\n        if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] <= '6'):\n            dp[i] += dp[i - 2]\n    return dp[n]\nIn this implementation, the function num_decodings() takes a string s as input and returns the number of ways to decode s. The function first initializes an array dp to store the number of ways to decode each prefix of s. It then fills the array using the recurrence relation described above. Finally, the function returns the value in the last cell of the array, which represents the number of ways to decode the entire string\n1\n2\n.\nHere's an example usage of the num_decodings() function:\npython\ns = '123'\nprint(num_decodings(s))  # prints 3\nIn this example, we find the number of ways to decode the string s. The function returns 3, indicating that there are 3 possible decodings of the string: ABC, LC, and AW\n1\n2\n.\n1\ngeeksforgeeks\n2\nstackoverflow"
    },
    {
        "Input": "Write a program to find the maximum sum of a subsequence with the constraint that no two elements in the subsequence are adjacent.",
        "Output": "To find the maximum sum of a subsequence with the constraint that no two elements in the subsequence are adjacent, we can use dynamic programming. One approach is to create an array to store the maximum sum of non-adjacent subsequence ending at each index. We can then fill the array using the following recurrence relation:\nIf the current element is not included, the maximum sum of non-adjacent subsequence ending at the current index is equal to the maximum sum of non-adjacent subsequence ending at the previous index.\nOtherwise, if the current element is included, the maximum sum of non-adjacent subsequence ending at the current index is equal to the sum of the current element and the maximum sum of non-adjacent subsequence ending at the index two positions before the current index.\nThe final value in the array will be the maximum sum of non-adjacent subsequence in the given list\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef max_sum_non_adjacent(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return arr[0]\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + arr[i])\n    return dp[n - 1]\nIn this implementation, the function max_sum_non_adjacent() takes a list of integers arr as input and returns the maximum sum of non-adjacent subsequence in arr. The function first checks if the length of the list is 0 or 1 and returns the appropriate value. It then initializes an array dp to store the maximum sum of non-adjacent subsequence ending at each index. It then fills the array using the recurrence relation described above. Finally, the function returns the value in the last cell of the array, which represents the maximum sum of non-adjacent subsequence in the given list\n1\n2\n.\nHere's an example usage of the max_sum_non_adjacent() function:\npython\narr = [5, 5, 10, 100, 10, 5]\nprint(max_sum_non_adjacent(arr))  # prints 110\nIn this example, we find the maximum sum of non-adjacent subsequence in the list arr. The function returns 110, indicating that the maximum sum of non-adjacent subsequence in arr is 110, which is obtained by picking the subsequence {5, 100, 5}\n2\n.\n1\ncodingninjas\n2\ngeeksforgeeks"
    },
    {
        "Input": "\"Create a program to find the number of islands in a 2D grid, where islands are defined by connected regions of '1's, but diagonal connections are not considered.\"",
        "Output": "To find the number of islands in a 2D grid, where islands are defined by connected regions of '1's, but diagonal connections are not considered, we can use a depth-first search (DFS) algorithm. We can traverse the grid and for each cell that contains a '1', we can perform a DFS to mark all the adjacent cells that contain a '1' as visited. We can then count the number of times we perform a DFS to find the total number of islands in the grid.\nHere's an implementation of this approach in Python:\npython\ndef num_islands(grid):\n    if not grid:\n        return 0\n\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '#'\n        dfs(grid, i + 1, j)\n        dfs(grid, i - 1, j)\n        dfs(grid, i, j + 1)\n        dfs(grid, i, j - 1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(grid, i, j)\n                count += 1\n\n    return count\nIn this implementation, the function num_islands() takes a 2D grid of characters grid as input and returns the number of islands in the grid. The function first checks if the grid is empty and returns 0 if it is. It then defines a helper function dfs to perform a DFS on the grid starting from a given cell. The dfs function marks the current cell as visited and recursively calls itself on all adjacent cells that contain a '1'. The function then initializes a counter count to 0 and iterates through the grid, calling the dfs function on each cell that contains a '1' and incrementing the count variable each time a DFS is performed. Finally, the function returns the count variable, which represents the total number of islands in the grid.\nHere's an example usage of the num_islands() function:\npython\ngrid = [['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']]\nprint(num_islands(grid))  # prints 3\nIn this example, we find the number of islands in the 2D grid grid. The function returns 3, indicating that there are 3 islands in the grid.\n1\nleetcode\n2\ngitbooks\n3\ngeeksforgeeks\n4\ninterviewbit\n5\ntechiedelight"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators, we can use a stack data structure. We can iterate through the string and push each opening bracket onto the stack. When we encounter a closing bracket, we can pop the top element from the stack and check if it matches the closing bracket. If it does not match, the string is not valid. If we reach the end of the string and the stack is empty, the string is valid.\nHere's an implementation of this approach in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    for c in s:\n        if c in '({[':\n            stack.append(c)\n        elif c in ')}]':\n            if not stack:\n                return False\n            if c == ')' and stack[-1] != '(':\n                return False\n            if c == '}' and stack[-1] != '{':\n                return False\n            if c == ']' and stack[-1] != '[':\n                return False\n            stack.pop()\n    return not stack\nIn this implementation, the function is_valid_expression() takes a string s as input and returns True if s is a valid expression with balanced parentheses, brackets, and curly braces, and False otherwise. The function first initializes an empty stack and iterates through the string. For each character in the string, the function checks if it is an opening bracket and pushes it onto the stack. If it is a closing bracket, the function checks if the top element of the stack matches the closing bracket. If it does not match, the function returns False. If we reach the end of the string and the stack is empty, the function returns True. Otherwise, the function returns False.\nHere's an example usage of the is_valid_expression() function:\npython\ns = '[(1 + 2) * {3 - 4}]'\nif is_valid_expression(s):\n    print(f'{s} is a valid expression')\nelse:\n    print(f'{s} is not a valid expression')\nIn this example, we check if the string s is a valid expression with balanced parentheses, brackets, and curly braces using the is_valid_expression() function. The function returns True, indicating that s is a valid expression.\n1\ngeeksforgeeks\n2\ncodingninjas\n3\nfavtutor\n4\nleetcode\n5\nbaeldung"
    },
    {
        "Input": "Write a Python class representing a segment tree and implement methods to update values and query for range sums.",
        "Output": "To implement a segment tree in Python, we can define a class SegmentTree that represents the tree. The class should have an array to store the tree, a method to build the tree, and methods to update values and query for range sums.\nHere's an implementation of the SegmentTree class in Python:\npython\nclass SegmentTree:\n    def __init__(self, arr):\n        self.arr = arr\n        self.tree = [0] * (4 * len(arr))\n        self.build_tree(0, 0, len(arr) - 1)\n\n    def build_tree(self, node, start, end):\n        if start == end:\n            self.tree[node] = self.arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(2 * node + 1, start, mid)\n            self.build_tree(2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update(self, node, start, end, idx, val):\n        if start == end:\n            self.arr[idx] = val\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update(2 * node + 1, start, mid, idx, val)\n            else:\n                self.update(2 * node + 2, mid + 1, end, idx, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_sum = self.query(2 * node + 1, start, mid, l, r)\n        right_sum = self.query(2 * node + 2, mid + 1, end, l, r)\n        return left_sum + right_sum\nIn this implementation, the SegmentTree class represents the segment tree with an array arr to store the original array and an array tree to store the tree. The class has a constructor that takes the original array as input and builds the tree using the build_tree method. The build_tree method recursively builds the tree by dividing the array into two halves and building the left and right subtrees. The update method updates a value in the original array and the corresponding value in the tree. The query method queries the tree for the sum of values in a given range.\nHere's an example usage of the SegmentTree class:\npython\narr = [1, 3, 5, 7, 9, 11]\ntree = SegmentTree(arr)\nprint(tree.query(0, 0, len(arr) - 1, 1, 3))  # prints 15\ntree.update(0, 0, len(arr) - 1, 2, 6)\nprint(tree.query(0, 0, len(arr) - 1, 1, 3))  # prints 16\nIn this example, we create a segment tree from the array arr using the SegmentTree class. We then query the tree for the sum of values in the range\n1\n3\nusing the query method and print the result. The function returns 15, which is the sum of values 3, 5, and 7. We then update the value at index 2 to 6 using the update method and query the tree again for the sum of values in the range\n1\n3\n. The function returns 16, which is the sum of values 3, 6, and 7.\n1\nleetcode\n2\nleetcode\n3\ngeeksforgeeks\n4\nhackerearth\n5\ngeeksforgeeks"
    },
    {
        "Input": "Create a program to find the minimum number of swaps required to sort a given list of integers.",
        "Output": "To find the minimum number of swaps required to sort a given list of integers, we can use various approaches. Here are some of the approaches and their implementations:\nApproach 1: Graph-Based Approach\nWe can visualize the problem as a graph. We will have N nodes and an edge directed from node i to node j if the element at the i’th index must be present at the j’th index in the sorted array. The graph will now contain many non-intersecting cycles. Now a cycle with 2 nodes will only require 1 swap to reach the correct ordering, similarly, a cycle with 3 nodes will only require 2 swaps to do so. Hence, the answer is the sum of cycle_size - 1 for all cycles in the graph\n1\n.\nHere's an implementation of this approach in Python:\npython\ndef min_swaps(arr):\n    n = len(arr)\n    visited = [False] * n\n    node_dict = {arr[i]: i for i in range(n)}\n    ans = 0\n    for i in range(n):\n        if visited[i] or node_dict[arr[i]] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = node_dict[arr[j]]\n            cycle_size += 1\n        ans += cycle_size - 1\n    return ans\nIn this implementation, the function min_swaps() takes a list of integers arr as input and returns the minimum number of swaps required to sort the array. The function first initializes a list visited to keep track of visited nodes and a dictionary node_dict to map each element to its index in the array. It then iterates through the array and checks if the current element has been visited or if it is already in the correct position. If it has been visited or is already in the correct position, the function continues to the next element. Otherwise, the function finds the cycle that contains the current element and calculates the size of the cycle. The function then adds cycle_size - 1 to the answer. Finally, the function returns the answer, which represents the minimum number of swaps required to sort the array\n1\n.\nApproach 2: Greedy Approach\nWe can use a greedy approach to find the minimum number of swaps required to sort the array. We can count the number of smaller elements on the right side than the current element. For each element, we swap it with the smallest element on the right side that is smaller than it. We repeat this process until the array is sorted\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef min_swaps(arr):\n    n = len(arr)\n    arr_pos = [(arr[i], i) for i in range(n)]\n    arr_pos.sort()\n    visited = [False] * n\n    ans = 0\n    for i in range(n):\n        if visited[i] or arr_pos[i][1] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = arr_pos[j][1]\n            cycle_size += 1\n        ans += cycle_size - 1\n    return ans\nIn this implementation, the function min_swaps() takes a list of integers arr as input and returns the minimum number of swaps required to sort the array. The function first creates a list of tuples arr_pos that contains each element and its index in the array. It then sorts the list by element value. The function then initializes a list visited to keep track of visited nodes and iterates through the array. For each element, the function checks if it has been visited or if it is already in the correct position. If it has been visited or is already in the correct position, the function continues to the next element. Otherwise, the function finds the cycle that contains the current element and calculates the size of the cycle. The function then adds cycle_size - 1 to the answer. Finally, the function returns the answer, which represents the minimum number of swaps required to sort the array\n2\n.\nHere's an example usage of the min_swaps() function:\npython\narr = [3, 9, 2, 4, 2]\nprint(min_swaps(arr))  # prints 2\nIn this example, we find the minimum number of swaps required to sort the array arr using the min_swaps() function. The function returns 2, indicating that 2 swaps are required to sort the array.\n1\ninterviewbit\n2\ncodingninjas"
    },
    {
        "Input": "Implement a function to find the longest common subsequence of two given strings.",
        "Output": "To find the longest common subsequence of two given strings, we can use dynamic programming. We can create a 2D array to store the length of the longest common subsequence of the prefixes of the two strings. We can then fill the array using the following recurrence relation:\nIf the current characters of the two strings match, the length of the longest common subsequence is equal to the length of the longest common subsequence of the prefixes of the two strings without the current characters plus 1.\nOtherwise, the length of the longest common subsequence is equal to the maximum of the length of the longest common subsequence of the prefix of the first string without the current character and the prefix of the second string with the current character, and the length of the longest common subsequence of the prefix of the first string with the current character and the prefix of the second string without the current character.\nThe final value in the array will be the length of the longest common subsequence of the two strings\n1\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef longest_common_subsequence(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            lcs.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return ''.join(reversed(lcs))\nIn this implementation, the function longest_common_subsequence() takes two strings s1 and s2 as input and returns the longest common subsequence of the two strings. The function first initializes a 2D array dp to store the length of the longest common subsequence of the prefixes of the two strings. It then fills the array using the recurrence relation described above. The function then constructs the longest common subsequence by tracing back from the last cell of the array. Finally, the function returns the longest common subsequence as a string\n1\n2\n.\nHere's an example usage of the longest_common_subsequence() function:\npython\ns1 = 'AGGTAB'\ns2 = 'GXTXAYB'\nprint(longest_common_subsequence(s1, s2))  # prints GTAB\nIn this example, we find the longest common subsequence of the two strings s1 and s2 using the longest_common_subsequence() function. The function returns GTAB, which is the longest common subsequence of the two strings.\n1\ntutorialspoint\n2\ngeeksforgeeks"
    },
    {
        "Input": "\"Write a program to find the number of arithmetic slices in a given list of integers, where an arithmetic slice is a contiguous subarray with at least three elements having the same difference.\"",
        "Output": "To find the number of arithmetic slices in a given list of integers, we can use dynamic programming. We can create an array to store the number of arithmetic slices ending at each index. We can then fill the array using the following recurrence relation:\nIf the current element, the previous element, and the element two positions before the current element form an arithmetic sequence, the number of arithmetic slices ending at the current index is equal to the number of arithmetic slices ending at the previous index plus 1.\nOtherwise, the number of arithmetic slices ending at the current index is 0.\nThe final value in the array will be the total number of arithmetic slices in the given list\n1\n.\nHere's an implementation of this approach in Python:\npython\ndef num_arithmetic_slices(arr):\n    n = len(arr)\n    if n < 3:\n        return 0\n    dp = [0] * n\n    for i in range(2, n):\n        if arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]:\n            dp[i] = dp[i - 1] + 1\n    return sum(dp)\nIn this implementation, the function num_arithmetic_slices() takes a list of integers arr as input and returns the number of arithmetic slices in the list. The function first checks if the length of the list is less than 3 and returns 0 if it is. It then initializes an array dp to store the number of arithmetic slices ending at each index. It then fills the array using the recurrence relation described above. Finally, the function returns the sum of the values in the array, which represents the total number of arithmetic slices in the given list\n1\n.\nHere's an example usage of the num_arithmetic_slices() function:\npython\narr = [1, 2, 3, 4]\nprint(num_arithmetic_slices(arr))  # prints 3\nIn this example, we find the number of arithmetic slices in the list arr using the num_arithmetic_slices() function. The function returns 3, indicating that there are 3 arithmetic slices in the list:\n1\n2\n3\n,\n2\n3\n4\n, and\n1\n2\n3\n4\n.\n1\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing a B-tree and implement methods to insert and search for nodes.",
        "Output": "Here's an implementation of a B-tree in Python that supports insert and search operations, based on the code from\n1\n:\npython\nclass BTree:\n    class Node:\n        def __init__(self, t):\n            self.keys = []\n            self.children = []\n            self.leaf = True\n            self.t = t\n\n        def split(self, parent, i):\n            new_node = self.__class__(self.t)\n            mid = self.t - 1\n            new_node.children = self.children[mid + 1:]\n            new_node.keys = self.keys[mid:]\n            self.children = self.children[:mid + 1]\n            self.keys = self.keys[:mid]\n            if parent:\n                parent.insert_child(i + 1, new_node, self.keys[mid])\n            else:\n                new_root = self.__class__(self.t)\n                new_root.leaf = False\n                new_root.keys = [self.keys[mid]]\n                new_root.children = [self, new_node]\n                self.parent = new_root\n                new_node.parent = new_root\n\n        def insert_child(self, i, child, key):\n            self.children.insert(i, child)\n            self.keys.insert(i - 1, key)\n            child.parent = self\n\n        def __repr__(self):\n            return f\"<BTree.Node: {self.keys}>\"\n\n    def __init__(self, t):\n        self.t = t\n        if self.t <= 1:\n            raise ValueError(\"B-Tree must have a degree of 2 or more.\")\n        self.root = self.Node(t)\n\n    def search(self, key, node=None):\n        if node is None:\n            node = self.root\n        if key in node.keys:\n            return node\n        elif node.leaf:\n            return None\n        else:\n            i = 0\n            while i < len(node.keys) and key > node.keys[i]:\n                i += 1\n            return self.search(key, node.children[i])\n\n    def insert(self, key):\n        node = self.root\n        if len(node.keys) == 2 * self.t - 1:\n            new_root = self.Node(self.t)\n            new_root.children.append(node)\n            node.parent = new_root\n            new_root.leaf = False\n            node.split(new_root, 0)\n            self.root = new_root\n            node = new_root\n        while not node.leaf:\n            i = 0\n            while i < len(node.keys) and key > node.keys[i]:\n                i += 1\n            if len(node.children[i].keys) == 2 * self.t - 1:\n                node.children[i].split(node, i)\n                if key > node.keys[i]:\n                    i += 1\n            node = node.children[i]\n        if key in node.keys:\n            return\n        node.keys.append(key)\n        node.keys.sort()\n\n    def __repr__(self):\n        return f\"<BTree: root={self.root}>\"\nIn this implementation, the BTree class represents a B-tree with a given degree t. The class has an inner class Node that represents a node in the tree. The Node class has an array keys to store the keys in the node, an array children to store the child nodes, a boolean leaf to indicate whether the node is a leaf node, and a degree t. The Node class also has methods to split the node, insert a child node, and return a string representation of the node.\nThe BTree class has a constructor that takes the degree t as input and initializes the root node. The class also has methods to search for a key in the tree and insert a key into the tree. The search method recursively searches for a key in the tree starting from the root node. The insert method inserts a key into the tree by traversing the tree from the root node to a leaf node and splitting nodes as necessary.\nHere's an example usage of the BTree class:\npython\ntree = BTree(3)\ntree.insert(1)\ntree.insert(2)\ntree.insert(3)\ntree.insert(4)\ntree.insert(5)\nprint(tree.search(3))  # prints <BTree.Node: [3]>\nIn this example, we create a B-tree with degree 3 using the BTree class. We then insert the keys 1, 2, 3, 4, and 5 into the tree using the insert method. Finally, we search for the key 3 in the tree using the search method and print the result, which is the node that contains the key 3.\n1\ngithub"
    },
    {
        "Input": "Implement a function to check if a given number is a power of any other number.",
        "Output": "To check if a given number is a power of any other number, we can use various approaches. Here are some of the approaches and their implementations:\nApproach 1: Repeated Division\nA simple solution is to repeatedly divide the given number by the potential base number until the quotient becomes 1. If the remainder is 0 at every step, the given number is a power of the potential base number. Otherwise, it is not\n1\n.\nHere's an implementation of this approach in Python:\npython\ndef is_power(x, y):\n    if x == 1:\n        return y == 1\n    while y % x == 0:\n        y //= x\n    return y == 1\nIn this implementation, the function is_power() takes two integers x and y as input and returns True if y is a power of x and False otherwise. The function first checks if x is equal to 1 and y is equal to 1, in which case y is a power of x. It then repeatedly divides y by x until the quotient becomes 1. If the remainder is 0 at every step, the function returns True. Otherwise, it returns False\n1\n.\nApproach 2: Logarithm\nAnother solution is to take the logarithm of the given number with respect to the potential base number. If the result is an integer, the given number is a power of the potential base number. Otherwise, it is not\n2\n.\nHere's an implementation of this approach in Python:\npython\nimport math\n\ndef is_power(x, y):\n    if x == 1:\n        return y == 1\n    power = int(math.log(y, x) + 0.5)\n    return x ** power == y\nIn this implementation, the function is_power() takes two integers x and y as input and returns True if y is a power of x and False otherwise. The function first checks if x is equal to 1 and y is equal to 1, in which case y is a power of x. It then takes the logarithm of y with respect to x using the math.log() function and rounds the result to the nearest integer using the int() and + 0.5 trick. If x raised to the power of the result is equal to y, the function returns True. Otherwise, it returns False\n2\n.\nHere's an example usage of the is_power() function:\npython\nprint(is_power(2, 8))  # prints True\nprint(is_power(3, 8))  # prints False\nIn this example, we check if the number 8 is a power of 2 and 3 using the is_power() function. The function returns True for the first call and False for the second call, indicating that 8 is a power of 2 but not a power of 3.\n1\ngeeksforgeeks\n2\ngeeksforgeeks"
    },
    {
        "Input": "\"Write a program to find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent, and the subarray can wrap around the end of the list.\"",
        "Output": "To find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent, and the subarray can wrap around the end of the list, we can use dynamic programming. We can create an array to store the maximum sum of non-adjacent elements ending at each index. We can then fill the array using the following recurrence relation:\nIf the current element is included in the sum, the maximum sum of non-adjacent elements ending at the current index is equal to the maximum sum of non-adjacent elements ending at the index two positions before the current index plus the current element.\nIf the current element is not included in the sum, the maximum sum of non-adjacent elements ending at the current index is equal to the maximum sum of non-adjacent elements ending at the previous index.\nThe final value in the array will be the maximum sum of non-adjacent elements in the list\n1\n.\nTo handle the constraint that the subarray can wrap around the end of the list, we can compute the maximum sum of non-adjacent elements in the list twice: once without the first element and once without the last element. We can then take the maximum of the two results as the final answer\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef max_sum_non_adjacent(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n    if n == 2:\n        return max(arr[0], arr[1])\n    dp1 = [0] * n\n    dp2 = [0] * n\n    dp1[0] = arr[0]\n    dp1[1] = max(arr[0], arr[1])\n    dp2[1] = arr[1]\n    dp2[2] = max(arr[1], arr[2])\n    for i in range(2, n - 1):\n        dp1[i] = max(dp1[i - 2] + arr[i], dp1[i - 1])\n    for i in range(3, n):\n        dp2[i] = max(dp2[i - 2] + arr[i], dp2[i - 1])\n    return max(dp1[-2], dp2[-1])\nIn this implementation, the function max_sum_non_adjacent() takes a list of integers arr as input and returns the maximum sum of non-adjacent elements in the list. The function first checks if the length of the list is less than or equal to 2 and returns the maximum of the two elements if it is. It then initializes two arrays dp1 and dp2 to store the maximum sum of non-adjacent elements ending at each index. It then fills the arrays using the recurrence relation described above. Finally, the function returns the maximum of the second-to-last element of dp1 and the last element of dp2, which represents the maximum sum of non-adjacent elements in the list\n1\n2\n.\nHere's an example usage of the max_sum_non_adjacent() function:\npython\narr = [3, 2, 5, 10, 7]\nprint(max_sum_non_adjacent(arr))  # prints 15\nIn this example, we find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent, and the subarray can wrap around the end of the list, using the max_sum_non_adjacent() function. The function returns 15, which is the maximum sum of non-adjacent elements in the list.\n1\ngeeksforgeeks\n2\nstackoverflow"
    },
    {
        "Input": "Implement a function to calculate the Fibonacci sequence up to a given number using dynamic programming.",
        "Output": "To calculate the Fibonacci sequence up to a given number using dynamic programming, we can use the bottom-up approach. In this approach, we start with the base cases of the Fibonacci sequence (0 and 1) and iteratively compute the next numbers in the sequence by summing the previous two numbers. We can use an array to store the computed values and avoid redundant computations by reusing the values in the array.\nHere's an implementation of this approach in Python:\npython\ndef fibonacci(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [0]\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib\nIn this implementation, the function fibonacci() takes an integer n as input and returns a list of the Fibonacci sequence up to the n-th number. The function first checks if n is equal to 0 or 1 and returns an empty list or a list containing 0, respectively. It then initializes an array fib with the first two numbers in the Fibonacci sequence. It then iteratively computes the next numbers in the sequence by summing the previous two numbers and appending the result to the array. Finally, the function returns the array, which contains the Fibonacci sequence up to the n-th number.\nHere's an example usage of the fibonacci() function:\npython\nprint(fibonacci(10))  # prints [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nIn this example, we calculate the Fibonacci sequence up to the 10th number using the fibonacci() function. The function returns\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n, which is the Fibonacci sequence up to the 10th number.\n1\nmedium\n2\nplainenglish\n3\nyoutube\n4\nbaeldung\n5\nmit"
    },
    {
        "Input": "Write a program to find the largest prime palindrome less than a given number.",
        "Output": "To find the largest prime palindrome less than a given number, we can use the following algorithm:\nStart from the given number and iterate backwards until we find a number that is both prime and a palindrome.\nCheck if each number is prime by iterating from 2 to the square root of the number and checking if the number is divisible by any of the integers in that range.\nCheck if each number is a palindrome by converting it to a string and checking if the string is equal to its reverse.\nHere's an implementation of this algorithm in Python:\npython\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef largest_prime_palindrome(n):\n    for i in range(n - 1, 0, -1):\n        if is_prime(i) and is_palindrome(i):\n            return i\n    return None\nIn this implementation, the function is_prime() takes an integer n as input and returns True if n is prime and False otherwise. The function first checks if n is less than 2 and returns False if it is. It then iterates from 2 to the square root of n and checks if n is divisible by any of the integers in that range. If n is divisible by any of those integers, the function returns False. Otherwise, it returns True.\nThe function is_palindrome() takes an integer n as input and returns True if n is a palindrome and False otherwise. The function first converts n to a string and checks if the string is equal to its reverse using the slice notation.\nThe function largest_prime_palindrome() takes an integer n as input and returns the largest prime palindrome less than n. The function iterates backwards from n - 1 to 1 and checks if each number is both prime and a palindrome using the is_prime() and is_palindrome() functions. If a number is both prime and a palindrome, the function returns that number. If no such number is found, the function returns None.\nHere's an example usage of the largest_prime_palindrome() function:\npython\nprint(largest_prime_palindrome(1000))  # prints 929\nIn this example, we find the largest prime palindrome less than 1000 using the largest_prime_palindrome() function. The function returns 929, which is the largest prime palindrome less than 1000.\n1\ngithub\n2\nleetcode\n3\nwikipedia\n4\ngeeksforgeeks\n5\nreddit"
    },
    {
        "Input": "Create a Python class representing a self-balancing binary search tree (such as an AVL tree or a red-black tree) and implement methods to insert and search for nodes.",
        "Output": "There are several self-balancing binary search tree implementations available in Python, such as AVL trees and red-black trees. Here are some resources that provide implementations and explanations of these data structures:\nThe self-balancing-binary-search-tree package on PyPI provides a Python implementation of an AVL tree\n1\n. The package includes a TreeNode class that represents a node in the tree and a SBBST class that represents the tree itself. The SBBST class provides methods to insert and search for nodes in the tree.\nThe AVL_Tree repository on GitHub provides an implementation of an AVL tree in Python\n2\n. The repository includes a Node class that represents a node in the tree and an AVLTree class that represents the tree itself. The AVLTree class provides methods to insert and search for nodes in the tree.\nThe askpython website provides an explanation of balanced binary trees and an implementation of a program in Python to determine if a binary tree is balanced or not\n3\n. The article includes an algorithm to check if a binary tree is balanced and a Python implementation of the algorithm.\nThe geeksforgeeks website provides an explanation of self-balancing binary search trees and a Python library for implementing them\n4\n. The library includes classes for AVL trees, red-black trees, and splay trees, as well as methods to insert, delete, and search for nodes in the trees.\nThe w3resource website provides an implementation of a program in Python to create a balanced binary search tree from a sorted array\n5\n. The article includes a TreeNode class that represents a node in the tree and a sorted_array_to_bst function that creates a balanced binary search tree from a sorted array.\nThe tutorialspoint website provides an explanation of balanced binary trees and an implementation of a program in Python to check if a binary tree is balanced or not\n6\n. The article includes a Node class that represents a node in the tree and a is_balanced function that checks if a binary tree is balanced.\n1\npypi\n2\nbetsybaileyy\n3\naskpython\n4\ngeeksforgeeks\n5\nw3resource\n6\ntutorialspoint"
    },
    {
        "Input": "Implement a function to check if a given number is a perfect square without using any built-in functions.",
        "Output": "To check if a given number is a perfect square without using any built-in functions, we can use various approaches. Here are some of the approaches and their implementations:\nApproach 1: Integer Square Root Algorithm\nOne solution is to use the integer square root algorithm and verify that the root's square value is the original number. We can start with an initial guess of the square root and iteratively improve the guess until it converges to the actual square root. We can then check if the square of the guess is equal to the original number\n1\n.\nHere's an implementation of this approach in Python:\npython\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    guess = n // 2\n    while guess * guess > n:\n        guess = (guess + n // guess) // 2\n    return guess * guess == n\nIn this implementation, the function is_perfect_square() takes an integer n as input and returns True if n is a perfect square and False otherwise. The function first checks if n is less than 0 and returns False if it is. It then checks if n is equal to 0 and returns True if it is. It then initializes an initial guess of the square root of n as n // 2. It then iteratively improves the guess by computing the average of the guess and n // guess and rounding down to the nearest integer using the // operator. It then checks if the square of the guess is equal to n and returns True if it is. Otherwise, it returns False.\nApproach 2: Odd Number Property\nAnother solution is to use the property that every perfect square is the sum of the odd numbers starting with 1. We can repeatedly subtract odd numbers from the given number until it becomes 0 or negative. If the value becomes 0 at some point, we can say that the number is a perfect square. Otherwise, it is not\n2\n.\nHere's an implementation of this approach in Python:\npython\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    i = 1\n    while n > 0:\n        n -= i\n        i += 2\n    return n == 0\nIn this implementation, the function is_perfect_square() takes an integer n as input and returns True if n is a perfect square and False otherwise. The function first checks if n is less than 0 and returns False if it is. It then initializes a variable i to 1 and repeatedly subtracts odd numbers from n until it becomes 0 or negative. If n becomes 0 at some point, the function returns True. Otherwise, it returns False.\nHere's an example usage of the is_perfect_square() function:\npython\nprint(is_perfect_square(16))  # prints True\nprint(is_perfect_square(17))  # prints False\nIn this example, we check if the numbers 16 and 17 are perfect squares using the is_perfect_square() function. The function returns True for the first call and False for the second call, indicating that 16 is a perfect square but 17 is not.\n1\nstackexchange\n2\ntechiedelight"
    },
    {
        "Input": "Write a program to find the longest common substring of two given strings.",
        "Output": "To find the longest common substring of two given strings, we can use dynamic programming. We can create a table to store the lengths of the longest common suffixes of all possible substrings of the two strings. We can then find the maximum value in the table and use it to extract the longest common substring.\nHere's an implementation of this approach in Python:\npython\ndef longest_common_substring(s1, s2):\n    m, n = len(s1), len(s2)\n    table = [[0] * (n + 1) for _ in range(m + 1)]\n    max_len = 0\n    end = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                table[i][j] = table[i - 1][j - 1] + 1\n                if table[i][j] > max_len:\n                    max_len = table[i][j]\n                    end = i\n            else:\n                table[i][j] = 0\n    return s1[end - max_len:end]\nIn this implementation, the function longest_common_substring() takes two strings s1 and s2 as input and returns the longest common substring of the two strings. The function first initializes a table table with dimensions (m + 1) x (n + 1), where m and n are the lengths of s1 and s2, respectively. It also initializes variables max_len and end to 0 to keep track of the maximum length of the common substring and its ending position in s1. It then iterates over all possible substrings of s1 and s2 and fills the table with the lengths of the longest common suffixes of each substring. If the length of a common suffix is greater than max_len, the function updates max_len and end to reflect the new maximum length and ending position. Finally, the function returns the longest common substring of s1 and s2 by extracting the substring of s1 that ends at position end and has length max_len.\nHere's an example usage of the longest_common_substring() function:\npython\ns1 = \"ABABC\"\ns2 = \"BABCA\"\nprint(longest_common_substring(s1, s2))  # prints \"ABC\"\nIn this example, we find the longest common substring of the strings \"ABABC\" and \"BABCA\" using the longest_common_substring() function. The function returns \"ABC\", which is the longest common substring of the two strings.\n1\nwikipedia\n2\njavatpoint\n3\ncodingninjas\n4\ngeeksforgeeks\n5\ninterviewbit"
    },
    {
        "Input": "Create a program to find the maximum XOR value of two numbers in a given list of integers.",
        "Output": "To find the maximum XOR value of two numbers in a given list of integers, we can use the bitwise XOR operator (^) to compute the XOR of all possible pairs of numbers in the list and keep track of the maximum value. However, this approach has a time complexity of O(n^2), where n is the length of the list, which is not efficient for large lists.\nA more efficient approach is to use a trie data structure to store the binary representation of the numbers in the list and find the maximum XOR value of two numbers by traversing the trie and selecting the bits that maximize the XOR value. This approach has a time complexity of O(n log m), where m is the maximum number of bits in the binary representation of the numbers in the list, which is much better than the brute-force approach.\nHere's an implementation of this approach in Python:\npython\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.is_end = True\n\n    def find_max_xor(self, num):\n        node = self.root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                node = node.children[1 - bit]\n                xor |= (1 << i)\n            else:\n                node = node.children[bit]\n        return xor\n\ndef max_xor(nums):\n    trie = Trie()\n    for num in nums:\n        trie.insert(num)\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, trie.find_max_xor(num))\n    return max_xor\nIn this implementation, the TrieNode class represents a node in the trie and has a dictionary children to store the child nodes and a boolean is_end to indicate whether the node represents the end of a number. The Trie class represents the trie itself and has a root node. The Trie class provides methods to insert a number into the trie and find the maximum XOR value of a number in the trie.\nThe max_xor() function takes a list of integers nums as input and returns the maximum XOR value of two numbers in the list. The function first creates a trie and inserts all the numbers in the list into the trie. It then iterates over all the numbers in the list and finds the maximum XOR value of each number in the trie using the find_max_xor() method. Finally, the function returns the maximum XOR value.\nHere's an example usage of the max_xor() function:\npython\nnums = [3, 10, 5, 25, 2, 8]\nprint(max_xor(nums))  # prints 28\nIn this example, we find the maximum XOR value of two numbers in the list\n3\n10\n5\n25\n2\n8\nusing the max_xor() function. The function returns 28, which is the maximum XOR value of two numbers in the list.\n1\ntakeuforward\n2\nleetcode\n3\nritambhara\n4\ncodingninjas\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators with precedence.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators with precedence, we can use a stack data structure to keep track of the opening symbols and pop them off the stack when we encounter a closing symbol. If the closing symbol matches the top of the stack, we continue. Otherwise, the expression is not balanced. We can also handle nested expressions by pushing the opening symbols onto the stack and popping them off when we encounter the corresponding closing symbols.\nHere's an implementation of this approach in Python:\npython\ndef is_valid_expression(s):\n    stack = []\n    for c in s:\n        if c in \"({[\":\n            stack.append(c)\n        elif c in \")}]\":\n            if not stack:\n                return False\n            elif c == \")\" and stack[-1] == \"(\":\n                stack.pop()\n            elif c == \"}\" and stack[-1] == \"{\":\n                stack.pop()\n            elif c == \"]\" and stack[-1] == \"[\":\n                stack.pop()\n            else:\n                return False\n    return not stack\nIn this implementation, the function is_valid_expression() takes a string s as input and returns True if s is a valid expression with balanced parentheses, brackets, and curly braces, and False otherwise. The function first initializes an empty stack. It then iterates over all the characters in s and pushes the opening symbols onto the stack and pops them off when we encounter the corresponding closing symbols. If the closing symbol matches the top of the stack, we continue. Otherwise, the expression is not balanced and the function returns False. If we reach the end of the string and the stack is empty, the expression is balanced and the function returns True.\nHere's an example usage of the is_valid_expression() function:\npython\ns = \"((2 + 3) * 5) / (4 - 1)\"\nprint(is_valid_expression(s))  # prints True\nIn this example, we check if the string \"((2 + 3) * 5) / (4 - 1)\" is a valid expression with balanced parentheses, brackets, and curly braces using the is_valid_expression() function. The function returns True, indicating that the expression is valid and balanced.\n1\ngeeksforgeeks\n2\ngeeksforgeeks\n3\njavatpoint\n4\nleetcode\n5\nfavtutor"
    },
    {
        "Input": "Write a Python class representing a trie (prefix tree) with support for efficient prefix search and word count.",
        "Output": "To implement a trie (prefix tree) in Python with support for efficient prefix search and word count, we can use the following steps:\nCreate a TrieNode class to represent a node in the trie. Each node should have a dictionary to store its child nodes, a boolean to indicate whether it represents the end of a word, and an integer to store the count of words that end at that node.\nCreate a Trie class to represent the trie itself. The Trie class should have a root node and provide methods to insert a word into the trie, search for a prefix in the trie, and count the number of words in the trie.\nTo insert a word into the trie, we start at the root node and iterate over the characters in the word. For each character, we check if the corresponding child node exists. If it does not exist, we create a new child node and add it to the dictionary. We then move to the child node and repeat the process for the next character. Once we reach the end of the word, we set the is_word boolean of the last node to True and increment the word_count integer of all the nodes on the path from the root to the last node.\nTo search for a prefix in the trie, we start at the root node and iterate over the characters in the prefix. For each character, we check if the corresponding child node exists. If it does not exist, we return an empty list. If it exists, we move to the child node and repeat the process for the next character. Once we reach the end of the prefix, we recursively traverse the subtree rooted at the last node and add all the words that end at the nodes to a list.\nTo count the number of words in the trie, we start at the root node and recursively traverse the subtree rooted at each child node. If a node represents the end of a word, we increment a counter. We then return the counter.\nHere's an implementation of this approach in Python:\npython\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        self.word_count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n            node.word_count += 1\n        node.is_word = True\n\n    def search_prefix(self, prefix):\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return []\n            node = node.children[c]\n        return self._get_words(node)\n\n    def count_words(self):\n        return self._count_words(self.root)\n\n    def _get_words(self, node):\n        words = []\n        if node.is_word:\n            words.append(\"\")\n        for c, child in node.children.items():\n            suffixes = self._get_words(child)\n            for suffix in suffixes:\n                words.append(c + suffix)\n        return words\n\n    def _count_words(self, node):\n        count = 0\n        if node.is_word:\n            count += 1\n        for child in node.children.values():\n            count += self._count_words(child)\n        return count\nIn this implementation, the TrieNode class represents a node in the trie and has a dictionary children to store its child nodes, a boolean is_word to indicate whether it represents the end of a word, and an integer word_count to store the count of words that end at that node. The Trie class represents the trie itself and has a root node. The Trie class provides methods to insert a word into the trie, search for a prefix in the trie, and count the number of words in the trie.\nThe insert() method takes a string word as input and inserts the word into the trie. The method first starts at the root node and iterates over the characters in the word. For each character, it checks if the corresponding child node exists. If it does not exist, it creates a new child node and adds it to the dictionary. It then moves to the child node and repeats the process for the next character. Once it reaches the end of the word, it sets the is_word boolean of the last node to True and increments the word_count integer of all the nodes on the path from the root to the last node.\nThe search_prefix() method takes a string prefix as input and returns a list of all the words in the trie that start with the prefix. The method first starts at the root node and iterates over the characters in the prefix. For each character, it checks if the corresponding child node exists. If it does not exist, it returns an empty list. If it exists, it moves to the child node and repeats the process for the next character. Once it reaches the end of the prefix, it recursively traverses the subtree rooted at the last node and adds all the words that end at the nodes to a list.\nThe count_words() method returns the number of words in the trie. The method first starts at the root node and recursively traverses the subtree rooted at each child node. If a node represents the end of a word, it increments a counter. It then returns the counter.\nHere's an example usage of the Trie class:\npython\nt = Trie()\nt.insert(\"apple\")\nt.insert(\"banana\")\nt.insert(\"cherry\")\nt.insert(\"grape\")\nt.insert(\"orange\")\nprint(t.search_prefix(\"a\"))  # prints [\"apple\"]\nprint(t.search_prefix(\"b\"))  # prints [\"banana\"]\nprint(t.search_prefix(\"c\"))  # prints [\"cherry\"]\nprint(t.search_prefix(\"g\"))  # prints [\"grape\"]\nprint(t.search_prefix(\"o\"))  # prints [\"orange\"]\nprint(t.count_words())  # prints 5\nIn this example, we create a Trie object t and insert five words into the trie. We then search for all the words that start with the prefixes \"a\", \"b\", \"c\", \"g\", and \"o\" using the search_prefix() method and print the results. We also count the number of words in the trie using the count_words() method and print the result.\n1\nalbertauyeung\n2\naleksandrhovhannisyan\n3\ngeeksforgeeks\n4\ngeeksforgeeks\n5\nstackoverflow"
    },
    {
        "Input": "\"Create a program to find the number of distinct ways to climb a staircase with a given number of steps, where you can take either 1 or 2 steps at a time.\"",
        "Output": "To find the number of distinct ways to climb a staircase with a given number of steps, where you can take either 1 or 2 steps at a time, we can use dynamic programming. We can start with the base cases of 1 step and 2 steps, which have 1 way and 2 ways to climb, respectively. We can then use the recurrence relation that the number of ways to climb n steps is equal to the sum of the number of ways to climb n-1 steps and n-2 steps. This is because we can either take 1 step from the (n-1)th step or 2 steps from the (n-2)th step to reach the nth step. We can use a list to store the number of ways to climb each step and compute the values iteratively.\nHere's an implementation of this approach in Python:\npython\ndef count_ways(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    ways = [0] * (n + 1)\n    ways[1] = 1\n    ways[2] = 2\n    for i in range(3, n + 1):\n        ways[i] = ways[i - 1] + ways[i - 2]\n    return ways[n]\nIn this implementation, the function count_ways() takes an integer n as input and returns the number of distinct ways to climb a staircase with n steps, where you can take either 1 or 2 steps at a time. The function first checks if n is equal to 1 or 2 and returns the corresponding base case values. It then initializes a list ways of length n + 1 with all values set to 0. It sets the values of ways[1] and ways[2] to 1 and 2, respectively, as these are the base cases. It then iteratively computes the values of ways[i] for i from 3 to n using the recurrence relation. Finally, it returns the value of ways[n], which is the number of distinct ways to climb the staircase with n steps.\nHere's an example usage of the count_ways() function:\npython\nn = 5\nprint(count_ways(n))  # prints 8\nIn this example, we find the number of distinct ways to climb a staircase with 5 steps using the count_ways() function. The function returns 8, indicating that there are 8 distinct ways to climb the staircase with 5 steps.\n1\nmaths\n2\nstackexchange"
    },
    {
        "Input": "Implement a function to check if a given number is a power of another number using logarithmic time complexity.",
        "Output": "To check if a given number is a power of another number using logarithmic time complexity, we can use the logarithmic property that if a number y is a power of x, then the logarithm of y to the base x is an integer. We can use this property to find the logarithm of the given number to the base of the potential base number and check if it is an integer. We can iterate over all the potential base numbers from 2 to the square root of the given number and check if the logarithm is an integer.\nHere's an implementation of this approach in Python:\npython\nimport math\n\ndef is_power_of(num, base):\n    if num == 1:\n        return True\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if math.log(num, i).is_integer():\n            return True\n    return False\nIn this implementation, the function is_power_of() takes two integers num and base as input and returns True if num is a power of base, and False otherwise. The function first checks if num is equal to 1 and returns True, as 1 is a power of any base. It then iterates over all the potential base numbers from 2 to the square root of num and checks if the logarithm of num to the base of the potential base number is an integer using the is_integer() method of the float class. If it is an integer, the function returns True. If none of the potential base numbers result in an integer logarithm, the function returns False.\nHere's an example usage of the is_power_of() function:\npython\nnum = 64\nbase = 2\nprint(is_power_of(num, base))  # prints True\nIn this example, we check if the number 64 is a power of 2 using the is_power_of() function. The function returns True, indicating that 64 is a power of 2.\n1\ncodingninjas\n2\ngeeksforgeeks\n3\ntowardsdatascience\n4\nmathoverflow\n5\nritambhara"
    },
    {
        "Input": "Write a program to find the maximum area of a rectangle formed by histograms in a given list of heights.",
        "Output": "To find the maximum area of a rectangle formed by histograms in a given list of heights, we can use the approach of finding the largest rectangle in a histogram. We can treat each height in the list as a bar in a histogram, and find the largest rectangle that can be formed using the bars. The largest rectangle will have a height equal to the height of the shortest bar and a width equal to the distance between the leftmost and rightmost bars that are shorter than the shortest bar. We can use a stack to keep track of the indices of the bars in the histogram and compute the area of the largest rectangle for each bar.\nHere's an implementation of this approach in Python:\npython\ndef max_rectangle_area(heights):\n    stack = []\n    max_area = 0\n    i = 0\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i - stack[-1] - 1 if stack else i)\n        max_area = max(max_area, area)\n    return max_area\nIn this implementation, the function max_rectangle_area() takes a list of integers heights as input and returns the maximum area of a rectangle formed by histograms in the list. The function first initializes an empty stack and a variable max_area to 0. It then iterates over the bars in the histogram and pushes the index of each bar onto the stack if it is taller than the previous bar. If it is shorter, the function pops the top index from the stack and computes the area of the largest rectangle that can be formed using the bar at the popped index as the shortest bar. The width of the rectangle is equal to the distance between the current index and the index at the top of the stack, or the current index if the stack is empty. The function updates the max_area variable with the maximum area computed so far. Once it has processed all the bars in the histogram, the function pops the remaining indices from the stack and computes the area of the largest rectangle that can be formed using each index as the shortest bar. The function returns the maximum area computed.\nHere's an example usage of the max_rectangle_area() function:\npython\nheights = [2, 1, 5, 6, 2, 3]\nprint(max_rectangle_area(heights))  # prints 10\nIn this example, we find the maximum area of a rectangle formed by histograms in the list\n2\n1\n5\n6\n2\n3\nusing the max_rectangle_area() function. The function returns 10, indicating that the largest rectangle that can be formed has an area of 10.\n1\nafteracademy\n2\nleetcode\n3\ninterviewbit\n4\ntakeuforward\n5\njavatpoint"
    },
    {
        "Input": "Create a Python class representing a graph and implement methods to find the shortest path between two vertices using Dijkstra's algorithm.",
        "Output": "To create a Python class representing a graph and implement methods to find the shortest path between two vertices using Dijkstra's algorithm, we can use the following steps:\nCreate a Graph class to represent the graph. The Graph class should have a dictionary to store the vertices and their edges, and provide methods to add vertices and edges to the graph.\nImplement Dijkstra's algorithm to find the shortest path between two vertices. Dijkstra's algorithm works by maintaining a set of unvisited vertices and their tentative distances from the start vertex. We can use a priority queue to efficiently select the vertex with the smallest tentative distance and update the tentative distances of its neighbors. We can also keep track of the previous vertex that leads to each vertex in the shortest path.\nImplement a method to return the shortest path between two vertices using the previous vertex information computed by Dijkstra's algorithm.\nHere's an implementation of this approach in Python:\npython\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n\n    def add_vertex(self, vertex):\n        self.vertices[vertex] = {}\n\n    def add_edge(self, vertex1, vertex2, weight):\n        self.vertices[vertex1][vertex2] = weight\n        self.vertices[vertex2][vertex1] = weight\n\n    def dijkstra(self, start_vertex):\n        distances = {vertex: float('inf') for vertex in self.vertices}\n        distances[start_vertex] = 0\n        previous_vertices = {vertex: None for vertex in self.vertices}\n        visited = set()\n        heap = [(0, start_vertex)]\n        while heap:\n            current_distance, current_vertex = heapq.heappop(heap)\n            if current_distance > distances[current_vertex]:\n                continue\n            visited.add(current_vertex)\n            for neighbor, weight in self.vertices[current_vertex].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(heap, (distance, neighbor))\n        return previous_vertices, distances\n\n    def shortest_path(self, start_vertex, end_vertex):\n        previous_vertices, distances = self.dijkstra(start_vertex)\n        path = []\n        current_vertex = end_vertex\n        while current_vertex != start_vertex:\n            path.insert(0, current_vertex)\n            current_vertex = previous_vertices[current_vertex]\n        path.insert(0, start_vertex)\n        return path, distances[end_vertex]\nIn this implementation, the Graph class represents the graph and has a dictionary vertices to store the vertices and their edges. The Graph class provides methods to add vertices and edges to the graph. The dijkstra() method implements Dijkstra's algorithm to find the shortest path between two vertices. The method takes a start vertex as input and returns two dictionaries: previous_vertices and distances. previous_vertices stores the previous vertex that leads to each vertex in the shortest path, and distances stores the tentative distances of all the vertices from the start vertex. The shortest_path() method takes a start vertex and an end vertex as input and returns a tuple (path, distance) where path is the shortest path between the start and end vertices and distance is the distance of the shortest path.\nHere's an example usage of the Graph class:\npython\ng = Graph()\ng.add_vertex('A')\ng.add_vertex('B')\ng.add_vertex('C')\ng.add_vertex('D')\ng.add_vertex('E')\ng.add_edge('A', 'B', 4)\ng.add_edge('A', 'C', 2)\ng.add_edge('B', 'C', 1)\ng.add_edge('B', 'D', 5)\ng.add_edge('C', 'D', 8)\ng.add_edge('C', 'E', 10)\ng.add_edge('D', 'E', 2)\npath, distance = g.shortest_path('A', 'E')\nprint(path)  # prints ['A', 'B', 'C', 'D', 'E']\nprint(distance)  # prints 11\nIn this example, we create a Graph object g and add five vertices and seven edges to the graph. We then find the shortest path between the vertices 'A' and 'E' using the shortest_path() method and print the result. The method returns the path ['A', 'B', 'C', 'D', 'E'] and the distance 11, indicating that the shortest path between 'A' and 'E' has a distance of 11.\n1\nstackabuse\n2\nudacity\n3\nbuiltin\n4\npieriantraining\n5\ngitconnected"
    },
    {
        "Input": "Implement a function to find the longest increasing subsequence in a given list of integers using dynamic programming.",
        "Output": "To find the longest increasing subsequence in a given list of integers using dynamic programming, we can use the approach of maintaining an array dp of the longest increasing subsequence ending at each index of the list. We can initialize the array with all values set to 1, as the longest increasing subsequence ending at each index is at least 1 (the element itself). We can then iterate over the list and for each element, we can iterate over all the previous elements and update the dp array with the maximum length of the increasing subsequence that can be formed by appending the current element to the subsequence ending at the previous element. Once we have computed the dp array, we can find the maximum value in the array to get the length of the longest increasing subsequence. We can then use the dp array to reconstruct the subsequence itself.\nHere's an implementation of this approach in Python:\npython\ndef longest_increasing_subsequence(nums):\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    subsequence = []\n    for i in range(n - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(nums[i])\n            max_length -= 1\n    subsequence.reverse()\n    return subsequence\nIn this implementation, the function longest_increasing_subsequence() takes a list of integers nums as input and returns the longest increasing subsequence in the list. The function first initializes an array dp of length n with all values set to 1, where n is the length of the list. It then iterates over the list and for each element, it iterates over all the previous elements and updates the dp array with the maximum length of the increasing subsequence that can be formed by appending the current element to the subsequence ending at the previous element. Once it has computed the dp array, the function finds the maximum value in the array to get the length of the longest increasing subsequence. It then uses the dp array to reconstruct the subsequence itself by iterating over the array from right to left and adding the elements to the subsequence in reverse order. The function returns the subsequence.\nHere's an example usage of the longest_increasing_subsequence() function:\npython\nnums = [3, 4, -1, 0, 6, 2, 3]\nprint(longest_increasing_subsequence(nums))  # prints [-1, 0, 2, 3]\nIn this example, we find the longest increasing subsequence in the list [3, 4, -1, 0, 6, 2, 3] using the longest_increasing_subsequence() function. The function returns [-1, 0, 2, 3], indicating that the longest increasing subsequence in the list is [-1, 0, 2, 3].\n1\nduke\n2\nbaeldung\n3\ntechiedelight\n4\nyoutube\n5\ncp-algorithms"
    },
    {
        "Input": "Write a program to find the number of unique BSTs (binary search trees) that can be formed with a given number of nodes.",
        "Output": "To find the number of unique BSTs (binary search trees) that can be formed with a given number of nodes, we can use dynamic programming. We can define a recursive formula to compute the number of unique BSTs for a given number of nodes. Let dp[i] be the number of unique BSTs that can be formed with i nodes. We can then compute dp[i] as the sum of the products of dp[j] and dp[i-j-1] for all j from 0 to i-1. This is because we can choose any node as the root, and the number of unique BSTs that can be formed with i nodes is equal to the sum of the products of the number of unique BSTs that can be formed with the nodes to the left and right of the root. We can use a list to store the dp values and compute the values iteratively.\nHere's an implementation of this approach in Python:\npython\ndef count_unique_bsts(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\nIn this implementation, the function count_unique_bsts() takes an integer n as input and returns the number of unique BSTs that can be formed with n nodes. The function first initializes a list dp of length n + 1 with all values set to 0. It sets the values of dp and dp[1] to 1, as there is only one unique BST that can be formed with 0 or 1 nodes. It then iteratively computes the values of dp[i] for i from 2 to n using the recursive formula. Finally, it returns the value of dp[n], which is the number of unique BSTs that can be formed with n nodes.\nHere's an example usage of the count_unique_bsts() function:\npython\nn = 3\nprint(count_unique_bsts(n))  # prints 5\nIn this example, we find the number of unique BSTs that can be formed with 3 nodes using the count_unique_bsts() function. The function returns 5, indicating that there are 5 unique BSTs that can be formed with 3 nodes.\n1\nleetcode"
    },
    {
        "Input": "Create a program to find the largest rectangular area of 1s in a binary matrix using stack-based approach.",
        "Output": "To find the largest rectangular area of 1s in a binary matrix using a stack-based approach, we can use the following steps:\nCreate a list heights of length n with all values set to 0, where n is the number of columns in the matrix.\nIterate over each row of the matrix and for each column, update the corresponding value in the heights list to be the height of the largest rectangle of 1s that can be formed with the current row as the base. We can use dynamic programming to compute the height of the largest rectangle of 1s for each column. The height of the rectangle for each column is equal to the number of consecutive 1s in the column starting from the current row and going up.\nFor each row, compute the largest rectangular area of 1s that can be formed with the row as the top row using the heights list. We can use a stack to keep track of the indices of the columns in the current row that have not been processed yet. We can push the index of the first column onto the stack and iterate over the remaining columns. For each column, we pop the top index from the stack and compute the area of the largest rectangle that can be formed using the column at the popped index as the right boundary and the current column as the left boundary. The height of the rectangle is equal to the value in the heights list at the popped index, and the width is equal to the distance between the current index and the index at the top of the stack, or the current index if the stack is empty. We update the maximum area seen so far and continue iterating over the remaining columns. If the stack is empty, we push the current index onto the stack and continue iterating over the remaining columns.\nReturn the maximum area seen so far.\nHere's an implementation of this approach in Python:\npython\ndef max_rectangle_area(matrix):\n    if not matrix:\n        return 0\n    n = len(matrix[0])\n    heights = [0] * n\n    max_area = 0\n    for row in matrix:\n        for i in range(n):\n            heights[i] = heights[i] + 1 if row[i] == 1 else 0\n        stack = []\n        i = 0\n        while i < n:\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1 if stack else i)\n                max_area = max(max_area, area)\n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n    return max_area\nIn this implementation, the function max_rectangle_area() takes a binary matrix as input and returns the largest rectangular area of 1s in the matrix. The function first checks if the matrix is empty and returns 0 if it is. It then initializes a list heights of length n with all values set to 0, where n is the number of columns in the matrix. It iterates over each row of the matrix and for each column, it updates the corresponding value in the heights list to be the height of the largest rectangle of 1s that can be formed with the current row as the base using dynamic programming. It then iterates over each row of the matrix again and for each row, it computes the largest rectangular area of 1s that can be formed with the row as the top row using a stack-based approach. It initializes an empty stack and a variable max_area to 0. It then iterates over the columns of the row and for each column, it pops the top index from the stack and computes the area of the largest rectangle that can be formed using the column at the popped index as the right boundary and the current column as the left boundary. If the stack is empty, it pushes the current index onto the stack and continues iterating over the remaining columns. The function updates the max_area variable with the maximum area computed so far. Once it has processed all the columns in the row, it pops the remaining indices from the stack and computes the area of the largest rectangle that can be formed using each index as the right boundary. The function returns the maximum area computed.\nHere's an example usage of the max_rectangle_area() function:\npython\nmatrix = [[1, 0, 1, 0, 0],\n          [1, 0, 1, 1, 1],\n          [1, 1, 1, 1, 1],\n          [1, 0, 0, 1, 0]]\nprint(max_rectangle_area(matrix))  # prints 6\nIn this example, we find the largest rectangular area of 1s in the binary matrix using the max_rectangle_area() function. The function returns 6, indicating that the largest rectangular area of 1s in the matrix is 6.\n1\nprepbytes\n2\ntechiedelight\n3\ncodingninjas\n4\nleetcode\n5\ngeeksforgeeks"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and operators with precedence.\"",
        "Output": "To implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and operators with precedence, we can use a stack-based approach. We can use a stack to keep track of the opening symbols encountered in the string and pop them from the stack when we encounter the corresponding closing symbols. We can also use a dictionary to map the opening symbols to their corresponding closing symbols. We can iterate over the string and for each character, we can check if it is an opening symbol. If it is, we push it onto the stack. If it is a closing symbol, we check if the stack is empty or if the top of the stack contains the corresponding opening symbol. If it does, we pop the opening symbol from the stack and continue iterating over the string. If it doesn't, we return False, indicating that the expression is not balanced. Once we have processed all the characters in the string, we check if the stack is empty. If it is, we return True, indicating that the expression is balanced. Otherwise, we return False.\nHere's an implementation of this approach in Python:\npython\ndef is_valid_expression(expression):\n    stack = []\n    opening_symbols = {'(': ')', '[': ']', '{': '}', '<': '>', '\"': '\"', \"'\": \"'\", '/': '/'}\n    closing_symbols = set(opening_symbols.values())\n    for char in expression:\n        if char in opening_symbols:\n            stack.append(char)\n        elif char in closing_symbols:\n            if not stack:\n                return False\n            opening_symbol = stack.pop()\n            if opening_symbols[opening_symbol] != char:\n                return False\n    return not stack\nIn this implementation, the function is_valid_expression() takes a string expression as input and returns True if the expression is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and operators with precedence, and False otherwise. The function first initializes an empty stack and a dictionary opening_symbols that maps the opening symbols to their corresponding closing symbols. It also initializes a set closing_symbols with all the closing symbols. It then iterates over the characters in the string and for each character, it checks if it is an opening symbol. If it is, it pushes it onto the stack. If it is a closing symbol, it checks if the stack is empty or if the top of the stack contains the corresponding opening symbol. If it does, it pops the opening symbol from the stack and continues iterating over the string. If it doesn't, it returns False, indicating that the expression is not balanced. Once it has processed all the characters in the string, the function checks if the stack is empty. If it is, it returns True, indicating that the expression is balanced. Otherwise, it returns False.\nHere's an example usage of the is_valid_expression() function:\npython\nexpression = '[(a + b) * c - d] / e'\nprint(is_valid_expression(expression))  # prints True\nIn this example, we check if the expression [(a + b) * c - d] / e is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and operators with precedence, using the is_valid_expression() function. The function returns True, indicating that the expression is valid and balanced.\n1\ncodesdope\n2\nenjoyalgorithms\n3\ngeeksforgeeks\n4\nafteracademy\n5\ncodingninjas"
    },
    {
        "Input": "Write a Python class representing a Bloom filter with support for efficient insertion and membership check.",
        "Output": "To create a Python class representing a Bloom filter with support for efficient insertion and membership check, we can use the following steps:\nInitialize the Bloom filter with a bit array of length m and k hash functions.\nImplement the add() method to insert an element into the Bloom filter. The method should compute the k hash values for the element and set the corresponding bits in the bit array to 1.\nImplement the contains() method to check if an element is in the Bloom filter. The method should compute the k hash values for the element and check if the corresponding bits in the bit array are all set to 1. If all the bits are set to 1, the method returns True, indicating that the element is probably in the Bloom filter. If any of the bits are not set to 1, the method returns False, indicating that the element is definitely not in the Bloom filter.\nHere's an implementation of this approach in Python:\npython\nimport mmh3\n\nclass BloomFilter:\n    def __init__(self, m, k):\n        self.m = m\n        self.k = k\n        self.bit_array = [False] * m\n\n    def add(self, element):\n        for i in range(self.k):\n            hash_value = mmh3.hash(element, i) % self.m\n            self.bit_array[hash_value] = True\n\n    def contains(self, element):\n        for i in range(self.k):\n            hash_value = mmh3.hash(element, i) % self.m\n            if not self.bit_array[hash_value]:\n                return False\n        return True\nIn this implementation, the BloomFilter class represents the Bloom filter and has three methods: __init__(), add(), and contains(). The __init__() method initializes the Bloom filter with a bit array of length m and k hash functions. The add() method takes an element as input and computes the k hash values for the element using the MurmurHash3 hash function. It then sets the corresponding bits in the bit array to True. The contains() method takes an element as input and computes the k hash values for the element using the MurmurHash3 hash function. It then checks if the corresponding bits in the bit array are all set to True. If all the bits are set to True, the method returns True, indicating that the element is probably in the Bloom filter. If any of the bits are not set to True, the method returns False, indicating that the element is definitely not in the Bloom filter.\nHere's an example usage of the BloomFilter class:\npython\nbf = BloomFilter(100, 3)\nbf.add('apple')\nbf.add('banana')\nbf.add('cherry')\nprint(bf.contains('apple'))  # prints True\nprint(bf.contains('banana'))  # prints True\nprint(bf.contains('cherry'))  # prints True\nprint(bf.contains('orange'))  # prints False\nIn this example, we create a BloomFilter object bf with a bit array of length 100 and 3 hash functions. We then add three elements 'apple', 'banana', and 'cherry' to the Bloom filter using the add() method. Finally, we check if the elements 'apple', 'banana', 'cherry', and 'orange' are in the Bloom filter using the contains() method. The method returns True for 'apple', 'banana', and 'cherry', indicating that these elements are probably in the Bloom filter, and False for 'orange', indicating that this element is definitely not in the Bloom filter.\n1\ngeeksforgeeks\n2\nkdnuggets\n3\nmu\n4\nenjoyalgorithms\n5\npython"
    },
    {
        "Input": "Create a program to find the number of distinct subsequences in a given string using dynamic programming.",
        "Output": "To find the number of distinct subsequences in a given string using dynamic programming, we can use the following approach:\nInitialize a list dp of length n+1 with all values set to 0, where n is the length of the string.\nSet dp to 1, as there is only one subsequence of an empty string.\nIterate over the string and for each character, iterate over the previous characters in the string. If the current character is equal to the previous character, the number of distinct subsequences that end with the current character is equal to the number of distinct subsequences that end with the previous character. If the current character is not equal to the previous character, the number of distinct subsequences that end with the current character is equal to the sum of the number of distinct subsequences that end with the previous character and the number of distinct subsequences that end with the previous character but do not include the current character. We can use the dp array to keep track of the number of distinct subsequences that end with each character.\nReturn the value of dp[n], which is the number of distinct subsequences in the string.\nHere's an implementation of this approach in Python:\npython\ndef count_distinct_subsequences(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last_seen = {}\n    for i in range(1, n + 1):\n        dp[i] = 2 * dp[i - 1]\n        if s[i - 1] in last_seen:\n            dp[i] -= dp[last_seen[s[i - 1]] - 1]\n        last_seen[s[i - 1]] = i\n    return dp[n] - 1\nIn this implementation, the function count_distinct_subsequences() takes a string s as input and returns the number of distinct subsequences in the string. The function first initializes a list dp of length n+1 with all values set to 0, where n is the length of the string. It sets dp to 1, as there is only one subsequence of an empty string. It then iterates over the string and for each character, it iterates over the previous characters in the string. If the current character is equal to the previous character, the number of distinct subsequences that end with the current character is equal to the number of distinct subsequences that end with the previous character. If the current character is not equal to the previous character, the number of distinct subsequences that end with the current character is equal to the sum of the number of distinct subsequences that end with the previous character and the number of distinct subsequences that end with the previous character but do not include the current character. The function uses the dp array to keep track of the number of distinct subsequences that end with each character. Finally, the function returns the value of dp[n] minus 1, which is the number of distinct subsequences in the string.\nHere's an example usage of the count_distinct_subsequences() function:\npython\ns = 'abab'\nprint(count_distinct_subsequences(s))  # prints 7\nIn this example, we find the number of distinct subsequences in the string 'abab' using the count_distinct_subsequences() function. The function returns 7, indicating that there are 7 distinct subsequences in the string.\n1\ntakeuforward\n2\nyoutube\n3\nyoutube\n4\nyoutube\n5\nduke"
    },
    {
        "Input": "Implement a function to check if a given number is a prime number using the Sieve of Eratosthenes algorithm.",
        "Output": "To implement a function to check if a given number is a prime number using the Sieve of Eratosthenes algorithm, we can use the following steps:\nCreate a list is_prime of length n+1 filled with all True values, where n is the given number.\nSet the first two elements of the list to False, as 0 and 1 are not prime numbers.\nIterate over the numbers from 2 to the square root of n. For each number, if it is a prime number (i.e., is_prime[i] is True), mark all its multiples as non-prime numbers by setting the corresponding elements in the is_prime list to False.\nCheck if the given number is a prime number by checking if the corresponding element in the is_prime list is True.\nHere's an implementation of this approach in Python:\npython\nimport math\n\ndef is_prime(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return is_prime[n]\nIn this implementation, the function is_prime() takes a number n as input and returns True if the number is a prime number and False otherwise. The function first initializes a list is_prime of length n+1 filled with all True values. It then sets the first two elements of the list to False, as 0 and 1 are not prime numbers. It then iterates over the numbers from 2 to the square root of n. For each number, if it is a prime number (i.e., is_prime[i] is True), it marks all its multiples as non-prime numbers by setting the corresponding elements in the is_prime list to False. Finally, the function checks if the given number is a prime number by checking if the corresponding element in the is_prime list is True.\nHere's an example usage of the is_prime() function:\npython\nn = 17\nprint(is_prime(n))  # prints True\nIn this example, we check if the number 17 is a prime number using the is_prime() function. The function returns True, indicating that 17 is a prime number.\n1\nw3resource\n2\nplainenglish\n3\nstackoverflow\n4\ntopcoder\n5\ncp-algorithms"
    },
    {
        "Input": "\"Write a program to find the minimum number of jumps required to reach the end of a given list of integers, where each integer represents the maximum number of steps that can be jumped from that position.\"",
        "Output": "To find the minimum number of jumps required to reach the end of a given list of integers, where each integer represents the maximum number of steps that can be jumped from that position, we can use dynamic programming. Here's an approach:\nInitialize a list dp of length n with all values set to infinity, where n is the length of the list.\nSet the first element of the dp list to 0, as we don't need to jump to reach the first element.\nIterate over the list and for each element, iterate over the previous elements in the list. For each previous element, check if it is reachable from the current element. If it is, update the value in the dp list for the previous element to be the minimum of its current value and the value of the current element in the dp list plus 1.\nReturn the value in the dp list for the last element, which represents the minimum number of jumps required to reach the end of the list.\nHere's an implementation of this approach in Python:\npython\ndef min_jumps(nums):\n    n = len(nums)\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return dp[n - 1]\nIn this implementation, the function min_jumps() takes a list of integers nums as input and returns the minimum number of jumps required to reach the end of the list. The function first initializes a list dp of length n with all values set to infinity, where n is the length of the list. It then sets the first element of the dp list to 0, as we don't need to jump to reach the first element. It then iterates over the list and for each element, it iterates over the previous elements in the list. For each previous element, it checks if it is reachable from the current element. If it is, it updates the value in the dp list for the previous element to be the minimum of its current value and the value of the current element in the dp list plus 1. Finally, the function returns the value in the dp list for the last element, which represents the minimum number of jumps required to reach the end of the list.\nHere's an example usage of the min_jumps() function:\npython\nnums = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]\nprint(min_jumps(nums))  # prints 3\nIn this example, we find the minimum number of jumps required to reach the end of the list [1][3][5][8][9][2][6][7][6][8][9] using the min_jumps() function. The function returns 3, indicating that we need to make 3 jumps to reach the end of the list.\n1\ntutorialspoint\n2\ninterviewbit\n3\nscaler\n4\ngeeksforgeeks\n5\nenjoyalgorithms"
    },
    {
        "Input": "Create a Python class representing a suffix tree with support for efficient substring search and longest common prefix.",
        "Output": "To create a Python class representing a suffix tree with support for efficient substring search and longest common prefix, we can use the following steps:\nImplement the Ukkonen's algorithm to build the suffix tree. This algorithm builds the suffix tree in linear time and space complexity.\nImplement the search() method to search for a substring in the suffix tree. The method should start at the root of the tree and follow the edges corresponding to the characters in the substring. If the substring is found, the method should return True. Otherwise, it should return False.\nImplement the longest_common_prefix() method to find the longest common prefix of a set of strings represented by the suffix tree. The method should start at the root of the tree and follow the edges that are common to all the strings. The method should return the longest common prefix found.\nHere's an implementation of this approach in Python:\npython\nclass SuffixTree:\n    class Node:\n        def __init__(self, start, end):\n            self.start = start\n            self.end = end\n            self.children = {}\n\n    def __init__(self, string):\n        self.string = string\n        self.root = self.Node(-1, -1)\n        self.root.suffix_link = self.root\n        self.active_node = self.root\n        self.active_edge = -1\n        self.active_length = 0\n        self.remaining_suffix_count = 0\n        self.last_new_node = None\n        self.build()\n\n    def build(self):\n        self.remaining_suffix_count = 0\n        self.last_new_node = None\n        self.active_edge = -1\n        self.active_length = 0\n        for i in range(len(self.string)):\n            self.add_suffix(i)\n        self.set_suffix_links(self.root)\n\n    def add_suffix(self, end):\n        self.remaining_suffix_count += 1\n        self.last_new_node = None\n        while self.remaining_suffix_count > 0:\n            if self.active_length == 0:\n                self.active_edge = end\n            if self.active_edge not in self.active_node.children:\n                leaf = self.Node(end, len(self.string))\n                self.active_node.children[self.active_edge] = leaf\n                self.add_suffix_link(self.active_node)\n                self.last_new_node = None\n            else:\n                next_node = self.active_node.children[self.active_edge]\n                if self.walk_down(next_node):\n                    continue\n                if self.string[next_node.start + self.active_length] == self.string[end]:\n                    if self.last_new_node is not None and self.active_node != self.root:\n                        self.last_new_node.suffix_link = self.active_node\n                        self.last_new_node = None\n                    self.active_length += 1\n                    self.add_suffix_link(self.active_node)\n                    break\n                split_end = next_node.start + self.active_length - 1\n                split_node = self.Node(next_node.start, split_end)\n                self.active_node.children[self.active_edge] = split_node\n                leaf = self.Node(end, len(self.string))\n                split_node.children[self.string[end]] = leaf\n                next_node.start += self.active_length\n                split_node.children[self.string[next_node.start]] = next_node\n                self.add_suffix_link(split_node)\n                if self.last_new_node is not None:\n                    self.last_new_node.suffix_link = split_node\n                self.last_new_node = split_node\n            self.remaining_suffix_count -= 1\n            if self.active_node == self.root and self.active_length > 0:\n                self.active_length -= 1\n                self.active_edge = end - self.remaining_suffix_count + 1\n            else:\n                self.active_node = self.active_node.suffix_link\n\n    def walk_down(self, node):\n        if self.active_length >= node.end - node.start:\n            self.active_edge += node.end - node.start\n            self.active_length -= node.end - node.start\n            self.active_node = node\n            return True\n        return False\n\n    def add_suffix_link(self, node):\n        if self.last_new_node is not None:\n            self.last_new_node.suffix_link = node\n        self.last_new_node = node\n\n    def set_suffix_links(self, node):\n        if node == self.root:\n            node.suffix_link = self.root\n        else:\n            node.suffix_link = self.get_suffix_link(node)\n        for child in node.children.values():\n            self.set_suffix_links(child)\n\n    def get_suffix_link(self, node):\n        if node.suffix_link is not None:\n            return node.suffix_link\n        if node == self.root:\n            return self.root\n        parent_suffix_link = self.get_suffix_link(node.parent)\n        edge_char = self.string[node.start]\n        child = parent_suffix_link.children[edge_char]\n        return child\n\n    def search(self, substring):\n        node = self.root\n        for char in substring:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\n    def longest_common_prefix(self):\n        node = self.root\n        prefix = ''\n        while len(node.children) == 1:\n            char, child = node.children.items()[0]\n            prefix += char\n            node = child\n        return prefix\nIn this implementation, the SuffixTree class represents the suffix tree and has several methods: __init__(), build(), add_suffix(), walk_down(), add_suffix_link(), set_suffix_links(), get_suffix_link(), search(), and longest_common_prefix(). The __init__() method initializes the suffix tree with a string and sets the root of the tree. The build() method builds the suffix tree using the Ukkonen's algorithm. The add_suffix() method adds a suffix to the tree. The walk_down() method walks down the tree to find the next node. The add_suffix_link() method adds a suffix link to the tree. The set_suffix_links() method sets the suffix links for all the nodes in the tree. The get_suffix_link() method gets the suffix link for a node. The search() method searches for a substring in the tree. The longest_common_prefix() method finds the longest common prefix of a set of strings represented by the suffix tree.\nHere's an example usage of the SuffixTree class:\npython\nstring = 'banana'\nsuffix_tree = SuffixTree(string)\nprint(suffix_tree.search('ana'))  # prints True\nprint(suffix_tree.longest_common_prefix())  # prints 'an'\nIn this example, we create a SuffixTree object suffix_tree with the string 'banana'. We then search for the substring 'ana' in the tree using the search() method. The method returns True, indicating that the substring is in the tree. Finally, we find the longest common prefix of the set of strings represented by the suffix tree using the longest_common_prefix() method. The method returns 'an', indicating that 'an' is the longest common prefix of the set of strings represented by the suffix tree.\n1\ngithub\n2\nfavtutor\n3\ngeeksforgeeks\n4\ncodingninjas\n5\ntutorialspoint"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators.\"",
        "Output": "To implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators, we can use a stack-based approach. We can use a stack to keep track of the opening symbols encountered in the string and pop them from the stack when we encounter the corresponding closing symbols. We can also use a dictionary to map the opening symbols to their corresponding closing symbols. We can iterate over the string and for each character, we can check if it is an opening symbol. If it is, we push it onto the stack. If it is a closing symbol, we check if the stack is empty or if the top of the stack contains the corresponding opening symbol. If it does, we pop the opening symbol from the stack and continue iterating over the string. If it doesn't, we return False, indicating that the expression is not balanced. Once we have processed all the characters in the string, we check if the stack is empty. If it is, we return True, indicating that the expression is balanced. Otherwise, we return False.\nHere's an implementation of this approach in Python:\npython\ndef is_valid_expression(expression):\n    stack = []\n    opening_symbols = {'(': ')', '[': ']', '{': '}', '<': '>', '\"': '\"', \"'\": \"'\", '/': '/'}\n    closing_symbols = set(opening_symbols.values())\n    for char in expression:\n        if char in opening_symbols:\n            stack.append(char)\n        elif char in closing_symbols:\n            if not stack:\n                return False\n            opening_symbol = stack.pop()\n            if opening_symbols[opening_symbol] != char:\n                return False\n    return not stack\nIn this implementation, the function is_valid_expression() takes a string expression as input and returns True if the expression is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators, and False otherwise. The function first initializes a stack to keep track of the opening symbols encountered in the string. It then initializes a dictionary opening_symbols to map the opening symbols to their corresponding closing symbols. It also initializes a set closing_symbols to keep track of the closing symbols encountered in the string. It then iterates over the string and for each character, it checks if it is an opening symbol. If it is, it pushes it onto the stack. If it is a closing symbol, it checks if the stack is empty or if the top of the stack contains the corresponding opening symbol. If it does, it pops the opening symbol from the stack and continues iterating over the string. If it doesn't, it returns False, indicating that the expression is not balanced. Finally, after processing all the characters in the string, if the stack is empty, then the expression is balanced; otherwise, it is not.\nHere's an example usage of the is_valid_expression() function:\npython\nexpression = 'if (a == b) { c = d; }'\nprint(is_valid_expression(expression))  # prints True\nIn this example, we check if the expression 'if (a == b) { c = d; }' is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators using the is_valid_expression() function. The function returns True, indicating that the expression is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators.\n1\nstackoverflow\n2\ngeeksforgeeks\n3\nenjoyalgorithms\n4\nafteracademy\n5\ncodingninjas"
    },
    {
        "Input": "Write a program to find the maximum sum subarray in a given circular array using Kadane's algorithm.",
        "Output": "To find the maximum sum subarray in a given circular array using Kadane's algorithm, we can use the following steps:\nFind the maximum sum subarray using Kadane's algorithm. This will give us the maximum sum subarray that does not wrap around the end of the array.\nFind the minimum sum subarray using Kadane's algorithm. This will give us the minimum sum subarray that does not wrap around the end of the array.\nCompute the total sum of the array.\nCompute the maximum sum subarray that wraps around the end of the array by subtracting the minimum sum subarray from the total sum of the array.\nReturn the maximum of the maximum sum subarray that does not wrap around the end of the array and the maximum sum subarray that wraps around the end of the array.\nHere's an implementation of this approach in Python:\npython\ndef max_sum_circular_subarray(nums):\n    def kadane(arr):\n        max_so_far = 0\n        max_ending_here = 0\n        for i in range(len(arr)):\n            max_ending_here += arr[i]\n            if max_ending_here < 0:\n                max_ending_here = 0\n            if max_so_far < max_ending_here:\n                max_so_far = max_ending_here\n        return max_so_far\n\n    max_sum = kadane(nums)\n    min_sum = kadane([-num for num in nums])\n    total_sum = sum(nums)\n    max_wrap_sum = total_sum + min_sum\n    if max_wrap_sum == 0:\n        return max_sum\n    return max(max_sum, max_wrap_sum)\nIn this implementation, the function max_sum_circular_subarray() takes a list of integers nums as input and returns the maximum sum subarray in the circular array. The function first defines a helper function kadane() that implements Kadane's algorithm to find the maximum sum subarray of a given array. It then uses Kadane's algorithm to find the maximum sum subarray that does not wrap around the end of the array and the minimum sum subarray that does not wrap around the end of the array. It then computes the total sum of the array and the maximum sum subarray that wraps around the end of the array. Finally, the function returns the maximum of the maximum sum subarray that does not wrap around the end of the array and the maximum sum subarray that wraps around the end of the array.\nHere's an example usage of the max_sum_circular_subarray() function:\npython\nnums = [1, -2, 3, -2]\nprint(max_sum_circular_subarray(nums))  # prints 3\nIn this example, we find the maximum sum subarray in the circular array [1, -2, 3, -2] using the max_sum_circular_subarray() function. The function returns 3, indicating that the maximum sum subarray in the circular array is [1].\n1\nMaximum Sum Circular Subarray - Kadane's Algorithm - Dynamic Programming - Python\nyoutube.com"
    },
    {
        "Input": "\"Create a program to find the number of distinct ways to decode a given string of digits into alphabets, where A=1, B=2, etc.\"",
        "Output": "To find the number of distinct ways to decode a given string of digits into alphabets, where A=1, B=2, etc., we can use dynamic programming. We can use a list dp of length n+1 to keep track of the number of ways to decode the string up to the i-th character, where n is the length of the string. We can initialize dp to 1, as there is only one way to decode an empty string. We can then iterate over the string and for each character, we can check if it can be decoded as a single digit or as a two-digit number. If it can be decoded as a single digit, we can add the number of ways to decode the string up to the i-1-th character to the number of ways to decode the string up to the i-th character. If it can be decoded as a two-digit number, we can add the number of ways to decode the string up to the i-2-th character to the number of ways to decode the string up to the i-th character. We can use a dictionary to map the digits to their corresponding alphabets. Finally, we can return the value of dp[n], which is the number of distinct ways to decode the string.\nHere's an implementation of this approach in Python:\npython\ndef num_decodings(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    mapping = {str(i): chr(i + 64) for i in range(1, 27)}\n    for i in range(1, n + 1):\n        if s[i - 1] in mapping:\n            dp[i] += dp[i - 1]\n        if i > 1 and s[i - 2:i] in mapping:\n            dp[i] += dp[i - 2]\n    return dp[n]\nIn this implementation, the function num_decodings() takes a string s as input and returns the number of distinct ways to decode the string. The function first initializes a list dp of length n+1 with all values set to 0, where n is the length of the string. It sets dp to 1, as there is only one way to decode an empty string. It then initializes a dictionary mapping to map the digits to their corresponding alphabets. It then iterates over the string and for each character, it checks if it can be decoded as a single digit or as a two-digit number. If it can be decoded as a single digit, it adds the number of ways to decode the string up to the i-1-th character to the number of ways to decode the string up to the i-th character. If it can be decoded as a two-digit number, it adds the number of ways to decode the string up to the i-2-th character to the number of ways to decode the string up to the i-th character. Finally, the function returns the value of dp[n], which is the number of distinct ways to decode the string.\nHere's an example usage of the num_decodings() function:\npython\ns = '226'\nprint(num_decodings(s))  # prints 3\nIn this example, we find the number of distinct ways to decode the string '226' into alphabets using the num_decodings() function. The function returns 3, indicating that there are 3 distinct ways to decode the string: 'BZ', 'VF', and 'BBF'.\n1\ngeeksforgeeks\n2\nstackoverflow\n3\ngeeksforgeeks\n4\nleetcode\n5\nleetcode"
    },
    {
        "Input": "Implement a function to find the longest common subsequence of three given strings using dynamic programming.",
        "Output": "To find the longest common subsequence of three given strings using dynamic programming, we can use the following approach:\nInitialize a 3D list dp of dimensions (m+1) x (n+1) x (o+1), where m, n, and o are the lengths of the three strings, respectively. Initialize all the values in the list to 0.\nIterate over the three strings and for each character, check if it is common to all three strings. If it is, update the value in the dp list for the current indices to be the value in the dp list for the previous indices plus 1.\nIf the character is not common to all three strings, update the value in the dp list for the current indices to be the maximum of the values in the dp list for the previous indices for each of the three strings.\nThe length of the longest common subsequence is the value in the dp list for the indices (m, n, o).\nHere's an implementation of this approach in Python:\npython\ndef lcs_of_three_strings(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    return dp[m][n][o]\nIn this implementation, the function lcs_of_three_strings() takes three strings X, Y, and Z as input and returns the length of the longest common subsequence of the three strings. The function first initializes a 3D list dp of dimensions (m+1) x (n+1) x (o+1), where m, n, and o are the lengths of the three strings, respectively. It initializes all the values in the list to 0. It then iterates over the three strings and for each character, it checks if it is common to all three strings. If it is, it updates the value in the dp list for the current indices to be the value in the dp list for the previous indices plus 1. If the character is not common to all three strings, it updates the value in the dp list for the current indices to be the maximum of the values in the dp list for the previous indices for each of the three strings. Finally, the function returns the value in the dp list for the indices (m, n, o), which is the length of the longest common subsequence.\nHere's an example usage of the lcs_of_three_strings() function:\npython\nX = 'AGGTAB'\nY = 'GXTXAYB'\nZ = 'GTAB'\nprint(lcs_of_three_strings(X, Y, Z))  # prints 2\nIn this example, we find the length of the longest common subsequence of the three strings 'AGGTAB', 'GXTXAYB', and 'GTAB' using the lcs_of_three_strings() function. The function returns 2, indicating that the longest common subsequence of the three strings is 'GT'.\n1\nstackoverflow\n2\nincludehelp\n3\ntutorialcup\n4\ngeeksforgeeks\n5\ncodingninjas"
    },
    {
        "Input": "\"Write a Python class representing a skip list and implement methods to insert, search, and remove elements efficiently.\"",
        "Output": "Here's a Python class representing a skip list and implementing methods to insert, search, and remove elements efficiently:\npython\nimport random\n\nclass SkipNode:\n    def __init__(self, height=0, elem=None):\n        self.elem = elem\n        self.next = [None] * height\n\nclass SkipList:\n    def __init__(self):\n        self.head = SkipNode()\n        self.len = 0\n        self.max_height = 0\n\n    def __len__(self):\n        return self.len\n\n    def random_height(self):\n        height = 1\n        while random.random() < 0.5 and height < len(self.head.next) + 1:\n            height += 1\n        return height\n\n    def find(self, elem, update=None):\n        if update is None:\n            update = [None] * len(self.head.next)\n        node = self.head\n        for i in reversed(range(len(node.next))):\n            while node.next[i] and node.next[i].elem < elem:\n                node = node.next[i]\n            if update:\n                update[i] = node\n        return node.next[0], update\n\n    def contains(self, elem):\n        node, _ = self.find(elem)\n        return node is not None and node.elem == elem\n\n    def insert(self, elem):\n        node, update = self.find(elem)\n        if node is None or node.elem != elem:\n            height = self.random_height()\n            if height > len(self.head.next):\n                self.head.next.extend([None] * (height - len(self.head.next)))\n            node = SkipNode(height, elem)\n            for i in range(height):\n                node.next[i] = update[i].next[i]\n                update[i].next[i] = node\n            self.len += 1\n\n    def remove(self, elem):\n        node, update = self.find(elem)\n        if node is not None and node.elem == elem:\n            for i in reversed(range(len(node.next))):\n                if update[i].next[i] != node:\n                    break\n                update[i].next[i] = node.next[i]\n            while len(self.head.next) > 1 and self.head.next[-1] is None:\n                self.head.next.pop()\n            self.len -= 1\nIn this implementation, the SkipNode class represents a node in the skip list and has two attributes: elem and next, where elem is the element stored in the node and next is a list of pointers to the next nodes. The SkipList class represents the skip list and has three attributes: head, len, and max_height, where head is a sentinel node, len is the number of elements in the list, and max_height is the maximum height of any node in the list. The class also has four methods: __len__(), random_height(), find(), contains(), insert(), and remove(). The __len__() method returns the number of elements in the list. The random_height() method generates a random height for a new node. The find() method finds the node with the given element and returns the node and a list of nodes that need to be updated. The contains() method checks if the list contains the given element. The insert() method inserts a new node with the given element into the list. The remove() method removes the node with the given element from the list.\nHere's an example usage of the SkipList class:\npython\nsl = SkipList()\nsl.insert(1)\nsl.insert(2)\nsl.insert(3)\nprint(len(sl))  # prints 3\nprint(sl.contains(2))  # prints True\nsl.remove(2)\nprint(len(sl))  # prints 2\nprint(sl.contains(2))  # prints False\nIn this example, we create a new SkipList object sl and insert the elements 1, 2, and 3 into the list using the insert() method. We then print the length of the list using the __len__() method and check if the list contains the element 2 using the contains() method. We then remove the element 2 from the list using the remove() method and again print the length of the list and check if the list contains the element 2.\n1\nwordpress\n2\nuci\n3\nskiplist\n4\ngeeksforgeeks\n5\njmu"
    },
    {
        "Input": "\"Create a program to find the minimum number of coins needed to make a given amount of change, with an infinite supply of each coin denomination, while minimizing the total number of coins.\"",
        "Output": "To find the minimum number of coins needed to make a given amount of change, with an infinite supply of each coin denomination, while minimizing the total number of coins, we can use dynamic programming. We can create a list dp of length amount+1 and initialize all the values in the list to infinity except for the value at index 0, which we set to 0. We can then iterate over the list of coin denominations and for each denomination, we can iterate over the dp list and update the value at each index to be the minimum of the current value and the value at the index minus the denomination plus one. Finally, we can return the value at index amount in the dp list.\nHere's an implementation of this approach in Python:\npython\ndef min_coins(amount, coins):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]\nIn this implementation, the function min_coins() takes an integer amount and a list of integers coins as input and returns the minimum number of coins needed to make the given amount of change. The function first initializes a list dp of length amount+1 with all values set to infinity except for the value at index 0, which is set to 0. It then iterates over the list of coin denominations and for each denomination, it iterates over the dp list and updates the value at each index to be the minimum of the current value and the value at the index minus the denomination plus one. Finally, the function returns the value at index amount in the dp list.\nHere's an example usage of the min_coins() function:\npython\namount = 11\ncoins = [1, 5, 6, 8]\nprint(min_coins(amount, coins))  # prints 2\nIn this example, we find the minimum number of coins needed to make the amount 11 using the coin denominations [1][5][6][8] using the min_coins() function. The function returns 2, indicating that the minimum number of coins needed is 2 (one 6-cent coin and one 5-cent coin).\n1\nPowered by Wolfram|Alpha\n2\nmedium\n3\neducative\n4\nyoutube\n5\nenjoyalgorithms"
    },
    {
        "Input": "Implement a function to find the longest increasing subarray with at most K distinct integers in a given list of integers using a sliding window approach.",
        "Output": "To find the longest increasing subarray with at most K distinct integers in a given list of integers using a sliding window approach, we can use the following steps:\nInitialize two pointers left and right to the beginning of the list.\nInitialize a dictionary count to keep track of the number of occurrences of each integer in the current subarray.\nInitialize a variable distinct to 0 to keep track of the number of distinct integers in the current subarray.\nInitialize a variable max_length to 0 to keep track of the length of the longest increasing subarray with at most K distinct integers.\nWhile right is less than the length of the list:\nIf the integer at index right is not in the dictionary count, increment distinct.\nIncrement the count of the integer at index right in the dictionary count.\nWhile distinct is greater than K or the integer at index right is less than the integer at index right-1:\nDecrement the count of the integer at index left in the dictionary count.\nIf the count of the integer at index left is 0, decrement distinct.\nIncrement left.\nUpdate max_length to be the maximum of max_length and right-left+1.\nIncrement right.\nReturn max_length.\nHere's an implementation of this approach in Python:\npython\ndef longest_increasing_subarray_with_k_distinct(nums, k):\n    left = right = distinct = max_length = 0\n    count = {}\n    while right < len(nums):\n        if nums[right] not in count:\n            distinct += 1\n        count[nums[right]] = count.get(nums[right], 0) + 1\n        while distinct > k or (right > 0 and nums[right] <= nums[right-1]):\n            count[nums[left]] -= 1\n            if count[nums[left]] == 0:\n                distinct -= 1\n            left += 1\n        max_length = max(max_length, right - left + 1)\n        right += 1\n    return max_length\nIn this implementation, the function longest_increasing_subarray_with_k_distinct() takes a list of integers nums and an integer k as input and returns the length of the longest increasing subarray with at most k distinct integers. The function first initializes two pointers left and right to the beginning of the list, a dictionary count to keep track of the number of occurrences of each integer in the current subarray, a variable distinct to 0 to keep track of the number of distinct integers in the current subarray, and a variable max_length to 0 to keep track of the length of the longest increasing subarray with at most k distinct integers. It then iterates over the list using the two pointers and the dictionary. For each integer, it checks if it is in the dictionary count. If it is not, it increments distinct. It then increments the count of the integer in the dictionary count. If distinct is greater than k or the integer at index right is less than or equal to the integer at index right-1, it decrements the count of the integer at index left in the dictionary count. If the count of the integer at index left is 0, it decrements distinct and increments left. It then updates max_length to be the maximum of max_length and right-left+1. Finally, the function returns max_length.\nHere's an example usage of the longest_increasing_subarray_with_k_distinct() function:\npython\nnums = [1, 3, 1, 2, 2, 3, 4]\nk = 3\nprint(longest_increasing_subarray_with_k_distinct(nums, k))  # prints 5\nIn this example, we find the length of the longest increasing subarray with at most 3 distinct integers in the list [1][3][1][2][2][3][4] using the longest_increasing_subarray_with_k_distinct() function. The function returns 5, indicating that the longest increasing subarray with at most 3 distinct integers is [1][2][2][3][4].\n1\nleetcode\n2\ncodingninjas\n3\nmedium\n4\ngeeksforgeeks\n5\ncp-algorithms"
    },
    {
        "Input": "Write a program to find the median of two sorted arrays of equal size in logarithmic time complexity.",
        "Output": "There are several ways to find the median of two sorted arrays of equal size in logarithmic time complexity. One approach is to use a binary search algorithm to find the median. Here's how the algorithm works:\nInitialize two pointers left and right to the beginning and end of the arrays, respectively.\nWhile left is less than or equal to right:\nCalculate the middle index mid as the average of left and right.\nIf the element at index mid in the first array is less than the element at index n-mid-1 in the second array, set left to mid+1.\nOtherwise, if the element at index mid in the first array is greater than the element at index n-mid-1 in the second array, set right to mid-1.\nOtherwise, return the element at index mid in either array as the median.\nIf the algorithm has not yet returned, return -1 to indicate that the median was not found.\nHere's an implementation of this approach in Python:\npython\ndef find_median_sorted_arrays(nums1, nums2):\n    n = len(nums1)\n    left, right = 0, n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums1[mid] < nums2[n - mid - 1]:\n            left = mid + 1\n        elif nums1[mid] > nums2[n - mid - 1]:\n            right = mid - 1\n        else:\n            return nums1[mid]\n    return -1\nIn this implementation, the function find_median_sorted_arrays() takes two sorted arrays nums1 and nums2 of equal size as input and returns the median of the two arrays. The function first initializes two pointers left and right to the beginning and end of the arrays, respectively. It then uses a binary search algorithm to find the median of the two arrays. For each iteration of the binary search, it calculates the middle index mid as the average of left and right. If the element at index mid in the first array is less than the element at index n-mid-1 in the second array, it sets left to mid+1. If the element at index mid in the first array is greater than the element at index n-mid-1 in the second array, it sets right to mid-1. Otherwise, it returns the element at index mid in either array as the median. If the algorithm has not yet returned, it returns -1 to indicate that the median was not found.\nHere's an example usage of the find_median_sorted_arrays() function:\npython\nnums1 = [1, 3, 5, 7, 9]\nnums2 = [2, 4, 6, 8, 10]\nprint(find_median_sorted_arrays(nums1, nums2))  # prints 5\nIn this example, we find the median of the two sorted arrays [1][3][5][7][9] and [2][4][6][8][10] using the find_median_sorted_arrays() function. The function returns 5, indicating that the median of the two arrays is 5.\n1\nstackexchange\n2\nleetcode\n3\nyoutube\n4\nyoutube\n5\ngeeksforgeeks"
    },
    {
        "Input": "Create a Python class representing a quadtree and implement methods to insert and search for points efficiently.",
        "Output": "Here's a Python class representing a quadtree and implementing methods to insert and search for points efficiently:\npython\nclass Point:\n    def __init__(self, x, y, data=None):\n        self.x = x\n        self.y = y\n        self.data = data\n\nclass QuadTree:\n    def __init__(self, boundary, max_points=4, max_depth=10, depth=0):\n        self.boundary = boundary\n        self.max_points = max_points\n        self.max_depth = max_depth\n        self.depth = depth\n        self.points = []\n        self.children = []\n\n    def insert(self, point):\n        if not self.boundary.contains(point):\n            return False\n        if len(self.points) < self.max_points or self.depth == self.max_depth:\n            self.points.append(point)\n            return True\n        if not self.children:\n            self.subdivide()\n        for child in self.children:\n            if child.insert(point):\n                return True\n        return False\n\n    def subdivide(self):\n        x = self.boundary.x\n        y = self.boundary.y\n        w = self.boundary.w / 2\n        h = self.boundary.h / 2\n        self.children.append(QuadTree(Rect(x - w, y - h, w, h), self.max_points, self.max_depth, self.depth + 1))\n        self.children.append(QuadTree(Rect(x + w, y - h, w, h), self.max_points, self.max_depth, self.depth + 1))\n        self.children.append(QuadTree(Rect(x - w, y + h, w, h), self.max_points, self.max_depth, self.depth + 1))\n        self.children.append(QuadTree(Rect(x + w, y + h, w, h), self.max_points, self.max_depth, self.depth + 1))\n\n    def search(self, boundary):\n        result = []\n        if not self.boundary.intersects(boundary):\n            return result\n        for point in self.points:\n            if boundary.contains(point):\n                result.append(point)\n        for child in self.children:\n            result.extend(child.search(boundary))\n        return result\n\nclass Rect:\n    def __init__(self, x, y, w, h):\n        self.x = x\n        self.y = y\n        self.w = w\n        self.h = h\n\n    def contains(self, point):\n        return (self.x - self.w <= point.x <= self.x + self.w and\n                self.y - self.h <= point.y <= self.y + self.h)\n\n    def intersects(self, other):\n        return (self.x - self.w <= other.x + other.w and\n                self.x + self.w >= other.x - other.w and\n                self.y - self.h <= other.y + other.h and\n                self.y + self.h >= other.y - other.h)\nIn this implementation, the Point class represents a point in two-dimensional space with optional data. The Rect class represents a rectangle in two-dimensional space through its center, width, and height. The QuadTree class represents the quadtree data structure itself. It is defined recursively, such that when a node needs to divide, it creates four children nodes. The class has four methods: __init__(), insert(), subdivide(), and search(). The __init__() method initializes a node of the quadtree. The insert() method inserts a point into the quadtree. The subdivide() method subdivides a node into four children nodes. The search() method searches for all points within a given boundary.\nHere's an example usage of the QuadTree class:\npython\nboundary = Rect(0, 0, 100, 100)\nquadtree = QuadTree(boundary, max_points=4, max_depth=10)\npoints = [Point(10, 10), Point(20, 20), Point(30, 30), Point(40, 40)]\nfor point in points:\n    quadtree.insert(point)\nresult = quadtree.search(Rect(0, 0, 50, 50))\nfor point in result:\n    print(point.x, point.y)\nIn this example, we create a new QuadTree object quadtree with a boundary of (0, 0, 100, 100) and a maximum of 4 points per node and 10 levels of depth. We then insert four points into the quadtree and search for all points within a boundary of (0, 0, 50, 50). The function returns the points (10, 10) and (20, 20), which are within the search boundary.\n1\ngithub\n2\nscipython\n3\nvt\n4\npypi\n5\nstackoverflow"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, slashes, and custom operators, allowing for nested expressions and operator precedence.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, slashes, and custom operators, allowing for nested expressions and operator precedence, we can use a stack data structure. We can iterate over the string and for each character, we can check if it is an opening symbol or a closing symbol. If it is an opening symbol, we push it onto the stack. If it is a closing symbol, we pop the top element from the stack and check if it matches the closing symbol. If it does not match or the stack is empty, the expression is not balanced. If we reach the end of the string and the stack is empty, the expression is balanced.\nHere's an implementation of this approach in Python:\npython\ndef is_valid_expression(expr):\n    stack = []\n    opening_symbols = \"([{<\"\n    closing_symbols = \")]}>\"\n    for char in expr:\n        if char in opening_symbols:\n            stack.append(char)\n        elif char in closing_symbols:\n            if not stack:\n                return False\n            top = stack.pop()\n            if opening_symbols.index(top) != closing_symbols.index(char):\n                return False\n    return not stack\nIn this implementation, the function is_valid_expression() takes a string expr as input and returns True if the expression is valid and False otherwise. The function first initializes an empty stack and two strings opening_symbols and closing_symbols that contain the opening and closing symbols, respectively. It then iterates over the string and for each character, it checks if it is an opening symbol or a closing symbol. If it is an opening symbol, it pushes it onto the stack. If it is a closing symbol, it pops the top element from the stack and checks if it matches the closing symbol. If it does not match or the stack is empty, the expression is not balanced and the function returns False. If we reach the end of the string and the stack is empty, the expression is balanced and the function returns True.\nHere's an example usage of the is_valid_expression() function:\npython\nexpr = \"(a + b) * (c - d)\"\nprint(is_valid_expression(expr))  # prints True\nIn this example, we check if the expression (a + b) * (c - d) is valid using the is_valid_expression() function. The function returns True, indicating that the expression is valid.\n1\ncodesdope\n2\ngeeksforgeeks\n3\nenjoyalgorithms\n4\nafteracademy\n5\ncodingninjas"
    },
    {
        "Input": "Write a program to find the maximum product of a subarray in a given list of integers.",
        "Output": "To find the maximum product of a subarray in a given list of integers, we can use the Kadane's algorithm. The algorithm works by keeping track of the maximum and minimum product subarrays ending at each index of the array. We initialize two variables max_so_far and min_so_far to the first element of the array and iterate over the remaining elements of the array. For each element, we update max_so_far and min_so_far as follows:\nIf the element is positive, we update max_so_far as the maximum of max_so_far * element and element, and min_so_far as the minimum of min_so_far * element and element.\nIf the element is zero, we reset max_so_far and min_so_far to 1.\nIf the element is negative, we swap max_so_far and min_so_far and update max_so_far as the maximum of max_so_far * element and element, and min_so_far as the minimum of min_so_far * element and element.\nAt each iteration, we update a variable result to be the maximum of result and max_so_far. Finally, we return result.\nHere's an implementation of this approach in Python:\npython\ndef max_product_subarray(nums):\n    max_so_far = min_so_far = result = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] > 0:\n            max_so_far = max(max_so_far * nums[i], nums[i])\n            min_so_far = min(min_so_far * nums[i], nums[i])\n        elif nums[i] == 0:\n            max_so_far = min_so_far = 1\n        else:\n            max_so_far, min_so_far = max(min_so_far * nums[i], nums[i]), min(max_so_far * nums[i], nums[i])\n        result = max(result, max_so_far)\n    return result\nIn this implementation, the function max_product_subarray() takes a list of integers nums as input and returns the maximum product of a subarray in the list. The function first initializes three variables max_so_far, min_so_far, and result to the first element of the array. It then iterates over the remaining elements of the array and updates max_so_far and min_so_far as described above. At each iteration, it updates result to be the maximum of result and max_so_far. Finally, the function returns result.\nHere's an example usage of the max_product_subarray() function:\npython\nnums = [2, 3, -2, 4]\nprint(max_product_subarray(nums))  # prints 6\nIn this example, we find the maximum product of a subarray in the list [1][2][-2][3] using the max_product_subarray() function. The function returns 6, indicating that the maximum product of a subarray is 6, which is obtained from the subarray [1][2].\n1\ntechiedelight\n2\ngeeksforgeeks\n3\nleetcode"
    },
    {
        "Input": "Create a program to find the longest increasing subsequence in a given list of integers using binary search.",
        "Output": "To find the longest increasing subsequence in a given list of integers using binary search, we can use the following steps:\nInitialize an empty list tails.\nIterate over the list of integers and for each integer, do the following:\nIf the integer is greater than the last element in tails, append it to tails.\nOtherwise, find the index of the first element in tails that is greater than or equal to the integer using binary search and replace that element with the integer.\nReturn the length of tails.\nHere's an implementation of this approach in Python:\npython\ndef longest_increasing_subsequence(nums):\n    tails = []\n    for num in nums:\n        if not tails or num > tails[-1]:\n            tails.append(num)\n        else:\n            left, right = 0, len(tails) - 1\n            while left < right:\n                mid = (left + right) // 2\n                if tails[mid] < num:\n                    left = mid + 1\n                else:\n                    right = mid\n            tails[left] = num\n    return len(tails)\nIn this implementation, the function longest_increasing_subsequence() takes a list of integers nums as input and returns the length of the longest increasing subsequence in the list. The function first initializes an empty list tails. It then iterates over the list of integers and for each integer, it checks if it is greater than the last element in tails. If it is, it appends it to tails. Otherwise, it uses binary search to find the index of the first element in tails that is greater than or equal to the integer and replaces that element with the integer. Finally, the function returns the length of tails.\nHere's an example usage of the longest_increasing_subsequence() function:\npython\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(longest_increasing_subsequence(nums))  # prints 4\nIn this example, we find the longest increasing subsequence in the list [1][2][3][101] using the longest_increasing_subsequence() function. The function returns 4, indicating that the longest increasing subsequence is [1][3][101].\n1\ncp-algorithms\n2\nstackoverflow\n3\nopengenus"
    },
    {
        "Input": "Implement a function to calculate the Levenshtein distance between two strings using dynamic programming.",
        "Output": "The Levenshtein distance is a measure of similarity between two strings. It is defined as the minimum number of changes required to convert one string into another, where a change can be an insertion, deletion, or substitution of a character. The Levenshtein distance is also known as the edit distance. It has applications in information theory, linguistics, and computer science.\nTo calculate the Levenshtein distance between two strings using dynamic programming, we can use a matrix to store the distances between all possible pairs of prefixes of the two strings. We can initialize the matrix with the distances between the empty prefixes and the prefixes of the two strings. We can then iterate over the remaining pairs of prefixes and fill in the matrix using the following recurrence relation:\nIf the characters at the current positions in the two strings are the same, the distance is the same as the distance between the prefixes without the current characters.\nOtherwise, the distance is the minimum of the distances between the prefixes without the current characters, plus one.\nThe Levenshtein distance between the two strings is the value in the bottom-right corner of the matrix.\nHere's an implementation of this approach in Python:\npython\ndef levenshtein_distance(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    return dp[m][n]\nIn this implementation, the function levenshtein_distance() takes two strings s1 and s2 as input and returns the Levenshtein distance between the two strings. The function first initializes a matrix dp with dimensions (m+1) x (n+1), where m and n are the lengths of s1 and s2, respectively. It then initializes the first row and column of the matrix with the distances between the empty prefixes and the prefixes of the two strings. It then iterates over the remaining pairs of prefixes and fills in the matrix using the recurrence relation described above. Finally, the function returns the value in the bottom-right corner of the matrix.\nHere's an example usage of the levenshtein_distance() function:\npython\ns1 = \"kitten\"\ns2 = \"sitting\"\nprint(levenshtein_distance(s1, s2))  # prints 3\nIn this example, we calculate the Levenshtein distance between the strings \"kitten\" and \"sitting\" using the levenshtein_distance() function. The function returns 3, indicating that the minimum number of changes required to convert \"kitten\" into \"sitting\" is 3.\n1\nyoutube\n2\neducative\n3\ncuelogic\n4\ntechiedelight\n5\nwikipedia"
    },
    {
        "Input": "\"Write a Python class representing an interval tree and implement methods to insert, search, and remove intervals efficiently.\"",
        "Output": "There are several ways to implement an interval tree in Python. One popular implementation is the intervaltree package, which provides a mutable, self-balancing interval tree for Python 2 and 3. The package allows queries by point, by range overlap, or by range containment. The intervaltree package provides methods to insert, search, and remove intervals efficiently.\nHere's an example usage of the intervaltree package:\npython\nfrom intervaltree import Interval, IntervalTree\n\ntree = IntervalTree()\ntree.add(Interval(0, 10))\ntree.add(Interval(5, 15))\ntree.add(Interval(10, 20))\nresult = tree.search(7)\nfor interval in result:\n    print(interval)\nIn this example, we create a new IntervalTree object tree and add three intervals to it. We then search for all intervals that overlap with the range [7][7] using the search() method. The function returns two intervals, (0, 10) and (5, 15), which overlap with the search range. We then print the intervals.\nAlternatively, we can implement an interval tree from scratch using a self-balancing binary search tree (BST) like a Red-Black Tree or an AVL Tree. We can augment the BST to maintain a set of intervals so that all operations can be done in O(logn) time. We can implement the following methods to insert, search, and remove intervals:\ninsert(interval): Inserts a new interval into the tree.\nremove(interval): Removes an interval from the tree.\nsearch(interval): Searches for all intervals that overlap with a given interval.\nHere's an implementation of an interval tree using a Red-Black Tree in Python:\npython\nclass Interval:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nclass Node:\n    def __init__(self, interval):\n        self.interval = interval\n        self.max_end = interval.end\n        self.left = None\n        self.right = None\n        self.color = 1  # 1 for red, 0 for black\n\nclass IntervalTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, interval):\n        node = Node(interval)\n        if self.root is None:\n            self.root = node\n            node.color = 0\n            return\n        curr = self.root\n        parent = None\n        while curr is not None:\n            parent = curr\n            if node.interval.start < curr.interval.start:\n                curr = curr.left\n            else:\n                curr = curr.right\n        node.parent = parent\n        if node.interval.start < parent.interval.start:\n            parent.left = node\n        else:\n            parent.right = node\n        self.fix_insert(node)\n\n    def fix_insert(self, node):\n        while node.parent is not None and node.parent.color == 1:\n            if node.parent == node.parent.parent.left:\n                uncle = node.parent.parent.right\n                if uncle is not None and uncle.color == 1:\n                    node.parent.color = 0\n                    uncle.color = 0\n                    node.parent.parent.color = 1\n                    node = node.parent.parent\n                else:\n                    if node == node.parent.right:\n                        node = node.parent\n                        self.left_rotate(node)\n                    node.parent.color = 0\n                    node.parent.parent.color = 1\n                    self.right_rotate(node.parent.parent)\n            else:\n                uncle = node.parent.parent.left\n                if uncle is not None and uncle.color == 1:\n                    node.parent.color = 0\n                    uncle.color = 0\n                    node.parent.parent.color = 1\n                    node = node.parent.parent\n                else:\n                    if node == node.parent.left:\n                        node = node.parent\n                        self.right_rotate(node)\n                    node.parent.color = 0\n                    node.parent.parent.color = 1\n                    self.left_rotate(node.parent.parent)\n        self.root.color = 0\n\n    def left_rotate(self, node):\n        right_child = node.right\n        node.right = right_child.left\n        if right_child.left is not None:\n            right_child.left.parent = node\n        right_child.parent = node.parent\n        if node.parent is None:\n            self.root = right_child\n        elif node == node.parent.left:\n            node.parent.left = right_child\n        else:\n            node.parent.right = right_child\n        right_child.left = node\n        node.parent = right_child\n        node.max_end = max(node.interval.end, node.left.max_end if node.left is not None else node.interval.end,\n                           node.right.max_end if node.right is not None else node.interval.end)\n        right_child.max_end = max(right_child.interval.end, node.max_end, right_child.right.max_end if right_child.right is not None else right_child.interval.end)\n\n    def right_rotate(self, node):\n        left_child = node.left\n        node.left = left_child.right\n        if left_child.right is not None:\n            left_child.right.parent = node\n        left_child.parent = node.parent\n        if node.parent is None:\n            self.root = left_child\n        elif node == node.parent.right:\n            node.parent.right = left_child\n        else:\n            node.parent.left = left_child\n        left_child.right = node\n        node.parent = left_child\n        node.max_end = max(node.interval.end, node.left.max_end if node.left is not None else node.interval.end,\n                           node.right.max_end if node.right is not None else node.interval.end)\n        left_child.max_end = max(left_child.interval.end, node.max_end, left_child.left.max_end if left_child.left is not None else left_child.interval.end)\n\n    def remove(self, interval):\n        node = self.search(interval)\n        if node is None:\n            raise ValueError(\"Interval not found\")\n        if node.left is None or node.right is None:\n            y = node\n        else:\n            y = self.successor(node)\n        if y.left is not None:\n            x = y.left\n        else:\n            x = y.right\n        if x is not None:\n            x.parent = y.parent\n        if y.parent is None:\n            self.root = x\n        elif y == y.parent.left:\n            y.parent.left = x\n        else:\n            y.parent.right = x\n        if y != node:\n            node.interval = y.interval\n        self.fix_delete(x, y)\n\n    def fix_delete(self, x, y):\n        if x is not None and y.color == 0:\n            while x != self.root and (x is None or x.color == 0):\n                if x == x.parent.left:\n                    w = x.parent.right\n                    if w.color == 1:\n                        w.color = 0\n                        x.parent.color = 1\n                        self.left_rotate(x.parent)\n                        w = x.parent.right\n                    if (w.left is None or w.left.color == 0) and (w.right is None or w.right.color == 0):\n                        w.color = 1\n                        x = x.parent\n                    else:\n                        if w.right is None or w.right.color == 0:\n1\ngithub\n2\npypi\n3\ngeeksforgeeks\n4\ngeeksforgeeks\n5\nopengenus"
    },
    {
        "Input": "Create a program to find the maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive.",
        "Output": "To find the maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive, we can use dynamic programming. We can maintain an auxiliary array sum of the same size as the input array to find the result. sum[i] stores the result for the subarray arr[0..i], i.e., the maximum possible sum in the subarray arr[0..i] such that no three elements are consecutive. We can use the following recurrence relation to fill in the sum array:\nsum[i] = max(sum[i-1], sum[i-2] + arr[i], sum[i-3] + arr[i] + arr[i-1])\nThe maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive is the maximum value in the sum array.\nHere's an implementation of this approach in Python:\npython\ndef max_sum_subarray(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    sum = [0] * n\n    sum[0] = nums[0]\n    sum[1] = max(nums[0], nums[1])\n    sum[2] = max(nums[0] + nums[2], nums[1], nums[2])\n    for i in range(3, n):\n        sum[i] = max(sum[i-1], sum[i-2] + nums[i], sum[i-3] + nums[i] + nums[i-1])\n    return max(sum)\nIn this implementation, the function max_sum_subarray() takes a list of integers nums as input and returns the maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive. The function first initializes an auxiliary array sum of the same size as the input array. It then fills in the sum array using the recurrence relation described above. Finally, the function returns the maximum value in the sum array.\nHere's an example usage of the max_sum_subarray() function:\npython\nnums = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(max_sum_subarray(nums))  # prints 27\nIn this example, we find the maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive in the list [1][2][3][4][5][6] using the max_sum_subarray() function. The function returns 27, indicating that the maximum sum of a subarray is 27, which is obtained from the subarray [1][3][5].\n1\nstackoverflow\n2\ngeeksforgeeks\n3\ncodingninjas\n4\ntutorialcup\n5\ngeeksforgeeks\n6\ncodingninjas"
    },
    {
        "Input": "Implement a function to check if a given number is a power of two using bitwise operations.",
        "Output": "To check if a given number is a power of two using bitwise operations, we can use the following property of binary numbers that are powers of two: they have only one set bit in their binary representation. We can use this property to check if a number is a power of two by counting the number of set bits in its binary representation. If the count is 1, the number is a power of two. However, this approach takes O(log n) time to solve the problem. We can improve the time complexity to O(1) using bitwise operations.\nTo check if a number is a power of two using bitwise operations, we can use the following observation: if a number is a power of two, its binary representation has only one set bit. For example, the binary representation of 8 is 1000, which has only one set bit. We can use this observation to check if a number is a power of two using the bitwise AND operator.\nIf we subtract 1 from a power of two, we get a number that has all the bits to the right of the set bit flipped. For example, if we subtract 1 from 8, we get 7, whose binary representation is 0111. If we take the bitwise AND of a power of two and its predecessor, we get 0. For example, if we take the bitwise AND of 8 and 7, we get 0. If a number is not a power of two, its binary representation has more than one set bit. For example, the binary representation of 6 is 0110, which has two set bits. If we take the bitwise AND of 6 and 5, we get a non-zero value.\nHere's an implementation of this approach in Python:\npython\ndef is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0\nIn this implementation, the function is_power_of_two() takes an integer n as input and returns True if n is a power of two and False otherwise. The function first checks if n is positive. If it is not positive, the function returns False. If n is positive, the function takes the bitwise AND of n and its predecessor n-1. If the result is 0, the function returns True, indicating that n is a power of two. Otherwise, the function returns False.\nHere's an example usage of the is_power_of_two() function:\npython\nn = 8\nprint(is_power_of_two(n))  # prints True\nIn this example, we check if the number 8 is a power of two using the is_power_of_two() function. The function returns True, indicating that 8 is a power of two.\n1\nyoutube\n2\nopengenus\n3\ngeeksforgeeks\n4\nincludehelp\n5\njava67"
    },
    {
        "Input": "\"Write a program to find the maximum sum subarray in a given circular array using Kadane's algorithm, with the constraint that the subarray must contain at least one element from each half of the circular array.\"",
        "Output": "To find the maximum sum subarray in a given circular array using Kadane's algorithm, with the constraint that the subarray must contain at least one element from each half of the circular array, we can use the following approach:\nFind the maximum sum subarray using Kadane's algorithm for the given array.\nFind the minimum sum subarray using Kadane's algorithm for the given array.\nCalculate the total sum of the array.\nIf the total sum minus the minimum sum is greater than the maximum sum, return the total sum minus the minimum sum. Otherwise, return the maximum sum.\nThe idea behind this approach is that the maximum sum subarray can either be a subarray that does not wrap around the circular array or a subarray that wraps around the circular array. If the maximum sum subarray does not wrap around the circular array, we can use Kadane's algorithm to find it. If"
    }
]