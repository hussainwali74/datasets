[
    {
        "Question": "ایم ایل",
        "Answer": "یقینا!یہاں ایک ٹائپ اسکرپٹ پروگرام کی ایک مثال ہے جو گراف پر چوڑائی کی پہلی تلاش کرتی ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: ریکارڈ <سٹرنگ ، سٹرنگ []> ؛کنسٹرکٹر () {this.adjacencyList = {} ؛} ایڈورٹیکس (ورٹیکس: سٹرنگ) {if (! this.adjacencyList [vertex]) {this.adjacencyList [vertex] = [] ؛}} ایڈج (ورٹیکس 1: سٹرنگ ، ورٹیکس 2: سٹرنگ) {this.adjacencyList [vertex1] .push (vertex2) ؛this.adjacencyList [vertex2] .Push (vertex1) ؛} بریڈھفیرسٹ سرچ (اسٹارٹورٹیکس: سٹرنگ) {کنسٹ ملاحظہ کریں: ریکارڈ <سٹرنگ ، بولین> = {} ؛کانسٹ قطار: سٹرنگ [] = [] ؛کانسٹنگ نتیجہ: سٹرنگ [] = [] ؛دورہ [اسٹارٹورٹیکس] = سچ ؛قطار.پش (اسٹارٹورٹیکس) ؛جبکہ (قطار۔ لمبائی) {موجودہ موجودہورٹیکس = قطار۔ شفٹ () !؛نتیجہ۔ پش (کرنٹورٹیکس) ؛this.adjacencyList [کرنٹٹورٹیکس] .foreach ((پڑوسی) => {اگر (! ملاحظہ کیا [پڑوسی]) {ملاحظہ کیا [پڑوسی] = سچ ؛ قطار.پش (پڑوسی) ؛}}) ؛} واپسی کا نتیجہ ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈورٹیکس (\"A\") ؛ گراف.اڈورٹیکس (\"بی\") ؛ گراف.اڈٹورٹیکس (\"سی\") ؛ گراف.اڈٹورٹیکس (\"ڈی\")؛ گراف.اڈورٹیکس (\"ای\") ؛ گراف.اڈیج (\"اے\" ، \"بی\") ؛ گراف.ڈیج (\"اے\" ، \"سی\") ؛ گراف.ڈیج (\"بی\" ، \"ڈی\") ؛ گراف.Addedge (\"C\" ، \"E\") ؛ کنسول.لوگ (گراف.بریڈھفیرسٹ سرچ (\"A\")) ؛// آؤٹ پٹ: ['A' ، 'B' ، 'C' ، 'D' ، 'E'] اس مثال میں ، ہم گراف میں عمودی اور کناروں کو شامل کرنے کے طریقوں کے ساتھ گراف کلاس کی وضاحت کرتے ہیں۔چوڑائی کی تلاش کا طریقہ کسی دیئے گئے ورٹیکس سے شروع ہونے والی چوڑائی کی پہلی تلاش کو انجام دیتا ہے۔اس میں دورہ شدہ چشموں کا سراغ لگانے کے لئے ملاحظہ کی گئی شے کا استعمال کیا جاتا ہے ، دورے کے لئے عمودی کو ذخیرہ کرنے کے لئے ایک قطار صف ، اور ملاحظہ کرنے والے عمودیوں کے آرڈر کو ذخیرہ کرنے کے لئے نتیجہ سرے۔ ہم گراف کلاس کی ایک نئی مثال بنائیں اور اس میں عمودی اور کناروں کو شامل کریں۔اس کے بعد ، ہم \"A\" کے ابتدائی حد کے ساتھ بریڈتھفیرسٹ سرچ طریقہ کو کہتے ہیں اور اس کے نتیجے میں لاگ ان کریں۔ پروگرام کی آؤٹ پٹ ['a' ، 'b' ، 'c' ، 'd' ، 'e'] ہوگی۔اس ترتیب کی نمائندگی کرتا ہے جس میں چوڑائی کی پہلی تلاش کے دوران عمودی کا دورہ کیا گیا تھا۔"
    },
    {
        "Question": "\"\"",
        "Answer": "ٹائپ اسکرپٹ میں ترتیب شدہ لنکڈ لسٹ میں بائنری سرچ الگورتھم کو نافذ کرنے کے ل we ، ہمیں لنکڈ فہرست کو ایک صف میں تبدیل کرنے کی ضرورت ہے تاکہ ہم بائنری تلاش کو موثر انداز میں انجام دے سکیں۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس لسٹنوڈ {قدر: نمبر ؛اگلا: لسٹنوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.next = null ؛class} کلاس لنکڈ لسٹ {سر: لسٹنوڈ |خالی؛کنسٹرکٹر () {this.head = null ؛} داخل کریں (قیمت: نمبر) {کونسٹ نیونوڈ = نیا لسٹنوڈ (قدر) ؛اگر (! this.head) {this.head = newnode ؛} دوسری {موجودہ = this.head ؛جبکہ (موجودہ۔ نیکسٹ) {موجودہ = موجودہ۔ نیکسٹ ؛} موجودہ۔ نیکسٹ = نیونوڈ ؛}} tosortedarray (): نمبر [] {CONST نتیجہ: نمبر [] = [] ؛آئیے موجودہ = this.head ؛جبکہ (موجودہ) {نتیجہ۔ پش (موجودہ. قیمت) ؛موجودہ = موجودہ۔ نیکسٹ ؛} واپسی کا نتیجہ ؛} بائنری سرچ (ٹارگٹ: نمبر): بولین {کونٹ سنٹری = یہ۔ ٹوسورٹری () () ؛بائیں = 0 ؛چلو دائیں = چھانٹری ڈری۔ لمبائی - 1 ؛جبکہ (بائیں <= دائیں) {const MID = math.floor ((بائیں + دائیں) / 2) ؛اگر (shartedarray [وسط] === ہدف) {سچ واپس ؛} ورنہ اگر (shartedarray [وسط] <ہدف) {بائیں = وسط + 1 ؛} دوسری {دائیں = وسط - 1 ؛}} غلط لوٹائیں ؛}} // مثال کے طور پر استعمال: لنکڈ لسٹ = نئی لنکڈ لسٹ () ؛ لنکڈ لسٹ۔ INSERT (10) ؛ لنکڈ لسٹ۔ INSERT (20) ؛ لنکڈ لسٹ۔ INSERT (30) ؛ لنکڈ لسٹ۔ INSERT (40) ؛ لنکڈ لسٹ۔ INSERT (50) ؛کنسول.لوگ (لنکڈ لسٹ.بائنری سرچ (30)) ؛// آؤٹ پٹ: trueconsole.log (لنکڈ لسٹ.بائنری سرچ (35)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہم لنکڈ لسٹ میں ایک ہی نوڈ کی نمائندگی کرنے کے لئے ایک لسٹنوڈ کلاس کی وضاحت کرتے ہیں ، اور لنکڈ لسٹ کلاس جو منسلک فہرست کی کارروائیوں کا انتظام کرتی ہے۔داخل کرنے کا طریقہ منسلک فہرست میں اقدار داخل کرنے کے لئے استعمال کیا جاتا ہے۔ بائنری تلاش کرنے کے ل we ، ہم پہلے لنکڈ فہرست کو ٹوسورٹیرے کے طریقہ کار کا استعمال کرتے ہوئے ترتیب دیئے گئے صف میں تبدیل کرتے ہیں۔یہ طریقہ منسلک فہرست کو عبور کرتا ہے اور ترتیب شدہ ترتیب میں اقدار کے ساتھ ایک صف تیار کرتا ہے۔ اس کے بعد ، بائنری تلاش کا طریقہ ترتیب شدہ صف پر بائنری تلاش کرتا ہے۔یہ صف کے آغاز اور اختتام تک بائیں اور دائیں پوائنٹرز کی ابتدا کرتا ہے ، اور درمیانی عنصر کے ساتھ ہدف کی قیمت کا موازنہ کرنے کے لئے درمیانی انڈیکس (وسط) کا تکرار سے حساب کتاب کرتا ہے۔اگر ہدف کی قیمت مل جاتی ہے تو ، یہ سچ واپس آجاتا ہے۔اگر ہدف کی قیمت چھوٹی ہے تو ، دائیں پوائنٹر کو ایڈجسٹ کیا جاتا ہے۔اگر ہدف کی قیمت بڑی ہے تو ، بائیں پوائنٹر کو ایڈجسٹ کیا جاتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ ہدف کی قیمت نہ مل جائے یا تلاش کی جگہ ختم ہوجائے۔اگر لنکڈ لسٹ میں ہدف کی قیمت مل جاتی ہے ، اور دوسری صورت میں جھوٹا ہوتا ہے تو پروگرام درست ہوگا۔"
    },
    {
        "Question": "زیر نگرانی اور غیر نگرانی سیکھنے میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہ ہے کہ اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن آریٹریجسٹینیکل (ٹری 1: ٹرینوڈ | نول ، ٹری 2: ٹرینوڈ | نول): بولین {// بیس کیسز: اگر دونوں درخت کالعدم ہیں تو ، وہ ایک جیسے ہیں اگر (ٹری 1 === nulسچ ؛} // اگر ایک درخت کالعدم ہے اور دوسرا نہیں ہے تو ، وہ ایک جیسے نہیں ہیں اگر (ٹری 1 === null || درخت 2 === null) {غلط واپس ؛} // چیک کریں کہ آیا موجودہ نوڈ کی اقدار برابر ہیں ، اور ان کے بائیں اور دائیں سبٹریز کی واپسی (treath1.value === tree2.value && aretreasidentical (treath1.left ، tree2.left) && aretresidentical (treath1.right ، درخت 2. رائٹ)) ؛} // مثال کے طور پر استعمال: // درخت 1 کونسٹ ٹری 1 = نیا ٹرینوڈ (1) ؛ ٹری 1. لیفٹ = نیا ٹرینوڈ (2) ؛ ٹری 1. رائٹ = نیا ٹرینوڈ (3) ؛ ٹری 1.left.left = نیاtreenode (4) ؛ trease1.left.right = نیا ٹرینوڈ (5) // درخت 2 (درخت سے ملتا جلتا ہے 1) کانسٹ ٹری 2 = نیا ٹرینوڈ (1) ؛ درخت 2. لیفٹ = نیا ٹرینوڈ (2) ؛ ٹری 2. رائٹ =نیا ٹرینوڈ (3) tree درخت 2.left.left = نیا ٹرینوڈ (4) ؛ ٹری 2.left.right = نیا ٹرینوڈ (5) ؛ کنسول.لوگ (اریٹ ریزیڈینیکل (ٹری 1 ، ٹری 2)) ؛// آؤٹ پٹ: ٹری // درخت 3 (درخت سے مختلف ڈھانچہ 1) کانسٹ ٹری 3 = نیا ٹرینوڈ (1) ؛ ٹری 3. لیفٹ = نیا ٹرینوڈ (2) ؛ ٹری 3. رائٹ = نیا ٹرینوڈ (3) ؛ ٹری 3.left.right= نیا ٹرینوڈ (4) ؛ ٹری 3. رائٹ.لیفٹ = نیا ٹرینوڈ (5) ؛ کنسول.لوگ (آریٹری ایسڈینیکل (ٹری 1 ، ٹری 3)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہم بائنری درخت میں نوڈ کی نمائندگی کرنے کے لئے ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں۔ہر نوڈ کی ایک قیمت ، ایک بائیں بچہ ، اور ایک دائیں بچہ ہوتا ہے۔ اریٹریسیڈینیکل فنکشن دو بائنری درختوں کو ان پٹ (ٹری 1 اور ٹری 2) کے طور پر لیتا ہے اور اگر درخت ایک جیسے اور غلط ہیں تو وہ سچ ثابت ہوتا ہے۔یہ درختوں کے نوڈس کا موازنہ کرنے کے لئے ایک تکرار نقطہ نظر کا استعمال کرتا ہے۔ فنکشن پہلے بیس کیسوں کی جانچ پڑتال کرتا ہے: اگر دونوں درخت کالعدم ہیں تو وہ ایک جیسے ہیں (بیس کیس 1)۔اگر ایک درخت کالعدم ہے اور دوسرا نہیں ہے تو ، وہ ایک جیسے نہیں ہیں (بیس کیس 2). اگر مذکورہ بالا بیس معاملات پوری نہیں کیے جاتے ہیں تو ، فنکشن ٹری 1 اور ٹری 2 کی موجودہ نوڈ اقدار کا موازنہ کرتا ہے۔اگر وہ برابر ہیں تو ، یہ بار بار دونوں درختوں کے بائیں سبٹریوں اور دائیں سب ٹریوں کے لئے اریٹریسیڈینیکل کہتے ہیں۔اگر یہ ساری بار بار کالیں درست لوٹتی ہیں تو پھر درختوں کو یکساں سمجھا جاتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم تین بائنری درخت بناتے ہیں: ٹری 1 ، ٹری 2 ، اور ٹری 3۔ٹری 1 اور ٹری 2 میں ایک ہی ڈھانچہ اور اقدار ہیں ، لہذا فنکشن کال آریٹیریسیڈینیکل (ٹری 1 ، ٹری 2) کو درست لوٹتا ہے۔تاہم ، ٹری 3 ٹری 1 سے ایک مختلف ڈھانچہ رکھتا ہے ، لہذا فنکشن کال آریٹیریسیڈینیکل (ٹری 1 ، ٹری 3) غلط لوٹتا ہے۔"
    },
    {
        "Question": "مشین لرننگ میں تعصب-مختلف تجارت کے تجارت کی وضاحت کریں۔",
        "Answer": "اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کرنا پیچیدہ ہوسکتا ہے ، لیکن میں آپ کو شروع کرنے کے لئے ایک آسان عمل درآمد فراہم کروں گا۔یہاں ٹائپ اسکرپٹ میں نافذ ہونے والی اسکیپ لسٹ کی ایک مثال ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسکیپلسٹنوڈ {قدر: نمبر ؛اگلا: اسکیپلسٹنوڈ |خالی؛نیچے: اسکیپلسٹنوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.next = null ؛this.down = null ؛class} کلاس اسکیپلسٹ {سر: اسکیپلسٹنوڈ |خالی؛میکسلیول: نمبر ؛سطح پروبییبلٹی: نمبر ؛کنسٹرکٹر () {this.head = null ؛this.maxlevel = 16 ؛// اسکیپ لسٹ کے ل maximum زیادہ سے زیادہ سطح اس۔ لیولپروبیبلٹی = 0.5 ؛// نوڈ کو اعلی سطح پر ہونے کا امکان} داخل کریں (قیمت: نمبر) {// اگر اسکیپ لسٹ خالی ہے تو ، ایک نیا نیچے کی سطح بنائیں اگر (! یہ۔ ہیڈ) {this.head = نیا اسکیپلسٹنوڈ (نمبر (نمبر.min_safe_integer) ؛this.head.down = نیا اسکیپلسٹنوڈ (قدر) ؛} موجودہ = this.head ؛چلو دو: اسکیپلسٹنوڈ |null = null ؛// نیچے کی سطح کے راستے کا راستہ ٹریک کریں: اسکیپلسٹنوڈ [] = [] ؛// نیچے کی سطح میں داخل کرنے کی پوزیشن تلاش کریں جبکہ (موجودہ) {اگر (موجودہ۔ ویلیو === ویلیو) {// قیمت پہلے سے موجود ہے ، واپسی داخل نہ کریں۔} if (موجودہ. نیکسٹ === null || موجودہ. next.value> ویلیو) {پاتھ.پش (موجودہ) ؛موجودہ = موجودہ۔ ڈاون ؛} else {موجودہ = موجودہ. نیکسٹ ؛}} آئیے insertabove = سچ ؛ڈاون نوڈ: اسکیپلسٹنوڈ |null = null ؛// ہر سطح میں نیا نوڈ داخل کریں (آئیے i = this.maxlevel-1 ؛ i> = 0 ؛ i--) {موجودہ = راستہ [i] ؛Const newnode = نیا اسکیپلسٹنوڈ (قدر) ؛اگر (insertabove) {newnode.down = ڈاؤن نوڈ ؛ڈاون نوڈ = newnode ؛} newnode.next = موجودہ. نیکسٹ ؛موجودہ۔ نیکسٹ = نیو نوڈ ؛// تصادفی طور پر فیصلہ کریں کہ آیا Insertabove = math.random () <this.levelprobability کے اوپر کی سطح داخل کرنا ہے یا نہیں۔}} تلاش (قیمت: نمبر): بولین {آئیے موجودہ = this.head ؛// قیمت کو تلاش کرنے کے لئے اسکیپ لسٹ کو عبور کریں جبکہ (موجودہ) {اگر (موجودہ.Value === ویلیو) {سچ واپس ؛} دوسری صورت میں اگر (موجودہ۔ نیکسٹ === نول} else {موجودہ = موجودہ. نیکسٹ ؛}} غلط لوٹائیں ؛}} // مثال کے طور پر استعمال: کونسٹ اسکیپلسٹ = نیا اسکیپلسٹ () ؛ اسکیپلسٹ.نسرٹ (3) ؛ اسکیپلسٹ.نسرٹ (1) ؛ اسکیپلسٹ.سرٹ (4) ؛ اسکیپلسٹ.سرٹ (2) ؛ کنسول.لوگ (اسکیپلسٹ.چارچ۔(2)) ؛// آؤٹ پٹ: trueconsole.log (skiplist.search (5)) ؛// آؤٹ پٹ: اس آسان عمل کو نفاذ میں ، ہمارے پاس دو کلاس ہیں: اسکیپلسٹنوڈ اسکیپ لسٹ میں ایک نوڈ کی نمائندگی کرتا ہے ، اور اسکیپلسٹ اسکیپ لسٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ اسکیپلسٹنوڈ کلاس میں تین خصوصیات ہیں: نوڈ کی قیمت ، اگلے پوائنٹس اگلے پوائنٹس کے پاس ہے۔نوڈ ایک ہی سطح میں ، اور نیچے کی سطح میں نوڈ کی طرف اشارہ کرتے ہیں۔ اسکیپلسٹ کلاس میں تین خصوصیات ہیں: اسکیپ لسٹ کے اوپری بائیں نوڈ کی طرف ہیڈ پوائنٹس ، میکسلیول اسکیپ لسٹ کے لئے زیادہ سے زیادہ سطح کی نمائندگی کرتا ہے (اس معاملے میں اس معاملے میں، 16) ، اور لیولپروبیبلٹی نوڈ کے اعلی سطح پر ہونے کے امکانات کا تعین کرتی ہے۔ داخل کرنے کا طریقہ داخل کرتا ہے"
    },
    {
        "Question": "مشین لرننگ میں کس حد تک زیادہ مناسب ہے اور اسے کیسے روکا جاسکتا ہے؟",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ پروگرام کی ایک مثال ہے جو گراف پر گہرائی سے پہلے تلاش کرتی ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: ریکارڈ <سٹرنگ ، سٹرنگ []> ؛کنسٹرکٹر () {this.adjacencyList = {} ؛} ایڈورٹیکس (ورٹیکس: سٹرنگ) {if (! this.adjacencyList [vertex]) {this.adjacencyList [vertex] = [] ؛}} ایڈج (ورٹیکس 1: سٹرنگ ، ورٹیکس 2: سٹرنگ) {this.adjacencyList [vertex1] .push (vertex2) ؛this.adjacencyList [vertex2] .Push (vertex1) ؛} ڈیپٹفیرسٹ سرچ (اسٹارٹورٹیکس: سٹرنگ) {کنسٹٹ ملاحظہ کریں: ریکارڈ <سٹرنگ ، بولین> = {} ؛کانسٹ ڈی ایف ایس = (ورٹیکس: سٹرنگ) => {ملاحظہ کیا [ورٹیکس] = سچ ؛کنسول.لاگ (ورٹیکس) ؛// ورٹیکس (جیسے ، پرنٹ) کے ساتھ کچھ کریں۔ ایڈجیسی لسٹ [ورٹیکس]} ؛ڈی ایف ایس (اسٹارٹورٹیکس) ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈورٹیکس (\"A\") ؛ گراف.اڈورٹیکس (\"بی\") ؛ گراف.اڈٹورٹیکس (\"سی\") ؛ گراف.اڈٹورٹیکس (\"ڈی\")؛ گراف.اڈورٹیکس (\"ای\") ؛ گراف.اڈیج (\"اے\" ، \"بی\") ؛ گراف.ڈیج (\"اے\" ، \"سی\") ؛ گراف.ڈیج (\"بی\" ، \"ڈی\") ؛ گراف.Addedge (\"C\" ، \"E\") ؛ گراف.ڈیپٹفیرسٹ سرچ (\"A\") ؛ اس مثال میں ، ہم گراف میں عمودی اور کناروں کو شامل کرنے کے طریقوں کے ساتھ گراف کلاس کی وضاحت کرتے ہیں۔ڈیپتھفیرسٹ سرچ کا طریقہ کسی دیئے گئے ورٹیکس سے شروع ہونے والی گہرائی کی پہلی تلاش کو انجام دیتا ہے۔اس میں گراف کو عبور کرنے اور ہر ایک ورٹیکس سے ملنے کے لئے ایک بار بار چلنے والا مددگار فنکشن ڈی ایف ایس کا استعمال کیا جاتا ہے۔ ڈی ایف ایس فنکشن ایک دلیل کے طور پر ایک عمومی طور پر لیتا ہے ، اسے دیکھنے کے طور پر نشان زد کرتا ہے ، اور ورٹیکس (اس معاملے میں ، اس کی طباعت) پر مطلوبہ کارروائی کرتا ہے۔اس کے بعد ، یہ موجودہ ورٹیکس کے ہر غیر منحصر پڑوسی پر بار بار ڈی ایف ایس کو کال کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم گراف کلاس کی ایک مثال بناتے ہیں اور عمودی (\"A\" ، \"B\" ، \"C\" ، \"D\" ، \"شامل کرتے ہیں۔ای \") اور گراف میں کناروں۔آخر میں ، ہم \"A\" کے ابتدائی حد کے ساتھ گہرائی سے چلنے والے طریقہ کار کو کہتے ہیں۔ گہرائی کی پہلی تلاش کے دوران ، پروگرام گراف کو گہرائی سے پہلے انداز میں عبور کرے گا ، اور ہر ایک حد کا دورہ کرے گا اور اس کی قیمت پرنٹ کرے گا۔آؤٹ پٹ وہ ترتیب ہوگا جس میں عمودی دورے کا دورہ کیا جائے گا۔"
    },
    {
        "Question": "مشین لرننگ پائپ لائن میں شامل اقدامات کی وضاحت کریں۔",
        "Answer": "خود توازن بائنری سرچ درخت ، جیسے AVL درخت یا سرخ رنگ کے درخت کو نافذ کرنا کافی پیچیدہ ہوسکتا ہے۔اس کے بجائے ، میں آپ کو ٹائپ اسکرپٹ میں AVL درخت کا مثال فراہم کروں گا۔اے وی ایل کا درخت ایک خود متوازن بائنری سرچ درخت ہے جو موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو یقینی بنانے کے لئے متوازن ڈھانچے کو برقرار رکھتا ہے۔یہاں ایک مثال کے نفاذ ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛اونچائی: نمبر ؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛this.height = 1 ؛}} کلاس avltree {جڑ: Treenode |خالی؛کنسٹرکٹر () {this.root = null ؛} getheight (نوڈ: ٹرینوڈ | null): نمبر {اگر (نوڈ ==== null) {واپس 0 ؛} نوڈ. height ؛} getBalanceFactor (نوڈ: Treenode | null): نمبر {if (node === null) {واپس 0 ؛this اس کو واپس کریں۔} اپ ڈیٹ ہائٹ (نوڈ: ٹرینوڈ) {نوڈ.ہائٹ = میتھ.میکس (this.getheight (node.left) ، this.getheight (node.right)) + 1 ؛} روٹیرائٹ (نوڈ: ٹرینوڈ): ٹرینوڈ {کونسٹ نیوروٹ = نوڈ.لفٹ ؛const temp = newrot.right ؛newrot.right = نوڈ ؛node.left = temp ؛this.updateHeight (نوڈ) ؛this.updateHeight (newrot) ؛واپس نیو روٹ ؛} گھومنے والی چیز (نوڈ: ٹرینوڈ): ٹرینوڈ {کونسٹ نیو روٹ = نوڈ. رائٹ ؛const temp = newrot.left ؛newrot.left = نوڈ ؛node.right = temp ؛this.updateHeight (نوڈ) ؛this.updateHeight (newrot) ؛واپس نیو روٹ ؛} داخل کریں (قیمت: نمبر) {this.root = this.insertnode (this.root ، value) ؛} Insertnode (نوڈ: ٹرینوڈ | null ، value: نمبر): treenode {if (نوڈ === null) {واپس نیا ٹرینوڈ (قیمت) واپس کریں ؛} if (value <node.value) {node.left = this.insertnode (node.left ، value) ؛} else {node.right = this.insertnode (node.right ، value) ؛} this.updateHeight (نوڈ) ؛کونسٹ بیلنس فیکٹر = this.getBalanceFactor (نوڈ) ؛// بائیں-بائیں کیس اگر (بیلنس فیکٹر> 1 && ویلیو <نوڈ.لفٹ! .Value) {اس کو واپس کریں۔} // دائیں رائٹ کیس اگر (بیلنس فیکٹر <-1 && ویلیو> نوڈ. رائٹ! .Value) {اس کو واپس کریں۔} // بائیں بازو کا معاملہ اگر (بیلنس فیکٹر> 1 && ویلیو> نوڈ۔ لیفٹ!اس کو واپس کریں۔ روٹیرائٹ (نوڈ) ؛} // دائیں- بائیں کیس اگر (بیلنس فیکٹر <-1 && ویلیو <نوڈ. رائٹ!اس کو واپس کریں۔} واپسی نوڈ ؛} تلاش (ویلیو: نمبر): بولین {واپس کریں۔} سرچنوڈ (نوڈ: ٹرینوڈ | نول ، ویلیو: نمبر): بولین {اگر (نوڈ === null) {غلط واپس ؛} if (value === node.value) {سچ واپس ؛} دوسری صورت میں اگر (ویلیو <نوڈ.والیو) {اس کی سرچ نوڈ (نوڈ.لفٹ ، ویلیو) واپس کریں ؛} دوسری {اس کی تلاش کریں۔ سرچنوڈ (نوڈ. رائٹ ، قدر)}} ہٹائیں (ویلیو: نمبر) {this.root = this.remove"
    },
    {
        "Question": "درجہ بندی کے کاموں میں استعمال شدہ اہم تشخیصی میٹرکس کیا ہیں؟",
        "Answer": "یقینا!انٹیجرز کی ایک صف پر انضمام کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن انضمام انضمام (ARR: نمبر []): نمبر [] {اگر (arr.length <= 1) {واپسی ARR ؛} کانٹ مڈل = ریاضی۔ فلور (arr.length / 2) ؛کانسٹ لیفٹار = آر آر ایس سلائس (0 ، درمیانی) ؛کونٹ رائٹ آر = آر آر ایس سلائس (درمیانی) ؛const sootdleftarr = انضمام (بائیں بازو) ؛const shordrightArr = انضمام (رائٹ آر) ؛واپسی انضمام (shartedleftarr ، shortedrightArr) ؛} فنکشن انضمام (بائیں بازو: نمبر [] ، دائیں: نمبر []): نمبر [] {cont wargedar: نمبر [] = [] ؛بائیں بازو کی طرف چلیں = 0 ؛آئیے رائٹ انڈیکس = 0 ؛جبکہ (بائیں انڈیکس <بائیں بازو کی لمبائی && رائٹ انڈیکس <رائٹ آر. لمبائی) {اگر (بائیں بازو [بائیں انڈیکس] <رائٹ آئر [رائٹ انڈیکس]) {انضمام شدہ اے آر آر۔ پش (بائیں بازو [بائیں انڈیکس]) ؛بائیں انڈیکس ++ ؛} دوسری {انضمام.رائٹ انڈیکس ++ ؛}} // بائیں سرنی سے باقی عناصر شامل کریں جبکہ (بائیں انڈیکس <بائیں بازو کی لمبائی) {انضمام arr.push (lethar [lethar [lethindex]) ؛بائیں انڈیکس ++ ؛} // باقی عناصر کو دائیں صف سے شامل کریں جبکہ (رائٹ انڈیکس <رائٹ آر. لمبائی) {انضمام شدہ۔رائٹ انڈیکس ++ ؛} واپس انضمام}} // مثال کے طور پر استعمال: Const arr = [8 ، 4 ، 2 ، 7 ، 1 ، 5 ، 9 ، 3 ، 6] const const shordarr = انضمام (arr) ؛ کنسول.لوگ (ترتیبر) ؛// آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] اس مثال میں ، ہمارے دو کام ہیں: انضمام اور انضمام۔انضمام کی تقریب ایک صف لیتی ہے اور بار بار اس کو دو حصوں میں تقسیم کرتی ہے جب تک کہ بیس کیس تک نہ پہنچ جائے (یعنی ، صف میں صرف ایک یا صفر عناصر ہوتے ہیں)۔اس کے بعد یہ انضمام کی تقریب کا استعمال کرتے ہوئے ترتیب شدہ آدھےوں کو ضم کرتا ہے اور ترتیب شدہ صف کو واپس کرتا ہے۔ انضمام کی تقریب دو ترتیب شدہ صفوں (لیفٹیر اور رائٹ آر) لیتی ہے اور انہیں ایک ہی ترتیب شدہ صف میں ضم کرتی ہے۔یہ دونوں صفوں کے عناصر کا موازنہ کرتا ہے اور چھوٹے عنصر کو انضمام کرنے والی سرنی میں شامل کرتا ہے جب تک کہ تمام عناصر کو ضم نہیں کردیا جاتا۔ مثال کے طور پر استعمال کے حصے میں ، ہم غیر ترتیب شدہ عدد کے ساتھ ایک صف آر آر بناتے ہیں۔اس کے بعد ہم انضمام پر انضمام کو کال کرتے ہیں تاکہ انضمام کی کارکردگی کا مظاہرہ کیا جاسکے اور ترتیب شدہ نتیجہ کو ترتیب دیا گیا ہو۔آخر میں ، ہم کنسول میں ترتیب شدہ سرنی چھانٹری کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کراس توثیق کیا ہے اور مشین لرننگ میں یہ کیوں کارآمد ہے؟",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینی کوڈ {بچے: نقشہ <سٹرنگ ، ٹرائینوڈ> ؛isendofword: بولین ؛کنسٹرکٹر () {this.children = نیا نقشہ () ؛this.isendofword = غلط ؛class} کلاس ٹری {جڑ: ٹرائنوڈ ؛کنسٹرکٹر () {this.root = new trienode () ؛} داخل کریں (لفظ: سٹرنگ) {موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛if (! موجودہ.کرین. has (چار)) {موجودہ.چلرین.سیٹ (چار ، نیا ٹرائینوڈ ()) ؛} موجودہ = کرنٹ.کرینین.بیٹ (چار) !؛} موجودہ.Isendofword = سچ ؛} تلاش (لفظ: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛اگر (! موجودہ۔ چائلڈرین.ہاس (چار)) {غلط لوٹائیں ؛} موجودہ = کرنٹ.کرینین.بیٹ (چار) !؛current موجودہ. آئسنڈفورڈ کو لوٹائیں ؛} اسٹارٹ ویتھ (سابقہ: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <prefix.length ؛ i ++) {const char = prefix [i] ؛اگر (! موجودہ۔ چائلڈرین.ہاس (چار)) {غلط لوٹائیں ؛} موجودہ = کرنٹ.کرینین.بیٹ (چار) !؛} سچ واپس ؛}} // مثال کے طور پر استعمال: const trie = new trie () ؛ trie.insert (\"ایپل\") ؛ trie.insert (\"کیلے\") ؛ trie.insert (\"اورینج\") ؛ کنسول.لوگ (trie.search (trie.search (\"سیب\"))؛// آؤٹ پٹ: trueconsole.log (trie.search (\"کیلے\")) ؛// آؤٹ پٹ: trueconsole.log (trie.search (\"اورنج\")) ؛// آؤٹ پٹ: trueconsole.log (trie.search (\"انگور\")) ؛// آؤٹ پٹ: falseconsole.log (trie.startswith (\"app\")) ؛// آؤٹ پٹ: trueconsole.log (trie.startswith (\"پابندی\")) ؛// آؤٹ پٹ: trueconsole.log (trie.startswith (\"یا\")) ؛// آؤٹ پٹ: trueconsole.log (trie.startswith (\"GR\")) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہمارے پاس دو کلاس ہیں: ٹرینیوڈ اور ٹری۔ٹرائینوڈ ٹری میں ایک نوڈ کی نمائندگی کرتا ہے ، اور ٹری ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔ ٹرائینوڈ کلاس میں دو خصوصیات ہیں: بچے ، جو ایک ایسا نقشہ ہے جو موجودہ نوڈ کے بچوں کے نوڈس کو محفوظ کرتا ہے ، اور آئسنڈوف ورڈ ، جو اس بات کی نشاندہی کرتا ہے کہ آیا موجودہ نوڈایک لفظ کے اختتام کو نشان زد کرتا ہے۔ ٹری کلاس میں ایک پراپرٹی ، جڑ ہے ، جو ٹری کے جڑ نوڈ کی نمائندگی کرتی ہے۔اس کے پاس ٹرائی میں ایک لفظ داخل کرنے ، ٹرائی میں ایک لفظ تلاش کرنے کے لئے طریقے داخل کرنے ، تلاش کرنے اور شروع کرنے والے طریقے ہیں ، اور یہ چیک کریں کہ کیا ٹری میں کوئی لفظ یا سابقہ موجود ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ایک مثال تیار کرتے ہیں۔ٹرائی کلاس اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں تین الفاظ (\"ایپل\" ، \"کیلے\" ، \"اورینج\") داخل کریں۔اس کے بعد ہم یہ چیک کرنے کے لئے تلاش کے طریقہ کار کا مظاہرہ کرتے ہیں کہ آیا ٹرائی اور اسٹارٹ ویتھ کے طریقہ کار میں مخصوص الفاظ موجود ہیں یا نہیں یہ چیک کرنے کے لئے کہ آیا ٹرائی میں مخصوص سابقہ موجود ہیں یا نہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "مشین لرننگ میں باقاعدگی اور معمول پر لانے کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں یہاں ایک مثال پروگرام ہے جس کا تعین کرنے کے لئے کہ آیا بائنری ٹری متوازن ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن isbalanced (جڑ: ٹرینوڈ | null): بولین {اگر (جڑ ==== null) {سچ واپس ؛} const getheight = (نوڈ: treenode | null): نمبر => {اگر (نوڈ === null) {واپس 0 ؛} کونسٹ لیفٹ ہائٹ = getheight (node.left) ؛کانسٹ رائٹ ہائٹ = گیٹھائٹ (نوڈ. رائٹ) ؛واپس میتھ۔ میکس (بائیں بازو ، رائٹ ہائٹ) + 1 ؛} ؛const isbalancedhelper = (نوڈ: ٹرینوڈ | null): بولین => {اگر (نوڈ ==== null) {سچ واپس ؛} کونسٹ لیفٹ ہائٹ = getheight (node.left) ؛کانسٹ رائٹ ہائٹ = گیٹھائٹ (نوڈ. رائٹ) ؛کانس اونچائی ڈف = ریاضی۔ اے بی ایس (بائیں بازو - رائٹ ہائٹ) ؛اگر (اونچائی ڈف> 1) {غلط لوٹیں ؛} isbalancedhelper (node.left) && isbalancedhelper (node.right) واپس کریں ؛} ؛isbalancedhelper (جڑ)} // مثال کے طور پر استعمال: کانسٹ روٹ = نیا ٹرینوڈ (1) ؛ روٹ. لیفٹ = نیا ٹرینوڈ (2) ؛ روٹ. رائٹ = نیا ٹرینوڈ (3) ؛ روٹ.لفٹ!. لیفٹ = نیا ٹرینوڈ(4) root روٹ. لیفٹ!// آؤٹ پٹ: trueroot.right! .left = new Treenode (6) ؛ جڑ.ایچ!// آؤٹ پٹ: اس مثال کے طور پر ، ہمارے پاس ایک ٹرینوڈ کلاس ہے جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے۔isbalanced فنکشن بائنری درخت کی جڑ نوڈ کو ان پٹ کے طور پر لے جاتا ہے اور بولین کی قیمت کو لوٹاتا ہے جس سے یہ ظاہر ہوتا ہے کہ درخت متوازن ہے یا نہیں۔ گیٹائٹ فنکشن اس کے بائیں اور دائیں کی اونچائی کا حساب کتاب کرکے درخت میں دیئے گئے نوڈ کی اونچائی کا حساب لگاتا ہے۔سبٹری۔یہ بائیں اور دائیں سبٹریس کے درمیان زیادہ سے زیادہ اونچائی لوٹاتا ہے ، نیز 1. اس بیلنسڈ ہیلپر فنکشن چیک کرتا ہے اگر اس کے بائیں اور دائیں سبٹریوں کی اونچائیوں کا موازنہ کرکے نوڈ متوازن ہے۔اگر اونچائیوں کے مابین مطلق فرق 1 سے زیادہ ہے تو ، یہ غلط لوٹتا ہے۔بصورت دیگر ، یہ بار بار جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں سبٹریز متوازن ہیں۔ مثال کے طور پر استعمال کے حصے میں ، ہم نوڈس کے ساتھ بائنری ٹری بناتے ہیں اور اقدار تفویض کرتے ہیں۔اس کے بعد ہم اس بات کا تعین کرنے کے لئے روٹ نوڈ پر islanced فنکشن کو کال کرتے ہیں کہ درخت متوازن ہے یا نہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "مشین لرننگ میں فیچر اسکیلنگ کا مقصد کیا ہے اور کون سی تکنیک استعمال کی جاسکتی ہے؟",
        "Answer": "دو قطاروں کا استعمال کرتے ہوئے اسٹیک پر عمل درآمد عناصر کے مرکزی ذخیرہ کرنے کے لئے ایک قطار اور معاون کارروائیوں کے لئے دوسری قطار کا استعمال کرکے حاصل کیا جاسکتا ہے۔ٹائپ اسکرپٹ میں دو قطاروں کا استعمال کرتے ہوئے اسٹیک پر عمل درآمد یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسٹیک {مین کیوئو: نمبر [] ؛auxqueue: نمبر [] ؛کنسٹرکٹر () {this.mainqueue = [] ؛this.auxqueue = [] ؛} پش (ویلیو: نمبر) {// تمام عناصر کو مینکیو سے آکسکیو میں منتقل کریں جبکہ (this.mainqueue.length> 0) {this.auxqueue.push (this.mainqueue.shift ()!) ؛} // نئے عنصر کو mainqueue میں شامل کریں۔// تمام عناصر کو Auxqueue سے mainqueue پر واپس منتقل کریں جبکہ (this.auxqueue.length> 0) {this.mainqueue.push (this.auxqueue.shift ()!) ؛}} پاپ (): نمبر |غیر وضاحتی {اس کو واپس کریں۔} جھانکنے (): نمبر |غیر وضاحتی {اس کو واپس کریں۔} isempty (): بولین {واپس کریں۔} سائز (): نمبر {اس کو واپس کریں۔}} // مثال کے طور پر استعمال: کانسٹ اسٹیک = نیا اسٹیک () اسٹیک.پش (1) ؛ اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛ کنسول.لوگ (اسٹیک.پپ ()) ؛// آؤٹ پٹ: 3console.log (stack.peek ()) ؛// آؤٹ پٹ: 2console.log (stack.isempty ()) ؛// آؤٹ پٹ: falseconsole.log (stack.size ()) ؛// آؤٹ پٹ: 2 میں اس مثال کے طور پر ، ہمارے پاس ایک اسٹیک کلاس ہے جو اسٹیک آپریشنز کی تقلید کے لئے دو قطاریں (مین کیوئو اور آکسکیو) استعمال کرتی ہے۔ پش طریقہ اسٹیک میں ایک عنصر کو شامل کرتا ہے۔یہ سب سے پہلے تمام عناصر کو مین کیو سے آکسکیو کی طرف لے جاتا ہے ، پھر نئے عنصر کو مین کیوئ میں شامل کرتا ہے ، اور آخر کار تمام عناصر کو آکسکیو سے مین کیوئ کی طرف لے جاتا ہے۔اس سے یہ یقینی بنتا ہے کہ نیا عنصر ہمیشہ قطار کے سامنے والے حصے میں شامل کیا جاتا ہے ، جس سے اسٹیک کے طرز عمل کی نقالی ہوتی ہے۔ پاپ کا طریقہ کار مین کیوئ کے پاپ طریقہ کا استعمال کرکے اسٹیک سے اوپر عنصر کو ہٹاتا ہے اور واپس کرتا ہے۔ جھانکنے کا طریقہ اوپر لوٹاتا ہے۔اسٹیک کا عنصر مین کیوئ کے آخری عنصر تک رسائی حاصل کرکے اسے ہٹائے بغیر۔ آئی ایس ای ٹی ایم پی طریقہ چیک کرتا ہے کہ اگر اسٹیک مین کیوئ کی لمبائی کی جانچ کر کے خالی ہے۔mainqueue.in مثال کے استعمال کے حصے میں ، ہم اسٹیک کلاس کی ایک مثال تیار کرتے ہیں ، تین عناصر کو اسٹیک پر دھکیل دیتے ہیں ، اور پاپ ، جھانکنے ، آئسیمپٹی اور سائز کو کال کرکے اسٹیک کی کارروائیوں کا مظاہرہ کرتے ہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "K-nearrest پڑوسیوں (KNN) الگورتھم اور اس کے اہم پیرامیٹرز کی وضاحت کریں۔",
        "Answer": "یقینا!کڈانے کے الگورتھم کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ سبریے کی رقم تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن میکسبرسمم (اے آر آر: نمبر []): نمبر {آئیے میکسم = آر آر [0] ؛آئیے کرینٹسم = آر آر [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {کرینٹسم = math.max (arr [i] ، کرینٹسم+arr [i]) ؛میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛max میکسم واپسی} // مثال کے طور پر استعمال: کانسٹ سرنی = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] ؛ کانسٹ میکسم = میکسبرسم (سرنی) ؛ کنسول.لاگ (میکسم (میکسم)) ؛// آؤٹ پٹ: 6 ان مثال کے طور پر ، میکسبرارسم فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور زیادہ سے زیادہ سبری کا مجموعہ واپس کرتا ہے۔فنکشن زیادہ سے زیادہ رقم کو موثر انداز میں تلاش کرنے کے لئے کڈانے کے الگورتھم کا استعمال کرتا ہے۔ الگورتھم دو متغیرات کی ابتدا کرتا ہے: میکسم اور کرینسم ، دونوں صف کے پہلے عنصر پر سیٹ کرتے ہیں۔اس کے بعد یہ دوسرے عنصر سے شروع ہونے والی صف کے ذریعے تکرار کرتا ہے۔ ہر عنصر کے ل it ، یہ نئے کرینٹسم کا حساب کتاب موجودہ عنصر کی زیادہ سے زیادہ یا موجودہ عنصر کے طور پر کرتا ہے جس میں پچھلے کرینٹسم میں شامل کیا جاتا ہے۔یہ قدم طے کرتا ہے کہ آیا نیا سبری شروع کرنا یا موجودہ سبری کو جاری رکھنا فائدہ مند ہے۔ میکسم متغیر کو اب تک پائے جانے والے زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے ہر تکرار پر اپ ڈیٹ کیا جاتا ہے۔ لوپ کے اختتام پر ، میکسم متغیر میں زیادہ سے زیادہ سبریئر رقم ہوتی ہے ،جس کے بعد اس کو واپس کردیا گیا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم انٹیجرز کے ساتھ ایک سرنی سرنی بناتے ہیں اور زیادہ سے زیادہ سبراے رقم تلاش کرنے کے لئے سرے پر میکسبرسم فنکشن کو کال کرتے ہیں۔نتیجہ کنسول پر چھپا ہوا ہے۔"
    },
    {
        "Question": "بائنری درجہ بندی میں صحت سے متعلق اور یاد کے درمیان کیا فرق ہے؟",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ میں بائنری ہیپ ڈیٹا ڈھانچے (خاص طور پر ایک کم سے کم HEAP) کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بائنری ہیپ {ہیپ: نمبر [] ؛کنسٹرکٹر () {this.heap = [] ؛} getleftChildIndex (پیرنٹ انڈیکس: نمبر): نمبر {واپسی 2 * پیرنٹ انڈیکس + 1 ؛} getRightChildIndex (پیرنٹ انڈیکس: نمبر): نمبر {واپسی 2 * پیرنٹ انڈیکس + 2 ؛} getParentIndex (ChildIndex: نمبر): نمبر {ریٹرن میتھ.فلور ((چائلڈ انڈیکس - 1) / 2) ؛} ہاسلفائلڈ (انڈیکس: نمبر): بولین {واپس کریں۔} ہاس رائٹچائلڈ (انڈیکس: نمبر): بولین {اس کو واپس کریں۔ گیٹ رائٹچلڈ انڈیکس (انڈیکس) <this.heap.length ؛} ہاسپینٹ (انڈیکس: نمبر): بولین {اس کو واپس کریں۔ گیٹ پیرینٹ انڈیکس (انڈیکس)> = 0 ؛} بائیں بچے (انڈیکس: نمبر): نمبر {اس کو واپس کریں۔} رائٹائڈ (انڈیکس: نمبر): نمبر {اس کو واپس کریں۔} والدین (انڈیکس: نمبر): نمبر {اس کو واپس کریں۔} تبادلہ (انڈیکس 1: نمبر ، انڈیکس 2: نمبر): باطل {const temp = this.heap [index1] ؛this.heap [index1] = this.heap [index2] ؛this.heap [index2] = عارضی ؛} جھانکنے (): نمبر |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛this اس کو واپس کریں۔ ہیپ [0] ؛} پول (): نمبر |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛} const آئٹم = this.heap [0] ؛this.heap [0] = this.heap [this.heap.length - 1] ؛this.heap.pop () ؛this.heapifydown () ؛آئٹم واپس ؛} شامل کریں (آئٹم: نمبر): باطل {this.heap.push (آئٹم) ؛this.heapifyup () ؛} ہیپیف اپ (): باطل {آئیے انڈیکس = this.heap.length - 1 ؛جبکہ (this.hasparent (index) && this.parent (index)> this.heap [index]) {cont parentindex = this.getParentIndex (انڈیکس) ؛this.swap (پیرنٹ انڈیکس ، انڈیکس) ؛انڈیکس = پیرنٹ انڈیکس ؛}} ہیپیفائ ڈاون (): باطل {آئیے انڈیکس = 0 ؛جبکہ (this.hasleftchild (index)) small smallerchild index = this.getleftchildindex (انڈیکس) ؛اگر (this.hasrightائلڈ (انڈیکس) && this.righticald (index) <this.leftchild (index)) {smallerchild index = this.getRightChildindex (انڈیکس) ؛} if (this.heap [index] <this.heap [smallerchildindex]) {بریک ؛} else {this.swap (انڈیکس ، smallerchildindex) ؛} انڈیکس = چھوٹے بچے}}} // مثال کے طور پر استعمال: کانسٹ ہیپ = نیا بائنری ہیپ () ؛ ہیپ.اڈ (5) ؛ ہیپ.اڈڈ (3) ؛ ہیپ.اڈ (8) ؛ ہیپ.اڈ (1) ؛ ہیپ.اڈ (9)؛ کنسول.لاگ (ہیپ.پول ()) ؛// آؤٹ پٹ: 1console.log (ہیپ.پول ()) ؛// آؤٹ پٹ: 3console.log (ہیپ.پیک ()) ؛// آؤٹ پٹ: 5 اس مثال کے طور پر ، ہمارے پاس بائنری ہیپ کلاس ہے جو بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس نفاذ میں خاص طور پر ایک کم سے کم عنصر پر توجہ دی جاتی ہے ، جہاں کم سے کم عنصر ہمیشہ جڑ میں ہوتا ہے۔ کلاس میں بائیں بچے ، دائیں بچے ، والدین اور ڈھیر میں عناصر کے اشارے تک رسائی حاصل کرنے کے طریقے شامل ہیں۔یہ ڈھیر (ADD) میں عناصر شامل کرنے ، جڑ عنصر (پول) کو بازیافت اور ہٹانے ، اور جڑ عنصر پر جھانکنے کے لئے بھی طریقے مہیا کرتا ہے۔"
    },
    {
        "Question": "جہتی کمی کے تصور کی وضاحت کریں اور اس مقصد کے لئے استعمال ہونے والی تکنیک کی ایک مثال دیں۔",
        "Answer": "یقینا!کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک سٹرنگ تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل عرصے سے پالندروومکسبسٹرنگ (ایس: سٹرنگ): سٹرنگ {آئیے شروع کریں = 0 ؛آئیے زیادہ سے زیادہ = 0 ؛// ایک سینٹر کانسٹرینڈ سینٹر = (بائیں: نمبر ، دائیں: نمبر) کے ارد گرد پھیلانے کے لئے ہیلپر فنکشن: باطل => {جبکہ (بائیں> = 0 && دائیں <s.length && s [بائیں] === s [دائیں]) {Const موجودہ لمبائی = دائیں - بائیں + 1 ؛اگر (موجودہ لمبائی> زیادہ سے زیادہ لمبائی) {اسٹارٹ = بائیں ؛maxlength = موجودہ لمبائی ؛}      بائیں--؛حق ++ ؛}} ؛کے لئے (آئیے i = 0 ؛ i <s.length ؛ i ++) {توسیعی ساؤنڈ سینٹر (i ، i) ؛// عجیب لمبائی پیلنڈرووم وسعت کا مرکز (i ، i + 1) ؛// یہاں تک کہ لمبائی کی لمبائی palindrome} واپسی s.substring (شروع کریں ، start + maxlength) ؛} // مثال کے طور پر استعمال: کانسٹ ان پٹ = \"باباڈ\" ؛ کانسٹنٹ طویل ترینپال انڈرووم = طویل ترینپال انڈروومکسوبسٹرنگ (ان پٹ) ؛ کنسول.لاگ (طویل ترین پالندرووم) ؛// آؤٹ پٹ: \"باب\" اس مثال میں ، سب سے طویل پالائنڈرومکسبسٹرنگ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور ایس کے اندر سب سے طویل پیلنڈرومک اسٹرنگ لوٹاتا ہے۔ فنکشن پیلنڈرمک سبسٹرنگز کو تلاش کرنے کے لئے کسی مرکز کے گرد پھیلنے کے تصور کو استعمال کرتا ہے۔یہ تار میں ہر کردار کے ذریعے تکرار کرتا ہے اور اسے کسی ممکنہ پیلنڈرووم کا مرکز سمجھتا ہے۔اس کے بعد یہ مرکز سے باہر کی طرف پھیلتا ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دونوں اطراف کے کردار برابر ہیں۔یہ مستقل طور پر جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں حرف برابر ہیں اور ونڈو کو اس وقت تک پھیلاتے ہیں جب تک کہ حروف اب برابر نہ ہوں یا تار ختم نہ ہوں۔لمبائی پیلنڈرووم (دو حروف کے درمیان مرکز)۔اس میں تمام ممکنہ پیلنڈرومک سبسٹرنگز کا احاطہ کیا گیا ہے۔ لوپ کے بعد ، فنکشن اسٹارٹ انڈیکس سے میکس لمبائی کی لمبائی کے ساتھ سٹرنگ لوٹاتا ہے ، جو ان پٹ سٹرنگ میں پائے جانے والے سب سے طویل پیلنڈرومک اسٹرنگ کی نمائندگی کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ایک نمونہ ان پٹ سٹرنگ فراہم کرتے ہیں۔ان پٹ اور اس پر طویل ترین پالندومکسبسٹرنگ فنکشن کو کال کریں۔نتیجہ ، سب سے طویل پیلنڈرومک اسٹرنگ ، کنسول پر چھاپتا ہے۔"
    },
    {
        "Question": "اعصابی نیٹ ورکس میں چالو کرنے کے افعال کا کیا کردار ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں گراف کی نمائندگی کرنے کے لئے ملحقہ میٹرکس کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ میٹرکس: نمبر [] [] ؛کنسٹرکٹر (نمبر: نمبر) {this.adjacencymatrix = [] ؛کے لئے (i = 0 ؛ i <numvertices ؛ i ++) {this.adjacencymatrix [i] = [] ؛کے لئے (j = 0 ؛ j <numvertices ؛ j ++) {this.adjacencymatrix [i] [j] = 0 ؛}}} ایڈجڈ (ماخذ: نمبر ، منزل: نمبر): باطل {this.adjacencymatrix [ماخذ] [منزل] = 1 ؛this.adjacencymatrix [منزل] [ماخذ] = 1 ؛} ریمجج (ماخذ: نمبر ، منزل: نمبر): باطل {this.adjacencymatrix [ماخذ] [منزل] = 0 ؛this.adjacencymatrix [منزل] [ماخذ] = 0 ؛} پرنٹ گراف (): باطل {کے لئے (i = 0 ؛ i <this.adjacencymatrix.length ؛ i ++) {const row = this.adjacencymatrix [i] ؛کنسول.لاگ (قطار.جوئن ('')) ؛}}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف (5) ؛ گراف.ڈیج (0 ، 1) ؛ گراف.ڈیج (0 ، 4) ؛ گراف.ڈیج (1 ، 2) ؛ گراف.ڈیج (1 ، 1 ،3) ؛ گراف.ڈیج (1 ، 4) گراف.ڈیج (2 ، 3) ؛ گراف.اڈیج (3 ، 4) ؛ گراف.پنٹ گراف () ؛ اس مثال میں ، گراف کلاس ملحقہ میٹرکس کا استعمال کرتے ہوئے گراف کی نمائندگی کرتا ہے. کنسٹرکٹر ان پٹ کے طور پر عمودی کی تعداد لیتا ہے اور تمام اقدار کے ساتھ ایک خالی ملحق میٹرکس کو شروع کرتا ہے۔ملحقہ میٹرکس میں متعلقہ اندراجات کو 0. پر ترتیب دے کر دو عمودی کے درمیان غیر مستقیم کنارے گراف کی ملحقہ میٹرکس کی نمائندگی کو کنسول پر پرنٹ کرتا ہے۔اس کے بعد ہم ایڈج کے طریقہ کار کا استعمال کرتے ہوئے متعدد کناروں کو شامل کرتے ہیں اور پرنٹ گراف کے طریقہ کار کا استعمال کرتے ہوئے ملحقہ میٹرکس پرنٹ کرتے ہیں۔نتیجے میں ملحقہ میٹرکس کنسول ڈاٹ نوٹ میں ظاہر ہوتا ہے: مذکورہ بالا عمل درآمد ایک غیر ہدایت شدہ گراف فرض کرتا ہے ، جہاں کنارے دو طرفہ ہیں۔اگر آپ کو ہدایت شدہ گراف کی نمائندگی کرنے کی ضرورت ہے تو ، آپ ہر ہدایت والے کنارے کے لئے ملحقہ میٹرکس میں صرف ایک اندراج طے کرنے کے لئے ایڈج اور ہٹانے کے طریقوں میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "عصبی نیٹ ورکس کی تربیت میں بیک پروپیگیشن الگورتھم اور اس کی اہمیت کی وضاحت کریں۔",
        "Answer": "یقینا!ایک درخت پر گہرائی سے پہلے تلاش (DFS) انجام دینے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بچے: ٹرینوڈ [] ؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.children = [] ؛} ایڈچائڈ (بچہ: ٹرینوڈ): باطل {this.children.push (بچہ) ؛}} فنکشن ڈی ایف ایس (نوڈ: ٹرینوڈ): باطل {کنسول.لوگ (نوڈ.والیو) ؛کے لئے (نوڈ. بچوں کا بچ child ہ) {DFS (بچہ) ؛}} // مثال کے طور پر استعمال: کانسٹ روٹ = نیا ٹرینوڈ (1) const کنٹڈ چلڈ 1 = نیا ٹرینوڈ (2) ؛ کانسٹ چلڈ 2 = نیا ٹرینوڈ (3) ؛ کنسٹ پوتے 1 = نیا ٹرینوڈ (4) ؛ کنسٹ پوتے 2 = نیا ٹرینوڈ (5) ؛ روٹ.اڈائڈائڈ (چائلڈ 1) ؛ روٹ.اڈڈائڈ (چائلڈ 2) ؛ چائلڈ 1۔ڈیڈچائلڈ (پوتے 1) ؛ چائلڈ 2۔اڈڈچائلڈ (پوتے 2) ؛ ڈی ایف ایس (روٹ) ؛ اس مثال میں ، ہمارے پاس درخت میں نوڈ کی نمائندگی کرنے والا ایک ٹرینوڈ کلاس ہے۔ہر نوڈ میں بچوں کی نوڈس کی ایک قدر اور ایک صف ہوتی ہے۔ ایڈڈائڈ کا طریقہ بچوں کو بچوں کی صف میں دھکیل کر بچوں کے نوڈس کو شامل کرنے کی اجازت دیتا ہے۔ ڈی ایف ایس فنکشن درخت پر گہرائی کی پہلی تلاش کرتا ہے۔یہ ان پٹ کے طور پر ایک نوڈ لیتا ہے اور موجودہ نوڈ کی قیمت پرنٹ کرکے شروع ہوتا ہے۔اس کے بعد ، یہ موجودہ نوڈ کے ہر بچے پر ڈی ایف ایس کو بار بار کال کرتا ہے ، جس سے درخت کو مؤثر طریقے سے گہرائی سے پہلے کی تلاش ہوتی ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ٹرینوڈ کی مثال بنا کر اور ایڈڈچڈ کے طریقہ کار کا استعمال کرتے ہوئے ان کو جوڑ کر درخت کا ڈھانچہ بناتے ہیں۔اس کے بعد ہم گہرائی سے پہلے تلاش کرنے کے لئے روٹ نوڈ پر ڈی ایف ایس کو کال کرتے ہیں۔نوڈس کی اقدار کنسول پر چھاپے جاتے ہیں ، جو درخت کی گہرائی سے پہلے ٹراورسل کا مظاہرہ کرتے ہیں۔ نوٹ: یہ مثال درختوں کی ایک عام ڈھانچہ فرض کرتی ہے جہاں ہر نوڈ میں بہت سے بچے ہوسکتے ہیں۔اگر آپ کے پاس درختوں کا مخصوص ڈھانچہ ہے تو ، آپ ٹرینوڈ کلاس اور اس کے مطابق مثال کے استعمال میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "تدریجی نزول کیا ہے اور اس کو مشین لرننگ میں کس طرح استعمال کیا جاتا ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں راہ کمپریشن کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے (جسے یونین-فنڈ ڈیٹا ڈھانچہ بھی کہا جاتا ہے) کے ایک مثال کے طور پر عمل درآمد: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.palent = [] ؛this.rank = [] ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {this.palent [x] = this.find (this.palent [x]) ؛// راستہ کمپریشن} اس کو واپس کریں۔ پیرنٹ [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (روٹ ایکس! == روٹ) {اگر (this.rank [روٹ ایکس] <this.rank [روٹ]) {this.palent [روٹ ایکس] = روٹ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}}} // مثال کے طور پر استعمال: کونسٹ ڈی ایس = نیا ڈسیوئنٹ سیٹ (5) ؛ ڈی ایس یون (0 ، 2) ؛ ڈی ایس یون (4 ، 2) ؛ ڈی ایس (3 ، 1) ؛ کنسول.لوگ (ڈی ایس (ڈی ایس.find (4) === ds.find (0)) ؛// آؤٹ پٹ: trueconsole.log (ds.find (1) === ds.find (2)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ناگوار طبقے کی کلاس راہ کمپریشن کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔ کنسٹرکٹر ناگوار سیٹ کا ابتدائی سائز لیتا ہے اور والدین کی صف اور درجہ بندی کی صف کو شروع کرتا ہے۔والدین کی صف میں ہر عنصر متعلقہ عنصر کے والدین کی نمائندگی کرتا ہے ، اور رینک سرنی ہر عنصر کے درجہ (یا اونچائی) کو اسٹور کرتا ہے۔ تلاش کرنے کا طریقہ اس ناپسندیدہ سیٹ کی جڑ تلاش کرتا ہے جس سے ایکس کا تعلق ہے۔یہ ہر ملاحظہ کرنے والے عنصر کے والدین کو جڑ سے بار بار اپ ڈیٹ کرکے راہ کمپریشن کا استعمال کرتا ہے ، جو درخت کو چپٹا کرنے اور مستقبل کی تلاش کو بہتر بنانے میں مدد کرتا ہے۔ یونین کا طریقہ دو متنازعہ سیٹوں کا اتحاد انجام دیتا ہے جس میں عناصر X اور Y پر مشتمل ہوتا ہے۔اس کو پہلے تلاش کے طریقہ کار کا استعمال کرتے ہوئے سیٹوں کی جڑیں مل جاتی ہیں۔اگر جڑیں مختلف ہیں تو ، یہ ان کی صفوں کا موازنہ کرتا ہے اور جڑ کو نچلے درجے کے ساتھ دوسری جڑ کے والدین بناتا ہے۔اگر درجات برابر ہیں تو ، یہ من مانی طور پر والدین کی حیثیت سے ایک جڑ کا انتخاب کرتا ہے اور اس کے درجہ میں اضافہ ہوتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم 5 کے سائز کے ساتھ ڈس ڈیسپیٹ کلاس کی ایک مثال تیار کرتے ہیں۔چیک کریں کہ آیا کچھ عناصر تلاش کے طریقہ کار کا استعمال کرتے ہوئے ایک ہی سیٹ سے تعلق رکھتے ہیں۔نتائج کنسول پر چھاپے جاتے ہیں ، جو راستے کے کمپریشن کے ساتھ ناپسندیدہ سیٹ ڈیٹا ڈھانچے کی فعالیت کا مظاہرہ کرتے ہیں۔"
    },
    {
        "Question": "جوڑنے والے سیکھنے کے تصور کی وضاحت کریں اور جوڑے کے طریقہ کار کی مثال دیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک مثال پروگرام یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی گراف بائپارٹائٹ ہے: ٹائپ اسکرپٹ کوپی کوڈینم رنگ {غیر رنگین = 0 ، سرخ = 1 ، بلیو = 2 ،} فنکشن آئس بپارٹائٹ (گراف: نمبر [] []): بولین {کانسٹ این = گراف. لمبائی ؛رنگین رنگ: رنگ [] = سرنی (این)کانسٹ ڈی ایف ایس = (نوڈ: نمبر ، رنگ: رنگ): بولین => {رنگ [نوڈ] = رنگ ؛کے لئے (گراف کے پڑوسی [نوڈ]) {اگر (رنگ [پڑوسی] === رنگ) {غلط لوٹیں ؛// ایک ہی رنگ کے ساتھ ملحقہ نوڈس پائے گئے ، بائپارٹائٹ نہیں} if (رنگ [پڑوسی] === رنگین۔// تکرار والی کال غلط لوٹ گئی ، بائپارٹائٹ نہیں}} سچ واپس ؛} ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اگر (رنگ [i] === color.uncolored &&! dfs (i ، color.red)) {غلط واپس ؛// ایک منسلک جزو ملا جو دو طرفہ نہیں ہے}} سچ واپس ؛// تمام منسلک اجزاء بائپارٹائٹ ہیں} // مثال کے طور پر استعمال: کانسٹ گراف 1 = [[1 ، 3] ، [0 ، 2] ، [1 ، 3] ، [0 ، 2]] ؛// بائپارٹائٹ گرافکنسول.لوگ (isbipartite (گراف 1)) ؛// آؤٹ پٹ: trueconst گراف 2 = [[1 ، 2 ، 3] ، [0 ، 2] ، [1 ، 3] ، [0 ، 2]] ؛// نہیں بائپارٹائٹ گرافکنسول.لوگ (isbipartite (گراف 2)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، isbipartite فنکشن ایک گراف لیتا ہے جس کی نمائندگی ملحقہ فہرست (گراف) کی حیثیت سے ہوتی ہے اور اگر گراف دو طرفہ اور غلط ہے تو صحیح لوٹتا ہے۔دو رنگوں سے رنگین رہیں جیسے کسی ملحقہ نوڈس کا رنگ ایک ہی نہیں ہوتا ہے۔ رنگین اینوم نوڈس کے لئے تین ممکنہ رنگوں کی وضاحت کرتا ہے: غیر رنگین ، سرخ اور نیلے رنگ۔غیر رنگین رنگ اس بات کی نشاندہی کرتا ہے کہ ابھی تک نوڈ کا رنگ نہیں ہوا ہے۔ ڈی ایف ایس مددگار فنکشن گہرائی کی پہلی تلاش کرتا ہے۔یہ ان پٹ کے طور پر ایک نوڈ اور رنگ لیتا ہے۔یہ موجودہ نوڈ کو مخصوص رنگ کے ساتھ رنگ دیتا ہے اور اپنے پڑوسیوں پر ڈی ایف ایس کو بار بار کال کرتا ہے ، اس بات کو یقینی بناتا ہے کہ وہ مخالف رنگ (3 - رنگ) کے ساتھ رنگین ہیں۔اگر اس کا سامنا کسی پڑوسی سے ہوتا ہے جو پہلے ہی ایک ہی رنگ کے ساتھ رنگین ہوچکا ہے تو ، یہ غلط لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ گراف دو طرفہ نہیں ہے۔اگر ایک بار بار چلنے والی کال غلط لوٹتی ہے تو ، فنکشن بھی غلط لوٹاتا ہے۔ اس بائپارٹائٹ فنکشن کی اہم منطق گراف میں ہر نوڈ کے ذریعے تکرار کرتی ہے۔اگر ابھی تک نوڈ کا رنگ نہیں ہوا ہے (رنگین۔اگر ڈی ایف ایس کے دوران کوئی منسلک جزو دو طرفہ نہیں پایا جاتا ہے تو ، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، اگر تمام منسلک اجزاء کامیابی کے ساتھ رنگین ہیں اور کوئی تنازعات نہیں پائے جاتے ہیں تو ، فنکشن سچ کو واپس کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم دو مثال گراف (گراف 1 اور گراف 2) فراہم کرتے ہیں۔ہم ہر گراف پر isbipartite فنکشن کہتے ہیں اور نتائج کو کنسول پر پرنٹ کرتے ہیں ، مختلف گرافوں کے لئے دو طرفہ چیک کا مظاہرہ کرتے ہیں۔"
    },
    {
        "Question": "جوڑنے کی تعلیم میں بیگنگ اور فروغ دینے میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بلوم فلٹر {بٹیرے: بولین [] ؛numhashfunctions: نمبر ؛کنسٹرکٹر (سائز: نمبر ، نمبر ہاشفکشن: نمبر) {this.bitarray = نیا سرنی (سائز). فل (غلط) ؛this.numhashfunctions = numhashfunctions ؛} شامل کریں (عنصر: سٹرنگ): باطل {کانسٹ ہیش = this.gethashes (عنصر) ؛کے لئے (ہیش کا ہیش) {this.bitarray [ہیش] = سچ ؛}} پر مشتمل ہے (عنصر: سٹرنگ): بولین {کانسٹ ہیش = this.gethashes (عنصر) ؛کے لئے (ہیش کا ہیش) {اگر (! this.bitarray [ہیش]) {جھوٹی لوٹ ؛}} سچ واپس ؛} نجی گیٹشیس (عنصر: سٹرنگ): نمبر [] {کانسٹ ہیش: نمبر [] = [] ؛کے لئے (آئیے i = 1 ؛ i <= this.numhashfunctions ؛ i ++) {const hash = this.hash (عنصر ، i) ؛ہیش۔ پش (ہیش) ؛} ہیشوں کی واپسی ؛} نجی ہیش (عنصر: سٹرنگ ، بیج: نمبر): نمبر {آئیے ہیش = 0 ؛کے لئے (آئیے i = 0 ؛ i <عنصری. لمبائی ؛ i ++) {ہیش = (ہیش * بیج+عنصر۔ charcodeat (i)) ٪ this.bitarray.length ؛} ہیش کی واپسی ؛}} // مثال کے طور پر استعمال: کانسٹ فلٹر = نیا بلوم فلٹر (100 ، 3) ؛ فلٹر.اڈ ('ایپل') ؛ فلٹر.اڈ ('کیلے') ؛ فلٹر.اڈڈ ('چیری') ؛ کنسول.لوگ (فلٹر (فلٹر.کونٹینز ('ایپل')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.کونٹینز ('کیلے')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.کونٹینز ('چیری')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.کونٹینز ('انگور')) ؛// آؤٹ پٹ: اس مثال کے طور پر ، بلوم فلٹر کلاس ایک سے زیادہ ہیش فنکشنز کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ کنسٹرکٹر دو پیرامیٹرز لیتا ہے: سائز (بٹ سرنی کا سائز) اور نمبرشفکشن (استعمال کرنے کے لئے ہیش افعال کی تعداد).شامل کرنے کا طریقہ بلوم فلٹر میں عنصر شامل کرتا ہے۔یہ گیٹشیس کے طریقہ کار کا استعمال کرتے ہوئے عنصر کے لئے متعدد ہیشوں کا حساب لگاتا ہے اور بٹ سرنی میں متعلقہ پوزیشنوں کو سچ پر سیٹ کرتا ہے۔ اگر کوئی عنصر بلوم فلٹر میں موجود ہے تو اس کا طریقہ چیک کرتا ہے۔یہ جیٹھاشس کے طریقہ کار کا استعمال کرتے ہوئے عنصر کے لئے ہیشوں کا حساب لگاتا ہے اور چیک کرتا ہے کہ کیا بٹ سرنی میں تمام متعلقہ پوزیشنیں درست ہیں۔اگر کوئی پوزیشن غلط ہے تو ، یہ غلط لوٹتی ہے۔بصورت دیگر ، یہ سچ لوٹتا ہے۔ گیٹشیس کا طریقہ مختلف بیجوں کی اقدار کے لئے ہیش کے طریقہ کار کو طلب کرکے کسی عنصر کے لئے متعدد ہیشوں کا حساب لگاتا ہے۔ ہیش کا طریقہ مخصوص بیج کا استعمال کرتے ہوئے کسی عنصر کے لئے ہیش کی قیمت کا حساب لگاتا ہے۔یہ عنصر کے ہر کردار کے ذریعے تکرار کرتا ہے ، ایک سادہ ہیشنگ الگورتھم (ضرب اور ماڈیولو) انجام دیتا ہے ، اور اس کے نتیجے میں ہیش ویلیو کو لوٹاتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم بلوم فلٹر کلاس کی ایک مثال بناتے ہیں جس میں 100 اور 3 کے تھوڑا سا سرنی سائز ہوتا ہے۔ہیش کے افعال.ہم ADD کے طریقہ کار کا استعمال کرتے ہوئے فلٹر میں تین عناصر شامل کرتے ہیں اور پھر چیک کریں کہ آیا اس میں شامل طریقہ کار کا استعمال کرتے ہوئے فلٹر میں کئی عناصر موجود ہیں یا نہیں۔بلوم فلٹر کی فعالیت کا مظاہرہ کرتے ہوئے نتائج کنسول پر چھاپے جاتے ہیں۔"
    },
    {
        "Question": "متن کی درجہ بندی کے کاموں کے ل natural قدرتی زبان پروسیسنگ (این ایل پی) میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!ہدایت شدہ ایسائکلک گراف (ڈی اے جی) پر ٹوپولوجیکل ترتیب دینے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: نقشہ <نمبر ، نمبر []> ؛کنسٹرکٹر () {this.adjacencyList = نیا نقشہ <نمبر ، نمبر []> () ؛} ایڈورٹیکس (ورٹیکس: نمبر): باطل {if (! this.adjacencylist.has (vertex)) {this.adjacencylist.set (vertex ، []) ؛}} ایڈج (سے: نمبر ، سے: نمبر): باطل {اگر (! this.adjacencylist.has (منجانب) ||گراف. ') ؛} کنسٹ پڑوسی = this.adjacencyList.get (منجانب) ؛پڑوسی۔ پش (سے) ؛} ٹوپولوجسٹسورٹ (): نمبر [] {کنسٹٹ ملاحظہ کریں: سیٹ <نمبر> = نیا سیٹ <نمبر> () ؛کانسٹ اسٹیک: نمبر [] = [] ؛کانسٹ ڈی ایف ایس = (ورٹیکس: نمبر): باطل => {ملاحظہ کیا گیا۔ ایڈ (ورٹیکس) ؛کنسٹ پڑوسی = this.adjacencyList.get (ورٹیکس) ؛اگر (پڑوسی) {کے لئے (پڑوسیوں کے پڑوسی) {اگر (! ملاحظہ کیا گیا۔ (پڑوسی)) {ڈی ایف ایس (پڑوسی) ؛}}} اسٹیک.پش (ورٹیکس) ؛} ؛کے لئے (اس کی کانسٹریکس۔ adjacencylist.keys ()) {اگر (! ملاحظہ کیا گیا۔ ہاس (ورٹیکس)) {DFS (ورٹیکس) ؛}} ریٹرن اسٹیک۔ ریورس () ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈورٹیکس (1) ؛ گراف.اڈورٹیکس (2) ؛ گراف.اڈورٹیکس (3) ؛ گراف.اڈورٹیکس (4) ؛ گراف.اڈورٹیکس (5) ؛گراف.اڈورٹیکس (6) ؛ گراف.ڈیج (1 ، 2) ؛ گراف.اڈیج (1 ، 3) ؛ گراف.ڈیج (2 ، 3) ؛ گراف.اڈیج (2 ، 4) ؛ گراف.اڈیج (3 ، 5) ؛ گراف.اڈیج (4 ، 6) ؛ گراف.ڈیج (5 ، 6) ؛ ترتیب ترتیب دیں// آؤٹ پٹ: [1 ، 2 ، 4 ، 3 ، 5 ، 6] اس مثال میں ، گراف کلاس ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرتا ہے۔اس میں ایک ملحقہ فہرست ہے جو ہر ایک کو اپنے پڑوسیوں کی فہرست میں نقشہ بناتی ہے۔ ایڈورٹیکس کا طریقہ کار ہمسایہ ممالک کی خالی صف کے ساتھ ملحقہ فہرست میں داخلہ بنا کر گراف میں ایک ورٹیکس کو شامل کرتا ہے۔ ایڈجڈ کا طریقہ ایک ورٹیکس سے ہدایت شدہ کنارے کو شامل کرتا ہے (سے) کسی دوسرے ورٹیکس (to) سے لے کر پڑوسیوں کی فہرست میں شامل کرکے۔ ٹوپولوجسٹسورٹ کا طریقہ ٹوپولوجیکل ترتیب دیتا ہے۔یہ گراف کو دریافت کرنے کے لئے گہرائی میں پہلی تلاش (DFS) نقطہ نظر کا استعمال کرتا ہے اور ان کے آخری اوقات کے الٹ ترتیب میں اسٹیک میں عمودی کو شامل کرتا ہے۔ایک عمودی وقت کے آخری وقت کی وضاحت اس وقت کے طور پر کی جاتی ہے جب اسے اپنے تمام پڑوسیوں سے ملنے کے بعد اسٹیک پر دھکیل دیا جاتا ہے۔آخر میں ، یہ ٹوپولوجیکل آرڈرنگ حاصل کرنے کے لئے اسٹیک کو الٹ ترتیب میں لوٹاتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ایک گراف مثال بناتے ہیں اور ڈی اے جی کی نمائندگی کرنے کے لئے عمودی اور کناروں کو شامل کرتے ہیں۔اس کے بعد ہم ٹوپولوجیکل سارٹ طریقہ کو ٹوپولوجیکل ترتیب دینے اور ترتیب شدہ عمودی کو حاصل کرنے کے لئے کال کرتے ہیں۔ترتیب شدہ عمودی کنسول پر چھاپے جاتے ہیں ، جس میں گراف کی ٹوپولوجیکل قسم کا مظاہرہ ہوتا ہے۔"
    },
    {
        "Question": "عدم توازن والے ڈیٹاسیٹس کو سنبھالنے میں کیا اہم چیلنجز ہیں اور ان سے کیسے خطاب کیا جاسکتا ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں K-D ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {نقطہ: نمبر [] ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (نقطہ: نمبر []) {this.Point = نقطہ ؛this.left = null ؛this.right = null ؛}} کلاس kdtree {جڑ: Treenode |خالی؛طول و عرض: نمبر ؛کنسٹرکٹر (طول و عرض: نمبر) {this.root = null ؛this.dimensions = طول و عرض ؛} داخل کریں (نقطہ: نمبر []): باطل {this.root = this.insertnode (this.root ، نقطہ ، 0) ؛} نجی Insertnode (نوڈ: ٹرینوڈ | null ، نقطہ: نمبر [] ، گہرائی: نمبر): ٹرینوڈ {اگر (نوڈ ==== null) {واپس نیا ٹرینوڈ (نقطہ) واپس کریں ؛const کنٹین کرنٹ ڈیمینشن = گہرائی ٪ اس۔اگر (نقطہ [موجودہ تدوین] <نوڈ.پوائنٹ [کرنٹ ڈیمینشن]) {node.left = this.insertnode (node.left ، نقطہ ، گہرائی + 1) ؛} else {node.right = this.insertnode (node.right ، نقطہ ، گہرائی + 1) ؛} واپسی نوڈ ؛} تلاش (نقطہ: نمبر []): بولین {اس کو واپس کریں۔ سرچنوڈ (یہ.روٹ ، پوائنٹ ، 0) ؛} نجی سرچ نوڈ (نوڈ: ٹرینوڈ | NULL ، نقطہ: نمبر [] ، گہرائی: نمبر): بولین {اگر (نوڈ ==== null) {غلط واپس ؛} if (this.arepointseal (node.Point ، نقطہ)) {سچ واپس ؛const کنٹین کرنٹ ڈیمینشن = گہرائی ٪ اس۔اگر (نقطہ [موجودہ جہت] <نوڈ.پوائنٹ [کرنٹ ڈیمینشن]) this اس کو واپس لوٹائیں۔} else {اس کی سرچ نوڈ (نوڈ.رائٹ ، پوائنٹ ، گہرائی + 1) واپس کریں ؛priective} پرائیویٹ سیکوئل (پوائنٹ 1: نمبر [] ، پوائنٹ 2: نمبر []): بولین {کے لئے (i = 0 ؛ i <this.dimensions ؛ i ++) {اگر (پوائنٹ 1 [i]! == پوائنٹ 2 [i]){جھوٹا لوٹ ؛}} سچ واپس ؛}} // مثال کے طور پر استعمال: کانسٹ kdtree = new kdtree (2) ؛ kdtree.insert ([3 ، 6]) ؛ kdtree.insert ([17 ، 15]) ؛ kdtree.insert ([13 ، 15]) ؛ kdtree.INSERT ([6 ، 12]) ؛ kdtree.insert ([9 ، 1]) ؛ kdtree.insert ([2 ، 7]) ؛ کنسول.لوگ (kdtree.search ([6 ، 12]) ؛// آؤٹ پٹ: trueconsole.log (kdtree.search ([13 ، 15])) ؛// آؤٹ پٹ: trueconsole.log (kdtree.search ([10 ، 10])) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ٹرینوڈ کلاس K-D درخت میں نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں طول و عرض کی لمبائی ، ایک بائیں بچے اور دائیں بچے کا ایک نقطہ ہوتا ہے۔ Kdtree کلاس K-D درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ ہے اور درخت میں طول و عرض کی تعداد ہے۔ داخل کرنے کا طریقہ INSERTNODE کے طریقہ کار کو کال کرکے K-D کے درخت میں ایک نیا نقطہ داخل کرتا ہے۔INSERTNODE کا طریقہ درخت کو بار بار عبور کرتا ہے ، موجودہ جہت کی اقدار کا موازنہ کرتا ہے تاکہ اس بات کا تعین کیا جاسکے کہ آیا بائیں یا دائیں سب ٹری میں نقطہ داخل کرنا ہے یا نہیں۔گہرائی کا استعمال درخت کی ہر سطح پر موجودہ جہت کا تعین کرنے کے لئے کیا جاتا ہے۔ تلاش کا طریقہ کار سرچنوڈ کے طریقہ کار کو کال کرکے K-D درخت میں دیئے گئے نقطہ کی تلاش کرتا ہے۔سرچنوڈ کا طریقہ درخت کو بار بار عبور کرتا ہے ، بائیں یا دائیں سب ٹری پر تشریف لے جانے کے لئے موجودہ جہت کی اقدار کا موازنہ کرتا ہے۔اگر نقطہ پایا جاتا ہے تو ، یہ سچ واپس آجاتا ہے۔ورنہ ،"
    },
    {
        "Question": "کراس اینٹروپی نقصان کے فنکشن کے تصور اور تربیت کی درجہ بندی کے ماڈلز میں اس کے کردار کی وضاحت کریں۔",
        "Answer": "یقینا!بائنری درخت میں دو نوڈس کے سب سے کم عام اجداد کو تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن سب سے کم کامونانسیسٹر (جڑ: ٹرینوڈ | نول ، پی: ٹرینوڈ ، Q: ٹرینوڈ): ٹرینوڈ |null {if (جڑ === null || جڑ === p || جڑ === Q) {روٹ روٹ ؛} کانسٹ بائیں = سب سے کم کامونانسیسٹر (روٹ. لیفٹ ، پی ، کیو) ؛کونٹ رائٹ = کم ترین کامونانسیسٹر (جڑ۔ رائٹ ، پی ، کیو) ؛اگر (بائیں! == null && دائیں! == null) {روٹ روٹ ؛left بائیں طرف لوٹ! == null؟بائیں: دائیں ؛} // مثال کے طور پر استعمال: کانسٹ روٹ = نیا ٹرینوڈ (3) ؛ روٹ. لیفٹ = نیا ٹرینوڈ (5) ؛ روٹ. رائٹ = نیا ٹرینوڈ (1) ؛ روٹ.لفٹ.لفٹ = نیا ٹرینوڈ (6)؛ روٹ. لیفٹ۔ رائٹ = نیا ٹرینوڈ (2) ؛ روٹ۔ رائٹ.لیفٹ = نیا ٹرینوڈ (0) ؛ روٹ. رائٹ. رائٹ = نیا ٹرینوڈ (8) ؛ روٹ.لفٹ.رائٹ.لیفٹ = نیا ٹرینوڈ (7)؛ root.left.right.right = new Treenode (4) ؛ const p = root.left ؛// قیمت کے ساتھ نوڈ// قیمت کے ساتھ نوڈ// آؤٹ پٹ: 5 اس مثال کے طور پر ، ٹرینوڈ کلاس بائنری درخت میں نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں اس کے بائیں اور دائیں بچوں کی قدر اور حوالہ ہوتا ہے۔ سب سے کم کامکومنانسٹر فنکشن تین پیرامیٹرز لیتا ہے: بائنری ٹری کی جڑ اور دو نوڈس پی اور کیو جس کے لئے ہم سب سے کم عام آباؤ اجداد تلاش کرنا چاہتے ہیں۔یہ بائنری کے درخت کو عبور کرنے کے لئے ایک بار بار نقطہ نظر استعمال کرتا ہے۔ ہر نوڈ پر ، یہ چیک کرتا ہے کہ آیا موجودہ نوڈ یا تو P یا Q ہے یا null ہے۔اگر ایسا ہے تو ، یہ موجودہ نوڈ کو سب سے کم عام آباؤ اجداد کے طور پر لوٹاتا ہے۔غیر نول اقدار ، اس کا مطلب یہ ہے کہ پی اور کیو مختلف سب ٹریوں میں موجود ہیں ، اور موجودہ نوڈ سب سے کم عام آباؤ اجداد ہے۔بصورت دیگر ، یہ نان نول سب ٹری کے نتائج یا کالعدم کو واپس کرتا ہے اگر دونوں سب ٹریوں کی مثال کے طور پر استعمال کے حصے میں ، ہم ایک بائنری ٹری بناتے ہیں اور اسے اقدار کے ساتھ شروع کرتے ہیں۔ہم درخت کے اندر دو نوڈس کے طور پر پی اور کیو کی وضاحت کرتے ہیں۔اس کے بعد ہم ان کے سب سے کم عام آباؤ اجداد کو تلاش کرنے کے لئے جڑوں اور دو نوڈس کے ساتھ سب سے کم کامونانسیسٹر فنکشن کہتے ہیں۔سب سے کم عام آباؤ اجداد نوڈ کی قدر کنسول پر چھپی ہوئی ہے۔"
    },
    {
        "Question": "ہائپر پیرامیٹر ٹیوننگ کا مقصد کیا ہے اور اسے مؤثر طریقے سے کیسے کیا جاسکتا ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک سپلیپ ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {کلید: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (کلید: نمبر) {this.key = key ؛this.left = null ؛this.right = null ؛}} کلاس splaytree {جڑ: Treenode |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (کلید: نمبر): باطل {اگر (this.root === null) {this.root = نیا ٹرینوڈ (کلید) ؛واپسی ؛} this.splay (کلید) ؛اگر (کلید <this.root.key) {const newnode = نیا ٹرینوڈ (کلید) ؛newnode.left = this.root.left ؛newnode.right = this.root ؛this.root.left = null ؛this.root = newnode ؛} دوسری صورت میں اگر (key> this.root.key) {const newnode = new Treenode (key) ؛newnode.right = this.root.right ؛newnode.left = this.root ؛this.root.right = null ؛this.root = newnode ؛}} تلاش (کلید: نمبر): بولین {this.splay (key) ؛اس کو واپس کریں!} نجی سپلی (کلید: نمبر): باطل {اگر (this.root === null || this.root.key === key) {واپسی ؛} کنسٹ ڈمی: ٹرینوڈ = {کلید: 0 ، بائیں: NULL ، دائیں: null} ؛بائیں طرف جانے دیں = ڈمی ؛آئیے رائٹ مین = ڈمی ؛آئیے موجودہ نوڈ = this.root ؛جبکہ (سچ ہے) {اگر (کلید <موجودہ نوڈ.کی) {اگر (موجودہ نوڈ.لفٹ ==== null) {بریک ؛} if (key <موجودہ نوڈ.لفٹ.کی) {const temp = pertionnode.left ؛موجودہ نوڈ.لفٹ = ٹیمپ. رائٹ ؛temp.right = موجودہ نوڈ ؛موجودہ نوڈ = عارضی ؛اگر (موجودہ نوڈ.لفٹ === null) {بریک ؛}} رائٹرمین.لفٹ = کرنٹ نوڈ ؛رائٹرمین = کرنٹ نوڈ ؛موجودہ نوڈ = کرنٹنوڈ.لفٹ ؛} دوسری صورت میں اگر (key> reverthynode.key) {if (currentnode.right ==== null) {بریک ؛} if (key> reverthynode.right.key) {const temp = retighternode.right ؛موجودہ نوڈ۔ رائٹ = temp.left ؛temp.left = موجودہ نوڈ ؛موجودہ نوڈ = عارضی ؛اگر (موجودہ نوڈ۔ رائٹ === null) {بریک ؛}} بائیں ٹری میکس۔ رائٹ = کرنٹ نوڈ ؛بائیں ٹری میکس = کرنٹ نوڈ ؛کرنٹنوڈ = کرنٹنوڈ. رائٹ ؛} دوسری {بریک ؛}} بائیں ٹری میکس. رائٹ = کرنٹنوڈ.لفٹ ؛رائٹرمین.لفٹ = کرنٹنوڈ. رائٹ ؛موجودہ نوڈ. لیفٹ = ڈمی. رائٹ ؛موجودہ نوڈ۔ رائٹ = dummy.left ؛this.root = موجودہ نوڈ ؛}} // مثال کے طور پر استعمال: Const splaytree = new splaytree () spla splaytree.insert (10) ؛ splaytree.insert (5) ؛ splaytree.insert (15) ؛ splaytree.insert (3) ؛ splaytree.insert (8) ؛splaytree.insert (12) ؛ splaytree.insert (17) ؛ کنسول.لوگ (splaytree.search (8)) ؛// آؤٹ پٹ: trueconsole.log (splaytree.search (12)) ؛// آؤٹ پٹ: trueconsole.log (splaytree.search (20)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ٹرینوڈ کلاس سپلی کے درخت میں ایک نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں ایک کلید ، اس کے بائیں بچے کا حوالہ ، اور اس کے دائیں بچے کا حوالہ ہوتا ہے۔ اسپلٹری کلاس اسپلٹ ٹری کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ ہے۔ داخل کرنے کا طریقہ سپلے کے درخت میں ایک نئی کلید داخل کرتا ہے"
    },
    {
        "Question": "کلسٹرنگ کے عمل کی وضاحت کریں اور کلسٹرنگ الگورتھم کی مثال دیں۔",
        "Answer": "نیٹ ورک کے بہاؤ کے مسئلے میں زیادہ سے زیادہ بہاؤ تلاش کرنے کے ل you ، آپ فورڈ فلکرسن الگورتھم یا اس کی ایک مختلف حالتوں ، جیسے ایڈمنڈس-کارپ الگورتھم یا ڈائنک کے الگورتھم کا استعمال کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں ایڈمنڈس کارپ الگورتھم کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {نجی گراف: نمبر [] [] ؛کنسٹرکٹر (گراف: نمبر [] []) {this.graph = گراف ؛bified نجی بی ایف ایس (ماخذ: نمبر ، ہدف: نمبر ، والدین: نمبر []): بولین {کنسٹٹ ملاحظہ کریں = نئی سرنی (اس. گراف.لنتھ). فل (غلط) ؛کانسٹ قطار: نمبر [] = [] ؛قطار.پش (ماخذ) ؛دورہ [ماخذ] = سچ ؛والدین [ماخذ] = -1 ؛جبکہ (قطار۔ لمبائی> 0) {کونسٹ یو = قطار۔ شفٹ () !؛کے لئے (آئیے v = 0 ؛ v <this.graph.length ؛ v ++) {اگر (! ملاحظہ کیا [v] && this.graph [u] [v]> 0) {قطار.پش (v) ؛دورہ [v] = سچ ؛والدین [v] = u ؛}}} واپسی کا دورہ [ہدف] ؛} نجی منکاسیٹی (راستہ: نمبر [] ، والدین: نمبر []): نمبر {آئیے منٹ کیپاسیٹی = انفینٹی ؛آئیے v = راستہ [راستہ۔ لمبائی - 1] ؛جبکہ (v! == 0) {const u = والدین [v] ؛mincapacity = math.min (mincapacity ، this.graph [u] [v]) ؛v = u ؛min mincapacity واپس ؛} نجی اپڈیٹرسیڈیول گراف (راستہ: نمبر [] ، والدین: نمبر [] ، منکاسیٹی: نمبر): باطل {چلو v = راستہ [راستہ۔ لمبائی - 1] ؛جبکہ (v! == 0) {const u = والدین [v] ؛this.graph [u] [v] -= mincapacity ؛this.graph [v] [u] += mincapacity ؛v = u ؛}} پبلک میکس فلو (ماخذ: نمبر ، ہدف: نمبر): نمبر {مستقل والدین: نمبر [] = نیا سرنی (اس.گراف.لنتھ) ؛آئیے زیادہ سے زیادہ = 0 ؛جبکہ (this.bfs (ماخذ ، ہدف ، والدین)) {const mincapacity = this.mincapacity ([ہدف] ، والدین) ؛this.updateresidual گراف ([ہدف] ، والدین ، mincapacity) ؛میکس فلو += mincapacity ؛} میکس فلو کی واپسی ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = [[0 ، 16 ، 13 ، 0 ، 0 ، 0] ، [0 ، 0 ، 10 ، 12 ، 0 ، 0] ، [0 ، 4 ، 0 ، 0 ، 14 ، 14 ،0] ، [0 ، 0 ، 9 ، 0 ، 0 ، 20] ، [0 ، 0 ، 0 ، 7 ، 0 ، 4] ، [0 ، 0 ، 0 ، 0 ، 0 ، 0 ، 0] ،] ؛ کانس نیٹ ورک =نیا گراف (گراف) Const کانسٹر ماخذ = 0 Const کنٹ ٹارگٹ = 5 ؛ کانسٹ میکس فلو = نیٹ ورک۔ میکس فلو (ماخذ ، ہدف) ؛ کنسول.لوگ (\"زیادہ سے زیادہ بہاؤ:\" ، زیادہ سے زیادہ فلو) ؛ اس مثال میں ، گراف کلاس اس کی نمائندگی کرتا ہےنیٹ ورک فلو گراف۔گراف پراپرٹی ایک دو جہتی صف ہے جو نوڈس کے درمیان کناروں کی صلاحیتوں کو محفوظ کرتی ہے۔ بی ایف ایس کا طریقہ کار سے لے کر ہدف تک بڑھانے والا راستہ تلاش کرنے کے لئے چوڑائی کی پہلی تلاش کرتا ہے۔اگر اس طرح کا راستہ موجود ہے اور مختصر ترین راستے کے ساتھ والدین کی صفوں کو اپ ڈیٹ کرتا ہے تو یہ سچ واپس آتا ہے۔ منکاسیٹی کا طریقہ کار بڑھانے والے راستے کے ساتھ کم سے کم صلاحیت کا تعین کرتا ہے۔ اپڈیٹیرسیڈیول گراف طریقہ راستے کو بڑھانے کے بعد بقایا گراف کی صلاحیتوں کو اپ ڈیٹ کرتا ہے۔"
    },
    {
        "Question": "جنریٹو اور امتیازی ماڈلز میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں مستقل اسٹیک ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسٹیک نوڈ <T> {قدر: t ؛اگلا: اسٹیک نوڈ <t> |خالی؛کنسٹرکٹر (ویلیو: ٹی ، اگلا: اسٹیک نوڈ <T> | null) {this.value = value ؛this.next = اگلا ؛class} کلاس مستقل اسٹیک <t> {نجی ورژن: {[کلید: نمبر]: اسٹیک نوڈ <T> |خالی }؛نجی تازہ ترین تبدیلی: نمبر ؛کنسٹرکٹر () {this.versions = {} ؛this.latestversion = 0 ؛یہ۔} پش (ویلیو: ٹی): باطل {کونٹ کرنٹورشن = this.latestversion ؛Const موجودہ ہیڈ = یہ۔کونسٹ نیو ہیڈ = نیا اسٹیک نوڈ (ویلیو ، کرنٹ ہیڈ) ؛this.latestversion ++ ؛یہ۔} پاپ (): باطل {کونٹ کرنٹ ورسن = this.latestversion ؛Const موجودہ ہیڈ = یہ۔اگر (موجودہ ہیڈ === null) {واپسی ؛} this.latestversion ++ ؛یہ۔} ٹاپ (): ٹی |null {const hethead = this.versions [this.latestversion] ؛موجودہ ہیڈ واپس! == کالعدم؟موجودہ ہیڈ. ویلیو: null ؛} getVersion (ورژن: نمبر): t [] {CONST نتیجہ: t [] = [] ؛موجودہ ہیڈ = یہ۔جبکہ (کرنٹ ہیڈ! == null) {نتیجہ۔ پش (موجودہ ہیڈ.Value) ؛موجودہ ہیڈ = کرنٹ ہیڈ. نیکسٹ ؛} واپسی کا نتیجہ ؛}} // مثال کے طور پر استعمال: کانسٹ اسٹیک = نیا مستقل اسٹیک <نمبر> () ؛ اسٹیک.پش (1) ؛ اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛ کونسٹ ورژن 1 = اسٹیک۔ لیٹسٹورشن ؛ کنسول.لاگ (کنسول.لاگ (stac.getVersion (ورژن 1)) ؛// آؤٹ پٹ: [1 ، 2 ، 3] اسٹیک.پپ () ؛ کنسٹ ورژن 2 = اسٹیک۔ لیٹسٹورشن ؛ کنسول.لوگ (اسٹیک.یٹ گیٹورسیشن (ورژن 2)) ؛// آؤٹ پٹ: [1 ، 2] اسٹیک.پش (4) ؛ کنسٹ ورژن 3 = اسٹیک۔ لیٹسٹورشن ؛ کنسول.لوگ (اسٹیک.یٹ گیٹ انورژن (ورژن 3)) ؛// آؤٹ پٹ: [1 ، 2 ، 4] کنسول.لوگ (اسٹیک.جیٹ وینس (ورژن 1)) ؛// آؤٹ پٹ: [1 ، 2 ، 3] کنسول.لاگ (اسٹیک. ٹاپ ()) ؛// آؤٹ پٹ: 4 ان مثال کے طور پر ، اسٹیک نوڈ کلاس اسٹیک میں نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں اسٹیک میں اگلے نوڈ کا ایک قدر اور ایک حوالہ ہوتا ہے۔ مستقل اسٹیک کلاس اسٹیک ڈیٹا ڈھانچے کو مستقل طور پر نافذ کرتا ہے۔یہ اسٹیک کے مختلف ورژن کو ذخیرہ کرنے کے لئے ایک لغت (ورژن) استعمال کرتا ہے۔ہر ورژن ایک منفرد ورژن نمبر کے ساتھ وابستہ ہے۔ پش طریقہ ایک نیا نوڈ بنا کر اور اسٹیک کے تازہ ترین ورژن کو اپ ڈیٹ کرکے اسٹیک میں ایک نئی قدر کا اضافہ کرتا ہے۔ پاپ طریقہ کار کے تازہ ترین ورژن کو اپ ڈیٹ کرکے اسٹیک سے ٹاپ عنصر کو ہٹا دیتا ہے۔اسٹیک۔ اوپر کا طریقہ تازہ ترین ورژن میں اسٹیک کے اوپری عنصر کی قدر لوٹاتا ہے۔ گیٹ ویورشن کا طریقہ نوڈس کو عبور کرکے اور اقدار کی ایک صف کو واپس کرکے اسٹیک کا ایک مخصوص ورژن بازیافت کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم تخلیق کرتے ہیں۔ایک مستقل اسٹیک ، اس پر اقدار کو دھکیلیں ، اور گیٹ ویورشن کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے مختلف ورژن بازیافت کریں۔ہم اوپر کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے اوپری عنصر تک رسائی حاصل کرنے کی صلاحیت کا بھی مظاہرہ کرتے ہیں۔"
    },
    {
        "Question": "منتقلی سیکھنے کے تصور کی وضاحت کریں اور یہ مشین لرننگ میں کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "دو ڈوروں کے مابین مختصر ترین مشترکہ بالادستی تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ استعمال کرسکتے ہیں۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن شارسٹ کامنس اپرسیئنسی (str1: سٹرنگ ، str2: سٹرنگ): سٹرنگ {const m = str1.length ؛const n = str2.length ؛// مشترکہ سپرسیوینسس کانس ڈی پی کی لمبائی کو ذخیرہ کرنے کے لئے ایک ٹیبل بنائیں: نمبر [] [] = [] ؛// ٹیبل کو شروع کریں (آئیے i = 0 ؛ i <= m ؛ i ++) {dp [i] = نئی سرنی (n+1). فل (0) ؛} // (i = 1 ؛ i <= m ؛ i ++) {for (j = 1 ؛ j <= n ؛ j ++) {if (str1 [i - 1] === str2 [j- 1]) {dp [i] [j] = 1 + dp [i - 1] [j - 1] ؛} else {dp [i] [j] = math.max (dp [i - 1] [j] ، dp [i] [j - 1]) ؛table}}} // ٹیبل کا استعمال کرتے ہوئے مختصر ترین عام سپرسیئینس کی تعمیر کریں ، سپرسیئنس = \"\" ؛i = m ؛j = n ؛جبکہ (i> 0 && j> 0) {اگر (str1 [i - 1] === str2 [j - 1]) {supressequence = str1 [i - 1] + سپرسیونسی ؛میں--؛J-- ؛} دوسری صورت میں (dp [i - 1] [j]> dp [i] [j - 1]) {supresequence = str1 [i - 1] + سپرسیئینس ؛میں--؛} else {supersequence = str2 [j - 1] + سپرسیئینس ؛J-- ؛}} // str1 سے باقی حروف شامل کریں جبکہ (i> 0) {supersequence = str1 [i - 1] + سپرسیئنس ؛میں--؛} // str2 سے باقی حروف شامل کریں جبکہ (j> 0) {supersequence = str2 [j - 1] + سپرسیئینس ؛J-- ؛sup سپرسیئنس کی واپسی ؛} // مثال کے طور پر استعمال: کانسٹ str1 = \"aggtab\" ؛ const str2 = \"gxtxayb\" ؛ const const const ould = shortscommonsupersequence (str1 ، str2) ؛ کنسول.لوگ (\"مختصر ترین مشترکہ صابن:\" ، نتیجہ) ؛ اس میں ؛مثال کے طور پر ، شارسٹ کامنس اپریسیوینس فنکشن دو ڈور لیتا ہے ، STR1 اور STR2 ، کیونکہ ان پٹ اور مختصر ترین عام سپرسیئنس کو لوٹاتا ہے۔ فنکشن STR1 اور STR2 کے مشترکہ سپرسیوینس کی لمبائی کے ساتھ ایک ٹیبل (DP) کو بھرنے کے لئے متحرک پروگرامنگ نقطہ نظر کا استعمال کرتا ہے۔ٹیبل کو نچلے حصے میں بھرا ہوا ہے ، جس میں ہر پوزیشن پر STR1 اور STR2 کے کرداروں کا موازنہ کیا جاتا ہے۔ ٹیبل کو بھرنے کے بعد ، فنکشن ٹیبل کے نیچے دائیں کونے سے بیک ٹریک کرتے ہوئے مختصر ترین مشترکہ بالادستی کی تعمیر کرتا ہے۔یہ STR1 اور STR2 کے کرداروں کا موازنہ کرتا ہے اور فیصلہ کرتا ہے کہ آیا کردار کو سپرسیئنس میں شامل کیا جائے یا زیادہ سے زیادہ لمبائی کے ساتھ ملحقہ سیل میں منتقل کیا جائے۔دو مثال کے تاروں (str1 اور str2) کے ساتھ مختصر ترین کامنسپرسیکوینس فنکشن۔اس کے نتیجے میں کم ترین مشترکہ سپرسیئنس کنسول پر چھپی ہوئی ہے۔"
    },
    {
        "Question": "تصویری درجہ بندی کے لئے مجازی اعصابی نیٹ ورک (CNN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "لاحقہ درخت کو نافذ کرنا ایک پیچیدہ کام ہے ، لیکن میں آپ کو شروع کرنے کے لئے ایک جائزہ اور کوڈ ٹیمپلیٹ فراہم کرسکتا ہوں۔ٹائپ اسکرپٹ میں ایک لاحقہ درخت کا بنیادی نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس لاحقہ لاحقہ لاحقہ {بچے: {[کلید: سٹرنگ]: لاحقہ اسٹرینوڈ} ؛شروع کریں: نمبر ؛اختتام: نمبر ؛کنسٹرکٹر (شروع: نمبر ، اختتام: نمبر) {this.children = {} ؛this.start = start ؛this.end = end ؛} ایڈائلڈ (کلید: سٹرنگ ، نوڈ: لاحقہ): باطل {this.children [key] = نوڈ ؛} گیٹائڈ (کلید: سٹرنگ): لاحقہ اسٹرینوڈ |غیر وضاحتی {اس کو واپس کریں۔ بچوں [کلید] ؛} ہاسچلڈ (کلید: سٹرنگ): بولین {اس میں ریٹرن کلید۔ بچوں ؛}} کلاس لاحقہ {جڑ: لاحقہ ؛متن: تار ؛کنسٹرکٹر (متن: سٹرنگ) {this.text = متن ؛this.root = نیا لاحقہ اسٹرینوڈ (-1 ، -1) ؛this.buildtree () ؛} بلڈ ٹری (): باطل {const n = this.text.length ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {موجودہ = this.root ؛کے لئے (j = i ؛ j <n ؛ j ++) {const key = this.text [j] ؛اگر (موجودہ۔} else {const newnode = نیا لاحقہ اسٹرینوڈ (j ، n - 1) ؛موجودہ.اڈائڈائڈ (کلید ، نیو نوڈ) ؛موجودہ = newnode ؛}}}} تلاش (پیٹرن: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <پیٹرن. لمبائی ؛ i ++) {const key = پیٹرن [i] ؛اگر (موجودہ۔} دوسری {جھوٹی لوٹ ؛}} سچ واپس ؛}} // مثال کے طور پر استعمال: کانسٹ ٹیکسٹ = \"کیلے\" ؛ کانسٹ لازمی = نیا لاحقہ (متن) ؛ کنسول.لوگ (لاحقہ۔ سرچ (\"این اے\")) ؛// آؤٹ پٹ: trueconsole.log (لاحقہ. search (\"ana\")) ؛// آؤٹ پٹ: trueconsole.log (لاحقہ۔ سرچ (\"انا\")) ؛// آؤٹ پٹ: trueconsole.log (لاحقہ۔ سرچ (\"ایپل\")) ؛// آؤٹ پٹ: اس مثال کے طور پر ، لاحقہ لاحقہ کلاس لاحقہ درخت میں ایک نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں سبسٹرنگ کے آغاز اور اختتامی پوزیشنوں اور اس کے بچوں کے نوڈس کا نقشہ کے بارے میں معلومات ہوتی ہے۔ لاحقہ کلاس لاحقہ درخت کے ڈیٹا ڈھانچے کو نافذ کرتا ہے۔اس میں ایک روٹ نوڈ اور ایک ٹیکسٹ پراپرٹی ہے جو اصل متن کی نمائندگی کرتی ہے۔ بلڈ ٹری کا طریقہ متن میں ہر کردار پر تکرار کرکے اور درخت میں شامل کرکے لاحقہ درخت کی تعمیر کرتا ہے۔جب ضروری ہو تو یہ نئے نوڈس تیار کرتا ہے اور موجودہ نوڈ کو اپ ڈیٹ کرتا ہے کیونکہ یہ درخت کو عبور کرتا ہے۔ تلاش کا طریقہ لاحقہ درخت میں دیئے گئے نمونہ کی تلاش کرتا ہے۔یہ جڑ سے شروع ہوتا ہے اور اس راستے کی پیروی کرتا ہے جو پیٹرن کے کرداروں سے ملتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم \"کیلے\" کے متن سے ایک لاحقہ درخت بناتے ہیں اور کچھ تلاشیں کرتے ہیں تاکہ یہ معلوم کیا جاسکے کہ درخت میں کچھ نمونے موجود ہیں یا نہیں۔یہ ایک لاحقہ درخت کا بنیادی نفاذ ہے ، اور زیادہ اعلی درجے کی افادیت جیسے اسٹرنگ کے سوالات کو سنبھالنا ، سب سے طویل عام سٹرنگ تلاش کرنا ، یا میموری کے استعمال کو بہتر بنانا آپ کی ضروریات کے مطابق شامل کیا جاسکتا ہے۔"
    },
    {
        "Question": "درجہ بندی کے کاموں کے لئے فیصلہ کن درختوں کے استعمال کے فوائد اور نقصانات کیا ہیں؟",
        "Answer": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ استعمال کرسکتے ہیں۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفیکیشن طویل ترین پلائنڈرمکسوبسینس (ایس ٹی آر: سٹرنگ): سٹرنگ {const n = str.length ؛کانسٹ ڈی پی: نمبر [] [] = [] ؛// ٹیبل کو شروع کریں (آئیے i = 0 ؛ i <n ؛ i ++) {dp [i] = نیا سرنی (n). فل (0) ؛ڈی پی [i] [i] = 1 ؛// ایک ہی کردار لمبائی 1} // کے لئے ٹیبل کو نیچے کے انداز میں بھریں (لین = 2 ؛ لین <= n ؛ لین ++) {کے لئے (i = 0 ؛ i <n - لین+)1 ؛ i ++) {const j = i+لین - 1 ؛اگر (str [i] === str [j] && لین === 2) {dp [i] [j] = 2 ؛} ورنہ اگر (str [i] === str [j]) {dp [i] [j] = dp [i + 1] [j - 1] + 2 ؛} else {dp [i] [j] = math.max (dp [i] [j - 1] ، dp [i + 1] [j]) ؛}}} // سب سے طویل palindromic متضاد کی تشکیل نو i = 0 ؛آئیے j = n - 1 ؛چلو متنازعہ = '' ؛جبکہ (i <j) {if (str [i] === str [j]) {متضاد += str [i] ؛i ++ ؛J-- ؛} ورنہ اگر (dp [i] [j-1]> dp [i + 1] [j]) {j-- ؛} else {i ++ ؛}} // اگر تار کی لمبائی عجیب ہے تو ، درمیانی کردار کو شامل کریں اگر (i === j) {متضاد += str [i] ؛} کے بعد کی واپسی ؛} // مثال کے طور پر استعمال: کانسٹٹر = 'کریکٹر' ؛ کانسٹ طویل عرصے سے سب سے طویل عرصے سے ترتیب = طویل ترینپالائنڈروومکسوبسینس (ایس ٹی آر) ؛ کنسول.لوگ ('سب سے طویل پیلائنڈروومک مشترکہ:' ، طویل عرصے سے تعی .ن) ؛ اس مثال میں ، سب سے طویل عرصے سے ، سب سے طویل عرصے تک ، ایک تاریک ترین فنکشن ایک تار کی تار لیتا ہے ،چونکہ ان پٹ اور لوٹاتا ہے۔ٹیبل کو نیچے کی طرف بھر دیا جاتا ہے ، مختلف لمبائیوں کے ذیلی ذخیروں پر غور کرتے ہوئے اور یہ جانچتے ہوئے کہ آیا سروں کے حروف برابر ہیں یا نہیں۔ ٹیبل کو بھرنے کے بعد ، فنکشن ٹیبل کے اوپری دائیں کونے سے بیک ٹریک کرکے سب سے طویل پیلنڈرومک متضاد کی تشکیل نو کرتا ہے۔یہ ایس ٹی آر کے کرداروں کا موازنہ کرتا ہے اور فیصلہ کرتا ہے کہ آیا اس کردار کو بعد میں شامل کرنا ہے یا زیادہ سے زیادہ لمبائی کے ساتھ ملحقہ سیل میں منتقل ہونا ہے۔مثال کے طور پر سٹرنگ (ایس ٹی آر) کے ساتھ کام کریں۔اس کے نتیجے میں سب سے طویل پیلنڈرومک متضاد کنسول پر چھاپتا ہے۔"
    },
    {
        "Question": "کمک سیکھنے کے تصور کی وضاحت کریں اور کسی درخواست کی مثال دیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں رینک اور راہ کے کمپریشن کے ذریعہ یونین کے ساتھ ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.rank = نئی صف (سائز) ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {// راستہ کمپریشن: پائے جانے والے جڑ کو x کا والدین بنائیں۔. والدین [x]) ؛this اس کو واپس کریں۔ والدین [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (روٹ ایکس! == روٹ) {// یونین بذریعہ درجہ: لمبے درخت کو لمبے درخت کی جڑ سے جوڑیں اگر (this.rank [روٹکس] <this.rank [روٹ]) {this.pearnt [روٹ ایکس] =جڑ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}} isconnected (x: نمبر ، Y: نمبر): بولین {اس کو واپس کریں۔}} // مثال کے طور پر استعمال: کونسٹ ڈی ایس = نیا ڈسیوئنٹسیٹ (5) ؛ ڈی ایس یون (0 ، 1) ؛ ڈی ایس یون (2 ، 3) ؛ ڈی ایس یون (1 ، 4) ؛ کنسول.لوگ (ds.isconced(0 ، 4)) ؛// آؤٹ پٹ: trueconsole.log (ds.isconnected (2 ، 4)) ؛// آؤٹ پٹ: اس پر عمل درآمد کو غلط ، ناکارہ طبقے کی کلاس ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں دو صفیں ہیں: ہر عنصر کے والدین کو ذخیرہ کرنے کے لئے والدین اور ہر عنصر کے درخت کی درجہ بندی (تخمینہ گہرائی) کو ذخیرہ کرنے کے لئے۔ یہ کنسٹرکٹر والدین کی صف کو اس طرح شروع کرتا ہے کہ ہر عنصر ابتدائی طور پر اس کا اپنا والدین ہوتا ہے ، اور درجہ بندی ابتدائی طور پر ہوتی ہے۔تمام زیرو۔ تلاش کرنے کا طریقہ اس سیٹ کی جڑ (نمائندہ) تلاش کرتا ہے جس میں دیئے گئے عنصر X کا تعلق ہے۔فائنڈ آپریشن کے دوران ، پائے جانے والے جڑ کو مستقبل کی تلاش کے ل X کا براہ راست والدین بنانے کے لئے پاتھ کمپریشن کا اطلاق کیا جاتا ہے ، جو درختوں کے ڈھانچے کو چپٹا کرنے میں مدد کرتا ہے۔ یونین کا طریقہ کار X اور Y کے ذریعہ نمائندگی کرنے والے دو سیٹوں کا اتحاد انجام دیتا ہے۔اس کو پہلے تلاش کے طریقہ کار کا استعمال کرتے ہوئے سیٹوں کی جڑیں مل جاتی ہیں۔اس کے بعد ، یہ جڑوں کی صفوں کا موازنہ کرتا ہے اور درخت کو چھوٹے درجے کے ساتھ بڑے رینک کے ساتھ جڑ سے جوڑتا ہے۔اگر صفیں برابر ہیں تو ، ایک درخت دوسرے کے ساتھ منسلک ہوتا ہے ، اور نئی جڑ کے عہدے میں اضافہ ہوتا ہے۔ اگر اس سے منسلک طریقہ چیک کرتا ہے کہ اگر دو عناصر X اور y اپنے جڑ عناصر کا موازنہ کرکے ایک ہی سیٹ میں ہیں۔ مثال کے طور پر استعمال کے حصے میں استعمال کے حصے میں۔، ہم پانچ عناصر کے ساتھ ناپسندیدہ سیٹ تشکیل دے کر ناپسندیدہ طبقے کے استعمال کا مظاہرہ کرتے ہیں۔ہم کچھ یونین کی کاروائیاں انجام دیتے ہیں اور اس سے منسلک طریقہ کار کا استعمال کرتے ہوئے عناصر کی رابطے کی جانچ کرتے ہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "نگرانی سیکھنے میں رجعت اور درجہ بندی میں کیا فرق ہے؟",
        "Answer": "2D جگہ میں پوائنٹس کے ایک سیٹ میں پوائنٹس کی قریب ترین جوڑی تلاش کرنے کے ل you ، آپ تقسیم اور فتح الگورتھم کو \"پوائنٹس کی قریب ترین جوڑی\" الگورتھم کے نام سے جانا جاتا ہے۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈ انٹرفیس پوائنٹ {x: نمبر ؛Y: نمبر ؛} فنکشن کا فاصلہ (P1: نقطہ ، P2: نقطہ): نمبر {const Dx = p2.x - p1.x ؛const dy = p2.y - p1.y ؛واپس میتھ۔ ایس کیو آر ٹی (dx * dx + dy * dy) ؛} فنکشن برٹفورس (پوائنٹس: پوائنٹ [] ، شروع: نمبر ، اختتام: نمبر): نمبر {آئیے ذہنیت = لامحدودیت ؛کے لئے (i = start ؛ i <= end ؛ i ++) {for (j = i+1 ؛ j <= end ؛ j ++) {کونسٹ ڈسٹ = ڈسٹنس (پوائنٹس [i] ، پوائنٹس [j]) ؛midestance = math.min (ذہن سازی ، ضلع) ؛}} لوٹنے والی ذہنیت ؛} فنکشن اسٹرپ کلوسیسٹ (پوائنٹس: پوائنٹ [] ، سائز: نمبر ، ذہن: نمبر): نمبر {آئیے منٹ = ذہن سازی ؛کے لئے (i = 0 ؛ i <سائز ؛ ++ i) {for (j = i +1 ؛ j <سائز && پوائنٹس [j] .y - پوائنٹس [i] .y <منٹ ؛ ++ j) {کونسٹ ڈسٹ = فاصلہ (پوائنٹس [i] ، پوائنٹس [j]) ؛MIN = math.min (منٹ ، ضلع) ؛}} ریٹرن منٹ ؛} فنکشن کلوزٹیل (پوائنٹس: پوائنٹ [] ، شروع: نمبر ، اختتام: نمبر): نمبر {کانسٹ سائز = اختتام - شروع + 1 ؛اگر (سائز <= 3) {واپس برٹفورس (پوائنٹس ، اسٹارٹ ، اختتام) ؛} const MID = math.floor ((start + end) / 2) ؛مڈپوائنٹ = پوائنٹس [درمیانی] کو برقرار رکھیں ؛کانسٹ لیفٹ ڈسٹنس = قریبی (پوائنٹس ، اسٹارٹ ، وسط) ؛کونٹ رائٹسٹینس = قریبی (پوائنٹس ، وسط + 1 ، اختتام) ؛midestance = math.min (بائیں بازو ، دائیں طرف) ؛کانسٹرپ: پوائنٹ [] = [] ؛آئیے j = 0 ؛کے لئے (i = start ؛ i <= end ؛ i ++) {if (math.abs (پوائنٹس [i] .x - مڈپوائنٹ. x) <ذہنیت) {پٹی [j] = پوائنٹس [i] ؛J ++ ؛st} کونسٹرپ ڈسٹنس = اسٹرپ کلوسیسٹ (پٹی ، جے ، ذہن سازی) ؛ریٹرن میتھ مین (ذہن سازی ، سٹرپ ڈسٹینس) ؛} فنکشن کلوز اسٹیٹ پیئر (پوائنٹس: پوائنٹ []): نمبر {پوائنٹس.سورٹ ((a ، b) => a.x - b.x) ؛قریب قریب واپس (پوائنٹس ، 0 ، پوائنٹس۔ لمبائی - 1) ؛} // مثال کے استعمال: کانسٹ پوائنٹس: پوائنٹ [] = [{x: 2 ، y: 3} ، {x: 12 ، y: 30} ، {x: 40 ، Y: 50} ، {x: 5 ، Y: 1} ، {x: 12 ، y: 10} ، {x: 3 ، y: 4} ،] ؛ منڈسٹینس = قریب ترین (پوائنٹس) ؛ کنسول۔لاگ ('قریب ترین جوڑی کا فاصلہ:' ، ذہن سازی) ؛ اس عمل میں ، نقطہ انٹرفیس 2D جگہ میں ایک نقطہ کی نمائندگی کرتا ہے ، جس میں X اور Y کوآرڈینیٹ ہوتے ہیں۔ فاصلے کی تقریب فاصلے کے فارمولے کا استعمال کرتے ہوئے دو پوائنٹس کے مابین یکلیڈین فاصلے کا حساب لگاتی ہے۔ایک ہیلپر فنکشن ہے جو بروٹ فورس کے نقطہ نظر کا استعمال کرتے ہوئے بہت کم پوائنٹس کے درمیان قریب ترین جوڑی کے فاصلے کا حساب لگاتا ہے۔ اسٹرپ کلوسیسٹ فنکشن ایک اور مددگار فنکشن ہے جو ایک دیئے گئے چوڑائی کی پٹی میں موجود پوائنٹس کے درمیان قریب ترین جوڑی کے فاصلے کا حساب لگاتا ہے۔فنکشن ہے"
    },
    {
        "Question": "سپورٹ ویکٹر مشینوں (ایس وی ایم) اور اس کے اہم پیرامیٹرز کے تصور کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں بی ٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بٹرینوڈ <T> {چابیاں: ٹی [] ؛بچے: btreenode <t> [] ؛اسلیف: بولین ؛کنسٹرکٹر (سلیف: بولین) {this.keys = [] ؛this.children = [] ؛this.isleaf = sileaf ؛}} کلاس btree <t> {جڑ: btreenode <t> ؛ڈگری: نمبر ؛کنسٹرکٹر (ڈگری: نمبر) {this.root = null ؛this.degree = ڈگری ؛} تلاش (کلید: ٹی): بولین {اس کو واپس کریں۔} داخل کریں (کلید: ٹی): باطل {اگر (this.root === null) {this.root = نیا Btreenode <T> (سچ) ؛this.root.keys.push (key) ؛} دوسری {اگر (this.root.keys.length === (2 * this.degree) - 1) {const newrot = new Btreenode <T> (غلط) ؛newrot.children.push (this.root) ؛this.splichild (newrot ، 0 ، this.root) ؛this.root = newrot ؛} this.insertnonfull (this.root ، key) ؛}} پرائیویٹ سرچ نوڈ (نوڈ: Btreenode <T> ، key: t): بولین {آئیے i = 0 ؛جبکہ (i <node.keys.length && & key> node.keys [i]) {i ++ ؛} if (i <node.keys.length && & & key === نوڈ.کیس [i]) {سچ واپس ؛} if (node.isleaf) {جھوٹی لوٹ ؛this اس کو واپس کریں۔} نجی Insertnonfull (نوڈ: btreenode <t> ، key: t): باطل {آئیے i = node.keys.length - 1 ؛if (node.isleaf) {جبکہ (i> = 0 && & & key <node.keys [i]) {node.keys [i + 1] = node.keys [i] ؛میں--؛} node.keys [i + 1] = کلید ؛} دوسری {جبکہ (i> = 0 && & & key <node.keys [i]) {i-- ؛} i ++ ؛if (node.children [i] .keys.length === (2 * this.degree) - 1) {this.splitchild (نوڈ ، i ، نوڈ.چالڈین [i]) ؛if (key> node.keys [i]) {i ++ ؛}} this.insertnonfull (node.children [i] ، کلید) ؛}} نجی اسپلچیلڈ (والدین: Btreenode <T> ، انڈیکس: نمبر ، بچہ: Btreenode <T>): باطل {const newnode = نیا Btreenode <T> (child.isleaf) ؛پیرنٹ.Keys.splice (انڈیکس ، 0 ، child.keys [this.degree - 1]) ؛پیرنٹ.کرینین.سپلیس (انڈیکس + 1 ، 0 ، نیو نوڈ) ؛newnode.keys = child.keys.splice (this.degree ، this.degree - 1) ؛if (! child.isleaf) {newnode.children = child.children.splice (this.degree ، this.degree) ؛}}} // مثال کے طور پر استعمال: کانسٹ btree = new btree <bunds> (3) ؛ btree.insert (5) ؛ btree.insert (10) ؛ btree.insert (3) ؛ btree.insert (1) ؛ btree.داخل کریں (7) ؛ کنسول.لوگ (btree.search (3)) ؛// آؤٹ پٹ: trueconsole.log (btree.search (6)) ؛// آؤٹ پٹ: اس پر عمل درآمد کو فال کریں ، Btreenode کلاس B-Tree میں ایک نوڈ کی نمائندگی کرتا ہے۔اس میں چابیاں کی ایک صف ، چائلڈ نوڈس کی ایک صف ہے ، اور ایک جھنڈا اس بات کی نشاندہی کرتا ہے کہ آیا نوڈ ایک پتی نوڈ ہے۔ بی ٹری کلاس بی ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ اور ایک ڈگری ہے جو ہر نوڈ میں زیادہ سے زیادہ چابیاں کا تعین کرتی ہے۔"
    },
    {
        "Question": "فیچر انجینئرنگ کا مقصد کیا ہے اور کون سی تکنیک استعمال کی جاسکتی ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں گراف کے کم سے کم پھیلنے والے درخت (MST) تلاش کرنے کے لئے کرسکل کے الگورتھم کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس یونین فائنڈ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.rank = نئی صف (سائز) ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {this.palent [x] = this.find (this.palent [x]) ؛this اس کو واپس کریں۔ والدین [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (روٹ ایکس! == روٹ) {اگر (this.rank [روٹ ایکس] <this.rank [روٹ]) {this.palent [روٹ ایکس] = روٹ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}}} کلاس ایج {ماخذ: نمبر ؛منزل: نمبر ؛وزن: تعداد ؛تعمیر کنندہ (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر) {this.source = ماخذ ؛this.destination = منزل ؛یہ۔ وزن = وزن ؛class} کلاس گراف {کناروں: کنارے [] ؛کنسٹرکٹر () {this.edges = [] ؛} ایڈج (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر): باطل {کانٹ ایج = نیا کنارے (ماخذ ، منزل ، وزن) ؛this.edges.push (کنارے) ؛} کرسکلمسٹ (): ایج [] {this.edges.sort ((a ، b) => a.weight - b.weight) ؛کانسٹ یونین فائنڈ = نیا یونین فائنڈ (this.edges.length) ؛کانسٹ ایم ایس ٹی: ایج [] = [] ؛کے لئے (اس کے لئے۔کونٹ روٹسٹینیشن = یونین فائنڈ.فائنڈ (ایج.ڈیسٹینیشن) ؛اگر (روٹ سورس! == روٹ ڈسٹینیشن) {MST.push (کنارے) ؛یونین فائنڈ ڈاٹ یون (روٹ سورس ، روٹ ڈسٹینیشن) ؛}} واپسی MST ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈیج (0 ، 1 ، 4) ؛ گراف.ڈیج (0 ، 7 ، 8) ؛ گراف.ڈیج (1 ، 2 ، 8) ؛ گراف۔ایڈجڈ (1 ، 7 ، 11) ؛ گراف.ڈیج (2 ، 3 ، 7) ؛ گراف.ڈیج (2 ، 8 ، 2) ؛ گراف.اڈیج (2 ، 5 ، 4) ؛ گراف.اڈیج (3 ، 4 ،9) ؛ گراف.ڈیج (3 ، 5 ، 14) ؛ گراف.ڈیج (4 ، 5 ، 10) ؛ گراف.اڈیج (5 ، 6 ، 2) ؛ گراف.اڈیج (6 ، 7 ، 1) ؛ گراف۔ ایڈجڈج.لاگ (`$ {Edge.Source} - $ {Edge.destination} ، وزن: $ {ایج. ویٹ}`) ؛} اس نفاذ میں ، یونین فائنڈ کلاس رینک کے ذریعہ یونین فٹ کمپریشن اور یونین کے ساتھ یونین فٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس کا استعمال الگورتھم کے دوران ناگوار سیٹوں پر نظر رکھنے کے لئے کیا جاتا ہے۔ کنارے کی کلاس گراف میں ایک کنارے کی نمائندگی کرتی ہے ، جس میں ماخذ ورٹیکس ، منزل مقصود اور وزن کو ذخیرہ کیا جاتا ہے۔"
    },
    {
        "Question": "بے ضابطگی کا پتہ لگانے کے تصور کی وضاحت کریں اور اس مقصد کے لئے استعمال ہونے والی تکنیک کی ایک مثال پیش کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ٹریپ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹریپ نوڈ <T> {کلید: نمبر ؛قیمت: ٹی ؛ترجیح: نمبر ؛بائیں: ٹریپ نوڈ <t> |خالی؛دائیں: ٹریپ نوڈ <t> |خالی؛کنسٹرکٹر (کلید: نمبر ، قدر: t) {this.key = key ؛this.value = value ؛this.priority = math.random () ؛this.left = null ؛this.right = null ؛class} کلاس ٹریپ <t> {جڑ: ٹریپ نوڈ <t> |خالی؛کنسٹرکٹر () {this.root = null ؛} پرائیویٹ روٹیٹ لفٹ (نوڈ: ٹریپ نوڈ <t>): ٹریپ نوڈ <t> {کونٹ رائٹچائڈ = نوڈ. رائٹ !؛node.right = rightild.left ؛رائٹچلڈ ڈاٹ لیفٹ = نوڈ ؛رائٹائڈ واپس ؛} نجی روٹیرائٹ (نوڈ: ٹریپ نوڈ <T>): ٹریپ نوڈ <T> {کانسٹیٹ لیفٹائڈ = نوڈ۔ لیفٹ !؛node.left = lifthild.right ؛بائیں بچے۔ رائٹ = نوڈ ؛بائیں بازو کی واپسی ؛} نجی داخلہ (نوڈ: ٹریپ نوڈ <T> | NULL ، KEY: نمبر ، قدر: T): ٹریپ نوڈ <T> {اگر (نوڈ === NULL) {نیا ٹریپ نوڈ <T> (کلیدی ، قدر) واپس لوٹائیں ؛} if (key <node.key) {node.left = this.insertnode (node.left ، key ، value) ؛اگر (نوڈ.لفٹ!}} دوسری صورت میں اگر (key> نوڈ.کی) {نوڈ۔ رائٹ = this.insertnode (نوڈ. رائٹ ، کلید ، قدر) ؛if (node.right! .priority <node.priority) {نوڈ = this.rotateleft (نوڈ) ؛}} واپسی نوڈ ؛} داخل کریں (کلید: نمبر ، قدر: ٹی): باطل {this.root = this.insertnode (this.root ، کلید ، قدر) ؛} نجی ڈیلیٹینوڈ (نوڈ: ٹریپ نوڈ <t> | null ، key: نمبر): ٹریپ نوڈ <T> |null {if (نوڈ === null) {واپسی NULL ؛} if (key <node.key) {node.left = this.deletenode (node.left ، key) ؛} دوسری صورت میں اگر (key> نوڈ.کی) {نوڈ. رائٹ = this.deletenode (node.right ، key) ؛} else {if (node.left === null && node.right === null) {واپس واپس ؛} ورنہ اگر (node.left === null) {نوڈ = this.rotateleft (نوڈ) ؛} ورنہ اگر (نوڈ.رائٹ === null) {نوڈ = this.rotateright (نوڈ) ؛} else {if (node.left.priority <node.right.priority) {نوڈ = this.rotateright (نوڈ) ؛} دوسری {نوڈ = this.rotateleft (نوڈ) ؛}} نوڈ = this.deletenode (نوڈ ، کلید) ؛} واپسی نوڈ ؛} حذف کریں (کلید: نمبر): باطل {this.root = this.deletenode (this.root ، key) ؛} نجی سرچ نوڈ (نوڈ: ٹریپ نوڈ <t> | null ، key: نمبر): t |null {if (نوڈ === null) {واپسی NULL ؛} if (key === node.key) {واپسی نوڈ.ولیو ؛} دوسری صورت میں اگر (کلید <نوڈ.کی) {اس کی تلاش کریں۔} else {اس کو واپس کریں۔ سرچنوڈ (نوڈ. رائٹ ، کلید) ؛}} تلاش (کلید: نمبر): ٹی |null {اس کو واپس کریں۔ سرچنوڈ (this.root ، key) ؛}} // مثال کے طور پر استعمال: const ٹریپ = نیا ٹریپ <سٹرنگ> () ؛ ٹریپ.نسرٹ (5 ، \"ایپل\") ؛ ٹری"
    },
    {
        "Question": "مشین لرننگ میں نقصان کے افعال کا کیا کردار ہے اور کچھ عام طور پر استعمال ہونے والے نقصان کے افعال کیا ہیں؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تاروں کی ایک صف کے درمیان سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے ایک مثال کا پروگرام یہ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل ترین کامومن پریفکس (ایس ٹی آر ایس: سٹرنگ []): سٹرنگ {اگر (str.length === 0) {واپسی '' ؛pref لیٹ پریفکس = strs [0] ؛کے لئے (i = 1 ؛ i <str.length ؛ i ++) {جبکہ (strs [i]. indexof (سابقہ)! == 0) {پریفکس = پریفکس.سوبسٹرنگ (0 ، سابقہ۔ لمبائی - 1) ؛اگر (سابقہ === '') {واپس '' ؛}}} واپسی کا سابقہ ؛} // مثال کے استعمال: کانسٹور اسٹرنگز = ['پھول' ، 'فلو' ، 'فلائٹ'] const const مشترکہ پریفکس = طویل ترین کامومن پریفکس (ڈور) ؛ کنسول.لوگ ('سب سے طویل عام پریفکس:' ، کامن پرفکس)؛// آؤٹ پٹ: \"FL\" اس پروگرام میں ، طویل عرصے سے کام کرنے والا فنکشن ان پٹ کے طور پر تار کی ایک صف لیتا ہے اور ان میں سب سے طویل عام سابقہ واپس کرتا ہے۔ فنکشن سرنی میں پہلی تار کے ساتھ سابقہ متغیر کو شروع کرتا ہے۔اس کے بعد ، یہ باقی ڈوروں کے ذریعے تکرار کرتا ہے اور چیک کرتا ہے کہ اگر انڈیکسف طریقہ استعمال کرتے ہوئے ہر تار کا سابقہ ایک سابقہ ہے۔اگر پریفکس کسی تار کا سابقہ نہیں ہے تو ، یہ سابقہ کے آخری کردار کو ہٹاتا ہے اور اس عمل کو جاری رکھے گا جب تک کہ ایک مشترکہ سابقہ مل جاتا ہے یا سابقہ خالی نہیں ہوجاتا ہے۔اگر کوئی مشترکہ سابقہ موجود نہیں ہے تو خالی تار۔"
    },
    {
        "Question": "کراس توثیق کا استعمال کرتے ہوئے ماڈل کے انتخاب اور تشخیص کے عمل کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس روپینوڈ {بائیں: روپینوڈ |تار ؛دائیں: روپینوڈ |تار ؛وزن: تعداد ؛کنسٹرکٹر (بائیں: روپینوڈ | سٹرنگ ، دائیں: روپینوڈ | سٹرنگ) {this.left = بائیں ؛this.right = دائیں ؛this.weight = this.calculateweitt () ؛} نجی حساب کتاب (): نمبر {if (type of this.left === 'سٹرنگ') {اس کو واپس کریں۔} دوسری {اس کو واپس کریں۔}}} کلاس رسی {جڑ: روپینوڈ |تار ؛کنسٹرکٹر (جڑ: روپینوڈ | سٹرنگ) {this.root = جڑ ؛} پرائیویٹ کونکٹنوڈس (نوڈ 1: روپینوڈ | سٹرنگ ، نوڈ 2: روپینوڈ | سٹرنگ): روپینوڈ {نیا روپینوڈ واپس کریں (نوڈ 1 ، نوڈ 2) ؛} نجی اسپلٹ نوڈ (نوڈ: روپینوڈ ، انڈیکس: نمبر): [روپنوڈ |سٹرنگ ، روپینوڈ |سٹرنگ] {if (index === 0) {واپسی [node.left ، node.right] ؛} دوسری صورت میں اگر (اشاریہ === نوڈ۔ ویٹ) {واپسی [نوڈ ، ''] ؛} ورنہ اگر (ٹائپوف نوڈ۔ لیفٹ === 'سٹرنگ') {کونسٹ لیفٹسبسٹرنگ = نوڈ.لفٹ.سوبسٹرنگ (0 ، انڈیکس) ؛کنسٹ رائٹسبسٹرنگ = نوڈ۔ لیفٹ.سوبسٹرنگ (انڈیکس) ؛واپسی [لیفٹسبسٹرنگ ، رائٹسبسٹرنگ + نوڈ۔ رائٹ] ؛} ورنہ اگر (index <node.left.weight) {const [leftsplit ، حقوق پلٹ] = this.splitnode (node.left as ropenode ، انڈیکس) ؛واپسی [leftsplit ، this.concatnodes (حقوق کی جگہ ، نوڈ. رائٹ)] ؛} else {const [leftsplit ، حقوق پلٹ] = this.splitnode (نوڈ۔ ropenode ، انڈیکس - node.left.weight) ؛واپس [this.concatnodes (node.left ، leftsplit) ، حقوق کی جگہ] ؛}} داخل کریں (اشاریہ: نمبر ، متن: سٹرنگ): باطل {کانسٹ [بائیں ، دائیں] = this.splitnode (یہ.روٹ بطور روپینوڈ ، انڈیکس) ؛const newnode = this.concatnodes (بائیں ، this.concatnodes (متن ، دائیں)) ؛this.root = newnode ؛} حذف کریں (اشاریہ: نمبر ، لمبائی: نمبر): باطل {Const [بائیں 1 ، دائیں 1] = this.splitnode (یہ.روٹ بطور روپینوڈ ، انڈیکس) ؛کانسٹ [بائیں 2 ، دائیں 2] = this.splitnode (دائیں 1 جیسے روپینوڈ ، لمبائی) ؛this.root = this.concatnodes (بائیں 1 ، دائیں 2) ؛} ٹاسٹرنگ (): سٹرنگ {کانسٹنگ نتیجہ: سٹرنگ [] = [] ؛Const traverse = (نوڈ: روپینوڈ | سٹرنگ) => {if (typeof نوڈ === 'سٹرنگ') {نتیجہ. پش (نوڈ) ؛} else {traverse (node.left) ؛traverse (node.right) ؛}} ؛traverse (this.root) ؛واپسی کا نتیجہ۔ join ('') ؛}} // مثال کے طور پر استعمال: کونسٹ رسی = نئی رسی (نیا روپینوڈ ('ہیلو ،' ، 'ورلڈ!')) ؛ rope.insert (7 ، 'خوبصورت') ؛ rope.delete (0 ، 7) ؛ کنسول۔لاگ (rope.tostring ()) ؛// آؤٹ پٹ: \"خوبصورت دنیا!\" اس نفاذ میں ، روپینوڈ کلاس رسی میں ایک نوڈ کی نمائندگی کرتی ہے ، جس میں یا تو تار (پتی نوڈ) ہوسکتا ہے یا دو بچوں کے نوڈس (اندرونی نوڈ) کا حوالہ ہوسکتا ہے۔ہر نوڈ میں ایک وزن کی پراپرٹی بھی ہوتی ہے جو اس نوڈ میں ذخیرہ شدہ اسٹرنگ کی لمبائی کی نمائندگی کرتی ہے۔ رسی کی کلاس رسی کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے اور مخصوص اشاریوں پر متن کو داخل کرنے اور حذف کرنے کے طریقے مہیا کرتی ہے ، اور ساتھ ہی رسی کو تار کی نمائندگی میں تبدیل کرتی ہے۔داخل کرنے کا طریقہ مخصوص انڈیکس پر رسی کو الگ کرتا ہے ، نئے متن کو علیحدہ نوڈ کے طور پر داخل کرتا ہے ، اور پھر نوڈس کو ایک ساتھ مل جاتا ہے۔"
    },
    {
        "Question": "مشین لرننگ میں L1 اور L2 کو باقاعدہ بنانے میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں بیل مین فورڈ الگورتھم کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ایج {ماخذ: نمبر ؛منزل: نمبر ؛وزن: تعداد ؛تعمیر کنندہ (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر) {this.source = ماخذ ؛this.destination = منزل ؛یہ۔ وزن = وزن ؛class} کلاس گراف {عمودی: نمبر ؛کناروں: کنارے [] ؛کنسٹرکٹر (عمودی: نمبر) {this.vertices = عمودی ؛this.edges = [] ؛} ایڈج (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر): باطل {کانٹ ایج = نیا کنارے (ماخذ ، منزل ، وزن) ؛this.edges.push (کنارے) ؛man بیل مین فورڈ (اسٹارٹورٹیکس: نمبر): نمبر [] {کنسٹ ڈسٹنس: نمبر [] = نیا سرنی (یہ ۔ورٹائٹس)فاصلہ [اسٹارٹورٹیکس] = 0 ؛کے لئے (آئیے i = 0 ؛ i <this.vertices - 1 ؛ i ++) {کے لئے (اس کے لئے۔اگر (فاصلہ [ماخذ]! == نمبر.میکس_ویلیو && فاصلہ [ماخذ] + وزن <فاصلہ [منزل]) {فاصلہ [منزل] = فاصلہ [ماخذ] + وزن ؛}}} for (this.edges کے کونسٹ ایج) {const {ماخذ ، منزل ، وزن} = کنارے ؛اگر (فاصلہ [ماخذ]! == نمبر.میکس_ویلیو && فاصلہ [ماخذ] + وزن <فاصلہ [منزل]) {نئی غلطی پھینک دیں ('گراف میں منفی وزن کا چکر ہوتا ہے') ؛}} واپسی کا فاصلہ ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف (5) ؛ گراف.ڈیج (0 ، 1 ، 4) ؛ گراف.ڈیج (0 ، 2 ، 3) ؛ گراف.اڈیج (1 ، 2 ، -2) ؛گراف.اڈیج (1 ، 3 ، 4) ؛ گراف.ڈیج (1 ، 4 ، 2) ؛ گراف.ڈیج (3 ، 2 ، 1) ؛ گراف.اڈیج (3 ، 1 ، 5) ؛ گراف.اڈیج (4 ،3 ، -3) ؛ کانسٹ اسٹارٹورٹیکس = 0 ؛ کانسٹلسٹ ڈسٹنس = گراف.بیل مین فورڈ (اسٹارٹورٹیکس) ؛ کنسول.لوگ ('ورٹیکس سے مختصر فاصلہ' ، اسٹارٹورٹیکس) ؛ کے لئے (i = 0 ؛ i <شارسٹ ڈسٹینس.لنتھ ؛ i ++){کنسول.لاگ ('ورٹیکس' ، i ، ':' ، مختصر ترین [i]) ؛} اس عمل میں ، ایج کلاس گراف میں ایک کنارے کی نمائندگی کرتا ہے ، جس میں ایک ماخذ ورٹیکس ، منزل مقصود ، اور وزن ہوتا ہے۔ گراف کلاسایک ہدایت نامہ گراف کی نمائندگی کرتا ہے اور کسی دیئے گئے اسٹارٹ ایکسٹریکس سے مختصر ترین فاصلوں کو تلاش کرنے کے لئے کناروں کو شامل کرنے اور بیل مین فورڈ الگورتھم کو انجام دینے کے طریقے مہیا کرتا ہے۔ بیل مین فورڈ کا طریقہ اسٹارٹ ورٹیکس سے مختصر فاصلے کو ذخیرہ کرنے کے لئے ایک صف کا فاصلہ شروع کرتا ہے۔اس کے بعد اس کی تکرار ہوتی ہے۔اس کے بعد ، یہ گراف میں منفی وزن کے چکروں کی جانچ پڑتال کرتا ہے۔اگر منفی وزن کا چکر مل جاتا ہے تو ، ایک غلطی پھینک دی جاتی ہے۔ فائنل طور پر ، پروگرام گراف کلاس کے استعمال کو گراف بنا کر ، کناروں کو شامل کرکے ، اور بیل مین فورڈ الگورتھم چلانے سے ظاہر کرتا ہے تاکہ ایک مخصوص اسٹارٹ ورٹیکس سے مختصر ترین فاصلوں کو تلاش کیا جاسکے۔اس کے بعد قلیل ترین فاصلوں کو کنسول پر چھپایا جاتا ہے۔"
    },
    {
        "Question": "قدرتی زبان پروسیسنگ کے کاموں میں لفظ ایمبیڈنگ کے تصور اور ان کے استعمال کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں وقفہ کے درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس وقفہ {کم: نمبر ؛اعلی: نمبر ؛کنسٹرکٹر (کم: نمبر ، اعلی: نمبر) {this.low = کم ؛this.high = اعلی ؛class} کلاس انٹرولٹرینوڈ {وقفہ: وقفہ ؛زیادہ سے زیادہ: نمبر ؛بائیں: انٹرالٹرینوڈ |خالی؛دائیں: انٹرالٹرینوڈ |خالی؛کنسٹرکٹر (وقفہ: وقفہ) {this.interval = وقفہ ؛this.max = وقفہ۔ ہائی ؛this.left = null ؛this.right = null ؛class} کلاس انٹرولٹری {جڑ: انٹرویلٹرینوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} پرائیویٹ گیٹ میکس (A: نمبر ، B: نمبر ، C: نمبر): نمبر {ریٹرن میتھ۔ میکس (A ، Math.max (B ، C)) ؛} نجی Insertnode (نوڈ: انٹرویلٹرینوڈ | NULL ، وقفہ: وقفہ): انٹرویلٹرینوڈ {اگر (نوڈ ==== null) {نیا انٹرویلٹرینوڈ (وقفہ) واپس کریں ؛} const {کم} = وقفہ ؛اگر (کم <node.interval.low) {node.left = this.insertnode (node.left ، وقفہ) ؛} else {node.right = this.insertnode (node.right ، وقفہ) ؛} node.max = this.getMax (node.max ، وقفہ. ہائی ، نوڈ. interval.high) ؛واپسی نوڈ ؛} داخل کریں (وقفہ: وقفہ): باطل {this.root = this.insertnode (this.root ، وقفہ) ؛} نجی ڈوورلاپ (وقفہ 1: وقفہ ، وقفہ 2: وقفہ): بولین {ریٹرن انٹرویویل 1.low <= intraval2.high && interval2.low <= introal1.high ؛} نجی سرچ اوورلیپنگ انٹرولز (نوڈ: انٹرویلٹرینوڈ | NULL ، وقفہ: وقفہ ، نتیجہ: وقفہ []): باطل {اگر (نوڈ === null) {واپسی ؛} if (this.dooverlap (node.interval ، وقفہ)) {نتیجہ. پش (node.interval) ؛} اگر (نوڈ.لفٹ!} if (node.right! == null && node.right.Interval.low <= interval.high) {this.searchoverlapping intervals (نوڈ.رائٹ ، وقفہ ، نتیجہ) ؛}} تلاش (وقفہ: وقفہ): وقفہ [] {کانسٹنگ نتیجہ: وقفہ [] = [] ؛this.searchoverlapping intervals (this.root ، وقفہ ، نتیجہ) ؛واپسی کا نتیجہ ؛}} // مثال کے طور پر استعمال: کانسٹ انٹروولٹری = نیا انٹروولٹری () ؛ انٹروولٹری.سرٹ (نیا وقفہ (15 ، 20)) inter انٹروولٹری.سرٹ (نیا وقفہ (10 ، 30)) inter انٹروولٹری.نسٹ (نیا وقفہ (5 ،20)) inter انٹروولٹری۔ INSERT (نیا وقفہ (12 ، 15)) inter انٹروولٹری.سرٹ (نیا وقفہ (17 ، 19)) inter انٹروولٹری.سرٹ (نیا وقفہ (30 ، 40)) const کانس سرچینٹرول = نیا وقفہ (14، ، 16) const vorelapping intervals = intervaltree.search (سرچینٹیورول) ؛ کنسول.لوگ ('اوور لیپنگ وقفے کے ساتھ اوورلیپنگ وقفے' ، سرچ انٹروول ، ':') ؛ اوورلیپنگ انٹروئولز۔ فارورچ ((وقفہ) => {کنسول۔.low ، '،' ، وقفہ. HIGH ، ']') ؛}) ؛ اس عمل میں ، وقفہ طبقہ ایک وقفہ کی نمائندگی کرتا ہے جس میں کم اور اعلی قیمت ہوتی ہے۔وقفے کے درخت میں ایک نوڈ کی نمائندگی کرتا ہے ، جس میں وقفہ ہوتا ہے ، اس کے وقفہ اور اولاد میں زیادہ سے زیادہ قیمت ہوتی ہے ، اور بائیں اور دائیں بچے کے نوڈس کا حوالہ ہوتا ہے۔ انٹرلٹری کلاس وقفہ درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے اور وقفوں کو داخل کرنے کے طریقے مہیا کرتا ہے اور۔اوورلیپنگ وقفوں کی تلاش کریں۔ داخل کرنے کا طریقہ موجودہ نوڈ کے وقفہ کم قیمت کے ساتھ اس کی کم قیمت کا موازنہ کرکے وقفہ کے درخت میں وقفہ داخل کرتا ہے۔یہ نوڈ کی زیادہ سے زیادہ اعلی قیمت کو اپ ڈیٹ کرتا ہے اور"
    },
    {
        "Question": "ترتیب کی پیش گوئی کے لئے بار بار نیورل نیٹ ورک (RNN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!یہاں ایک ٹائپ اسکرپٹ پروگرام کی ایک مثال ہے جو گراف پر چوڑائی کی پہلی تلاش کرتی ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: ریکارڈ <سٹرنگ ، سٹرنگ []> ؛کنسٹرکٹر () {this.adjacencyList = {} ؛} ایڈورٹیکس (ورٹیکس: سٹرنگ) {if (! this.adjacencyList [vertex]) {this.adjacencyList [vertex] = [] ؛}} ایڈج (ورٹیکس 1: سٹرنگ ، ورٹیکس 2: سٹرنگ) {this.adjacencyList [vertex1] .push (vertex2) ؛this.adjacencyList [vertex2] .Push (vertex1) ؛} بریڈھفیرسٹ سرچ (اسٹارٹورٹیکس: سٹرنگ) {کنسٹ ملاحظہ کریں: ریکارڈ <سٹرنگ ، بولین> = {} ؛کانسٹ قطار: سٹرنگ [] = [] ؛کانسٹنگ نتیجہ: سٹرنگ [] = [] ؛دورہ [اسٹارٹورٹیکس] = سچ ؛قطار.پش (اسٹارٹورٹیکس) ؛جبکہ (قطار۔ لمبائی) {موجودہ موجودہورٹیکس = قطار۔ شفٹ () !؛نتیجہ۔ پش (کرنٹورٹیکس) ؛this.adjacencyList [کرنٹٹورٹیکس] .foreach ((پڑوسی) => {اگر (! ملاحظہ کیا [پڑوسی]) {ملاحظہ کیا [پڑوسی] = سچ ؛ قطار.پش (پڑوسی) ؛}}) ؛} واپسی کا نتیجہ ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈورٹیکس (\"A\") ؛ گراف.اڈورٹیکس (\"بی\") ؛ گراف.اڈٹورٹیکس (\"سی\") ؛ گراف.اڈٹورٹیکس (\"ڈی\")؛ گراف.اڈورٹیکس (\"ای\") ؛ گراف.اڈیج (\"اے\" ، \"بی\") ؛ گراف.ڈیج (\"اے\" ، \"سی\") ؛ گراف.ڈیج (\"بی\" ، \"ڈی\") ؛ گراف.Addedge (\"C\" ، \"E\") ؛ کنسول.لوگ (گراف.بریڈھفیرسٹ سرچ (\"A\")) ؛// آؤٹ پٹ: ['A' ، 'B' ، 'C' ، 'D' ، 'E'] اس مثال میں ، ہم گراف میں عمودی اور کناروں کو شامل کرنے کے طریقوں کے ساتھ گراف کلاس کی وضاحت کرتے ہیں۔چوڑائی کی تلاش کا طریقہ کسی دیئے گئے ورٹیکس سے شروع ہونے والی چوڑائی کی پہلی تلاش کو انجام دیتا ہے۔اس میں دورہ شدہ چشموں کا سراغ لگانے کے لئے ملاحظہ کی گئی شے کا استعمال کیا جاتا ہے ، دورے کے لئے عمودی کو ذخیرہ کرنے کے لئے ایک قطار صف ، اور ملاحظہ کرنے والے عمودیوں کے آرڈر کو ذخیرہ کرنے کے لئے نتیجہ سرے۔ ہم گراف کلاس کی ایک نئی مثال بنائیں اور اس میں عمودی اور کناروں کو شامل کریں۔اس کے بعد ، ہم \"A\" کے ابتدائی حد کے ساتھ بریڈتھفیرسٹ سرچ طریقہ کو کہتے ہیں اور اس کے نتیجے میں لاگ ان کریں۔ پروگرام کی آؤٹ پٹ ['a' ، 'b' ، 'c' ، 'd' ، 'e'] ہوگی۔اس ترتیب کی نمائندگی کرتا ہے جس میں چوڑائی کی پہلی تلاش کے دوران عمودی کا دورہ کیا گیا تھا۔"
    },
    {
        "Question": "اعصابی نیٹ ورکس میں چالو کرنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ٹائپ اسکرپٹ میں ترتیب شدہ لنکڈ لسٹ میں بائنری سرچ الگورتھم کو نافذ کرنے کے ل we ، ہمیں لنکڈ فہرست کو ایک صف میں تبدیل کرنے کی ضرورت ہے تاکہ ہم بائنری تلاش کو موثر انداز میں انجام دے سکیں۔یہاں ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس لسٹنوڈ {قدر: نمبر ؛اگلا: لسٹنوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.next = null ؛class} کلاس لنکڈ لسٹ {سر: لسٹنوڈ |خالی؛کنسٹرکٹر () {this.head = null ؛} داخل کریں (قیمت: نمبر) {کونسٹ نیونوڈ = نیا لسٹنوڈ (قدر) ؛اگر (! this.head) {this.head = newnode ؛} دوسری {موجودہ = this.head ؛جبکہ (موجودہ۔ نیکسٹ) {موجودہ = موجودہ۔ نیکسٹ ؛} موجودہ۔ نیکسٹ = نیونوڈ ؛}} tosortedarray (): نمبر [] {CONST نتیجہ: نمبر [] = [] ؛آئیے موجودہ = this.head ؛جبکہ (موجودہ) {نتیجہ۔ پش (موجودہ. قیمت) ؛موجودہ = موجودہ۔ نیکسٹ ؛} واپسی کا نتیجہ ؛} بائنری سرچ (ٹارگٹ: نمبر): بولین {کونٹ سنٹری = یہ۔ ٹوسورٹری () () ؛بائیں = 0 ؛چلو دائیں = چھانٹری ڈری۔ لمبائی - 1 ؛جبکہ (بائیں <= دائیں) {const MID = math.floor ((بائیں + دائیں) / 2) ؛اگر (shartedarray [وسط] === ہدف) {سچ واپس ؛} ورنہ اگر (shartedarray [وسط] <ہدف) {بائیں = وسط + 1 ؛} دوسری {دائیں = وسط - 1 ؛}} غلط لوٹائیں ؛}} // مثال کے طور پر استعمال: لنکڈ لسٹ = نئی لنکڈ لسٹ () ؛ لنکڈ لسٹ۔ INSERT (10) ؛ لنکڈ لسٹ۔ INSERT (20) ؛ لنکڈ لسٹ۔ INSERT (30) ؛ لنکڈ لسٹ۔ INSERT (40) ؛ لنکڈ لسٹ۔ INSERT (50) ؛کنسول.لوگ (لنکڈ لسٹ.بائنری سرچ (30)) ؛// آؤٹ پٹ: trueconsole.log (لنکڈ لسٹ.بائنری سرچ (35)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہم لنکڈ لسٹ میں ایک ہی نوڈ کی نمائندگی کرنے کے لئے ایک لسٹنوڈ کلاس کی وضاحت کرتے ہیں ، اور لنکڈ لسٹ کلاس جو منسلک فہرست کی کارروائیوں کا انتظام کرتی ہے۔داخل کرنے کا طریقہ منسلک فہرست میں اقدار داخل کرنے کے لئے استعمال کیا جاتا ہے۔ بائنری تلاش کرنے کے ل we ، ہم پہلے لنکڈ فہرست کو ٹوسورٹیرے کے طریقہ کار کا استعمال کرتے ہوئے ترتیب دیئے گئے صف میں تبدیل کرتے ہیں۔یہ طریقہ منسلک فہرست کو عبور کرتا ہے اور ترتیب شدہ ترتیب میں اقدار کے ساتھ ایک صف تیار کرتا ہے۔ اس کے بعد ، بائنری تلاش کا طریقہ ترتیب شدہ صف پر بائنری تلاش کرتا ہے۔یہ صف کے آغاز اور اختتام تک بائیں اور دائیں پوائنٹرز کی ابتدا کرتا ہے ، اور درمیانی عنصر کے ساتھ ہدف کی قیمت کا موازنہ کرنے کے لئے درمیانی انڈیکس (وسط) کا تکرار سے حساب کتاب کرتا ہے۔اگر ہدف کی قیمت مل جاتی ہے تو ، یہ سچ واپس آجاتا ہے۔اگر ہدف کی قیمت چھوٹی ہے تو ، دائیں پوائنٹر کو ایڈجسٹ کیا جاتا ہے۔اگر ہدف کی قیمت بڑی ہے تو ، بائیں پوائنٹر کو ایڈجسٹ کیا جاتا ہے۔لوپ اس وقت تک جاری رہتا ہے جب تک کہ ہدف کی قیمت نہ مل جائے یا تلاش کی جگہ ختم ہوجائے۔اگر لنکڈ لسٹ میں ہدف کی قیمت مل جاتی ہے ، اور دوسری صورت میں جھوٹا ہوتا ہے تو پروگرام درست ہوگا۔"
    },
    {
        "Question": "پرنسپل جزو تجزیہ (پی سی اے) کے تصور اور جہتی میں کمی میں اس کے کردار کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہ ہے کہ اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن آریٹریجسٹینیکل (ٹری 1: ٹرینوڈ | نول ، ٹری 2: ٹرینوڈ | نول): بولین {// بیس کیسز: اگر دونوں درخت کالعدم ہیں تو ، وہ ایک جیسے ہیں اگر (ٹری 1 === nulسچ ؛} // اگر ایک درخت کالعدم ہے اور دوسرا نہیں ہے تو ، وہ ایک جیسے نہیں ہیں اگر (ٹری 1 === null || درخت 2 === null) {غلط واپس ؛} // چیک کریں کہ آیا موجودہ نوڈ کی اقدار برابر ہیں ، اور ان کے بائیں اور دائیں سبٹریز کی واپسی (treath1.value === tree2.value && aretreasidentical (treath1.left ، tree2.left) && aretresidentical (treath1.right ، درخت 2. رائٹ)) ؛} // مثال کے طور پر استعمال: // درخت 1 کونسٹ ٹری 1 = نیا ٹرینوڈ (1) ؛ ٹری 1. لیفٹ = نیا ٹرینوڈ (2) ؛ ٹری 1. رائٹ = نیا ٹرینوڈ (3) ؛ ٹری 1.left.left = نیاtreenode (4) ؛ trease1.left.right = نیا ٹرینوڈ (5) // درخت 2 (درخت سے ملتا جلتا ہے 1) کانسٹ ٹری 2 = نیا ٹرینوڈ (1) ؛ درخت 2. لیفٹ = نیا ٹرینوڈ (2) ؛ ٹری 2. رائٹ =نیا ٹرینوڈ (3) tree درخت 2.left.left = نیا ٹرینوڈ (4) ؛ ٹری 2.left.right = نیا ٹرینوڈ (5) ؛ کنسول.لوگ (اریٹ ریزیڈینیکل (ٹری 1 ، ٹری 2)) ؛// آؤٹ پٹ: ٹری // درخت 3 (درخت سے مختلف ڈھانچہ 1) کانسٹ ٹری 3 = نیا ٹرینوڈ (1) ؛ ٹری 3. لیفٹ = نیا ٹرینوڈ (2) ؛ ٹری 3. رائٹ = نیا ٹرینوڈ (3) ؛ ٹری 3.left.right= نیا ٹرینوڈ (4) ؛ ٹری 3. رائٹ.لیفٹ = نیا ٹرینوڈ (5) ؛ کنسول.لوگ (آریٹری ایسڈینیکل (ٹری 1 ، ٹری 3)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہم بائنری درخت میں نوڈ کی نمائندگی کرنے کے لئے ایک ٹرینوڈ کلاس کی وضاحت کرتے ہیں۔ہر نوڈ کی ایک قیمت ، ایک بائیں بچہ ، اور ایک دائیں بچہ ہوتا ہے۔ اریٹریسیڈینیکل فنکشن دو بائنری درختوں کو ان پٹ (ٹری 1 اور ٹری 2) کے طور پر لیتا ہے اور اگر درخت ایک جیسے اور غلط ہیں تو وہ سچ ثابت ہوتا ہے۔یہ درختوں کے نوڈس کا موازنہ کرنے کے لئے ایک تکرار نقطہ نظر کا استعمال کرتا ہے۔ فنکشن پہلے بیس کیسوں کی جانچ پڑتال کرتا ہے: اگر دونوں درخت کالعدم ہیں تو وہ ایک جیسے ہیں (بیس کیس 1)۔اگر ایک درخت کالعدم ہے اور دوسرا نہیں ہے تو ، وہ ایک جیسے نہیں ہیں (بیس کیس 2). اگر مذکورہ بالا بیس معاملات پوری نہیں کیے جاتے ہیں تو ، فنکشن ٹری 1 اور ٹری 2 کی موجودہ نوڈ اقدار کا موازنہ کرتا ہے۔اگر وہ برابر ہیں تو ، یہ بار بار دونوں درختوں کے بائیں سبٹریوں اور دائیں سب ٹریوں کے لئے اریٹریسیڈینیکل کہتے ہیں۔اگر یہ ساری بار بار کالیں درست لوٹتی ہیں تو پھر درختوں کو یکساں سمجھا جاتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم تین بائنری درخت بناتے ہیں: ٹری 1 ، ٹری 2 ، اور ٹری 3۔ٹری 1 اور ٹری 2 میں ایک ہی ڈھانچہ اور اقدار ہیں ، لہذا فنکشن کال آریٹیریسیڈینیکل (ٹری 1 ، ٹری 2) کو درست لوٹتا ہے۔تاہم ، ٹری 3 ٹری 1 سے ایک مختلف ڈھانچہ رکھتا ہے ، لہذا فنکشن کال آریٹیریسیڈینیکل (ٹری 1 ، ٹری 3) غلط لوٹتا ہے۔"
    },
    {
        "Question": "گمشدہ ڈیٹا کو سنبھالنے میں کیا اہم چیلنجز ہیں اور اسے سنبھالنے کے لئے کون سی تکنیک استعمال کی جاسکتی ہے؟",
        "Answer": "اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کرنا پیچیدہ ہوسکتا ہے ، لیکن میں آپ کو شروع کرنے کے لئے ایک آسان عمل درآمد فراہم کروں گا۔یہاں ٹائپ اسکرپٹ میں نافذ ہونے والی اسکیپ لسٹ کی ایک مثال ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسکیپلسٹنوڈ {قدر: نمبر ؛اگلا: اسکیپلسٹنوڈ |خالی؛نیچے: اسکیپلسٹنوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.next = null ؛this.down = null ؛class} کلاس اسکیپلسٹ {سر: اسکیپلسٹنوڈ |خالی؛میکسلیول: نمبر ؛سطح پروبییبلٹی: نمبر ؛کنسٹرکٹر () {this.head = null ؛this.maxlevel = 16 ؛// اسکیپ لسٹ کے ل maximum زیادہ سے زیادہ سطح اس۔ لیولپروبیبلٹی = 0.5 ؛// نوڈ کو اعلی سطح پر ہونے کا امکان} داخل کریں (قیمت: نمبر) {// اگر اسکیپ لسٹ خالی ہے تو ، ایک نیا نیچے کی سطح بنائیں اگر (! یہ۔ ہیڈ) {this.head = نیا اسکیپلسٹنوڈ (نمبر (نمبر.min_safe_integer) ؛this.head.down = نیا اسکیپلسٹنوڈ (قدر) ؛} موجودہ = this.head ؛چلو دو: اسکیپلسٹنوڈ |null = null ؛// نیچے کی سطح کے راستے کا راستہ ٹریک کریں: اسکیپلسٹنوڈ [] = [] ؛// نیچے کی سطح میں داخل کرنے کی پوزیشن تلاش کریں جبکہ (موجودہ) {اگر (موجودہ۔ ویلیو === ویلیو) {// قیمت پہلے سے موجود ہے ، واپسی داخل نہ کریں۔} if (موجودہ. نیکسٹ === null || موجودہ. next.value> ویلیو) {پاتھ.پش (موجودہ) ؛موجودہ = موجودہ۔ ڈاون ؛} else {موجودہ = موجودہ. نیکسٹ ؛}} آئیے insertabove = سچ ؛ڈاون نوڈ: اسکیپلسٹنوڈ |null = null ؛// ہر سطح میں نیا نوڈ داخل کریں (آئیے i = this.maxlevel-1 ؛ i> = 0 ؛ i--) {موجودہ = راستہ [i] ؛Const newnode = نیا اسکیپلسٹنوڈ (قدر) ؛اگر (insertabove) {newnode.down = ڈاؤن نوڈ ؛ڈاون نوڈ = newnode ؛} newnode.next = موجودہ. نیکسٹ ؛موجودہ۔ نیکسٹ = نیو نوڈ ؛// تصادفی طور پر فیصلہ کریں کہ آیا Insertabove = math.random () <this.levelprobability کے اوپر کی سطح داخل کرنا ہے یا نہیں۔}} تلاش (قیمت: نمبر): بولین {آئیے موجودہ = this.head ؛// قیمت کو تلاش کرنے کے لئے اسکیپ لسٹ کو عبور کریں جبکہ (موجودہ) {اگر (موجودہ.Value === ویلیو) {سچ واپس ؛} دوسری صورت میں اگر (موجودہ۔ نیکسٹ === نول} else {موجودہ = موجودہ. نیکسٹ ؛}} غلط لوٹائیں ؛}} // مثال کے طور پر استعمال: کونسٹ اسکیپلسٹ = نیا اسکیپلسٹ () ؛ اسکیپلسٹ.نسرٹ (3) ؛ اسکیپلسٹ.نسرٹ (1) ؛ اسکیپلسٹ.سرٹ (4) ؛ اسکیپلسٹ.سرٹ (2) ؛ کنسول.لوگ (اسکیپلسٹ.چارچ۔(2)) ؛// آؤٹ پٹ: trueconsole.log (skiplist.search (5)) ؛// آؤٹ پٹ: اس آسان عمل کو نفاذ میں ، ہمارے پاس دو کلاس ہیں: اسکیپلسٹنوڈ اسکیپ لسٹ میں ایک نوڈ کی نمائندگی کرتا ہے ، اور اسکیپلسٹ اسکیپ لسٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ اسکیپلسٹنوڈ کلاس میں تین خصوصیات ہیں: نوڈ کی قیمت ، اگلے پوائنٹس اگلے پوائنٹس کے پاس ہے۔نوڈ ایک ہی سطح میں ، اور نیچے کی سطح میں نوڈ کی طرف اشارہ کرتے ہیں۔ اسکیپلسٹ کلاس میں تین خصوصیات ہیں: اسکیپ لسٹ کے اوپری بائیں نوڈ کی طرف ہیڈ پوائنٹس ، میکسلیول اسکیپ لسٹ کے لئے زیادہ سے زیادہ سطح کی نمائندگی کرتا ہے (اس معاملے میں اس معاملے میں، 16) ، اور لیولپروبیبلٹی نوڈ کے اعلی سطح پر ہونے کے امکانات کا تعین کرتی ہے۔ داخل کرنے کا طریقہ داخل کرتا ہے"
    },
    {
        "Question": "تصویری جنریشن کے لئے جنریٹو ایڈورسیریل نیٹ ورک (GAN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!یہاں ایک ٹائپ اسکرپٹ پروگرام کی ایک مثال ہے جو گراف پر گہرائی سے پہلے تلاش کرتی ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: ریکارڈ <سٹرنگ ، سٹرنگ []> ؛کنسٹرکٹر () {this.adjacencyList = {} ؛} ایڈورٹیکس (ورٹیکس: سٹرنگ) {if (! this.adjacencyList [vertex]) {this.adjacencyList [vertex] = [] ؛}} ایڈج (ورٹیکس 1: سٹرنگ ، ورٹیکس 2: سٹرنگ) {this.adjacencyList [vertex1] .push (vertex2) ؛this.adjacencyList [vertex2] .Push (vertex1) ؛} ڈیپٹفیرسٹ سرچ (اسٹارٹورٹیکس: سٹرنگ) {کنسٹٹ ملاحظہ کریں: ریکارڈ <سٹرنگ ، بولین> = {} ؛کانسٹ ڈی ایف ایس = (ورٹیکس: سٹرنگ) => {ملاحظہ کیا [ورٹیکس] = سچ ؛کنسول.لاگ (ورٹیکس) ؛// ورٹیکس (جیسے ، پرنٹ) کے ساتھ کچھ کریں۔ ایڈجیسی لسٹ [ورٹیکس]} ؛ڈی ایف ایس (اسٹارٹورٹیکس) ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈورٹیکس (\"A\") ؛ گراف.اڈورٹیکس (\"بی\") ؛ گراف.اڈٹورٹیکس (\"سی\") ؛ گراف.اڈٹورٹیکس (\"ڈی\")؛ گراف.اڈورٹیکس (\"ای\") ؛ گراف.اڈیج (\"اے\" ، \"بی\") ؛ گراف.ڈیج (\"اے\" ، \"سی\") ؛ گراف.ڈیج (\"بی\" ، \"ڈی\") ؛ گراف.Addedge (\"C\" ، \"E\") ؛ گراف.ڈیپٹفیرسٹ سرچ (\"A\") ؛ اس مثال میں ، ہم گراف میں عمودی اور کناروں کو شامل کرنے کے طریقوں کے ساتھ گراف کلاس کی وضاحت کرتے ہیں۔ڈیپتھفیرسٹ سرچ کا طریقہ کسی دیئے گئے ورٹیکس سے شروع ہونے والی گہرائی کی پہلی تلاش کو انجام دیتا ہے۔اس میں گراف کو عبور کرنے اور ہر ایک ورٹیکس سے ملنے کے لئے ایک بار بار چلنے والا مددگار فنکشن ڈی ایف ایس کا استعمال کیا جاتا ہے۔ ڈی ایف ایس فنکشن ایک دلیل کے طور پر ایک عمومی طور پر لیتا ہے ، اسے دیکھنے کے طور پر نشان زد کرتا ہے ، اور ورٹیکس (اس معاملے میں ، اس کی طباعت) پر مطلوبہ کارروائی کرتا ہے۔اس کے بعد ، یہ موجودہ ورٹیکس کے ہر غیر منحصر پڑوسی پر بار بار ڈی ایف ایس کو کال کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم گراف کلاس کی ایک مثال بناتے ہیں اور عمودی (\"A\" ، \"B\" ، \"C\" ، \"D\" ، \"شامل کرتے ہیں۔ای \") اور گراف میں کناروں۔آخر میں ، ہم \"A\" کے ابتدائی حد کے ساتھ گہرائی سے چلنے والے طریقہ کار کو کہتے ہیں۔ گہرائی کی پہلی تلاش کے دوران ، پروگرام گراف کو گہرائی سے پہلے انداز میں عبور کرے گا ، اور ہر ایک حد کا دورہ کرے گا اور اس کی قیمت پرنٹ کرے گا۔آؤٹ پٹ وہ ترتیب ہوگا جس میں عمودی دورے کا دورہ کیا جائے گا۔"
    },
    {
        "Question": "بیچ تدریجی نزول اور اسٹاکسٹک تدریجی نزول میں کیا فرق ہے؟",
        "Answer": "خود توازن بائنری سرچ درخت ، جیسے AVL درخت یا سرخ رنگ کے درخت کو نافذ کرنا کافی پیچیدہ ہوسکتا ہے۔اس کے بجائے ، میں آپ کو ٹائپ اسکرپٹ میں AVL درخت کا مثال فراہم کروں گا۔اے وی ایل کا درخت ایک خود متوازن بائنری سرچ درخت ہے جو موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو یقینی بنانے کے لئے متوازن ڈھانچے کو برقرار رکھتا ہے۔یہاں ایک مثال کے نفاذ ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛اونچائی: نمبر ؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛this.height = 1 ؛}} کلاس avltree {جڑ: Treenode |خالی؛کنسٹرکٹر () {this.root = null ؛} getheight (نوڈ: ٹرینوڈ | null): نمبر {اگر (نوڈ ==== null) {واپس 0 ؛} نوڈ. height ؛} getBalanceFactor (نوڈ: Treenode | null): نمبر {if (node === null) {واپس 0 ؛this اس کو واپس کریں۔} اپ ڈیٹ ہائٹ (نوڈ: ٹرینوڈ) {نوڈ.ہائٹ = میتھ.میکس (this.getheight (node.left) ، this.getheight (node.right)) + 1 ؛} روٹیرائٹ (نوڈ: ٹرینوڈ): ٹرینوڈ {کونسٹ نیوروٹ = نوڈ.لفٹ ؛const temp = newrot.right ؛newrot.right = نوڈ ؛node.left = temp ؛this.updateHeight (نوڈ) ؛this.updateHeight (newrot) ؛واپس نیو روٹ ؛} گھومنے والی چیز (نوڈ: ٹرینوڈ): ٹرینوڈ {کونسٹ نیو روٹ = نوڈ. رائٹ ؛const temp = newrot.left ؛newrot.left = نوڈ ؛node.right = temp ؛this.updateHeight (نوڈ) ؛this.updateHeight (newrot) ؛واپس نیو روٹ ؛} داخل کریں (قیمت: نمبر) {this.root = this.insertnode (this.root ، value) ؛} Insertnode (نوڈ: ٹرینوڈ | null ، value: نمبر): treenode {if (نوڈ === null) {واپس نیا ٹرینوڈ (قیمت) واپس کریں ؛} if (value <node.value) {node.left = this.insertnode (node.left ، value) ؛} else {node.right = this.insertnode (node.right ، value) ؛} this.updateHeight (نوڈ) ؛کونسٹ بیلنس فیکٹر = this.getBalanceFactor (نوڈ) ؛// بائیں-بائیں کیس اگر (بیلنس فیکٹر> 1 && ویلیو <نوڈ.لفٹ! .Value) {اس کو واپس کریں۔} // دائیں رائٹ کیس اگر (بیلنس فیکٹر <-1 && ویلیو> نوڈ. رائٹ! .Value) {اس کو واپس کریں۔} // بائیں بازو کا معاملہ اگر (بیلنس فیکٹر> 1 && ویلیو> نوڈ۔ لیفٹ!اس کو واپس کریں۔ روٹیرائٹ (نوڈ) ؛} // دائیں- بائیں کیس اگر (بیلنس فیکٹر <-1 && ویلیو <نوڈ. رائٹ!اس کو واپس کریں۔} واپسی نوڈ ؛} تلاش (ویلیو: نمبر): بولین {واپس کریں۔} سرچنوڈ (نوڈ: ٹرینوڈ | نول ، ویلیو: نمبر): بولین {اگر (نوڈ === null) {غلط واپس ؛} if (value === node.value) {سچ واپس ؛} دوسری صورت میں اگر (ویلیو <نوڈ.والیو) {اس کی سرچ نوڈ (نوڈ.لفٹ ، ویلیو) واپس کریں ؛} دوسری {اس کی تلاش کریں۔ سرچنوڈ (نوڈ. رائٹ ، قدر)}} ہٹائیں (ویلیو: نمبر) {this.root = this.remove"
    },
    {
        "Question": "ایک گرم انکوڈنگ کے تصور اور اس کے استعمال کے متغیر متغیر کی نمائندگی کرنے میں اس کے استعمال کی وضاحت کریں۔",
        "Answer": "یقینا!انٹیگرس کی ایک صف پر انضمام کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن انضمام انضمام (ARR: نمبر []): نمبر [] {اگر (arr.length <= 1) {واپسی ARR ؛} کانٹ مڈل = ریاضی۔ فلور (arr.length / 2) ؛کانسٹ لیفٹار = آر آر ایس سلائس (0 ، درمیانی) ؛کونٹ رائٹ آر = آر آر ایس سلائس (درمیانی) ؛const sootdleftarr = انضمام (بائیں بازو) ؛const shordrightArr = انضمام (رائٹ آر) ؛واپسی انضمام (shartedleftarr ، shortedrightArr) ؛} فنکشن انضمام (بائیں بازو: نمبر [] ، دائیں: نمبر []): نمبر [] {cont wargedar: نمبر [] = [] ؛بائیں بازو کی طرف چلیں = 0 ؛آئیے رائٹ انڈیکس = 0 ؛جبکہ (بائیں انڈیکس <بائیں بازو کی لمبائی && رائٹ انڈیکس <رائٹ آر. لمبائی) {اگر (بائیں بازو [بائیں انڈیکس] <رائٹ آئر [رائٹ انڈیکس]) {انضمام شدہ اے آر آر۔ پش (بائیں بازو [بائیں انڈیکس]) ؛بائیں انڈیکس ++ ؛} دوسری {انضمام.رائٹ انڈیکس ++ ؛}} // بائیں سرنی سے باقی عناصر شامل کریں جبکہ (بائیں انڈیکس <بائیں بازو کی لمبائی) {انضمام arr.push (lethar [lethar [lethindex]) ؛بائیں انڈیکس ++ ؛} // باقی عناصر کو دائیں صف سے شامل کریں جبکہ (رائٹ انڈیکس <رائٹ آر. لمبائی) {انضمام شدہ۔رائٹ انڈیکس ++ ؛} واپس انضمام}} // مثال کے طور پر استعمال: Const arr = [8 ، 4 ، 2 ، 7 ، 1 ، 5 ، 9 ، 3 ، 6] const const shordarr = انضمام (arr) ؛ کنسول.لوگ (ترتیبر) ؛// آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] اس مثال میں ، ہمارے دو کام ہیں: انضمام اور انضمام۔انضمام کی تقریب ایک صف لیتی ہے اور بار بار اس کو دو حصوں میں تقسیم کرتی ہے جب تک کہ بیس کیس تک نہ پہنچ جائے (یعنی ، صف میں صرف ایک یا صفر عناصر ہوتے ہیں)۔اس کے بعد یہ انضمام کی تقریب کا استعمال کرتے ہوئے ترتیب شدہ آدھےوں کو ضم کرتا ہے اور ترتیب شدہ صف کو واپس کرتا ہے۔ انضمام کی تقریب دو ترتیب شدہ صفوں (لیفٹیر اور رائٹ آر) لیتی ہے اور انہیں ایک ہی ترتیب شدہ صف میں ضم کرتی ہے۔یہ دونوں صفوں کے عناصر کا موازنہ کرتا ہے اور چھوٹے عنصر کو انضمام کرنے والی سرنی میں شامل کرتا ہے جب تک کہ تمام عناصر کو ضم نہیں کردیا جاتا۔ مثال کے طور پر استعمال کے حصے میں ، ہم غیر ترتیب شدہ عدد کے ساتھ ایک صف آر آر بناتے ہیں۔اس کے بعد ہم انضمام پر انضمام کو کال کرتے ہیں تاکہ انضمام کی کارکردگی کا مظاہرہ کیا جاسکے اور ترتیب شدہ نتیجہ کو ترتیب دیا گیا ہو۔آخر میں ، ہم کنسول میں ترتیب شدہ سرنی چھانٹری کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "درجہ بندی کے لئے سپورٹ ویکٹر مشین (ایس وی ایم) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینی کوڈ {بچے: نقشہ <سٹرنگ ، ٹرائینوڈ> ؛isendofword: بولین ؛کنسٹرکٹر () {this.children = نیا نقشہ () ؛this.isendofword = غلط ؛class} کلاس ٹری {جڑ: ٹرائنوڈ ؛کنسٹرکٹر () {this.root = new trienode () ؛} داخل کریں (لفظ: سٹرنگ) {موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛if (! موجودہ.کرین. has (چار)) {موجودہ.چلرین.سیٹ (چار ، نیا ٹرائینوڈ ()) ؛} موجودہ = کرنٹ.کرینین.بیٹ (چار) !؛} موجودہ.Isendofword = سچ ؛} تلاش (لفظ: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛اگر (! موجودہ۔ چائلڈرین.ہاس (چار)) {غلط لوٹائیں ؛} موجودہ = کرنٹ.کرینین.بیٹ (چار) !؛current موجودہ. آئسنڈفورڈ کو لوٹائیں ؛} اسٹارٹ ویتھ (سابقہ: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <prefix.length ؛ i ++) {const char = prefix [i] ؛اگر (! موجودہ۔ چائلڈرین.ہاس (چار)) {غلط لوٹائیں ؛} موجودہ = کرنٹ.کرینین.بیٹ (چار) !؛} سچ واپس ؛}} // مثال کے طور پر استعمال: const trie = new trie () ؛ trie.insert (\"ایپل\") ؛ trie.insert (\"کیلے\") ؛ trie.insert (\"اورینج\") ؛ کنسول.لوگ (trie.search (trie.search (\"سیب\"))؛// آؤٹ پٹ: trueconsole.log (trie.search (\"کیلے\")) ؛// آؤٹ پٹ: trueconsole.log (trie.search (\"اورنج\")) ؛// آؤٹ پٹ: trueconsole.log (trie.search (\"انگور\")) ؛// آؤٹ پٹ: falseconsole.log (trie.startswith (\"app\")) ؛// آؤٹ پٹ: trueconsole.log (trie.startswith (\"پابندی\")) ؛// آؤٹ پٹ: trueconsole.log (trie.startswith (\"یا\")) ؛// آؤٹ پٹ: trueconsole.log (trie.startswith (\"GR\")) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ہمارے پاس دو کلاس ہیں: ٹرینیوڈ اور ٹری۔ٹرائینوڈ ٹری میں ایک نوڈ کی نمائندگی کرتا ہے ، اور ٹری ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔ ٹرائینوڈ کلاس میں دو خصوصیات ہیں: بچے ، جو ایک ایسا نقشہ ہے جو موجودہ نوڈ کے بچوں کے نوڈس کو محفوظ کرتا ہے ، اور آئسنڈوف ورڈ ، جو اس بات کی نشاندہی کرتا ہے کہ آیا موجودہ نوڈایک لفظ کے اختتام کو نشان زد کرتا ہے۔ ٹری کلاس میں ایک پراپرٹی ، جڑ ہے ، جو ٹری کے جڑ نوڈ کی نمائندگی کرتی ہے۔اس کے پاس ٹرائی میں ایک لفظ داخل کرنے ، ٹرائی میں ایک لفظ تلاش کرنے کے لئے طریقے داخل کرنے ، تلاش کرنے اور شروع کرنے والے طریقے ہیں ، اور یہ چیک کریں کہ کیا ٹری میں کوئی لفظ یا سابقہ موجود ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ایک مثال تیار کرتے ہیں۔ٹرائی کلاس اور داخل کرنے کے طریقہ کار کا استعمال کرتے ہوئے ٹری میں تین الفاظ (\"ایپل\" ، \"کیلے\" ، \"اورینج\") داخل کریں۔اس کے بعد ہم یہ چیک کرنے کے لئے تلاش کے طریقہ کار کا مظاہرہ کرتے ہیں کہ آیا ٹرائی اور اسٹارٹ ویتھ کے طریقہ کار میں مخصوص الفاظ موجود ہیں یا نہیں یہ چیک کرنے کے لئے کہ آیا ٹرائی میں مخصوص سابقہ موجود ہیں یا نہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "اعصابی نیٹ ورکس میں ڈراپ آؤٹ ریگولائزیشن کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں یہاں ایک مثال پروگرام ہے جس کا تعین کرنے کے لئے کہ آیا بائنری ٹری متوازن ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن isbalanced (جڑ: ٹرینوڈ | null): بولین {اگر (جڑ ==== null) {سچ واپس ؛} const getheight = (نوڈ: treenode | null): نمبر => {اگر (نوڈ === null) {واپس 0 ؛} کونسٹ لیفٹ ہائٹ = getheight (node.left) ؛کانسٹ رائٹ ہائٹ = گیٹھائٹ (نوڈ. رائٹ) ؛واپس میتھ۔ میکس (بائیں بازو ، رائٹ ہائٹ) + 1 ؛} ؛const isbalancedhelper = (نوڈ: ٹرینوڈ | null): بولین => {اگر (نوڈ ==== null) {سچ واپس ؛} کونسٹ لیفٹ ہائٹ = getheight (node.left) ؛کانسٹ رائٹ ہائٹ = گیٹھائٹ (نوڈ. رائٹ) ؛کانس اونچائی ڈف = ریاضی۔ اے بی ایس (بائیں بازو - رائٹ ہائٹ) ؛اگر (اونچائی ڈف> 1) {غلط لوٹیں ؛} isbalancedhelper (node.left) && isbalancedhelper (node.right) واپس کریں ؛} ؛isbalancedhelper (جڑ)} // مثال کے طور پر استعمال: کانسٹ روٹ = نیا ٹرینوڈ (1) ؛ روٹ. لیفٹ = نیا ٹرینوڈ (2) ؛ روٹ. رائٹ = نیا ٹرینوڈ (3) ؛ روٹ.لفٹ!. لیفٹ = نیا ٹرینوڈ(4) root روٹ. لیفٹ!// آؤٹ پٹ: trueroot.right! .left = new Treenode (6) ؛ جڑ.ایچ!// آؤٹ پٹ: اس مثال کے طور پر ، ہمارے پاس ایک ٹرینوڈ کلاس ہے جو بائنری درخت میں نوڈ کی نمائندگی کرتا ہے۔isbalanced فنکشن بائنری درخت کی جڑ نوڈ کو ان پٹ کے طور پر لے جاتا ہے اور بولین کی قیمت کو لوٹاتا ہے جس سے یہ ظاہر ہوتا ہے کہ درخت متوازن ہے یا نہیں۔ گیٹائٹ فنکشن اس کے بائیں اور دائیں کی اونچائی کا حساب کتاب کرکے درخت میں دیئے گئے نوڈ کی اونچائی کا حساب لگاتا ہے۔سبٹری۔یہ بائیں اور دائیں سبٹریس کے درمیان زیادہ سے زیادہ اونچائی لوٹاتا ہے ، نیز 1. اس بیلنسڈ ہیلپر فنکشن چیک کرتا ہے اگر اس کے بائیں اور دائیں سبٹریوں کی اونچائیوں کا موازنہ کرکے نوڈ متوازن ہے۔اگر اونچائیوں کے مابین مطلق فرق 1 سے زیادہ ہے تو ، یہ غلط لوٹتا ہے۔بصورت دیگر ، یہ بار بار جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں سبٹریز متوازن ہیں۔ مثال کے طور پر استعمال کے حصے میں ، ہم نوڈس کے ساتھ بائنری ٹری بناتے ہیں اور اقدار تفویض کرتے ہیں۔اس کے بعد ہم اس بات کا تعین کرنے کے لئے روٹ نوڈ پر islanced فنکشن کو کال کرتے ہیں کہ درخت متوازن ہے یا نہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "پہلے سے تربیت یافتہ ماڈلز اور ٹھیک ٹوننگ کا استعمال کرتے ہوئے منتقلی کے سیکھنے کے تصور کی وضاحت کریں۔",
        "Answer": "دو قطاروں کا استعمال کرتے ہوئے اسٹیک پر عمل درآمد عناصر کے مرکزی ذخیرہ کرنے کے لئے ایک قطار اور معاون کارروائیوں کے لئے دوسری قطار کا استعمال کرکے حاصل کیا جاسکتا ہے۔ٹائپ اسکرپٹ میں دو قطاروں کا استعمال کرتے ہوئے اسٹیک پر عمل درآمد یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسٹیک {مین کیوئو: نمبر [] ؛auxqueue: نمبر [] ؛کنسٹرکٹر () {this.mainqueue = [] ؛this.auxqueue = [] ؛} پش (ویلیو: نمبر) {// تمام عناصر کو مینکیو سے آکسکیو میں منتقل کریں جبکہ (this.mainqueue.length> 0) {this.auxqueue.push (this.mainqueue.shift ()!) ؛} // نئے عنصر کو mainqueue میں شامل کریں۔// تمام عناصر کو Auxqueue سے mainqueue پر واپس منتقل کریں جبکہ (this.auxqueue.length> 0) {this.mainqueue.push (this.auxqueue.shift ()!) ؛}} پاپ (): نمبر |غیر وضاحتی {اس کو واپس کریں۔} جھانکنے (): نمبر |غیر وضاحتی {اس کو واپس کریں۔} isempty (): بولین {واپس کریں۔} سائز (): نمبر {اس کو واپس کریں۔}} // مثال کے طور پر استعمال: کانسٹ اسٹیک = نیا اسٹیک () اسٹیک.پش (1) ؛ اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛ کنسول.لوگ (اسٹیک.پپ ()) ؛// آؤٹ پٹ: 3console.log (stack.peek ()) ؛// آؤٹ پٹ: 2console.log (stack.isempty ()) ؛// آؤٹ پٹ: falseconsole.log (stack.size ()) ؛// آؤٹ پٹ: 2 میں اس مثال کے طور پر ، ہمارے پاس ایک اسٹیک کلاس ہے جو اسٹیک آپریشنز کی تقلید کے لئے دو قطاریں (مین کیوئو اور آکسکیو) استعمال کرتی ہے۔ پش طریقہ اسٹیک میں ایک عنصر کو شامل کرتا ہے۔یہ سب سے پہلے تمام عناصر کو مین کیو سے آکسکیو کی طرف لے جاتا ہے ، پھر نئے عنصر کو مین کیوئ میں شامل کرتا ہے ، اور آخر کار تمام عناصر کو آکسکیو سے مین کیوئ کی طرف لے جاتا ہے۔اس سے یہ یقینی بنتا ہے کہ نیا عنصر ہمیشہ قطار کے سامنے والے حصے میں شامل کیا جاتا ہے ، جس سے اسٹیک کے طرز عمل کی نقالی ہوتی ہے۔ پاپ کا طریقہ کار مین کیوئ کے پاپ طریقہ کا استعمال کرکے اسٹیک سے اوپر عنصر کو ہٹاتا ہے اور واپس کرتا ہے۔ جھانکنے کا طریقہ اوپر لوٹاتا ہے۔اسٹیک کا عنصر مین کیوئ کے آخری عنصر تک رسائی حاصل کرکے اسے ہٹائے بغیر۔ آئی ایس ای ٹی ایم پی طریقہ چیک کرتا ہے کہ اگر اسٹیک مین کیوئ کی لمبائی کی جانچ کر کے خالی ہے۔mainqueue.in مثال کے استعمال کے حصے میں ، ہم اسٹیک کلاس کی ایک مثال تیار کرتے ہیں ، تین عناصر کو اسٹیک پر دھکیل دیتے ہیں ، اور پاپ ، جھانکنے ، آئسیمپٹی اور سائز کو کال کرکے اسٹیک کی کارروائیوں کا مظاہرہ کرتے ہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "مشین لرننگ میں ڈیٹا پری پروسیسنگ اور صفائی کے عمل کی وضاحت کریں۔",
        "Answer": "یقینا!کڈنے کے الگورتھم کا استعمال کرتے ہوئے عددی کی ایک صف میں زیادہ سے زیادہ سبریے کا مجموعہ تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن میکسبرسم (اے آر آر: نمبر []): نمبر {آئیے میکسم = آر آر [0] ؛آئیے کرینٹسم = آر آر [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {کرینٹسم = math.max (arr [i] ، کرینٹسم+arr [i]) ؛میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛max میکسم واپسی} // مثال کے طور پر استعمال: کانسٹ سرنی = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] ؛ کانسٹ میکسم = میکسبرسم (سرنی) ؛ کنسول.لاگ (میکسم (میکسم)) ؛// آؤٹ پٹ: 6 ان مثال کے طور پر ، میکسبرارسم فنکشن ان پٹ کے طور پر عدد کی ایک صف لیتا ہے اور زیادہ سے زیادہ سبری کا مجموعہ واپس کرتا ہے۔فنکشن زیادہ سے زیادہ رقم کو موثر انداز میں تلاش کرنے کے لئے کڈانے کے الگورتھم کا استعمال کرتا ہے۔ الگورتھم دو متغیرات کی ابتدا کرتا ہے: میکسم اور کرینسم ، دونوں صف کے پہلے عنصر پر سیٹ کرتے ہیں۔اس کے بعد یہ دوسرے عنصر سے شروع ہونے والی صف کے ذریعے تکرار کرتا ہے۔ ہر عنصر کے ل it ، یہ نئے کرینٹسم کا حساب کتاب موجودہ عنصر کی زیادہ سے زیادہ یا موجودہ عنصر کے طور پر کرتا ہے جس میں پچھلے کرینٹسم میں شامل کیا جاتا ہے۔یہ قدم طے کرتا ہے کہ آیا نیا سبری شروع کرنا یا موجودہ سبری کو جاری رکھنا فائدہ مند ہے۔ میکسم متغیر کو اب تک پائے جانے والے زیادہ سے زیادہ رقم کو ذخیرہ کرنے کے لئے ہر تکرار پر اپ ڈیٹ کیا جاتا ہے۔ لوپ کے اختتام پر ، میکسم متغیر میں زیادہ سے زیادہ سبریئر رقم ہوتی ہے ،جس کے بعد اس کو واپس کردیا گیا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم انٹیجرز کے ساتھ ایک سرنی سرنی بناتے ہیں اور زیادہ سے زیادہ سبراے رقم تلاش کرنے کے لئے سرے پر میکسبرسم فنکشن کو کال کرتے ہیں۔نتیجہ کنسول پر چھپا ہوا ہے۔"
    },
    {
        "Question": "سفارشات کے نظام میں ماڈل پر مبنی اور میموری پر مبنی باہمی تعاون کے ساتھ فلٹرنگ میں کیا فرق ہے؟",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ میں بائنری ہیپ ڈیٹا ڈھانچے (خاص طور پر ایک کم سے کم ہیپ) کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بائنری ہیپ {ہیپ: نمبر [] ؛کنسٹرکٹر () {this.heap = [] ؛} getleftChildIndex (پیرنٹ انڈیکس: نمبر): نمبر {واپسی 2 * پیرنٹ انڈیکس + 1 ؛} getRightChildIndex (پیرنٹ انڈیکس: نمبر): نمبر {واپسی 2 * پیرنٹ انڈیکس + 2 ؛} getParentIndex (ChildIndex: نمبر): نمبر {ریٹرن میتھ.فلور ((چائلڈ انڈیکس - 1) / 2) ؛} ہاسلفائلڈ (انڈیکس: نمبر): بولین {واپس کریں۔} ہاس رائٹچائلڈ (انڈیکس: نمبر): بولین {اس کو واپس کریں۔ گیٹ رائٹچلڈ انڈیکس (انڈیکس) <this.heap.length ؛} ہاسپینٹ (انڈیکس: نمبر): بولین {اس کو واپس کریں۔ گیٹ پیرینٹ انڈیکس (انڈیکس)> = 0 ؛} بائیں بچے (انڈیکس: نمبر): نمبر {اس کو واپس کریں۔} رائٹائڈ (انڈیکس: نمبر): نمبر {اس کو واپس کریں۔} والدین (انڈیکس: نمبر): نمبر {اس کو واپس کریں۔} تبادلہ (انڈیکس 1: نمبر ، انڈیکس 2: نمبر): باطل {const temp = this.heap [index1] ؛this.heap [index1] = this.heap [index2] ؛this.heap [index2] = عارضی ؛} جھانکنے (): نمبر |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛this اس کو واپس کریں۔ ہیپ [0] ؛} پول (): نمبر |غیر وضاحتی {اگر (this.heap.length === 0) {غیر واضح شدہ واپس ؛} const آئٹم = this.heap [0] ؛this.heap [0] = this.heap [this.heap.length - 1] ؛this.heap.pop () ؛this.heapifydown () ؛آئٹم واپس ؛} شامل کریں (آئٹم: نمبر): باطل {this.heap.push (آئٹم) ؛this.heapifyup () ؛} ہیپیف اپ (): باطل {آئیے انڈیکس = this.heap.length - 1 ؛جبکہ (this.hasparent (index) && this.parent (index)> this.heap [index]) {cont parentindex = this.getParentIndex (انڈیکس) ؛this.swap (پیرنٹ انڈیکس ، انڈیکس) ؛انڈیکس = پیرنٹ انڈیکس ؛}} ہیپیفائ ڈاون (): باطل {آئیے انڈیکس = 0 ؛جبکہ (this.hasleftchild (index)) small smallerchild index = this.getleftchildindex (انڈیکس) ؛اگر (this.hasrightائلڈ (انڈیکس) && this.righticald (index) <this.leftchild (index)) {smallerchild index = this.getRightChildindex (انڈیکس) ؛} if (this.heap [index] <this.heap [smallerchildindex]) {بریک ؛} else {this.swap (انڈیکس ، smallerchildindex) ؛} انڈیکس = چھوٹے بچے}}} // مثال کے طور پر استعمال: کانسٹ ہیپ = نیا بائنری ہیپ () ؛ ہیپ.اڈ (5) ؛ ہیپ.اڈڈ (3) ؛ ہیپ.اڈ (8) ؛ ہیپ.اڈ (1) ؛ ہیپ.اڈ (9)؛ کنسول.لاگ (ہیپ.پول ()) ؛// آؤٹ پٹ: 1console.log (ہیپ.پول ()) ؛// آؤٹ پٹ: 3console.log (ہیپ.پیک ()) ؛// آؤٹ پٹ: 5 اس مثال کے طور پر ، ہمارے پاس بائنری ہیپ کلاس ہے جو بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس نفاذ میں خاص طور پر ایک کم سے کم عنصر پر توجہ دی جاتی ہے ، جہاں کم سے کم عنصر ہمیشہ جڑ میں ہوتا ہے۔ کلاس میں بائیں بچے ، دائیں بچے ، والدین اور ڈھیر میں عناصر کے اشارے تک رسائی حاصل کرنے کے طریقے شامل ہیں۔یہ ڈھیر (ADD) میں عناصر شامل کرنے ، جڑ عنصر (پول) کو بازیافت اور ہٹانے ، اور جڑ عنصر پر جھانکنے کے لئے بھی طریقے مہیا کرتا ہے۔"
    },
    {
        "Question": "قدرتی زبان پروسیسنگ کے کاموں میں ورڈ 2 وی ای سی ایمبیڈنگز اور ان کے استعمال کے تصور کی وضاحت کریں۔",
        "Answer": "یقینا!کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک سٹرنگ تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل عرصے سے پالندروومکسبسٹرنگ (ایس: سٹرنگ): سٹرنگ {آئیے شروع کریں = 0 ؛آئیے زیادہ سے زیادہ = 0 ؛// ایک سینٹر کانسٹرینڈ سینٹر = (بائیں: نمبر ، دائیں: نمبر) کے ارد گرد پھیلانے کے لئے ہیلپر فنکشن: باطل => {جبکہ (بائیں> = 0 && دائیں <s.length && s [بائیں] === s [دائیں]) {Const موجودہ لمبائی = دائیں - بائیں + 1 ؛اگر (موجودہ لمبائی> زیادہ سے زیادہ لمبائی) {اسٹارٹ = بائیں ؛maxlength = موجودہ لمبائی ؛}      بائیں--؛حق ++ ؛}} ؛کے لئے (آئیے i = 0 ؛ i <s.length ؛ i ++) {توسیعی ساؤنڈ سینٹر (i ، i) ؛// عجیب لمبائی پیلنڈرووم وسعت کا مرکز (i ، i + 1) ؛// یہاں تک کہ لمبائی کی لمبائی palindrome} واپسی s.substring (شروع کریں ، start + maxlength) ؛} // مثال کے طور پر استعمال: کانسٹ ان پٹ = \"باباڈ\" ؛ کانسٹنٹ طویل ترینپال انڈرووم = طویل ترینپال انڈروومکسوبسٹرنگ (ان پٹ) ؛ کنسول.لاگ (طویل ترین پالندرووم) ؛// آؤٹ پٹ: \"باب\" اس مثال میں ، سب سے طویل پالائنڈرومکسبسٹرنگ فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور ایس کے اندر سب سے طویل پیلنڈرومک اسٹرنگ لوٹاتا ہے۔ فنکشن پیلنڈرمک سبسٹرنگز کو تلاش کرنے کے لئے کسی مرکز کے گرد پھیلنے کے تصور کو استعمال کرتا ہے۔یہ تار میں ہر کردار کے ذریعے تکرار کرتا ہے اور اسے کسی ممکنہ پیلنڈرووم کا مرکز سمجھتا ہے۔اس کے بعد یہ مرکز سے باہر کی طرف پھیلتا ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دونوں اطراف کے کردار برابر ہیں۔یہ مستقل طور پر جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں حرف برابر ہیں اور ونڈو کو اس وقت تک پھیلاتے ہیں جب تک کہ حروف اب برابر نہ ہوں یا تار ختم نہ ہوں۔لمبائی پیلنڈرووم (دو حروف کے درمیان مرکز)۔اس میں تمام ممکنہ پیلنڈرومک سبسٹرنگز کا احاطہ کیا گیا ہے۔ لوپ کے بعد ، فنکشن اسٹارٹ انڈیکس سے میکس لمبائی کی لمبائی کے ساتھ سٹرنگ لوٹاتا ہے ، جو ان پٹ سٹرنگ میں پائے جانے والے سب سے طویل پیلنڈرومک اسٹرنگ کی نمائندگی کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ایک نمونہ ان پٹ سٹرنگ فراہم کرتے ہیں۔ان پٹ اور اس پر طویل ترین پالندومکسبسٹرنگ فنکشن کو کال کریں۔نتیجہ ، سب سے طویل پیلنڈرومک اسٹرنگ ، کنسول پر چھاپتا ہے۔"
    },
    {
        "Question": "ترتیب کی پیش گوئی کے لئے ایک طویل قلیل مدتی میموری (LSTM) نیٹ ورک کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں گراف کی نمائندگی کرنے کے لئے ملحقہ میٹرکس کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ میٹرکس: نمبر [] [] ؛کنسٹرکٹر (نمبر: نمبر) {this.adjacencymatrix = [] ؛کے لئے (i = 0 ؛ i <numvertices ؛ i ++) {this.adjacencymatrix [i] = [] ؛کے لئے (j = 0 ؛ j <numvertices ؛ j ++) {this.adjacencymatrix [i] [j] = 0 ؛}}} ایڈجڈ (ماخذ: نمبر ، منزل: نمبر): باطل {this.adjacencymatrix [ماخذ] [منزل] = 1 ؛this.adjacencymatrix [منزل] [ماخذ] = 1 ؛} ریمجج (ماخذ: نمبر ، منزل: نمبر): باطل {this.adjacencymatrix [ماخذ] [منزل] = 0 ؛this.adjacencymatrix [منزل] [ماخذ] = 0 ؛} پرنٹ گراف (): باطل {کے لئے (i = 0 ؛ i <this.adjacencymatrix.length ؛ i ++) {const row = this.adjacencymatrix [i] ؛کنسول.لاگ (قطار.جوئن ('')) ؛}}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف (5) ؛ گراف.ڈیج (0 ، 1) ؛ گراف.ڈیج (0 ، 4) ؛ گراف.ڈیج (1 ، 2) ؛ گراف.ڈیج (1 ، 1 ،3) ؛ گراف.ڈیج (1 ، 4) گراف.ڈیج (2 ، 3) ؛ گراف.اڈیج (3 ، 4) ؛ گراف.پنٹ گراف () ؛ اس مثال میں ، گراف کلاس ملحقہ میٹرکس کا استعمال کرتے ہوئے گراف کی نمائندگی کرتا ہے. کنسٹرکٹر ان پٹ کے طور پر عمودی کی تعداد لیتا ہے اور تمام اقدار کے ساتھ ایک خالی ملحق میٹرکس کو شروع کرتا ہے۔ملحقہ میٹرکس میں متعلقہ اندراجات کو 0. پر ترتیب دے کر دو عمودی کے درمیان غیر مستقیم کنارے گراف کی ملحقہ میٹرکس کی نمائندگی کو کنسول پر پرنٹ کرتا ہے۔اس کے بعد ہم ایڈج کے طریقہ کار کا استعمال کرتے ہوئے متعدد کناروں کو شامل کرتے ہیں اور پرنٹ گراف کے طریقہ کار کا استعمال کرتے ہوئے ملحقہ میٹرکس پرنٹ کرتے ہیں۔نتیجے میں ملحقہ میٹرکس کنسول ڈاٹ نوٹ میں ظاہر ہوتا ہے: مذکورہ بالا عمل درآمد ایک غیر ہدایت شدہ گراف فرض کرتا ہے ، جہاں کنارے دو طرفہ ہیں۔اگر آپ کو ہدایت شدہ گراف کی نمائندگی کرنے کی ضرورت ہے تو ، آپ ہر ہدایت والے کنارے کے لئے ملحقہ میٹرکس میں صرف ایک اندراج طے کرنے کے لئے ایڈج اور ہٹانے کے طریقوں میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "اعصابی نیٹ ورک کی تربیت میں جلد رکنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "یقینا!ایک درخت پر گہرائی سے پہلے تلاش (DFS) انجام دینے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بچے: ٹرینوڈ [] ؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.children = [] ؛} ایڈچائڈ (بچہ: ٹرینوڈ): باطل {this.children.push (بچہ) ؛}} فنکشن ڈی ایف ایس (نوڈ: ٹرینوڈ): باطل {کنسول.لوگ (نوڈ.والیو) ؛کے لئے (نوڈ. بچوں کا بچ child ہ) {DFS (بچہ) ؛}} // مثال کے طور پر استعمال: کانسٹ روٹ = نیا ٹرینوڈ (1) const کنٹڈ چلڈ 1 = نیا ٹرینوڈ (2) ؛ کانسٹ چلڈ 2 = نیا ٹرینوڈ (3) ؛ کنسٹ پوتے 1 = نیا ٹرینوڈ (4) ؛ کنسٹ پوتے 2 = نیا ٹرینوڈ (5) ؛ روٹ.اڈائڈائڈ (چائلڈ 1) ؛ روٹ.اڈڈائڈ (چائلڈ 2) ؛ چائلڈ 1۔ڈیڈچائلڈ (پوتے 1) ؛ چائلڈ 2۔اڈڈچائلڈ (پوتے 2) ؛ ڈی ایف ایس (روٹ) ؛ اس مثال میں ، ہمارے پاس درخت میں نوڈ کی نمائندگی کرنے والا ایک ٹرینوڈ کلاس ہے۔ہر نوڈ میں بچوں کی نوڈس کی ایک قدر اور ایک صف ہوتی ہے۔ ایڈڈائڈ کا طریقہ بچوں کو بچوں کی صف میں دھکیل کر بچوں کے نوڈس کو شامل کرنے کی اجازت دیتا ہے۔ ڈی ایف ایس فنکشن درخت پر گہرائی کی پہلی تلاش کرتا ہے۔یہ ان پٹ کے طور پر ایک نوڈ لیتا ہے اور موجودہ نوڈ کی قیمت پرنٹ کرکے شروع ہوتا ہے۔اس کے بعد ، یہ موجودہ نوڈ کے ہر بچے پر ڈی ایف ایس کو بار بار کال کرتا ہے ، جس سے درخت کو مؤثر طریقے سے گہرائی سے پہلے کی تلاش ہوتی ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ٹرینوڈ کی مثال بنا کر اور ایڈڈچڈ کے طریقہ کار کا استعمال کرتے ہوئے ان کو جوڑ کر درخت کا ڈھانچہ بناتے ہیں۔اس کے بعد ہم گہرائی سے پہلے تلاش کرنے کے لئے روٹ نوڈ پر ڈی ایف ایس کو کال کرتے ہیں۔نوڈس کی اقدار کنسول پر چھاپے جاتے ہیں ، جو درخت کی گہرائی سے پہلے ٹراورسل کا مظاہرہ کرتے ہیں۔ نوٹ: یہ مثال درختوں کی ایک عام ڈھانچہ فرض کرتی ہے جہاں ہر نوڈ میں بہت سے بچے ہوسکتے ہیں۔اگر آپ کے پاس درختوں کا مخصوص ڈھانچہ ہے تو ، آپ ٹرینوڈ کلاس اور اس کے مطابق مثال کے استعمال میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "ٹی سن (ٹی تقسیم شدہ اسٹاکسٹک پڑوسی ایمبیڈنگ) کے تصور کی وضاحت کریں اور طول و عرض میں کمی میں اس کے استعمال۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں راہ کے کمپریشن کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے (جسے یونین-فنڈ ڈیٹا ڈھانچہ بھی کہا جاتا ہے) کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.palent = [] ؛this.rank = [] ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {this.palent [x] = this.find (this.palent [x]) ؛// راستہ کمپریشن} اس کو واپس کریں۔ پیرنٹ [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (روٹ ایکس! == روٹ) {اگر (this.rank [روٹ ایکس] <this.rank [روٹ]) {this.palent [روٹ ایکس] = روٹ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}}} // مثال کے طور پر استعمال: کونسٹ ڈی ایس = نیا ڈسیوئنٹ سیٹ (5) ؛ ڈی ایس یون (0 ، 2) ؛ ڈی ایس یون (4 ، 2) ؛ ڈی ایس (3 ، 1) ؛ کنسول.لوگ (ڈی ایس (ڈی ایس.find (4) === ds.find (0)) ؛// آؤٹ پٹ: trueconsole.log (ds.find (1) === ds.find (2)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ناگوار طبقے کی کلاس راہ کمپریشن کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔ کنسٹرکٹر ناگوار سیٹ کا ابتدائی سائز لیتا ہے اور والدین کی صف اور درجہ بندی کی صف کو شروع کرتا ہے۔والدین کی صف میں ہر عنصر متعلقہ عنصر کے والدین کی نمائندگی کرتا ہے ، اور رینک سرنی ہر عنصر کے درجہ (یا اونچائی) کو اسٹور کرتا ہے۔ تلاش کرنے کا طریقہ اس ناپسندیدہ سیٹ کی جڑ تلاش کرتا ہے جس سے ایکس کا تعلق ہے۔یہ ہر ملاحظہ کرنے والے عنصر کے والدین کو جڑ سے بار بار اپ ڈیٹ کرکے راہ کمپریشن کا استعمال کرتا ہے ، جو درخت کو چپٹا کرنے اور مستقبل کی تلاش کو بہتر بنانے میں مدد کرتا ہے۔ یونین کا طریقہ دو متنازعہ سیٹوں کا اتحاد انجام دیتا ہے جس میں عناصر X اور Y پر مشتمل ہوتا ہے۔اس کو پہلے تلاش کے طریقہ کار کا استعمال کرتے ہوئے سیٹوں کی جڑیں مل جاتی ہیں۔اگر جڑیں مختلف ہیں تو ، یہ ان کی صفوں کا موازنہ کرتا ہے اور جڑ کو نچلے درجے کے ساتھ دوسری جڑ کے والدین بناتا ہے۔اگر درجات برابر ہیں تو ، یہ من مانی طور پر والدین کی حیثیت سے ایک جڑ کا انتخاب کرتا ہے اور اس کے درجہ میں اضافہ ہوتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم 5 کے سائز کے ساتھ ڈس ڈیسپیٹ کلاس کی ایک مثال تیار کرتے ہیں۔چیک کریں کہ آیا کچھ عناصر تلاش کے طریقہ کار کا استعمال کرتے ہوئے ایک ہی سیٹ سے تعلق رکھتے ہیں۔نتائج کنسول پر چھاپے جاتے ہیں ، جو راستے کے کمپریشن کے ساتھ ناپسندیدہ سیٹ ڈیٹا ڈھانچے کی فعالیت کا مظاہرہ کرتے ہیں۔"
    },
    {
        "Question": "درجہ بندی کے لئے بے ترتیب جنگل کے جوڑ کو تربیت دینے میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک مثال پروگرام یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی گراف بائپارٹائٹ ہے: ٹائپ اسکرپٹ کوپی کوڈینم رنگ {غیر رنگین = 0 ، سرخ = 1 ، بلیو = 2 ،} فنکشن آئس بپارٹائٹ (گراف: نمبر [] []): بولین {کانسٹ این = گراف. لمبائی ؛رنگین رنگ: رنگ [] = سرنی (این)کانسٹ ڈی ایف ایس = (نوڈ: نمبر ، رنگ: رنگ): بولین => {رنگ [نوڈ] = رنگ ؛کے لئے (گراف کے پڑوسی [نوڈ]) {اگر (رنگ [پڑوسی] === رنگ) {غلط لوٹیں ؛// ایک ہی رنگ کے ساتھ ملحقہ نوڈس پائے گئے ، بائپارٹائٹ نہیں} if (رنگ [پڑوسی] === رنگین۔// تکرار والی کال غلط لوٹ گئی ، بائپارٹائٹ نہیں}} سچ واپس ؛} ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اگر (رنگ [i] === color.uncolored &&! dfs (i ، color.red)) {غلط واپس ؛// ایک منسلک جزو ملا جو دو طرفہ نہیں ہے}} سچ واپس ؛// تمام منسلک اجزاء بائپارٹائٹ ہیں} // مثال کے طور پر استعمال: کانسٹ گراف 1 = [[1 ، 3] ، [0 ، 2] ، [1 ، 3] ، [0 ، 2]] ؛// بائپارٹائٹ گرافکنسول.لوگ (isbipartite (گراف 1)) ؛// آؤٹ پٹ: trueconst گراف 2 = [[1 ، 2 ، 3] ، [0 ، 2] ، [1 ، 3] ، [0 ، 2]] ؛// نہیں بائپارٹائٹ گرافکنسول.لوگ (isbipartite (گراف 2)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، isbipartite فنکشن ایک گراف لیتا ہے جس کی نمائندگی ملحقہ فہرست (گراف) کی حیثیت سے ہوتی ہے اور اگر گراف دو طرفہ اور غلط ہے تو صحیح لوٹتا ہے۔دو رنگوں سے رنگین رہیں جیسے کسی ملحقہ نوڈس کا رنگ ایک ہی نہیں ہوتا ہے۔ رنگین اینوم نوڈس کے لئے تین ممکنہ رنگوں کی وضاحت کرتا ہے: غیر رنگین ، سرخ اور نیلے رنگ۔غیر رنگین رنگ اس بات کی نشاندہی کرتا ہے کہ ابھی تک نوڈ کا رنگ نہیں ہوا ہے۔ ڈی ایف ایس مددگار فنکشن گہرائی کی پہلی تلاش کرتا ہے۔یہ ان پٹ کے طور پر ایک نوڈ اور رنگ لیتا ہے۔یہ موجودہ نوڈ کو مخصوص رنگ کے ساتھ رنگ دیتا ہے اور اپنے پڑوسیوں پر ڈی ایف ایس کو بار بار کال کرتا ہے ، اس بات کو یقینی بناتا ہے کہ وہ مخالف رنگ (3 - رنگ) کے ساتھ رنگین ہیں۔اگر اس کا سامنا کسی پڑوسی سے ہوتا ہے جو پہلے ہی ایک ہی رنگ کے ساتھ رنگین ہوچکا ہے تو ، یہ غلط لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ گراف دو طرفہ نہیں ہے۔اگر ایک بار بار چلنے والی کال غلط لوٹتی ہے تو ، فنکشن بھی غلط لوٹاتا ہے۔ اس بائپارٹائٹ فنکشن کی اہم منطق گراف میں ہر نوڈ کے ذریعے تکرار کرتی ہے۔اگر ابھی تک نوڈ کا رنگ نہیں ہوا ہے (رنگین۔اگر ڈی ایف ایس کے دوران کوئی منسلک جزو دو طرفہ نہیں پایا جاتا ہے تو ، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، اگر تمام منسلک اجزاء کامیابی کے ساتھ رنگین ہیں اور کوئی تنازعات نہیں پائے جاتے ہیں تو ، فنکشن سچ کو واپس کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم دو مثال گراف (گراف 1 اور گراف 2) فراہم کرتے ہیں۔ہم ہر گراف پر isbipartite فنکشن کہتے ہیں اور نتائج کو کنسول پر پرنٹ کرتے ہیں ، مختلف گرافوں کے لئے دو طرفہ چیک کا مظاہرہ کرتے ہیں۔"
    },
    {
        "Question": "لکیری رجعت پسند ماڈلز میں L1 اور L2 کو باقاعدہ بنانے میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بلوم فلٹر {بٹیرے: بولین [] ؛numhashfunctions: نمبر ؛کنسٹرکٹر (سائز: نمبر ، نمبر ہاشفکشن: نمبر) {this.bitarray = نیا سرنی (سائز). فل (غلط) ؛this.numhashfunctions = numhashfunctions ؛} شامل کریں (عنصر: سٹرنگ): باطل {کانسٹ ہیش = this.gethashes (عنصر) ؛کے لئے (ہیش کا ہیش) {this.bitarray [ہیش] = سچ ؛}} پر مشتمل ہے (عنصر: سٹرنگ): بولین {کانسٹ ہیش = this.gethashes (عنصر) ؛کے لئے (ہیش کا ہیش) {اگر (! this.bitarray [ہیش]) {جھوٹی لوٹ ؛}} سچ واپس ؛} نجی گیٹشیس (عنصر: سٹرنگ): نمبر [] {کانسٹ ہیش: نمبر [] = [] ؛کے لئے (آئیے i = 1 ؛ i <= this.numhashfunctions ؛ i ++) {const hash = this.hash (عنصر ، i) ؛ہیش۔ پش (ہیش) ؛} ہیشوں کی واپسی ؛} نجی ہیش (عنصر: سٹرنگ ، بیج: نمبر): نمبر {آئیے ہیش = 0 ؛کے لئے (آئیے i = 0 ؛ i <عنصری. لمبائی ؛ i ++) {ہیش = (ہیش * بیج+عنصر۔ charcodeat (i)) ٪ this.bitarray.length ؛} ہیش کی واپسی ؛}} // مثال کے طور پر استعمال: کانسٹ فلٹر = نیا بلوم فلٹر (100 ، 3) ؛ فلٹر.اڈ ('ایپل') ؛ فلٹر.اڈ ('کیلے') ؛ فلٹر.اڈڈ ('چیری') ؛ کنسول.لوگ (فلٹر (فلٹر.کونٹینز ('ایپل')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.کونٹینز ('کیلے')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.کونٹینز ('چیری')) ؛// آؤٹ پٹ: trueconsole.log (فلٹر.کونٹینز ('انگور')) ؛// آؤٹ پٹ: اس مثال کے طور پر ، بلوم فلٹر کلاس ایک سے زیادہ ہیش فنکشنز کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ کنسٹرکٹر دو پیرامیٹرز لیتا ہے: سائز (بٹ سرنی کا سائز) اور نمبرشفکشن (استعمال کرنے کے لئے ہیش افعال کی تعداد).شامل کرنے کا طریقہ بلوم فلٹر میں عنصر شامل کرتا ہے۔یہ گیٹشیس کے طریقہ کار کا استعمال کرتے ہوئے عنصر کے لئے متعدد ہیشوں کا حساب لگاتا ہے اور بٹ سرنی میں متعلقہ پوزیشنوں کو سچ پر سیٹ کرتا ہے۔ اگر کوئی عنصر بلوم فلٹر میں موجود ہے تو اس کا طریقہ چیک کرتا ہے۔یہ جیٹھاشس کے طریقہ کار کا استعمال کرتے ہوئے عنصر کے لئے ہیشوں کا حساب لگاتا ہے اور چیک کرتا ہے کہ کیا بٹ سرنی میں تمام متعلقہ پوزیشنیں درست ہیں۔اگر کوئی پوزیشن غلط ہے تو ، یہ غلط لوٹتی ہے۔بصورت دیگر ، یہ سچ لوٹتا ہے۔ گیٹشیس کا طریقہ مختلف بیجوں کی اقدار کے لئے ہیش کے طریقہ کار کو طلب کرکے کسی عنصر کے لئے متعدد ہیشوں کا حساب لگاتا ہے۔ ہیش کا طریقہ مخصوص بیج کا استعمال کرتے ہوئے کسی عنصر کے لئے ہیش کی قیمت کا حساب لگاتا ہے۔یہ عنصر کے ہر کردار کے ذریعے تکرار کرتا ہے ، ایک سادہ ہیشنگ الگورتھم (ضرب اور ماڈیولو) انجام دیتا ہے ، اور اس کے نتیجے میں ہیش ویلیو کو لوٹاتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم بلوم فلٹر کلاس کی ایک مثال بناتے ہیں جس میں 100 اور 3 کے تھوڑا سا سرنی سائز ہوتا ہے۔ہیش کے افعال.ہم ADD کے طریقہ کار کا استعمال کرتے ہوئے فلٹر میں تین عناصر شامل کرتے ہیں اور پھر چیک کریں کہ آیا اس میں شامل طریقہ کار کا استعمال کرتے ہوئے فلٹر میں کئی عناصر موجود ہیں یا نہیں۔بلوم فلٹر کی فعالیت کا مظاہرہ کرتے ہوئے نتائج کنسول پر چھاپے جاتے ہیں۔"
    },
    {
        "Question": "اعصابی نیٹ ورکس میں توجہ کے طریقہ کار کے تصور اور ترتیب سے ترتیب کے کاموں میں ان کے استعمال کی وضاحت کریں۔",
        "Answer": "یقینا!ہدایت شدہ ایسائکلک گراف (ڈی اے جی) پر ٹوپولوجیکل ترتیب دینے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: نقشہ <نمبر ، نمبر []> ؛کنسٹرکٹر () {this.adjacencyList = نیا نقشہ <نمبر ، نمبر []> () ؛} ایڈورٹیکس (ورٹیکس: نمبر): باطل {if (! this.adjacencylist.has (vertex)) {this.adjacencylist.set (vertex ، []) ؛}} ایڈج (سے: نمبر ، سے: نمبر): باطل {اگر (! this.adjacencylist.has (منجانب) ||گراف. ') ؛} کنسٹ پڑوسی = this.adjacencyList.get (منجانب) ؛پڑوسی۔ پش (سے) ؛} ٹوپولوجسٹسورٹ (): نمبر [] {کنسٹٹ ملاحظہ کریں: سیٹ <نمبر> = نیا سیٹ <نمبر> () ؛کانسٹ اسٹیک: نمبر [] = [] ؛کانسٹ ڈی ایف ایس = (ورٹیکس: نمبر): باطل => {ملاحظہ کیا گیا۔ ایڈ (ورٹیکس) ؛کنسٹ پڑوسی = this.adjacencyList.get (ورٹیکس) ؛اگر (پڑوسی) {کے لئے (پڑوسیوں کے پڑوسی) {اگر (! ملاحظہ کیا گیا۔ (پڑوسی)) {ڈی ایف ایس (پڑوسی) ؛}}} اسٹیک.پش (ورٹیکس) ؛} ؛کے لئے (اس کی کانسٹریکس۔ adjacencylist.keys ()) {اگر (! ملاحظہ کیا گیا۔ ہاس (ورٹیکس)) {DFS (ورٹیکس) ؛}} ریٹرن اسٹیک۔ ریورس () ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈورٹیکس (1) ؛ گراف.اڈورٹیکس (2) ؛ گراف.اڈورٹیکس (3) ؛ گراف.اڈورٹیکس (4) ؛ گراف.اڈورٹیکس (5) ؛گراف.اڈورٹیکس (6) ؛ گراف.ڈیج (1 ، 2) ؛ گراف.اڈیج (1 ، 3) ؛ گراف.ڈیج (2 ، 3) ؛ گراف.اڈیج (2 ، 4) ؛ گراف.اڈیج (3 ، 5) ؛ گراف.اڈیج (4 ، 6) ؛ گراف.ڈیج (5 ، 6) ؛ ترتیب ترتیب دیں// آؤٹ پٹ: [1 ، 2 ، 4 ، 3 ، 5 ، 6] اس مثال میں ، گراف کلاس ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرتا ہے۔اس میں ایک ملحقہ فہرست ہے جو ہر ایک کو اپنے پڑوسیوں کی فہرست میں نقشہ بناتی ہے۔ ایڈورٹیکس کا طریقہ کار ہمسایہ ممالک کی خالی صف کے ساتھ ملحقہ فہرست میں داخلہ بنا کر گراف میں ایک ورٹیکس کو شامل کرتا ہے۔ ایڈجڈ کا طریقہ ایک ورٹیکس سے ہدایت شدہ کنارے کو شامل کرتا ہے (سے) کسی دوسرے ورٹیکس (to) سے لے کر پڑوسیوں کی فہرست میں شامل کرکے۔ ٹوپولوجسٹسورٹ کا طریقہ ٹوپولوجیکل ترتیب دیتا ہے۔یہ گراف کو دریافت کرنے کے لئے گہرائی میں پہلی تلاش (DFS) نقطہ نظر کا استعمال کرتا ہے اور ان کے آخری اوقات کے الٹ ترتیب میں اسٹیک میں عمودی کو شامل کرتا ہے۔ایک عمودی وقت کے آخری وقت کی وضاحت اس وقت کے طور پر کی جاتی ہے جب اسے اپنے تمام پڑوسیوں سے ملنے کے بعد اسٹیک پر دھکیل دیا جاتا ہے۔آخر میں ، یہ ٹوپولوجیکل آرڈرنگ حاصل کرنے کے لئے اسٹیک کو الٹ ترتیب میں لوٹاتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم ایک گراف مثال بناتے ہیں اور ڈی اے جی کی نمائندگی کرنے کے لئے عمودی اور کناروں کو شامل کرتے ہیں۔اس کے بعد ہم ٹوپولوجیکل سارٹ طریقہ کو ٹوپولوجیکل ترتیب دینے اور ترتیب شدہ عمودی کو حاصل کرنے کے لئے کال کرتے ہیں۔ترتیب شدہ عمودی کنسول پر چھاپے جاتے ہیں ، جس میں گراف کی ٹوپولوجیکل قسم کا مظاہرہ ہوتا ہے۔"
    },
    {
        "Question": "Q- لرننگ کا استعمال کرتے ہوئے گہری کمک سیکھنے کے ایجنٹ کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں K-D ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {نقطہ: نمبر [] ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (نقطہ: نمبر []) {this.Point = نقطہ ؛this.left = null ؛this.right = null ؛}} کلاس kdtree {جڑ: Treenode |خالی؛طول و عرض: نمبر ؛کنسٹرکٹر (طول و عرض: نمبر) {this.root = null ؛this.dimensions = طول و عرض ؛} داخل کریں (نقطہ: نمبر []): باطل {this.root = this.insertnode (this.root ، نقطہ ، 0) ؛} نجی Insertnode (نوڈ: ٹرینوڈ | null ، نقطہ: نمبر [] ، گہرائی: نمبر): ٹرینوڈ {اگر (نوڈ ==== null) {واپس نیا ٹرینوڈ (نقطہ) واپس کریں ؛const کنٹین کرنٹ ڈیمینشن = گہرائی ٪ اس۔اگر (نقطہ [موجودہ تدوین] <نوڈ.پوائنٹ [کرنٹ ڈیمینشن]) {node.left = this.insertnode (node.left ، نقطہ ، گہرائی + 1) ؛} else {node.right = this.insertnode (node.right ، نقطہ ، گہرائی + 1) ؛} واپسی نوڈ ؛} تلاش (نقطہ: نمبر []): بولین {اس کو واپس کریں۔ سرچنوڈ (یہ.روٹ ، پوائنٹ ، 0) ؛} نجی سرچ نوڈ (نوڈ: ٹرینوڈ | NULL ، نقطہ: نمبر [] ، گہرائی: نمبر): بولین {اگر (نوڈ ==== null) {غلط واپس ؛} if (this.arepointseal (node.Point ، نقطہ)) {سچ واپس ؛const کنٹین کرنٹ ڈیمینشن = گہرائی ٪ اس۔اگر (نقطہ [موجودہ جہت] <نوڈ.پوائنٹ [کرنٹ ڈیمینشن]) this اس کو واپس لوٹائیں۔} else {اس کی سرچ نوڈ (نوڈ.رائٹ ، پوائنٹ ، گہرائی + 1) واپس کریں ؛priective} پرائیویٹ سیکوئل (پوائنٹ 1: نمبر [] ، پوائنٹ 2: نمبر []): بولین {کے لئے (i = 0 ؛ i <this.dimensions ؛ i ++) {اگر (پوائنٹ 1 [i]! == پوائنٹ 2 [i]){جھوٹا لوٹ ؛}} سچ واپس ؛}} // مثال کے طور پر استعمال: کانسٹ kdtree = new kdtree (2) ؛ kdtree.insert ([3 ، 6]) ؛ kdtree.insert ([17 ، 15]) ؛ kdtree.insert ([13 ، 15]) ؛ kdtree.INSERT ([6 ، 12]) ؛ kdtree.insert ([9 ، 1]) ؛ kdtree.insert ([2 ، 7]) ؛ کنسول.لوگ (kdtree.search ([6 ، 12]) ؛// آؤٹ پٹ: trueconsole.log (kdtree.search ([13 ، 15])) ؛// آؤٹ پٹ: trueconsole.log (kdtree.search ([10 ، 10])) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ٹرینوڈ کلاس K-D درخت میں نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں طول و عرض کی لمبائی ، ایک بائیں بچے اور دائیں بچے کا ایک نقطہ ہوتا ہے۔ Kdtree کلاس K-D درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ ہے اور درخت میں طول و عرض کی تعداد ہے۔ داخل کرنے کا طریقہ INSERTNODE کے طریقہ کار کو کال کرکے K-D کے درخت میں ایک نیا نقطہ داخل کرتا ہے۔INSERTNODE کا طریقہ درخت کو بار بار عبور کرتا ہے ، موجودہ جہت کی اقدار کا موازنہ کرتا ہے تاکہ اس بات کا تعین کیا جاسکے کہ آیا بائیں یا دائیں سب ٹری میں نقطہ داخل کرنا ہے یا نہیں۔گہرائی کا استعمال درخت کی ہر سطح پر موجودہ جہت کا تعین کرنے کے لئے کیا جاتا ہے۔ تلاش کا طریقہ کار سرچنوڈ کے طریقہ کار کو کال کرکے K-D درخت میں دیئے گئے نقطہ کی تلاش کرتا ہے۔سرچنوڈ کا طریقہ درخت کو بار بار عبور کرتا ہے ، بائیں یا دائیں سب ٹری پر تشریف لے جانے کے لئے موجودہ جہت کی اقدار کا موازنہ کرتا ہے۔اگر نقطہ پایا جاتا ہے تو ، یہ سچ واپس آجاتا ہے۔ورنہ ،"
    },
    {
        "Question": "اعصابی نیٹ ورکس میں بیچ کو معمول پر لانے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "یقینا!بائنری درخت میں دو نوڈس کے سب سے کم عام اجداد کو تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن سب سے کم کامونانسیسٹر (جڑ: ٹرینوڈ | نول ، پی: ٹرینوڈ ، Q: ٹرینوڈ): ٹرینوڈ |null {if (جڑ === null || جڑ === p || جڑ === Q) {روٹ روٹ ؛} کانسٹ بائیں = سب سے کم کامونانسیسٹر (روٹ. لیفٹ ، پی ، کیو) ؛کونٹ رائٹ = کم ترین کامونانسیسٹر (جڑ۔ رائٹ ، پی ، کیو) ؛اگر (بائیں! == null && دائیں! == null) {روٹ روٹ ؛left بائیں طرف لوٹ! == null؟بائیں: دائیں ؛} // مثال کے طور پر استعمال: کانسٹ روٹ = نیا ٹرینوڈ (3) ؛ روٹ. لیفٹ = نیا ٹرینوڈ (5) ؛ روٹ. رائٹ = نیا ٹرینوڈ (1) ؛ روٹ.لفٹ.لفٹ = نیا ٹرینوڈ (6)؛ روٹ. لیفٹ۔ رائٹ = نیا ٹرینوڈ (2) ؛ روٹ۔ رائٹ.لیفٹ = نیا ٹرینوڈ (0) ؛ روٹ. رائٹ. رائٹ = نیا ٹرینوڈ (8) ؛ روٹ.لفٹ.رائٹ.لیفٹ = نیا ٹرینوڈ (7)؛ root.left.right.right = new Treenode (4) ؛ const p = root.left ؛// قیمت کے ساتھ نوڈ// قیمت کے ساتھ نوڈ// آؤٹ پٹ: 5 اس مثال کے طور پر ، ٹرینوڈ کلاس بائنری درخت میں نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں اس کے بائیں اور دائیں بچوں کی قدر اور حوالہ ہوتا ہے۔ سب سے کم کامکومنانسٹر فنکشن تین پیرامیٹرز لیتا ہے: بائنری ٹری کی جڑ اور دو نوڈس پی اور کیو جس کے لئے ہم سب سے کم عام آباؤ اجداد تلاش کرنا چاہتے ہیں۔یہ بائنری کے درخت کو عبور کرنے کے لئے ایک بار بار نقطہ نظر استعمال کرتا ہے۔ ہر نوڈ پر ، یہ چیک کرتا ہے کہ آیا موجودہ نوڈ یا تو P یا Q ہے یا null ہے۔اگر ایسا ہے تو ، یہ موجودہ نوڈ کو سب سے کم عام آباؤ اجداد کے طور پر لوٹاتا ہے۔غیر نول اقدار ، اس کا مطلب یہ ہے کہ پی اور کیو مختلف سب ٹریوں میں موجود ہیں ، اور موجودہ نوڈ سب سے کم عام آباؤ اجداد ہے۔بصورت دیگر ، یہ نان نول سب ٹری کے نتائج یا کالعدم کو واپس کرتا ہے اگر دونوں سب ٹریوں کی مثال کے طور پر استعمال کے حصے میں ، ہم ایک بائنری ٹری بناتے ہیں اور اسے اقدار کے ساتھ شروع کرتے ہیں۔ہم درخت کے اندر دو نوڈس کے طور پر پی اور کیو کی وضاحت کرتے ہیں۔اس کے بعد ہم ان کے سب سے کم عام آباؤ اجداد کو تلاش کرنے کے لئے جڑوں اور دو نوڈس کے ساتھ سب سے کم کامونانسیسٹر فنکشن کہتے ہیں۔سب سے کم عام آباؤ اجداد نوڈ کی قدر کنسول پر چھپی ہوئی ہے۔"
    },
    {
        "Question": "غیر منقولہ سیکھنے کے کاموں میں آٹو انکوڈرز کے تصور اور ان کے استعمال کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک سپلیپ ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {کلید: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (کلید: نمبر) {this.key = key ؛this.left = null ؛this.right = null ؛}} کلاس splaytree {جڑ: Treenode |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (کلید: نمبر): باطل {اگر (this.root === null) {this.root = نیا ٹرینوڈ (کلید) ؛واپسی ؛} this.splay (کلید) ؛اگر (کلید <this.root.key) {const newnode = نیا ٹرینوڈ (کلید) ؛newnode.left = this.root.left ؛newnode.right = this.root ؛this.root.left = null ؛this.root = newnode ؛} دوسری صورت میں اگر (key> this.root.key) {const newnode = new Treenode (key) ؛newnode.right = this.root.right ؛newnode.left = this.root ؛this.root.right = null ؛this.root = newnode ؛}} تلاش (کلید: نمبر): بولین {this.splay (key) ؛اس کو واپس کریں!} نجی سپلی (کلید: نمبر): باطل {اگر (this.root === null || this.root.key === key) {واپسی ؛} کنسٹ ڈمی: ٹرینوڈ = {کلید: 0 ، بائیں: NULL ، دائیں: null} ؛بائیں طرف جانے دیں = ڈمی ؛آئیے رائٹ مین = ڈمی ؛آئیے موجودہ نوڈ = this.root ؛جبکہ (سچ ہے) {اگر (کلید <موجودہ نوڈ.کی) {اگر (موجودہ نوڈ.لفٹ ==== null) {بریک ؛} if (key <موجودہ نوڈ.لفٹ.کی) {const temp = pertionnode.left ؛موجودہ نوڈ.لفٹ = ٹیمپ. رائٹ ؛temp.right = موجودہ نوڈ ؛موجودہ نوڈ = عارضی ؛اگر (موجودہ نوڈ.لفٹ === null) {بریک ؛}} رائٹرمین.لفٹ = کرنٹ نوڈ ؛رائٹرمین = کرنٹ نوڈ ؛موجودہ نوڈ = کرنٹنوڈ.لفٹ ؛} دوسری صورت میں اگر (key> reverthynode.key) {if (currentnode.right ==== null) {بریک ؛} if (key> reverthynode.right.key) {const temp = retighternode.right ؛موجودہ نوڈ۔ رائٹ = temp.left ؛temp.left = موجودہ نوڈ ؛موجودہ نوڈ = عارضی ؛اگر (موجودہ نوڈ۔ رائٹ === null) {بریک ؛}} بائیں ٹری میکس۔ رائٹ = کرنٹ نوڈ ؛بائیں ٹری میکس = کرنٹ نوڈ ؛کرنٹنوڈ = کرنٹنوڈ. رائٹ ؛} دوسری {بریک ؛}} بائیں ٹری میکس. رائٹ = کرنٹنوڈ.لفٹ ؛رائٹرمین.لفٹ = کرنٹنوڈ. رائٹ ؛موجودہ نوڈ. لیفٹ = ڈمی. رائٹ ؛موجودہ نوڈ۔ رائٹ = dummy.left ؛this.root = موجودہ نوڈ ؛}} // مثال کے طور پر استعمال: Const splaytree = new splaytree () spla splaytree.insert (10) ؛ splaytree.insert (5) ؛ splaytree.insert (15) ؛ splaytree.insert (3) ؛ splaytree.insert (8) ؛splaytree.insert (12) ؛ splaytree.insert (17) ؛ کنسول.لوگ (splaytree.search (8)) ؛// آؤٹ پٹ: trueconsole.log (splaytree.search (12)) ؛// آؤٹ پٹ: trueconsole.log (splaytree.search (20)) ؛// آؤٹ پٹ: اس مثال کے طور پر ، ٹرینوڈ کلاس سپلی کے درخت میں ایک نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں ایک کلید ، اس کے بائیں بچے کا حوالہ ، اور اس کے دائیں بچے کا حوالہ ہوتا ہے۔ اسپلٹری کلاس اسپلٹ ٹری کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ ہے۔ داخل کرنے کا طریقہ سپلے کے درخت میں ایک نئی کلید داخل کرتا ہے"
    },
    {
        "Question": "کلسٹرنگ کے لئے گاوسی مکسچر ماڈل (جی ایم ایم) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "نیٹ ورک کے بہاؤ کے مسئلے میں زیادہ سے زیادہ بہاؤ تلاش کرنے کے ل you ، آپ فورڈ فلکرسن الگورتھم یا اس کی ایک مختلف حالتوں ، جیسے ایڈمنڈس-کارپ الگورتھم یا ڈائنک کے الگورتھم کا استعمال کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں ایڈمنڈس کارپ الگورتھم کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {نجی گراف: نمبر [] [] ؛کنسٹرکٹر (گراف: نمبر [] []) {this.graph = گراف ؛bified نجی بی ایف ایس (ماخذ: نمبر ، ہدف: نمبر ، والدین: نمبر []): بولین {کنسٹٹ ملاحظہ کریں = نئی سرنی (اس. گراف.لنتھ). فل (غلط) ؛کانسٹ قطار: نمبر [] = [] ؛قطار.پش (ماخذ) ؛دورہ [ماخذ] = سچ ؛والدین [ماخذ] = -1 ؛جبکہ (قطار۔ لمبائی> 0) {کونسٹ یو = قطار۔ شفٹ () !؛کے لئے (آئیے v = 0 ؛ v <this.graph.length ؛ v ++) {اگر (! ملاحظہ کیا [v] && this.graph [u] [v]> 0) {قطار.پش (v) ؛دورہ [v] = سچ ؛والدین [v] = u ؛}}} واپسی کا دورہ [ہدف] ؛} نجی منکاسیٹی (راستہ: نمبر [] ، والدین: نمبر []): نمبر {آئیے منٹ کیپاسیٹی = انفینٹی ؛آئیے v = راستہ [راستہ۔ لمبائی - 1] ؛جبکہ (v! == 0) {const u = والدین [v] ؛mincapacity = math.min (mincapacity ، this.graph [u] [v]) ؛v = u ؛min mincapacity واپس ؛} نجی اپڈیٹرسیڈیول گراف (راستہ: نمبر [] ، والدین: نمبر [] ، منکاسیٹی: نمبر): باطل {چلو v = راستہ [راستہ۔ لمبائی - 1] ؛جبکہ (v! == 0) {const u = والدین [v] ؛this.graph [u] [v] -= mincapacity ؛this.graph [v] [u] += mincapacity ؛v = u ؛}} پبلک میکس فلو (ماخذ: نمبر ، ہدف: نمبر): نمبر {مستقل والدین: نمبر [] = نیا سرنی (اس.گراف.لنتھ) ؛آئیے زیادہ سے زیادہ = 0 ؛جبکہ (this.bfs (ماخذ ، ہدف ، والدین)) {const mincapacity = this.mincapacity ([ہدف] ، والدین) ؛this.updateresidual گراف ([ہدف] ، والدین ، mincapacity) ؛میکس فلو += mincapacity ؛} میکس فلو کی واپسی ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = [[0 ، 16 ، 13 ، 0 ، 0 ، 0] ، [0 ، 0 ، 10 ، 12 ، 0 ، 0] ، [0 ، 4 ، 0 ، 0 ، 14 ، 14 ،0] ، [0 ، 0 ، 9 ، 0 ، 0 ، 20] ، [0 ، 0 ، 0 ، 7 ، 0 ، 4] ، [0 ، 0 ، 0 ، 0 ، 0 ، 0 ، 0] ،] ؛ کانس نیٹ ورک =نیا گراف (گراف) Const کانسٹر ماخذ = 0 Const کنٹ ٹارگٹ = 5 ؛ کانسٹ میکس فلو = نیٹ ورک۔ میکس فلو (ماخذ ، ہدف) ؛ کنسول.لوگ (\"زیادہ سے زیادہ بہاؤ:\" ، زیادہ سے زیادہ فلو) ؛ اس مثال میں ، گراف کلاس اس کی نمائندگی کرتا ہےنیٹ ورک فلو گراف۔گراف پراپرٹی ایک دو جہتی صف ہے جو نوڈس کے درمیان کناروں کی صلاحیتوں کو محفوظ کرتی ہے۔ بی ایف ایس کا طریقہ کار سے لے کر ہدف تک بڑھانے والا راستہ تلاش کرنے کے لئے چوڑائی کی پہلی تلاش کرتا ہے۔اگر اس طرح کا راستہ موجود ہے اور مختصر ترین راستے کے ساتھ والدین کی صفوں کو اپ ڈیٹ کرتا ہے تو یہ سچ واپس آتا ہے۔ منکاسیٹی کا طریقہ کار بڑھانے والے راستے کے ساتھ کم سے کم صلاحیت کا تعین کرتا ہے۔ اپڈیٹیرسیڈیول گراف طریقہ راستے کو بڑھانے کے بعد بقایا گراف کی صلاحیتوں کو اپ ڈیٹ کرتا ہے۔"
    },
    {
        "Question": "درجہ بندی کے کاموں میں صحت سے متعلق اور درستگی میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں مستقل اسٹیک ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسٹیک نوڈ <T> {قدر: t ؛اگلا: اسٹیک نوڈ <t> |خالی؛کنسٹرکٹر (ویلیو: ٹی ، اگلا: اسٹیک نوڈ <T> | null) {this.value = value ؛this.next = اگلا ؛class} کلاس مستقل اسٹیک <t> {نجی ورژن: {[کلید: نمبر]: اسٹیک نوڈ <T> |خالی }؛نجی تازہ ترین تبدیلی: نمبر ؛کنسٹرکٹر () {this.versions = {} ؛this.latestversion = 0 ؛یہ۔} پش (ویلیو: ٹی): باطل {کونٹ کرنٹورشن = this.latestversion ؛Const موجودہ ہیڈ = یہ۔کونسٹ نیو ہیڈ = نیا اسٹیک نوڈ (ویلیو ، کرنٹ ہیڈ) ؛this.latestversion ++ ؛یہ۔} پاپ (): باطل {کونٹ کرنٹ ورسن = this.latestversion ؛Const موجودہ ہیڈ = یہ۔اگر (موجودہ ہیڈ === null) {واپسی ؛} this.latestversion ++ ؛یہ۔} ٹاپ (): ٹی |null {const hethead = this.versions [this.latestversion] ؛موجودہ ہیڈ واپس! == کالعدم؟موجودہ ہیڈ. ویلیو: null ؛} getVersion (ورژن: نمبر): t [] {CONST نتیجہ: t [] = [] ؛موجودہ ہیڈ = یہ۔جبکہ (کرنٹ ہیڈ! == null) {نتیجہ۔ پش (موجودہ ہیڈ.Value) ؛موجودہ ہیڈ = کرنٹ ہیڈ. نیکسٹ ؛} واپسی کا نتیجہ ؛}} // مثال کے طور پر استعمال: کانسٹ اسٹیک = نیا مستقل اسٹیک <نمبر> () ؛ اسٹیک.پش (1) ؛ اسٹیک.پش (2) ؛ اسٹیک.پش (3) ؛ کونسٹ ورژن 1 = اسٹیک۔ لیٹسٹورشن ؛ کنسول.لاگ (کنسول.لاگ (stac.getVersion (ورژن 1)) ؛// آؤٹ پٹ: [1 ، 2 ، 3] اسٹیک.پپ () ؛ کنسٹ ورژن 2 = اسٹیک۔ لیٹسٹورشن ؛ کنسول.لوگ (اسٹیک.یٹ گیٹورسیشن (ورژن 2)) ؛// آؤٹ پٹ: [1 ، 2] اسٹیک.پش (4) ؛ کنسٹ ورژن 3 = اسٹیک۔ لیٹسٹورشن ؛ کنسول.لوگ (اسٹیک.یٹ گیٹ انورژن (ورژن 3)) ؛// آؤٹ پٹ: [1 ، 2 ، 4] کنسول.لوگ (اسٹیک.جیٹ وینس (ورژن 1)) ؛// آؤٹ پٹ: [1 ، 2 ، 3] کنسول.لاگ (اسٹیک. ٹاپ ()) ؛// آؤٹ پٹ: 4 ان مثال کے طور پر ، اسٹیک نوڈ کلاس اسٹیک میں نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ میں اسٹیک میں اگلے نوڈ کا ایک قدر اور ایک حوالہ ہوتا ہے۔ مستقل اسٹیک کلاس اسٹیک ڈیٹا ڈھانچے کو مستقل طور پر نافذ کرتا ہے۔یہ اسٹیک کے مختلف ورژن کو ذخیرہ کرنے کے لئے ایک لغت (ورژن) استعمال کرتا ہے۔ہر ورژن ایک منفرد ورژن نمبر کے ساتھ وابستہ ہے۔ پش طریقہ ایک نیا نوڈ بنا کر اور اسٹیک کے تازہ ترین ورژن کو اپ ڈیٹ کرکے اسٹیک میں ایک نئی قدر کا اضافہ کرتا ہے۔ پاپ طریقہ کار کے تازہ ترین ورژن کو اپ ڈیٹ کرکے اسٹیک سے ٹاپ عنصر کو ہٹا دیتا ہے۔اسٹیک۔ اوپر کا طریقہ تازہ ترین ورژن میں اسٹیک کے اوپری عنصر کی قدر لوٹاتا ہے۔ گیٹ ویورشن کا طریقہ نوڈس کو عبور کرکے اور اقدار کی ایک صف کو واپس کرکے اسٹیک کا ایک مخصوص ورژن بازیافت کرتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم تخلیق کرتے ہیں۔ایک مستقل اسٹیک ، اس پر اقدار کو دھکیلیں ، اور گیٹ ویورشن کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے مختلف ورژن بازیافت کریں۔ہم اوپر کے طریقہ کار کا استعمال کرتے ہوئے اسٹیک کے اوپری عنصر تک رسائی حاصل کرنے کی صلاحیت کا بھی مظاہرہ کرتے ہیں۔"
    },
    {
        "Question": "ورڈ فریکوینسی-انورسورس دستاویز فریکوینسی (TF-IDF) اور متن کے تجزیے میں اس کے استعمال کے تصور کی وضاحت کریں۔",
        "Answer": "دو ڈوروں کے مابین مختصر ترین مشترکہ بالادستی تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ استعمال کرسکتے ہیں۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن شارسٹ کامنس اپرسیونسی (str1: سٹرنگ ، str2: سٹرنگ): سٹرنگ {const m = str1.length ؛const n = str2.length ؛// مشترکہ سپرسیوینسس کانس ڈی پی کی لمبائی کو ذخیرہ کرنے کے لئے ایک ٹیبل بنائیں: نمبر [] [] = [] ؛// ٹیبل کو شروع کریں (آئیے i = 0 ؛ i <= m ؛ i ++) {dp [i] = نئی سرنی (n+1). فل (0) ؛} // (i = 1 ؛ i <= m ؛ i ++) {for (j = 1 ؛ j <= n ؛ j ++) {if (str1 [i - 1] === str2 [j- 1]) {dp [i] [j] = 1 + dp [i - 1] [j - 1] ؛} else {dp [i] [j] = math.max (dp [i - 1] [j] ، dp [i] [j - 1]) ؛table}}} // ٹیبل کا استعمال کرتے ہوئے مختصر ترین عام سپرسیئینس کی تعمیر کریں ، سپرسیئنس = \"\" ؛i = m ؛j = n ؛جبکہ (i> 0 && j> 0) {اگر (str1 [i - 1] === str2 [j - 1]) {supressequence = str1 [i - 1] + سپرسیونسی ؛میں--؛J-- ؛} دوسری صورت میں (dp [i - 1] [j]> dp [i] [j - 1]) {supresequence = str1 [i - 1] + سپرسیئینس ؛میں--؛} else {supersequence = str2 [j - 1] + سپرسیئینس ؛J-- ؛}} // str1 سے باقی حروف شامل کریں جبکہ (i> 0) {supersequence = str1 [i - 1] + سپرسیئنس ؛میں--؛} // str2 سے باقی حروف شامل کریں جبکہ (j> 0) {supersequence = str2 [j - 1] + سپرسیئینس ؛J-- ؛sup سپرسیئنس کی واپسی ؛} // مثال کے طور پر استعمال: کانسٹ str1 = \"aggtab\" ؛ const str2 = \"gxtxayb\" ؛ const const const ould = shortscommonsupersequence (str1 ، str2) ؛ کنسول.لوگ (\"مختصر ترین مشترکہ صابن:\" ، نتیجہ) ؛ اس میں ؛مثال کے طور پر ، شارسٹ کامنس اپریسیوینس فنکشن دو ڈور لیتا ہے ، STR1 اور STR2 ، کیونکہ ان پٹ اور مختصر ترین عام سپرسیئنس کو لوٹاتا ہے۔ فنکشن STR1 اور STR2 کے مشترکہ سپرسیوینس کی لمبائی کے ساتھ ایک ٹیبل (DP) کو بھرنے کے لئے متحرک پروگرامنگ نقطہ نظر کا استعمال کرتا ہے۔ٹیبل کو نچلے حصے میں بھرا ہوا ہے ، جس میں ہر پوزیشن پر STR1 اور STR2 کے کرداروں کا موازنہ کیا جاتا ہے۔ ٹیبل کو بھرنے کے بعد ، فنکشن ٹیبل کے نیچے دائیں کونے سے بیک ٹریک کرتے ہوئے مختصر ترین مشترکہ بالادستی کی تعمیر کرتا ہے۔یہ STR1 اور STR2 کے کرداروں کا موازنہ کرتا ہے اور فیصلہ کرتا ہے کہ آیا کردار کو سپرسیئنس میں شامل کیا جائے یا زیادہ سے زیادہ لمبائی کے ساتھ ملحقہ سیل میں منتقل کیا جائے۔دو مثال کے تاروں (str1 اور str2) کے ساتھ مختصر ترین کامنسپرسیکوینس فنکشن۔اس کے نتیجے میں کم ترین مشترکہ سپرسیئنس کنسول پر چھپی ہوئی ہے۔"
    },
    {
        "Question": "جنریٹو ماڈلنگ کے ل a متغیر آٹو اینکوڈر (VAE) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "لاحقہ درخت کو نافذ کرنا ایک پیچیدہ کام ہے ، لیکن میں آپ کو شروع کرنے کے لئے ایک جائزہ اور کوڈ ٹیمپلیٹ فراہم کرسکتا ہوں۔ٹائپ اسکرپٹ میں ایک لاحقہ درخت کا بنیادی نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس لاحقہ لاحقہ لاحقہ {بچے: {[کلید: سٹرنگ]: لاحقہ اسٹرینوڈ} ؛شروع کریں: نمبر ؛اختتام: نمبر ؛کنسٹرکٹر (شروع: نمبر ، اختتام: نمبر) {this.children = {} ؛this.start = start ؛this.end = end ؛} ایڈائلڈ (کلید: سٹرنگ ، نوڈ: لاحقہ): باطل {this.children [key] = نوڈ ؛} گیٹائڈ (کلید: سٹرنگ): لاحقہ اسٹرینوڈ |غیر وضاحتی {اس کو واپس کریں۔ بچوں [کلید] ؛} ہاسچلڈ (کلید: سٹرنگ): بولین {اس میں ریٹرن کلید۔ بچوں ؛}} کلاس لاحقہ {جڑ: لاحقہ ؛متن: تار ؛کنسٹرکٹر (متن: سٹرنگ) {this.text = متن ؛this.root = نیا لاحقہ اسٹرینوڈ (-1 ، -1) ؛this.buildtree () ؛} بلڈ ٹری (): باطل {const n = this.text.length ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {موجودہ = this.root ؛کے لئے (j = i ؛ j <n ؛ j ++) {const key = this.text [j] ؛اگر (موجودہ۔} else {const newnode = نیا لاحقہ اسٹرینوڈ (j ، n - 1) ؛موجودہ.اڈائڈائڈ (کلید ، نیو نوڈ) ؛موجودہ = newnode ؛}}}} تلاش (پیٹرن: سٹرنگ): بولین {آئیے موجودہ = this.root ؛کے لئے (آئیے i = 0 ؛ i <پیٹرن. لمبائی ؛ i ++) {const key = پیٹرن [i] ؛اگر (موجودہ۔} دوسری {جھوٹی لوٹ ؛}} سچ واپس ؛}} // مثال کے طور پر استعمال: کانسٹ ٹیکسٹ = \"کیلے\" ؛ کانسٹ لازمی = نیا لاحقہ (متن) ؛ کنسول.لوگ (لاحقہ۔ سرچ (\"این اے\")) ؛// آؤٹ پٹ: trueconsole.log (لاحقہ. search (\"ana\")) ؛// آؤٹ پٹ: trueconsole.log (لاحقہ۔ سرچ (\"انا\")) ؛// آؤٹ پٹ: trueconsole.log (لاحقہ۔ سرچ (\"ایپل\")) ؛// آؤٹ پٹ: اس مثال کے طور پر ، لاحقہ لاحقہ کلاس لاحقہ درخت میں ایک نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں سبسٹرنگ کے آغاز اور اختتامی پوزیشنوں اور اس کے بچوں کے نوڈس کا نقشہ کے بارے میں معلومات ہوتی ہے۔ لاحقہ کلاس لاحقہ درخت کے ڈیٹا ڈھانچے کو نافذ کرتا ہے۔اس میں ایک روٹ نوڈ اور ایک ٹیکسٹ پراپرٹی ہے جو اصل متن کی نمائندگی کرتی ہے۔ بلڈ ٹری کا طریقہ متن میں ہر کردار پر تکرار کرکے اور درخت میں شامل کرکے لاحقہ درخت کی تعمیر کرتا ہے۔جب ضروری ہو تو یہ نئے نوڈس تیار کرتا ہے اور موجودہ نوڈ کو اپ ڈیٹ کرتا ہے کیونکہ یہ درخت کو عبور کرتا ہے۔ تلاش کا طریقہ لاحقہ درخت میں دیئے گئے نمونہ کی تلاش کرتا ہے۔یہ جڑ سے شروع ہوتا ہے اور اس راستے کی پیروی کرتا ہے جو پیٹرن کے کرداروں سے ملتا ہے۔ مثال کے طور پر استعمال کے حصے میں ، ہم \"کیلے\" کے متن سے ایک لاحقہ درخت بناتے ہیں اور کچھ تلاشیں کرتے ہیں تاکہ یہ معلوم کیا جاسکے کہ درخت میں کچھ نمونے موجود ہیں یا نہیں۔یہ ایک لاحقہ درخت کا بنیادی نفاذ ہے ، اور زیادہ اعلی درجے کی افادیت جیسے اسٹرنگ کے سوالات کو سنبھالنا ، سب سے طویل عام سٹرنگ تلاش کرنا ، یا میموری کے استعمال کو بہتر بنانا آپ کی ضروریات کے مطابق شامل کیا جاسکتا ہے۔"
    },
    {
        "Question": "تدریجی فروغ دینے میں جلد رکنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ استعمال کرسکتے ہیں۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن سب سے طویل پالندرمکسوبسینس (ایس ٹی آر: سٹرنگ): سٹرنگ {const n = str.length ؛کانسٹ ڈی پی: نمبر [] [] = [] ؛// ٹیبل کو شروع کریں (آئیے i = 0 ؛ i <n ؛ i ++) {dp [i] = نیا سرنی (n). فل (0) ؛ڈی پی [i] [i] = 1 ؛// ایک ہی کردار لمبائی 1} // کے لئے ٹیبل کو نیچے کے انداز میں بھریں (لین = 2 ؛ لین <= n ؛ لین ++) {کے لئے (i = 0 ؛ i <n - لین+)1 ؛ i ++) {const j = i+لین - 1 ؛اگر (str [i] === str [j] && لین === 2) {dp [i] [j] = 2 ؛} ورنہ اگر (str [i] === str [j]) {dp [i] [j] = dp [i + 1] [j - 1] + 2 ؛} else {dp [i] [j] = math.max (dp [i] [j - 1] ، dp [i + 1] [j]) ؛}}} // سب سے طویل palindromic متضاد کی تشکیل نو i = 0 ؛آئیے j = n - 1 ؛چلو متنازعہ = '' ؛جبکہ (i <j) {if (str [i] === str [j]) {متضاد += str [i] ؛i ++ ؛J-- ؛} ورنہ اگر (dp [i] [j-1]> dp [i + 1] [j]) {j-- ؛} else {i ++ ؛}} // اگر تار کی لمبائی عجیب ہے تو ، درمیانی کردار کو شامل کریں اگر (i === j) {متضاد += str [i] ؛} کے بعد کی واپسی ؛} // مثال کے طور پر استعمال: کانسٹٹر = 'کریکٹر' ؛ کانسٹ طویل عرصے سے سب سے طویل عرصے سے ترتیب = طویل ترینپالائنڈروومکسوبسینس (ایس ٹی آر) ؛ کنسول.لوگ ('سب سے طویل پیلائنڈروومک مشترکہ:' ، طویل عرصے سے تعی .ن) ؛ اس مثال میں ، سب سے طویل عرصے سے ، سب سے طویل عرصے تک ، ایک تاریک ترین فنکشن ایک تار کی تار لیتا ہے ،چونکہ ان پٹ اور لوٹاتا ہے۔ٹیبل کو نیچے کی طرف بھر دیا جاتا ہے ، مختلف لمبائیوں کے ذیلی ذخیروں پر غور کرتے ہوئے اور یہ جانچتے ہوئے کہ آیا سروں کے حروف برابر ہیں یا نہیں۔ ٹیبل کو بھرنے کے بعد ، فنکشن ٹیبل کے اوپری دائیں کونے سے بیک ٹریک کرکے سب سے طویل پیلنڈرومک متضاد کی تشکیل نو کرتا ہے۔یہ ایس ٹی آر کے کرداروں کا موازنہ کرتا ہے اور فیصلہ کرتا ہے کہ آیا اس کردار کو بعد میں شامل کرنا ہے یا زیادہ سے زیادہ لمبائی کے ساتھ ملحقہ سیل میں منتقل ہونا ہے۔مثال کے طور پر سٹرنگ (ایس ٹی آر) کے ساتھ کام کریں۔اس کے نتیجے میں سب سے طویل پیلنڈرومک متضاد کنسول پر چھاپتا ہے۔"
    },
    {
        "Question": "اعصابی مشین ترجمے کے ماڈلز میں الفاظ کی توجہ کے تصور کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں رینک اور راہ کے کمپریشن کے ذریعہ یونین کے ساتھ ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.rank = نئی صف (سائز) ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {// راستہ کمپریشن: پائے جانے والے جڑ کو x کا والدین بنائیں۔. والدین [x]) ؛this اس کو واپس کریں۔ والدین [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (روٹ ایکس! == روٹ) {// یونین بذریعہ درجہ: لمبے درخت کو لمبے درخت کی جڑ سے جوڑیں اگر (this.rank [روٹکس] <this.rank [روٹ]) {this.pearnt [روٹ ایکس] =جڑ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}} isconnected (x: نمبر ، Y: نمبر): بولین {اس کو واپس کریں۔}} // مثال کے طور پر استعمال: کونسٹ ڈی ایس = نیا ڈسیوئنٹسیٹ (5) ؛ ڈی ایس یون (0 ، 1) ؛ ڈی ایس یون (2 ، 3) ؛ ڈی ایس یون (1 ، 4) ؛ کنسول.لوگ (ds.isconced(0 ، 4)) ؛// آؤٹ پٹ: trueconsole.log (ds.isconnected (2 ، 4)) ؛// آؤٹ پٹ: اس پر عمل درآمد کو غلط ، ناکارہ طبقے کی کلاس ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں دو صفیں ہیں: ہر عنصر کے والدین کو ذخیرہ کرنے کے لئے والدین اور ہر عنصر کے درخت کی درجہ بندی (تخمینہ گہرائی) کو ذخیرہ کرنے کے لئے۔ یہ کنسٹرکٹر والدین کی صف کو اس طرح شروع کرتا ہے کہ ہر عنصر ابتدائی طور پر اس کا اپنا والدین ہوتا ہے ، اور درجہ بندی ابتدائی طور پر ہوتی ہے۔تمام زیرو۔ تلاش کرنے کا طریقہ اس سیٹ کی جڑ (نمائندہ) تلاش کرتا ہے جس میں دیئے گئے عنصر X کا تعلق ہے۔فائنڈ آپریشن کے دوران ، پائے جانے والے جڑ کو مستقبل کی تلاش کے ل X کا براہ راست والدین بنانے کے لئے پاتھ کمپریشن کا اطلاق کیا جاتا ہے ، جو درختوں کے ڈھانچے کو چپٹا کرنے میں مدد کرتا ہے۔ یونین کا طریقہ کار X اور Y کے ذریعہ نمائندگی کرنے والے دو سیٹوں کا اتحاد انجام دیتا ہے۔اس کو پہلے تلاش کے طریقہ کار کا استعمال کرتے ہوئے سیٹوں کی جڑیں مل جاتی ہیں۔اس کے بعد ، یہ جڑوں کی صفوں کا موازنہ کرتا ہے اور درخت کو چھوٹے درجے کے ساتھ بڑے رینک کے ساتھ جڑ سے جوڑتا ہے۔اگر صفیں برابر ہیں تو ، ایک درخت دوسرے کے ساتھ منسلک ہوتا ہے ، اور نئی جڑ کے عہدے میں اضافہ ہوتا ہے۔ اگر اس سے منسلک طریقہ چیک کرتا ہے کہ اگر دو عناصر X اور y اپنے جڑ عناصر کا موازنہ کرکے ایک ہی سیٹ میں ہیں۔ مثال کے طور پر استعمال کے حصے میں استعمال کے حصے میں۔، ہم پانچ عناصر کے ساتھ ناپسندیدہ سیٹ تشکیل دے کر ناپسندیدہ طبقے کے استعمال کا مظاہرہ کرتے ہیں۔ہم کچھ یونین کی کاروائیاں انجام دیتے ہیں اور اس سے منسلک طریقہ کار کا استعمال کرتے ہوئے عناصر کی رابطے کی جانچ کرتے ہیں۔نتائج کنسول پر چھاپے گئے ہیں۔"
    },
    {
        "Question": "زبان کی ماڈلنگ کے لئے بار بار نیورل نیٹ ورک (RNN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "2D جگہ میں پوائنٹس کے ایک سیٹ میں پوائنٹس کی قریب ترین جوڑی تلاش کرنے کے ل you ، آپ تقسیم اور فتح الگورتھم کو \"قریب ترین جوڑی پوائنٹس\" الگورتھم کے نام سے جانا جاتا ہے۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈ انٹرفیس پوائنٹ {x: نمبر ؛Y: نمبر ؛} فنکشن کا فاصلہ (P1: نقطہ ، P2: نقطہ): نمبر {const Dx = p2.x - p1.x ؛const dy = p2.y - p1.y ؛واپس میتھ۔ ایس کیو آر ٹی (dx * dx + dy * dy) ؛} فنکشن برٹفورس (پوائنٹس: پوائنٹ [] ، شروع: نمبر ، اختتام: نمبر): نمبر {آئیے ذہنیت = لامحدودیت ؛کے لئے (i = start ؛ i <= end ؛ i ++) {for (j = i+1 ؛ j <= end ؛ j ++) {کونسٹ ڈسٹ = ڈسٹنس (پوائنٹس [i] ، پوائنٹس [j]) ؛midestance = math.min (ذہن سازی ، ضلع) ؛}} لوٹنے والی ذہنیت ؛} فنکشن اسٹرپ کلوسیسٹ (پوائنٹس: پوائنٹ [] ، سائز: نمبر ، ذہن: نمبر): نمبر {آئیے منٹ = ذہن سازی ؛کے لئے (i = 0 ؛ i <سائز ؛ ++ i) {for (j = i +1 ؛ j <سائز && پوائنٹس [j] .y - پوائنٹس [i] .y <منٹ ؛ ++ j) {کونسٹ ڈسٹ = فاصلہ (پوائنٹس [i] ، پوائنٹس [j]) ؛MIN = math.min (منٹ ، ضلع) ؛}} ریٹرن منٹ ؛} فنکشن کلوزٹیل (پوائنٹس: پوائنٹ [] ، شروع: نمبر ، اختتام: نمبر): نمبر {کانسٹ سائز = اختتام - شروع + 1 ؛اگر (سائز <= 3) {واپس برٹفورس (پوائنٹس ، اسٹارٹ ، اختتام) ؛} const MID = math.floor ((start + end) / 2) ؛مڈپوائنٹ = پوائنٹس [درمیانی] کو برقرار رکھیں ؛کانسٹ لیفٹ ڈسٹنس = قریبی (پوائنٹس ، اسٹارٹ ، وسط) ؛کونٹ رائٹسٹینس = قریبی (پوائنٹس ، وسط + 1 ، اختتام) ؛midestance = math.min (بائیں بازو ، دائیں طرف) ؛کانسٹرپ: پوائنٹ [] = [] ؛آئیے j = 0 ؛کے لئے (i = start ؛ i <= end ؛ i ++) {if (math.abs (پوائنٹس [i] .x - مڈپوائنٹ. x) <ذہنیت) {پٹی [j] = پوائنٹس [i] ؛J ++ ؛st} کونسٹرپ ڈسٹنس = اسٹرپ کلوسیسٹ (پٹی ، جے ، ذہن سازی) ؛ریٹرن میتھ مین (ذہن سازی ، سٹرپ ڈسٹینس) ؛} فنکشن کلوز اسٹیٹ پیئر (پوائنٹس: پوائنٹ []): نمبر {پوائنٹس.سورٹ ((a ، b) => a.x - b.x) ؛قریب قریب واپس (پوائنٹس ، 0 ، پوائنٹس۔ لمبائی - 1) ؛} // مثال کے استعمال: کانسٹ پوائنٹس: پوائنٹ [] = [{x: 2 ، y: 3} ، {x: 12 ، y: 30} ، {x: 40 ، Y: 50} ، {x: 5 ، Y: 1} ، {x: 12 ، y: 10} ، {x: 3 ، y: 4} ،] ؛ منڈسٹینس = قریب ترین (پوائنٹس) ؛ کنسول۔لاگ ('قریب ترین جوڑی کا فاصلہ:' ، ذہن سازی) ؛ اس عمل میں ، نقطہ انٹرفیس 2D جگہ میں ایک نقطہ کی نمائندگی کرتا ہے ، جس میں X اور Y کوآرڈینیٹ ہوتے ہیں۔ فاصلے کی تقریب فاصلے کے فارمولے کا استعمال کرتے ہوئے دو پوائنٹس کے مابین یکلیڈین فاصلے کا حساب لگاتی ہے۔ایک ہیلپر فنکشن ہے جو بروٹ فورس کے نقطہ نظر کا استعمال کرتے ہوئے بہت کم پوائنٹس کے درمیان قریب ترین جوڑی کے فاصلے کا حساب لگاتا ہے۔ اسٹرپ کلوسیسٹ فنکشن ایک اور مددگار فنکشن ہے جو ایک دیئے گئے چوڑائی کی پٹی میں موجود پوائنٹس کے درمیان قریب ترین جوڑی کے فاصلے کا حساب لگاتا ہے۔فنکشن ہے"
    },
    {
        "Question": "لاجسٹک ریگریشن ماڈل میں L1 اور L2 کو باقاعدہ بنانے میں کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں بی ٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بٹرینوڈ <T> {چابیاں: ٹی [] ؛بچے: btreenode <t> [] ؛اسلیف: بولین ؛کنسٹرکٹر (سلیف: بولین) {this.keys = [] ؛this.children = [] ؛this.isleaf = sileaf ؛}} کلاس btree <t> {جڑ: btreenode <t> ؛ڈگری: نمبر ؛کنسٹرکٹر (ڈگری: نمبر) {this.root = null ؛this.degree = ڈگری ؛} تلاش (کلید: ٹی): بولین {اس کو واپس کریں۔} داخل کریں (کلید: ٹی): باطل {اگر (this.root === null) {this.root = نیا Btreenode <T> (سچ) ؛this.root.keys.push (key) ؛} دوسری {اگر (this.root.keys.length === (2 * this.degree) - 1) {const newrot = new Btreenode <T> (غلط) ؛newrot.children.push (this.root) ؛this.splichild (newrot ، 0 ، this.root) ؛this.root = newrot ؛} this.insertnonfull (this.root ، key) ؛}} پرائیویٹ سرچ نوڈ (نوڈ: Btreenode <T> ، key: t): بولین {آئیے i = 0 ؛جبکہ (i <node.keys.length && & key> node.keys [i]) {i ++ ؛} if (i <node.keys.length && & & key === نوڈ.کیس [i]) {سچ واپس ؛} if (node.isleaf) {جھوٹی لوٹ ؛this اس کو واپس کریں۔} نجی Insertnonfull (نوڈ: btreenode <t> ، key: t): باطل {آئیے i = node.keys.length - 1 ؛if (node.isleaf) {جبکہ (i> = 0 && & & key <node.keys [i]) {node.keys [i + 1] = node.keys [i] ؛میں--؛} node.keys [i + 1] = کلید ؛} دوسری {جبکہ (i> = 0 && & & key <node.keys [i]) {i-- ؛} i ++ ؛if (node.children [i] .keys.length === (2 * this.degree) - 1) {this.splitchild (نوڈ ، i ، نوڈ.چالڈین [i]) ؛if (key> node.keys [i]) {i ++ ؛}} this.insertnonfull (node.children [i] ، کلید) ؛}} نجی اسپلچیلڈ (والدین: Btreenode <T> ، انڈیکس: نمبر ، بچہ: Btreenode <T>): باطل {const newnode = نیا Btreenode <T> (child.isleaf) ؛پیرنٹ.Keys.splice (انڈیکس ، 0 ، child.keys [this.degree - 1]) ؛پیرنٹ.کرینین.سپلیس (انڈیکس + 1 ، 0 ، نیو نوڈ) ؛newnode.keys = child.keys.splice (this.degree ، this.degree - 1) ؛if (! child.isleaf) {newnode.children = child.children.splice (this.degree ، this.degree) ؛}}} // مثال کے طور پر استعمال: کانسٹ btree = new btree <bunds> (3) ؛ btree.insert (5) ؛ btree.insert (10) ؛ btree.insert (3) ؛ btree.insert (1) ؛ btree.داخل کریں (7) ؛ کنسول.لوگ (btree.search (3)) ؛// آؤٹ پٹ: trueconsole.log (btree.search (6)) ؛// آؤٹ پٹ: اس پر عمل درآمد کو فال کریں ، Btreenode کلاس B-Tree میں ایک نوڈ کی نمائندگی کرتا ہے۔اس میں چابیاں کی ایک صف ، چائلڈ نوڈس کی ایک صف ہے ، اور ایک جھنڈا اس بات کی نشاندہی کرتا ہے کہ آیا نوڈ ایک پتی نوڈ ہے۔ بی ٹری کلاس بی ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ اور ایک ڈگری ہے جو ہر نوڈ میں زیادہ سے زیادہ چابیاں کا تعین کرتی ہے۔"
    },
    {
        "Question": "گیم پلے ایجنٹوں میں گہری کمک سیکھنے اور اس کے اطلاق کے تصور کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں گراف کے کم سے کم پھیلنے والے درخت (MST) تلاش کرنے کے لئے کرسکل کے الگورتھم کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس یونین فائنڈ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.rank = نئی صف (سائز) ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {this.palent [x] = this.find (this.palent [x]) ؛this اس کو واپس کریں۔ والدین [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {const rootx = this.find (x) ؛کانسٹ روٹ = this.find (y) ؛اگر (روٹ ایکس! == روٹ) {اگر (this.rank [روٹ ایکس] <this.rank [روٹ]) {this.palent [روٹ ایکس] = روٹ ؛} دوسری صورت میں اگر (this.rank [روٹ ایکس]> یہ۔ رینک [روٹ]) {this.peart [روٹ] = روٹ ایکس ؛} else {this.pearnt [روٹ] = روٹ ایکس ؛this.rank [rootx] ++ ؛}}}} کلاس ایج {ماخذ: نمبر ؛منزل: نمبر ؛وزن: تعداد ؛تعمیر کنندہ (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر) {this.source = ماخذ ؛this.destination = منزل ؛یہ۔ وزن = وزن ؛class} کلاس گراف {کناروں: کنارے [] ؛کنسٹرکٹر () {this.edges = [] ؛} ایڈج (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر): باطل {کانٹ ایج = نیا کنارے (ماخذ ، منزل ، وزن) ؛this.edges.push (کنارے) ؛} کرسکلمسٹ (): ایج [] {this.edges.sort ((a ، b) => a.weight - b.weight) ؛کانسٹ یونین فائنڈ = نیا یونین فائنڈ (this.edges.length) ؛کانسٹ ایم ایس ٹی: ایج [] = [] ؛کے لئے (اس کے لئے۔کونٹ روٹسٹینیشن = یونین فائنڈ.فائنڈ (ایج.ڈیسٹینیشن) ؛اگر (روٹ سورس! == روٹ ڈسٹینیشن) {MST.push (کنارے) ؛یونین فائنڈ ڈاٹ یون (روٹ سورس ، روٹ ڈسٹینیشن) ؛}} واپسی MST ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف () ؛ گراف.اڈیج (0 ، 1 ، 4) ؛ گراف.ڈیج (0 ، 7 ، 8) ؛ گراف.ڈیج (1 ، 2 ، 8) ؛ گراف۔ایڈجڈ (1 ، 7 ، 11) ؛ گراف.ڈیج (2 ، 3 ، 7) ؛ گراف.ڈیج (2 ، 8 ، 2) ؛ گراف.اڈیج (2 ، 5 ، 4) ؛ گراف.اڈیج (3 ، 4 ،9) ؛ گراف.ڈیج (3 ، 5 ، 14) ؛ گراف.ڈیج (4 ، 5 ، 10) ؛ گراف.اڈیج (5 ، 6 ، 2) ؛ گراف.اڈیج (6 ، 7 ، 1) ؛ گراف۔ ایڈجڈج.لاگ (`$ {Edge.Source} - $ {Edge.destination} ، وزن: $ {ایج. ویٹ}`) ؛} اس نفاذ میں ، یونین فائنڈ کلاس رینک کے ذریعہ یونین فٹ کمپریشن اور یونین کے ساتھ یونین فٹ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس کا استعمال الگورتھم کے دوران ناگوار سیٹوں پر نظر رکھنے کے لئے کیا جاتا ہے۔ کنارے کی کلاس گراف میں ایک کنارے کی نمائندگی کرتی ہے ، جس میں ماخذ ورٹیکس ، منزل مقصود اور وزن کو ذخیرہ کیا جاتا ہے۔"
    },
    {
        "Question": "کلسٹرنگ کے لئے خود سے منظم نقشہ (SOM) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ٹریپ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹریپ نوڈ <T> {کلید: نمبر ؛قیمت: ٹی ؛ترجیح: نمبر ؛بائیں: ٹریپ نوڈ <t> |خالی؛دائیں: ٹریپ نوڈ <t> |خالی؛کنسٹرکٹر (کلید: نمبر ، قدر: t) {this.key = key ؛this.value = value ؛this.priority = math.random () ؛this.left = null ؛this.right = null ؛class} کلاس ٹریپ <t> {جڑ: ٹریپ نوڈ <t> |خالی؛کنسٹرکٹر () {this.root = null ؛} پرائیویٹ روٹیٹ لفٹ (نوڈ: ٹریپ نوڈ <t>): ٹریپ نوڈ <t> {کونٹ رائٹچائڈ = نوڈ. رائٹ !؛node.right = rightild.left ؛رائٹچلڈ ڈاٹ لیفٹ = نوڈ ؛رائٹائڈ واپس ؛} نجی روٹیرائٹ (نوڈ: ٹریپ نوڈ <T>): ٹریپ نوڈ <T> {کانسٹیٹ لیفٹائڈ = نوڈ۔ لیفٹ !؛node.left = lifthild.right ؛بائیں بچے۔ رائٹ = نوڈ ؛بائیں بازو کی واپسی ؛} نجی داخلہ (نوڈ: ٹریپ نوڈ <T> | NULL ، KEY: نمبر ، قدر: T): ٹریپ نوڈ <T> {اگر (نوڈ === NULL) {نیا ٹریپ نوڈ <T> (کلیدی ، قدر) واپس لوٹائیں ؛} if (key <node.key) {node.left = this.insertnode (node.left ، key ، value) ؛اگر (نوڈ.لفٹ!}} دوسری صورت میں اگر (key> نوڈ.کی) {نوڈ۔ رائٹ = this.insertnode (نوڈ. رائٹ ، کلید ، قدر) ؛if (node.right! .priority <node.priority) {نوڈ = this.rotateleft (نوڈ) ؛}} واپسی نوڈ ؛} داخل کریں (کلید: نمبر ، قدر: ٹی): باطل {this.root = this.insertnode (this.root ، کلید ، قدر) ؛} نجی ڈیلیٹینوڈ (نوڈ: ٹریپ نوڈ <t> | null ، key: نمبر): ٹریپ نوڈ <T> |null {if (نوڈ === null) {واپسی NULL ؛} if (key <node.key) {node.left = this.deletenode (node.left ، key) ؛} دوسری صورت میں اگر (key> نوڈ.کی) {نوڈ. رائٹ = this.deletenode (node.right ، key) ؛} else {if (node.left === null && node.right === null) {واپس واپس ؛} ورنہ اگر (node.left === null) {نوڈ = this.rotateleft (نوڈ) ؛} ورنہ اگر (نوڈ.رائٹ === null) {نوڈ = this.rotateright (نوڈ) ؛} else {if (node.left.priority <node.right.priority) {نوڈ = this.rotateright (نوڈ) ؛} دوسری {نوڈ = this.rotateleft (نوڈ) ؛}} نوڈ = this.deletenode (نوڈ ، کلید) ؛} واپسی نوڈ ؛} حذف کریں (کلید: نمبر): باطل {this.root = this.deletenode (this.root ، key) ؛} نجی سرچ نوڈ (نوڈ: ٹریپ نوڈ <t> | null ، key: نمبر): t |null {if (نوڈ === null) {واپسی NULL ؛} if (key === node.key) {واپسی نوڈ.ولیو ؛} دوسری صورت میں اگر (کلید <نوڈ.کی) {اس کی تلاش کریں۔} else {اس کو واپس کریں۔ سرچنوڈ (نوڈ. رائٹ ، کلید) ؛}} تلاش (کلید: نمبر): ٹی |null {اس کو واپس کریں۔ سرچنوڈ (this.root ، key) ؛}} // مثال کے طور پر استعمال: const ٹریپ = نیا ٹریپ <سٹرنگ> () ؛ ٹریپ.نسرٹ (5 ، \"ایپل\") ؛ ٹری"
    },
    {
        "Question": "ملٹی کلاس درجہ بندی میں صحت سے متعلق اور یاد کے درمیان کیا فرق ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تاروں کی ایک صف کے درمیان سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے ایک مثال کا پروگرام یہ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل ترین کامومن پریفکس (ایس ٹی آر ایس: سٹرنگ []): سٹرنگ {اگر (str.length === 0) {واپسی '' ؛pref لیٹ پریفکس = strs [0] ؛کے لئے (i = 1 ؛ i <str.length ؛ i ++) {جبکہ (strs [i]. indexof (سابقہ)! == 0) {پریفکس = پریفکس.سوبسٹرنگ (0 ، سابقہ۔ لمبائی - 1) ؛اگر (سابقہ === '') {واپس '' ؛}}} واپسی کا سابقہ ؛} // مثال کے استعمال: کانسٹور اسٹرنگز = ['پھول' ، 'فلو' ، 'فلائٹ'] const const مشترکہ پریفکس = طویل ترین کامومن پریفکس (ڈور) ؛ کنسول.لوگ ('سب سے طویل عام پریفکس:' ، کامن پرفکس)؛// آؤٹ پٹ: \"FL\" اس پروگرام میں ، طویل عرصے سے کام کرنے والا فنکشن ان پٹ کے طور پر تار کی ایک صف لیتا ہے اور ان میں سب سے طویل عام سابقہ واپس کرتا ہے۔ فنکشن سرنی میں پہلی تار کے ساتھ سابقہ متغیر کو شروع کرتا ہے۔اس کے بعد ، یہ باقی ڈوروں کے ذریعے تکرار کرتا ہے اور چیک کرتا ہے کہ اگر انڈیکسف طریقہ استعمال کرتے ہوئے ہر تار کا سابقہ ایک سابقہ ہے۔اگر پریفکس کسی تار کا سابقہ نہیں ہے تو ، یہ سابقہ کے آخری کردار کو ہٹاتا ہے اور اس عمل کو جاری رکھے گا جب تک کہ ایک مشترکہ سابقہ مل جاتا ہے یا سابقہ خالی نہیں ہوجاتا ہے۔اگر کوئی مشترکہ سابقہ موجود نہیں ہے تو خالی تار۔"
    },
    {
        "Question": "قدرتی زبان پروسیسنگ کے کاموں میں ورڈ 2 وی ای سی ایمبیڈنگز اور ان کے استعمال کے تصور کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس روپینوڈ {بائیں: روپینوڈ |تار ؛دائیں: روپینوڈ |تار ؛وزن: تعداد ؛کنسٹرکٹر (بائیں: روپینوڈ | سٹرنگ ، دائیں: روپینوڈ | سٹرنگ) {this.left = بائیں ؛this.right = دائیں ؛this.weight = this.calculateweitt () ؛} نجی حساب کتاب (): نمبر {if (type of this.left === 'سٹرنگ') {اس کو واپس کریں۔} دوسری {اس کو واپس کریں۔}}} کلاس رسی {جڑ: روپینوڈ |تار ؛کنسٹرکٹر (جڑ: روپینوڈ | سٹرنگ) {this.root = جڑ ؛} پرائیویٹ کونکٹنوڈس (نوڈ 1: روپینوڈ | سٹرنگ ، نوڈ 2: روپینوڈ | سٹرنگ): روپینوڈ {نیا روپینوڈ واپس کریں (نوڈ 1 ، نوڈ 2) ؛} نجی اسپلٹ نوڈ (نوڈ: روپینوڈ ، انڈیکس: نمبر): [روپنوڈ |سٹرنگ ، روپینوڈ |سٹرنگ] {if (index === 0) {واپسی [node.left ، node.right] ؛} دوسری صورت میں اگر (اشاریہ === نوڈ۔ ویٹ) {واپسی [نوڈ ، ''] ؛} ورنہ اگر (ٹائپوف نوڈ۔ لیفٹ === 'سٹرنگ') {کونسٹ لیفٹسبسٹرنگ = نوڈ.لفٹ.سوبسٹرنگ (0 ، انڈیکس) ؛کنسٹ رائٹسبسٹرنگ = نوڈ۔ لیفٹ.سوبسٹرنگ (انڈیکس) ؛واپسی [لیفٹسبسٹرنگ ، رائٹسبسٹرنگ + نوڈ۔ رائٹ] ؛} ورنہ اگر (index <node.left.weight) {const [leftsplit ، حقوق پلٹ] = this.splitnode (node.left as ropenode ، انڈیکس) ؛واپسی [leftsplit ، this.concatnodes (حقوق کی جگہ ، نوڈ. رائٹ)] ؛} else {const [leftsplit ، حقوق پلٹ] = this.splitnode (نوڈ۔ ropenode ، انڈیکس - node.left.weight) ؛واپس [this.concatnodes (node.left ، leftsplit) ، حقوق کی جگہ] ؛}} داخل کریں (اشاریہ: نمبر ، متن: سٹرنگ): باطل {کانسٹ [بائیں ، دائیں] = this.splitnode (یہ.روٹ بطور روپینوڈ ، انڈیکس) ؛const newnode = this.concatnodes (بائیں ، this.concatnodes (متن ، دائیں)) ؛this.root = newnode ؛} حذف کریں (اشاریہ: نمبر ، لمبائی: نمبر): باطل {Const [بائیں 1 ، دائیں 1] = this.splitnode (یہ.روٹ بطور روپینوڈ ، انڈیکس) ؛کانسٹ [بائیں 2 ، دائیں 2] = this.splitnode (دائیں 1 جیسے روپینوڈ ، لمبائی) ؛this.root = this.concatnodes (بائیں 1 ، دائیں 2) ؛} ٹاسٹرنگ (): سٹرنگ {کانسٹنگ نتیجہ: سٹرنگ [] = [] ؛Const traverse = (نوڈ: روپینوڈ | سٹرنگ) => {if (typeof نوڈ === 'سٹرنگ') {نتیجہ. پش (نوڈ) ؛} else {traverse (node.left) ؛traverse (node.right) ؛}} ؛traverse (this.root) ؛واپسی کا نتیجہ۔ join ('') ؛}} // مثال کے طور پر استعمال: کونسٹ رسی = نئی رسی (نیا روپینوڈ ('ہیلو ،' ، 'ورلڈ!')) ؛ rope.insert (7 ، 'خوبصورت') ؛ rope.delete (0 ، 7) ؛ کنسول۔لاگ (rope.tostring ()) ؛// آؤٹ پٹ: \"خوبصورت دنیا!\" اس نفاذ میں ، روپینوڈ کلاس رسی میں ایک نوڈ کی نمائندگی کرتی ہے ، جس میں یا تو تار (پتی نوڈ) ہوسکتا ہے یا دو بچوں کے نوڈس (اندرونی نوڈ) کا حوالہ ہوسکتا ہے۔ہر نوڈ میں ایک وزن کی پراپرٹی بھی ہوتی ہے جو اس نوڈ میں ذخیرہ شدہ اسٹرنگ کی لمبائی کی نمائندگی کرتی ہے۔ رسی کی کلاس رسی کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے اور مخصوص اشاریوں پر متن کو داخل کرنے اور حذف کرنے کے طریقے مہیا کرتی ہے ، اور ساتھ ہی رسی کو تار کی نمائندگی میں تبدیل کرتی ہے۔داخل کرنے کا طریقہ مخصوص انڈیکس پر رسی کو الگ کرتا ہے ، نئے متن کو علیحدہ نوڈ کے طور پر داخل کرتا ہے ، اور پھر نوڈس کو ایک ساتھ مل جاتا ہے۔"
    },
    {
        "Question": "مشین ترجمے کے لئے ٹرانسفارمر ماڈل کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں بیل مین فورڈ الگورتھم کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ایج {ماخذ: نمبر ؛منزل: نمبر ؛وزن: تعداد ؛تعمیر کنندہ (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر) {this.source = ماخذ ؛this.destination = منزل ؛یہ۔ وزن = وزن ؛class} کلاس گراف {عمودی: نمبر ؛کناروں: کنارے [] ؛کنسٹرکٹر (عمودی: نمبر) {this.vertices = عمودی ؛this.edges = [] ؛} ایڈج (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر): باطل {کانٹ ایج = نیا کنارے (ماخذ ، منزل ، وزن) ؛this.edges.push (کنارے) ؛man بیل مین فورڈ (اسٹارٹورٹیکس: نمبر): نمبر [] {کنسٹ ڈسٹنس: نمبر [] = نیا سرنی (یہ ۔ورٹائٹس)فاصلہ [اسٹارٹورٹیکس] = 0 ؛کے لئے (آئیے i = 0 ؛ i <this.vertices - 1 ؛ i ++) {کے لئے (اس کے لئے۔اگر (فاصلہ [ماخذ]! == نمبر.میکس_ویلیو && فاصلہ [ماخذ] + وزن <فاصلہ [منزل]) {فاصلہ [منزل] = فاصلہ [ماخذ] + وزن ؛}}} for (this.edges کے کونسٹ ایج) {const {ماخذ ، منزل ، وزن} = کنارے ؛اگر (فاصلہ [ماخذ]! == نمبر.میکس_ویلیو && فاصلہ [ماخذ] + وزن <فاصلہ [منزل]) {نئی غلطی پھینک دیں ('گراف میں منفی وزن کا چکر ہوتا ہے') ؛}} واپسی کا فاصلہ ؛}} // مثال کے طور پر استعمال: کانسٹ گراف = نیا گراف (5) ؛ گراف.ڈیج (0 ، 1 ، 4) ؛ گراف.ڈیج (0 ، 2 ، 3) ؛ گراف.اڈیج (1 ، 2 ، -2) ؛گراف.اڈیج (1 ، 3 ، 4) ؛ گراف.ڈیج (1 ، 4 ، 2) ؛ گراف.ڈیج (3 ، 2 ، 1) ؛ گراف.اڈیج (3 ، 1 ، 5) ؛ گراف.اڈیج (4 ،3 ، -3) ؛ کانسٹ اسٹارٹورٹیکس = 0 ؛ کانسٹلسٹ ڈسٹنس = گراف.بیل مین فورڈ (اسٹارٹورٹیکس) ؛ کنسول.لوگ ('ورٹیکس سے مختصر فاصلہ' ، اسٹارٹورٹیکس) ؛ کے لئے (i = 0 ؛ i <شارسٹ ڈسٹینس.لنتھ ؛ i ++){کنسول.لاگ ('ورٹیکس' ، i ، ':' ، مختصر ترین [i]) ؛} اس عمل میں ، ایج کلاس گراف میں ایک کنارے کی نمائندگی کرتا ہے ، جس میں ایک ماخذ ورٹیکس ، منزل مقصود ، اور وزن ہوتا ہے۔ گراف کلاسایک ہدایت نامہ گراف کی نمائندگی کرتا ہے اور کسی دیئے گئے اسٹارٹ ایکسٹریکس سے مختصر ترین فاصلوں کو تلاش کرنے کے لئے کناروں کو شامل کرنے اور بیل مین فورڈ الگورتھم کو انجام دینے کے طریقے مہیا کرتا ہے۔ بیل مین فورڈ کا طریقہ اسٹارٹ ورٹیکس سے مختصر فاصلے کو ذخیرہ کرنے کے لئے ایک صف کا فاصلہ شروع کرتا ہے۔اس کے بعد اس کی تکرار ہوتی ہے۔اس کے بعد ، یہ گراف میں منفی وزن کے چکروں کی جانچ پڑتال کرتا ہے۔اگر منفی وزن کا چکر مل جاتا ہے تو ، ایک غلطی پھینک دی جاتی ہے۔ فائنل طور پر ، پروگرام گراف کلاس کے استعمال کو گراف بنا کر ، کناروں کو شامل کرکے ، اور بیل مین فورڈ الگورتھم چلانے سے ظاہر کرتا ہے تاکہ ایک مخصوص اسٹارٹ ورٹیکس سے مختصر ترین فاصلوں کو تلاش کیا جاسکے۔اس کے بعد قلیل ترین فاصلوں کو کنسول پر چھپایا جاتا ہے۔"
    },
    {
        "Question": "مجاز عصبی نیٹ ورکس میں ڈراپ آؤٹ ریگولائزیشن کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں وقفہ کے درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس وقفہ {کم: نمبر ؛اعلی: نمبر ؛کنسٹرکٹر (کم: نمبر ، اعلی: نمبر) {this.low = کم ؛this.high = اعلی ؛class} کلاس انٹرولٹرینوڈ {وقفہ: وقفہ ؛زیادہ سے زیادہ: نمبر ؛بائیں: انٹرالٹرینوڈ |خالی؛دائیں: انٹرالٹرینوڈ |خالی؛کنسٹرکٹر (وقفہ: وقفہ) {this.interval = وقفہ ؛this.max = وقفہ۔ ہائی ؛this.left = null ؛this.right = null ؛class} کلاس انٹرولٹری {جڑ: انٹرویلٹرینوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} پرائیویٹ گیٹ میکس (A: نمبر ، B: نمبر ، C: نمبر): نمبر {ریٹرن میتھ۔ میکس (A ، Math.max (B ، C)) ؛} نجی Insertnode (نوڈ: انٹرویلٹرینوڈ | NULL ، وقفہ: وقفہ): انٹرویلٹرینوڈ {اگر (نوڈ ==== null) {نیا انٹرویلٹرینوڈ (وقفہ) واپس کریں ؛} const {کم} = وقفہ ؛اگر (کم <node.interval.low) {node.left = this.insertnode (node.left ، وقفہ) ؛} else {node.right = this.insertnode (node.right ، وقفہ) ؛} node.max = this.getMax (node.max ، وقفہ. ہائی ، نوڈ. interval.high) ؛واپسی نوڈ ؛} داخل کریں (وقفہ: وقفہ): باطل {this.root = this.insertnode (this.root ، وقفہ) ؛} نجی ڈوورلاپ (وقفہ 1: وقفہ ، وقفہ 2: وقفہ): بولین {ریٹرن انٹرویویل 1.low <= intraval2.high && interval2.low <= introal1.high ؛} نجی سرچ اوورلیپنگ انٹرولز (نوڈ: انٹرویلٹرینوڈ | NULL ، وقفہ: وقفہ ، نتیجہ: وقفہ []): باطل {اگر (نوڈ === null) {واپسی ؛} if (this.dooverlap (node.interval ، وقفہ)) {نتیجہ. پش (node.interval) ؛} اگر (نوڈ.لفٹ!} if (node.right! == null && node.right.Interval.low <= interval.high) {this.searchoverlapping intervals (نوڈ.رائٹ ، وقفہ ، نتیجہ) ؛}} تلاش (وقفہ: وقفہ): وقفہ [] {کانسٹنگ نتیجہ: وقفہ [] = [] ؛this.searchoverlapping intervals (this.root ، وقفہ ، نتیجہ) ؛واپسی کا نتیجہ ؛}} // مثال کے طور پر استعمال: کانسٹ انٹروولٹری = نیا انٹروولٹری () ؛ انٹروولٹری.سرٹ (نیا وقفہ (15 ، 20)) inter انٹروولٹری.سرٹ (نیا وقفہ (10 ، 30)) inter انٹروولٹری.نسٹ (نیا وقفہ (5 ،20)) inter انٹروولٹری۔ INSERT (نیا وقفہ (12 ، 15)) inter انٹروولٹری.سرٹ (نیا وقفہ (17 ، 19)) inter انٹروولٹری.سرٹ (نیا وقفہ (30 ، 40)) const کانس سرچینٹرول = نیا وقفہ (14، ، 16) const vorelapping intervals = intervaltree.search (سرچینٹیورول) ؛ کنسول.لوگ ('اوور لیپنگ وقفے کے ساتھ اوورلیپنگ وقفے' ، سرچ انٹروول ، ':') ؛ اوورلیپنگ انٹروئولز۔ فارورچ ((وقفہ) => {کنسول۔.low ، '،' ، وقفہ. HIGH ، ']') ؛}) ؛ اس عمل میں ، وقفہ طبقہ ایک وقفہ کی نمائندگی کرتا ہے جس میں کم اور اعلی قیمت ہوتی ہے۔وقفے کے درخت میں ایک نوڈ کی نمائندگی کرتا ہے ، جس میں وقفہ ہوتا ہے ، اس کے وقفہ اور اولاد میں زیادہ سے زیادہ قیمت ہوتی ہے ، اور بائیں اور دائیں بچے کے نوڈس کا حوالہ ہوتا ہے۔ انٹرلٹری کلاس وقفہ درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہے اور وقفوں کو داخل کرنے کے طریقے مہیا کرتا ہے اور۔اوورلیپنگ وقفوں کی تلاش کریں۔ داخل کرنے کا طریقہ موجودہ نوڈ کے وقفہ کم قیمت کے ساتھ اس کی کم قیمت کا موازنہ کرکے وقفہ کے درخت میں وقفہ داخل کرتا ہے۔یہ نوڈ کی زیادہ سے زیادہ اعلی قیمت کو اپ ڈیٹ کرتا ہے اور"
    },
    {
        "Question": "خود ساختہ سیکھنے کے تصور کی وضاحت کریں اور کسی درخواست کی مثال دیں۔",
        "Answer": "خود ساختہ سیکھنا ایک مشین لرننگ تکنیک ہے جس میں ایک ماڈل واضح انسانی تشریحات یا لیبلوں پر بھروسہ کیے بغیر بغیر لیبل والے ڈیٹا سے سیکھتا ہے۔اس کے بجائے ، ماڈل اپنے سپروائزری سگنل بنانے کے لئے ڈیٹا میں موجود موروثی ڈھانچے یا معلومات کا فائدہ اٹھاتا ہے۔یہ سگنلز ماڈل کو اعداد و شمار سے معنی خیز خصوصیات یا نمائندگی نکالنے کے لئے تربیت دینے کے لئے استعمال ہوتے ہیں۔"
    },
    {
        "Question": "دستاویز کلسٹرنگ کے لئے درجہ بندی کے کلسٹرنگ ماڈل کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "دستاویز کلسٹرنگ کے لئے ایک درجہ بندی کے کلسٹرنگ ماڈل کی تربیت میں عام طور پر مندرجہ ذیل اہم اقدامات شامل ہوتے ہیں: ڈیٹا کی تیاری: دستاویزات کا ایک مجموعہ جمع کریں جسے آپ کلسٹر کرنا چاہتے ہیں۔کسی بھی غیر متعلقہ معلومات ، جیسے HTML ٹیگز یا اوقاف کو ہٹا کر دستاویزات کو پہلے سے تیار کریں۔متن کو معمول پر لانے کی تکنیک انجام دیں جیسے ٹوکنائزیشن ، اسٹیمنگ ، اور اسٹاپ الفاظ کو کلسٹرنگ کے ل a ایک مناسب شکل میں تبدیل کرنے کے لئے اسٹاپ الفاظ کو ہٹانا۔عام نقطہ نظر میں بیگ آف ورڈز ماڈل ، اصطلاحی تعدد-انڈرس دستاویز فریکوینسی (TF-IDF) وزن ، یا ورڈ 2 وی ای سی یا دستانے جیسے لفظ ایمبیڈنگ شامل ہیں۔یہ تکنیک دستاویزات کو فیچر ویکٹر یا ایمبیڈنگ میں تبدیل کرتی ہیں۔ ڈسٹنس یا مماثلت کا حساب کتاب: کمپیوٹ"
    },
    {
        "Question": "رجعت پسندی کے کاموں میں مطلب اسکوائرڈ غلطی (ایم ایس ای) اور مطلب مطلق غلطی (MAE) کے درمیان کیا فرق ہے؟",
        "Answer": "میین اسکوائرڈ غلطی (ایم ایس ای) اور مطلب مطلق غلطی (ایم اے ای) دونوں رجعت پسندی کے کاموں میں بڑے پیمانے پر استعمال ہونے والے نقصان کے افعال ہیں ، لیکن وہ اس میں مختلف ہیں کہ وہ پیش گوئی اور حقیقت کے مابین غلطیوں کی پیمائش کرتے ہیں۔"
    },
    {
        "Question": "ٹرانسفارمر ماڈلز میں توجہ کے طریقہ کار کے تصور اور زبان کو سمجھنے کے کاموں میں ان کے استعمال کی وضاحت کریں۔",
        "Answer": "توجہ کے طریقہ کار ایک ہیں"
    },
    {
        "Question": "کمک سیکھنے کے لئے گہری Q-نیٹ ورک (DQN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "گہری Q-Network (DQN) کی تربیت میں کمک سیکھنے میں کئی کلیدی اقدامات شامل ہیں۔اس میں شامل اہم اقدامات یہ ہیں: ماحولیات کا سیٹ اپ: مسئلے کی شناخت اور اس کی وضاحت کمک سیکھنے کے کام کے طور پر کریں۔ماحول یا سمیلیٹر مرتب کریں جس کے ساتھ ایجنٹ بات چیت کرے گا۔یہ ماحول ایجنٹ کو مشاہدات فراہم کرتا ہے اور اسے اپنی پالیسی کی بنیاد پر اقدامات کرنے کی اجازت دیتا ہے۔ہر تجربے میں ایجنٹ کی حالت ، کارروائی کی گئی ، نتیجے میں انعام ، اور اگلی ریاست شامل ہوتی ہے۔یہ ری پلے میموری سیکھنے کے عمل کے دوران تصادفی طور پر نمونے لینے اور تجربات کو دوبارہ استعمال کرکے زیادہ موثر تربیت کی اجازت دیتی ہے۔ نیورل نیٹ ورک فن تعمیر: نیورل نیٹ ورک فن تعمیر کو ڈیزائن کریں ، عام طور پر ایک گہری عصبی"
    },
    {
        "Question": "مجاز اعصابی نیٹ ورکس میں بیچ کو معمول پر لانے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "بیچ نارملائزیشن ایک ایسی تکنیک ہے جو تربیت کے دوران ہر منی بیچ کے اندر انٹرمیڈیٹ سرگرمیوں کو معمول پر لانے کے لئے مجاز اعصابی نیٹ ورکس (سی این این) میں استعمال ہوتی ہے۔اس کا مقصد نیٹ ورک کے سیکھنے کے عمل کی استحکام اور کارکردگی کو بہتر بنانا ہے۔ بیچ کو معمول پر لانے کے بنیادی فوائد یہ ہیں: داخلی کوویرٹ شفٹ سے نمٹنا: اندرونی کوویرٹ شفٹ سے مراد اس رجحان سے ہوتا ہے جہاں نیٹ ورک کے آدانوں کی تقسیم میں تبدیلی آتی ہے کیونکہ اس سے پہلے کی تہوں کے پیرامیٹرز ہوتے ہیں۔تربیت کے دوران تازہ کاری۔اس سے آہستہ آہستہ استحکام اور محتاط وزن کے آغاز کی ضرورت کا باعث بن سکتا ہے۔بیچ کو معمول پر لانے سے اندرونی COV کے اثرات کم ہوجاتے ہیں"
    },
    {
        "Question": "جنریٹو ایڈورسیریل نیٹ ورکس (GANs) کے تصور اور تصویری ترکیب میں ان کے استعمال کی وضاحت کریں۔",
        "Answer": "جنریٹو ایڈورسیریل نیٹ ورک (GANs) مشین لرننگ ماڈلز کی ایک کلاس ہے جو نئے نمونے تیار کرنے کے لئے استعمال ہوتی ہے جو دیئے گئے ڈیٹاسیٹ سے ملتی جلتی ہے۔GANs دو اہم اجزاء پر مشتمل ہے: ایک جنریٹر نیٹ ورک اور ایک امتیازی سلوک نیٹ ورک۔ان کو ایک مخالف انداز میں تربیت دی جاتی ہے ، جہاں جنریٹر امتیازی سلوک کو بے وقوف بنانے کے لئے حقیقت پسندانہ نمونے تیار کرنے کی کوشش کرتا ہے ، جبکہ امتیازی سلوک کرنے والے کا مقصد حقیقی اور پیدا ہونے والے نمونوں میں فرق کرنا ہے۔ امیج ترکیب کے تناظر میں GANs کس طرح کام کرتے ہیں اس کا ایک جائزہ: جنریٹر نیٹ ورک: جنریٹر نیٹ ورک:جنریٹر بے ترتیب شور یا ایک اویکت ویکٹر کو ان پٹ کے طور پر لیتا ہے اور اسے ہدف کے اعداد و شمار (جیسے ، تصاویر) کی جگہ پر نقشہ دیتا ہے۔یہ عام طور پر متعدد پرتوں پر مشتمل ہوتا ہے ، بشمول مکمل طور پر منسلک یا مجازی پرتوں ، اس کے بعد ایکٹیویشن افعال ہوتے ہیں۔جنریٹر کا ہدف حقیقت پسندانہ نمونے تیار کرنا ہے جو حقیقی اعداد و شمار کی تقسیم سے ملتے جلتے ہیں۔"
    },
    {
        "Question": "فنکشن کے قریب ہونے کے لئے ریڈیل بیس فنکشن (آر بی ایف) نیٹ ورک کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "فنکشن کے قریب ہونے کے لئے ریڈیل بیس فنکشن (آر بی ایف) نیٹ ورک کی تربیت میں کئی کلیدی اقدامات شامل ہیں۔اس میں شامل اہم اقدامات یہ ہیں: ڈیٹا کی تیاری: ٹریننگ ڈیٹاسیٹ تیار کریں ، جس میں ان پٹ آؤٹ پٹ جوڑے ہوتے ہیں جو ہدف کی تقریب کی نمائندگی کرتے ہیں۔اس بات کو یقینی بنائیں کہ ڈیٹاسیٹ وسیع پیمانے پر آدانوں کا احاطہ کرتا ہے اور مطلوبہ فنکشن کی درست نمائندگی کرتا ہے۔"
    },
    {
        "Question": "قدرتی زبان پروسیسنگ کے کاموں میں لفظ ایمبیڈنگ کے تصور اور ان کے استعمال کی وضاحت کریں۔",
        "Answer": "لفظ ایمبیڈنگ ایک اعلی جہتی جگہ میں الفاظ کی گھنے ویکٹر نمائندگی ہیں ، جہاں ہر جہت لفظ کے معنی کے ایک خاص پہلو کو اپنی گرفت میں لیتی ہے۔وہ قدرتی زبان پروسیسنگ (این ایل پی) کے کاموں میں بڑے پیمانے پر استعمال ہوتے ہیں تاکہ الفاظ کے مابین معنوی تعلقات کو اپنی گرفت میں لائیں اور کمپیوٹر کو انسانی زبان کو زیادہ موثر طریقے سے سمجھنے اور اس پر کارروائی کرنے کے قابل بنائے۔ یہاں لفظ ایمبیڈنگ کے تصور اور این ایل پی کاموں میں ان کے استعمال کا ایک جائزہ: لفظ کے معنی کی نمائندگی: لفظ ایمبیڈنگ کا مقصد ایک مسلسل ویکٹر کی جگہ میں الفاظ کی نمائندگی کرنا ہے ، جہاں اسی طرح کے الفاظ ایک دوسرے کے قریب ہوتے ہیں اور اسی طرح کے سیاق و سباق کے معنی بانٹتے ہیں۔روایتی ویرل نمائندگیوں کے برعکس جیسے ایک گرم انکوڈنگ ، لفظ ایمبیڈنگس نے معنوی تعلقات کو حاصل کیا اور لفظ کی مماثلت اور متعلقہ کے بارے میں معلومات حاصل کی۔ تقسیم ہائپو"
    },
    {
        "Question": "مشین ٹرانسلیشن کے لئے ترتیب سے ترتیب ماڈل کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "مشین ترجمہ کے لئے ترتیب سے ترتیب (SEQ2SEQ) ماڈل کی تربیت میں کئی اہم اقدامات شامل ہیں۔یہاں عام عمل کا ایک جائزہ ہے: اعداد و شمار کی تیاری: ایک متوازی کارپس جمع کریں جس میں ماخذ زبان کے جملوں اور ان کے متعلقہ ترجمے کو ہدف زبان میں جمع کیا جائے۔ جملے کو ٹوکنائزنگ ، ہینڈلنگ ، اوقاف ، کم کیاسنگ ، اور کسی بھی ضروری معمول یا صفائی ستھرائی کے اقدامات کا استعمال کرکے اعداد و شمار کو پیش کریں۔انکوڈر ڈیکوڈر فن تعمیر: SEQ2SEQ ماڈل کے فن تعمیر کو ڈیزائن کریں ، جو ایک انکوڈر اور ڈیکوڈر پر مشتمل ہوتا ہے۔ انکوڈر ماخذ کی زبان کا جملہ ان پٹ کے طور پر لیتا ہے اور اس پر عملدرآمد کرتا ہے تاکہ \"سیاق و سباق ویکٹر\" کہا جاتا ہے۔ڈیکوڈر سیاق و سباق کو ویکٹر لیتا ہے اور ترجمہ شدہ آؤٹ پٹ جملے کا لفظ ورڈ .3 کے ذریعہ تیار کرتا ہے"
    },
    {
        "Question": "بے ترتیب جنگل کے جوڑنے والی تربیت میں جلد رکنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ابتدائی طور پر رکنا ایک ایسی تکنیک ہے جو بے ترتیب جنگلات کے جوڑوں کی تربیت میں استعمال ہوتی ہے تاکہ زیادہ سے زیادہ فٹنگ کو روکا جاسکے اور عمومی کارکردگی کو بہتر بنایا جاسکے۔جلد رکنے کا مقصد ایک تلاش کرنا ہے"
    },
    {
        "Question": "اعصابی سوال کے جواب دینے والے ماڈلز میں الفاظ کی توجہ کے تصور کی وضاحت کریں۔",
        "Answer": "اعصابی سوال کے جواب دینے والے ماڈلز میں ، الفاظ کی توجہ ایک ایسا طریقہ کار ہے جو کسی مخصوص سوال کے جواب سے متعلق ان پٹ سیاق و سباق میں مخصوص الفاظ یا ٹوکن پر مرکوز ہے۔اس سے ماڈل کو ان الفاظ کی شناخت اور زیادہ اہمیت دینے میں مدد ملتی ہے جو جواب پیدا کرنے کے لئے انتہائی اہم ہیں۔ اعصابی سوال کے جواب دینے والے ماڈلز میں الفاظ کی توجہ کس طرح کام کرتی ہے: ماڈل فن تعمیر: اعصابی سوال کے جواب دینے والے ماڈل عام طور پر ایک انکوڈر ڈیکوڈر فن تعمیر پر مشتمل ہوتے ہیں ، جیسےمقبول تسلسل سے ترتیب (SEQ2SEQ) ماڈل یا اس کے مختلف ، ٹرانسفارمر ماڈل۔ انکوڈر ان پٹ سیاق و سباق پر کارروائی کرتا ہے (جیسے ، ایک پیراگراف یا ایک دستاویز) اور اسے پوشیدہ ریاستوں یا سرایت کے سلسلے میں تبدیل کرتا ہے۔ ڈیکوڈر پیدا کرتا ہےانکوڈ شدہ سیاق و سباق کی نمائندگی میں شرکت کرکے جواب۔ بات چیت کا طریقہ کار: توجہ کا طریقہ کار اجازت دیتا ہے"
    },
    {
        "Question": "متن کی نسل کے لئے جنریٹو ایڈورسیریل نیٹ ورک (GAN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "ٹیکسٹ جنریشن کے لئے جنریٹو ایڈورسیریل نیٹ ورک (GAN) کی تربیت میں بہت سے اقدامات شامل ہیں۔اگرچہ GANs عام طور پر تصویری ترکیب جیسے کاموں کے لئے استعمال ہوتے ہیں ، لیکن متن کی متضاد نوعیت کی وجہ سے GANs کے ساتھ ٹیکسٹ جنریشن زیادہ مشکل ہے۔تاہم ، مشروط GANs یا ٹیکسٹ GANS جیسے مختلف قسمیں متن کی نسل کے لئے استعمال کی جاسکتی ہیں۔ٹیکسٹ جنریشن کے لئے ایک GAN کی تربیت میں شامل اہم اقدامات یہ ہیں: ڈیٹا کی تیاری: متن کی مثالوں کا ڈیٹاسیٹ جمع کریں ، جو جملے ، پیراگراف یا دستاویزات ہوسکتے ہیں۔ ٹیکنائزنگ ، اسٹاپ ورڈز کو ہٹانا ، خصوصی کرداروں کو سنبھالنے ، اور انجام دینے کے ذریعہ ٹیکسٹ ڈیٹا کو پیش کریں۔صفائی کے دیگر ضروری اقدامات۔ متن کے اعداد و شمار کو عددی نمائندگی میں شامل کریں ، جیسے لفظ ایمبیڈنگ یا ایک گرم انکوڈنگ۔"
    },
    {
        "Question": "سپورٹ ویکٹر مشینوں (ایس وی ایم) میں L1 اور L2 کو باقاعدہ بنانے میں کیا فرق ہے؟",
        "Answer": "سپورٹ ویکٹر مشینوں (ایس وی ایم) میں ، ایل 1 اور ایل 2 ریگولرائزیشن مختلف جرمانے کی شرائط کا حوالہ دیتے ہیں جو مقصد کے فنکشن میں باقاعدگی کی اصطلاح شامل کرکے اوور فٹنگ کو کنٹرول کرنے کے لئے استعمال ہوتے ہیں۔SVM میں L1 اور L2 ریگولرائزیشن کے درمیان فرق یہ ہے: L1 ریگولرائزیشن (LASSO): L1 باقاعدگی سے مقصد کی تقریب میں جرمانے کی اصطلاح کے طور پر گتانک کی مطلق اقدار کا اضافہ ہوتا ہے۔ یہ ماڈل کو کچھ گتانکوں کو بالکل فروغ دے کر ویرل گتانک کی حوصلہ افزائی کرتا ہے۔صفر.ایل 1 ریگولرائزیشن خصوصیت کے انتخاب کے ل useful مفید ثابت ہوسکتی ہے کیونکہ یہ خودکار خصوصیت کے انتخاب کو مؤثر طریقے سے انجام دینے کے لئے کم اہم خصوصیات کو صفر سے سکڑتی ہے۔ L1 باقاعدگی کی اصطلاح کی نمائندگی کی جاسکتی ہے: λ * || W ||پیرامیٹر اور || ڈبلیو || ₁"
    },
    {
        "Question": "پالیسی تدریج کے تصور اور ان کے استعمال کو کمک سیکھنے میں استعمال کریں۔",
        "Answer": "پالیسی گریڈینٹ پالیسی پیرامیٹرز کو براہ راست بہتر بنا کر ایک ایجنٹ کو زیادہ سے زیادہ پالیسی تلاش کرنے کی تربیت دینے کے لئے کمک لرننگ (آر ایل) میں استعمال ہونے والے الگورتھم کی ایک کلاس ہیں۔ویلیو پر مبنی طریقوں کے برعکس جس کا مقصد ویلیو فنکشن کا اندازہ لگانا ہے ، پالیسی تدریجی طریقے براہ راست ایک پیرامیٹرائزڈ پالیسی سیکھتے ہیں جو نقشہ سازی کرتا ہے۔"
    },
    {
        "Question": "غیر نگرانی شدہ سیکھنے کے لئے گہری عقیدہ نیٹ ورک (DBN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "گہری عقیدہ نیٹ ورک (DBN) کی تربیت میں کئی اقدامات شامل ہیں۔ایک ڈی بی این ایک قسم کا جنریٹو ماڈل ہے جس میں ایک دوسرے کے اوپر سجا دیئے گئے محدود بولٹزمان مشینوں (آر بی ایم) کی متعدد پرتوں پر مشتمل ہوتا ہے۔غیر منقولہ سیکھنے کے لئے ڈی بی این کی تربیت میں شامل اہم اقدامات یہ ہیں: آر بی ایم کے ساتھ پیش کش: ڈی بی این کی ہر پرت کو ایک پرت کے لحاظ سے آر بی ایم کے طور پر پیش کیا جاتا ہے۔ ان پٹ ڈیٹا پر آر بی ایم کی تربیت کرکے پہلی پرت کے ساتھ شروع کریں۔پہلا آر بی ایم تربیت یافتہ ہے ، اس کی پوشیدہ پرت کی سرگرمیاں اگلی پرت میں آر بی ایم کو تربیت دینے کے لئے ان پٹ کے طور پر استعمال کی جاتی ہیں۔ اس عمل کو اس وقت تک جاری رکھیں جب تک کہ ڈی بی این میں موجود تمام آر بی ایم پریٹرینیٹڈ نہیں ہیں۔"
    },
    {
        "Question": "گاوسی مکسچر ماڈل (جی ایم ایم) کی تربیت میں جلد رکنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "گاوسی مکسچر ماڈل (جی ایم ایم) کی تربیت میں ، ابتدائی اسٹاپنگ ایک ایسی تکنیک ہے جو زیادہ سے زیادہ فٹنگ کو روکنے اور تربیتی عمل کو روکنے کے لئے ماڈل کو عام کرنے کو بہتر بنانے کے لئے استعمال کی جاتی ہے۔جلد رکنے کا مقصد ماڈل کی پیچیدگی اور کارکردگی کے مابین ایک زیادہ سے زیادہ تجارت کی تلاش کرنا ہے۔جی ایم ایم ٹریننگ میں ابتدائی اسٹاپنگ کس طرح کام کرتی ہے: تربیت کی تکرار: جی ایم ایم کی تربیت میں عام طور پر ایک تکراری الگورتھم شامل ہوتا ہے ، جیسے توقع-میکسیمائزیشن (ای ایم) الگورتھم۔ ایم ای ایم الگورتھم ماڈل پیرامیٹرز کو مشاہدہ شدہ اعداد و شمار کے امکانات کو زیادہ سے زیادہ کرنے کے لئے ماڈل پیرامیٹرز کو اپ ڈیٹ کرتا ہے۔اور امکان: جیسے جیسے تکرار کی تعداد بڑھتی جارہی ہے ، جی ایم ایم ماڈل زیادہ پیچیدہ اور کر سکتا ہے"
    },
    {
        "Question": "قدرتی زبان پروسیسنگ کے کاموں میں لفظ سینس ڈسگریشن اور اس کے استعمال کے تصور کی وضاحت کریں۔",
        "Answer": "ورڈ سینس ڈیسیمبیگیشن (ڈبلیو ایس ڈی) کسی مخصوص سیاق و سباق میں کسی لفظ کے مطلوبہ معنی یا احساس کا تعین کرنے کا کام ہے۔قدرتی زبان پروسیسنگ (این ایل پی) میں ، الفاظ میں اکثر متعدد ممکنہ حواس ہوتے ہیں ، اور ڈبلیو ایس ڈی کا مقصد اس سیاق و سباق کی بنیاد پر انتہائی مناسب احساس کا انتخاب کرنا ہے جس میں لفظ ظاہر ہوتا ہے۔مقصد زبان کی تفہیم کی درستگی اور بہاو NLP کاموں کی درستگی کو بہتر بنانا ہے۔یہاں لفظ سینس ڈسگریشن کے تصور اور این ایل پی میں اس کے استعمال کی وضاحت ہے: لفظ میں ابہام کا مطلب ہے: قدرتی زبان میں بہت سے الفاظ کے سیاق و سباق کے لحاظ سے متعدد معنی یا حواس ہوتے ہیں۔ مثال کے طور پر ، لفظ \"بینک\" A کا حوالہ دے سکتا ہے۔"
    },
    {
        "Question": "تصویری جنریشن کے لئے مجاز متغیر آٹو اینکوڈر (CVAE) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "ایک مجازی متغیر آٹو اینکوڈر (CVAE) کی تربیت میں تصویری جنریشن کے لئے جنریٹو ماڈل سیکھنے کے ل several کئی اقدامات شامل ہیں۔CVAE متغیرات آٹو انکوڈرز (VAEs) اور کنفیوئل نیورل نیٹ ورکس (CNNs) کے تصورات کو جوڑتا ہے تاکہ تصاویر کی تقسیم کو حاصل کیا جاسکے اور نئی تخلیقات پیدا کی جاسکیں۔تصویری جنریشن کے لئے CVAE کی تربیت میں شامل اہم اقدامات یہاں ہیں: ڈیٹا کی تیاری: CVAE کی تربیت کے لئے تصاویر کا ایک ڈیٹاسیٹ تیار کریں۔(جیسے ، سائز تبدیل کرنا ، فصل)"
    },
    {
        "Question": "قدرتی زبان پروسیسنگ کے کاموں میں لفظ ایمبیڈنگ کے تصور اور ان کے استعمال کی وضاحت کریں۔",
        "Answer": "لفظ ایمبیڈنگ قدرتی زبان پروسیسنگ (این ایل پی) میں ایک بنیادی تکنیک ہے جو الفاظ کی نمائندگی کرتی ہے جس میں ایک مسلسل ویکٹر کی جگہ میں گھنے ، کم جہتی ویکٹر کی نمائندگی ہوتی ہے۔لفظ ایمبیڈنگ کا تصور اس خیال پر مبنی ہے کہ اسی طرح کے معنی والے الفاظ میں ویکٹر کی طرح کی نمائندگی ہوتی ہے ، جس سے مشینیں معنوی تعلقات اور سیاق و سباق سے متعلق معلومات حاصل کرنے کے قابل ہوجاتی ہیں۔یہاں لفظ ایمبیڈنگ کے تصور اور این ایل پی کے کاموں میں ان کے استعمال کی وضاحت ہے: لفظ کی نمائندگی: روایتی طور پر ، این ایل پی میں الفاظ کو ایک گرم ویکٹر کی حیثیت سے پیش کیا گیا تھا ، جہاں ہر لفظ کی نمائندگی ایک ویرل ویکٹر کے ذریعہ کی جاتی ہے۔"
    },
    {
        "Question": "جذبات کے تجزیے کے لئے بار بار اعصابی نیٹ ورک (RNN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "جذبات کے تجزیے کے لئے بار بار اعصابی نیٹ ورک (RNN) کی تربیت میں ایک ماڈل کی تعمیر کے ل several کئی اقدامات شامل ہیں جو کسی دیئے گئے متن کے جذبات (مثبت یا منفی) کی پیش گوئی کرسکتے ہیں۔RNNs خاص طور پر اس کام کے ل suitable موزوں ہیں کیونکہ وہ متن میں ترتیب وار انحصار پر قبضہ کرسکتے ہیں۔جذبات کے تجزیے کے لئے آر این این کی تربیت میں شامل اہم اقدامات یہ ہیں: اعداد و شمار کی تیاری: جذبات کے تجزیے کے لئے ایک لیبل لگا ہوا ڈیٹاسیٹ تیار کریں ، جہاں ہر متن کا نمونہ ایک جذبات کے لیبل (مثبت یا منفی) سے وابستہ ہوتا ہے۔"
    },
    {
        "Question": "تدریجی طور پر فروغ پزیر درختوں کے جوڑنے والی تربیت میں جلد رکنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "تربیت کے عمل کے دوران تدریجی طور پر فروغ پزیر درختوں کے جوڑنے والی تربیت میں ابتدائی طور پر رکنا ایک ایسی تکنیک ہے جو زیادہ سے زیادہ مناسب ہونے کو روکنے اور زیادہ سے زیادہ تعداد کو بڑھانے والے تکرار (جسے درختوں کے نام سے بھی جانا جاتا ہے) کا تعین کرنے کے لئے استعمال کیا جاتا ہے۔جلد رکنے کا مقصد اس نقطہ کو تلاش کرنا ہے جس پر ایک توثیق کے سیٹ پر ماڈل کی کارکردگی ہراساں ہونا شروع ہوجاتی ہے ، جس سے یہ ظاہر ہوتا ہے کہ مزید اس کی نشاندہی ہوتی ہے۔"
    },
    {
        "Question": "اعصابی مشین ترجمے کے ماڈلز میں لفظ سیدھ کے تصور کی وضاحت کریں۔",
        "Answer": "اعصابی مشین ٹرانسلیشن (این ایم ٹی) کے ماڈلز میں ورڈ سیدھ سے مراد ماخذ زبان اور ہدف زبان کے جملوں کے مابین الفاظ کو سیدھ میں کرنے کے عمل سے مراد ہے۔اس کا مقصد منبع جملے میں الفاظ اور ہدف کے جملہ میں ان کے متعلقہ ترجموں کے مابین خط و کتابت یا صف بندی قائم کرنا ہے۔این ایم ٹی ماڈلز میں ورڈ سیدھ ایک لازمی جزو ہے کیونکہ اس سے ماڈل کو مختلف زبانوں میں الفاظ کے مابین ترجمے کا رشتہ سیکھنے میں مدد ملتی ہے۔یہاں NMT ماڈلز میں لفظ سیدھ کے تصور کی وضاحت ہے: لفظ کی سیدھ کی اہمیت: اعصابی مشین ترجمہ میں ، ماڈل ماخذ زبان کے جملہ سے کسی ہدف کی زبان کے جملے میں ترجمہ کرنا سیکھتا ہے۔ ورڈ کی صف بندی بہت ضروری ہے کیونکہ اس کی وجہ یہ ہے۔"
    },
    {
        "Question": "بے ضابطگی کا پتہ لگانے کے لئے جنریٹو ایڈورسیریل نیٹ ورک (GAN) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "بے ضابطگی کا پتہ لگانے کے لئے جنریٹو ایڈورسیریل نیٹ ورک (GAN) کی تربیت میں ایک ماڈل بنانے کے لئے کئی اقدامات شامل ہیں جو عام اعداد و شمار تیار کرسکیں اور غیر معمولی نمونوں کی نشاندہی کرسکیں۔بے ضابطگی کا پتہ لگانے کے لئے ایک GAN کی تربیت میں شامل اہم اقدامات یہ ہیں: ڈیٹا کی تیاری: عام ڈیٹا کے نمونے پر مشتمل ڈیٹاسیٹ تیار کریں۔عدم استحکام یا تو نایاب واقعات یا ڈیٹا پوائنٹس ہوسکتے ہیں جو عام تقسیم سے نمایاں طور پر انحراف کرتے ہیں۔ اس بات کا یقین کریں کہ ڈیٹاسیٹ اچھی طرح سے پیشگی ہے اور مطلوبہ خصوصیات کی نمائندگی کرتا ہے جو معمول کے طرز عمل کی وضاحت کرتی ہے۔عام طور پر گان پر مشتمل ہوتا ہے"
    },
    {
        "Question": "فیصلہ ٹری ماڈلز میں L1 اور L2 کو باقاعدہ بنانے میں کیا فرق ہے؟",
        "Answer": "فیصلے کے درختوں کے ماڈلز میں ، L1 اور L2 ریگولرائزیشن دو مختلف اقسام کو باقاعدہ بنانے کی تکنیک کا حوالہ دیتے ہیں جو زیادہ مناسب ہونے کو روکنے اور ماڈل کی عمومی صلاحیت کو بہتر بنانے کے لئے استعمال ہوتے ہیں۔فیصلے کے درختوں کے ماڈلز میں L1 اور L2 کو باقاعدہ بنانے کے درمیان اہم اختلافات یہ ہیں: جرمانے کا حساب کتاب: L1 ریگولرائزیشن (LASSO): L1 باقاعدگی سے نقصان کی تقریب میں جرمانہ کی اصطلاح شامل ہوتی ہے جو ماڈل کے گتانکوں یا خصوصیت کے وزن کی مطلق اقدار کے متناسب ہے۔جرمانے کی اصطلاح کو گتانک کی مطلق اقدار کے مجموعہ کے طور پر حساب کیا جاتا ہے۔جرمانے کی اصطلاح کو گتانک کی مربع اقدار کے مجموعہ کے طور پر حساب کیا جاتا ہے۔"
    },
    {
        "Question": "اداکار-تنقیدی الگورتھم کے تصور اور ان کے استعمال کو کمک سیکھنے میں استعمال کریں۔",
        "Answer": "اداکار تنقیدی الگورتھم کمک لرننگ الگورتھم کی ایک کلاس ہے جو کمک سیکھنے کے کاموں میں زیادہ سے زیادہ پالیسیاں سیکھنے کے لئے ویلیو پر مبنی طریقوں (نقاد) اور پالیسی پر مبنی طریقوں (اداکار) دونوں کے عناصر کو یکجا کرتی ہے۔یہ الگورتھم مختلف ڈومینز میں بڑے پیمانے پر استعمال ہوتے رہے ہیں ، جن میں روبوٹکس ، گیم پلےنگ ، اور خود مختار ایجنٹ شامل ہیں۔یہاں اداکار-تنقیدی الگورتھم کے تصور اور ان کے استعمال سے کمک لرننگ کے استعمال کی وضاحت ہے: اداکار: اداکار کا جزو موجودہ پالیسی پر مبنی اقدامات کے انتخاب کے لئے ذمہ دار ہے۔ اداکار براہ راست ایک ایسی پالیسی تقریب سیکھتا ہے جس سے ریاستوں کا نقشہ تیار کرتا ہے۔عمل۔ پالیسی متنازعہ ہوسکتی ہے ، جہاں اداکار براہ راست بہترین عمل ، یا اسٹاکسٹک کو آگے بڑھاتا ہے ، جہاں اداکار عمل سے زیادہ امکانی تقسیم کو پیش کرتا ہے۔ اداکار کا مقصد وقت کے ساتھ متوقع واپسی یا مجموعی انعام کو زیادہ سے زیادہ کرنا ہے۔"
    },
    {
        "Question": "بے ضابطگی کا پتہ لگانے کے لئے ایک متغیر آٹو اینکوڈر (VAE) کی تربیت میں شامل اہم اقدامات کی وضاحت کریں۔",
        "Answer": "بے ضابطگی کا پتہ لگانے کے لئے ایک متغیر آٹو اینکوڈر (VAE) کی تربیت میں ایک ماڈل کی تعمیر کے ل several کئی اقدامات شامل ہیں جو عام اعداد و شمار کو مؤثر طریقے سے تشکیل دے سکتے ہیں اور متضاد نمونوں کا پتہ لگاسکتے ہیں۔یہاں ایک VAE کی تربیت میں شامل اہم اقدامات یہ ہیں"
    },
    {
        "Question": "خود کو منظم کرنے والے نقشہ (SOM) کی تربیت میں جلدی روکنے کا مقصد کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ابتدائی طور پر رکنا ایک ایسی تکنیک ہے جو خود کو منظم کرنے والے نقشوں (SOMs) کی تربیت کے دوران استعمال کی جاتی ہے تاکہ ماڈل کی عمومی صلاحیت کو بہتر بنایا جاسکے۔ابتدائی رکنے کا مقصد تربیت کے عمل کی نگرانی کرنا اور تربیت کو روکنا ہے جب توثیق کے سیٹ پر کارکردگی خراب ہونے لگتی ہے۔یہاں یہ ہے کہ ایس او ایم کی تربیت میں ابتدائی اسٹاپنگ کس طرح کام کرتی ہے: تربیت کا عمل: کسی SOM کی تربیت کے دوران ، ان پٹ ڈیٹا کو تکرار سے نیٹ ورک کے سامنے پیش کیا جاتا ہے ، اور نیوران کے وزن کو ان پٹ نمونوں کی بہتر نمائندگی کرنے کے لئے ایڈجسٹ کیا جاتا ہے۔ تربیت کے عمل میں عام طور پر متعدد شامل ہوتے ہیں۔تکرار یا ایپوچز۔ کارکردگی کی نگرانی:"
    },
    {
        "Question": "دو صفوں کے درمیان اوسط اسکوائرڈ غلطی (ایم ایس ای) کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا"
    },
    {
        "Question": "\"بائنری درجہ بندی کے ماڈل کی درستگی ، صحت سے متعلق ، اور یاد کرنے کے لئے ایک ازگر فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو بائنری درجہ بندی کے ماڈل کی درستگی ، صحت سے متعلق اور یاد کی گنتی کرتا ہے: پائیتھون کوپی کوڈ ڈیف کمپیوٹ_بائنری_کلیسفیکیشن_میٹرکس (سچ_ لیبلز ، پیش گوئی شدہ_لیبلز): \"\" \"\" \"\" \"\" بائنری درجہ بندی کے لئے درستگی ، صحت سے متعلق ، اور یاد کی گنتی کرتی ہے۔ndarray): بائنری درجہ بندی کے حقیقی لیبل۔ پیشن گوئی_ لیبلز (فہرست یا numpy.ndarray): بائنری درجہ بندی کے پیش گوئی والے لیبل۔ ریٹرن: فلوٹ: ماڈل کی درستگی۔ فلوٹ: ماڈل کی صحت سے متعلق۔ فلوٹ: فلوٹ: ماڈل کی یاد۔ \"\"\" اگر لین (ٹری_لیبلز)! = لین (پیش گوئی شدہ_لیبل): ویلیو ایرر (\"ان پٹ آرائیوں کو ایک ہی لمبائی ہونی چاہئے۔\") ٹری_ لیبلز = این پی.ارے (ٹری_لیبل) پیش گوئی کی گئی_لیبلز = این پی آر آرے (پیش گوئی کی گئی_ لیبلز) سچ_پوزیٹو = این پی ایس او ایم (ایس یو ایم (np.logical_and (پیش گوئی"
    },
    {
        "Question": "دیئے گئے مشین لرننگ ماڈل کے لئے K-fold کراس توثیق کرنے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو دیئے گئے مشین لرننگ ماڈل کے لئے K-fold کراس توثیق کرتا ہے: پیتھون کوپی کوڈفرم اسکلرن.موڈیل_ سلیکشن امپورٹ Kfoldimport numpy as npdef K_fold_cross_validation (ماڈل ، x ، Y ، K)دیئے گئے مشین لرننگ ماڈل کے لئے۔ آرگس: ماڈل: مشین لرننگ ماڈل کا اندازہ کیا جائے۔ x (numpy.ndarray): ان پٹ کی خصوصیاتکراس توثیق کے لئے۔ واپسی: numpy.ndarray: ہر گنا کے لئے تشخیص کے اسکور کی صف۔"
    },
    {
        "Question": "کم میکس اسکیلنگ کا استعمال کرتے ہوئے ایک عددی فیچر ویکٹر کو معمول پر لانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ایک عددی خصوصیت کے ویکٹر کو معمول پر لانے کے لئے کم سے کم میکس اسکیلنگ انجام دیتا ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف من_میکس_سکلنگ (فیچر_ویکٹر): \"\" \"ایک عددی فیچر ویکٹر کو معمول پر لانے کے لئے کم سے کم میکس اسکیلنگ انجام دیتا ہے۔: فیچر ویکٹر کو معمول بنایا جائے۔ ریٹرنس: numpy.ndarray: معمول کی خصوصیت ویکٹر۔اس فنکشن کو واپس کریں۔"
    },
    {
        "Question": "اسٹاکسٹک تدریجی نزول کی اصلاح کا استعمال کرتے ہوئے لاجسٹک ریگریشن کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!اسٹاکسٹک تدریجی نزول (ایس جی ڈی) کی اصلاح کا استعمال کرتے ہوئے لاجسٹک ریگریشن کے لئے ایک ازگر کلاس کی ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی سی ایل اے ایس سی لاجسٹک ریگریسس جی ڈی: ڈیف __init __ (خود ، لرننگ_ریٹ = 0.01 ، num_epochs = 1000 ، Batch_size = 32).num_epochs = num_epochs self.batch_size = بیچ_سائز سیلف۔ وائٹس۔(num_features) self.bias = 0 for _"
    },
    {
        "Question": "کسی دیئے گئے امکانی تقسیم کے انٹروپی کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے امکانی تقسیم کے انٹروپی کا حساب لگانے کے لئے یہاں ایک ازگر فنکشن ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کے حساب کتاب_انٹروپی (احتمالات): \"\" \"\" \"دیئے گئے امکانی تقسیم کے اینٹروپی کا حساب لگاتا ہے۔. واپسی: فلوٹ: اینٹروپی ویلیو۔آسان گنتی کے ل a ایک غیرمعمولی صف میں۔اس کے بعد ، ہم فارمولے کا استعمال کرتے ہوئے اینٹروپی کا حساب لگاتے ہیں: CSSCOPY Codyentropy = -sum (P * Log2 (P)) جہاں P تقسیم میں ہر امکان کی نمائندگی کرتا ہے۔حساب کتاب میں ایک چھوٹی سی ایپسیلن ویلیو (1E-8) شامل ہے"
    },
    {
        "Question": "اجتماعی طریقہ کار کا استعمال کرتے ہوئے درجہ بندی کے کلسٹرنگ کو انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو اجلومیٹو طریقہ کا استعمال کرتے ہوئے درجہ بندی کے کلسٹرنگ کو انجام دیتا ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکیپی.کلوسٹر۔ ہیرارچی درآمد لنکج ، ڈینڈرگرامڈیمڈف ہائیرارچیکل_کلوسٹرنگ (ڈیٹا ، میتھک = 'یوکلڈین')اجتماعی طریقہ کار کا استعمال کرتے ہوئے۔اسکیپی کے تعلق کے فنکشن کے ذریعہ تائید کردہ کوئی دوسرا طریقہ. پہلے سے طے شدہ 'یوکلیڈین' ہے۔"
    },
    {
        "Question": "دو ویکٹروں کے مابین کوسائن مماثلت کی گنتی کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں دو ویکٹروں کے مابین کوسائن مماثلت کی گنتی کے لئے ایک ازگر فنکشن ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی ڈی ای ایف کوسائن_سیمیلیٹی (ویکٹر 1 ، ویکٹر 2): \"\" \"دو ویکٹروں کے مابین کوسائن مماثلت کی گنتی کرتی ہے۔.ویکٹر 2) مماثلت = ڈاٹ_ پروڈکٹ / (نورم_ویکٹر 1 * نورم_ویکٹر 2) اس فنکشن کو مماثلت میں لوٹائیں ، ہم دو ویکٹروں کے ڈاٹ پروڈکٹ کا حساب لگانے کے لئے نومی کے این پی ڈاٹ ڈیوٹ فنکشن کا استعمال کرتے ہیں۔پھر،"
    },
    {
        "Question": "درجہ بندی کے لئے K-nearrest پڑوسیوں (KNN) الگورتھم کے لئے ایک ازگر کلاس نافذ کریں۔",
        "Answer": "یقینا!درجہ بندی کے لئے K-nearrest پڑوسیوں (KNN) الگورتھم کے لئے ایک ازگر کلاس کی ایک مثال یہ ہے: Pythoncopy Codemport numpy as npfrom scipy.spatial.distance درآمد CdistClass knnclassifier: def __init __ (خود ، 3).x_train = کوئی بھی نہیں۔.ارگسورٹ (فاصلوں ، محور = 1) [: ،: self.k] قریب ترین_لیبلز = سیلف۔"
    },
    {
        "Question": "ملٹی ویریٹیٹ عام تقسیم کے بعد مصنوعی اعداد و شمار تیار کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!ایک کثیر القومی عام تقسیم کے بعد مصنوعی اعداد و شمار تیار کرنے کے لئے یہاں ایک ازگر کا فنکشن ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف جنریٹ_مولٹیویریٹ_نورمل_ڈیٹا (جس کا مطلب ہے ، کوویرنس ، نمبر_سمپل): \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" نیپریئٹ عام تقسیم کے بعد مصنوعی اعداد و شمار تیار کرتی ہے۔تقسیم کا ویکٹر۔"
    },
    {
        "Question": "بائنری درجہ بندی کے لئے دیئے گئے ڈیٹاسیٹ کی جینی نجاست کا حساب لگانے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!بائنری درجہ بندی کے لئے دیئے گئے ڈیٹاسیٹ کی جینی ناپاکی کا حساب لگانے کے لئے یہاں ایک ازگر کا فنکشن ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کا حساب کتاب_جین_مپیوریٹی (لیبل): \"\" \"بائنری درجہ بندی کے لئے دیئے گئے ڈیٹاسیٹ کی جینی نجاست کا حساب لگاتا ہے۔: ڈیٹاسیٹ کے لیبل۔ واپسی: فلوٹ: جینی ناپاک قیمت۔) Gini_impurityin اس فنکشن کو واپس کریں ، ہم سب سے پہلے ڈیٹاسیٹ میں ہر کلاس لیبل کی موجودگی کو گننے کے لئے NUMPY کے NP.Bincount فنکشن کا استعمال کرتے ہیں۔اس کے بعد ہم اس کا حساب لگاتے ہیں"
    },
    {
        "Question": "چی مربع ٹیسٹ کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دینے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!چی مربع ٹیسٹ کا استعمال کرتے ہوئے خصوصیت کے انتخاب کو انجام دینے کے لئے یہاں ایک ازگر فنکشن ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکیپی۔.ndarray): خصوصیت میٹرکسChi2_stats = [] p_values = [] حد میں خصوصیت کے لئے (x.shape [1]): مشاہدہ کیا گیا"
    },
    {
        "Question": "درجہ بندی کے لئے سپورٹ ویکٹر مشین (ایس وی ایم) الگورتھم کے لئے ایک ازگر کلاس نافذ کریں۔",
        "Answer": "یقینا!سپورٹ ویکٹر مشین (ایس وی ایم) کے لئے ایک ازگر کلاس کی ایک مثال یہ ہے کہ سککیٹ لرن لائبریری کا استعمال کرتے ہوئے درجہ بندی کے لئے الگورتھم: پائیتھون کوپی کوڈفرم اسکلرن۔ ایس وی ایم امپورٹ ایس وی سی سی ایل اے ایس ایس ایس سی ایم سی ایل ایسفائر: ڈیف __init __ (خود ، دخش = 'آر بی ایف' ، سی = 1.0):self.kernel = Kernel self.c = c self.model = کوئی بھی Def فٹ (خود ، x_train ، y_train): self.model = svc (دانا = self.kernel ، c = self.c) self.model.fit (x_train (x_train، Y_TRAIN) ڈیف پیشن گوئی (خود ، X_TEST): اگر سیلف موڈل کوئی نہیں ہے: استثناء بڑھاؤ (\"ابھی تک تربیت یافتہ نہیں۔ پہلے فٹ طریقہ کو کال کریں۔\"(__init__ طریقہ) پیرامیٹرز دانا اور سی لیتا ہے ، جو اس کی نمائندگی کرتا ہے"
    },
    {
        "Question": "دیئے گئے ڈیٹاسیٹ پر پرنسپل جزو تجزیہ (پی سی اے) انجام دینے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے ڈیٹاسیٹ پر پرنسپل جزو تجزیہ (پی سی اے) کو انجام دینے کے لئے یہاں ایک ازگر فنکشن ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی ڈی ای ایف پرفارمنس_پی سی اے (ڈیٹا ، نمبر_کیمپینٹس = کوئی بھی نہیں): \"\" \"دیئے گئے ڈیٹاسیٹ پر پرنسپل جزو تجزیہ (پی سی اے) انجام دیتا ہے۔numpy.ndarray): شکل کے ساتھ ان پٹ ڈیٹاسیٹ (num_samples ، num_features)۔ num_components (int): برقرار رکھنے کے لئے پرنسپل اجزاء کی تعداد۔ اگر کوئی نہیں ، تو تمام اجزاء کو برقرار رکھتے ہیں۔ واپسی: numpy.ndarray: شکل کے ساتھ پی سی اے کے بعد تبدیل شدہ ڈیٹاسیٹ ((num_samples ، num_components). numpy.ndarray: ہر پرنسپل جزو سے مطابقت پذیر ایگین ویلیوز۔ numpy.ndarray: ہر پرنسپل جزو سے مطابقت رکھنے والے ایجین ویکٹر (لوڈنگ)۔ \"\" \""
    },
    {
        "Question": "متن کی درجہ بندی کے لئے بولی بایس الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!متن کی درجہ بندی کے لئے بولی بایس الگورتھم کے لئے ایک ازگر کلاس کی ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی"
    },
    {
        "Question": "زیڈ اسکور کے طریقہ کار کا استعمال کرتے ہوئے آؤٹ لیئر کا پتہ لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!زیڈ اسکور کے طریقہ کار کا استعمال کرتے ہوئے آؤٹ لیئر کا پتہ لگانے کے لئے ایک ازگر فنکشن یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف ڈٹیکٹ_آؤٹلیئرز_زکور (ڈیٹا ، تھریشولڈ = 3): \"\" \"زیڈ اسکور کے طریقہ کار کا استعمال کرتے ہوئے آؤٹ لیئر کا پتہ لگانا انجام دیتا ہے۔ آرگس: ڈیٹا (numpy.ndarray): شکل (num_samples ، num_features) کے ساتھ ان پٹ ڈیٹا۔ دہلیز (فلوٹ): زیڈ اسکور کے لئے دہلیز۔ دہلیز سے زیادہ زیڈ اسکور والے ڈیٹا پوائنٹس کو آؤٹ لیئرز سمجھا جاتا ہے۔ واپسی: numpy.ndarray: ایک بولین سرنی اشارہ کرناچاہے ہر ڈیٹا پوائنٹ ایک آؤٹ لیٹر ہو۔)) # دہلیز سے زیادہ زیڈ اسکورز پر مبنی آؤٹ لیئرز کا تعین کریں is_outlier = np.any (z_scores> دہلیز ، محور = 1) واپسی IS_OUTLIER"
    },
    {
        "Question": "درجہ بندی کے لئے بے ترتیب جنگل الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!درجہ بندی کے لئے بے ترتیب جنگل الگورتھم کے لئے ایک ازگر کلاس کی ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکلن۔= num_trees self.max_depth = max_depth sell"
    },
    {
        "Question": "بائنری درجہ بندی کے ماڈل کے لئے آر او سی وکر (اے یو سی) کے تحت علاقے کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!بائنری درجہ بندی کے ماڈل کے لئے آر او سی وکر (اے یو سی) کے تحت علاقے کا حساب لگانے کے لئے یہاں ایک ازگر کا فنکشن ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکلرن۔ میٹرکس کو امپورٹ روک_کورو ، اے یو سی ڈی ای ایف کا حساب کتاب (Y_TRUE ، Y_SCORE): \"\" \"\" ROC کے تحت علاقے کا حساب کتاب کرتا ہے۔(اے یو سی) بائنری درجہ بندی کے ماڈل کے لئے۔قدر.(ٹی پی آر"
    },
    {
        "Question": "کسی دیئے گئے ڈیٹاسیٹ پر K-means کلسٹرنگ انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں دیئے گئے ڈیٹاسیٹ پر K-means کلسٹرنگ انجام دینے کے لئے ایک ازگر فنکشن ہے: Pythoncopy Codemport numpy as npdef kmeans_clustering (ڈیٹا ، کے ، میکس_یٹریشن = 100): \"\" \"\" دیئے گئے ڈیٹاسیٹ پر K-means کلسٹرنگ انجام دیتا ہے۔ndarray): شکل (num_samples ، num_features) کے ساتھ ان پٹ ڈیٹا"
    },
    {
        "Question": "درجہ بندی کے ماڈل کے F1 اسکور کی گنتی کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!درجہ بندی کے ماڈل کے F1 اسکور کی گنتی کے لئے یہاں ایک ازگر فنکشن ہے: Pythoncopy Codemport numpy as npdef حساب کتاب_ف 1_سور (Y_True ، y_pred): \"\" \"\" درجہ بندی کے ماڈل کے F1 اسکور کا حساب لگاتا ہے۔درجہ بندی کے مسئلے کا"
    },
    {
        "Question": "رجعت کے لئے تدریجی فروغ دینے والے الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!رجعت کے لئے تدریجی فروغ دینے والے الگورتھم کے لئے یہاں ایک ازگر کی کلاس ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی سی ایل اے ایس کے گریڈینٹ بوسٹنگریگریسر: ڈیف __init __ (خود ، N_ESTIMATORS = لرننگ_ریٹ = 0.1 ، میکس_ڈیپٹھ = 3)= زیادہ سے زیادہ_ڈیپٹھ سیلف۔اسٹیمیٹرز = [] ڈیف فٹ (خود ، ایکس ، وائی): # ہدف کی اقدار کے ساتھ باقیات کو شروع کریں"
    },
    {
        "Question": "ڈیٹاسیٹ کو اسٹریٹیفائڈ نمونے لینے کا استعمال کرتے ہوئے تربیت اور جانچ کے سیٹوں میں تقسیم کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!اسٹریٹائڈ نمونے لینے کا استعمال کرتے ہوئے تربیت اور جانچ کے سیٹوں میں ڈیٹاسیٹ کو تقسیم کرنے کے لئے یہاں ایک ازگر کا فنکشن ہے: پائیٹون کوپی کوڈفرم اسکلن ۔موڈیل_ سلیکشن کو درآمد ٹرین_ٹیسٹ_سپلٹ ڈیف اسٹریٹائڈ_ٹیٹڈ_ٹیسٹ_سپلٹ (ایکس ، وائی ، ٹیسٹ_سائز = 0.2 ، رینڈم_سٹیٹ = کوئی بھی نہیں): \"\" \"\" \"\" \"stratified نمونے لینے کا استعمال کرتے ہوئے۔.x_train ، x_test ، y_train ، y_test = ٹرین_ٹیسٹ_سپلٹ (x ، y ، test_size = ٹیسٹ"
    },
    {
        "Question": "بیگ آف ورڈز ماڈل کا استعمال کرتے ہوئے خصوصیت نکالنے کے ل a ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!بیگ آف ورڈز ماڈل کا استعمال کرتے ہوئے خصوصیت کو نکالنے کے لئے ایک ازگر فنکشن یہ ہے: پائیتھون کوپی کوڈفرم اسکلرن ۔فیٹور_ ایکسٹرائن۔ ٹیکسٹ امپورٹ کاؤنٹ ویکٹورائزر ڈیف ایکسٹریکٹ_فیکچر_بو (متن): \"\" \"بیگ آف ورڈز ماڈل کا استعمال کرتے ہوئے خصوصیت کا حصول کریں۔فہرست): متن کی دستاویزات کی فہرست۔ واپسی: ٹیوپل: ٹیوپل (خصوصیات ، فیچر_ نام) جس میں نکالی ہوئی خصوصیات اور خصوصیت کے نام شامل ہیں۔خصوصیات کی واپسی ، فیچر_نامین اس فنکشن ، ہم خصوصیت نکالنے کے ل sc سکیٹ لرن کے کاؤنٹ ویکٹرائزر کا استعمال کرتے ہیں"
    },
    {
        "Question": "ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے ل a ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے لئے یہاں ایک ازگر کا فنکشن ہے جس کا مطلب ہے.'مطلب' پر قائم حکمت عملی کے ساتھ سیکھیں سادہ نقشہ دار کلاس۔امپٹر کا Fit_transformfort طریقہ ڈیٹاسیٹ X پر موجود امپٹر کو فٹ بیٹھتا ہے اور گمشدہ اقدار پر معنی خیز کارکردگی کا مظاہرہ کرتا ہے ، جس سے تیار کردہ ڈیٹاسیٹ واپس ہوتا ہے۔ آپ اس فنکشن کو مندرجہ ذیل کے طور پر استعمال کرسکتے ہیں: کاپی کوڈ"
    },
    {
        "Question": "ترتیب کی پیش گوئی کے لئے پوشیدہ مارکوف ماڈل (HMM) الگورتھم کے لئے ایک ازگر کلاس نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو تسلسل کی پیش گوئی کے لئے پوشیدہ مارکوف ماڈل (HMM) الگورتھم کو نافذ کرتی ہے: Pythoncopy Codemport numpy as npclass hidedmarkovModel: def __init __ (خود ، ریاستوں ، مشاہدات ، اسٹارٹ_پروب ، سیلف_پروب ، سیلف. اسٹیٹس = سیلف. اسٹیٹس = اسٹیٹس۔ اسٹیٹس = اسٹیٹس۔ اسٹیٹس = اسٹیٹس۔ اسٹیٹس = اسٹیٹسمشاہدات خود# ابتداء الفا [0 ،:] = self.start_prob * self.emission_prob [: ، self.observes.index.index (مشاہدات [0])] # انڈکشن"
    },
    {
        "Question": "کلسٹرنگ کے نتائج کے لئے سلیمیٹ اسکور کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!کلسٹرنگ کے نتائج کے لئے سلہویٹ اسکور کا حساب لگانے کے لئے یہاں ایک ازگر کا فنکشن ہے: پیتھون کوپی کوڈفرم اسکلرن۔ میٹرکس امپورٹ سلہوئٹی_سمپلس ، سلہوئٹی_سکوریڈف کیلکولیٹ_سیلہوٹ_سکور (ایکس ، لیبلز): \"\" \"ایک کلسٹرنگ کے لئے سلہیٹ اسکور کا حساب لگائیں۔: ان پٹ ڈیٹاسیٹ۔ لیبل (numpy.ndarray): ہر ڈیٹا پوائنٹ کے لئے پیش گوئی شدہ کلسٹر لیبل۔ واپسی: فلوٹ: سلہوٹ اسکور۔سلیمیٹ اسکور کا حساب کتاب کرنے کے لئے سلویٹ_سکور فنکشن۔silhoette_score فنکشن ان پٹ ڈیٹاسیٹ لیتا ہے"
    },
    {
        "Question": "معیاری کاری کا استعمال کرتے ہوئے فیچر اسکیلنگ انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!معیاری کاری کا استعمال کرتے ہوئے فیچر اسکیلنگ کو انجام دینے کے لئے ایک ازگر فنکشن ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی ڈی ای ایف اسٹینڈرائز_فیٹریچرز (ایکس): \"\" \"معیاری استعمال کا استعمال کرتے ہوئے فیچر اسکیلنگ انجام دیں۔معیاری ڈیٹاسیٹ۔ان پٹ ڈیٹاسیٹ X میں ہر خصوصیت کا انحراف بالترتیب NUMPY کے وسط اور STD افعال کا استعمال کرتے ہوئے۔اس کے بعد ، ہم ہر خصوصیت سے وسیلہ کو گھٹا دیتے ہیں اور معیاری کاری کو انجام دینے کے لئے معیاری انحراف کے ذریعہ تقسیم کرتے ہیں۔نتیجے میں معیاری ڈیٹاسیٹ واپس کردیا گیا ہے۔ آپ اس فنکشن کو مندرجہ ذیل استعمال کرسکتے ہیں: پیتھون کوپی کوڈیمپورٹ NUMPY بطور NP#"
    },
    {
        "Question": "اسموٹ الگورتھم کا استعمال کرتے ہوئے اقلیتی طبقے کی حد سے تجاوز کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جس میں ایک اقلیتی طبقے کی حد سے تجاوز کرنے کا کام کیا گیا ہے (مصنوعی اقلیت سے زیادہ نمونے لینے کی تکنیک) الگورتھم: پائیتھون کوپی کوڈیمپورٹ نیمپمی کے طور پر این پیفرم اسکلرن۔\"\" اسموٹ الگورتھم کا استعمال کرتے ہوئے اقلیتی طبقے کی حد سے تجاوز کریں۔اوورسمپلنگ_راٹیو (فلوٹ): اکثریت طبقے کے نمونے کے لئے اقلیتی طبقاتی نمونے کا مطلوبہ تناسب۔ واپسی: numpy.ndarray: اوورسمپلڈ ڈیٹاسیٹ۔ numpy.ndarray: تازہ ترین ہدف لیبل۔y == 0] اقلیتی_سمپلز = x [y == 1] #"
    },
    {
        "Question": "رجعت کے لئے فیصلے کے درخت الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!رجعت کے لئے فیصلے کے درخت الگورتھم کے لئے ایک ازگر کی کلاس یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی سی ایل اے ایس ڈی ڈینسٹریریگریسر: ڈیف __init __ (خود ، میکس_ڈیپتھ = کوئی بھی نہیں): سیلف۔میکس_ڈیپتھ = میکس_ ڈی پی ٹی ایچ ایف فٹ (خود ، X ، Y): سیلف.ٹری = سیلف۔_ بلڈ_ٹری (x ، y ، گہرائی = 0) Def _build_tree (خود ، x ، y ، گہرائی): اگر گہرائی == self.max_depth یا np.var (y) == 0: واپسی np.Mean (y) فیچر_ انڈیکس ، split_value= سیلف۔] ، گہرائی + 1) دائیں_سوبٹری = سیلف۔"
    },
    {
        "Question": "دو متغیرات کے مابین باہمی معلومات کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!دو متغیرات کے مابین باہمی معلومات کا حساب لگانے کے لئے یہاں ایک ازگر کا فنکشن ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکیپی امپورٹ اسٹیٹ ڈیف کیلکولیٹ_موئل_ انفارمیشن (ایکس ، وائی): \"\" \"دو متغیر کے مابین باہمی معلومات کا حساب لگائیں۔متغیر. y (numpy.ndarray): دوسرا متغیر۔ واپسی: فلوٹ: باہمی معلومات۔# کمپیوٹ مارجنل احتمالاتx_probs)): رینج میں جے کے لئے (لین (Y_Probs)):"
    },
    {
        "Question": "گرڈ سرچ اور کراس توثیق کا استعمال کرتے ہوئے ماڈل کے انتخاب کو انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو گرڈ سرچ اور کراس توثیق کا استعمال کرتے ہوئے ماڈل کا انتخاب انجام دیتا ہے: پائیتھون کوپی کوڈفرم اسکلرن ۔موڈیل_ سلیکشن امپورٹ گرڈ سرچ سی وی ڈی ای ایف پرفارم_ گرڈ_سرچ (ایکس ، وائی ، ماڈل ، پیرام_گرڈ ، سی وی = 5): \"\" گرڈ سرچ اور کراس- کا استعمال کرتے ہوئے ماڈل کا انتخاب کریں۔توثیق. آرگس: x (numpy.ndarray): فیچر میٹرکسکراس توثیق کرنے والے فولڈز کی تعداد۔ پہلے سے طے شدہ 5 ہے۔ واپسی: آبجیکٹ: گرڈ سرچ کے ذریعے پائے جانے والا بہترین ماڈل۔# بہترین ماڈل حاصل کریں best_model = grid_search.best_estimator_"
    },
    {
        "Question": "بات چیت کی شرائط پیدا کرکے فیچر انجینئرنگ انجام دینے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو بات چیت کی شرائط تشکیل دے کر فیچر انجینئرنگ کو انجام دیتا ہے: پائیٹون کوپی کوڈیمپورٹ پانڈاس بطور Pdfrom اسکلیئرن۔ پریپروسیسنگ درآمد پولیومیومیلفیٹورز ڈیف تخلیق_ٹینٹریکشن_ٹرمز (ڈیٹا ، ڈگری = 2 ، شامل_بیاس = غلط).تعامل کی شرائط کے ساتھ ڈیٹا۔"
    },
    {
        "Question": "گاوسی مرکب ماڈلز کے لئے توقع-میکسیمائزیشن (EM) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو گوسی مکسچر ماڈل (جی ایم ایم) کے لئے توقع-میکسمائزیشن (ای ایم) الگورتھم کو نافذ کرتی ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی سی ایل اے ایس سی گوسیانمکسٹریموڈیل: ڈی ای ایف __ (خود ، این_کمپونٹس ، میکس_ٹر = 100 ، ٹی او ایل = 100 ، ٹی او ایل = 100 ، ٹیول =گوسی مکسچر ماڈل (جی ایم ایم) توقع-میکسمائزیشن (EM) الگورتھم کا استعمال کرتے ہوئے۔ آرگس: N_COMPONENTS (INT): گاوسی اجزاء کی تعداد۔ میکس_ٹر (INT): زیادہ سے زیادہ تعداد کی تعداد۔ پہلے سے طے شدہ ہے۔1E-4 ہے۔"
    },
    {
        "Question": "درجہ بندی کے ماڈل کے لئے K (ap@k) میں اوسط صحت سے متعلق کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو درجہ بندی کے ماڈل کے لئے K (ap@k) میں اوسط صحت سے متعلق کا حساب لگاتا ہے: Pythoncopy کوڈیمپورٹ numpy as npdef اوسط_پیسیشن_ٹ (Y_true ، y_pred ، k): \"\" \"\" \"K (ap@k) کے لئے اوسط صحت سے متعلق حساب لگائیں۔ایک درجہ بندی کا ماڈل۔ آرگس: Y_TRUE (numpy.ndarray): نمونے کے حقیقی لیبل۔INT): K. ریٹرنس کی قدر: فلوٹ: کے میں اوسط صحت سے متعلق۔ہر پوزیشن کی صحت سے متعلق صحت سے متعلق"
    },
    {
        "Question": "ٹینسور فلو یا پائٹورچ جیسی لائبریری کا استعمال کرتے ہوئے گہری عصبی نیٹ ورک الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!ٹینسر فلو لائبریری کا استعمال کرتے ہوئے گہری عصبی نیٹ ورک کے لئے ازگر کی کلاس کو نافذ کرنے کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ ٹینسور فلو بطور TFClass DiepNealurnetwork: Def __Init __ (خود ، ان پٹ_ڈیم ، پوشیدہ_نیٹس ، آؤٹ پٹ_ڈیم): \"\" ڈیپ نیورل نیٹ ورک (DNN) عمل درآمد۔آرگس: ان پٹ_ڈیم (انٹ): ان پٹ خصوصیات کی جہتself.hidded_units = hadded_units self.output_dim = آؤٹ پٹ_ڈیم سیلف۔ موڈل = سیلف۔= (self.input_dim ،))))"
    },
    {
        "Question": "ایک آٹورگریسی انٹیگریٹڈ موونگ اوسط (اے آر آئی ایم اے) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": ""
    },
    {
        "Question": "کلسٹرنگ کے لئے سیلف آرگنائزنگ میپ (SOM) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر طبقے کی ایک مثال ہے جو کلسٹرنگ کے لئے خود سے منظم نقشہ (SOM) الگورتھم کو نافذ کرتی ہے: Pythoncopy Codemport numpy as npclass سیلفورگنائزنگ میپ: Def __init __ (خود ، ان پٹ_ڈیم ، میپ_سائز): \"\" خود سے متعلق نگاری کا نقشہ (SOM) الگوریتھمکلسٹرنگ۔ آرگس: ان پٹ_ڈیم (انٹ): ان پٹ ڈیٹا کی جہتSOM وزن خود۔ wwights = np.random.rand.rand (Map_size [0] ، Map_size [1] ، ان پٹ_ڈیم) ڈیف ٹرین (خود ، x ، Epochs ، لرننگ_ریٹ = 0.1): \"\" \"دیئے گئے ان پٹ ڈیٹا پر SOM کو تربیت دیں۔آرگس:"
    },
    {
        "Question": "تکرار کی خصوصیت کے خاتمے کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دینے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!.یا پانڈاس.ڈیٹافریم: منتخب کردہ خصوصیات۔ \"\" \"تخمینہ لگانے والا = لکیری ریگریشن () # ایک لکیری ریگریشن ماڈل کا استعمال تخمینہ لگانے والا RFE = RFE (تخمینہ لگانے والا ، N_FEATURES_TO_SELECT) rfe.fit (X ، Y) منتخب_فیٹریچرز = RFE.Transfor (X) ریٹرنمنتخب کردہ_فیٹورین یہ"
    },
    {
        "Question": "بولٹزمان مشین الگورتھم کے لئے غیر سنجیدہ سیکھنے کے لئے ازگر کلاس کو نافذ کریں۔",
        "Answer": "اس کی کمپیوٹیشنل ضروریات اور پیچیدگیوں کی وجہ سے شروع سے بولٹزمان مشین الگورتھم کو عملی جامہ پہنانا ایک پیچیدہ کام ہے۔تاہم ، میں آپ کو بولٹزمان مشین اور اس کی تربیت الگورتھم کا جائزہ فراہم کرسکتا ہوں۔یہاں ایک اعلی سطحی تفصیل ہے: ایک بولٹزمان مشین ایک غیر منقولہ پیداواری پیداواری نیورل نیٹ ورک ماڈل ہے جو بائنری یونٹوں (نیوران) پر مشتمل ہے جو مرئی اور پوشیدہ پرتوں میں ترتیب دیا گیا ہے۔بولٹزمان مشین کا ہدف ان پٹ ڈیٹا کی بنیادی تقسیم سیکھنا ہے۔ یہاں ایک آسان تر ہے"
    },
    {
        "Question": "ترتیب کی پیش گوئی کے لئے طویل قلیل مدتی میموری (LSTM) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں تسلسل کی پیش گوئی کے ل long طویل قلیل مدتی میموری (LSTM) الگورتھم کا ایک آسان عمل یہ ہے: Pythoncopy Codimport numpy as npclass lstm: def __init __ (خود ، ان پٹ_سائز ، پوشیدہ_سائز ، آؤٹ پٹ_سائز): \"\" طویل مختصر مدت) ترتیب کی پیش گوئی کے لئے الگورتھم۔ آرگس: ان پٹ_سائز (INT): ان پٹ ترتیب کی جہت۔ پوشیدہ_سائز (INT): پوشیدہ پرت میں یونٹوں کی تعداد۔.hided_size = پوشیدہ_سائز سیلف۔ آؤٹ پٹ_سائز = آؤٹ پٹ_سائز # وزن اور تعصب کو شروع کریں۔= np.random.randn (ان پٹ_سائز + پوشیدہ_سائز ، پوشیدہ_سائز) سیلف۔ ڈبلیو سی = این پی. آرینڈوم.رینڈن (ان پٹ_سائز + پوشیدہ_سائز ، پوشیدہ_سائز) سیلف۔ ڈبلیو۔."
    },
    {
        "Question": "K-fold stratified کراس توثیق کا استعمال کرتے ہوئے ماڈل کی تشخیص کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو کے فولڈ اسٹریٹیفائڈ کراس توثیق کا استعمال کرتے ہوئے ماڈل کی تشخیص کرتا ہے: پیتھون کوپی کوڈفرم اسکلرن ۔موڈیل_ سلیکشن درآمد اسٹریٹائڈکفولڈ فریم اسکلن۔ماڈل کی تشخیص K-fold stratified کراس توثیق کا استعمال کرتے ہوئے۔ آرگس: ماڈل: تشخیص کرنے کے لئے ماڈل۔ x (numpy.ndarray): ان پٹ کی خصوصیات۔ y (numpy.ndarray): ہدف متغیرکراس توثیق کے لئے تقسیم۔ واپسی: ڈکٹ: ایک لغت جس میں تشخیص میٹرکس (درستگی ، صحت سے متعلق ، یاد) پر مشتمل ہے۔صحت سے متعلق ': [] ،' یاد ': []} ٹرین_ انڈیکس کے لئے ، skf.split (x ، y) میں ٹیسٹ_ انڈیکس: x_train ، x_test"
    },
    {
        "Question": "L1 ریگولرائزیشن کا استعمال کرتے ہوئے خصوصیت کے انتخاب کو انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو L1 باقاعدگی کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دیتا ہے: پائیٹون کوپی کوڈفرم اسکلرن۔ لائنر_موڈیل درآمد لاجسٹک ریگریشن ڈیف سلیکٹ_فیٹورز_ل 1 (x ، Y ، c = 1.0): \"\" \"L1 باقاعدگی کا استعمال کرتے ہوئے خصوصیت کا انتخاب کریں۔ args: x (numpy.ndarray)ان پٹ کی خصوصیات. y (numpy.ndarray): ہدف متغیر"
    },
    {
        "Question": "کمک سیکھنے کے لئے ڈیپ کیو نیٹ ورک (ڈی کیو این) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!ذیل میں کمک لرننگ کے لئے گہری Q-Network (DQN) الگورتھم کے لئے ایک ازگر کلاس کا نفاذ ہے: Pythoncopy Codemport randimport numpy کے طور پر NPFROM کلیکشن ڈیکوفرم ٹینسورفلو.کراس۔امپورٹ ایڈمکلاس dqn: def __init __ (خود ، state_size ، action_size ، gamma = 0.95 ، epsilon = 1.0 ، epsilon_decay = 0.995 ، epsilon_min = 0.01 ، لرننگ_ریٹ = 0.001)میکسلن = 2000)"
    },
    {
        "Question": "ٹائم سیریز کی پیش گوئی کرنے کے لئے ٹائم سیریز (ایس ٹی ایل) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ٹائم سیریز کی پیشن گوئی کرتے ہیں جو موسمی گلنا ٹائم سیریز (ایس ٹی ایل) کے طریقہ کار کا استعمال کرتے ہوئے پیش گوئی کرتے ہیں: پیتھون کوپی کوڈیمپورٹ نیمپی کو بطور این پیفرم اسٹٹسموڈلز۔ ٹی ایس اے۔ ایس ایونل امپورٹ ایس ٹی ایل ڈی ای ایف ایس ٹی ایل_فورکاسٹ (ٹائم_سیریز ، سیزنل_پیڈ ، فاریکاسٹ_پیڈس): \"\"ٹائم سیریز (ایس ٹی ایل) کا موسمی سڑن۔مستقبل میں پیش گوئی کرنے کے اقدامات۔ واپسی:"
    },
    {
        "Question": "K-nearrest پڑوسیوں (KNN) کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو K-nearest پڑوسیوں (KNN) الگورتھم کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرتا ہے: Pythoncopy Codemport numpy as npfrom Sklearn.impute درآمد knnimputerdef knn_imputation (ڈیٹاسیٹ ، کے = 5)K-nearrest پڑوسیوں کا استعمال کرتے ہوئے ڈیٹاسیٹ میں قدریں (k"
    },
    {
        "Question": "دو سیٹوں کے مابین جیکارڈ مماثلت کے گتانک کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو دو سیٹوں کے مابین جیکارڈ مماثلت کے گتانک کا حساب لگاتا ہے: پیتھون کوپی کوڈیڈف جیکارڈ_سمیریٹی (سیٹ 1 ، سیٹ 2): \"\" \"\" دو سیٹوں کے مابین جیکارڈ مماثلت کے گتانک کا حساب لگائیں۔: دوسرا سیٹ۔ واپسی: فلوٹ: جیکارڈ مماثلت کا گتانک۔{1 ، 2 ، 3 ، 4 ، 5} سیٹ 2 = {4 ، 5 ، 6 ، 7 ، 8"
    },
    {
        "Question": "امیج کی درجہ بندی کے لئے مجاز عصبی نیٹ ورک (CNN) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!ذیل میں امیج کی درجہ بندی کے لئے کنفیوئل نیورل نیٹ ورک (سی این این) الگورتھم کے لئے ایک ازگر کلاس کا نفاذ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم ٹینسورفلو.کراس.موڈلز درآمد ترتیب ترتیب"
    },
    {
        "Question": "تکرار کی خصوصیت کے اضافے کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دینے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو تکرار فیچر ایڈیشن (آر ایف اے) کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دیتا ہے: پیتھون کوپی کوڈفرم اسکلرن ۔فیٹور_ سلیکشن امپورٹ آر ایف ای سی ویففوم اسکلن۔ لائنر_موڈل درآمد لائنر ریگریشن ڈی ای ایف ریکارسیو_فوریو_فیٹیشن (ایکس ، وائی ، نمبر) کی خصوصیت کا اضافہ (ایکس ، وائی ، نمبر). آرگس: ایکس (سرنی کی طرح): ان پٹ کی خصوصیات\"تخمینہ لگانے والا = لکیری ریگریشن () # اپنے مطلوبہ تخمینے والے سلیکٹر = آر ایف ای سی وی (تخمینہ لگانے والا ، مرحلہ = 1 ، سی وی = 5) سلیکٹر.فٹ (ایکس ، وائی) منتخب کردہ سے تبدیل کریں"
    },
    {
        "Question": "جنریٹو ایڈورسیریل نیٹ ورک (GAN) الگورتھم کے لئے جنریٹو ماڈلنگ کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!ایڈمکلاس گان: ڈیف __init __ (خود ، ان پٹ_ڈیم ، جنریٹر_لیئرز ، امتیازی سلوک_لیئرز): سیلف۔ ان پٹ_ڈیم = ان پٹ_ڈیم سیلف۔ خود۔ خود.combined.compile (نقصان = 'بائنری_کراسینٹروپی' ، آپٹیمائزر = آدم ()) ڈیف _ بلڈ_جینریٹر (خود ، پرت): جنریٹر = ترتیب (ترتیب ()"
    },
    {
        "Question": "کفایت شعاری ہموار (ETS) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو کفایت شعاری کو استعمال کرتے ہوئے ٹائم سیریز کی پیش گوئی کرتا ہے (ETS) طریقہ: Pythoncopy Codimport numpy as npfrom statsmodels.tsa.holtwinters کی کارکردگی کا مظاہرہ کرتے ہوئےسیریز کی پیشن گوئی کرنے والی تیز رفتار ہموار (ETS) طریقہ کار کا استعمال کرتے ہوئے۔ آرگس: ٹائم_سیریز (سرنی کی طرح): ان پٹ ٹائم سیریز کا ڈیٹا۔ پیشن گوئی_ اسٹپس (INT): مستقبل میں پیش گوئی کرنے کے اقدامات کی تعداد۔ رجحان (STR): رجحان کی قسم: رجحان کی قسم: رجحان کی قسمجزو \"شامل کریں\" (اضافی) یا \"ہوسکتا ہے۔"
    },
    {
        "Question": "میٹرکس کی تکمیل کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "گمشدہ قیمت کے تضاد کے ل Mat میٹرکس کی تکمیل کو انجام دینے میں عام طور پر میٹرکس فیکٹرائزیشن تکنیک کا استعمال شامل ہوتا ہے۔میٹرکس کی تکمیل کے لئے ایک مقبول طریقہ واحد ویلیو سڑن (ایس وی ڈی) ہے۔یہاں ایک ازگر فنکشن ہے جو ایس وی ڈی کے ساتھ میٹرکس کی تکمیل کا استعمال کرتے ہوئے قیمت میں کمی کو انجام دیتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NPFROM numpy.linalg درآمد SVDDEF میٹرکس_کمپلیشن (ڈیٹا ، رینک = کوئی بھی نہیں)). آرگس: ڈیٹا (ndarray): گمشدہ اقدار کے ساتھ ان پٹ ڈیٹاسیٹ۔ رینک (INT): دوبارہ تعمیر شدہ میٹرکس کا درجہ۔ اگر کوئی نہیں تو ، یہ اعداد و شمار کی بنیاد پر خود بخود طے ہوجائے گا۔ واپسی: ndarray: imputed ڈیٹاسیٹ۔ \"\"\" # گمشدہ اقدار کی نشاندہی کریں"
    },
    {
        "Question": "ملٹی لیبل کی درجہ بندی کے لئے ہیمنگ نقصان کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ملٹی لیبل کی درجہ بندی کے لئے ہتھوڑے کے نقصان کا حساب لگاتا ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈیف ہیمنگ_لوس (Y_TRUE ، Y_PRED): \"\" \"ملٹی لیبل کی درجہ بندی کے لئے ہیمنگ نقصان کا حساب لگائیں۔سچے لیبل۔ Y_PRED (سرنی کی طرح): پیش گوئی شدہ لیبل۔ واپسی: فلوٹ: ہیمنگ نقصان۔."
    },
    {
        "Question": "کمک سیکھنے کے لئے اداکار تنقیدی الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!یہاں کمک سیکھنے کے لئے اداکار تنقیدی الگورتھم کے لئے ایک ازگر کلاس کا نفاذ ہے: پیتھونکپی کوڈیمپورٹ نیمپی کے طور پر اینپمپورٹ ٹینسورفلو کے طور پر ٹی ایف آروم ٹینسورفلو.کراس۔lr_actric = 0.001 ، lr_critic = 0.01 ، گاما = 0.99): self.state_dim = state_dim self.action_dim = action_dim self.lr_actr = lr_acter self.lr_critic = lr_critic self.gamma = gamma = gamma = gamma"
    },
    {
        "Question": "نبی لائبریری کا استعمال کرتے ہوئے ٹائم سیریز کی پیش گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو نبی لائبریری کا استعمال کرتے ہوئے ٹائم سیریز کی پیش گوئی کرتا ہے: پائیتھون کوپی کوڈفرم ایف بی پرو فوم امپورٹ پربویپیٹ پربویڈف نبی_فورکاسٹ (ٹائم_سیریز ، پیشن گوئی_ اسٹپس): \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" پیش گوئی کی پیش گوئی کو پیش گوئی کریں۔مطلوبہ نبی فارمیٹ میں۔ پیشن گوئی_ اسٹپس (INT): مستقبل میں پیش گوئی کرنے کے اقدامات کی تعداد۔ واپسی: ڈیٹا فریم: پیش گوئی کی گئی اقدار۔ڈیٹا ماڈل.فٹ (ٹائم_سیریز"
    },
    {
        "Question": "ارتباط پر مبنی خصوصیت کے انتخاب کا استعمال کرتے ہوئے خصوصیت کے انتخاب کو انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ارتباط پر مبنی خصوصیت کے انتخاب کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دیتا ہے: PDITHONCOPY کوڈیمپورٹ پانڈاس بطور Pdimport numpy بطور NPDEF ارتباط_فیٹور_ سلیکشن (ڈیٹا ، تھریشولڈ): \"\" \"ارتباط پر مبنی خصوصیت کا انتخاب استعمال کرتے ہوئے خصوصیت کا انتخاب کریں۔ آرگس: ڈیٹا (ڈیٹا فیم):ان پٹ ڈیٹاسیٹ۔ تھریشولڈ (فلوٹ): خصوصیات کو منتخب کرنے کے لئے ارتباط کی حد۔ واپسی: فہرست: منتخب کردہ خصوصیت کے نام۔"
    },
    {
        "Question": "دو سیٹوں کے مابین وزن والے جیکارڈ مماثلت کے گتانک کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہ ایک ازگر فنکشن ہے جو دو سیٹوں کے مابین وزن والے جیکارڈ مماثلت کے گتانک کا حساب لگاتا ہے: پائیتھون کوپی کوڈیڈف ویٹڈ_جاکارڈ_سیمریٹی (سیٹ 1 ، سیٹ 2 ، وزن): \"\" \"\" دو سیٹوں کے مابین وزن والے جیکارڈ مماثلت کے گتانک کا حساب لگائیں۔سیٹ. سیٹ 2 (سیٹ یا فہرست): دوسرا سیٹ۔ وزن (ڈکٹ): سیٹ میں ہر عنصر کے لئے وزن کی ایک لغت۔ واپسی:"
    },
    {
        "Question": "جنریٹو ماڈلنگ کے لئے متغیر آٹو اینکوڈر (VAE) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!جنریٹو ماڈلنگ کے لئے متغیر آٹو انکوڈر (VAE) الگورتھم کے لئے ایک ازگر کلاس کا نفاذ یہاں ہے: پائیٹون کوپی کوڈیمپورٹ ٹینسور فلو بطور Tffrom tensorflow.keras امپورٹ لیئرسکلاس Vae (tf.keras.model): Def __ __ __init __ (خود ، دیر سے)خود) .__ init __ ()"
    },
    {
        "Question": "طویل قلیل مدتی میموری (ایل ایس ٹی ایم) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو طویل قلیل مدتی میموری (ایل ایس ٹی ایم) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ایم پورٹ پانڈاس کے طور پر پی ڈی ایف آر او ایم ایس پی آر پروسیسنگ۔LSTM_FORECAST (ٹائم_سیریز ، پیشن گوئی_ اسٹپس ، لوک بیک بیک = 60 ، یونٹ = 50 ، ایپوچ = 100): \"\" \"طویل قلیل مدتی میموری (ایل ایس ٹی ایم) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کریں۔سیریز کا ڈیٹا۔"
    },
    {
        "Question": "متعدد تاثرات کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو ایک سے زیادہ نقائص کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرتا ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NPFROM SKLEREN.Experimental درآمد enable_iterative_imputerfrom Skarlen.impute امپورٹ ITERATIVEIMPUTERDEF ایک سے زیادہ_IMPUPTATION (ڈیٹا ، ITERATIONS = 10): \""
    },
    {
        "Question": "انٹر ریٹر معاہدے کے لئے کوہن کے کپا گتانک کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو بین ریٹر معاہدے کے لئے کوہن کے کاپا کے گتانک کا حساب لگاتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی ڈیف کوہین_کاپا_ کوفیفیٹ (مشاہدہ ، توقع): \"\" \"\" انٹر ریٹر معاہدے کے لئے کوہن کے کاپا کوپینٹ کا حساب لگائیں۔): مشاہدہ شدہ درجہ بندی یا درجہ بندی۔مشاہدہ کیا گیا) اگر آئنس اسٹینس (توقع ، فہرست): متوقع = NP.Array (متوقع) # مشاہدہ معاہدے کے معاہدے = NP.SUM (مشاہدہ == متوقع) کا حساب لگائیں # موقع کے معاہدے کا حساب لگائیں"
    },
    {
        "Question": "کمک سیکھنے کے لئے دنیاوی فرق (ٹی ڈی) الگورتھم کے لئے ایک ازگر کلاس نافذ کریں۔",
        "Answer": "یقینا!کمک سیکھنے کے لئے عارضی فرق (ٹی ڈی) الگورتھم کے لئے ایک ازگر کلاس کا نفاذ یہاں ہے: پیتھون کوپی کوڈکلاس ٹی ڈی: ڈیف __init __ (خود ، نمبر_سٹیٹس ، نمبر_ایکٹس ، الفا = 0.1 ، گاما = 0.9)num_actions"
    },
    {
        "Question": "ایکسجنجینس متغیر (اریمیکس) ماڈل کے ساتھ آٹورگریسی انٹیگریٹڈ مووینگ اوسط کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو آٹ کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرتا ہے"
    },
    {
        "Question": "ملٹی لیبل کی درجہ بندی کے لئے وزن والے ہیمنگ نقصان کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ملٹی لیبل کی درجہ بندی کے وزن کے ہتھوڑے کے نقصان کا حساب لگاتا ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈیف ویٹڈ_ہامنگ_لوس (Y_TRUE ، Y_PRED ، وزن = کوئی بھی نہیں): \"\" \"\" کثیر لیبل کی درجہ بندی کے وزن کے ہتھوڑے کے نقصان کا حساب لگائیں۔numpy.ndarray یا فہرست): سچے لیبل۔ Y_PRED (numpy.ndarray یا فہرست): پیش گوئی شدہ لیبل۔ وزن (numpy.ndarray یا فہرست ، اختیاری)وزن والے ہتھوڑے کے نقصان کا حساب کتاب۔ \"\" \""
    },
    {
        "Question": "غیر نگرانی شدہ سیکھنے کے لئے ڈیپ ڈائٹر نیٹ ورک (DBN) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ڈیپ پرٹون کلاس (ڈی بی این) کے لئے ایک ازگر کلاس کا نفاذ غیر منقولہ سیکھنے کے لئے الگورتھم: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر اینپم پورٹ ٹینسور فلو کے طور پر ٹفوم ٹینسر فلو۔ کراس امپورٹ لیئرسکلاس ڈی بی این: ڈیف __ انیٹ __ (خود ، نمبر ، ہڈین __ (خود ، نمبر ، ہڈین)گہری عقیدے کا نیٹ ورک۔ آرگس: NUM_VISIBLE (INT): مرئی یونٹوں کی تعداد۔ پوشیدہ_لیئرز (فہرست): ہر پرت میں پوشیدہ اکائیوں کی تعداد کی نمائندگی کرنے والے عدد کی فہرست۔ واپسی: کوئی بھی نہیں \"\" خود۔"
    },
    {
        "Question": "ویکٹر آٹورگریشن (VAR) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ویکٹر آٹورگریشن (VAR) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرتا ہے: PDFROM STASMODELS.tsa.api درآمد وردف ور_فوریکاسٹ (ڈیٹا ، پیشن گوئی ، وقت کی سیریز) کے طور پر این پی ایمپورٹ پانڈاس کے طور پر پائیتھون کوپی کوڈیمپورٹ نیمپی کوآٹوریگریشن (var) ماڈل۔ آرگس: ڈیٹا (پانڈاس.ڈیٹا فیم): ان پٹ ٹائم سیریز کا ڈیٹا۔ ہر کالم ایک متغیر کی نمائندگی کرتا ہے۔ پیشن گوئی_ اسٹپس (INT): مستقبل میں پیش گوئی کرنے کے اقدامات کی تعداداقدار۔ \"\" \" # چیک کریں کہ آیا ان پٹ ڈیٹا ایک ڈیٹا فریم ہے اور اسے کسی نپی سرنی میں تبدیل کریں"
    },
    {
        "Question": "رجعت پسندی کی خرابی کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو رجعت پسندی کے استعمال کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرتا ہے: پیڈھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ایم پورٹ پانڈاس کے طور پر PDFROMPORT.LINER_MODEL درآمد لائنر ریگریشن ریگریشن_مپٹیشن (ڈیٹا): \"\" گمشدہ اقدار کا استعمال کریں۔آرگس: ڈیٹا (پانڈاس.ڈیٹافریم): ان پٹ ڈیٹاسیٹ۔ ریٹرنس: پانڈاس.ڈیٹافریم: دیئے گئے ڈیٹاسیٹ۔ \"\" \" # چیک کریں کہ آیا ان پٹ ڈیٹا ڈیٹا فریم ہے یا نہیں"
    },
    {
        "Question": "انٹر ریٹر معاہدے کے لئے کریپینڈورف کے الفا گتانک کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو انٹر ریٹر معاہدے کے لئے کرپینڈورف کے الفا گتانک کا حساب لگاتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کرپینڈورف_الفا (ڈیٹا ، لیول_ف_میزورمنٹ ، ویلیو_کونٹس = کوئی بھی نہیں): \"\" کریپینڈورف کے الفا کوٹ کے لئے \"\" \"کا حساب کتاب کریں۔numpy.ndarray یا فہرست): 2D سرنی یا فہرست کے طور پر ان پٹ ڈیٹا ، جہاں ہر قطار ایک مختلف شے/مشاہدے کی نمائندگی کرتی ہے اور ہر کالم ایک مختلف راٹر کی نمائندگی کرتا ہے۔ سطح_ف_میسورمنٹ (ایس ٹی آر): اعداد و شمار کی پیمائش کی سطح۔ درست اختیارات ہیں۔ درست اختیارات ہیں۔'برائے نام' ، 'آرڈینل' ، یا 'وقفہ'۔ ویلیو_کونٹ (فہرست ، اختیاری): ہر کالم کے لئے الگ الگ اقدار کی تعداد۔ پیمائش کی برائے نام اور عام سطح کے لئے درکار۔ پہلے سے طے شدہ کوئی نہیں ہے۔"
    },
    {
        "Question": "کمک سیکھنے کے لئے مونٹی کارلو ٹری سرچ (ایم سی ٹی ایس) الگورتھم کے لئے ایک ازگر کلاس نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو مونٹی کارلو ٹری سرچ (ایم سی ٹی ایس) الگورتھم کو کمک سیکھنے کے لئے نافذ کرتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی سی ایل اے ایس نوڈ: ڈیف __INIT __ (خود ، ریاست ، والدین = کوئی نہیں): سیلف۔ اسٹیٹ = اسٹیٹ سیلف۔ سیلف۔ والدین = والدین۔بچے = [] self.visits = 0 self.wins = 0 کلاس mcts: def __init __ (خود ، num_simulations ، ایکسپلوریشن_کونسٹنٹ): self.num_simulations"
    },
    {
        "Question": "گاوسی پروسیس ریگریشن (جی پی آر) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو گاوسی پروسیس ریگریشن (جی پی آر) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیش گوئی کرتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفوملن۔ گوسی_پروسیس امپورٹ گوسی پروسیسریسروسٹرن۔ وقت انجام دیںگاوسی پروسیس ریگریشن (جی پی آر) کا استعمال کرتے ہوئے سیریز کی پیش گوئیٹیسٹ سیٹ کی ان پٹ خصوصیات۔ واپسی: numpy.ndarray: ٹیسٹ سیٹ کے لئے پیش گوئی شدہ اقدار"
    },
    {
        "Question": "درختوں پر مبنی خصوصیت کی اہمیت کا استعمال کرتے ہوئے خصوصیت کے انتخاب کو انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو درخت پر مبنی خصوصیت کی اہمیت کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دیتا ہے: پائیتھون کوپی کوڈفرم اسکلرن۔بنیاد پر خصوصیت کی اہمیت۔اختیارات 'درجہ بندی' یا 'رجعت' ہیں۔ پہلے سے طے شدہ 'درجہ بندی' ہے۔ num_features (INT ، اختیاری): منتخب کرنے کے لئے اعلی خصوصیات کی تعداد۔ اگر کوئی نہیں تو ، تمام خصوصیات واپس کردی جائیں گی۔ پہلے سے نہیں ہے۔ واپس"
    },
    {
        "Question": "ملٹی کلاس کی درجہ بندی کے لئے ملٹی کلاس لاگ-لاس کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ملٹی کلاس کی درجہ بندی کے لئے ملٹی کلاس لاگ-لاس کا حساب لگاتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NPFROM MATH درآمد لاگ ڈیف ملٹی کلاس_لوگ_لوس (Y_TRUE ، Y_PRED ، EPS = 1E-15): \"\" \"\" \"\" حساب کتاب کریں اس کا حساب لگائیں۔"
    },
    {
        "Question": "بار بار نیورل نیٹ ورک (RNN) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو بار بار نیورل نیٹ ورک (آر این این) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی آئی ایمپورٹ ٹینسور فلو کے طور پر tfdef rnn_time_series_forecasting (ڈیٹا ، ونڈو_سائز ، num_units = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، namets = 64 ، numets = 64 ، num_units = 64 ، num_units = 64 ، num_units = 64 ، num_units = 64 ، num_units = 64 ، num_units = 24\"\" \"بار بار نیورل نیٹ ورک (آر این این) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کریں۔، اختیاری): ہر RNN پرت میں یونٹوں کی تعداد۔ پہلے سے طے شدہ 64. num_layers (INT ، اختیاری): RNN پرتوں کی تعداد۔ پہلے سے طے شدہ 2. NUM_EPOCHS (INT ، اختیاری): تربیت کے عہدوں کی تعداد ہے۔ پہلے سے طے شدہ ہے۔"
    },
    {
        "Question": "انٹر ریٹر معاہدے کے لئے فلیس کے کپا کے گتانک کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو اس کا حساب لگاتا ہے"
    },
    {
        "Question": "اصلاح کے مسائل کے لئے ارتقائی الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!: فٹنس فنکشن کو بہتر بنایا جائے۔ num_variables (INT): مسئلے میں متغیرات یا طول و عرض کی تعداد۔: ہر متغیر کے لئے تغیر کا امکان۔"
    },
    {
        "Question": "موسمی آٹورگریسی انٹیگریٹڈ موونگ اوسط (SARIMA) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو موسمی آٹورگریسی انٹیگریٹڈ موونگ اوسط (سریما) ماڈل کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرتا ہے: پیڈون کوپی کوڈیمپورٹ پانڈاس کو بطور پیڈیمپورٹ اسٹیٹموڈلز۔ اے پی آئی ایس ایس ڈی ای ایف سریما_فورکاسٹ (ڈیٹا ، آرڈر ، موسمی_آرڈینتھ ، پیش گوئی وقت) کے طور پر استعمال کرتے ہیں۔موسمی طور پر آٹورجریج انٹیگریٹڈ موونگ اوسط (سریما) ماڈل۔ آرگس: ڈیٹا (پانڈاس.سیریز): ان پٹ ٹائم سیریز کا ڈیٹا۔ آرڈر (ٹیوپل): ساریما ماڈل (پی ، ڈی ، کیو) کے غیر موسمی جزو کا آرڈر (پی ، ڈی ، کیو). موسمی_اڈر (ٹپل): سریما ماڈل کے موسمی جزو کا حکم"
    },
    {
        "Question": "جینیاتی الگورتھم کا استعمال کرتے ہوئے خصوصیت کے انتخاب کو انجام دینے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو جینیاتی الگورتھم کا استعمال کرتے ہوئے خصوصیت کا انتخاب انجام دیتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکلن ۔موڈیل_ سلیکشن درآمد ٹرین_ٹیسٹ_سپلٹفرم اسکلرین_مودل امپورٹ لاجسٹک ریگریشنکلاس جینیٹیکل گورٹچرلیکشن: ڈیف __ انٹیٹل گورٹیشن: ڈیف __ شرح): \"\" \"جینیٹیکل گوریتھمفیچرلیکشن کلاس شروع کریں. آرگس: NUM_FEATURES (INT): ڈیٹاسیٹ میں خصوصیات کی کل تعداد۔ہر خصوصیت"
    },
    {
        "Question": "ملٹی کلاس کی درجہ بندی کے لئے ملٹی کلاس F1 اسکور کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ملٹی کلاس F1 اسکور کا حساب ملٹی کلاس کی درجہ بندی کے لئے حساب کرتا ہے: پائیتھون کوپی کوڈفرم اسکیلین۔ میٹرکس درآمد F1_SCOREDEF ملٹی کلاس_ف 1_ سکور (Y_True ، Y_PRED): \"\" \"\" \"\" \"\" ملٹی کلاس F1 اسکور کے لئے ملٹی کلاس F1 اسکور کا حساب لگائیں۔سچے لیبل۔ Y_PRED (سرنی کی طرح): پیش گوئی شدہ لیبل۔ واپسی: فلوٹ: ملٹی کلاس F1 اسکور۔اگر لین (سیٹ (Y_True))! = لین (سیٹ (Y_PRED)): Y_TRUE اور Y_PRED میں لیبل ایک جیسے ہیں!'وزن والے' اوسط آپشن کا استعمال"
    },
    {
        "Question": "غیر منقولہ سیکھنے کے لئے ویرل کوڈنگ الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو غیر منقولہ تعلیم کے لئے ویرل کوڈنگ الگورتھم کو نافذ کرتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NPFROM SKLEREN.DECPOSISON درآمد لغت کی تعلیم کی درآمد DICTIONARYLEARNCLASS سپارسیکوڈنگ: DEF __INIT __ (spectiar ، n_Components = 2 ، الفا = 1 ، میکس_ میکس = 1 ، میکس = 1 ، میکس = 1 ، میکس = 1)کلاس. آرگس: N_COMPONENTS (INT): سیکھنے کے لئے اجزاء (لغت کے جوہری) کی تعداد۔"
    },
    {
        "Question": "تیز رفتار ہموار کرنے والے اسٹیٹ اسپیس ماڈل (ETS) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیشن گوئی کرنے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو تیز رفتار ہموار کرنے والے اسٹیٹ اسپیس ماڈل (ETS) کے طریقہ کار کا استعمال کرتے ہوئے ٹائم سیریز کی پیش گوئی کرتا ہے: PDITHONCOPY CODYMPORT NUMPY بطور NPimport Pandas pdfrom statsmodels.tsa.holtwinters درآمد ایکسپونیشینشنل سنسموتھنگ ڈیف پیش گوئی کی پیش کش (ڈیٹا ، forecats_st_st_stet_stet_stet_stet_stet_st_st_st_st_st_st_st_st_st_st_st_st_stet_stet_stet_stet_stet_st_stet_stet_stet_steps (forecats_st_st_st_steps ، forecast_st_stet_stet_steps (forecats_st_steps)تیز رفتار ہموار کرنے والے اسٹیٹ اسپیس ماڈل (ETS) کے طریقہ کار کا استعمال کرتے ہوئے۔ آرگس: ڈیٹا (numpy.ndarray یا pandas.series): ٹائم سیریز کا ڈیٹا۔ پیشن گوئی_ اسٹپس (INT): مستقبل میں پیش گوئی کرنے کے لئے وقت کی تعداد کی تعداد۔ واپسی: پانڈاس۔سیریز: پیش گوئی شدہ اقدار۔"
    },
    {
        "Question": "زنجیروں کی مساوات (چوہوں) کے ذریعہ ایک سے زیادہ استثنیٰ کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کو ختم کرنے کے لئے ایک ازگر فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو زنجیروں کی مساوات (چوہوں) کے ذریعہ ایک سے زیادہ استثنیٰ کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کی تزئین و آرائش کو انجام دیتا ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی آئی ایمپورٹ پانڈاس پی ڈی ایف آر اسکلرن۔زنجیروں کی مساوات (چوہوں) کے طریقہ کار کے ذریعہ متعدد نقائص کا استعمال کرتے ہوئے ڈیٹاسیٹ میں گمشدہ اقدار کی تسلی۔ویلی ایرر: اگر ان پٹ ڈیٹا پانڈاس ڈیٹا فریم نہیں ہے۔"
    },
    {
        "Question": "فلیس کے کاپا گتانک کا استعمال کرتے ہوئے بین الاقوامی معاہدے کا حساب لگانے کے لئے ایک ازگر فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو فلیس کے کاپا کے گتانک کا استعمال کرتے ہوئے بین السطور معاہدے کا حساب لگاتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پیفرم اسکیپی۔ڈیٹا (numpy.ndarray): ان پٹ ڈیٹا میٹرکس جہاں ہر قطار کسی شے کی نمائندگی کرتی ہے اور ہر کالم ایک تشریح کی نمائندگی کرتا ہے۔ میٹرکس میں ہر عنصر تفویض کردہ لیبل کی نمائندگی کرتا ہے"
    },
    {
        "Question": "اصلاح کے مسائل کے لئے ذرہ بھیڑ آپٹیمائزیشن (PSO) الگورتھم کے لئے ایک ازگر کلاس کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو اصلاح کے مسائل کے لئے ذرہ بھیڑ آپٹیمائزیشن (PSO) الگورتھم کو نافذ کرتی ہے: Pythoncopy Codemport numpy بطور NPClass ذرات وراپٹیمائزر: Def __init __ (خود ، مقصد_فونکشن ، N_Particles ، N_Dimensions ، Binders ، Binds ، Binds ، Binders ، Binders ، Binds ، Max_iter ،"
    }
]