[
    {
        "Question": "numpy",
        "Answer": "نوم (عددی ازگر) ایک مشہور ازگر لائبریری ہے جو ان صفوں پر موثر انداز میں کام کرنے کے لئے ریاضی کے افعال کی ایک وسیع رینج کے ساتھ ساتھ بڑی ، کثیر جہتی صفوں اور میٹرک کے لئے مدد فراہم کرتی ہے۔یہ ازگر کے ساتھ سائنسی کمپیوٹنگ کے لئے ایک بنیادی پیکیج ہے۔ یہاں کچھ کلیدی خصوصیات اور فنکشنلیاں ہیں جو نمی کے ذریعہ فراہم کی گئیں: کثیر جہتی سرنی آبجیکٹ: نمی کی مرکزی خصوصیت NDARAY ہے (N"
    },
    {
        "Question": "0 سے 9 تک کی اقدار کے ساتھ ایک نپی سرنی بنائیں۔",
        "Answer": "یقینا!یہاں 0 سے 9 تک کی اقدار کے ساتھ ایک نپی سرنی بنانے کی ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.arang، ہم نپی لائبریری درآمد کرتے ہیں اور 0 سے 9 تک اقدار کے ساتھ ایک صف بنانے کے لئے ارینج () فنکشن کا استعمال کرتے ہیں۔ ارینج () فنکشن مخصوص رینج کی بنیاد پر نمبروں کی ترتیب پیدا کرتا ہے ، جو بلٹ ان رینج () فنکشن کی طرح ہے۔ازگر میںآخر میں ، ہم دیکھنے کے لئے صف پرنٹ کرتے ہیں"
    },
    {
        "Question": "0 اور 1 کے درمیان 10 یکساں طور پر فاصلہ والی اقدار کے ساتھ ایک 1D numpy صف بنائیں۔",
        "Answer": "یقینا!یہاں 0 اور 1 کے درمیان 10 یکساں طور پر فاصلہ والی اقدار کے ساتھ 1D نیپی سرنی بنانے کی ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.linspace (0 ، 1 ، 10) پرنٹ (سرنی) آؤٹ پٹ: کاپی کوڈ [0۔0.11111111 0.222222222 0.333333333 0.44444444444 0.55555556 0.66666667 0.777"
    },
    {
        "Question": "ایک 3x3 numpy سرنی بنائیں اور اسے 1D صف میں تبدیل کریں۔",
        "Answer": "یقینا!یہاں ایک 3x3 numpy سرنی بنانے اور اسے 1D سرنی میں تبدیل کرنے کی ایک مثال ہے: Pythoncopy Codimport numpy As NP# ایک 3x3 arrayarray_2d = np.array بنائیں ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [[[1 ، 2 ، 3] ، [4 ، 5 ، 6]7 ، 8 ، 9]]]# سرنی کو 1d arrayarray_1d = array_2d.flatten () پرنٹ (\"اصل 2 ڈی سرنی:\") پرنٹ (array_2d) پرنٹ (\"\\ nreshaped 1d سرنی:\") پرنٹ (سرنی_1d) آؤٹ پٹ: لیس کوپی کوڈورجینل 2 ڈی سرنی: [[1 2 3] [4 5 6] ["
    },
    {
        "Question": "ایک نپی سرنی میں زیادہ سے زیادہ قیمت تلاش کریں۔",
        "Answer": "ایک نپی سرنی میں زیادہ سے زیادہ قیمت تلاش کرنے کے ل you ، آپ زیادہ سے زیادہ () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) میکس_ ویلیو = np.max (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"زیادہ سے زیادہ قیمت): \"، میکس_ ویلیو) آؤٹ پٹ: یامل کوپی کوڈرری: [4 2 9 5 1 7] زیادہ سے زیادہ قیمت: 9"
    },
    {
        "Question": "ایک نپی سرنی میں کم سے کم قیمت تلاش کریں۔",
        "Answer": "ایک نپی سرنی میں کم سے کم قیمت تلاش کرنے کے ل you ، آپ کم سے کم () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) Min_value = np.min (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"کم سے کم قیمت): \"، MIN_VALUE) آؤٹ پٹ: YAMLCOPY CODEARRAY: [4 2 9 5 1 7] کم سے کم قیمت: 1 اس کوڈ میں ، ہم پہلے سرے کے نام سے ایک نپی سرنی بناتے ہیں۔اس کے بعد ، ہم صف میں کم سے کم قیمت تلاش کرنے کے لئے NP.MIN () فنکشن کا استعمال کرتے ہیں۔NP.MIN () فنکشن صف میں موجود کم سے کم قیمت لوٹاتا ہے۔آخر ، ہم"
    },
    {
        "Question": "ایک numpy صف کے وسط کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کے وسط (اوسط) کا حساب لگانے کے ل you ، آپ وسط () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) مینی_ ویلیو = np.mean (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"مطلب:\" مطلب:\"، مینی_ ویلیو) آؤٹ پٹ: میک فیلیکوپی کوڈرری: [4 2 9 5 1 7] مطلب: 4.6666666666666667 اس کوڈ میں ، ہم پہلے ایک نپی سرنی بناتے ہیں جسے سرنی کہتے ہیں۔اس کے بعد ، ہم اوسط قدر کا حساب لگانے کے لئے NP.Mean () فنکشن کا استعمال کرتے ہیں"
    },
    {
        "Question": "ایک نمی سرنی کے معیاری انحراف کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے معیاری انحراف کا حساب لگانے کے لئے ، آپ ایس ٹی ڈی () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) std_value = np.std (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"معیاری انحراف."
    },
    {
        "Question": "ایک numpy صف کے تغیر کا حساب لگائیں۔",
        "Answer": "ایک numpy صف کے تغیر کا حساب لگانے کے لئے ، آپ VAR () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) متغیر_اولیو = np.var (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"تغیر:\" تغیر: \"تغیر:\" تغیر:\"، متغیر_ ویلیو) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [4 2 9 5 1 7"
    },
    {
        "Question": "ایک نمی سرنی کے عناصر کا خلاصہ۔",
        "Answer": "ایک نمی سرنی کے عناصر کا خلاصہ کرنے کے ل you ، آپ رقم () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) sum_value = np.sum (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"رقم:\" رقم:\"، SUM_VALUE) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [4 2 9 5 1 7] خلاصہ: 28 اس کوڈ میں ، ہم پہلے سرے کے نام سے ایک نپی سرنی بناتے ہیں۔اس کے بعد ، ہم صف میں عناصر کے جوڑے کا حساب لگانے کے لئے NP.SUM () فنکشن کا استعمال کرتے ہیں۔NP.SUM () فنکشن صف میں تمام اقدار کو شامل کرتا ہے اور واپسی کرتا ہے"
    },
    {
        "Question": "دو numpy صفوں کے ڈاٹ پروڈکٹ کا حساب لگائیں۔",
        "Answer": "دو numpy صفوں کے ڈاٹ پروڈکٹ کا حساب لگانے کے ل you ، آپ ڈاٹ () فنکشن یا @ آپریٹر استعمال کرسکتے ہیں۔دونوں طریقوں کا استعمال کرتے ہوئے ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ numpy as nparray1 = np"
    },
    {
        "Question": "ایک نپی سرنی میں عناصر کے آرڈر کو الٹ دیں۔",
        "Answer": "ایک نپی سرنی میں عناصر کے ترتیب کو پلٹانے کے ل you ، آپ انڈیکسنگ کو [::-1] اشارے کے ساتھ استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]]) الٹ_رای = سرنی [::-1] پرنٹ (\"اصل سرنی:\" ، سرنی) پرنٹ (\"سرنی) پرنٹ (\" الٹ سرنی): \"،"
    },
    {
        "Question": "چڑھائی ترتیب میں ایک نمی سرنی کو ترتیب دیں۔",
        "Answer": "چڑھائی ترتیب میں ایک نمی سرنی کو ترتیب دینے کے ل you ، آپ ترتیب () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) ترتیب شدہ_رای = np.sort (سرنی) پرنٹ (\"اصل سرنی:\" ، سرنی) پرنٹ (\"چھانٹے ہوئے)سرنی: \"، چھانٹے ہوئے_آرے) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈوریجینل سرنی: [4 2 9 5 1 7] ترتیب شدہ سرنی: [1 2 4 5 7 9]` `` `"
    },
    {
        "Question": "کم سے کم قیمت کے اشارے ایک نمی سرنی میں تلاش کریں۔",
        "Answer": "کم سے کم قیمت کے اشاریے کو کسی نمی سرنی میں تلاش کرنے کے ل you ، آپ ارگمین () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) من_ انڈیکس = np.argmin (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اشاریہ کا اشاریہکم سے کم قیمت: \"، MIN_INDEX) آؤٹ پٹ: ریاضی کاپی کوڈرری: [4 2 9 5 1 7] کم سے کم قیمت کا اشاریہ: 4 اس کوڈ میں ، ہم سرنی کے نام سے ایک نمی سرنی بناتے ہیں۔اس کے بعد ہم تلاش کرنے کے لئے NP.argmin () فنکشن کا استعمال کرتے ہیں"
    },
    {
        "Question": "نمی سرنی میں انوکھی اقدار تلاش کریں۔",
        "Answer": "ایک نپی سرنی میں انوکھی اقدار کو تلاش کرنے کے ل you ، آپ NP.Unique () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[2 ، 1 ، 3 ، 2 ، 3 ، 1 ، 4 ، 5 ، 4 ، 4]) منفرد_اولیوس = np.unique (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"منفرد اقدار:\" ، منفرد_اولیوز) آؤٹ پٹ: ریاضی کاپی کوڈرری: [2 1 3 2 3 1 4 5 4] انوکھی اقدار: [1 2 3 4 5] اس کوڈ میں ، ہم ایک نمی سرنی تخلیق کرتے ہیں جسے `سرنی کہتے ہیں۔"
    },
    {
        "Question": "ہر ایک منفرد قدر کے واقعات کی تعداد کو ایک نمی صف میں گنیں۔",
        "Answer": "ایک نمی سرنی میں ہر منفرد قدر کے واقعات کی تعداد کو گننے کے ل you ، آپ NP.unique () فنکشن کو ریٹرن_کونٹ = سچے پیرامیٹر کے ساتھ استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[2 ، 1 ، 3 ، 2 ، 3 ، 1 ، 4 ، 5 ، 4]) منفرد_اولیوس ، گنتی = np.unique (صف ، ریٹرن_کاؤنٹ = سچ) پرنٹ (پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"منفرد اقدار:\" ، منفرد_والیوز) پرنٹ (\"گنتی:\" ، گنتی) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [2 1"
    },
    {
        "Question": "تمام منفی اقدار کو ایک numpy صف میں صفر سے تبدیل کریں۔",
        "Answer": "تمام منفی اقدار کو ایک نمی سرنی میں صفر کے ساتھ تبدیل کرنے کے ل you ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([ -2 ، 3 ، -5 ، 1 ، -4 ، 6]) سرنی_نون_نیگیٹیو = np.where (سرنی <0 ، 0 ، سرنی) پرنٹ (\"اصل سرنی) پرنٹ (\" اصل سرنی)."
    },
    {
        "Question": "عنصر کے لحاظ سے دو numpy صفوں کو شامل کریں۔",
        "Answer": "عنصر کے لحاظ سے دو numpy صفوں کو شامل کرنے کے ل you ، آپ آسانی سے + آپریٹر استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6]) نتیجہ = array1 + array2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر وار رقم:\" ، نتیجہ) آؤٹ پٹ"
    },
    {
        "Question": "ایک نمی سرنی کو دوسرے عنصر کے لحاظ سے گھٹائیں۔",
        "Answer": "کسی دوسرے عنصر کے لحاظ سے ایک نمی سرنی کو گھٹا دینے کے ل you ، آپ - آپریٹر استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ numpy as nparray1 = np.array ([4 ، 6 ، 8]) array2 = np.array ([1 ، 3 ، 5]) نتیجہ = array1 - array2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر کے مطابق گھٹاؤ:\" ، نتیجہ) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری 1: [4 6 8] سرنی 2: [1 3 5] عنصر کے مطابق گھٹاؤ: [3 3 3 3 3] ``"
    },
    {
        "Question": "ایک نمی سرنی کو دوسرے عنصر کے لحاظ سے تقسیم کریں۔",
        "Answer": "ایک نمی سرنی کو دوسرے عنصر کے لحاظ سے تقسیم کرنے کے ل you ، آپ / آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([10 ، 15 ، 20]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = array1 / arry2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر وار ڈویژن:\" ، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈرری 1: [10 15 20] سرنی 2: [2 3 4] عنصر کے مطابق تقسیم: [5۔5. 5.] اس کوڈ میں ، ہم"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق مربع جڑ کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے عنصر وار مربع جڑ کا حساب لگانے کے ل you ، آپ NP.SQRT () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 9 ، 16]) نتیجہ = np.sqrt (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر کے مطابق مربع جڑ:\" ، \"،\" ، \"نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [4 9 16] عنصر کے مطابق مربع جڑ: [2۔3. 4.] ``"
    },
    {
        "Question": "ایک نپی سرنی کے عنصر کے مطابق لوگرتھم (بیس 10) کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کے عنصر کے مطابق لوگرتھم (بیس 10) کا حساب لگانے کے ل you ، آپ NP.log10 () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 10 ، 100]) نتیجہ = np.log10 (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر کے مطابق لوگرتھم (بیس 10): \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 10 100] عنصر کے مطابق لوگرتھم (بیس 10): [0۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے حساب سے حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق سائن کا حساب لگانے کے ل you ، آپ NP.SIN () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([0 ، np.pi/2 ، np.pi]) نتیجہ = np.sin (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر-عقلمند سائن: \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [0۔1.57079633 3.14159265] عنصر کے مطابق سائن: [0.00000000E+00 1.00000000E+00 1.224"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق کوسائن کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے عنصر وار کوسائن کا حساب لگانے کے ل you ، آپ NP.COS () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([0 ، np.pi/2 ، np.pi]) نتیجہ = np.cos (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر-عقلمند کوسائن: \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [0۔1.57079633 3.14159265] عنصر کے مطابق کوسائن: [1.000000E+00 6.123234E-17"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق ٹینجنٹ کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق ٹینجینٹ کا حساب لگانے کے ل you ، آپ NP.TAN () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([0 ، np.pi/4 ، np.pi/2]) نتیجہ = np.tan (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"عنصر کے مطابق ٹینجینٹ: \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [0۔0.78539816 1.57079633] عنصر کے مطابق ٹینجینٹ: [0.00000000E+00 1.00000000E+00 1.63312394E+16] اس کوڈ میں ، ہم ایک نام کی سرنی کرتے ہیں جس کے ساتھ سرے کہتے ہیں"
    },
    {
        "Question": "4 قطاروں اور 5 کالموں کے ساتھ 2D سرنی میں 1D numpy سرنی کو نئی شکل دیں۔",
        "Answer": "4 قطاروں اور 5 کالموں کے ساتھ 2D سرنی میں 1D numpy سرنی کو نئی شکل دینے کے ل you ، آپ NP.reshape () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray_1d = np.array ([1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، 10 ، 11 ، 12 ، 13 ، 14 ، 15 ، 16 ، 17 ، 18 ، 18."
    },
    {
        "Question": "اخترن عناصر کو 2D numpy صف سے نکالیں۔",
        "Answer": "2D numpy صف سے اخترن عناصر کو نکالنے کے ل you ، آپ NP.Diagonal () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray_2d = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]]) ڈایگونل_لیمنٹس = این پی ڈیاگونل (سرنی_2 ڈی) پرنٹ (پرنٹ (\"اصل 2 ڈی سرنی:\") پرنٹ (سرنی_2 ڈی) پرنٹ (\"\\ ndiagonal عناصر:\") پرنٹ (ڈایگونل_لیمنٹس) آؤٹ پٹ: Luacopy کوڈورجینل 2 ڈی سرنی: [[1 2 3] [4 5 6] [7 8 9]] اخترن"
    },
    {
        "Question": "ایک نپی سرنی کی شکل حاصل کریں۔",
        "Answer": "ایک نپی سرنی کی شکل حاصل کرنے کے ل you ، آپ .shape وصف استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) شکل = سرنی.شپ پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"\\ nshape: \"، شکل) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [[1 2 3] ["
    },
    {
        "Question": "ایک نمی سرنی کے طول و عرض کی تعداد حاصل کریں۔",
        "Answer": "ایک نمی سرنی کے طول و عرض کی تعداد حاصل کرنے کے ل you ، آپ .ndim وصف استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) num_dimensions = array.ndimprint (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"پرنٹ (\"time n طول و عرض کی تعداد: \"، num_dimensions) آؤٹ پٹ: Luacopy CodeArray: [[1 2 3] [4 5 6]] طول و عرض کی تعداد: 2 اس کوڈ میں ، ہم طول و عرض 2x3 کے ساتھ سرنی نامی ایک 2d numpy سرنی بناتے ہیں۔اس کے بعد ہم رسائی حاصل کرتے ہیں"
    },
    {
        "Question": "ایک نپی سرنی میں عناصر کی ڈیٹا کی قسم حاصل کریں۔",
        "Answer": "اعداد و شمار کی قسم کے عناصر کو ایک نمی سرنی میں حاصل کرنے کے ل you ، آپ .dtype وصف کو استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) dtype = array.dtypeprint (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ ndata قسم:\" ، ،DTYPE) آؤٹ پٹ: YAMLCOPY CODEARRAY: [1 2 3 4 4 5] ڈیٹا کی قسم: INT64 اس کوڈ میں ، ہم عناصر کے ساتھ سرنی نامی ایک 1D numpy صف تیار کرتے ہیں `[1 ، 2 ، 3 ، 4"
    },
    {
        "Question": "عمودی طور پر دو numpy صفوں کو جوڑیں۔",
        "Answer": "عمودی طور پر (قطاروں کے ساتھ ساتھ) دو نپی سرنیوں کو جوڑنے کے ل you ، آپ NP.vstack () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) سرنی 2 = np.array ([[7 ، 8 ، 9] ، [10 ، [10 ،11 ، 12]]) نتیجہ = np.vstack ((array1 ، array2)) پرنٹ (\"سرنی 1:\") پرنٹ (سرنی 1) پرنٹ (\"\\ نارتھ 2:\") پرنٹ (array2) پرنٹ (\"\\ nconcated سرنی:\") پرنٹ (نتیجہ) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری 1: [[1"
    },
    {
        "Question": "عمودی طور پر ایک سے زیادہ ذیلی اریوں میں ایک نمی سرنی کو تقسیم کریں۔",
        "Answer": "عمودی طور پر (قطاروں کے ساتھ ساتھ) ایک سے زیادہ ذیلی اریوں میں ایک نمی سرنی کو تقسیم کرنے کے ل you ، آپ NP.vsplit () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3 ، 4] ، [5 ، 6 ، 7 ، 8] ، [9 ، 10 ، 11 ، 12]] سب_ریز"
    },
    {
        "Question": "افقی طور پر ایک سے زیادہ ذیلی اریوں میں ایک نمی سرنی کو تقسیم کریں۔",
        "Answer": "افقی طور پر (کالموں کے ساتھ ساتھ) ایک سے زیادہ ذیلی اریوں میں ایک نمی سرنی کو تقسیم کرنے کے ل you ، آپ NP.HSplit () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3 ، 4] ، [5 ، 6 ، 7 ، 8] ، [9 ، 10 ، 11 ، 12]]) sub_arrays = np.Hsplit (سرنی ، 2) پرنٹ (\"اصل سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ nsub-arrays:\") سب_آرے میں سب_اری کے لئے: پرنٹ (سب_ریری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈورجینل سرنی: [[[[[["
    },
    {
        "Question": "دو numpy صفوں کے مابین عنصر کے حساب سے موازنہ کریں۔",
        "Answer": "دو numpy صفوں کے مابین عنصر کے حساب سے موازنہ کرنے کے ل you ، آپ مختلف موازنہ آپریٹرز یا افعال استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: موازنہ آپریٹرز (<، <= ،> ،> = ، == ،!) کا استعمال کرتے ہوئے: Pythoncopy کوڈیمپورٹ numpy as nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array (([1 ، 2 ، 3]) ([1 ، 2 ، 3])[2 ، 2 ، 2]) نتیجہ = سرنی 1 <سرنی 2"
    },
    {
        "Question": "ان اشارے تلاش کریں جہاں دو نمی صفوں کے عناصر برابر ہیں۔",
        "Answer": "ان اشاریہ کو تلاش کرنے کے لئے جہاں دو نمی صفوں کے عناصر برابر ہیں ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3 ، 4]) array2 = np.array ([3 ، 2 ، 1 ، 4]) اشارے = np. where (array1 == array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"اشارے:\" ، اشارے) آؤٹ پٹ: لیس کوپی کوڈرری 1: [1 2 3 4] سرنی 2: [3 2 1 4] اشارے: (سرنی ([1 ، 3]) ،) اس مثال میں ، ہم `استعمال کرتے ہیں"
    },
    {
        "Question": "ان اشارے تلاش کریں جہاں ایک نمی سرنی کے عناصر ایک مخصوص قیمت سے زیادہ ہوتے ہیں۔",
        "Answer": "ان اشاریہ کو تلاش کرنے کے لئے جہاں ایک نمی سرنی کے عناصر ایک مخصوص قیمت سے زیادہ ہوتے ہیں ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 5 ، 3 ، 7 ، 2]) ویلیو = 3 انڈیکس = np.where (سرنی> ویلیو) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"قیمت: \"، ویلیو) پرنٹ (\" اشارے: \"، انڈیکس) آؤٹ پٹ: کاپی کوڈ"
    },
    {
        "Question": "ان اشارے تلاش کریں جہاں کسی نمی سرنی کے عناصر کسی دی گئی حالت کو پورا کرتے ہیں۔",
        "Answer": "ان اشارے تلاش کرنے کے لئے جہاں کسی نمی سرنی کے عناصر کسی دیئے گئے کو پورا کرتے ہیں"
    },
    {
        "Question": "ایک مخصوص ڈیٹا کی قسم کے ساتھ ایک numpy سرے بنائیں۔",
        "Answer": "ایک مخصوص ڈیٹا کی قسم کے ساتھ ایک نمی سرنی بنانے کے ل you ، آپ سرے کی تخلیق کرتے وقت DTYPE پیرامیٹر استعمال کرسکتے ہیں۔ڈی ٹائپ پیرامیٹر آپ کو صف کے ل data مطلوبہ ڈیٹا کی قسم کی وضاحت کرنے کی اجازت دیتا ہے۔یہاں ہے"
    },
    {
        "Question": "ایک نمی سرنی کو ازگر کی فہرست میں تبدیل کریں۔",
        "Answer": "ایک نمی سرنی کو ازگر کی فہرست میں تبدیل کرنے کے ل you ، آپ numpy صف کے ٹولسٹ () طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) لسٹ_آرے = سرنی۔ ٹولسٹ () پرنٹ (\"نیمپی سرنی:\" ، سرنی) پرنٹ (\"تبدیل شدہ فہرست:\"."
    },
    {
        "Question": "ازگر کی فہرست کو ایک نمی سرنی میں تبدیل کریں۔",
        "Answer": "ازگر کی فہرست کو ایک نمی سرنی میں تبدیل کرنے کے ل you ، آپ NP.Array () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور npmy_list = [1 ، 2 ، 3 ، 4 ، 5] numpy_array = np.array (my_list) پرنٹ (\"ازگر کی فہرست:\" ، my_list) پرنٹ (\"تبدیل شدہ numpy سرنی:\" ، numpy_array)"
    },
    {
        "Question": "کسی ٹیکسٹ فائل سے ڈیٹا کو ایک نپی سرنی میں لوڈ کریں۔",
        "Answer": "کسی ٹیکسٹ فائل سے ڈیٹا کو کسی نپی سرنی میں لوڈ کرنے کے ل you ، آپ NP.loadtxt () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور npdata = np.loadtxt ('data.txt') پرنٹ (\"بھری ہوئی ڈیٹا:\") پرنٹ (ڈیٹا) اس مثال میں ، ہم فرض کرتے ہیں کہ آپ کے پاس 'ڈیٹا ڈاٹ ٹی ٹی ایس' کے نام سے ایک ٹیکسٹ فائل ہے۔اس ڈیٹا پر مشتمل ہے جس کو آپ کسی نمی سرنی میں لوڈ کرنا چاہتے ہیں۔NP.Loadtxt () فنکشن فائل سے ڈیٹا کو پڑھتا ہے اور لوڈ شدہ اقدار پر مشتمل ڈیٹا نامی ایک نپی سرنی تیار کرتا ہے۔ پہلے سے طے شدہ ، NP.LoadTxt () یہ فرض کرتا ہے کہ ٹیکسٹ فائل میں وائٹ اسپیس سے الگ الگ اقدار ہیں اور یہ کہ تمام اقدار کی ہیںایک ہی ڈیٹا کی قسم۔تاہم ، آپ اضافی دلائل کی وضاحت کرکے NP.loadtxt () کے طرز عمل کو اپنی مرضی کے مطابق بنا سکتے ہیں۔مثال کے طور پر ، آپ فائل میں استعمال ہونے والے ڈیمیٹر کی وضاحت کرسکتے ہیں ، ہیڈر قطاریں چھوڑ سکتے ہیں ، ڈیٹا کی قسم کی وضاحت کرسکتے ہیں ، اور بہت کچھ۔یہاں ایک مثال ہے جو کچھ اضافی دلائل کا مظاہرہ کرتی ہے: پائیٹون کوپی کوڈیمپورٹ"
    },
    {
        "Question": "ایک نمی سرنی سے اخترن میٹرکس بنائیں۔",
        "Answer": "ایک نمی سرنی سے اخترن میٹرکس بنانے کے ل you ، آپ NP.Diag () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4]) ڈایگونل_میٹرکس = np.diag (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اخترن میٹرکس:\") پرنٹ."
    },
    {
        "Question": "ایک numpy صف کے سراغ کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کے سراغ کا حساب لگانے کے لئے ، آپ NP.Trace () فنکشن استعمال کرسکتے ہیں۔مربع میٹرکس کا سراغ اخترن عناصر کے مجموعہ کے طور پر بیان کیا گیا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]]) ٹریس ="
    },
    {
        "Question": "دو numpy صفوں کے عنصر کے حساب سے ضرب کریں۔",
        "Answer": "دو numpy صفوں کے عنصر کے حساب سے ضرب لگانے کے ل you ، آپ * آپریٹر یا NP.multiply () فنکشن استعمال کرسکتے ہیں۔دونوں نقطہ نظر کا استعمال کرتے ہوئے یہاں ایک مثال ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6])# * آپریٹورسٹولٹ 1 = سرنی 2 استعمال کرتے ہوئے# استعمال کرتے ہوئے# استعمال کرتے ہوئے# استعمال کرتے ہوئے# استعمال کرتے ہوئے#np.multiply () نتیجہ 2 = np.multiply (array1 ، array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"نتیجہ * آپریٹر کا استعمال کرتے ہوئے:\" ، نتیجہ 1) پرنٹ (\"پرنٹ (\" پرنٹ (\"NP.multiply (): \"، نتیجہ 2) آؤٹ پٹ کا استعمال کرتے ہوئے"
    },
    {
        "Question": "ایک نپی سرنی میں اسکیلر ویلیو کے عنصر کے حساب سے کام کریں۔",
        "Answer": "کسی نپی سرنی میں اسکیلر ویلیو کے عنصر کے حساب سے اضافے کے ل you ، آپ آسانی سے + آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3]) اسکیلر = 5 ریزولٹ = سرنی + اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [1 2 3] اسکیلر: 5 ریزولٹ: [6 7 8] اس مثال میں ، ہمارے پاس شکل (3 ،) کے ساتھ ایک نمی سرنی ہے اور اسکیلر ویلیو اسکیلر 5 کے برابر ہے۔سرنی + اسکیلر کو انجام دینے کے بعد ، اسکیلر ویلیو کو صف کے ہر عنصر میں شامل کیا جاتا ہے ،"
    },
    {
        "Question": "اسکیلر ویلیو اور ایک نپی سرنی کے عنصر کے لحاظ سے ضرب انجام دیں۔",
        "Answer": "اسکیلر ویلیو اور نپی سرنی کے عنصر کے حساب سے ضرب انجام دینے کے ل you ، آپ * آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3]) اسکیلر = 5 ریزولٹ = سرنی * اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [1 2 3] اسکیلر: 5 ریزولٹ: [5 10 15] اس مثال میں ، ہمارے پاس شکل (3 ،) اور اسکیلر ویلیو اسکیلر کے ساتھ ایک نمی سرنی ہے۔"
    },
    {
        "Question": "اسکیلر ویلیو کے ذریعہ کسی نمی سرنی کی عنصر کے مطابق تقسیم کریں۔",
        "Answer": "کسی اسکیلر ویلیو کے ذریعہ کسی نمی سرنی کی عنصر کے مطابق تقسیم کرنے کے ل you ، آپ / آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([10 ، 20 ، 30]) اسکیلر = 5 ریزولٹ = سرنی / اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: MakeFilecopy CodeArray: [10 20 30] اسکیلر: 5 ریزولٹ: [2۔6..] اس مثال میں ، ہمارے پاس شکل (3 ،) اور اسکیلر ویلیو اسکیلر کے ساتھ ایک نمی سرنی ہے۔ 5 کے برابر"
    },
    {
        "Question": "ایک نمی سرنی کے ایک مخصوص محور کے ساتھ عناصر کی رقم کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کے مخصوص محور کے ساتھ عناصر کے جوڑے کا حساب لگانے کے ل you ، آپ محور پیرامیٹر کے ساتھ NP.SUM () فنکشن استعمال کرسکتے ہیں۔محور پیرامیٹر محور کی وضاحت کرتا ہے جس کے ساتھ ساتھ رقم کا حساب لگانا چاہئے۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]])# محور 0 (کالم) Sum_axis_0 = np.sum (سرنی ، محور= 0)# محور 1 (قطاریں) کے ساتھ ساتھ رقم کا حساب لگائیں sum_axis_1 = np.sum (سرنی ، محور = 1) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"محور کے ساتھ جمع 0:\") پرنٹ (sum_axis_0) پرنٹ(\"رقم"
    },
    {
        "Question": "عناصر کی مصنوعات کا حساب کتاب ایک مخصوص محور کے ساتھ کریں۔",
        "Answer": "ایک نمی سرنی کے مخصوص محور کے ساتھ عناصر کی مصنوعات کا حساب لگانے کے ل you ، آپ محور پیرامیٹر کے ساتھ NP.Prod () فنکشن استعمال کرسکتے ہیں۔محور پیرامیٹر محور کی وضاحت کرتا ہے جس کے ساتھ ساتھ مصنوع کا حساب لگانا چاہئے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]])# محور 0 (کالم) کے ساتھ مصنوع کا حساب لگائیں= 0)# محور 1 (قطاریں) کے ساتھ مصنوع کا حساب لگائیں (قطار) پروڈکٹ_یکسس_1 = این پی پی۔"
    },
    {
        "Question": "ایک نمی سرنی میں عناصر کی مجموعی رقم کا حساب لگائیں۔",
        "Answer": "ایک نپی سرنی میں عناصر کی مجموعی رقم کا حساب لگانے کے ل you ، آپ NP.Cumsum () فنکشن استعمال کرسکتے ہیں۔یہ ایک مخصوص محور کے ساتھ مجموعی رقم کی گنتی کرتا ہے۔اگر کسی محور کی وضاحت نہیں کی گئی ہے تو ، مجموعی رقم کا حساب صف کے چپٹی ورژن پر کیا جاتا ہے۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نوم کے بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) cumulative_sum = np.cumsum (\"سرنی:\" ، سرنی) پرنٹ (\"مجموعی رقم:\"."
    },
    {
        "Question": "ایک نپی سرنی میں عناصر کی مجموعی مصنوعات کا حساب لگائیں۔",
        "Answer": "ایک نپی سرنی میں عناصر کی مجموعی مصنوعات کا حساب لگانے کے ل you ، آپ استعمال کرسکتے ہیں"
    },
    {
        "Question": "کسی نمی سرنی کی عنصر کے مطابق مطلق اقدار کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کی عنصر کے مطابق مطلق اقدار کا حساب لگانے کے ل you ، آپ NP.ABS () فنکشن استعمال کرسکتے ہیں۔یہ صف میں ہر عنصر کی مطلق اقدار کی گنتی کرتا ہے ، جس کے نتیجے میں ایک ہی شکل کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([ -1 ، -2 ، 3 ، -4 ، 5]) مطلق_ایولس = np.abs (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"مطلق)اقدار: \"، مطلق_ایلیوس) آؤٹ پٹ: ریاضی کاپی کوڈرری: [-1 -2 3 -4 5] مطلق اقدار: [1 2 3 4 5]"
    },
    {
        "Question": "دو numpy صفوں کے عنصر کے حساب سے فرش ڈویژن کا حساب لگائیں۔",
        "Answer": "دو numpy صفوں کے عنصر کے حساب سے فرش ڈویژن کا حساب لگانے کے ل you ، آپ // آپریٹر یا NP.floor_divide () فنکشن استعمال کرسکتے ہیں۔دونوں طریقے فرش ڈویژن کو انجام دیتے ہیں ، جس سے تقسیم کا نتیجہ قریب ترین عددی تک جاتا ہے۔یہاں ایک مثال ہے: // آپریٹر کا استعمال کرتے ہوئے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([7 ، 10 ، 15]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = سرنی 1 // array2 پرنٹ (\"سرنی 1: \"، سرنی 1) پرنٹ (\" سرنی 2: \"، سرنی 2) پرنٹ (\" فلور ڈویژن نتیجہ: \"، نتیجہ) NP.floor_divide () کا استعمال کرتے ہوئے: pythoncopy کوڈیمپورٹ numpy as nparray1 = np.array ([7 ، 10 ،15]) سرنی 2"
    },
    {
        "Question": "دو numpy صفوں کے عنصر کے مطابق ماڈیولو کا حساب لگائیں۔",
        "Answer": "دو numpy صفوں کے عنصر کے مطابق ماڈیولو کا حساب لگانے کے ل you ، آپ ٪ آپریٹر یا NP.MOD () فنکشن استعمال کرسکتے ہیں۔دونوں طریقے ماڈیولو آپریشن انجام دیتے ہیں ، جو تقسیم کے بعد باقی کی گنتی کرتے ہیں۔یہاں ایک مثال ہے: ٪ آپریٹر کا استعمال کرتے ہوئے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([7 ، 10 ، 15]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = سرنی 1 ٪ array2 پرنٹ (\"سرنی 1: \"، array1) پرنٹ (\" سرنی 2: \"، اری 2) پرنٹ (\" ماڈیولو نتیجہ: \"، نتیجہ) NP.MOD (): Pythoncopy Codemport numpy کے طور پر nparray1 = np.array ([7 ، 10 ، 15])array2 = np.array ([2 ، 3 ، 4])"
    },
    {
        "Question": "عنصر کے لحاظ سے منطقی اور دو نمی صفوں کے درمیان آپریشن انجام دیں۔",
        "Answer": "عنصر کے لحاظ سے منطقی اور آپریشن کو دو numpy صفوں کے درمیان انجام دینے کے ل you ، آپ NP.logical_and () فنکشن استعمال کرسکتے ہیں۔یہ ان پٹ صفوں میں منطقی اور اسی طرح کے عناصر کی گنتی کرتا ہے ، جس کے نتیجے میں بولین اقدار کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([سچ ، سچ ، غلط ، غلط]) array2 = np.array ([سچ ، غلط ، سچ ، غلط]) نتیجہ = np.logical_and (array1 ، arry2)پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، اری 2) پرنٹ (\"منطقی اور نتیجہ:\" ، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈآرری 1: [سچ سچ غلط جھوٹا] سرنی"
    },
    {
        "Question": "عنصر کے لحاظ سے منطقی یا دو نمی صفوں کے درمیان آپریشن انجام دیں۔",
        "Answer": "عنصر کے لحاظ سے منطقی یا دو نمی صفوں کے مابین آپریشن کرنے کے ل you ، آپ NP.logical_or () فنکشن استعمال کرسکتے ہیں۔یہ ان پٹ صفوں میں منطقی یا اسی طرح کے عناصر کی گنتی کرتا ہے ، جس کے نتیجے میں بولین اقدار کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([سچ ، ، غلط ، غلط ، غلط]) array2 = np.array ([سچ ، غلط ، سچ ، غلط]) نتیجہ = np.logical_or (array1 ، arry2)پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، اری 2) پرنٹ (\"منطقی یا نتیجہ:\" ، نتیجہ) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈآرری"
    },
    {
        "Question": "عنصر کے لحاظ سے منطقی انجام نہ دیں جو کسی نمی سرنی پر آپریشن نہ کریں۔",
        "Answer": "عنصر کے مطابق منطقی انجام دینے کے ل nump ، کسی نمی سرنی پر آپریشن نہ کریں ، آپ NP.logical_not () فنکشن استعمال کرسکتے ہیں۔یہ ان پٹ سرنی میں ہر عنصر کی منطقی گنتی نہیں کرتا ہے ، جس کے نتیجے میں بولین اقدار کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([سچ ، غلط ، سچ]) نتیجہ = np.logical_not (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"منطقی نہیں نتیجہ:\" ، نتیجہ)آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری:"
    },
    {
        "Question": "نوم کے ارینج فنکشن کا استعمال کرتے ہوئے نمبروں کا ایک تسلسل تیار کریں۔",
        "Answer": "یقینا!آپ نوم کے آرینج () فنکشن کا استعمال کرتے ہوئے نمبروں کا ایک تسلسل تیار کرسکتے ہیں۔ارینج () فنکشن ایک مخصوص آغاز ، اختتام اور مرحلہ سائز کے ساتھ نمبروں کی 1 جہتی صف تیار کرتا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# 0 سے 9 (خصوصی) تسلسل = NP.Arange (0 ، 10) پرنٹ (\"ترتیب:\" ، ترتیب) آؤٹ پٹ: میک فیلیکوپی کوڈیسیوینس: [0 1 2 2 تک نمبروں کی ترتیب پیدا کریں۔3 4 5 6 7 8 9] اس مثال میں"
    },
    {
        "Question": "اس کے عناصر کو ایک مخصوص تعداد میں دہراتے ہوئے ایک غیرمعمولی سرنی کو نئی شکل دیں۔",
        "Answer": "ایک مخصوص تعداد کو ایک مخصوص تعداد میں دہراتے ہوئے ایک نمی سرنی کو نئی شکل دینے کے ل you ، آپ NP.REEPEAT () فنکشن استعمال کرسکتے ہیں۔یہ فنکشن ان پٹ سرنی میں ہر عنصر کو ایک خاص تعداد میں دہراتا ہے ، جس کے نتیجے میں ایک نئی شکل مختلف شکل کے ساتھ ہوتی ہے۔یہاں مثال دی گئی ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3])# ہر عنصر کو 2 ٹائمسریپیڈ_ریری = np.repeat (سرنی ، دہرانے = 2) پرنٹ (\"اصل سرنی:\" کو دہرا کر صف کو نئی شکل دیں (\"اصل سرنی:\"، سرنی) پرنٹ (\"دوبارہ تشکیل شدہ سرنی:\" ، resshaped_array) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈورجینل سرنی: [1 2 3] دوبارہ تیار شدہ سرنی: [1 1 2 2 2 3 3] اس مثال میں ، ہمارے پاس عناصر پر مشتمل ایک 1D نام ہے جس میں عناصر شامل ہیں۔`[1 ،"
    },
    {
        "Question": "ایک مخصوص شکل میں زیرو کے ساتھ ایک نمی سرنی کو پیڈ کریں۔",
        "Answer": "ایک مخصوص شکل میں زیرو کے ساتھ ایک نمی سرنی کو پیڈ کرنے کے ل you ، آپ NP.PAD () فنکشن استعمال کرسکتے ہیں۔NP.PAD () فنکشن آپ کو مطلوبہ بھرتی کی شکل اور بھرتی کے لئے استعمال ہونے والی قدر کی وضاحت کرکے ایک صف میں بھرتی شامل کرنے کی اجازت دیتا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2] ، [3 ، 4]])# زروس کے ساتھ سرنی (3 ، 4) پیڈڈ_ریری = این پی پیڈ (سرنی (سرنی.سرنی:"
    },
    {
        "Question": "ایک نپی سرنی پر عنصر کے حساب سے پاور آپریشن انجام دیں۔",
        "Answer": "ایک نپی سرنی پر عنصر کے حساب سے پاور آپریشن انجام دینے کے ل you ، آپ NP.POWER () فنکشن استعمال کرسکتے ہیں۔NP.POWER () فنکشن صف میں ہر عنصر کو ایک مخصوص طاقت میں اٹھاتا ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3])# ایکسپینٹ 2 ریزولٹ = این پی پاور (سرنی ، 2) پرنٹ (\"اصل سرنی:\" ، سرنی کے ساتھ عنصر کے مطابق بجلی کا آپریشن انجام دیں۔) پرنٹ (\"نتیجہ:\" ، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈورجینل سرنی: [1 2 3] نتیجہ: [1 4 9] اس مثال میں ، ہمارے پاس عناصر کے ساتھ سرنی کہا جاتا ہے۔ [1"
    },
    {
        "Question": "نوم کے ویکٹرائز فنکشن کا استعمال کرتے ہوئے ایک نمی سرنی کے ہر عنصر پر کسٹم فنکشن کا اطلاق کریں۔",
        "Answer": "نوم (عددی ازگر) ایک مشہور ازگر لائبریری ہے جو ان صفوں پر موثر انداز میں کام کرنے کے لئے ریاضی کے افعال کی ایک وسیع رینج کے ساتھ ساتھ بڑی ، کثیر جہتی صفوں اور میٹرک کے لئے مدد فراہم کرتی ہے۔یہ ازگر کے ساتھ سائنسی کمپیوٹنگ کے لئے ایک بنیادی پیکیج ہے۔ یہاں کچھ کلیدی خصوصیات اور فنکشنلیاں ہیں جو نمی کے ذریعہ فراہم کی گئیں: کثیر جہتی سرنی آبجیکٹ: نیمپی کی مرکزی خصوصیت نڈرے (این جہتی سرنی) آبجیکٹ ہے ، جو آپ کو بڑے ذخیرہ کرنے اور بڑی ہیرا پھیری کرنے کی اجازت دیتی ہے۔سرنی موثر انداز میں۔یہ صفیں مختلف سائز اور طول و عرض کی ہوسکتی ہیں ، اور وہ تیز ، ویکٹرائزڈ آپریشنز مہیا کرتے ہیں۔ میٹیمیٹک افعال: نیمپی نے ریاضی کے افعال کی ایک وسیع رینج فراہم کی ہے جو واضح لوپ کی ضرورت کے بغیر براہ راست صفوں پر لاگو ہوسکتی ہے۔ان افعال میں بنیادی ریاضی کی کاروائیاں ، مثلثی افعال ، کفایت شعاری اور لوگرتھمک افعال ، اعداد و شمار کے افعال ، اور بہت کچھ شامل ہیں۔ بروڈکاسٹنگ: نیمپی براڈکاسٹنگ کی حمایت کرتا ہے ، جو آپ کو مختلف شکلوں اور سائز کی صفوں کے مابین ریاضی کے کام انجام دینے کی سہولت دیتا ہے۔براڈکاسٹنگ بڑی صفوں کی شکل سے ملنے کے لئے خود بخود چھوٹی چھوٹی صفوں کو وسعت دیتی ہے ، جس سے واضح لوپنگ کی ضرورت کو ختم کیا جاتا ہے۔آپ سرنی کی شکل کو تبدیل کرسکتے ہیں ، صفوں کو یکجا کرسکتے ہیں ، اسپلٹ صفوں کو اکٹھا کرسکتے ہیں ، عناصر کو نکال سکتے ہیں ، اور سرنی ڈھانچے کو دوبارہ ترتیب دینے یا اس میں ترمیم کرنے کے لئے دیگر کاروائیاں انجام دے سکتے ہیں۔ لائنر الجبرا آپریشنز: نومی لکیری الجبرا کے افعال ، جیسے میٹرکس ضرب ، میٹرکس کا ایک جامع سویٹ فراہم کرتا ہے۔سڑن (جیسے ، لو ، کیو آر) ، ایگین ویلیوز اور ایگین ویکٹر ، لکیری مساوات کو حل کرنا ، اور بہت کچھ۔ رینڈم نمبر جنریشن: نمی میں ایک بے ترتیب ماڈیول شامل ہوتا ہے جو آپ کو مختلف امکانی تقسیم کے ساتھ بے ترتیب نمبر اور بے ترتیب صف پیدا کرنے کی اجازت دیتا ہے۔ دیگر لائبریریوں کے ساتھ انضمام: نیمپیازگر سائنسی کمپیوٹنگ ماحولیاتی نظام میں ایک بنیادی لائبریری ہے اور جدید سائنسی اور عددی کمپیوٹیشن کے لئے ایس سی آئی پی وائی (سائنسی ازگر) جیسی دیگر لائبریریوں کے ساتھ اچھی طرح سے مربوط ہے ، پلاٹ اور تصور کے لئے میٹپلوٹلیب ، اور ڈیٹا ہیرا پھیری اور تجزیہ کے لئے پانڈاس۔کمپیوٹنگ کی صلاحیت ، ازگر میں موثر عددی کارروائیوں اور ڈیٹا ہیرا پھیری کو قابل بنانا۔یہ مختلف ڈومینز میں وسیع پیمانے پر استعمال ہوتا ہے ، بشمول سائنسی تحقیق ، ڈیٹا تجزیہ ، مشین لرننگ ، اور بہت کچھ۔"
    },
    {
        "Question": "نپی سرنی سے مخصوص اخترن عناصر کے ساتھ اخترن میٹرکس بنائیں۔",
        "Answer": "یقینا!یہاں 0 سے 9 تک کی اقدار کے ساتھ ایک نپی سرنی بنانے کی ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.arang، ہم نپی لائبریری درآمد کرتے ہیں اور 0 سے 9 تک اقدار کے ساتھ ایک صف بنانے کے لئے ارینج () فنکشن کا استعمال کرتے ہیں۔ ارینج () فنکشن مخصوص رینج کی بنیاد پر نمبروں کی ترتیب پیدا کرتا ہے ، جو بلٹ ان رینج () فنکشن کی طرح ہے۔ازگر میںآخر میں ، ہم نتیجہ دیکھنے کے لئے صف کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق مجموعی رقم کا حساب لگائیں۔",
        "Answer": "یقینا!یہاں ایک 3x3 numpy سرے بنانے کی ایک مثال ہے جس میں صفر پر مقرر کردہ تمام عناصر: Pythoncopy Codemport numpy as nparray = np.zeros ((3 ، 3)) پرنٹ (سرنی) آؤٹ پٹ: Luacopy کوڈ [[0.0. 0.] [0.0. 0.] [0.0. 0.]] اس کوڈ میں ، ہم نپی لائبریری درآمد کرتے ہیں اور 3x3 سرنی بنانے کے لئے زیروس () فنکشن کا استعمال کرتے ہیں۔زیروس () فنکشن مطلوبہ صف کی شکل کو اس معاملے میں ٹپل (3 ، 3) کی طرح لیتا ہے اور تمام عناصر کو صفر تک شروع کرتا ہے۔آخر میں ، ہم نتیجہ دیکھنے کے لئے صف کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق مجموعی مصنوع کا حساب لگائیں۔",
        "Answer": "یقینا!یہاں 0 اور 1 کے درمیان بے ترتیب اقدار کے ساتھ 2x2 numpy سرے بنانے کی ایک مثال ہے: Pythoncopy Codimport numpy as nparray = np.random.rand.rand (2 ، 2) پرنٹ (سرنی) آؤٹ پٹ: Luacopy کوڈ [[0.74931949 0.1896888] [0.4161288] [0.4161288] [0.4161288] [0.4161288]] اس کوڈ میں ، ہم numpy لائبریری درآمد کرتے ہیں اور 0 اور 1 کے درمیان بے ترتیب اقدار کے ساتھ 2x2 سرنی بنانے کے لئے بے ترتیب۔ رینڈ () فنکشن کا استعمال کرتے ہیں۔ بے ترتیب۔ رینڈ () فنکشن یکساں تقسیم سے بے ترتیب نمبر تیار کرتا ہے۔دلائل (2 ، 2) صف کی شکل کی وضاحت کرتے ہیں۔آخر میں ، ہم نتیجہ دیکھنے کے لئے صف کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک مخصوص رینج کے مابین یکساں طور پر فاصلہ والی اقدار کے ساتھ ایک نپی سرنی بنائیں۔",
        "Answer": "یقینا!یہاں 0 اور 1 کے درمیان 10 یکساں طور پر فاصلہ والی اقدار کے ساتھ 1D نیپی سرنی بنانے کی ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر nparray = np.linspace (0 ، 1 ، 10) پرنٹ (سرنی) آؤٹ پٹ: csharpcopy کوڈ [0۔0.1111111 0.222222222 0.333333333 0.4444444444444444444444444 0.555555556 0.6666666667 0.77777777777777778 0.8888889 فنکشن کے ساتھ ، 10 اور اس کوڈ کے ساتھ ، ہم Numpy لائبریری () ARPY لائبریری () کو تخلیق کرنے کے لئے لنسپیس () فنکشن استعمال کرتے ہیں () فنکشن استعمال کرتے ہیں۔ دلائل: اسٹارٹ ویلیو (اس معاملے میں 0) ، اختتامی قیمت (اس معاملے میں 1) ، اور عناصر کی تعداد جو ہم صف میں چاہتے ہیں (اس معاملے میں 10)۔یہ وقفہ کو شروع اور اختتامی اقدار کے درمیان مساوی حصوں میں تقسیم کرتا ہے اور صف پیدا کرتا ہے۔آخر میں ، ہم نتیجہ دیکھنے کے لئے صف کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کی اقدار کو رینج [0 ، 1] میں معمول بنائیں۔\"",
        "Answer": "یقینا!یہاں ایک 3x3 numpy سرنی بنانے اور اسے 1D سرنی میں تبدیل کرنے کی ایک مثال ہے: Pythoncopy Codimport numpy As NP# ایک 3x3 arrayarray_2d = np.array بنائیں ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [[[1 ، 2 ، 3] ، [4 ، 5 ، 6]7 ، 8 ، 9]]]# سرنی کو 1d arrayarray_1d = array_2d.flatten () پرنٹ (\"اصل 2 ڈی سرنی:\") پرنٹ (array_2d) پرنٹ (\"\\ nreshaped 1d سرنی:\") پرنٹ (سرنی_1d) آؤٹ پٹ: Luacopy Codyoriginal 2d سرنی: [[1 2 3] [4 5 6] [7 8 9]] نے 1D سرنی کو نئی شکل دی: [1 2 3 4 5 6 6 7 8 9] اس کوڈ میں ، ہم پہلے 3x3 numpy سرے کو کال کریںnp.array () فنکشن کا استعمال کرتے ہوئے سرنی_2 ڈی۔اس کے بعد ہم 2D سرنی کو 1D سرنی میں نئی شکل دینے کے لئے فلیٹن () کا طریقہ استعمال کرتے ہیں ، جو ایک نئی 1D صف لوٹاتا ہے۔آخر میں ، ہم نتائج کو دیکھنے کے لئے اصل 2D سرنی اور 1D سرنی کو دوبارہ تیار کیا۔"
    },
    {
        "Question": "دو numpy صفوں کے عنصر کے مطابق کراس پروڈکٹ کا حساب لگائیں۔",
        "Answer": "ایک نپی سرنی میں زیادہ سے زیادہ قیمت تلاش کرنے کے ل you ، آپ زیادہ سے زیادہ () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) میکس_ ویلیو = np.max (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"زیادہ سے زیادہ قیمت): \"، میکس_ ویلیو) آؤٹ پٹ: یامل کوپی کوڈرری: [4 2 9 5 1 7] زیادہ سے زیادہ قیمت: 9 اس کوڈ میں ، ہم پہلے ایک نپی سرنی بناتے ہیں جسے سرنی کہتے ہیں۔اس کے بعد ، ہم صف میں زیادہ سے زیادہ قیمت تلاش کرنے کے لئے NP.MAX () فنکشن کا استعمال کرتے ہیں۔NP.MAX () فنکشن صف میں موجود زیادہ سے زیادہ قیمت لوٹاتا ہے۔آخر میں ، ہم اصل صف اور زیادہ سے زیادہ قیمت دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "عنصر کے حساب سے ڈاٹ پروڈکٹ کا حساب دو numpy صفوں کے حساب سے کریں۔",
        "Answer": "ایک نپی سرنی میں کم سے کم قیمت تلاش کرنے کے ل you ، آپ کم سے کم () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) Min_value = np.min (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"کم سے کم قیمت): \"، MIN_VALUE) آؤٹ پٹ: YAMLCOPY CODEARRAY: [4 2 9 5 1 7] کم سے کم قیمت: 1 اس کوڈ میں ، ہم پہلے سرے کے نام سے ایک نپی سرنی بناتے ہیں۔اس کے بعد ، ہم صف میں کم سے کم قیمت تلاش کرنے کے لئے NP.MIN () فنکشن کا استعمال کرتے ہیں۔NP.MIN () فنکشن صف میں موجود کم سے کم قیمت لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور کم سے کم قیمت دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "عنصر کے لحاظ سے دو نمی صفوں کے مابین مطلق فرق کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کے وسط (اوسط) کا حساب لگانے کے ل you ، آپ وسط () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) مینی_ ویلیو = np.mean (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"مطلب:\" مطلب:\"، مینی_ ویلیو) آؤٹ پٹ: میک فیلیکوپی کوڈرری: [4 2 9 5 1 7] مطلب: 4.6666666666666667 اس کوڈ میں ، ہم پہلے ایک نپی سرنی بناتے ہیں جسے سرنی کہتے ہیں۔اس کے بعد ، ہم صف کی اوسط قدر کا حساب لگانے کے لئے NP.Mean () فنکشن کا استعمال کرتے ہیں۔NP.Mean () فنکشن صف میں عناصر کی اوسط قیمت لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور اوسط قدر دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق آرکٹینجنٹ کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے میڈین کا حساب لگانے کے ل you ، آپ میڈین () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) میڈین_ویلیو = np.median (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"میڈین:\" میڈین: \"میڈین:\"، میڈین_ ویلیو) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [4 2 9 5 1 7] میڈین: 4.5 اس کوڈ میں ، ہم پہلے ایک نپی سرنی بناتے ہیں جسے سرنی کہتے ہیں۔اس کے بعد ، ہم سرنی کی درمیانی قیمت کا حساب لگانے کے لئے NP.Median () فنکشن کا استعمال کرتے ہیں۔NP.Median () فنکشن ترتیب شدہ سرنی کی درمیانی قیمت ، یا دو درمیانی اقدار کی اوسط کو لوٹاتا ہے اگر سرنی میں عناصر کی تعداد بھی ہے۔آخر میں ، ہم اصل صف اور درمیانی قیمت دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نپی سرنی کے عنصر کے مطابق ہائپربولک سائن کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے معیاری انحراف کا حساب لگانے کے لئے ، آپ ایس ٹی ڈی () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) std_value = np.std (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"معیاری انحراف.اس کے بعد ، ہم سرنی کے معیاری انحراف کا حساب لگانے کے لئے NP.STD () فنکشن کا استعمال کرتے ہیں۔NP.STD () فنکشن معیاری انحراف کو لوٹاتا ہے ، جو صف کی اقدار میں تغیر یا بازی کی مقدار کا ایک پیمانہ ہے۔آخر میں ، ہم اصل سرنی اور معیاری انحراف کی قیمت دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نپی سرنی کے عنصر کے مطابق ہائپربولک کوسائن کا حساب لگائیں۔",
        "Answer": "ایک numpy صف کے تغیر کا حساب لگانے کے لئے ، آپ VAR () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) متغیر_اولیو = np.var (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"تغیر:\" تغیر: \"تغیر:\" تغیر:\"، متغیر_ ویلیو) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [4 2 9 5 1 7] تغیر: 8.6666666666666666666666 اس کوڈ میں ، ہم پہلے ایک نمی سرنی تیار کرتے ہیں جسے سرنی کہتے ہیں۔اس کے بعد ، ہم سرنی کے تغیر کا حساب لگانے کے لئے NP.var () فنکشن کا استعمال کرتے ہیں۔NP.VAR () فنکشن تغیر کو لوٹاتا ہے ، جو اوسط سے اوسط مربع انحراف کا ایک پیمانہ ہے۔آخر میں ، ہم اصل صف اور تغیر کی قیمت دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق ہائپربولک ٹینجینٹ کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کے عناصر کا خلاصہ کرنے کے ل you ، آپ رقم () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) sum_value = np.sum (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"رقم:\" رقم:\"، SUM_VALUE) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [4 2 9 5 1 7] خلاصہ: 28 اس کوڈ میں ، ہم پہلے سرے کے نام سے ایک نپی سرنی بناتے ہیں۔اس کے بعد ، ہم صف میں عناصر کے جوڑے کا حساب لگانے کے لئے NP.SUM () فنکشن کا استعمال کرتے ہیں۔NP.SUM () فنکشن سرنی میں موجود تمام اقدار کو شامل کرتا ہے اور اس کا نتیجہ لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور رقم کی قیمت دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر وار آرکسین کا حساب لگائیں۔",
        "Answer": "دو numpy صفوں کے ڈاٹ پروڈکٹ کا حساب لگانے کے ل you ، آپ ڈاٹ () فنکشن یا @ آپریٹر استعمال کرسکتے ہیں۔دونوں طریقوں کا استعمال کرتے ہوئے یہاں ایک مثال ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6]) ڈاٹ_ پروڈکٹ 1 = np.dot (array1 ، array2) dot_product2= array1.dot (array2) dot_product3 = array1 @ array2 پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"ڈاٹ پروڈکٹ 1:\" ، ڈاٹ_ پروڈکٹ 1) پرنٹ (\"ڈاٹ پروڈکٹ 2:\"، ڈاٹ_پروڈکٹ 2) پرنٹ (\"ڈاٹ پروڈکٹ 3:\" ، ڈاٹ_ پروڈکٹ 3) آؤٹ پٹ: ریاضی کاپی کوڈرری 1: [1 2 3] سرنی 2: [4 5 6] ڈاٹ پروڈکٹ 1: 32dot پروڈکٹ 2: 32dot 3: 32 ان کوڈ ، ہم ، ہم ، ہمدو numpy صفیں بنائیں ، array1 اور arry2.اس کے بعد ہم تین مختلف طریقوں کا استعمال کرتے ہوئے صفوں کے ڈاٹ پروڈکٹ کا حساب لگاتے ہیں: NP.DOT (array1 ، array2): یہ طریقہ دو سرنیوں کی ڈاٹ پروڈکٹ کا حساب لگانے کے لئے Numpy سے DOT () فنکشن کا استعمال کرتا ہے۔یہ طریقہ ڈاٹ پروڈکٹ کا حساب لگانے کے لئے براہ راست Array1 آبجیکٹ پر DOT () کے طریقہ کار کو کال کرتا ہے۔ array1 @ array2: یہ طریقہ @ آپریٹر کا استعمال کرتا ہے ، جسے میٹرکس ضرب آپریٹر کے نام سے بھی جانا جاتا ہے ، ڈاٹ پروڈکٹ کا حساب کتاب کرنے کے لئے۔ تمام تین طریقوں سے ملتے ہیں۔ڈاٹ پروڈکٹ کا نتیجہ۔آخر میں ، ہم دونوں صفوں اور ڈاٹ پروڈکٹ کی اقدار دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے حساب سے آرکوسین کا حساب لگائیں۔",
        "Answer": "ایک numpy سرنی کو منتقل کرنے کے ل you ، آپ ٹرانسپوز () فنکشن یا .T وصف استعمال کرسکتے ہیں۔دونوں طریقوں کا استعمال کرتے ہوئے یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) transposed1 = np.transpose (سرنی) transposed2 = array.tprint (\"اصل صف: \") پرنٹ (سرنی) پرنٹ (\" \\ n ٹرانزپوزڈ سرنی 1: \") پرنٹ (ٹرانسپوزڈ 1) پرنٹ (\" \\ n ٹرانسپوزڈ سرنی 2: \") پرنٹ (ٹرانسپوزڈ 2) آؤٹ پٹ: لوکاپی کوڈوریجینل سرنی: [[1 2 3] [[[1 2 3] [4 5 6]] منتقلی سرنی 1: [[1 4] [2 5] [3 6]] ٹرانسپوزڈ سرنی 2: [[1 4] [2 5] [3 6]] اس کوڈ میں ، ہم ایک نمی سرنی بناتے ہیںسرنی کہا جاتا ہے۔اس کے بعد ہم دو طریقوں کا استعمال کرتے ہوئے ٹرانسپوزڈ سرنی حاصل کرتے ہیں: NP.transpose (سرنی): یہ طریقہ ٹرانسپوزڈ سرنی حاصل کرنے کے لئے Numpy سے ٹرانسپوز () فنکشن کا استعمال کرتا ہے۔ٹرانسپوزڈ سرنی۔ دونوں طریقوں سے وہی ٹرانسپوزڈ سرنی نتیجہ برآمد ہوتا ہے۔آخر میں ، ہم اصل صف اور ٹرانسپوزڈ صفوں کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق آرکوٹینجنٹ کا حساب لگائیں۔",
        "Answer": "ایک نپی سرنی میں عناصر کے ترتیب کو پلٹانے کے ل you ، آپ انڈیکسنگ کو [::-1] اشارے کے ساتھ استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]]) الٹ_ری = سرنی [::-1] پرنٹ (\"اصل سرنی:\" ، سرنی) پرنٹ (\"الٹ سرنی): \"، الٹ_ریری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈورجینل سرنی: [1 2 3 4 4 5] الٹ سرنی: [5 4 3 3 2 1] اس کوڈ میں ، ہم عناصر کے ساتھ سرنی نامی ایک نپی سرنی بناتے ہیں [1 ، 2 ، 3 ، 4 ،5].عناصر کے حکم کو پلٹانے کے ل we ، ہم انڈیکسنگ کے دوران [::-1] اشارے کا استعمال کرتے ہیں۔یہ اشارہ -1 کے ایک قدم کے ساتھ صف کا ایک نیا نظریہ پیدا کرتا ہے ، جو عناصر کے حکم کو مؤثر طریقے سے تبدیل کرتا ہے۔آخر میں ، ہم اصل سرنی اور الٹ سرنی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے حساب سے آرکسن کا حساب لگائیں۔",
        "Answer": "چڑھائی ترتیب میں ایک نمی سرنی کو ترتیب دینے کے ل you ، آپ ترتیب () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) ترتیب شدہ_آرے = np.sort (سرنی) پرنٹ (\"اصل سرنی:\" ، سرنی) پرنٹ (\"چھانٹیا ہوا)سرنی: \"، چھانٹے ہوئے_آرے) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈوریجینل سرنی: [4 2 9 5 1 7] ترتیب شدہ سرنی: [1 2 4 5 7 9] اس کوڈ میں ، ہم عناصر کے ساتھ سرے نامی ایک نام کی سرے بناتے ہیں [4 ، 2 ، 9، 5 ، 1 ، 7]۔اس کے بعد ہم سرے کو چڑھائی ترتیب میں ترتیب دینے کے لئے NP.Sort () فنکشن کا استعمال کرتے ہیں۔NP.Sort () فنکشن ترتیب شدہ عناصر کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور ترتیب شدہ سرنی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر وار آرکوش کا حساب لگائیں۔",
        "Answer": "ایک نپی سرنی میں زیادہ سے زیادہ قیمت کے اشارے تلاش کرنے کے ل you ، آپ ارگمیکس () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) میکس_ انڈیکس = این پی.آرگمیکس (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اشاریہ کا اشاریہزیادہ سے زیادہ قیمت: \"، MAX_INDEX) آؤٹ پٹ: ریاضی کاپی کوڈرری: [4 2 9 5 1 7] زیادہ سے زیادہ قیمت کا اشاریہ: 2 اس کوڈ میں ، ہم سرنی کے نام سے ایک نمی سرنی بناتے ہیں۔اس کے بعد ہم صف میں زیادہ سے زیادہ قیمت کا انڈیکس تلاش کرنے کے لئے NP.Argmax () فنکشن کا استعمال کرتے ہیں۔NP.Argmax () فنکشن صف میں موجود زیادہ سے زیادہ قیمت کا انڈیکس لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور زیادہ سے زیادہ قیمت کے انڈیکس دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اگر زیادہ سے زیادہ قیمت کے متعدد واقعات ہوتے ہیں تو ، ارگمیکس () پہلے واقعے کا انڈیکس واپس کردے گا۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر وار آرکٹین کا حساب لگائیں۔",
        "Answer": "کم سے کم قیمت کے اشاریے کو کسی نمی سرنی میں تلاش کرنے کے ل you ، آپ ارگمین () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 2 ، 9 ، 5 ، 1 ، 7]) من_ انڈیکس = np.argmin (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اشاریہ کا اشاریہکم سے کم قیمت: \"، MIN_INDEX) آؤٹ پٹ: ریاضی کاپی کوڈرری: [4 2 9 5 1 7] کم سے کم قیمت کا اشاریہ: 4 اس کوڈ میں ، ہم سرنی کے نام سے ایک نمی سرنی بناتے ہیں۔اس کے بعد ہم صف میں کم سے کم قیمت کا انڈیکس تلاش کرنے کے لئے NP.argmin () فنکشن کا استعمال کرتے ہیں۔NP.Argmin () فنکشن صف میں موجود کم سے کم قیمت کا انڈیکس لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور کم سے کم قیمت کا انڈیکس دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اگر کم سے کم قیمت کے متعدد واقعات ہوتے ہیں تو ، ارگمین () پہلے واقعے کا انڈیکس واپس کردے گا۔"
    },
    {
        "Question": "ایک نپی سرنی کے عنصر کے مطابق لاجسٹک سگمائڈ فنکشن کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی میں انوکھی اقدار کو تلاش کرنے کے ل you ، آپ NP.Unique () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[2 ، 1 ، 3 ، 2 ، 3 ، 1 ، 4 ، 5 ، 4 ، 4]) منفرد_اولیوس = np.unique (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"منفرد اقدار:\" ، منفرد_والیوز) آؤٹ پٹ: ریاضی کاپی کوڈرری: [2 1 3 2 3 1 4 5 4] انوکھی اقدار: [1 2 3 4 5] اس کوڈ میں ، ہم عناصر کے ساتھ سرنی نامی ایک نپی سرنی بناتے ہیں۔[2 ، 1 ، 3 ، 2 ، 3 ، 1 ، 4 ، 5 ، 4]۔اس کے بعد ہم صف میں انوکھی اقدار تلاش کرنے کے لئے NP.Unique () فنکشن کا استعمال کرتے ہیں۔NP.Unique () فنکشن ایک ترتیب شدہ صف کو اصل صف میں موجود انوکھی اقدار کے ساتھ لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور انوکھی اقدار دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ منفرد اقدار کو چڑھائی ترتیب میں ترتیب دیا گیا ہے۔"
    },
    {
        "Question": "ایک نپی سرنی کے عنصر کے مطابق سافٹ میکس فنکشن کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی میں ہر منفرد قدر کے واقعات کی تعداد کو گننے کے ل you ، آپ NP.unique () فنکشن کو ریٹرن_کونٹ = سچے پیرامیٹر کے ساتھ استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[2 ، 1 ، 3 ، 2 ، 3 ، 1 ، 4 ، 5 ، 4]) منفرد_اولیوس ، گنتی = np.unique (صف ، ریٹرن_کاؤنٹ = سچ) پرنٹ (پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"منفرد اقدار:\" ، منفرد_والیوز) پرنٹ (\"گنتی:\" ، گنتی) آؤٹ پٹ: ریاضی کاپی کوڈرری: [2 1 3 2 3 1 4 5 4] منفرد اقدار: [1 2 3 4 45] گنتی: [2 2 2 2 2 1] اس کوڈ میں ، ہم عناصر [2 ، 1 ، 3 ، 2 ، 3 ، 1 ، 4 ، 5 ، 4] کے ساتھ سرنی نامی ایک نپی سرنی تیار کرتے ہیں۔اس کے بعد ہم منفرد اقدار اور ان کی متعلقہ گنتی دونوں کو حاصل کرنے کے لئے NP.Unique () فنکشن کا استعمال کرتے ہیں۔NP.Unique () فنکشن دو صفوں کو لوٹاتا ہے: انوکھا_اولی جو اصل صف میں انوکھی اقدار پر مشتمل ہے ، اور ہر انوکھی قدر کی گنتی پر مشتمل ہے۔آخر میں ، ہم اصل سرنی ، انوکھی اقدار اور گنتی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق لوگرتھم (بیس 2) کا حساب لگائیں۔",
        "Answer": "تمام منفی اقدار کو ایک نمی سرنی میں صفر کے ساتھ تبدیل کرنے کے ل you ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([ -2 ، 3 ، -5 ، 1 ، -4 ، 6]) سرنی_نون_نیگیٹیو = np.where (سرنی <0 ، 0 ، سرنی) پرنٹ (\"اصل سرنی) پرنٹ (\" اصل سرنی).یہ کوڈ ، ہم عناصر [-2 ، 3 ، -5 ، 1 ، -4 ، 6] کے ساتھ سرنی نامی ایک نپی سرنی بناتے ہیں۔اس کے بعد ہم تمام منفی اقدار کو صفر سے تبدیل کرنے کے لئے NP.Where () فنکشن کا استعمال کرتے ہیں۔NP. Where () فنکشن تین دلائل لیتا ہے: چیک کرنے کی شرط (اس معاملے میں ، منفی اقدار کی نشاندہی کرنے کے لئے سرنی <0) ، عناصر کو تبدیل کرنے کی قدر جہاں حالت درست ہے (صفر) ، اور برقرار رکھنے کی قدرعناصر جہاں حالت غلط ہے (سرنی کی اصل اقدار)۔آخر میں ، ہم صفر کی جگہ منفی اقدار کے ساتھ اصل صف اور ترمیم شدہ صف دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر وار مربع کا حساب لگائیں۔",
        "Answer": "عنصر کے لحاظ سے دو numpy صفوں کو شامل کرنے کے ل you ، آپ آسانی سے + آپریٹر استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6]) نتیجہ = array1 + array2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر کے مطابق رقم:\" ، نتیجہ) آؤٹ پٹ: ریاضی کا کوڈرری 1: [1 2 3] سرنی 2: [4 5 6] عنصر کے مطابق رقم: [5 7 9 9] اس کوڈ میں ، ہم بالترتیب عناصر [1 ، 2 ، 3] اور [4 ، 5 ، 6] کے ساتھ دو نپی سرنی ، سرنی 1 اور سرنی 2 بناتے ہیں۔اس کے بعد ہم + آپریٹر کا استعمال کرتے ہوئے دو صفوں میں عنصر کے حساب سے شامل کرتے ہیں ، اور نتیجہ کو متغیر میں اسٹور کرتے ہیں۔+ آپریٹر عنصر کے حساب سے اضافہ کرتا ہے ، یعنی اس میں دونوں صفوں کے متعلقہ عناصر کو ایک ساتھ جوڑ دیا جاتا ہے۔آخر میں ، ہم دونوں صفوں اور عنصر کے حساب سے دونوں کا نتیجہ پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق مکعب کا حساب لگائیں۔",
        "Answer": "کسی دوسرے عنصر کے لحاظ سے ایک نمی سرنی کو گھٹا دینے کے ل you ، آپ - آپریٹر استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ numpy as nparray1 = np.array ([4 ، 6 ، 8]) array2 = np.array ([1 ، 3 ، 5]) نتیجہ = array1 - array2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر کے مطابق گھٹاؤ:\" ، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈرری 1: [4 6 8] سرنی 2: [1 3 5] عنصر کے مطابق گھٹاؤ: [3 3 3 3] اس کوڈ میں ، ہم بالترتیب عناصر [4 ، 6 ، 8] اور [1 ، 3 ، 5] کے ساتھ دو نپی سرنی ، سرنی 1 اور سرنی 2 بناتے ہیں۔اس کے بعد ہم - آپریٹر کا استعمال کرتے ہوئے اری 1 سے اری 2 کے عنصر کے حساب سے گھٹاؤ انجام دیتے ہیں ، اور نتیجہ کو متغیر میں اسٹور کرتے ہیں۔- آپریٹر عنصر کے مطابق گھٹاؤ انجام دیتا ہے ، جس کا مطلب ہے کہ یہ اری 1 سے اری 2 کے اسی عناصر کو گھٹا دیتا ہے۔آخر میں ، ہم دونوں صفوں اور عنصر کے حساب سے گھٹاؤ کے نتیجے میں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق مکعب کی جڑ کا حساب لگائیں۔",
        "Answer": "عنصر کے لحاظ سے دو numpy صفوں کو ضرب کرنے کے ل you ، آپ * آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([2 ، 3 ، 4]) array2 = np.array ([5 ، 6 ، 7]) نتیجہ = array1 * array2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر کے مطابق ضرب:\" ، نتیجہ) آؤٹ پٹ: لیس کاپی کوڈرری 1: [2 3 4] سرنی 2: [5 6 7] عنصر کے لحاظ سے ضرب: [10 18 18 28] اس کوڈ میں ، ہم بالترتیب عناصر [2 ، 3 ، 4] اور [5 ، 6 ، 7] کے ساتھ دو نپی سرنی ، سرنی 1 اور سرنی 2 بناتے ہیں۔اس کے بعد ہم * آپریٹر کا استعمال کرتے ہوئے دونوں صفوں کے عنصر کے حساب سے ضرب کرتے ہیں ، اور نتیجہ کو متغیر میں اسٹور کرتے ہیں۔* آپریٹر عنصر کے مطابق ضرب انجام دیتا ہے ، جس کا مطلب ہے کہ یہ دونوں صفوں کے اسی عناصر کو ایک ساتھ مل کر بڑھاتا ہے۔آخر میں ، ہم دونوں صفوں اور عنصر کے حساب سے ضرب کے نتائج کو پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگائیں۔",
        "Answer": "ایک نمی سرنی کو دوسرے عنصر کے لحاظ سے تقسیم کرنے کے ل you ، آپ / آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([10 ، 15 ، 20]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = array1 / arry2 پرنٹ (\"سرنی 1:\" ، سرنی 1)پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"عنصر وار ڈویژن:\" ، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈرری 1: [10 15 20] سرنی 2: [2 3 4] عنصر کے مطابق تقسیم: [5۔5. 5.] اس کوڈ میں ، ہم بالترتیب عناصر [10 ، 15 ، 20] اور [2 ، 3 ، 4] کے ساتھ ، دو نپی سرنی ، سرنی 1 اور اری 2 تیار کرتے ہیں۔اس کے بعد ہم / آپریٹر کا استعمال کرتے ہوئے اری 2 کے ذریعہ اری 1 کی عنصر وار ڈویژن انجام دیتے ہیں ، اور نتیجہ متغیر میں نتیجہ کو اسٹور کرتے ہیں۔/ آپریٹر عنصر کے مطابق تقسیم انجام دیتا ہے ، یعنی یہ اری 1 کے اسی عناصر کو اری 2 کے ذریعہ تقسیم کرتا ہے۔آخر میں ، ہم دونوں صفوں اور عنصر کے حساب سے تقسیم کے نتائج کو پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق الٹا ٹینجنٹ کا حساب لگائیں۔",
        "Answer": "کسی نمی سرنی کے عنصر وار مربع جڑ کا حساب لگانے کے ل you ، آپ NP.SQRT () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([4 ، 9 ، 16]) نتیجہ = np.sqrt (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر کے مطابق مربع جڑ:\" ، \"،\" ، \"نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [4 9 16] عنصر کے مطابق مربع جڑ: [2۔3. 4.] اس کوڈ میں ، ہم عناصر [4 ، 9 ، 16] کے ساتھ سرنی نامی ایک نپی سرنی بناتے ہیں۔اس کے بعد ہم سرنی کے عنصر وار مربع جڑ کا حساب لگانے کے لئے NP.SQRT () فنکشن کا استعمال کرتے ہیں۔NP.SQRT () فنکشن ہر عنصر کے مربع جڑ کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور عنصر کے حساب سے مربع جڑ کا نتیجہ دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "\"ایک نمی صف کو دیکھتے ہوئے ، 0 اور 1 کے درمیان اپنی اقدار کو معمول پر لانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر کے حساب سے حساب کتاب کرنے کے ل you ، آپ NP.EXP () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.Array ([1 ، 2 ، 3]) نتیجہ = np.exp (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر کے مطابق کفایت شعاری:\" ، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 2 3] عنصر کے لحاظ سے کفایت شعاری: [2.71828183 7.3890561 20.08553692] اس کوڈ میں ، ہم عناصر کے ساتھ سرنی نامی ایک نمی سرے بناتے ہیں [1 ، 2 ، 3]۔اس کے بعد ہم سرنی کے عنصر کے حساب سے حساب کتاب کرنے کے لئے NP.EXP () فنکشن کا استعمال کرتے ہیں۔NP.EXP () فنکشن ہر عنصر کی صریح کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور عنصر کے لحاظ سے صریح نتیجہ دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "دیئے گئے وزن کی بنیاد پر ایک نمی سرنی کے وزن کی اوسط کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نمی سرنی کے عنصر کے مطابق لوگرتھم (بیس 10) کا حساب لگانے کے ل you ، آپ NP.log10 () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 10 ، 100]) نتیجہ = np.log10 (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر کے مطابق لوگرتھم (بیس 10): \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 10 100] عنصر کے مطابق لوگرتھم (بیس 10): [0۔1. 2.] اس کوڈ میں ، ہم عناصر [1 ، 10 ، 100] کے ساتھ سرنی نامی ایک نپی سرنی بناتے ہیں۔اس کے بعد ہم سرنی کے عنصر کے حساب سے لاجارتھم (بیس 10) کا حساب لگانے کے لئے NP.log10 () فنکشن کا استعمال کرتے ہیں۔NP.LOG10 () فنکشن ہر عنصر کے لوگرتھم (بیس 10) کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور عنصر کے حساب سے دونوں لاگ ان (بیس 10) کے نتائج دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق مجموعی مصنوعات کی گنتی کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق سائن کا حساب لگانے کے ل you ، آپ NP.SIN () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([0 ، np.pi/2 ، np.pi]) نتیجہ = np.sin (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر-عقلمند سائن: \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [0۔1.57079633 3.14159265] عنصر کے مطابق سائن: [0.00000000E+00 1.00000000E+00 1.22464680E-16] اس کوڈ میں ، ہم عناصر کے ساتھ سرے کے نام سے ایک نام کی صف تیار کرتے ہیں [0 ، NP.PI/2 ، NP.PI]۔اس کے بعد ہم سرنی کے عنصر وار سائن کا حساب لگانے کے لئے NP.SIN () فنکشن کا استعمال کرتے ہیں۔NP.SIN () فنکشن ہر عنصر کے سائن کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور عنصر کے حساب سے دونوں کا نتیجہ دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیا گیا ، قطار کے حساب سے اور کالم وار رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر وار کوسائن کا حساب لگانے کے ل you ، آپ NP.COS () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([0 ، np.pi/2 ، np.pi]) نتیجہ = np.cos (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"عنصر-عقلمند کوسائن: \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [0۔1.57079633 3.14159265] عنصر کے مطابق کوسائن: [1.000000E+00 6.123234E-17 -1.000000E+00] اس کوڈ میں ، ہم عناصر کے ساتھ ایک نام کی سرنی کرتے ہیں [0 ، NP.PI/2 ، NP.PI]۔اس کے بعد ہم سرنی کے عنصر وار کوسائن کا حساب لگانے کے لئے NP.COS () فنکشن کا استعمال کرتے ہیں۔NP.COS () فنکشن ہر عنصر کی کوسائن کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور عنصر کے حساب سے کوسائن کے نتائج دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "کسی نمی سرنی میں کسی خاص قدر کے پہلے واقعے کا انڈیکس تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق ٹینجینٹ کا حساب لگانے کے ل you ، آپ NP.TAN () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([0 ، np.pi/4 ، np.pi/2]) نتیجہ = np.tan (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"عنصر کے مطابق ٹینجینٹ: \"، نتیجہ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [0۔0.78539816 1.57079633] عنصر کے مطابق ٹینجینٹ: [0.00000000E+00 1.00000000E+00 1.63312394E+16] اس کوڈ میں ، ہم عناصر کے ساتھ سرے کے نام سے ایک ناممری صف تیار کرتے ہیں [0 ، NP.PI/4 ، NP.PI/2]اس کے بعد ہم سرنی کے عنصر وار ٹینجینٹ کا حساب لگانے کے لئے NP.TAN () فنکشن کا استعمال کرتے ہیں۔NP.TAN () فنکشن ہر عنصر کے ٹینجنٹ کے ساتھ ایک نئی صف لوٹاتا ہے۔آخر میں ، ہم اصل سرنی اور عنصر کے حساب سے ٹینجینٹ نتیجہ دونوں پرنٹ کرتے ہیں۔نوٹ کریں کہ اس کا نتیجہ فلوٹنگ پوائنٹ نمبروں کی ایک نمی صف ہے۔"
    },
    {
        "Question": "\"دو نمی سرنیوں کو دیکھتے ہوئے ، ان کے مابین کوسائن مماثلت کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "4 قطاروں اور 5 کالموں کے ساتھ 2D سرنی میں 1D numpy سرنی کو نئی شکل دینے کے ل you ، آپ NP.reshape () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray_1d = np.array ([1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، 10 ، 11 ، 12 ، 13 ، 14 ، 15 ، 16 ، 17 ، 18 ، 18.کوڈورجینل 1 ڈی سرنی: [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 18 19 20] دوبارہ تیار شدہ 2 ڈی سرنی: [[1 2 3 4 5] [6 7 8 9 10] [11 12 13 1415] [16 17 18 19 19 20]] اس کوڈ میں ، ہم پہلے 20 عناصر کے ساتھ Array_1d کے نام سے ایک 1D numpy صف تیار کرتے ہیں۔اس کے بعد ہم 1D سرنی کو 4 قطاروں اور 5 کالموں کے ساتھ 2D سرنی میں دوبارہ تشکیل دینے کے لئے NP.reshape () فنکشن کا استعمال کرتے ہیں۔NP.reshape () کی پہلی دلیل اصل صف ہے ، اور دوسری دلیل ٹوپل (4 ، 5) کے طور پر نتیجے میں ہونے والی صف کی مطلوبہ شکل کی وضاحت کرتی ہے۔آخر میں ، ہم دونوں اصل 1D سرنی اور دوبارہ تیار کردہ 2D سرنی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک فنکشن لکھیں تاکہ یوکلیڈین فاصلے کا حساب کتاب کریں جس میں دو نکات کے درمیان نمی اریوں کی نمائندگی کی جائے۔",
        "Answer": "2D numpy صف سے اخترن عناصر کو نکالنے کے ل you ، آپ NP.Diagonal () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray_2d = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]]) ڈایگونل_لیمنٹس = این پی ڈیاگونل (سرنی_2 ڈی) پرنٹ (پرنٹ (\"اصل 2 ڈی سرنی:\") پرنٹ (سرنی_2 ڈی) پرنٹ (\"\\ ndiagonal عناصر:\") پرنٹ (ڈایگونل_یلیمنٹس) آؤٹ پٹ: Luacopy کوڈورجینل 2 ڈی سرنی: [[1 2 3] [4 5 6] [7 8 9]] اخترن عناصر.اس کے بعد ہم سرے سے اخترن عناصر نکالنے کے لئے NP.Diagonal () فنکشن کا استعمال کرتے ہیں۔NP.Diagonal () فنکشن ایک 1D سرنی واپس کرتا ہے جس میں اخترن عناصر شامل ہیں۔آخر میں ، ہم اصل 2D سرنی اور نکالے ہوئے اخترن عناصر دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، ونڈو کے ایک مخصوص سائز کی چلتی اوسط کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک نپی سرنی کی شکل حاصل کرنے کے ل you ، آپ .shape وصف استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) شکل = سرنی.شپ پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"shap nshape: \"، شکل) آؤٹ پٹ: Luacopy CodeArray: [[1 2 3] [4 5 6]] شکل: (2 ، 3) اس کوڈ میں ، ہم طول و عرض 2x3 کے ساتھ سرنی نامی ایک 2D numpy صف تیار کرتے ہیں۔اس کے بعد ہم سرنی کے شپ وصف تک رسائی حاصل کرتے ہیں ، جو صف کی شکل کی نمائندگی کرنے والے ایک ٹپل کو لوٹاتا ہے۔اس معاملے میں ، شکل ٹپل (2 ، 3) ہے ، جس سے یہ ظاہر ہوتا ہے کہ صف میں 2 قطار اور 3 کالم ہیں۔آخر میں ، ہم اصل سرنی اور اس کی شکل دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق لاگ ان فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نمی سرنی کے طول و عرض کی تعداد حاصل کرنے کے ل you ، آپ .ndim وصف استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) num_dimensions = array.ndimprint (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"پرنٹ (\"time n طول و عرض کی تعداد: \"، num_dimensions) آؤٹ پٹ: Luacopy CodeArray: [[1 2 3] [4 5 6]] طول و عرض کی تعداد: 2 اس کوڈ میں ، ہم طول و عرض 2x3 کے ساتھ سرنی نامی ایک 2d numpy سرنی بناتے ہیں۔اس کے بعد ہم سرنی کے .ndim وصف تک رسائی حاصل کرتے ہیں ، جو صف کے طول و عرض کی تعداد کو لوٹاتا ہے۔اس معاملے میں ، Num_dimension متغیر کو 2 پر سیٹ کیا جائے گا ، جس سے یہ ظاہر ہوتا ہے کہ سرنی کی دو جہت ہیں۔آخر میں ، ہم اصل سرنی اور طول و عرض کی تعداد دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، صف کی خود کشی کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "اعداد و شمار کی قسم کے عناصر کو ایک نمی سرنی میں حاصل کرنے کے ل you ، آپ .dtype وصف کو استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) dtype = array.dtypeprint (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ ndata قسم:\" ، ،ڈی ٹائپ) آؤٹ پٹ: یاملکپی کوڈرری: [1 2 3 4 4 5] ڈیٹا کی قسم: انٹ 644 اس کوڈ میں ، ہم عناصر کے ساتھ سرنی نامی ایک 1 ڈی نیپی سرنی بناتے ہیں [1 ، 2 ، 3 ، 4 ، 5]۔اس کے بعد ہم سرنی کے .dtype وصف تک رسائی حاصل کرتے ہیں ، جو صف میں عناصر کے ڈیٹا کی قسم کو لوٹاتا ہے۔اس معاملے میں ، DTYPE متغیر کو INT64 پر سیٹ کیا جائے گا ، جس سے یہ ظاہر ہوتا ہے کہ صف میں موجود عناصر میں ڈیٹا کی قسم 64 بٹ عدد ہے۔آخر میں ، ہم اصل سرنی اور ڈیٹا کی قسم دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "کسی مخصوص محور کے ساتھ ایک نمی سرنی کے عنصر کے مطابق مجموعی مجموعی کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "عمودی طور پر (قطاروں کے ساتھ ساتھ) دو نپی سرنیوں کو جوڑنے کے ل you ، آپ NP.vstack () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) سرنی 2 = np.array ([[7 ، 8 ، 9] ، [10 ، [10 ،11 ، 12]]) نتیجہ = np.vstack ((array1 ، array2)) پرنٹ (\"سرنی 1:\") پرنٹ (سرنی 1) پرنٹ (\"\\ نارتھ 2:\") پرنٹ (array2) پرنٹ (\"\\ nconcated سرنی:\") پرنٹ (نتیجہ) آؤٹ پٹ: Luacopy CodeArray 1: [[1 2 3] [4 5 6]] سرنی 2: [[7 8 9] [10 11 12]] مشترکہ سرنی: [[1 2 3] [45]] [7 8 9] [10 11 12]] اس کوڈ میں ، ہم ایک ہی تعداد میں کالموں کے ساتھ اری 1 اور اری 2 نامی دو 2 ڈی نیپی آریاں بناتے ہیں۔اس کے بعد ہم np.vstack () فنکشن کو عمودی طور پر ایک ساتھ اسٹیک کرنے کے لئے استعمال کرتے ہیں ، جس کے نتیجے میں ایک نئی کنکیٹیٹڈ صف ہوتی ہے۔NP.Vstack () فنکشن ٹوپل (array1 ، array2) کے اندر دلائل کے طور پر صفوں کو لیتا ہے۔آخر میں ، ہم دونوں اصل صفوں اور مشترکہ سرنی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، مخصوص فیصد پر صد فیصد اقدار کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "افقی طور پر (کالموں کے ساتھ ساتھ) دو numpy صفوں کو ہم آہنگ کرنے کے ل you ، آپ NP.hstack () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([[1 ، 2] ، [3 ، 4]]) سرنی 2 = np.array ([[5 ، 6] ، [7 ، 8]]) نتیجہ =np.hstack ((array1 ، array2)) پرنٹ (\"سرنی 1:\") پرنٹ (array1) پرنٹ (\"\\ نارتھ 2:\") پرنٹ (array2) پرنٹ (\"\\ n concatenated سرنی:\") پرنٹ (نتیجہ) آؤٹ پٹ:Luacopy Codearray 1: [[1 2] [3 4]] سرنی 2: [[5 6] [7 8]] مشترکہ سرنی: [[1 2 5 6] [3 4 7 8]] اس کوڈ میں ، ہم تخلیق کرتے ہیںدو 2 ڈی نیپی سرنیوں کو ایک ہی تعداد میں قطار کے ساتھ اری 1 اور اری 2 کہتے ہیں۔اس کے بعد ہم NP.HSTACK () فنکشن کو افقی طور پر صفوں کو ایک ساتھ اسٹیک کرنے کے لئے استعمال کرتے ہیں ، جس کے نتیجے میں ایک نئی کنکیٹیٹڈ صف ہوتی ہے۔NP.HSTACK () فنکشن ٹوپل (array1 ، array2) کے اندر دلائل کے طور پر صفوں کو لیتا ہے۔آخر میں ، ہم دونوں اصل صفوں اور مشترکہ سرنی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے مطابق سگمائڈ فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "عمودی طور پر (قطاروں کے ساتھ ساتھ) ایک سے زیادہ ذیلی اریوں میں ایک نمی سرنی کو تقسیم کرنے کے ل you ، آپ NP.vsplit () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3 ، 4] ، [5 ، 6 ، 7 ، 8] ، [9 ، 10 ، 11 ، 12]]) sub_arrays = np.vsplit (سرنی ، 3) پرنٹ (\"اصل سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ nsub-arrays:\") sub_array کے لئے sub_array کے لئے: پرنٹ (سب_اری) آؤٹ پٹ: Luacopy کوڈورجینل سرنی: [[1 2 3 4][5 6 6 7 8] [9 10 11 12]] ذیلی ایریز: [[1 2 3 4]]] [[5 6 7 8]] [[9 10 11 12]] اس کوڈ میں ، ہم 2 ڈی نپی تیار کرتے ہیںسرنی کو طول و عرض 3x4 کے ساتھ سرنی کہا جاتا ہے۔اس کے بعد ہم سرنی کو عمودی طور پر متعدد ذیلی عبور میں تقسیم کرنے کے لئے NP.vsplit () فنکشن کا استعمال کرتے ہیں۔NP.VSPLIT () فنکشن دو دلائل لیتا ہے: اصل صف اور بنانے کے لئے یکساں سائز کے ذیلی اریوں کی تعداد۔اس معاملے میں ، ہم سرنی کو 3 ذیلی اراضی میں تقسیم کرتے ہیں ، جس کے نتیجے میں تین 1d صفیں ہوتی ہیں۔آخر میں ، ہم ایک لوپ کا استعمال کرتے ہوئے ایک ایک کرکے اصل سرنی اور ذیلی عادی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، صف کے موڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "افقی طور پر (کالموں کے ساتھ ساتھ) ایک سے زیادہ ذیلی اریوں میں ایک نمی سرنی کو تقسیم کرنے کے ل you ، آپ NP.HSplit () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3 ، 4] ، [5 ، 6 ، 7 ، 8] ، [9 ، 10 ، 11 ، 12]]) sub_arrays = np.Hsplit (سرنی ، 2) پرنٹ (\"اصل سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ nsub-arrays:\") سب_ریری کے لئے سب_آرے میں: پرنٹ (سب_ریری) آؤٹ پٹ: Luacopy کوڈورجینل سرنی: [[1 2 3 4][5 6 7 7 8] [9 10 11 12]] ذیلی عادی: [[1 2] [5 6] [9 10]] [[3 4] [7 8] [11 12]] اس کوڈ میں ، ہمطول و عرض 3x4 کے ساتھ سرنی نامی ایک 2D نپی سرنی بنائیں۔اس کے بعد ہم NP.HSplit () فنکشن کو افقی طور پر سرنی کو متعدد ذیلی خطوں میں تقسیم کرنے کے لئے استعمال کرتے ہیں۔NP.HSPLIT () فنکشن دو دلائل لیتا ہے: اصل صف اور بنانے کے لئے یکساں سائز کے ذیلی اریوں کی تعداد۔اس معاملے میں ، ہم سرنی کو 2 ذیلی سرے میں تقسیم کرتے ہیں ، جس کے نتیجے میں دو 2 ڈی صفیں ہوتی ہیں ، ہر ایک کی اصل صفوں کی طرح قطار کی ایک ہی تعداد ہوتی ہے۔آخر میں ، ہم ایک لوپ کا استعمال کرتے ہوئے ایک ایک کرکے اصل سرنی اور ذیلی عادی دونوں پرنٹ کرتے ہیں۔"
    },
    {
        "Question": "ایک نمی سرنی کے عنصر کے حساب سے حساب کتاب کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو numpy صفوں کے مابین عنصر کے حساب سے موازنہ کرنے کے ل you ، آپ مختلف موازنہ آپریٹرز یا افعال استعمال کرسکتے ہیں۔یہاں کچھ مثالیں ہیں: موازنہ آپریٹرز (<، <= ،> ،> = ، == ،! =) کا استعمال کرتے ہوئے: pythoncopy کوڈیمپورٹ numpy as nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array (([1 ، 2 ، 3]) ([1 ، 2 ، 3]).3] سرنی 2: [2 2 2] نتیجہ: [سچ جھوٹا غلط] اس مثال میں ، ہم <آپریٹر کا استعمال کرتے ہوئے اری 2 میں متعلقہ عنصر کے ساتھ اری 1 کے ہر عنصر کا موازنہ کرتے ہیں۔نتیجے میں صف کے نتیجے میں عنصر کے مطابق موازنہ کے نتائج ہوتے ہیں ، جہاں سچ اشارہ ہوتا ہے کہ اری 1 میں متعلقہ عنصر اری 2 میں متعلقہ عنصر سے کم ہے۔) ، np.greater_equal () ، np.equal () ، np.not_equal ()): pythoncopy کوڈیمپورٹ numpy as nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([2 ، 2 ،2]) نتیجہ = np.less (array1 ، array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"نتیجہ:\" ، نتیجہ) آؤٹ پٹ: SQLCOPY CodeArray 1: [12 3] سرنی 2: [2 2 2] نتیجہ: [سچ جھوٹا غلط] اس مثال میں ، ہم array1 اور array2 کے مابین عنصر کے حساب سے موازنہ کرنے کے لئے NP.less () فنکشن کا استعمال کرتے ہیں۔نتیجے میں سرنی کے نتیجے میں عنصر کے مطابق موازنہ کے نتائج ہوتے ہیں ، جہاں سچ اشارہ ہوتا ہے کہ اری 1 میں متعلقہ عنصر اری 2 میں متعلقہ عنصر سے کم ہے۔گریٹر () ، np.greater_equal () ، np.equal () ، np.not_equal ()) دو numpy صفوں کے مابین مختلف عنصر کے مطابق موازنہ انجام دینے کے لئے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، ونڈو کے ایک مخصوص سائز کے چلتے ہوئے میڈین کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ان اشاریہ کو تلاش کرنے کے لئے جہاں دو نمی صفوں کے عناصر برابر ہیں ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3 ، 4]) array2 = np.array ([3 ، 2 ، 1 ، 4]) اشارے = np. where (array1 == array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"اشارے:\" ، اشارے) آؤٹ پٹ: لیس کوپی کوڈرری 1: [1 2 3 4] سرنی 2: [3 2 1 4] اشارے: (سرنی ([1 ، 3]]) ،) اس مثال میں ، ہم اری 1 اور اری 2 کے عناصر کا موازنہ کرنے کے لئے == آپریٹر کا استعمال کرتے ہیں۔NP. Where () فنکشن صفوں کا ایک ٹپل لوٹاتا ہے جس میں اشارے ہوتے ہیں جہاں موازنہ درست ہے۔اس معاملے میں ، انڈیکس 1 اور 3 کے عناصر دونوں صفوں میں برابر ہیں۔آؤٹ پٹ (سرنی ([1 ، 3])) ، اس بات کی نشاندہی کرتا ہے کہ جن اشارے جہاں عناصر برابر ہیں 1 اور 3. نوٹ کریں کہ NP.Where () () ایک ٹوپل اریوں کو لوٹاتا ہے کیونکہ یہ متعدد جہتوں اور شرائط کو سنبھال سکتا ہے۔اگر آپ کے پاس متعدد شرائط یا صفیں ہیں تو ، آپ ان صفوں میں اسی عناصر تک رسائی کے ل the اشاریہ استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "کسی نمی سرنی کے عنصر کے مطابق سافٹ میکس فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ان اشاریہ کو تلاش کرنے کے لئے جہاں ایک نمی سرنی کے عناصر ایک مخصوص قیمت سے زیادہ ہوتے ہیں ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 5 ، 3 ، 7 ، 2]) ویلیو = 3 انڈیکس = np.where (سرنی> ویلیو) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"پرنٹ (\" پرنٹ (\"قیمت: \"، ویلیو) پرنٹ (\" اشاریہ: \"، انڈیکس) آؤٹ پٹ: میک فیلیکوپی کوڈرری: [1 5 3 7 2] ویلیو: 3 انڈیکس: (سرنی ([1 ، 3])) ،) اس مثال میں ، ہم ہر عنصر کا موازنہ کرتے ہیں> آپریٹر کا استعمال کرتے ہوئے ویلیو 3 کے ساتھ صف کی۔NP. Where () فنکشن صفوں کا ایک ٹپل لوٹاتا ہے جس میں اشارے ہوتے ہیں جہاں موازنہ درست ہے۔اس معاملے میں ، انڈیکس 1 اور 3 کے عناصر مخصوص قیمت 3 سے زیادہ ہیں۔آپ اس نقطہ نظر کو انڈیکس تلاش کرنے کے ل use استعمال کرسکتے ہیں جہاں کسی نمی سرنی کے عناصر کسی بھی مطلوبہ حالت کو پورا کرتے ہیں ، جیسے ایک مخصوص قیمت سے کم ، برابر ، وغیرہ سے کم ، سے کم ہونا۔"
    },
    {
        "Question": "\"2 ڈی نپی سرنی کو دیا گیا ، صف کے کوویرینس میٹرکس کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایسے اشارے تلاش کرنے کے لئے جہاں کسی نام کی سرنی کے عناصر کسی دی گئی حالت کو پورا کرتے ہیں ، آپ NP.Where () فنکشن استعمال کرسکتے ہیں۔NP. Where () فنکشن اشاریہ پر مشتمل صفوں کا ایک ٹپل لوٹاتا ہے جہاں دی گئی حالت درست ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 5 ، 3 ، 7 ، 2]) حالت = سرنی ٪ 2 == 0 indices = np.where (حالت) پرنٹ (\"سرنی:\" ، سرنی)پرنٹ (\"حالت:\" ، حالت) پرنٹ (\"اشاریہ:\" ، اشاریہ) آؤٹ پٹ: SQLCOPY CODEARRAY: [1 5 3 7 2] حالت: [غلط جھوٹے غلط جھوٹے سچ] اشارے: (سرنی ([[4]) ،)اس مثال میں ، ہم ماڈیولو آپریٹر ٪ کا استعمال کرتے ہوئے ایک شرط کی وضاحت کرتے ہیں تاکہ یہ چیک کیا جاسکے کہ آیا سرنی کے عناصر یہاں تک ہیں یا نہیں (سرنی ٪ 2 == 0)۔حالت بولین سرنی کا جائزہ لیتی ہے جہاں سچ اس بات کی نشاندہی کرتا ہے کہ متعلقہ عنصر حالت کو پورا کرتا ہے۔اس کے بعد NP.Where () فنکشن کا استعمال ان اشاریہ کو تلاش کرنے کے لئے کیا جاتا ہے جہاں حالت درست ہے۔آؤٹ پٹ (سرنی ([4])) ، اس بات کی نشاندہی کرتا ہے کہ انڈیکس 4 میں عنصر حالت کو پورا کرتا ہے۔ آپ اپنی مخصوص ضروریات کے مطابق حالت میں ترمیم کرسکتے ہیں۔مثال کے طور پر ، آپ اپنی حالت کی وضاحت کے لئے موازنہ آپریٹرز (<، <= ،> ،> = ، == ،!) یا کسی اور منطقی یا ریاضی کی کارروائیوں کا استعمال کرسکتے ہیں۔NP. Where () فنکشن انڈیکس کو واپس کردے گا جہاں حالت مطمئن ہے۔"
    },
    {
        "Question": "نیوٹن کے طریقہ کار کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر وار مربع جڑ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک مخصوص ڈیٹا کی قسم کے ساتھ ایک نمی سرنی بنانے کے ل you ، آپ سرے کی تخلیق کرتے وقت DTYPE پیرامیٹر استعمال کرسکتے ہیں۔ڈی ٹائپ پیرامیٹر آپ کو صف کے ل data مطلوبہ ڈیٹا کی قسم کی وضاحت کرنے کی اجازت دیتا ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ڈیٹا کی قسم 'int'array_int = np.array ([1 ، 2 ، 3] ، dtype = int) کے ساتھ ایک نپی سرنی بنائیں ([1 ، 2 ، 3] ، dtype = int)'سرنی_فلوٹ = np.array ([1.0 ، 2.0 ، 3.0] ، dtype = فلوٹ) پرنٹ (\"انٹ ڈیٹا کی قسم کے ساتھ صف:\" ، سرنی_ٹ) پرنٹ (\"array_int کی ڈیٹا کی قسم:\" ، array_int.dtype) پرنٹ () پرنٹ () پرنٹ () پرنٹ۔: [1.2. 3.] اعداد و شمار کی قسم Array_float: Flot64in اس مثال کے طور پر ، ہم مختلف ڈیٹا کی اقسام کے ساتھ دو numpy صف تیار کرتے ہیں۔پہلی سرنی سرنی_ٹ انٹ ڈیٹا کی قسم کے ساتھ تشکیل دی گئی ہے جس کو INT کے طور پر مخصوص کیا گیا ہے ، جبکہ دوسری سرنی سرنی_فلوٹ فلوٹ کے طور پر مخصوص ڈیٹا ٹائپ کے ساتھ تشکیل دی گئی ہے۔ڈی ٹائپ پیرامیٹر اس بات کو یقینی بناتا ہے کہ صفوں کے عناصر مخصوص ڈیٹا کی قسم کے ہوں۔آؤٹ پٹ میں ، آپ صفوں اور ان کے متعلقہ اعداد و شمار کی اقسام کو دیکھ سکتے ہیں۔ آپ ڈی ٹائپ پیرامیٹر کا استعمال کرتے ہوئے مطلوبہ ڈیٹا کی قسم کی وضاحت کرکے مختلف ڈیٹا کی قسموں کی صفیں بنانے کے لئے ، ڈیٹا کی دیگر اقسام جیسے BOOL ، STR ، پیچیدہ ، وغیرہ استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کے ذریعہ ، سرنی کے شینن اینٹروپی کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک نپی سرنی کو ازگر کی فہرست میں تبدیل کرنے کے ل you ، آپ نپی سرنی کے ٹولسٹ () طریقہ استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) لسٹ_آرے = سرنی۔ ٹولسٹ () پرنٹ (\"نیمپی سرنی:\" ، سرنی) پرنٹ (\"تبدیل شدہ فہرست:\"، فہرست_آرے) آؤٹ پٹ: لیس کوپی کوڈینمپی سرنی: [1 2 3 4 4 5] تبدیل شدہ فہرست: [1 ، 2 ، 3 ، 4 ، 5] اس مثال میں ، ہمارے پاس ایک نمی سرنی ہے جس میں عددی ہے جس میں عددی ہے۔نپی سرنی پر ٹولسٹ () کے طریقہ کار کو کال کرکے ، ہم صف کی ایک ازگر کی فہرست کی نمائندگی حاصل کرتے ہیں ، جو متغیر فہرست_اری کو تفویض کیا جاتا ہے۔اس کے بعد تبدیل شدہ فہرست پرنٹ کی جاتی ہے۔ ٹولسٹ () کا طریقہ کار نپی سرنی کو ایک نیسٹڈ فہرست میں تبدیل کرتا ہے ، جہاں صف کا ہر عنصر نتیجے کی فہرست میں عنصر بن جاتا ہے۔نتیجے میں فہرست اسی ترتیب اور اقدار کو برقرار رکھتی ہے جیسے اصل نمی سرنی۔ یہ ذہن میں رکھیں کہ ایک بڑی نمی سرنی کو ازگر کی فہرست میں تبدیل کرنے سے زیادہ میموری استعمال ہوسکتی ہے ، کیونکہ فہرستیں عام طور پر نیمپی صفوں سے کم میموری سے موثر ہوتی ہیں۔"
    },
    {
        "Question": "عنصر کے لحاظ سے مطلق فرق کو دو نمی صفوں کے درمیان حساب کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ازگر کی فہرست کو ایک نمی سرنی میں تبدیل کرنے کے ل you ، آپ NP.Array () فنکشن استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور npmy_list = [1 ، 2 ، 3 ، 4 ، 5] numpy_array = np.array (my_list) پرنٹ (\"ازگر کی فہرست:\" ، my_list) پرنٹ (\"تبدیل شدہ numpy سرنی:\" ، numpy_array)آؤٹ پٹ: لیس کوپی کوڈپائٹن کی فہرست: [1 ، 2 ، 3 ، 4 ، 5] تبدیل شدہ نپی سرنی: [1 2 3 4 4 5] اس مثال میں ، ہمارے پاس ایک ازگر کی فہرست ہے جس میں My_list کہا جاتا ہے جس میں عددی ہوتا ہے۔فہرست کو NP.Array () فنکشن میں منتقل کرکے ، ہم فہرست سے ایک numpy سرنی numpy_array تشکیل دیتے ہیں۔اس کے بعد تبدیل شدہ numpy سرنی پرنٹ کیا جاتا ہے۔ NP.Array () فنکشن ازگر کی فہرست کو ایک نمی سرنی میں تبدیل کرتا ہے ، جس کی فہرست کا ہر عنصر نتیجے میں ہونے والی صف میں عنصر بن جاتا ہے۔نتیجے میں سرنی ایک ہی ترتیب اور اقدار کو برقرار رکھتی ہے جیسا کہ اصل ازگر کی فہرست ہے۔ نمی سرنیوں نے ازگر کی فہرستوں سے مختلف فوائد پیش کیے ہیں ، جن میں موثر اسٹوریج ، عنصر کے مطابق آپریشن ، اور وسیع ریاضی کی خصوصیات شامل ہیں۔ازگر کی فہرست کو ایک نمی سرنی میں تبدیل کرنے سے آپ عددی کمپیوٹوں اور ڈیٹا کی ہیرا پھیری کے ل these ان فوائد کو فائدہ اٹھانے کی اجازت دیتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، صف کے عنصر کے مطابق مکعب کی جڑ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی ٹیکسٹ فائل میں ایک نمی سرنی کو بچانے کے ل you ، آپ NP.Savetxt () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]]) np.savetxt ('array_data.txt' ، سرنی) پرنٹ (\"numpy سرے محفوظ ہوا'array_data.txt' فائل۔ \") اس مثال میں ، ہمارے پاس شکل (2 ، 3) کے ساتھ سرنی کہا جاتا ہے۔np.savetxt ('array_data.txt' ، سرنی) کو کال کرکے ، ہم 'array_data.txt' نامی ایک ٹیکسٹ فائل میں صف کو محفوظ کرتے ہیں۔ٹیکسٹ فائل میں موجود ڈیٹا کو وائٹ اسپیس سے الگ الگ اقدار کے طور پر فارمیٹ کیا جائے گا ، جس میں سرنی کی ہر قطار کو الگ لائن کے طور پر پیش کیا جاتا ہے۔مثال کے طور پر ، آپ اقدار کے مابین استعمال ہونے والے حد بندی ، فلوٹنگ پوائنٹ نمبروں کی صحت سے متعلق ، اور فارمیٹ سٹرنگ کو کنٹرول کرسکتے ہیں۔یہاں کچھ اضافی دلائل کے ساتھ ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1.23456789 ، 2.3456789 ، 3.456789] ، [4.567890 ، 5.67890 ، 6.7890]] NP.Savetxt'،' ، fmt = '٪. 2f') پرنٹ (\"numpy سرنی 'array_data.txt' فائل کو محفوظ کیا گیا ہے۔\") اس تازہ ترین مثال میں ، ہم ڈیمیمیٹر = 'کا استعمال کرتے ہوئے اقدار کے مابین ایک کوما (،) کی وضاحت کرتے ہیں ،'.ہم 2 اعشاریہ مقامات کے ساتھ فلوٹنگ پوائنٹ فارمیٹ کی وضاحت کرنے کے لئے ایف ایم ٹی = '٪. 2f' بھی استعمال کرتے ہیں۔نتیجے میں آنے والی ٹیکسٹ فائل میں کوما کے ذریعہ اقدار کو الگ کیا جائے گا اور 2 اعشاریہ مقامات کے ساتھ دکھایا جائے گا۔ پہلے سے طے شدہ ، NP.Savetxt () فنکشن سادہ متن کی شکل کا استعمال کرتے ہوئے صف کو محفوظ کرتا ہے۔اگر آپ کو زیادہ پیچیدہ ڈیٹا ڈھانچے کو بچانے یا اضافی میٹا ڈیٹا کو برقرار رکھنے کی ضرورت ہے تو ، آپ دوسرے فائل فارمیٹس جیسے NUMPY کے .NPY یا .NPZ فارمیٹس ، یا یہاں تک کہ دیگر فائل فارمیٹس کو پانڈوں یا HDF5 جیسی لائبریریوں کے ذریعہ تعاون یافتہ استعمال کرنے پر غور کرسکتے ہیں۔"
    },
    {
        "Question": "عنصر کے مطابق مجموعی طور پر ایک نمی سرنی کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی ٹیکسٹ فائل سے ڈیٹا کو کسی نپی سرنی میں لوڈ کرنے کے ل you ، آپ NP.loadtxt () فنکشن استعمال کرسکتے ہیں۔اس کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور npdata = np.loadtxt ('data.txt') پرنٹ (\"بھری ہوئی ڈیٹا:\") پرنٹ (ڈیٹا) اس مثال میں ، ہم فرض کرتے ہیں کہ آپ کے پاس 'ڈیٹا ڈاٹ ٹی ٹی ایس' کے نام سے ایک ٹیکسٹ فائل ہے۔اس ڈیٹا پر مشتمل ہے جس کو آپ کسی نمی سرنی میں لوڈ کرنا چاہتے ہیں۔NP.Loadtxt () فنکشن فائل سے ڈیٹا کو پڑھتا ہے اور لوڈ شدہ اقدار پر مشتمل ڈیٹا نامی ایک نپی سرنی تیار کرتا ہے۔ پہلے سے طے شدہ ، NP.LoadTxt () یہ فرض کرتا ہے کہ ٹیکسٹ فائل میں وائٹ اسپیس سے الگ الگ اقدار ہیں اور یہ کہ تمام اقدار کی ہیںایک ہی ڈیٹا کی قسم۔تاہم ، آپ اضافی دلائل کی وضاحت کرکے NP.loadtxt () کے طرز عمل کو اپنی مرضی کے مطابق بنا سکتے ہیں۔مثال کے طور پر ، آپ فائل میں استعمال ہونے والے ڈیمیٹر کی وضاحت کرسکتے ہیں ، ہیڈر قطاریں چھوڑ سکتے ہیں ، ڈیٹا کی قسم کی وضاحت کرسکتے ہیں ، اور بہت کچھ۔یہاں ایک مثال ہے جو کچھ اضافی دلائل کو ظاہر کرتی ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور npdata = np.loadtxt ('data.txt' ، ڈیلیمیٹر = '،' ، اسکیپروز = 1 ، dtype = int) پرنٹ (\"بھری ہوئی ڈیٹا:\") پرنٹ (ڈیٹا (\"ڈیٹا) پرنٹ (\") اس تازہ ترین مثال میں ، ہم ایک کوما (،) کو حدود = '،' استعمال کرتے ہوئے اقدار کے مابین حد بندی کے طور پر بیان کرتے ہیں۔ہم فائل کی پہلی قطار کو چھوڑنے کے لئے اسکیپروز = 1 کا بھی استعمال کرتے ہیں (یہ فرض کرتے ہوئے کہ اس میں ہیڈر کی معلومات موجود ہے)۔مزید برآں ، ہم اعداد و شمار کو عددی اقدار کے طور پر لوڈ کرنے کے لئے dtype = انٹ کی وضاحت کرتے ہیں۔ان دلائل کو اپنے ٹیکسٹ فائل کی ساخت اور شکل کے مطابق ایڈجسٹ کریں۔ نوٹ کریں کہ NP.loadtxt () فرض کرتا ہے کہ ٹیکسٹ فائل میں صرف عددی اعداد و شمار موجود ہیں۔اگر آپ کی ٹیکسٹ فائل میں غیر عددی اقدار یا عددی اور غیر عددی اقدار کا مرکب ہوتا ہے تو ، آپ کو لوڈنگ کے عمل کو سنبھالنے کے ل other دوسرے افعال یا لائبریریوں کو استعمال کرنے کی ضرورت پڑسکتی ہے ، جیسے NP.genfromtxt () یا لائبریری جیسے پانڈاس۔"
    },
    {
        "Question": "\"2 ڈی نپی سرنی کو دیا گیا ، صف کے ارتباط میٹرکس کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": ""
    },
    {
        "Question": "",
        "Answer": "ایک نمی سرنی کے سراغ کا حساب لگانے کے لئے ، آپ NP.Trace () فنکشن استعمال کرسکتے ہیں۔مربع میٹرکس کا سراغ اخترن عناصر کے مجموعہ کے طور پر بیان کیا گیا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]]) ٹریس = این پی ٹریس (سرنی) پرنٹ (پرنٹ (سرنی) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"ٹریس:\" ، ٹریس) آؤٹ پٹ: Luacopy CodeArray: [[1 2 3] [4 5 6] [7 8 9]] ٹریس: 15 میں اس مثال کے طور پر ، ہمارے پاس ایک نمی ہےشکل کے ساتھ سرنی سرنی (3 ، 3)NP.Trace (سرنی) کو کال کرکے ، ہم سرنی کے سراغ کا حساب لگاتے ہیں ، جو اس کے اخترن عناصر کا مجموعہ ہے۔نتیجے میں ٹریس ویلیو متغیر ٹریس اور پرنٹ میں محفوظ ہے۔ NP.Trace () فنکشن کو اعلی جہتی صفوں کے سراغ کا حساب لگانے کے لئے بھی استعمال کیا جاسکتا ہے۔جب دو سے زیادہ جہتوں والی صفوں پر اطلاق ہوتا ہے تو ، فنکشن آخری دو محوروں کو ٹھیک کرکے تشکیل شدہ ہر دو جہتی سبری میں اخترن عناصر کا خلاصہ کرتا ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، بٹ وائز آپریشنز کا استعمال کرتے ہوئے صف کے عنصر وار مربع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "دو numpy صفوں کے عنصر کے حساب سے ضرب لگانے کے ل you ، آپ * آپریٹر یا NP.multiply () فنکشن استعمال کرسکتے ہیں۔دونوں نقطہ نظر کا استعمال کرتے ہوئے یہاں ایک مثال ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6])# * آپریٹورسٹولٹ 1 = سرنی 2 استعمال کرتے ہوئے# استعمال کرتے ہوئے# استعمال کرتے ہوئے# استعمال کرتے ہوئے# استعمال کرتے ہوئے#np.multiply () نتیجہ 2 = np.multiply (array1 ، array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"نتیجہ * آپریٹر کا استعمال کرتے ہوئے:\" ، نتیجہ 1) پرنٹ (\"پرنٹ (\" پرنٹ (\"NP.Multiply (): \"، نتیجہ 2) آؤٹ پٹ کا استعمال کرتے ہوئے نتیجہ: SQLCOPY CODEARRAY 1: [1 2 3] سرنی 2: [4 5 6] نتیجہ * آپریٹر کا استعمال کرتے ہوئے: [4 10 18] NP.Multiply () کا استعمال کرتے ہوئے نتیجہ: [[4 10 18] اس مثال کے طور پر ، ہمارے پاس دو نمی اری ، اری 1 اور اری 2 ہیں ، دونوں شکل (3 ،) کے ساتھ ہیں۔ہم * آپریٹر اور NP.Multiply () فنکشن کا استعمال کرتے ہوئے دونوں صفوں کے مابین عنصر کے حساب سے ضرب کرتے ہیں۔نتیجے میں آنے والی صفیں ، نتیجہ 1 اور نتیجہ 2 ، عنصر کے مطابق ضرب والی اقدار پر مشتمل ہیں۔ دونوں آپریٹر اور این پی۔ ملٹی پلائی () صفوں کے مطابق عناصر پر عنصر کے مطابق ضرب لگائیں۔نتیجے میں ہونے والی صف کی شکل ان پٹ اریوں کی طرح ہوگی ، اور ہر عنصر ان پٹ صفوں سے متعلقہ عناصر کی پیداوار ہوگا۔ آپ اپنی ترجیح یا اپنے کوڈ کی مخصوص ضروریات کے مطابق یا تو نقطہ نظر کا استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "عددی استحکام کی تکنیکوں کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر کے مطابق سافٹ میکس فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو numpy صفوں کے میٹرکس ضرب کو انجام دینے کے ل you ، آپ NP.DOT () فنکشن یا @ آپریٹر استعمال کرسکتے ہیں۔یہاں دونوں نقطہ نظر کا استعمال کرتے ہوئے ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([[1 ، 2] ، [3 ، 4]]) سرنی 2 = np.array ([[5 ، 6] ، [7 ، 8]])# np.dot () نتیجہ 1 = np.dot (array1 ، array2)# @ operatorresult2 = array1 @ array2 پرنٹ (\"سرنی 1:\") پرنٹ (سرنی 1) پرنٹ (\"سرنی 2:\") پرنٹ (\"سرنی 2:\") پرنٹ(\"NP.DOT () کا استعمال کرتے ہوئے نتیجہ:\") پرنٹ (نتیجہ 1) پرنٹ (\" @ آپریٹر کا استعمال کرتے ہوئے نتیجہ:\") پرنٹ (نتیجہ 2) آؤٹ پٹ: Luacopy کوڈرری 1: [[1 2] [3 4]] سرنی 2: [[]]] []]]] NP.DOT () کا استعمال کرتے ہوئے نتیجہ: [[19 22] [43 50]] @ آپریٹر کا استعمال کرتے ہوئے نتیجہ: [[19 22] [43 50]] اس مثال میں ، ہمارے پاس دو نمی ہےسرے ، سرنی 1 اور سرنی 2 ، دونوں شکل (2 ، 2) کے ساتھ۔ہم NP.DOT (array1 ، array2) اور array1 @ array2 کا استعمال کرتے ہوئے دونوں صفوں کے مابین میٹرکس ضرب انجام دیتے ہیں۔نتیجے میں ہونے والی صفیں ، نتیجہ 1 اور نتیجہ 2 ، میٹرکس ضرب کے نتائج پر مشتمل ہیں۔ دونوں NP.DOT () فنکشن اور @ آپریٹر ان پٹ صفوں پر میٹرکس ضرب انجام دیتے ہیں۔اس کے نتیجے میں سرنی ان پٹ صفوں کے طول و عرض کی بنیاد پر مناسب شکل ہوگی۔مثال کے طور پر ، اگر arry1 ایک M × n میٹرکس ہے اور array2 ایک n × p میٹرکس ہے تو ، اس کے نتیجے میں سرنی ایک M × p میٹرکس ہے۔ نوٹ کریں گے کہ میٹرکس ضرب کے لئے ، پہلی صف میں کالموں کی تعداد کے برابر ہونا چاہئےدوسری صف میں قطاروں کی تعداد۔اگر ان پٹ صفوں کی شکلیں میٹرکس ضرب کے لئے مطابقت نہیں رکھتی ہیں تو ، ایک ویلی ایرر اٹھایا جائے گا۔ آپ اپنی ترجیح یا آپ کے کوڈ کی مخصوص ضروریات کے مطابق یا تو نقطہ نظر کا استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیا گیا ، سنگل ویلیو سڑن (ایس وی ڈی) کا استعمال کرتے ہوئے صف کے پرنسپل اجزاء کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نپی سرنی میں اسکیلر ویلیو کے عنصر کے حساب سے اضافے کے ل you ، آپ آسانی سے + آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3]) اسکیلر = 5 ریزولٹ = سرنی + اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [1 2 3] اسکیلر: 5 ریزولٹ: [6 7 8] اس مثال میں ، ہمارے پاس شکل (3 ،) کے ساتھ ایک نمی سرنی ہے اور اسکیلر ویلیو اسکیلر 5 کے برابر ہے۔سرنی + اسکیلر کو انجام دینے کے بعد ، اسکیلر کی قیمت سرنی کے ہر عنصر میں شامل کی جاتی ہے ، جس کے نتیجے میں ایک نئی صف کا نتیجہ اسی شکل کے ساتھ ہوتا ہے جس کی اصل صف ہوتی ہے۔سرنی کے ہر عنصر کو انفرادی طور پر اسکیلر ویلیو میں شامل کیا جاتا ہے ، جس سے نتیجہ سرنی میں اسی عنصر کو پیدا ہوتا ہے۔ عنصر کے حساب سے اضافی آپریشن کسی بھی شکل اور جہتی کی اسکیلر اور صفوں کے درمیان انجام دیا جاسکتا ہے ، اور اسکیلر ویلیو کو شامل کیا جائے گا۔اس کے مطابق ہر عنصر۔"
    },
    {
        "Question": "بابل کے طریقہ کار کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر وار مربع جڑ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نپی سرنی سے اسکیلر ویلیو کے عنصر کے حساب سے گھٹاؤ انجام دینے کے ل you ، آپ - آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3]) اسکیلر = 5 ریزولٹ = سرنی - اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [1 2 3] اسکیلر: 5 ریزولٹ: [-4 -3 -2] اس مثال میں ، ہمارے پاس شکل (3 ،) کے ساتھ ایک نمی سرنی ہے اور اسکیلر ویلیو اسکیلر کے برابر ہے5. سرنی کو انجام دینے سے - اسکیلر ، اسکیلر ویلیو کو سرنی کے ہر عنصر سے گھٹا دیا جاتا ہے ، جس کے نتیجے میں ایک نئی صف کا نتیجہ ہوتا ہے جس کی اصل صف کی طرح ہوتی ہے۔سرنی کے ہر عنصر کو انفرادی طور پر اسکیلر ویلیو کے ذریعہ گھٹا دیا جاتا ہے ، جس سے نتیجہ سرنی میں اسی عنصر کو پیدا ہوتا ہے۔ یہ عنصر کے مطابق گھٹاؤ کا عمل کسی بھی شکل اور جہتی کی ایک اسکیلر اور صفوں کے درمیان انجام دیا جاسکتا ہے ، اور اسکیلر ویلیو کو گھٹا دیا جائے گا۔اس کے مطابق ہر عنصر۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، بٹ وائس شفٹ آپریشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق لوگرتھم (بیس 2) کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "اسکیلر ویلیو اور نپی سرنی کے عنصر کے حساب سے ضرب انجام دینے کے ل you ، آپ * آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3]) اسکیلر = 5 ریزولٹ = سرنی * اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [1 2 3] اسکیلر: 5 ریزولٹ: [5 10 15] اس مثال میں ، ہمارے پاس شکل (3 ،) کے ساتھ ایک نمی سرنی ہے اور اسکیلر ویلیو اسکیلر 5 کے برابر ہے۔سرنی * اسکیلر کو انجام دینے کے بعد ، سرنی کا ہر عنصر اسکیلر ویلیو سے ضرب ہوتا ہے ، جس کے نتیجے میں ایک نئی صف کا نتیجہ اسی شکل کے ساتھ ہوتا ہے جس کی اصل صف کی طرح ہوتا ہے۔سرنی کے ہر عنصر کو انفرادی طور پر اسکیلر ویلیو سے کئی گنا بڑھایا جاتا ہے ، جس سے نتائج کی صف میں اسی عنصر کو پیدا ہوتا ہے۔ عنصر کے مطابق ضرب آپریشن کسی بھی شکل اور جہتی کی ایک اسکیلر اور صفوں کے درمیان انجام دیا جاسکتا ہے ، اور اسکیلر ویلیو کو ضرب دیا جائے گا۔اس کے مطابق ہر عنصر۔"
    },
    {
        "Question": "ٹیلر سیریز کی توسیع کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی اسکیلر ویلیو کے ذریعہ کسی نمی سرنی کی عنصر کے مطابق تقسیم کرنے کے ل you ، آپ / آپریٹر استعمال کرسکتے ہیں۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([10 ، 20 ، 30]) اسکیلر = 5 ریزولٹ = سرنی / اسکیلر پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"اسکیلر:\" ، اسکیلر) پرنٹ (\"نتیجہ): \"، نتیجہ) آؤٹ پٹ: MakeFilecopy CodeArray: [10 20 30] اسکیلر: 5 ریزولٹ: [2۔6..] اس مثال میں ، ہمارے پاس شکل (3 ،) اور اسکیلر ویلیو اسکیلر کے ساتھ ایک نمی سرنی ہے۔ 5 کے برابراصل سرنی کی طرح ایک ہی شکل کے ساتھ ایک نیا سرنی نتیجہ۔سرنی کے ہر عنصر کو انفرادی طور پر اسکیلر ویلیو کے ذریعہ تقسیم کیا جاتا ہے ، جس سے نتیجہ سرنی میں اسی عنصر کو پیدا ہوتا ہے۔ یہ عنصر کے مطابق ڈویژن آپریشن کسی بھی شکل اور جہتی کی ایک اسکیلر اور صفوں کے درمیان انجام دیا جاسکتا ہے ، اور اسکیلر ویلیو کو تقسیم کیا جائے گا۔اس کے مطابق ہر عنصر۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، بجلی کی تکرار کے طریقہ کار کا استعمال کرتے ہوئے سرے کے ایگن ویلیوز اور ایگن ویکٹروں کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک نمی سرنی کے مخصوص محور کے ساتھ عناصر کے جوڑے کا حساب لگانے کے ل you ، آپ محور پیرامیٹر کے ساتھ NP.SUM () فنکشن استعمال کرسکتے ہیں۔محور پیرامیٹر محور کی وضاحت کرتا ہے جس کے ساتھ ساتھ رقم کا حساب لگانا چاہئے۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]])# محور 0 (کالم) Sum_axis_0 = np.sum (سرنی ، محور= 0)# محور 1 (قطاریں) کے ساتھ ساتھ رقم کا حساب لگائیں sum_axis_1 = np.sum (سرنی ، محور = 1) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"محور کے ساتھ جمع 0:\") پرنٹ (sum_axis_0) پرنٹ۔اس مثال کے طور پر ، ہمارے پاس شکل (2 ، 3) کی ایک 2D numpy سرنی سرنی ہے۔ہم NP.SUM (سرنی ، محور = 0) کا استعمال کرتے ہوئے محور 0 کے ساتھ ساتھ رقم کا حساب لگاتے ہیں ، جو ہمیں ہر کالم کے لئے عناصر کا مجموعہ فراہم کرتا ہے۔نتیجہ ، sum_axis_0 ، شکل کی ایک 1D صف ہے (3) جس میں ہر کالم کے ساتھ عناصر کا مجموعہ ہوتا ہے۔ اسی طرح ، ہم محور 1 کے ساتھ ساتھ NP.SUM (سرنی ، محور = 1) کا استعمال کرتے ہوئے رقم کا حساب لگاتے ہیں ، جو ہمیں اس کا مجموعہ دیتا ہے۔ہر صف کے لئے عناصر۔نتیجہ ، SUM_AXIS_1 ، شکل (2) کی ایک 1D صف ہے جس میں ہر صف کے ساتھ عناصر کا مجموعہ ہوتا ہے۔ مطلوبہ محور کی وضاحت کرتے ہوئے ، آپ اس محور کے ساتھ ساتھ رقم کا حساب لگاسکتے ہیں اور طول و عرض کا کم نتیجہ حاصل کرسکتے ہیں۔اگر محور = کوئی نہیں یا فراہم نہیں کیا گیا ہے تو ، اس کا حساب صف کے تمام عناصر پر لگایا جائے گا۔ آپ اس نقطہ نظر کو کسی نمی سرنی کے کسی بھی محور کے ساتھ رقم کا حساب لگانے کے لئے استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "numpy.power فنکشن کا استعمال کرتے ہوئے ایک numpy سرے کے عنصر کے مطابق مکعب کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نمی سرنی کے مخصوص محور کے ساتھ عناصر کی مصنوعات کا حساب لگانے کے ل you ، آپ محور پیرامیٹر کے ساتھ NP.Prod () فنکشن استعمال کرسکتے ہیں۔محور پیرامیٹر محور کی وضاحت کرتا ہے جس کے ساتھ ساتھ مصنوع کا حساب لگانا چاہئے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6]])# محور 0 (کالم) کے ساتھ مصنوع کا حساب لگائیں= 0)# محور 1 (قطاریں) کے ساتھ پروڈکٹ کا حساب لگائیں پروڈکٹ_ایکسس_1 = این پی پی۔ پرود (سرنی ، محور = 1) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"محور کے ساتھ پروڈکٹ 0:\") پرنٹ (پروڈکٹ_یکسس_0) پرنٹ(\"محور کے ساتھ پروڈکٹ 1:\":) پرنٹ (پروڈکٹ_یکسس_1) آؤٹ پٹ: لوکاپی کوڈرری: [[1 2 3] [4 5 6]] محور کے ساتھ ساتھ مصنوعات 0: [4 10 18] محور 1 کے ساتھ ساتھ: [6 120] میں مصنوعاتاس مثال کے طور پر ، ہمارے پاس شکل (2 ، 3) کی ایک 2D numpy سرنی سرنی ہے۔ہم NP.Prod (سرنی ، محور = 0) کا استعمال کرتے ہوئے محور 0 کے ساتھ ساتھ مصنوع کا حساب لگاتے ہیں ، جو ہمیں ہر کالم کے لئے عناصر کی پیداوار فراہم کرتا ہے۔نتیجہ ، پروڈکٹ_یکسس_0 ، شکل کی ایک 1D صف ہے (3) جس میں ہر کالم کے ساتھ عناصر کی مصنوعات پر مشتمل ہوتا ہے۔ اسی طرح ، ہم NP.Prod (سرنی ، محور = 1) کا استعمال کرتے ہوئے محور 1 کے ساتھ ساتھ مصنوع کا حساب لگاتے ہیں ، جو ہمیں مصنوع دیتا ہےہر صف کے لئے عناصر۔نتیجہ ، پروڈکٹ_ایکسس_1 ، شکل کی ایک 1D صف ہے (2) جس میں ہر صف کے ساتھ عناصر کی پیداوار ہوتی ہے۔ مطلوبہ محور کی وضاحت کرتے ہوئے ، آپ اس محور کے ساتھ ساتھ مصنوع کا حساب لگاسکتے ہیں اور طول و عرض کا کم نتیجہ حاصل کرسکتے ہیں۔اگر محور = کوئی نہیں یا فراہم نہیں کیا گیا ہے تو ، مصنوع کا حساب صف کے تمام عناصر پر لگایا جائے گا۔ آپ اس نقطہ نظر کو کسی بھی محور کے کسی بھی محور کے ساتھ مصنوع کا حساب لگانے کے لئے استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، ہورنر کے طریقہ کار کا استعمال کرتے ہوئے سرے کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک نپی سرنی میں عناصر کی مجموعی رقم کا حساب لگانے کے ل you ، آپ NP.Cumsum () فنکشن استعمال کرسکتے ہیں۔یہ ایک مخصوص محور کے ساتھ مجموعی رقم کی گنتی کرتا ہے۔اگر کسی محور کی وضاحت نہیں کی گئی ہے تو ، مجموعی رقم کا حساب صف کے چپٹی ورژن پر کیا جاتا ہے۔یہاں ایک مثال یہ ہے: پائیتھون کوپی کوڈیمپورٹ نوم کے بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) cumulative_sum = np.cumsum (\"سرنی:\" ، سرنی) پرنٹ (\"مجموعی رقم:\".NP.Cumsum (سرنی) کو کال کرنے سے ، عناصر کی مجموعی رقم کا حساب لگایا جاتا ہے ، جس کے نتیجے میں ایک نئی سرنی مجموعی_سم ہوتی ہے۔ ہر عنصر کو پچھلے تمام عناصر کے مجموعہ میں شامل کرکے مجموعی رقم حاصل کی جاتی ہے۔نتیجے میں ہونے والی صف میں ، انڈیکس I میں ہر عنصر اصل صف سے انڈیکس I (شامل) تک عناصر کا مجموعہ ہے۔ آپ کثیر جہتی صفوں کے لئے ایک مخصوص محور کے ساتھ مجموعی رقم کی گنتی کے لئے محور پیرامیٹر کی بھی وضاحت کرسکتے ہیں۔مثال کے طور پر ، np.cumsumsum (سرنی ، محور = 0) قطار کے ساتھ مجموعی رقم کی گنتی کرے گا اگر سرنی 2D سرنی ہے۔ NP.Cumsum () کا استعمال کرتے ہوئے ، آپ آسانی سے ایک نامدار صف میں عناصر کے مجموعی رقم کا حساب لگاسکتے ہیں۔"
    },
    {
        "Question": "numpy.arctan فنکشن کا استعمال کرتے ہوئے کسی numpy سرے کے عنصر کے مطابق الٹا ٹینجنٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نپی سرنی میں عناصر کی مجموعی مصنوعات کا حساب لگانے کے ل you ، آپ NP.Cumprod () فنکشن استعمال کرسکتے ہیں۔یہ ایک مخصوص محور کے ساتھ مجموعی مصنوع کی گنتی کرتا ہے۔اگر کسی محور کی وضاحت نہیں کی گئی ہے تو ، مجموعی مصنوع کا حساب صف کے چپٹی ورژن پر کیا جاتا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) cumulative_product = np.cumprod (\"سرنی:\" ، سرنی) پرنٹ (\"مجموعی مصنوع:\".NP.CUMPROD (سرنی) کو کال کرنے سے ، عناصر کی مجموعی مصنوعات کا حساب لگایا جاتا ہے ، جس کے نتیجے میں ایک نئی سرنی مجموعی_ پروڈکٹ ہوتی ہے۔ مجموعی مصنوع ہر عنصر کو پچھلے عناصر کی مصنوعات کے ساتھ ضرب دے کر حاصل کیا جاتا ہے۔نتیجے میں ہونے والی صف میں ، انڈیکس I میں ہر عنصر اصل صف سے انڈیکس I (شامل) تک عناصر کی پیداوار ہے۔ آپ کثیر جہتی صفوں کے لئے ایک مخصوص محور کے ساتھ مجموعی مصنوع کی گنتی کے لئے محور پیرامیٹر کی بھی وضاحت کرسکتے ہیں۔مثال کے طور پر ، np.cumprod (سرنی ، محور = 0) قطاروں کے ساتھ مجموعی مصنوعات کی گنتی کرے گا اگر سرنی 2D سرنی ہے۔ NP.Cumprod () کا استعمال کرتے ہوئے ، آپ آسانی سے ایک نمی سرنی میں عناصر کی مجموعی مصنوعات کا حساب لگاسکتے ہیں۔"
    },
    {
        "Question": "\"2 ڈی نپی سرنی کو دیکھتے ہوئے ، ہر صف کے ساتھ عنصر کے مطابق مجموعی مصنوعات کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کی عنصر کے مطابق مطلق اقدار کا حساب لگانے کے ل you ، آپ NP.ABS () فنکشن استعمال کرسکتے ہیں۔یہ صف میں ہر عنصر کی مطلق اقدار کی گنتی کرتا ہے ، جس کے نتیجے میں ایک ہی شکل کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([ -1 ، -2 ، 3 ، -4 ، 5]) مطلق_ایولس = np.abs (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"مطلق)اقدار: \"، مطلق_اولیوس) آؤٹ پٹ: ریاضی کاپی کوڈرری: [-1 -2 3 -4 5] مطلق اقدار: [1 2 3 4 4 5] اس مثال میں ، ہمارے پاس اقدار کے ساتھ 1D نمی سرنی ہے [-1 ، -2، 3 ، -4 ، 5]۔NP.ABS (سرنی) کو فون کرکے ، صف میں ہر عنصر کی مطلق اقدار کا حساب لگایا جاتا ہے ، جس کے نتیجے میں ایک نئی صف مطلق_ایلیوز ہوتی ہے۔ NP.ABS () فنکشن ایک نئی صف لوٹاتا ہے جہاں ہر عنصر متعلقہ عنصر کی مطلق قدر ہے۔ان پٹ سرنی میں۔یہ بنیادی طور پر ہر عنصر کی علامت کو ہٹا دیتا ہے اور اس بات کو یقینی بناتا ہے کہ تمام اقدار غیر منفی ہیں۔() ، آپ آسانی سے کسی نمی سرنی کی عنصر کے مطابق مطلق اقدار کی گنتی کرسکتے ہیں۔"
    },
    {
        "Question": "numpy.exp فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق علامت کا حساب لگانے کے ل you ، آپ NP.SIGN () فنکشن استعمال کرسکتے ہیں۔یہ صف میں ہر عنصر کی علامت کی گنتی کرتا ہے ، جس کے نتیجے میں ایک ہی شکل کی ایک نئی صف ہوتی ہے۔کسی نمبر X کی علامت کی وضاحت اس طرح کی گئی ہے: اگر x> 0 ، نشان 1. اگر x <0 ہے تو ، علامت -1.if x == 0 ہے ، اس کی علامت 0. ہے۔جیسا کہ nparray = np.Array ([ -1 ، -2 ، 3 ، 0 ، 5]) اشارے = np.Sign (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"نشانیاں:\" ، نشانیاں) آؤٹ پٹ: میک فیل کوپیکوڈرری: [-1 -2 3 0 5] اشارے: [-1 -1 1 0 1] اس مثال میں ، ہمارے پاس اقدار [-1 ، -2 ، 3 ، 0 ، 5] کے ساتھ ایک 1D نیپی سرنی سرنی ہے۔NP.SIGN (سرنی) کو فون کرکے ، صف میں ہر عنصر کی علامت کا حساب لگایا جاتا ہے ، جس کے نتیجے میں ایک نئی صف کی علامت ہوتی ہے۔ NP.SIGN () فنکشن ایک نئی صف لوٹاتا ہے جہاں ہر عنصر میں اسی عنصر کی علامت ہوتی ہےان پٹ سرنییہ منفی تعداد میں -1 کی قیمت ، 1 مثبت تعداد میں ، اور 0 زیرو کو تفویض کرتا ہے۔.سائن () ، آپ آسانی سے کسی نمی سرنی کے عنصر کے مطابق علامت کی گنتی کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arcsin فنکشن کا استعمال کرتے ہوئے صف کے عنصر کے مطابق الٹا سائن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "دو numpy صفوں کے عنصر کے حساب سے فرش ڈویژن کا حساب لگانے کے ل you ، آپ // آپریٹر یا NP.floor_divide () فنکشن استعمال کرسکتے ہیں۔دونوں طریقے فرش ڈویژن کو انجام دیتے ہیں ، جس سے تقسیم کا نتیجہ قریب ترین عددی تک جاتا ہے۔یہاں ایک مثال ہے: // آپریٹر کا استعمال کرتے ہوئے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([7 ، 10 ، 15]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = سرنی 1 // array2 پرنٹ (\"سرنی 1: \"، سرنی 1) پرنٹ (\" سرنی 2: \"، سرنی 2) پرنٹ (\" فلور ڈویژن نتیجہ: \"، نتیجہ) NP.floor_divide () کا استعمال کرتے ہوئے: pythoncopy کوڈیمپورٹ numpy as nparray1 = np.array ([7 ، 10 ،15]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = np.floor_divide (array1 ، array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"پرنٹ (\"فلور ڈویژن کا نتیجہ: \"، نتیجہ) آؤٹ پٹ: لیس کاپی کوڈرری 1: [7 10 15] سرنی 2: [2 3 4] فرش ڈویژن کا نتیجہ: [3 3 3] دونوں مثالوں میں ، ہمارے پاس دو 1 ڈی نیپی آریاں ہیں: سرنی 1 اور سرنی 2array1 // array2 یا np.floor_divide (array1 ، array2) انجام دے کر ، عنصر کے حساب سے فرش ڈویژن کا حساب لگایا جاتا ہے ، جس کے نتیجے میں ایک نئی صف کا نتیجہ ہوتا ہے۔ فرش ڈویژن آپریشن ہر عنصر کو اری 2 میں array2 میں array2 میں تقسیم کرتا ہے ، اور اس کو گول کرتا ہے۔قریب ترین عددی کے نتیجے میں۔نتیجہ سرنی کی شکل اسی طرح ہوگی جس طرح ان پٹ سرنیوں کی طرح ہے۔ آپ اپنی ترجیح پر منحصر ہے ، یا تو // آپریٹر یا NP.FLOOR_DIVIDE () فنکشن کا استعمال کرتے ہوئے numpy arrays کے عنصر کے لحاظ سے فرش ڈویژن انجام دے سکتے ہیں۔"
    },
    {
        "Question": "numpy.cumsum فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو numpy صفوں کے عنصر کے مطابق ماڈیولو کا حساب لگانے کے ل you ، آپ ٪ آپریٹر یا NP.MOD () فنکشن استعمال کرسکتے ہیں۔دونوں طریقے ماڈیولو آپریشن انجام دیتے ہیں ، جو تقسیم کے بعد باقی کی گنتی کرتے ہیں۔یہاں ایک مثال ہے: ٪ آپریٹر کا استعمال کرتے ہوئے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([7 ، 10 ، 15]) array2 = np.array ([2 ، 3 ، 4]) نتیجہ = سرنی 1 ٪ array2 پرنٹ (\"سرنی 1: \"، array1) پرنٹ (\" سرنی 2: \"، اری 2) پرنٹ (\" ماڈیولو نتیجہ: \"، نتیجہ) NP.MOD (): Pythoncopy Codemport numpy کے طور پر nparray1 = np.array ([7 ، 10 ، 15])array2 = np.array ([2 ، 3 ، 4]) نتیجہ = np.mod (array1 ، array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"ماڈیولو نتیجہ:\"، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈرری 1: [7 10 15] سرنی 2: [2 3 4] ماڈیولو نتیجہ: [1 1 3] دونوں مثالوں میں ، ہمارے پاس دو 1 ڈی نپی سرنی ہیں: سرنی 1 اور سرنی 2۔Array1 ٪ array2 یا NP.MOD (array1 ، array2) انجام دے کر ، عنصر کے مطابق ماڈیولو کا حساب لگایا جاتا ہے ، جس کے نتیجے میں ایک نئی صف کا نتیجہ نکلتا ہے۔ ماڈیولو آپریشن Array2 میں اسی عنصر کے ذریعہ Array1 میں ہر عنصر کو تقسیم کرنے کے بعد باقی کی گنتی کرتا ہے۔نتیجہ سرنی کی شکل اسی طرح ہوگی جس طرح ان پٹ سرنیوں کی طرح ہے۔ آپ اپنی ترجیح پر منحصر ہے ، یا تو ٪ آپریٹر یا NP.MOD () فنکشن کا استعمال کرتے ہوئے numpy arrays کے عنصر کے مطابق ماڈیولو انجام دے سکتے ہیں۔"
    },
    {
        "Question": "\"2 ڈی نپی سرنی کو دیکھتے ہوئے ، ہر کالم کے ساتھ عنصر کے مطابق مجموعی مصنوعات کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "عنصر کے لحاظ سے منطقی اور آپریشن کو دو numpy صفوں کے درمیان انجام دینے کے ل you ، آپ NP.logical_and () فنکشن استعمال کرسکتے ہیں۔یہ ان پٹ صفوں میں منطقی اور اسی طرح کے عناصر کی گنتی کرتا ہے ، جس کے نتیجے میں بولین اقدار کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([سچ ، سچ ، غلط ، غلط]) array2 = np.array ([سچ ، غلط ، سچ ، غلط]) نتیجہ = np.logical_and (array1 ، arry2)پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، اری 2) پرنٹ (\"منطقی اور نتیجہ:\" ، نتیجہ) آؤٹ پٹ: SQLCOPY کوڈرری 1: [سچ سچ غلط جھوٹا] سرنی 2: [سچ جھوٹا سچغلط] منطقی اور نتیجہ: [سچ جھوٹا غلط جھوٹا] اس مثال میں ، ہمارے پاس دو 1D نپی سرنی ہیں: سرنی 1 اور سرنی 2۔NP.logical_and (arry1 ، array2) پر کال کرکے ، عنصر کے مطابق منطقی اور آپریشن انجام دیا جاتا ہے ، جس کے نتیجے میں ایک نیا سرنی نتیجہ برآمد ہوتا ہے۔ NP.logical_and () فنکشن ان پٹ صفوں میں متعلقہ عناصر کا موازنہ کرتا ہے اور اگر دونوں عناصر سچ ہیں تو وہ سچ ہیں۔، ورنہ یہ غلط لوٹتا ہے۔نتیجے میں ہونے والی صف کی شکل ان پٹ کی طرح ہوگی۔عنصر کے لحاظ سے منطقی اور دو نمی اریوں کے درمیان آپریشن آسانی سے انجام دے سکتے ہیں۔"
    },
    {
        "Question": "numpy.sinh فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق ہائپربولک سائن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "عنصر کے لحاظ سے منطقی یا دو نمی صفوں کے مابین آپریشن کرنے کے ل you ، آپ NP.logical_or () فنکشن استعمال کرسکتے ہیں۔یہ ان پٹ صفوں میں منطقی یا اسی طرح کے عناصر کی گنتی کرتا ہے ، جس کے نتیجے میں بولین اقدار کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray1 = np.array ([سچ ، ، غلط ، غلط ، غلط]) array2 = np.array ([سچ ، غلط ، سچ ، غلط]) نتیجہ = np.logical_or (array1 ، arry2)پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"منطقی یا نتیجہ:\" ، نتیجہ) آؤٹ پٹ: SQLCOPY کوڈرری 1: [سچ سچ غلط جھوٹا] سرنی 2: [سچ جھوٹا سچغلط] منطقی یا نتیجہ: [سچ سچ سچ غلط] اس مثال میں ، ہمارے پاس دو 1D نپی سرنی ہیں: سرنی 1 اور سرنی 2۔NP.logical_or (array1 ، arry2) پر کال کرکے ، عنصر کے مطابق منطقی یا آپریشن انجام دیا جاتا ہے ، جس کے نتیجے میں ایک نیا سرنی نتیجہ ہوتا ہے۔ NP.logical_or () فنکشن ان پٹ صفوں میں متعلقہ عناصر کا موازنہ کرتا ہے اور اگر کم از کم کسی ایک میں کم از کم کسی ایک کو درست کرتا ہے۔عناصر سچ ہیں ، ورنہ یہ غلط لوٹتا ہے۔نتیجے میں ہونے والی صفوں کی شکل ان پٹ اریوں کی طرح ہوگی۔ آپ کسی بھی شکل اور جہت کی صفوں میں NP.logical_or () کا اطلاق کرسکتے ہیں ، اور اس کے مطابق عنصر کے مطابق منطقی یا آپریشن کا حساب لگائے گا۔ NP.logical_or () کا استعمال کرتے ہوئے ، آپدو نپی صفوں کے درمیان آسانی سے عنصر کے مطابق منطقی یا آپریشن انجام دے سکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arccos فنکشن کا استعمال کرتے ہوئے صف کے عنصر کے مطابق الٹا الٹا کوسائن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "عنصر کے مطابق منطقی انجام دینے کے ل nump ، کسی نمی سرنی پر آپریشن نہ کریں ، آپ NP.logical_not () فنکشن استعمال کرسکتے ہیں۔یہ ان پٹ سرنی میں ہر عنصر کی منطقی گنتی نہیں کرتا ہے ، جس کے نتیجے میں بولین اقدار کی ایک نئی صف ہوتی ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([سچ ، غلط ، سچ]) نتیجہ = np.logical_not (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"منطقی نہیں نتیجہ:\" ، نتیجہ)آؤٹ پٹ: SQLCOPY CODEARRAY: [سچ جھوٹا سچ] منطقی نتیجہ نہیں: [غلط سچ جھوٹا] اس مثال میں ، ہمارے پاس 1D numpy سرنی ہے جسے سرنی کہا جاتا ہے۔NP.logical_not (سرنی) کو کال کرنے سے ، عنصر کے مطابق منطقی آپریشن انجام دیا جاتا ہے ، جس کے نتیجے میں ایک نیا سرنی نتیجہ ہوتا ہے۔ NP.logical_not () فنکشن ان پٹ سرنی میں ہر عنصر کی نفی کرتا ہے۔اگر عنصر سچ ہے تو ، یہ غلط ہوجاتا ہے ، اور اگر عنصر غلط ہے تو ، یہ سچ ہوجاتا ہے۔نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ آپ کسی بھی شکل اور جہتی کی صفوں پر NP.logical_not () کا اطلاق کرسکتے ہیں ، اور اس کے مطابق عنصر کے مطابق منطقی آپریشن کا حساب لگائے گا۔آسانی سے عنصر کے مطابق منطقی انجام دے سکتے ہیں نہ کہ کسی نمی سرنی پر آپریشن کریں۔"
    },
    {
        "Question": "لوپ کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر کے مطابق مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی مخصوص رینج کے مابین بے ترتیب عدد کے ساتھ ایک نمی سرنی بنانے کے ل you ، آپ NP.Random.randint () فنکشن استعمال کرسکتے ہیں۔یہ فنکشن ایک دیئے گئے کم (شامل) سے اعلی (خصوصی) رینج تک بے ترتیب عدد پیدا کرتا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# 0 اور 10Array = np.random.randint (0 ، 10 ، سائز = 5) پرنٹ (\"بے ترتیب صف:\" ، سرنی) آؤٹ پٹ: ریاضی کاپی کے درمیان 5 بے ترتیب عدد کے ساتھ 1D سرنی تیار کریں۔کوڈرینڈم سرنی: [4 9 3 2 7] اس مثال میں ، ہم NP.Random.Randint (0 ، 10 ، سائز = 5) کا استعمال کرتے ہیں تاکہ 1D (شامل) اور 10 (خصوصی) کے درمیان بے ترتیب عدد کے ساتھ سائز 5 کی 1D صف پیدا کی جاسکے (خصوصی))سائز کا پیرامیٹر نتیجے میں ہونے والی صف کی شکل کا تعین کرتا ہے۔ آپ کم اور اعلی پیرامیٹرز میں ترمیم کرکے اور مطلوبہ سائز کی وضاحت کرکے صف کی حد اور سائز کو ایڈجسٹ کرسکتے ہیں۔ اگر آپ بے ترتیب عدد کے ساتھ کثیر جہتی صف بنانا چاہتے ہیں تو ، آپ کر سکتے ہیں۔سائز کے پیرامیٹر کے طور پر ایک ٹپل فراہم کریں۔مثال کے طور پر ، سائز = (3 ، 4) ایک 3x4 سرنی بنائے گا۔ NP.Random.Randint () کا استعمال کرتے ہوئے ، آپ ایک مخصوص حد میں بے ترتیب انٹیگرس کے ساتھ ایک numpy صف تیار کرسکتے ہیں۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیا گیا ، ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوعات کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!آپ نوم کے آرینج () فنکشن کا استعمال کرتے ہوئے نمبروں کا ایک تسلسل تیار کرسکتے ہیں۔ارینج () فنکشن ایک مخصوص آغاز ، اختتام اور مرحلہ سائز کے ساتھ نمبروں کی 1 جہتی صف تیار کرتا ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# 0 سے 9 (خصوصی) تسلسل = NP.Arange (0 ، 10) پرنٹ (\"ترتیب:\" ، ترتیب) آؤٹ پٹ: میک فیلیکوپی کوڈیسیوینس: [0 1 2 2 تک نمبروں کی ترتیب پیدا کریں۔3 4 5 6 6 7 8 9] اس مثال میں ، ہم 0 (شامل) سے شروع ہونے والے نمبروں کی ترتیب پیدا کرنے اور 10 (خصوصی) پر اختتام پذیر نمبروں کی ترتیب پیدا کرنے کے لئے NP.arange (0 ، 10) استعمال کرتے ہیں۔نتیجے میں ہونے والی صف میں 0 سے 9 تک کی تعداد ہوتی ہے۔ آپ ارینج () فنکشن کے پیرامیٹرز میں ترمیم کرکے ترتیب کے آغاز ، اختتام اور مرحلے کے سائز کو اپنی مرضی کے مطابق بنا سکتے ہیں۔مثال کے طور پر ، NP.Arange (1 ، 11 ، 2) 2 کے مرحلہ سائز کے ساتھ ایک ترتیب پیدا کرے گا ، جس کے نتیجے میں [1 3 5 7 9] ہے۔ ارینج () فنکشن لچکدار ہے اور آپ کو مؤثر طریقے سے نمبروں کی ترتیب بنانے کی اجازت دیتا ہے۔"
    },
    {
        "Question": "numpy.cosh فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق ہائپربولک کوسائن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک مخصوص تعداد کو ایک مخصوص تعداد میں دہراتے ہوئے ایک نمی سرنی کو نئی شکل دینے کے ل you ، آپ NP.REEPEAT () فنکشن استعمال کرسکتے ہیں۔یہ فنکشن ان پٹ سرنی میں ہر عنصر کو ایک خاص تعداد میں دہراتا ہے ، جس کے نتیجے میں ایک نئی شکل مختلف شکل کے ساتھ ہوتی ہے۔یہاں مثال دی گئی ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3])# ہر عنصر کو 2 ٹائمسریپیڈ_ریری = np.repeat (سرنی ، دہرانے = 2) پرنٹ (\"اصل سرنی:\" کو دہرا کر صف کو نئی شکل دیں (\"اصل سرنی:\"، سرنی) پرنٹ (\"دوبارہ تشکیل شدہ سرنی:\" ، resshaped_array) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈورجینل سرنی: [1 2 3] دوبارہ تیار شدہ سرنی: [1 1 2 2 2 3 3] اس مثال میں ، ہمارے پاس عناصر پر مشتمل ایک 1D نام ہے جس میں عناصر شامل ہیں۔[1 ، 2 ، 3]۔np.repeat (سرنی ، دہراتا ہے = 2) پر کال کرکے ، ہم ہر عنصر کو 2 بار دہراتے ہوئے صف کو نئی شکل دیتے ہیں۔نتیجے میں سرنی resshaped_array میں بار بار عناصر شامل ہوتے ہیں [1 ، 1 ، 2 ، 2 ، 3 ، 3]. آپ NP.repeat () فنکشن کے دہرائے جانے والے پیرامیٹر میں ترمیم کرکے ہر عنصر کے لئے تکرار کی تعداد کو ایڈجسٹ کرسکتے ہیں۔مطلوبہ محور کی وضاحت کرکے کثیر جہتی صفیں جس کے ساتھ ہی تکرار ہونا چاہئے۔ NP.REEPEAT () کا استعمال کرتے ہوئے ، آپ اس کے عناصر کو ایک مخصوص تعداد میں دہراتے ہوئے ایک غیرمعمولی صف کو دوبارہ تشکیل دے سکتے ہیں اور مطلوبہ شکل حاصل کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arctan فنکشن کا استعمال کرتے ہوئے سر کے عنصر کے مطابق الٹا ٹینجنٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک مخصوص شکل میں زیرو کے ساتھ ایک نمی سرنی کو پیڈ کرنے کے ل you ، آپ NP.PAD () فنکشن استعمال کرسکتے ہیں۔NP.PAD () فنکشن آپ کو مطلوبہ بھرتی کی شکل اور بھرتی کے لئے استعمال ہونے والی قدر کی وضاحت کرکے ایک صف میں بھرتی شامل کرنے کی اجازت دیتا ہے۔یہاں ایک مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([[1 ، 2] ، [3 ، 4]])# زروس کے ساتھ سرنی (3 ، 4) پیڈڈ_ریری = این پی پیڈ (سرنی (سرنی.سرنی: [[1 2] [3 4]] بولڈ سرنی: [[1 2 0 0] [3 4 0 0] [0 0 0 0]] اس مثال میں ، ہمارے پاس شکل کے ساتھ سرنی نامی 2 ڈی نیپری سرنی ہے۔(2 ، 2)NP.PAD (سرنی ، (0 ، 1) ، (0 ، 2)) ، موڈ = 'مستقل') پر کال کرکے ، ہم (3 ، 4) کی شکل حاصل کرنے کے لئے زیرو کے ساتھ صف کو پیڈ کرتے ہیں۔(0 ، 1) بھرتی کی تشکیل سے یہ واضح ہوتا ہے کہ پہلی جہت کو اوپر سے 0 قطار کے ساتھ اور نیچے 1 قطار کے ساتھ پیڈ کیا جانا چاہئے ، جبکہ (0 ، 2) بھرتی کی ترتیب یہ بتاتی ہے کہ دوسری جہت کو 0 کالموں کے ساتھ پیڈ کیا جانا چاہئے۔دائیں طرف بائیں اور 2 کالم۔موڈ = 'مستقل' پیرامیٹر اس بات کو یقینی بناتا ہے کہ صفر کو بھرنے کے لئے استعمال کیا جائے۔ آپ اپنی مخصوص ضروریات کے مطابق بھرتی کی ترتیب اور پیڈنگ موڈ کو ایڈجسٹ کرسکتے ہیں۔NP.PAD () فنکشن مطلوبہ شکل کو حاصل کرنے کے لئے numpy صفوں کو بھرنے میں لچک فراہم کرتا ہے۔"
    },
    {
        "Question": "ایک بار بار چلنے والے نقطہ نظر کا استعمال کرتے ہوئے کسی نمی سرنی کے عنصر کے مطابق مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نپی سرنی پر عنصر کے حساب سے پاور آپریشن انجام دینے کے ل you ، آپ NP.POWER () فنکشن استعمال کرسکتے ہیں۔NP.POWER () فنکشن صف میں ہر عنصر کو ایک مخصوص طاقت میں اٹھاتا ہے۔یہاں ایک مثال یہ ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی بطور nparray = np.array ([1 ، 2 ، 3])# ایکسپینٹ 2 ریزولٹ = این پی پاور (سرنی ، 2) پرنٹ (\"اصل سرنی:\" ، سرنی کے ساتھ عنصر کے مطابق بجلی کا آپریشن انجام دیں۔) پرنٹ (\"نتیجہ:\" ، نتیجہ) آؤٹ پٹ: لیس کاپی کوڈورجینل سرنی: [1 2 3] نتیجہ: [1 4 9] اس مثال میں ، ہمارے پاس عناصر کے ساتھ سرنی کہا جاتا ہے [1 ، 2 ، 3]این پی پاور (سرنی ، 2) کو کال کرکے ، ہم 2 کے اخراج کے ساتھ عنصر کے حساب سے بجلی کا آپریشن انجام دیتے ہیں۔ اس کے نتیجے میں سرنی کے نتیجے میں عناصر [1 ، 4 ، 9] ہوتے ہیں ، جو اصل عناصر کا مربع ہیں۔مختلف پاور آپریشنز انجام دینے کے لئے NP.Power () فنکشن میں اخراج کنندہ کی قیمت کو ایڈجسٹ کرسکتے ہیں۔مثال کے طور پر ، این پی پاور (سرنی ، 3) ہر عنصر کو 3. کی طاقت میں بڑھائے گا۔نشریات کے لئے مطابقت پذیر ہیں۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، numpy.cumprod فنکشن کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے ہر عنصر پر کسٹم فنکشن کا اطلاق کرنے کے ل you ، آپ نمی کے ویکٹرائز () فنکشن استعمال کرسکتے ہیں۔ویکٹرائز () فنکشن آپ کو ایک ویکٹرائزڈ فنکشن بنانے کی اجازت دیتا ہے جس کو عنصر کے لحاظ سے کسی صف میں لاگو کیا جاسکتا ہے۔یہاں ایک مثال یہ ہے: Pythoncopy Codemport numpy As NP# ایک کسٹم فنکشن ڈیف کسٹم_فونکشن (x) کی وضاحت کریں:# عنصر کو مربع اگر یہ مثبت ہے تو ، بصورت دیگر عنصر کو واپس لوٹائیں x ** 2 اگر x> 0 دوسری x# ایک ویکٹرائزڈ فنکشن ویکٹورائزڈ_فکشن = این پی بنائیں۔ویکٹرائز (کسٹم_فونکشن)# ایک numpy arrayarray = np.Array بنائیں ([ -1 ، 2 ، -3 ، 4 ، -5])# ویکٹرائزڈ فنکشن کو arrayresult = vectorized_function (سرنی) پرنٹ (\"اصل سرنی:\" پر لگائیں۔سرنی) پرنٹ (\"نتیجہ:\" ، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈورجینل سرنی: [-1 2 -3 4 -5] نتیجہ: [-1 4 -3 16 -5] اس مثال میں ، ہم ایک کسٹم فنکشن کسٹم_فکشن کی وضاحت کرتے ہیں (x) جو عنصر کو مثبت ہے اگر یہ مثبت ہے ، اور اگر یہ منفی ہے تو خود عنصر کو لوٹاتا ہے۔اس کے بعد ہم NP.Vectorize (کسٹم_فکشن) کا استعمال کرتے ہوئے ایک ویکٹرائزڈ فنکشن تشکیل دیتے ہیں۔آخر میں ، ہم ویکٹرائزڈ فنکشن کو ایک نپی سرنی سرنی پر لاگو کرتے ہیں ، جس کے نتیجے میں کسٹم فنکشن کے ساتھ سرنی کا نتیجہ ہوتا ہے۔نپی سرنی ، لیکن یہ ہمیشہ سب سے زیادہ موثر نقطہ نظر نہیں ہوسکتا ہے۔اگر ممکن ہو تو ، یہ تجویز کیا جاتا ہے کہ آپ اپنے کسٹم فنکشن کو براہ راست نمی کے سرنی آپریشنوں کا استعمال کرتے ہوئے نافذ کریں ، کیونکہ وہ عام طور پر تیز اور زیادہ موثر ہوتے ہیں۔"
    },
    {
        "Question": "numpy.exp فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق لاجسٹک سگمائڈ فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "میں اپنے پچھلے جواب میں غلط جواب کے لئے معذرت خواہ ہوں۔np.vectorize () numpy میں فنکشن دراصل کارکردگی کے فوائد فراہم نہیں کرتا ہے کیونکہ یہ اب بھی ازگر کے لوپ میں چلتا ہے۔بہتر کارکردگی کے ل it ، یہ تجویز کی جاتی ہے کہ وہ براہ راست نوم کے سرنی آپریشن استعمال کریں۔یہاں ایک تازہ ترین مثال ہے: پائیٹون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک کسٹم فنکشن ڈیف کسٹم_فونکشن (x) کی وضاحت کریں:# عنصر کو مثبت ہے ، ورنہ عنصر کو واپس لوٹائیں x ** 2 اگر x> 0 اور x# ایک numpy array = np بنائیں = np.ار ([ -1 ، 2 ، -3 ، 4 ، 4 ، -5])# Arrayresult = np.where پر کسٹم فنکشن کا اطلاق کریں (سرنی> 0 ، سرنی ** 2 ، سرنی) پرنٹ (\"اصل سرنی:\": \"سرنی) پرنٹ (\"نتیجہ:\" ، نتیجہ) آؤٹ پٹ: لیس کوپی کوڈورجینل سرنی: [-1 2 -3 4 -5] نتیجہ: [-1 4 -3 16 -5] اس تازہ ترین مثال میں ، ہم اسی کسٹم فنکشن کی وضاحت کرتے ہیںکسٹم_فکشن (x) جو عنصر کو مثبت ہے اگر یہ مثبت ہے ، اور اگر یہ منفی ہے تو خود عنصر کو لوٹاتا ہے۔NP.Vectorize () کو استعمال کرنے کے بجائے ، ہم ویکٹرائزڈ انداز میں کسٹم فنکشن عنصر کے لحاظ سے کسٹم فنکشن کو لاگو کرنے کے لئے NUMPY کے NP.Where () فنکشن کا استعمال کرتے ہیں۔NP. Where () فنکشن مشروط اظہار کے طور پر کام کرتا ہے ، اس بات کا اندازہ کرتا ہے کہ آیا صف میں ہر عنصر صفر سے زیادہ ہے یا نہیں۔اگر حالت سچ ہے تو ، یہ عنصر کو مربع کرتی ہے ، بصورت دیگر ، یہ اصل عنصر کو برقرار رکھتی ہے۔ NP.Where () جیسے NP.Vectorize () کے استعمال کے مقابلے میں ، NP.Where () جیسے NP. Where () ، براہ راست ، NP. Where () کے مقابلے میں بہتر کارکردگی فراہم کرسکتی ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arcsinh فنکشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سائن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک نپی سرنی سے مخصوص اخترن عناصر کے ساتھ اخترن میٹرکس بنانے کے ل you ، آپ NP.Diag () فنکشن استعمال کرسکتے ہیں۔NP.DIAG () فنکشن آپ کو اخترن سرنی کی تعمیر یا کسی صف سے اخترن عناصر نکالنے کی اجازت دیتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نوم کے بطور این پی# ایک نیمپی اری ڈیڈیگونل_ ای ایلیمنٹس = این پی آر آرے بنائیں ([1 ، 2 ، 3])# مخصوص ڈایگونل عناصر کے ساتھ ایک اخترن میٹرکس بنائیں:\") پرنٹ (اخترن_میٹرکس) آؤٹ پٹ: Luacopy کوڈیڈیاگونل میٹرکس: [[1 0 0] [0 2 0] [0 0 3]] اس مثال میں ، ہمارے پاس اقدار [1 ، 2 ، 3] کے ساتھ 1D numpy سرنی اخترن_ایلمنٹ ہے [1 ، 2 ، 3]NP.Diag (diagonal_elements) کو کال کرکے ، ہم مخصوص اخترن عناصر کے ساتھ ایک اخترن میٹرکس بناتے ہیں۔نتیجے میں اخترن_میٹرکس ایک 2D نمی سرنی ہے جس کی شکل (3 ، 3) ہے ، جہاں اخترن عناصر اخترن_ایلیمنٹس سرنی کے عناصر سے مطابقت رکھتے ہیں۔ آپ اخترن عناصر کے ل any کسی بھی مطلوبہ اقدار پر مشتمل اخترن_ایلیمنٹ سرنی کو ایڈجسٹ کرسکتے ہیں۔NP.DIAG () فنکشن ایک نمی سرنی سے اخترن میٹرکس کی تعمیر کا ایک آسان طریقہ فراہم کرتا ہے۔"
    },
    {
        "Question": "numpy.add.redduce فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے ل you ، آپ NP.Cumsum () فنکشن استعمال کرسکتے ہیں۔NP.Cumsum () فنکشن ایک صف لوٹاتا ہے جہاں ہر عنصر اس انڈیکس تک عناصر کا مجموعی مجموعہ ہوتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) بنائیں ([1 ، 2 ، 3 ، 4 ، 5]))# عنصر کے مطابق مجموعی طور پر سمکومولیٹو_سم = np.cumsum (سرنی) پرنٹ (\"اصل) پرنٹ کریں۔سرنی: \"، سرنی) پرنٹ (\" مجموعی رقم: \"، مجموعی_سم) آؤٹ پٹ: کم کوپی کوڈورجینل سرنی: [1 2 3 4 5] مجموعی رقم: [1 3 6 10 15] اس مثال میں ، ہمارے پاس 1 ڈی نمپری سرنی ہےعناصر کے ساتھ [1 ، 2 ، 3 ، 4 ، 5]۔NP.Cumsumsum (سرنی) کو کال کرکے ، ہم عنصر کے حساب سے مجموعی رقم کا حساب لگاتے ہیں۔نتیجے میں مجموعی_سم سرنی میں ہر انڈیکس میں مجموعی رقم شامل ہوتی ہے ، جہاں ہر عنصر تمام عناصر کا مجموعہ ہوتا ہے اور اس میں شامل ہوتا ہے۔پہلے سے طے شدہ طور پر ، یہ چپٹی ہوئی صف کے ساتھ ساتھ مجموعی رقم انجام دیتا ہے۔اگر آپ کثیر جہتی صف کے مخصوص محور کے ساتھ مجموعی رقم کا حساب لگانا چاہتے ہیں تو ، آپ محور پیرامیٹر کی وضاحت کرسکتے ہیں۔"
    },
    {
        "Question": "\"2 ڈی نپی سرنی کو دیکھتے ہوئے ، لوپ کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوعات کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے ل you ، آپ NP.Cumprod () فنکشن استعمال کرسکتے ہیں۔NP.CUMPROD () فنکشن ایک صف لوٹاتا ہے جہاں ہر عنصر اس انڈیکس تک عناصر کی مجموعی مصنوعات ہوتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.array ([1 ، 2 ، 3 ، 4 ، 5]] بنائیں ([1 ، 2 ، 3 ، 4 ، 5])# عنصر کے مطابق مجموعی پروڈکٹکومولیٹو_ پروڈکٹ = np.Cumprod (\"اصل) پرنٹ (\" اصل) پرنٹ کریں۔سرنی: \"، سرنی) پرنٹ (\" مجموعی مصنوع: \"، مجموعی_ پروڈکٹ) آؤٹ پٹ: لیس کوپی کوڈورجینل سرنی: [1 2 3 4 5] مجموعی مصنوع: [1 2 6 24 120] اس مثال میں ، ہمارے پاس 1 ڈی نیمپری سرنی ہےعناصر کے ساتھ [1 ، 2 ، 3 ، 4 ، 5]۔NP.CUMPROD (سرنی) کو کال کرکے ، ہم عنصر کے حساب سے مجموعی مصنوعات کا حساب لگاتے ہیں۔نتیجے میں مجموعی_پروڈکٹ سرنی ہر انڈیکس میں مجموعی مصنوع پر مشتمل ہے ، جہاں ہر عنصر تمام عناصر کی مصنوعات ہوتا ہے جس میں NP.cumsums () ، np.cumprod () فنکشن 1D دونوں پر استعمال کیا جاسکتا ہے۔کثیر جہتی صفیں۔پہلے سے طے شدہ طور پر ، یہ چپٹی ہوئی صف کے ساتھ ساتھ مجموعی مصنوعات کو انجام دیتا ہے۔اگر آپ کثیر جہتی صف کے مخصوص محور کے ساتھ مجموعی مصنوع کا حساب لگانا چاہتے ہیں تو ، آپ محور پیرامیٹر کی وضاحت کرسکتے ہیں۔"
    },
    {
        "Question": "numpy.tanh فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق ہائپربولک ٹینجینٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک مخصوص رینج کے مابین یکساں طور پر فاصلہ والی اقدار کے ساتھ ایک numpy صف بنانے کے ل you ، آپ NP.LINSPACE () فنکشن استعمال کرسکتے ہیں۔NP.LINSPACE () فنکشن کسی وقفے کے اندر یکساں طور پر فاصلہ والی اقدار کی ایک مخصوص تعداد تیار کرتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# 0 اور 1Array = np.linspace (0 ، 1 ، 5) پرنٹ (\"سرنی:\" ، سرنی) آؤٹ پٹ کے درمیان 5 یکساں طور پر فاصلہ والی اقدار کے ساتھ ایک نیپی سرنی بنائیں: جاوا اسکرپٹ کوپی کوڈئری: [00.25 0.5 0.75 1.] اس مثال میں ، ہم NP.LINSPACE (0 ، 1 ، 5) کا استعمال کرتے ہیں تاکہ 0 اور 1 کے درمیان 5 یکساں طور پر فاصلہ والی اقدار کے ساتھ ایک نپی سرنی بنائیں۔0.75 ، 1.0]۔NP.LINSPACE () فنکشن وقفہ کو شروع اور اختتامی اقدار (اس معاملے میں 0 اور 1) کے درمیان تقسیم کرتا ہے۔نمبر پیرامیٹر کی وضاحت کرکے صف میں۔آپ مختلف رینج کی وضاحت کے ل start آغاز اور اختتامی اقدار کو بھی ایڈجسٹ کرسکتے ہیں۔NP.LINSPACE () کا استعمال کرتے ہوئے ، آپ آسانی سے ایک مخصوص حد کے اندر یکساں فاصلہ والی اقدار کے ساتھ ایک نمی سرنی تشکیل دے سکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arccosh فنکشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک کوسائن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "رینج [0 ، 1] میں ایک numpy سرنی کی اقدار کو معمول پر لانے کے ل you ، آپ مندرجہ ذیل فارمولے کو استعمال کرسکتے ہیں: پائیٹون کوپی کوڈینورمالائزڈ_آرائی = (سرنی - این پی مین (سرنی)) / (این پی ایم میکس (سرنی) - این پی ایم (این پی۔سرنی)) اس فارمولے میں ، سرنی آپ کے اصل نمی سرنی کی نمائندگی کرتی ہے۔NP.MIN (سرنی) اور NP.MAX (سرنی) کے افعال بالترتیب سرنی کی کم سے کم اور زیادہ سے زیادہ اقدار کا حساب لگاتے ہیں۔ یہاں ایک مثال ہے: Pythoncopy Codemport numpy As NP# ایک numpy arrayarray = np.array بنائیں ([1 ، 2، 3 ، 4 ، 5])# اقدار کو حد سے معمول بنائیں [0 ، 1] معمول کے مطابق_رای = (سرنی - np.min (سرنی)) / (np.max (سرنی) - np.min (سرنی)) پرنٹ (پرنٹ (سرنی))\"اصل سرنی:\" ، سرنی) پرنٹ (\"نارملائزڈ سرنی:\" ، نارملائزڈ_آرے) آؤٹ پٹ: ریاضی کا کوڈورجینل سرنی: [1 2 3 4 5] معمول کی سرنی: [0۔0.25 0.5 0.75 1.] اس مثال میں ، ہمارے پاس اقدار [1 ، 2 ، 3 ، 4 ، 5] کے ساتھ ایک اصل نمی سرنی ہے۔ہم ہر عنصر سے سرنی کی کم سے کم قیمت کو گھٹا کر اور اسے کم سے کم اور زیادہ سے زیادہ اقدار کے مابین حد سے تقسیم کرکے معمول کے مطابق سرنی نارمل_یری کا حساب لگاتے ہیں۔اس کے نتیجے میں معمول کے مطابق_رائے کی حد [0 ، 1] کی قدر ہوتی ہے ، جہاں کم سے کم قیمت 0 پر نقش ہوتی ہے اور زیادہ سے زیادہ قیمت کو اس فارمولے کا استعمال کرتے ہوئے 1. کے ذریعہ نقشہ لگایا جاتا ہے ، آپ آسانی سے ایک نمی صف کی اقدار کو حد تک معمول بنا سکتے ہیں [0 ، 1]۔"
    },
    {
        "Question": "ابتدائی قدر کے ساتھ numpy.cumsum فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "عنصر کے مطابق کراس پروڈکٹ کی وضاحت نمی صفوں کے لئے نہیں کی گئی ہے کیونکہ کراس پروڈکٹ آپریشن عام طور پر ویکٹروں یا مخصوص طول و عرض کے ساتھ صفوں پر انجام دیا جاتا ہے۔کراس پروڈکٹ ایک ویکٹر آپریشن ہے جو تین جہتی جگہ میں دو ان پٹ ویکٹروں کے لئے ایک نئے ویکٹر کے کھڑے کا حساب لگاتا ہے۔ اگر آپ کے پاس دو تھری ڈی ویکٹر ہیں جن کی نمائندگی نمی اری کے طور پر کی جاتی ہے تو ، آپ ان کی کراس پروڈکٹ کا حساب لگانے کے لئے NP.cross () فنکشن استعمال کرسکتے ہیں۔تاہم ، NP.cross () فنکشن پورے ویکٹروں پر کام کرتا ہے ، عنصر کے لحاظ سے نہیں۔ یہاں ایک مثال ہے: Pythoncopy Codemport numpy As NP# دو 3D ویکٹر کو numpy arraysvector1 = np.array ([1 ، 2 ، 3] کے طور پر بنائیں ([1 ، 2 ، 3]) ویکٹر 2 = np.array ([4 ، 5 ، 6]])# ویکٹرس کراس_ پروڈکٹ = np.cross (ویکٹر 1 ، ویکٹر 2) پرنٹ (\"ویکٹر 1:\" ، ویکٹر 1) پرنٹ (\"ویکٹر 2:\" ، کے کراس پروڈکٹ کا حساب لگائیں۔ویکٹر 2) پرنٹ (\"کراس پروڈکٹ:\" ، کراس_ پروڈکٹ) آؤٹ پٹ: لیس کوپی کوڈ ویکٹر 1: [1 2 3] ویکٹر 2: [4 5 6] کراس پروڈکٹ: [-3 6 -3] اس مثال میں ، ہمارے پاس دو 3D ویکٹر ہیںnumpy arrays vector1 اور ویکٹر 2 کے طور پر نمائندگی.NP.CROSS (ویکٹر 1 ، ویکٹر 2) کو کال کرکے ، ہم ان کے کراس پروڈکٹ کا حساب لگاتے ہیں اور نتیجے میں ویکٹر کراس_ پروڈکٹ حاصل کرتے ہیں۔ اگر آپ کے پاس ایک ہی شکل کی دو نپی آریاں ہیں اور آپ عنصر کے لحاظ سے آپریشن کرنا چاہتے ہیں ، جیسے ملٹی متعلقہ عناصر ،آپ * آپریٹر استعمال کرسکتے ہیں۔تاہم ، نوٹ کریں کہ یہ کراس پروڈکٹ آپریشن نہیں بلکہ ایک سادہ عنصر کے مطابق ضرب ہے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، عنصر کے حساب سے مجموعی مصنوعات کا حساب کتاب کرنے کے لئے ایک فنکشن لکھیں جو ایک تکرار نقطہ نظر کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ ہوتا ہے۔\"",
        "Answer": "دو numpy صفوں کے عنصر کے مطابق ڈاٹ پروڈکٹ کا حساب لگانے کے ل you ، آپ آسانی سے * آپریٹر استعمال کرسکتے ہیں۔* آپریٹر دو صفوں کے درمیان عنصر کے حساب سے ضرب انجام دیتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# دو numpy arraysarray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6])# عنصر کے مطابق ڈاٹ پروڈکٹ ڈوٹ_ پروڈکٹ = کا حساب لگائیںarray1 * array2 پرنٹ (\"سرنی 1:\" ، array1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"ڈاٹ پروڈکٹ:\" ، ڈاٹ_ پروڈکٹ) آؤٹ پٹ: ریاضی کاپی کوڈرری 1: [1 2 3] سرنی 2: [4 5 6] ڈاٹ پروڈکٹ: [4 10 18] اس مثال میں ، ہمارے پاس بالترتیب اقدار [1 ، 2 ، 3] اور [4 ، 5 ، 6] کے ساتھ دو نمی اری اری اور سرنی 2 ہیں۔اری 1 * سرنی 2 کو انجام دے کر ، ہم عنصر کے مطابق ڈاٹ پروڈکٹ کا حساب لگاتے ہیں ، جس کے نتیجے میں صف [4 ، 10 ، 18] ہوتی ہے۔ نوٹ کریں کہ یہ آپریشن ویکٹر یا میٹرکس ضرب کی ڈاٹ پروڈکٹ کی طرح نہیں ہے۔عنصر کے مطابق ڈاٹ پروڈکٹ دونوں صفوں کے متعلقہ عناصر کو ایک ساتھ بڑھاتا ہے۔"
    },
    {
        "Question": "لوپ کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر کے مطابق لاجسٹک سگمائڈ فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو numpy صفوں کے مابین عنصر کے مطابق مطلق فرق کا حساب لگانے کے ل you ، آپ NP.ABS () فنکشن استعمال کرسکتے ہیں۔NP.ABS () فنکشن صف میں ہر عنصر کی مطلق قیمت کا حساب لگاتا ہے۔یہاں ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی# دو نیمپی اریزرری 1 = این پی.ارے بنائیں ([1 ، 2 ، 3]) سرنی 2 = این پی.ارے ([4 ، 5 ، 6])# عنصر کے مطابق مطلق اختلافات_ڈف = کا حساب لگائیں۔np.abs (arry1 - array2) پرنٹ (\"سرنی 1:\" ، arry1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"مطلق فرق:\" ، Abs_diff) آؤٹ پٹ: لیس کوپی کوڈرری 1: [1 2 3] سرنی2: [4 5 6] مطلق فرق: [3 3 3] اس مثال میں ، ہمارے پاس دو نپی سرنی سرنی 1 اور سرنی 2 ہیں جن کی اقدار [1 ، 2 ، 3] اور [4 ، 5 ، 6] کے ساتھ ہیں۔سرنی 1 سے اری 2 کو گھٹانے اور NP.ABS () کا استعمال کرتے ہوئے مطلق قدر لینے سے ، ہم عنصر کے مطابق مطلق فرق کا حساب لگاتے ہیں ، جس کے نتیجے میں صف [3 ، 3 ، 3] ہوتا ہے۔ NP.ABS () فنکشن کا حساب کتاب کرنے کے لئے استعمال کیا جاسکتا ہے۔ان کی شکلوں یا سائز سے قطع نظر ، دو صفوں کے درمیان مطلق فرق۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arctanh فنکشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک ٹینجینٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر وار آرکٹینجنٹ کا حساب لگانے کے ل you ، آپ NP.arctan () فنکشن استعمال کرسکتے ہیں۔NP.ARCTAN () فنکشن ان پٹ سرنی کے عنصر وار آرکٹینجنٹ (الٹا ٹینجینٹ) لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayArray = np.Array ([0 ، 1 ، -1]) بنائیں ([0 ، 1 ، -1])# عنصر کے مطابق آرکٹینجنٹارکٹین_آرے = np.arctan (سرنی) پرنٹ (\"سرنی:\" ، سرنی کا حساب لگائیں۔) پرنٹ (\"آرکٹینجینٹ سرنی:\" ، آرکٹن_اری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [0 1 -1] آرکٹینجینٹ سرنی: [0. 0.78539816 -0.78539816] اس مثال میں ، ہمارے پاس ایک نپری سرنی ہے جس کی اقدار [0 ، 1 ، ، 1 ، 1 ، 1 ہیں۔-1]۔NP.ARCTAN (سرنی) کو کال کرکے ، ہم سرنی کے عنصر وار آرکٹینجنٹ کا حساب لگاتے ہیں اور نتیجے میں سرنی آرکٹن_ارے حاصل کرتے ہیں۔ NP.arctan () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر آرکٹینجنٹ فنکشن کا اطلاق کرتا ہے۔انفرادی طور پرنتیجے میں سرنی کی شکل ان پٹ سرنی کی طرح ہوگی۔"
    },
    {
        "Question": "numpy.add.accumulate فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق ہائپربولک سائن کا حساب لگانے کے ل you ، آپ NP.SINH () فنکشن استعمال کرسکتے ہیں۔NP.SINH () فنکشن ان پٹ سرنی کے ہائپربولک سائن کو لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.Array ([0 ، 1 ، 2]) بنائیں ([0 ، 1 ، 2])# عنصر کے مطابق ہائپربولک sinesinh_array = np.sinh (سرنی) پرنٹ (\"سرنی:\" ، سرنی کا حساب لگائیں) پرنٹ (\"ہائپربولک سائن سرنی:\" ، سینہ_ری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [0 1 2] ہائپربولک سائن سرنی: [0۔1.17520119 3.62686041] اس مثال میں ، ہمارے پاس اقدار [0 ، 1 ، 2] کے ساتھ ایک نمی سرنی ہے۔NP.SINH (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق ہائپربولک سائن کا حساب لگاتے ہیں اور نتیجے میں سرنی sinh_array حاصل کرتے ہیں۔ NP.SINH () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور اس میں ہائپربولک سائن فنکشن کا اطلاق ہوتا ہے۔ہر عنصر انفرادی طور پر۔نتیجے میں سرنی کی شکل ان پٹ سرنی کی طرح ہوگی۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، numpy.multiply.reduce فنکشن کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق ہائپربولک کوسائن کا حساب لگانے کے ل you ، آپ NP.COSH () فنکشن استعمال کرسکتے ہیں۔NP.COSH () فنکشن ان پٹ سرنی کے ہائپربولک کوسائن کو لوٹاتا ہے۔اس کی ایک مثال یہ ہے: Pythoncopy Codemport numpy as np# ایک numpy arrayarray = np.Array ([0 ، 1 ، 2]] بنائیں ([0 ، 1 ، 2])# عنصر کے مطابق ہائپربولک cosinecosh_array = np.cosh (سرنی) پرنٹ (\"سرنی:\" ، سرنی کا حساب لگائیں) پرنٹ (\"ہائپربولک کوسائن سرنی:\" ، COSH_ARRAY) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [0 1 2] ہائپربولک کوسائن سرنی: [1.1.54308063 3.76219569] اس مثال میں ، ہمارے پاس اقدار [0 ، 1 ، 2] کے ساتھ ایک نمی سرنی ہے۔NP.COSH (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق ہائپربولک کوسائن کا حساب لگاتے ہیں اور نتیجے میں سرنی COSH_ARRAY حاصل کرتے ہیں۔ NP.COSH () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور اس میں ہائپربولک کوسائن فنکشن کا اطلاق ہوتا ہے۔ہر عنصر انفرادی طور پر۔نتیجے میں سرنی کی شکل ان پٹ سرنی کی طرح ہوگی۔"
    },
    {
        "Question": "numpy.einsum فنکشن کا استعمال کرتے ہوئے ایک numpy سرے کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق ہائپربولک ٹینجینٹ کا حساب لگانے کے ل you ، آپ NP.TANH () فنکشن استعمال کرسکتے ہیں۔NP.TANH () فنکشن ان پٹ سرنی کے ہائپربولک ٹینجینٹ کو لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.array ([0 ، 1 ، -1]) بنائیں# عنصر کے مطابق ہائپربولک Tangenttanh_array = np.tanh (سرنی) پرنٹ (\"سرنی:\" ، ، \"سرنی) پرنٹ (\"ہائپربولک ٹینجینٹ سرنی:\" ، تنہ_ری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈئری: [0 1 -1] ہائپربولک ٹینجینٹ سرنی: [0. 0.76159416 -06159416] اس مثال کے ساتھ ، ہمارے پاس اقدار کے ساتھ ایک نمی سرنی ہے۔، 1 ، -1]۔NP.TANH (سرنی) کو فون کرکے ، ہم سرنی کے عنصر کے مطابق ہائپربولک ٹینجنٹ کا حساب لگاتے ہیں اور نتیجے میں سرنی tanh_array حاصل کرتے ہیں۔ NP.Tanh () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور اس میں ہائپربولک ٹینجینٹ فنکشن کا اطلاق ہوتا ہے۔ہر عنصر انفرادی طور پر۔نتیجے میں سرنی کی شکل ان پٹ سرنی کی طرح ہوگی۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، لوپ کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک ٹینجینٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر وار آرکسین (الٹا سائن) کا حساب لگانے کے ل you ، آپ NP.Arcsin () فنکشن استعمال کرسکتے ہیں۔NP.ARCSIN () فنکشن ان پٹ سرنی کی آرکسین لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.Array ([0 ، 0.5 ، 1]) بنائیں# عنصر کے مطابق آرکسینرکسین_ارے = np.arcsin (سرنی) پرنٹ (\"سرنی:\" ، سرنی) کا حساب لگائیں۔پرنٹ (\"آرکسین سرنی:\" ، آرکسن_ری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [0۔0.5 1.] آرکسین سرنی: [0۔0.52359878 1.57079633] اس مثال میں ، ہمارے پاس اقدار [0 ، 0.5 ، 1] کے ساتھ ایک نمی سرنی ہے۔NP.ARCSIN (سرنی) کو کال کرکے ، ہم سرنی کے عنصر وار آرکسین کا حساب لگاتے ہیں اور نتیجے میں سرنی آرکسن_ارے حاصل کرتے ہیں۔ NP.Arcsin () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر آرکسین فنکشن کا اطلاق کرتا ہے۔انفرادی طور پرنتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: آرکسین فنکشن ریڈیوں میں اقدار کو لوٹاتا ہے۔"
    },
    {
        "Question": "فہرست کی تفہیم کا استعمال کرتے ہوئے کسی نمی سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نپی سرنی کے عنصر وار آرکوسین (الٹا کوسائن) کا حساب لگانے کے ل you ، آپ NP.Arccos () فنکشن استعمال کرسکتے ہیں۔NP.ARCCOS () فنکشن ان پٹ سرنی کے آرکوسین کو لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.Array ([1 ، 0.5 ، 0]) بنائیں# عنصر کے مطابق آرکوسینئیرکوس_آرے = np.arccos (سرنی) پرنٹ (\"سرنی:\" ، سرنی) کا حساب لگائیں۔پرنٹ (\"آرکوسین سرنی:\" ، آرکوس_ری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [1۔0.5 0.] آرکوسین سرنی: [0.1.04719755 1.57079633] اس مثال میں ، ہمارے پاس اقدار [1 ، 0.5 ، 0] کے ساتھ ایک نمی سرنی ہے۔NP.Arccos (سرنی) کو کال کرکے ، ہم سرنی کے عنصر وار آرکوسین کا حساب لگاتے ہیں اور نتیجے میں سرنی آرکوس_ارے حاصل کرتے ہیں۔ NP.Arccos () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر آرکوسین فنکشن کا اطلاق کرتا ہے۔انفرادی طور پرنتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: آرکوسین فنکشن ریڈیوں میں اقدار کو لوٹاتا ہے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، numpy.multiply.accumulate فنکشن کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "نیمپی کسی نمی سرنی کے عنصر وار آرک کوٹینجنٹ (الٹا کوٹینجنٹ) کا حساب لگانے کے لئے بلٹ ان فنکشن فراہم نہیں کرتا ہے۔تاہم ، آپ عنصر کے مطابق آرکوٹینجنٹ کی گنتی کے ل some کچھ اضافی حساب کتاب کے ساتھ NP.arctan () فنکشن کا استعمال کرسکتے ہیں۔آرکوٹینجنٹ کو π/2 اور آرکٹینجنٹ کے درمیان فرق کے طور پر ظاہر کیا جاسکتا ہے۔ یہاں ایک مثال ہے کہ آپ ایک نپی سرنی کے عنصر کے مطابق آرکوٹینجنٹ کا حساب کیسے لگاسکتے ہیں: پیتھون کوپی کوڈیمپورٹ نام کو این پی کے طور پر این پی# ایک نیمپری اری آرے = این پی آر آرے بنائیں ([[[[[[1 ، 0.5 ، -1])# عنصر کے حساب سے آرکوٹینجینٹارککوٹ_آرے = np.pi/2 -np.arctan (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"آرکوٹینجینٹ سرنی:\" ، آرک کوٹ_رے) آؤٹ پٹ: جاوا اسکرپٹ کوپیکوڈرری: [1. 0.5 -1.] آرکوٹینجینٹ سرنی: [0.78539816 1.10714872 2.35619449] اس مثال میں ، ہمارے پاس اقدار [1 ، 0.5 ، -1] کے ساتھ ایک نمی سرنی ہے۔π/2 سے سرنی کے آرکٹینجنٹ کو گھٹانے سے ، ہم عنصر کے مطابق آرکوٹینجنٹ حاصل کرتے ہیں اور اسے آرکوٹ_اری میں اسٹور کرتے ہیں۔ اس کے نتیجے میں سرنی آرکوٹ_رے کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: آرکوٹینجنٹ فنکشن ریڈین میں اقدار کو لوٹاتا ہے۔"
    },
    {
        "Question": "numpy.vectorize فنکشن کا استعمال کرتے ہوئے ایک numpy سرے کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نپی سرنی کے عنصر کے مطابق آرکسن (الٹا ہائپربولک سائن) کا حساب لگانے کے ل you ، آپ NP.Arcsinh () فنکشن استعمال کرسکتے ہیں۔NP.ARCSINH () فنکشن ان پٹ سرنی کے آرکسن کو لوٹاتا ہے۔اس کی ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.array ([0 ، 1 ، -1]) بنائیں ([0 ، 1 ، -1])# عنصر کے مطابق آرکسین ہارکسین ہ_ارے = np.arcsinh (سرنی) پرنٹ (\"سرنی:\" ، سرنی: \"،\" سرنی: \") پرنٹ (\"آرکسن سرے:\" ، آرکنسن ہ_ارری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈئری: [0 1 -1] آرکسننہ سرنی: [0. 0.88137359 -0.88137359] اس مثال میں ، ہمارے پاس اقدار [0 ، 1 ، 1 ، 1 کے ساتھ ایک نپری صف ہے۔-1]۔NP.Arcsinh (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق آرکسن ایچ کا حساب لگاتے ہیں اور نتیجے میں سرنی آرکینح_ارے کو حاصل کرتے ہیں۔ این پی.اارکسین ایچ () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر آرکسن فنکشن کا اطلاق کرتا ہے۔انفرادی طور پراس کے نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: آرکین ہین فنکشن ریڈینز میں اقدار کو لوٹاتا ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، ایک تکرار نقطہ نظر کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک ٹینجینٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک نپی سرنی کے عنصر وار آرکوش (الٹا ہائپربولک کوسائن) کا حساب لگانے کے ل you ، آپ NP.Arccosh () فنکشن استعمال کرسکتے ہیں۔NP.ARCCOSH () فنکشن ان پٹ سرنی کے آرکوش کو لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.array ([1 ، 2 ، 3]) بنائیں# عنصر کے مطابق آرکوکوشرکوش_ارے = np.arccosh (سرنی) پرنٹ (\"سرنی:\" ، سرنی)پرنٹ (\"آرکوش سرنی:\" ، آرکوش_ری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [1 2 3] آرکوش سرنی: [0۔1.3169579 1.76274717] اس مثال میں ، ہمارے پاس اقدار [1 ، 2 ، 3] کے ساتھ ایک نمی سرنی ہے۔NP.Arccosh (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق آرکوش کا حساب لگاتے ہیں اور نتیجے میں سرنی آرکوش_ارے حاصل کرتے ہیں۔ NP.Arccosh () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر آرکوش فنکشن کا اطلاق کرتا ہے۔انفرادی طور پرنتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: آرکوش فنکشن ریڈینز میں اقدار کو لوٹاتا ہے۔"
    },
    {
        "Question": "numpy.ufunc.reduce فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نپی سرنی کے عنصر کے مطابق آرکٹان (الٹا ہائپربولک ٹینجینٹ) کا حساب لگانے کے ل you ، آپ NP.arctanh () فنکشن استعمال کرسکتے ہیں۔NP.arctanh () فنکشن ان پٹ سرنی کے آرکٹین کو لوٹاتا ہے۔یہاں ایک مثال یہ ہے: Pythoncopy Codemport numpy as Np# ایک numpy arrayarray = np.array ([0 ، 0.5 ، -0.8]) بنائیں ([0 ، 0.5 ، -0.8])# عنصر کے حساب سے آرکٹان ہارکٹرک_ارے = np.arctanh (سرنی) پرنٹ (\"سرنی:\" ، سرنی: \") پرنٹ (\"آرکٹانھ سرنی:\" ، آرکٹانھ_ریری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈئری: [0.5 -0 -0.8] آرکٹانھ سرنی: [0. 0.54930614 -1.098612229] اس مثال میں ، ہمارے پاس اقدار [0 ، 0.5 کے ساتھ ایک نپی سرنی ہے [0 ، 0.5، -0.8]۔NP.arctanh (سرنی) کو کال کرنے سے ، ہم سرنی کے عنصر وار آرکٹین کا حساب لگاتے ہیں اور نتیجے میں سرنی آرکٹانھ_رے حاصل کرتے ہیں۔ NP.arctanh () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر آرکٹان فنکشن کا اطلاق کرتا ہے۔انفرادی طور پراس کے نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: آرکٹانھ فنکشن ریڈینز میں اقدار کو لوٹاتا ہے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، numpy.multiply.outer فنکشن کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق لاجسٹک سگمائڈ فنکشن کا حساب لگانے کے ل you ، آپ سرنی اور ڈویژن آپریٹر کے عناصر کو ختم کرنے کے لئے NP.Exp () فنکشن کا استعمال کرسکتے ہیں / عنصر کے مطابق تقسیم کو انجام دینے کے ل .۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی# ایک نیمی اری آرے = این پی آرے بنائیں ([-1 ، 0 ، 1])# عنصر کے مطابق لاجسٹک سگمائڈسگمائڈ_ررے = 1 / (1 + np.exp (-array)) کا حساب لگائیں۔پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"سگمائڈ سرنی:\" ، سگمائڈ_ریری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈئری: [-1 0 1] سگمائڈ سرنی: [0.26894142 0.5 0.5 0.73105858] اس مثال کے ساتھ ، ہمارے پاس ایک نمی سرنی ہے۔اقدار [-1 ، 0 ، 1]۔1 / (1 + np.exp (-array)) کا حساب لگاتے ہوئے ، ہم سرنی کے ہر عنصر پر لاجسٹک سگمائڈ فنکشن کا اطلاق کرتے ہیں اور نتیجے میں سرنی سگمائڈ_اریے حاصل کرتے ہیں۔ لاجسٹک سگمائڈ فنکشن 1 / (1 + ایکسپ (-x (-x) کے طور پر بیان کیا گیا ہے۔)) ، جہاں ایکسپ () کفایت شعاری فنکشن ہے۔سگمائڈ فنکشن کسی بھی حقیقی نمبر کو رینج (0 ، 1) میں نقشہ بناتا ہے ، جس سے \"S\" کے سائز والے منحنی خطوط پیدا ہوتے ہیں۔یہ عام طور پر بائنری درجہ بندی کے مسائل کو ماڈل بنانے اور چالو کرنے کے افعال کے ل ne نیورل نیٹ ورکس میں استعمال ہوتا ہے۔ NP.Exp () numpy میں فنکشن سرنی کے ہر عنصر کی کفایت شعاری کا حساب لگاتا ہے ، اور ڈویژن آپریٹر / عنصر وار ڈویژن کو انجام دیتا ہے۔"
    },
    {
        "Question": "numpy.power فنکشن کا استعمال کرتے ہوئے ایک numpy سرے کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق سافٹ میکس فنکشن کا حساب لگانے کے ل you ، آپ مطلوبہ محور کے ساتھ ساتھ غیر متزلزل اقدار کے مطابق سرنی کے عناصر اور NP.SUM () فنکشن کو ختم کرنے کے لئے NP.EXP () فنکشن کا استعمال کرسکتے ہیں۔یہاں ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نوم کے بطور NP# ایک numpy arrayArray = np.Array ([1 ، 2 ، 3]) بنائیں# عنصر کے مطابق سافٹ میکسسوفٹ میکس_ارے = np.exp (سرنی) / np.sum (np.exp (np.exp (np.exp (np.expسرنی)) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"سافٹ میکس سرنی:\" ، سافٹ میکس_ رے) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [1 2 3] سافٹ میکس سرنی: [0.09003057 0.24472847 0.66524096] اس مثال میں ، ہمارے پاس ایک نپپی ایرا ہے۔اقدار [1 ، 2 ، 3] کے ساتھ۔NP.EXP (سرنی) / NP.SUM (NP.EXP (سرنی)) کا حساب لگاتے ہوئے ، ہم سافٹ میکس فنکشن کو سرنی کے ہر عنصر پر لاگو کرتے ہیں اور نتیجے میں سرنی سافٹ میکس_ارے کو حاصل کرتے ہیں۔ سافٹ میکس فنکشن عام طور پر مشین لرننگ اور گہری سیکھنے میں استعمال ہوتا ہے۔ملٹی کلاس درجہ بندی کے مسائل کے ل .۔یہ ایک ان پٹ سرنی کو کلاسوں میں امکانی تقسیم میں تبدیل کرتا ہے ، جہاں ہر عنصر متعلقہ طبقے کے امکان کی نمائندگی کرتا ہے۔سافٹ میکس فنکشن کو ایکسپ (ایکس) / سم (ایکسپ (ایکس)) کے طور پر بیان کیا گیا ہے ، جہاں ایکسپ () کفایت شعاری فنکشن ہے اور رقم () مطلوبہ محور کے ساتھ ساتھ خفیہ اقدار کی رقم کا حساب لگاتا ہے۔ نوٹ: سافٹ میکس فنکشن عام طور پر ہوتا ہےصف کے آخری محور کے ساتھ لگایا گیا ، یہ فرض کرتے ہوئے کہ سرنی کا ہر عنصر ایک علیحدہ طبقے یا زمرے کی نمائندگی کرتا ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، فہرست کی تفہیم کا استعمال کرتے ہوئے عنصر کے مطابق الٹا ہائپربولک ٹینجینٹ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق لوگرتھم (بیس 2) کا حساب لگانے کے ل you ، آپ NP.log2 () فنکشن استعمال کرسکتے ہیں۔NP.LOG2 () فنکشن ان پٹ سرنی کے لوگرتھم (بیس 2) لوٹاتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayArray = np.Array ([2 ، 4 ، 8]) بنائیں ([2 ، 4 ، 8])# عنصر کے مطابق لوگرتھم (بیس 2) لاگ 2_آرے = np.log2 (سرنی) پرنٹ (\"سرنی) پرنٹ کریں (\" سرنی): \"، سرنی) پرنٹ (\" لاگ 2 سرنی: \"، لاگ 2_ری) آؤٹ پٹ: ریاضی کاپی کوڈرری: [2 4 8] لاگ 2 سرنی: [1۔2. 3.] اس مثال میں ، ہمارے پاس اقدار [2 ، 4 ، 8] کے ساتھ ایک نمی سرنی ہے۔NP.log2 (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق لوگرتھم (بیس 2) کا حساب لگاتے ہیں اور نتیجے میں سرنی لاگ 2_آرے حاصل کرتے ہیں۔ NP.log2 () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ لوگرتھم کو لاگو کرتا ہے۔(بیس 2) ہر عنصر میں انفرادی طور پر کام کریں۔اس کے نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ نوٹ: لوگرتھم (بیس 2) عام طور پر کمپیوٹر سائنس اور انفارمیشن تھیوری میں انفارمیشن مواد کی پیمائش کرنے اور بائنری سسٹم سے متعلق حساب کتاب کرنے کے لئے استعمال ہوتا ہے۔"
    },
    {
        "Question": "numpy.ufunc.accumulate فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق مجموعی مجموعی حساب کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق مربع کا حساب لگانے کے ل you ، آپ NP.Square () فنکشن استعمال کرسکتے ہیں۔NP.SQUARE () فنکشن ان پٹ سرنی کے عنصر وار مربع کو لوٹاتا ہے۔یہاں ایک مثال ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی# ایک نیمپی اری آرے = این پی آرے ([1 ، 2 ، 3]) بنائیں ([1 ، 2 ، 3])# عنصر کے مطابق اسکوائرس کوئرڈ_آرے = این پی.سکیئر (سرنی) پرنٹ (\"سرنی:\" ، سرنی) کا حساب لگائیں۔پرنٹ (\"اسکوائرڈ سرنی:\" ، اسکوائرڈ_ری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [1 2 3] مربع سرنی: [1 4 9] اس مثال میں ، ہمارے پاس اقدار [1 ، 2 ، 3] کے ساتھ ایک نمی سرنی ہے۔NP.SQUARE (سرنی) کو کال کرکے ، ہم سرنی کے عنصر وار مربع کا حساب لگاتے ہیں اور نتیجے میں سرنی اسکوائر_آرے حاصل کرتے ہیں۔ NP.SQUARE () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور یہ ہر عنصر پر مربع آپریشن کا اطلاق کرتا ہے۔انفرادی طور پراس کے نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ کسی صف کے مربع کو کیلکولیٹ کرنا ہر عنصر کو 2 کی طاقت میں بڑھانے کے مترادف ہے۔ یہ مختلف ریاضی اور کمپیوٹیشنل کاموں میں ایک عام آپریشن ہے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، numpy.prod فنکشن کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر وار مکعب کا حساب لگانے کے ل you ، آپ NP.POWER () فنکشن کو استعمال کرسکتے ہیں جس میں 3 پر سیٹ کیا جاتا ہے۔یہاں ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayArray = np.array ([1 ، 2 ، 3]) بنائیں# عنصر کے مطابق کیوب کیوبڈ_آرے = np.power (سرنی ، 3) پرنٹ (\"سرنی:\" ، ، \"کا حساب لگائیں۔سرنی) پرنٹ (\"کیوبڈ سرنی:\" ، کیوبڈ_آرے) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [1 2 3] کیوبڈ سرنی: [1 8 27] اس مثال میں ، ہمارے پاس اقدار کے ساتھ ایک نمی سرنی ہے [1 ، 2 ، 3]این پی پاور (سرنی ، 3) پر کال کرکے ، ہم سرنی کے عنصر وار مکعب کا حساب لگاتے ہیں اور نتیجے میں سرنی کیوبڈ_آرے حاصل کرتے ہیں۔ہر عنصر انفرادی طور پر۔نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ ایک صف کے مکعب کو کیلکولیٹ کرنا ہر عنصر کو 3 کی طاقت میں بڑھانے کے مترادف ہے۔ یہ ریاضی اور کمپیوٹیشنل کاموں میں ایک عام آپریشن ہے۔"
    },
    {
        "Question": "numpy.piecise فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نمی سرنی کے عنصر کے مطابق مکعب کی جڑ کا حساب لگانے کے ل you ، آپ NP.CBRT () فنکشن استعمال کرسکتے ہیں۔NP.CBRT () فنکشن ان پٹ سرنی کے مکعب کی جڑ کو لوٹاتا ہے۔اس کی ایک مثال یہ ہے: Pythoncopy Codemport numpy as np# ایک numpy arrayarray = np.Array ([1 ، 8 ، 27]) بنائیں ([1 ، 8 ، 27])# عنصر کے مطابق کیوب روٹ کیوبڈ_روٹ_رائی = np.cbrt (سرنی) پرنٹ (\"سرنی:\" ، سرنی کا حساب لگائیں۔) پرنٹ (\"کیوب روٹ سرنی:\" ، کیوبڈ_روٹ_آرے) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 8 27] مکعب کی جڑ کی صف: [1.2. 3.] اس مثال میں ، ہمارے پاس ایک نمی سرنی ہے جس میں اقدار [1 ، 8 ، 27] ہیں۔NP.CBRT (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق مکعب کی جڑ کا حساب لگاتے ہیں اور نتیجے میں سرنی کیوبڈ_روٹ_ارے حاصل کرتے ہیں۔ہر عنصر انفرادی طور پر۔نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ کسی صف کے مکعب کی جڑ کو کیلکولیٹ کرنا اس نمبر کو تلاش کرنے کے مترادف ہے جو ، جب 3 کی طاقت میں اٹھایا جاتا ہے تو ، ان پٹ سرنی کے ہر عنصر کو دیتا ہے۔یہ ریاضی اور کمپیوٹیشنل کاموں میں ایک عام آپریشن ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.arcosh فنکشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سیکنڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے ل you ، آپ NP.EXP () فنکشن استعمال کرسکتے ہیں۔NP.EXP () فنکشن ان پٹ سرنی میں ہر عنصر کی کفایت شعاری کی گنتی کرتا ہے۔یہاں ایک مثال یہ ہے: پیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی# ایک نیمپی اری آرے = این پی آرے بنائیں۔پرنٹ (\"کفایت شعاری سرنی:\" ، ایکسپونشنل_ریری) آؤٹ پٹ: جاوا اسکرپٹ کوپی کوڈرری: [1 2 3] کفایت شعاری صف: [2.71828183 7.3890561 20.08553692] اس مثال میں ، ہمارے پاس اقدار [1 ، 2 ، 3] کے ساتھ ایک نپری سرنی ہے۔NP.EXP (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق کفایت شعاری کا حساب لگاتے ہیں اور نتیجے میں سرنی کو حاصل کرتے ہیں۔انفرادی طور پرنتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ کسی سرنی کی صریح کو کیلکولیٹ کرنا ان پٹ سرنی میں ہر عنصر کی طاقت کے مطابق ریاضی کے مستقل ای کی قدر تلاش کرنے کے مترادف ہے۔مختلف ریاضی اور سائنسی حساب کتاب میں یہ ایک عام آپریشن ہے۔"
    },
    {
        "Question": "numpy.apply_along_axis فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق الٹا ٹینجنٹ (آرکٹینجنٹ) کا حساب لگانے کے ل you ، آپ NP.arctan () فنکشن استعمال کرسکتے ہیں۔NP.ARCTAN () فنکشن ان پٹ سرنی میں ہر عنصر کے الٹا ٹینجینٹ (ریڈین میں) واپس کرتا ہے۔یہاں ایک مثال ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NP# ایک numpy arrayarray = np.array ([0 ، 1 ، -1]) بنائیں# عنصر کے مطابق الٹا tangentinverse_tan_array = np.arctan (سرنی) پرنٹ (\"سرنی:\"سرنی) پرنٹ (\"الٹا ٹینجینٹ سرنی:\" ، الٹا_تان_آرے) آؤٹ پٹ: ریاضی کاپی کوڈآرری: [0 1 -1] الٹا ٹینجنٹ سرنی: [0. 0.78539816 -0.78539816] اس مثال میں ، ہمارے پاس اقدار [0 کے ساتھ ایک نپپ سرنی ہے۔، 1 ، -1]۔NP.ARCTAN (سرنی) کو کال کرکے ، ہم سرنی کے عنصر کے مطابق الٹا ٹینجنٹ کا حساب لگاتے ہیں اور نتیجے میں سرنی الٹا_ٹان_ارے حاصل کرتے ہیں۔ NP.arctan () فنکشن کسی بھی شکل اور سائز کی صفوں کو سنبھال سکتا ہے ، اور اس سے الٹا ٹینجنٹ آپریشن کا اطلاق ہوتا ہے۔ہر عنصر انفرادی طور پر۔نتیجے میں ہونے والی صف کی شکل ان پٹ سرنی کی طرح ہوگی۔ کسی صف کے الٹا ٹینجنٹ کو کیلکولیٹ کرنا زاویہ (ریڈینز میں) تلاش کرنے کے مترادف ہے جس کا ٹینجینٹ ان پٹ سرنی میں ہر عنصر کے برابر ہے۔مختلف ریاضی اور سائنسی حساب کتاب میں یہ ایک عام آپریشن ہے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، فہرست کی تفہیم کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو 0 اور 1 کے درمیان ایک نمی سرنی کی اقدار کو معمول بناتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کو معمول کے مطابق_رای (سرنی): Min_val = np.min (سرنی) میکس_وال = np.max (سرنی) معمول کی_رای = (صف -MIN_VAL) / (میکس_وال - MIN_VAL) واپس معمول کے مطابق_رائے# مثال کے طور پر usagearray = np.Array ([1 ، 2 ، 3 ، 4 ، 5]) معمول پر مبنی_رای = معمول کے_رائے (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"معمول کی سرنی).0.25 0.5 0.75 1.] اس مثال میں ، نارملائز_ری () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے۔اس میں پہلے بالترتیب NP.MIN () اور NP.MAX () افعال کا استعمال کرتے ہوئے سرنی کی کم سے کم اور زیادہ سے زیادہ اقدار ملتی ہیں۔اس کے بعد ، یہ کم سے کم قیمت کو گھٹا کر اور حد (زیادہ سے زیادہ قیمت مائنس کم سے کم قیمت) کے ذریعہ تقسیم کرکے معمول کی صف کا حساب لگاتا ہے۔اس سے یہ یقینی بنتا ہے کہ معمول کی سرنی اقدار 0 اور 1. کے درمیان پڑتی ہیں۔یہ معمول کے مطابق سرنی عنصر کے حساب سے گنتی کرے گا اور نتیجے میں معمول کی صف کو واپس کرے گا۔"
    },
    {
        "Question": "کسٹم فنکشن کے ساتھ numpy.vectorize فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو دیئے گئے وزن پر مبنی ایک نمی سرنی کی وزن کی اوسط کا حساب لگاتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف ویٹڈ_ایوریج (سرنی ، وزن): # چیک کریں کہ آیا سرنی اور وزن ایک ہی شکل ہے اگر سرنی۔ شپ! = وزن!.شپ: ویلیو ایرر (\"سرنی اور وزن میں ایک ہی شکل ہونی چاہئے۔\") # وزن کو معمول پر لائیں_ایوائٹس = وزن / np.sum (وزن) # وزن والے اوسط وزن والے_ایگ = np.sum (سرنی * عام_ایئٹ) واپسی وزن_ایگ # کا حساب لگائیں۔مثال کے طور پر usagearray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) وزن = np.array ([[0.1 ، 0.2 ، 0.3 ، 0.2 ، 0.2]) نتیجہ = وزن والے_اوریج (سرنی ، وزن) پرنٹ (\"سرنی:\"، سرنی) پرنٹ (\" وزن: \"، وزن) پرنٹ (\" وزن اوسط: \"، نتیجہ) آؤٹ پٹ: یامل کوپی کوڈرری: [1 2 3 4 5] وزن: [0.1 0.2 0.3 0.2 0.2 0.2] وزن اوسط: 3.2 اس میںمثال کے طور پر ، ویٹڈ_اوریج () فنکشن ان پٹ کے طور پر دو نمی سرنی لیتا ہے: سرنی ، جس میں اقدار اور وزن ہوتا ہے ، جس میں ہر قیمت کے لئے متعلقہ وزن ہوتا ہے۔یہ پہلے چیک کرتا ہے کہ آیا سرنی اور وزن ایک ہی شکل ہے۔اس کے بعد ، یہ وزن کو معمول پر لاتا ہے تاکہ ان کو تمام وزن کے حساب سے تقسیم کیا جاسکے تاکہ وہ اس بات کو یقینی بناتے ہیں کہ وہ 1.1 تک کا اضافہ کریں ، فنکشن عام وزن کے ساتھ صف کے عنصر کے حساب سے وزن کے اوسط کا حساب لگاتا ہے اور نتائج کا خلاصہ کرتے ہیں۔ آپ کر سکتے ہیں۔اس فنکشن کو ایک ہی شکل کی کسی بھی طرح کی صفوں کے ساتھ استعمال کریں ، جس سے آپ اقدار کے کسی بھی سیٹ کے ل custom اپنی مرضی کے مطابق وزن پر مبنی وزن کی اوسط کی گنتی کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، لوپ کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سیکنڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو ایک numpy صف کی عنصر کے مطابق مجموعی مصنوع کی گنتی کرتی ہے: Pythoncopy Codemport numpy as npdef cumulative_product (سرنی): cumulative_array = np.cumprod (سرنی) واپسی cumulative_array# مثال usagearray = np.array2 ، 3 ، 4 ، 5]) مجموعی_رای = مجموعی_ پروڈکٹ (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"مجموعی مصنوعات کی سرنی:\" ، مجموعی_رای) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 2 3 4 5] مجموعی مصنوع کی سرنی.یہ سرنی عناصر کی مجموعی مصنوعات کی گنتی کے لئے NP.Cumprod () فنکشن کا استعمال کرتا ہے۔NP.CUMPROD () فنکشن ایک صف لوٹاتا ہے جہاں ہر عنصر ان پٹ سرنی سے متعلقہ عناصر کی مجموعی مصنوعات ہوتا ہے۔ آپ اس فنکشن کو کسی بھی طرح کی شکل اور سائز سے قطع نظر ، کسی بھی نمی سرنی کے ساتھ استعمال کرسکتے ہیں۔یہ مجموعی مصنوع کے عنصر کے حساب سے حساب کتاب کرے گا اور نتیجے میں ہونے والی صف کو واپس کرے گا۔"
    },
    {
        "Question": "numpy.add.at فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو 2 ڈی نیپی سرنی کے قطار کے لحاظ سے اور کالم وار رقم کا حساب لگاتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کے حساب کتاب_سوم (سرنی): قطار_سومز = این پی ایس او ایم (سرنی ، محور = 1) کول_سمز = این پی ایس یو ایم۔..[7 8 9]] قطار کی رقم: [6 15 24] کالم کی رقم: [12 15 18] اس مثال میں ، حساب کتاب_سوم () فنکشن ان پٹ کے طور پر 2 ڈی نیپی سرنی لیتا ہے۔کالم کے حساب سے رقم کا حساب لگانے کے لئے قطار کے حساب سے رقم اور محور = 0 کا حساب لگانے کے لئے یہ محور = 1 کے ساتھ NP.SUM () فنکشن کا استعمال کرتا ہے۔محور پیرامیٹر محور کی وضاحت کرتا ہے جس کے ساتھ ساتھ خلاصہ انجام دیا جاتا ہے۔ فنکشن دو صفوں کو لوٹاتا ہے: قطار_سوم جس میں ہر قطار کا مجموعہ ہوتا ہے ، اور کرنل_سوم جس میں ہر کالم کا مجموعہ ہوتا ہے۔ آپ اس فنکشن کو کسی بھی 2 ڈی نپی سرنی کے ساتھ استعمال کرسکتے ہیںصف وار اور کالم وار رقم کا حساب لگائیں۔"
    },
    {
        "Question": "\"ایک 2 ڈی نپی سرنی کو دیکھتے ہوئے ، ابتدائی قدر کے ساتھ numpy.prod فنکشن کا استعمال کرتے ہوئے عنصر کے مطابق مجموعی مصنوع کو ایک مخصوص محور کے ساتھ حساب کتاب کرنے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جس میں کسی خاص سرنی میں کسی خاص قدر کی پہلی موجودگی کا اشاریہ مل جاتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف فائنڈ_فیرسٹ_ انڈیکس (سرنی ، ویلیو): کوشش کریں: انڈیکس = این پی۔] [0] انڈیکس ایرر کے علاوہ ریٹرن انڈیکس: کوئی بھی نہیں# مثال کے طور پر usagearray = np.Array ([1 ، 2 ، 3 ، 4 ، 5 ، 3 ، 6]) ویلیو = 3 فرسٹ_ انڈیکس = Find_first_index (سرنی ، ویلیو) پرنٹ (\"سرنی:\" سرنی:\"، سرنی) پرنٹ (\" قدر: \"، قدر) اگر فرسٹ_ انڈیکس کوئی نہیں ہے: پرنٹ (\" قیمت کا پہلا انڈیکس: \"، فرسٹ_ انڈیکس) دوسری: پرنٹ (\" سرنی میں قیمت نہیں ملتی ہے۔ \")[1 2 3 4 5 3 6] ویلیو: 3 فرسٹ انڈیکس ویلیو: 2 میں اس مثال کے طور پر ، find_first_index () فنکشن ایک numpy صف اور ایک مخصوص قدر کو آدانوں کے طور پر لیتا ہے۔یہ اشارے تلاش کرنے کے لئے NP.Where () فنکشن کا استعمال کرتا ہے جہاں سرنی مخصوص قیمت کے برابر ہے۔چونکہ NP.Where () صفوں کا ایک ٹپل (ہر جہت کے لئے ایک) لوٹاتا ہے ، لہذا ہم پہلے طول و عرض کے ساتھ اشارے حاصل کرنے کے لئے پہلے عنصر [0] تک رسائی حاصل کرتے ہیں ، اور پھر [0] دوبارہ پہلی بار واقعہ کا اشاریہ حاصل کرنے کے لئے۔اگر مخصوص قدر صف میں نہیں ملتی ہے تو ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔ آپ اس فنکشن کو کسی بھی نمی سرنی اور قدر کے ساتھ استعمال کرسکتے ہیں تاکہ اس قدر کی پہلی موجودگی کا انڈیکس تلاش کیا جاسکے۔"
    },
    {
        "Question": "کسٹم اظہار کے ساتھ numpy.einsum فنکشن کا استعمال کرتے ہوئے ایک numpy سرے کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو دو نمی سرنیوں کے مابین کوسائن مماثلت کا حساب لگاتی ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کوسائن_سیمیلیٹی (اری 1 ، اری 2): ڈاٹ_ پروڈکٹ = این پی ڈاٹ (ارای 1 ، ارای 2) نورم 1 = این پی ایل ایل جی۔ ناورم (نورم 1 (این پی ایل 11) (این پی ایل ایل جی۔np.linalg.norm (array2) مماثلت = ڈاٹ_ پروڈکٹ / (نورم 1 * نورم 2) مماثلت کی واپسی# مثال usagearray1 = np.array ([1 ، 2 ، 3]) array2 = np.array ([4 ، 5 ، 6]) مماثلت= cosine_simarity (array1 ، array2) پرنٹ (\"سرنی 1:\" ، سرنی 1) پرنٹ (\"سرنی 2:\" ، سرنی 2) پرنٹ (\"کوسائن مماثلت:\" ، مماثلت) آؤٹ پٹ: یمل کوپی کوڈرری 1: [1 2 3] سرنی 2: [4 5 6] کوسائن مماثلت: 0.9746318461970762in اس مثال کے طور پر ، Cosine_simility () فنکشن ان پٹ کے طور پر دو numpy صفوں کو لے جاتا ہے۔یہ NP.DOT () کا استعمال کرتے ہوئے دونوں صفوں کے مابین ڈاٹ پروڈکٹ کا حساب لگاتا ہے۔اس کے بعد ، یہ NP.LINLG.Norm () کا استعمال کرتے ہوئے دونوں صفوں کے یوکلیڈین اصولوں کی گنتی کرتا ہے۔آخر میں ، یہ DOT پروڈکٹ کو کوسائن مماثلت حاصل کرنے کے لئے اصولوں کی مصنوعات کے ذریعہ تقسیم کرتا ہے۔ یہ فنکشن دونوں صفوں کے مابین کوسائن کی مماثلت لوٹاتا ہے۔ آپ اس فنکشن کو ان کی کوسائن مماثلت کا حساب لگانے کے لئے ایک ہی شکل کی کسی بھی دو نمی صفوں کے ساتھ استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، فہرست کی تفہیم کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سیکنڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو نمی سرنیوں کی نمائندگی کرنے والے دو پوائنٹس کے درمیان یوکلیڈین فاصلے کا حساب لگاتی ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی بطور این پی ڈی ای ایف یوکلیڈین_ڈیسٹنس (پوائنٹ 1 ، پوائنٹ 2): فاصلہ = این پی ایل ایل ایل جی۔ ناورم (پوائنٹ 1 - پوائنٹ 2) ریٹرن ڈسٹنس# مثال# مثال کے طور پر# مثال کے طور پر استعمال نقطہ 1 = این پی.ارے ([1 ، 2 ، 3]) پوائنٹ 2 = این پی.ارے ([4 ، 5 ، 6]) فاصلہ = یوکلیڈین_ڈسٹینس (پوائنٹ 1 ، پوائنٹ 2) پرنٹ (\"پوائنٹ 1:\" ، پوائنٹ 1) پرنٹ (\"پوائنٹ 2:\"، پوائنٹ 2) پرنٹ (\"یوکلیڈین فاصلہ:\" ، فاصلہ) آؤٹ پٹ: یامل کوپی کوڈپوائنٹ 1: [1 2 3] پوائنٹ 2: [4 5 6] یوکلیڈین فاصلہ: 5.196152424227066632in اس مثال کے طور پر ، یوکلیڈین_ڈیسٹنس () فنکشن دو نمی سرز کی نمائندگی کرتا ہے۔آدانوں کے طور پر پوائنٹس.یہ پہلے نقطہ سے دوسرے نقطہ کو گھٹاتے ہوئے NP.LINLG.Norm () کا استعمال کرتے ہوئے پوائنٹس کے مابین یکلیڈین فاصلے کا حساب لگاتا ہے۔NP.LINLG.Norm () فنکشن نتیجے میں ویکٹر کے یوکلیڈین معمول کی گنتی کرتا ہے ، جو نقطہ کے درمیان یوکلیڈین فاصلے کے برابر ہے۔ یہ فنکشن دو نکات کے درمیان یوکلیڈین فاصلہ لوٹاتا ہے۔ آپ اس فنکشن کو کسی بھی دو numpy صفوں کے ساتھ استعمال کرسکتے ہیں۔اسی شکل کی نمائندگی کرنے والے پوائنٹس ان کے یوکلیڈین فاصلے کا حساب لگانے کے لئے۔"
    },
    {
        "Question": "کسٹم محور کے ساتھ numpy.cumumsum فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق مجموعی مجموعی کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو ایک نمی سرنی کے لئے ایک مخصوص ونڈو سائز کی چلتی اوسط کا حساب لگاتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف موونگ_اوریج (سرنی ، ونڈو_سائز): cumsum = np.cumsum (سرنی) cumsum [ونڈو_سائز:].]) ونڈو_سائز = 3 اے ویورجز = موونگ_اوریج (سرنی ، ونڈو_سائز) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"چلتی اوسط (ونڈو سائز =\" ، ونڈو_سائز ، \"):\" ، اوسط) آؤٹ پٹ: ایس کیو ایل کوپی کوڈرری: [1 2 34 5 6 6 7 8 9 10] حرکت پذیر اوسط (ونڈو کا سائز = 3): [2. 3. 3. 4. 4. 5. 6. 6. 7. 8. 9.] اس مثال میں ، موونگ_اوریج () فنکشن ایک نمی سرنی اور ایک لیتا ہےآدانوں کے طور پر ونڈو کا سائز۔یہ سرنی کے مجموعی رقم کا حساب لگانے کے لئے NP.CUMSUMS () فنکشن کا استعمال کرتا ہے۔اس کے بعد ، یہ ونڈو کے آخر میں مجموعی رقم سے ونڈو کے آغاز پر مجموعی رقم کو گھٹا دیتا ہے تاکہ ونڈو کے اندر اقدار کا مجموعہ حاصل کیا جاسکے۔آخر میں ، یہ چلتی اوسط کا حساب لگانے کے لئے ونڈو کے سائز کے ذریعہ رقم کو تقسیم کرتا ہے۔ فنکشن حرکت پذیر اوسط پر مشتمل ایک صف لوٹاتا ہے۔ آپ اس فنکشن کو کسی بھی نیمی سرنی اور ونڈو سائز کے ساتھ کسی بھی طرح کی ونڈو سائز کے مقابلے میں چلنے والی اوسط کا حساب لگانے کے لئے استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک 2 ڈی نپی سرنی کو دیکھتے ہوئے ، ابتدائی قدر کے ساتھ numpy.cumprod فنکشن کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "لاجسٹ فنکشن ، جسے لاجسٹک فنکشن کے نام سے بھی جانا جاتا ہے ، سگمائڈ فنکشن کے الٹا کے طور پر بیان کیا گیا ہے۔یہ عام طور پر 0 اور 1 کے درمیان اقدار کو پوری اصلی نمبر لائن پر نقشہ بنانے کے لئے استعمال ہوتا ہے۔یہاں ایک فنکشن کی ایک مثال ہے جو ایک numpy سرنی کے عنصر کے مطابق لاگ ان فنکشن کا حساب لگاتی ہے: Pythoncopy Codemport numpy as npdef Logit (سرنی): واپس Np.log (سرنی / (1 - سرنی))# مثال usagearray = np.array ((سرنی / (1 - سرنی))۔۔یہ فارمولے: لاگ (سرنی / (1 - سرنی)) کا استعمال کرتے ہوئے لاگ ان اقدار کا حساب لگانے کے لئے (1 - سرنی) کے ذریعہ سرنی کے عنصر کے حساب سے ڈویژن انجام دیتا ہے۔ فنکشن عنصر کے مطابق لاگ ان اقدار پر مشتمل ایک صف لوٹاتا ہے۔ آپ کر سکتے ہیں۔صف میں ہر عنصر کے لئے لاگ ان اقدار کا حساب لگانے کے لئے اس فنکشن کو کسی بھی نمی سرنی کے ساتھ استعمال کریں۔"
    },
    {
        "Question": "numpy.lib.stride_tricks.as_strided فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک نمی سرنی کی خودکشی سے سرنی اور خود کے پیچھے رہ جانے والے ورژن کے درمیان مماثلت کی پیمائش ہوتی ہے۔یہ عام طور پر سگنل پروسیسنگ اور ٹائم سیریز تجزیہ میں استعمال ہوتا ہے۔یہاں ایک فنکشن کی ایک مثال ہے جو ایک نمی سرنی کی خودمختاری کا حساب لگاتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف آٹوکوریلیشن (سرنی): این = لین (سرنی) کا مطلب = این پی ایم (سرنی) سنٹرڈ_رای = سرنی - مطلب آٹوکور = این پی کورلیٹ (این پی۔ کریلیٹسینٹرڈ_رای ، سینٹرڈ_ری ، موڈ = 'مکمل') آٹوکور = آٹوکور [N-1:] / (N * NP.Var (سرنی)) آٹو کارر# مثال usagearray = np.array ([1 ، 2 ، 3 ، 4 ، 5]) آٹوکور_والیوز = آٹوکوریلیشن (سرنی) پرنٹ (\"سرنی:\" ، سرنی) پرنٹ (\"آٹوکوریلیشن ویلیوز:\" ، آٹوکور_والیوز) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 2 3 4 4 5] خود کشی کی اقدار: [1. 0.6 0.6 0.6 0.6 0..] اس مثال میں ، خود کشی () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے۔یہ پہلے صف کے وسط کا حساب لگاتا ہے۔اس کے بعد ، یہ صف کا ایک مرکزیت حاصل کرنے کے لئے صف سے وسط کو گھٹا دیتا ہے۔ فنکشن آٹوکوریلیشن کی گنتی کے لئے NP.corlet () فنکشن کا استعمال کرتا ہے۔موڈ = 'مکمل' پیرامیٹر اس بات کو یقینی بناتا ہے کہ مکمل خودکشی کی گنتی کی جائے۔اس کے نتیجے میں خودکشی سے متعلق سرنی کو (n * تغیر) کے ذریعہ تقسیم کرکے -1 اور 1 کے درمیان اقدار حاصل کرنے کے لئے معمول بنایا جاتا ہے۔ یہ فنکشن آٹوکوریلیشن اقدار پر مشتمل ایک صف کو لوٹاتا ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، numpy.piecise فنکشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سیکنڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو ایک مخصوص محور کے ساتھ ساتھ ایک نمی سرنی کے عنصر کے مطابق مجموعی طور پر حساب کتاب کرتی ہے: پائیتھونکپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کمولیٹو_سم (سرنی ، محور = کوئی نہیں): واپسی این پی ڈاٹ کامم (سرنی ، محور = محور)# مثالusagearray = np.array ([[1 ، 2 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]]) مجموعی_سم_ایکسس 0 = کمولیٹو_سم (سرنی ، محور = 0) کمولیٹو_سم_ایکسس 1 = کمولیٹو_سم (سرنی ، محور =1) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ n -cumulative Sum (محور = 0):\") پرنٹ (cumulative_sum_axis0) پرنٹ (\"\\ n -cumulative Sum (محور = 1):\") پرنٹ (مجموعی_سم_ایکسس 1) آؤٹ پٹ: Luacopy Codearray: [[1 2 3] [4 5 6] [7 8 9]] مجموعی رقم (محور = 0): [[1 2 3] [5 7 9] [12 15 18]] مجموعی رقم (محور= 1): [[1 3 6] [4 9 15] [7 15 24]] اس مثال میں ، مجموعی_سم () فنکشن دو پیرامیٹرز لیتا ہے: نمی سرنی اور محور جس کے ساتھ ساتھ مجموعی رقم کا حساب کتاب کرنا ہے۔NP.Cumsum () فنکشن کو مجموعی رقم کی گنتی کے لئے استعمال کیا جاتا ہے ، اور محور پیرامیٹر کو محور کی وضاحت کرنے کے لئے پاس کیا جاتا ہے۔ آپ کسی بھی نمی سرنی اور مطلوبہ محور کے ساتھ فنکشن کو کال کرسکتے ہیں تاکہ اس محور کے ساتھ عنصر کے لحاظ سے مجموعی جمع کا حساب لگایا جاسکے۔"
    },
    {
        "Question": "numpy.ufunc.reduceat فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو ایک numpy سرنی کے لئے مخصوص فیصد پر صد فیصد اقدار کا حساب لگاتی ہے: Pythoncopy Codeimport numpy بطور NPDEF پرسنٹائل_والیوز (سرنی ، فیصد): واپسی NP.percentile (سرنی ، فیصد)# مثال usagearray = np.array ([1 1، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، 9 ، 10]) فیصد = [25 ، 50 ، 75] نتیجہ = صد فیصد_ایلیوس (سرنی ، فیصد) پرنٹ (\"صف:\") پرنٹ (سرنی) پرنٹ (سرنی) پرنٹ (\"\\ npencentile اقدار:\") I کے لئے I ، P میں گنتی (فیصد): پرنٹ (\"پرنٹائل {}:}}\". فارمیٹ (پی ، نتیجہ [I])) آؤٹ پٹ: یامل کوپی کوڈرری: [1 2 3 4 5 6 67 8 9 10] صد فیصد اقدار: صد فیصد 25: 3.25 فیصد 50: 5.5percentile 75: 7.75 اس مثال کے طور پر ، پرسنٹائل_والیوز () فنکشن دو پیرامیٹرز لیتا ہے: نپی سرنی اور فیصد کی ایک فہرست جس میں صد فیصد کی اقدار کا حساب کتاب کرنا ہے۔NP.percentile () فنکشن فراہم کردہ فیصد کی بنیاد پر صد فیصد اقدار کی گنتی کے لئے استعمال کیا جاتا ہے۔ آپ کسی بھی numpy صف کے ساتھ فنکشن کو کال کرسکتے ہیں اور متعلقہ فیصد اقدار کو حاصل کرنے کے لئے مطلوبہ فیصد کی فہرست۔"
    },
    {
        "Question": "\"ایک 2 ڈی نیپی سرنی کو دیکھتے ہوئے ، عنصر کے مطابق مجموعی مصنوعات کا حساب کتاب کرنے کے لئے ایک فنکشن لکھیں جو ایک مخصوص محور کے ساتھ ایک مخصوص محور کے ساتھ ایک مخصوص محور کا استعمال کرتے ہیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کی ایک مثال ہے جو ایک numpy سرنی کے عنصر کے مطابق سگمائڈ فنکشن کا حساب لگاتی ہے: Pythoncopy Codemport numpy as npdef sigmoid (سرنی): واپسی 1 / (1 + np.exp (-Array))# مثال usagearray = np.array.] سگمائڈ نتیجہ: [0.26894142 0.5 0.73105858] اس مثال میں ، سگمائڈ () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے اور اظہار 1 / (1 + np.exp (-Array)) کا استعمال کرتے ہوئے سگمائڈ فنکشن عنصر کے لحاظ سے لاگو ہوتا ہے۔NP.EXP () فنکشن سرنی میں ہر عنصر کی کفایت شعاری کی گنتی کرتا ہے۔"
    },
    {
        "Question": "کسٹم ایکسپینٹ کے ساتھ numpy.power فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "numpy لائبریری کسی صف کے موڈ کا حساب لگانے کے لئے براہ راست فنکشن فراہم نہیں کرتی ہے۔تاہم ، آپ اس کو حاصل کرنے کے لئے scipy.stats.mode فنکشن استعمال کرسکتے ہیں۔یہاں ایک فنکشن کی ایک مثال ہے جو ایک نمی سرنی کے موڈ کا حساب لگاتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر NPFROM Scipy.stats درآمد موڈیڈف کیلکولیٹ_موڈ (سرنی): نتیجہ = وضع (سرنی) واپسی کا نتیجہ۔([1 ، 2 ، 2 ، 3 ، 3 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4 ، 4]موڈ_ ویلیو) آؤٹ پٹ: میک فیلیکوپی کوڈئری: [1 2 2 3 3 3 4 4 4 4 4] موڈ: 4 ان مثال کے طور پر ، حساب کتاب_موڈ () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے اور موڈ کی گنتی کے ل sc اسکیپی ڈاٹ اسٹیٹس سے موڈ فنکشن کا استعمال کرتا ہے۔موڈ فنکشن کسی ایسی شے کو لوٹاتا ہے جس میں وضع (زبانیں) اور ان کی گنتی ہوتی ہے۔اس معاملے میں ، ہم سرنی کے موڈ کو حاصل کرنے کے ل result نتیجہ۔ موڈ [0] کا استعمال کرتے ہوئے پہلے موڈ تک رسائی حاصل کرتے ہیں۔ اس بات کو یقینی بنائیں کہ آپ Scipy.stats.mode فنکشن کو استعمال کرنے کے لئے Scipy لائبریری انسٹال ہے۔آپ اسے PIP انسٹال SCIPY کا استعمال کرکے انسٹال کرسکتے ہیں۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، ایک کسٹم تھریشولڈ کے ساتھ numpy.arcosh فنکشن کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سیکنڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "آپ numpy فنکشن numpy.reciprocal () استعمال کرسکتے ہیں تاکہ کسی نمی سرنی کے عنصر کے مطابق باہمی حساب کتاب کیا جاسکے۔یہاں ایک فنکشن کی ایک مثال ہے جو ایک نمی سرنی کے باہمی حساب کتاب کا حساب لگاتی ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کے حساب کتاب_ریسیپروکال (سرنی): نتیجہ = این پی۔ ریسیپروکال (سرنی) واپسی کا نتیجہ# مثال usagearray = np.array ([1 ، 2 ، 3 ، 3 ، 3 ،4 ، 5]) باہمی_رای = حساب کتاب_ریسیپروکال (سرنی) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ nreciprocal سرنی:\") پرنٹ (باہمی تعاون_اری) آؤٹ پٹ: CSHARPCOPY CODEARRAY: [1 2 3 4 4 5] باہمی صف:[1.0.5 0.33333333 0.25 0.2] اس مثال میں ، حساب کتاب_ریسیپروکال () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے اور عنصر کے مطابق باہمی اجزاء کی گنتی کے لئے numpy.reciprocal () فنکشن کا استعمال کرتا ہے۔اس کا نتیجہ ایک نئے numpy سرنی کے طور پر واپس کیا گیا ہے۔ نوٹ کریں کہ اگر ان پٹ سرنی میں کوئی عنصر صفر ہے تو ، باہمی انفینٹی (INF) ہوگا۔اگر آپ اس معاملے کو مختلف طریقے سے سنبھالنا چاہتے ہیں تو ، آپ اس کے مطابق فنکشن میں ترمیم کرسکتے ہیں۔"
    },
    {
        "Question": "numpy.add.reduceat فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے حساب سے مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی مخصوص ونڈو سائز کے ساتھ کسی نمی سرنی کے چلتے ہوئے میڈین کا حساب لگانے کے ل you ، آپ نمی کے AS_STRIDED () فنکشن کے ساتھ ساتھ NUMPY.Median () فنکشن استعمال کرسکتے ہیں تاکہ سرنی کے اوورلیپنگ نظارے پیدا کریں۔ یہاں ایک ایسی مثال ہے جو چلتی میڈین کا حساب لگاتی ہے:پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کا حساب کتاب_موونگ_میڈین (سرنی ، ونڈو_ سائز): # ونڈو کی حدود کو سنبھالنے کے لئے کنارے کی قدروں کے ساتھ سرنی کو پیڈ کریں۔پیڈڈ سرنی کا نظارہ اوورلیپنگ ونڈوز ونڈو_ویوز = np.lib.stride_tricks.sliden_window_view (padded_array ، ونڈو_شپ = ونڈو_سائز) کے ساتھ بنائیں # ہر ونڈو کے آخری محور کے ساتھ میڈین کا حساب لگائیں۔مووینگ_میڈین# مثال کے طور پر یسجیرے = np.array ([1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9]) ونڈو_سائز = 3 ایموونگ_میڈین = حساب کتاب_موونگ_میڈین (سرنی ، ونڈو_ سائز) پرنٹ (\"سرنی:\") پرنٹ (ارک)) پرنٹ (\"\\ nmoving میڈین:\") پرنٹ (موونگ_میڈین) آؤٹ پٹ: CSHARPCOPY CODERRAY: [1 2 3 4 5 6 7 8 9] متحرک میڈین: [1.2. 3. 4. 4. 5. 6. 7. 8.] اس مثال میں ، حساب کتاب_مونگ_میڈین () فنکشن ایک نمی سرنی اور ونڈو کا سائز ان پٹ کے طور پر لیتا ہے۔یہ ونڈو کی حدود کو سنبھالنے کے لئے NP.PAD () کا استعمال کرتے ہوئے کنارے کی اقدار کے ساتھ صف کو پیڈ کرتا ہے۔اس کے بعد ، یہ NP.lib.stride_tricks.sling_window_view () کا استعمال کرتے ہوئے اوورلیپنگ ونڈوز کے ساتھ بولڈ سرنی کا نظارہ تخلیق کرتا ہے۔آخر میں ، یہ NP.Median () کا استعمال کرتے ہوئے ہر ونڈو کے آخری محور کے ساتھ میڈین کا حساب لگاتا ہے۔ نوٹ کریں کہ نتیجے میں چلنے والی میڈین سرنی کی لمبائی لین (سرنی) کی لمبائی ہوگی - ونڈو_سائز + 1 کی وجہ سے کھڑکی کی وجہ سے کھڑکی میں تبدیلی کی وجہ سے۔"
    },
    {
        "Question": "\"ایک 2 ڈی نپی سرنی کو دیکھتے ہوئے ، مشروط بیان کے ساتھ فہرست کی تفہیم کا استعمال کرتے ہوئے ایک مخصوص محور کے ساتھ عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "کسی نمی سرنی کے عنصر کے مطابق سافٹ میکس فنکشن کا حساب لگانے کے ل you ، آپ نمی کے این پی ایس او ایم () فنکشن کے محور پیرامیٹر کے ساتھ ساتھ کفایت شعاری فنکشن NP.EXP () کا استعمال کرسکتے ہیں۔ عنصر کے مطابق سافٹ میکس کا حساب کتاب کرتا ہے۔پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کے حساب کتاب_سوفٹ میکس (سرنی): # عنصر کے مطابق کفایت شعاری فنکشن ایکسپونشنل فنکشن ایکسپ_ری = این پی. ای ایکس پی (سرنی) # آخری محور کے ساتھ ساتھ اس کا حساب لگائیں۔# ہر عنصر کو سافٹ میکس_ارے = ایکسپ_آرے / سوم_ایکسپ_آرے ریٹرن سافٹ میکس_ اری# مثال کے طور پر تقسیم کریں۔sof nsoftMax سرنی: \") پرنٹ (سافٹ میکس_ اریے) آؤٹ پٹ: CSHARPCOPY CODERRAY: [1 2 3] سافٹ میکس سرنی: [0.09003057 0.24472847 0.66524096] اس مثال میں ، حساب کتاب_سوفٹ میکس () فنکشن ایک ناپکی سرنی کے طور پر ان پٹ لیتا ہے۔یہ سب سے پہلے ان پٹ سرنی پر عنصر کے مطابق کفایت شعاری فنکشن NP.EXP () کا اطلاق کرتا ہے ، جس کے نتیجے میں Exp_array ہوتا ہے۔اس کے بعد ، اس کا حساب کتاب Exp_array کے آخری محور کے ساتھ NP.SUM () کے ساتھ محور = -1 اور کیپ ڈیمس = سچ کے ساتھ کیا جاتا ہے ، جس کے نتیجے میں SUM_EXP_ARRAY ہوتا ہے۔آخر میں ، یہ SoftMax_array میں سافٹ میکس اقدار کو حاصل کرنے کے لئے Sum_exp_array کے ذریعہ Exp_array کے ہر عنصر کو تقسیم کرتا ہے۔"
    },
    {
        "Question": "متعدد آدانوں کے ساتھ numpy.vectorize فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "2D numpy صف کے کوویرینس میٹرکس کا حساب لگانے کے ل you ، آپ NP.Cov () فنکشن کا استعمال کرسکتے ہیں۔ ایک مثال کے فنکشن جو کوویرئنس میٹرکس کا حساب لگاتا ہے: پائیٹون کوپی کوڈیمپورٹ NUMPY کے طور پر NPDEF CACTIONT_COVARIANCE_MATRIX (سرے)array.shape [0] <سرنی.شپ [1]: سرنی = سرنی۔ ٹی # کوویرنس میٹرکس کوورینس_میٹرکس = این پی.کوف (سرنی ، روور = غلط) واپسی کوویرنس_مٹریکس # مثال usagearray = np.arely ([1 ، [1 ، [12 ، 3] ، [4 ، 5 ، 6] ، [7 ، 8 ، 9]]) covariance_matrix = حساب کتاب_کواورینس_میٹرکس (سرنی) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ ncovariance میٹرکس:\") پرنٹ (\") پرنٹ (\" \\ ncovariance میٹرکس: \") پرنٹکوویرنس_میٹرکس) آؤٹ پٹ: لوکاپی کوڈآرری: [[1 2 3] [4 5 6] [7 8 9]] کوویرینس میٹرکس: [[0.6666666666666666666666666666666666666666666666666666666666667] 0.666666667]] اس مثال میں ، حساب کتاب_کواورینس_میٹرکس() فنکشن ان پٹ کے طور پر 2 ڈی نیپی سرنی لیتا ہے۔اگر قطاروں کی تعداد کالموں کی تعداد سے کم ہے تو ، اس بات کو یقینی بنانے کے لئے صف کو منتقل کیا جاتا ہے کہ ہر قطار متغیر کی نمائندگی کرتی ہے۔اس کے بعد ، یہ کوویرینس میٹرکس کا حساب لگانے کے لئے rovar = غلط کے ساتھ NP.COV () استعمال کرتا ہے ، جہاں ہر کالم متغیر کی نمائندگی کرتا ہے۔نتیجے میں کوویرئنس میٹرکس واپس آگیا ہے۔"
    },
    {
        "Question": "\"ایک نمی سرنی کو دیکھتے ہوئے ، ابتدائی اسٹاپ کے ساتھ لوپ کا استعمال کرتے ہوئے سرنی کے عنصر کے مطابق الٹا ہائپربولک سیکنڈ کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "یقینا!یہاں ایک مثال کا فنکشن ہے جو نیوٹن کے طریقہ کار کا استعمال کرتے ہوئے ایک نمی سرنی کے عنصر کے مطابق مربع جڑ کا حساب لگاتا ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کے حساب کتاب_سقورٹ_نیٹن (سرنی ، نمبر_ٹر = 10): # مربع روٹ کے لئے ابتدائی اندازہ شروع کریں# رینج میں _ کے لئے نیوٹن کے طریقہ کار کی تکرار کریں (Num_iter): اندازہ = 0.5 * (اندازہ + سرنی / اندازہ) واپسی کا اندازہ لگائیں# مثال usagearray = np.array ([1 ، 4 ، 9 ، 16 ، 25]) SQRT_ARRAY = حساب کتاب_ ایس کیو آر ٹی_نوٹن ((سرنی) پرنٹ (\"سرنی:\") پرنٹ (سرنی) پرنٹ (\"\\ nsquare روٹ:\") پرنٹ (SQRT_ARRAY) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 4 9 16 25] مربع روٹ: [1۔2. 3. 4. 5 ..] اس مثال میں ، حساب کتاب_ ایس کیو آر ٹی_نوٹن () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے اور صف میں ہر عنصر کے مربع جڑ کا تخمینہ لگانے کے لئے نیوٹن کے طریقہ کار کی تکرار کو انجام دیتا ہے۔تکرار کی تعداد کو NUM_ITER پیرامیٹر کے ذریعہ کنٹرول کیا جاتا ہے ، جو پہلے سے طے شدہ طور پر 10 پر سیٹ کیا جاتا ہے۔مربع جڑ کے لئے ابتدائی اندازہ ہر عنصر کے لئے 1 پر سیٹ کیا گیا ہے۔فنکشن قریب مربع جڑوں کی ایک صف لوٹاتا ہے۔"
    },
    {
        "Question": "numpy.ufunc.accumulateat فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق مجموعی رقم کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "کسی نمی سرنی کے شینن اینٹروپی کا حساب لگانے کے ل you ، آپ ایک ایسا فنکشن لکھ سکتے ہیں جو سرنی کی اقدار کی امکانی تقسیم کی گنتی کرتا ہے اور پھر انٹروپی فارمولے کو لاگو کرتا ہے۔یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کے حساب کتاب_شانن_انٹروپی (سرنی): # سرنی منفرد_ایولس ، ویلیو_کاؤنٹس = این پی.ایونک (سرنی ، ریٹرن_کونٹ = سچے) میں ہر انوکھے قدر کے واقعات کو گنیں۔/ لین (سرنی) # اینٹروپی فارمولا اینٹروپی = -np.sum (احتمالات * NP.log2 (امکانات)) ریٹرن اینٹروپی # مثال usagearray = np.array ([1 ، 1 ، 2 ، 3 ، 3 کا استعمال کرتے ہوئے شینن اینٹروپی کا حساب لگائیں.2 3 3 3 4 4 4 4 4] شینن اینٹروپی: 1.84643934467101544 اس مثال کے طور پر ، حساب کتاب_شانن_ینٹروپی () فنکشن ان پٹ کے طور پر ایک نمی سرنی لیتا ہے۔یہ منفرد اقدار اور صف میں ان کی متعلقہ گنتی حاصل کرنے کے لئے NP.Unique () کا استعمال کرتا ہے۔اس کے بعد ، یہ عناصر کی کل تعداد کے حساب سے گنتی کو تقسیم کرکے ہر قدر کے امکانات کی گنتی کرتا ہے۔آخر میں ، یہ شینن اینٹروپی فارمولا -NP.SUM (احتمالات * NP.log2 (امکانات)) کا اطلاق کرتا ہے تاکہ اینٹروپی ویلیو کی گنتی کی جاسکے۔"
    },
    {
        "Question": "\"2 ڈی نیپی سرنی کو دیکھتے ہوئے ، ایک سے زیادہ آدانوں کے ساتھ numpy.prod فنکشن کا استعمال کرتے ہوئے عنصر کے مطابق مجموعی مصنوع کا حساب لگانے کے لئے ایک فنکشن لکھیں۔\"",
        "Answer": "آپ numpy.abs () فنکشن کا استعمال کرکے دو numpy صفوں کے مابین عنصر کے مطابق مطلق فرق کا حساب لگانے کے لئے ایک فنکشن لکھ سکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈیمپورٹ نوم کے بطور این پی ڈی ای ایف کا حساب کتاب_ایلیمنٹ وائز_بسولٹ_ڈیفینس (اری 1 ، اری 2): مطلق_ڈیفینس = این پی. اے بی ایس (ارای 1 - ارای 2) واپسی مطلق_ڈیفینس# مثال usagearray1 = NP.Array ([1 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 2 ، 3].فرق: \") پرنٹ (ABS_DIFF) آؤٹ پٹ: ریاضی کاپی کوڈرری 1: [1 2 3] سرنی 2: [4 2 1] عنصر کے مطابق مطلق فرق: [3 0 2] اس مثال میں ، حساب کتاب_ایلمنٹ وائز_بسولٹ_ڈیفینس () فنکشن دو نمی لیتا ہےان پٹ کے طور پر صفیں (سرنی 1 اور سرنی 2)۔یہ Array1 سے array2 کو گھٹا کر اور پھر مطلق اقدار کو حاصل کرنے کے لئے NP.ABS () کا اطلاق کرکے عنصر کے مطابق مطلق فرق کا حساب لگاتا ہے۔نتیجے میں ہونے والی صف میں ان پٹ صفوں میں متعلقہ عناصر کے مابین مطلق فرق ہوتا ہے۔"
    },
    {
        "Question": "numpy.lib.scimath.expm1 فنکشن کا استعمال کرتے ہوئے ایک numpy سرے کے عنصر کے مطابق کفایت شعاری فنکشن کا حساب لگانے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "آپ numpy.cbrt () فنکشن کا استعمال کرتے ہوئے ایک numpy سرنی کے عنصر کے مطابق مکعب جڑ کا حساب لگانے کے لئے ایک فنکشن لکھ سکتے ہیں۔یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی ڈی ای ایف کا حساب کتاب_ایلیمنٹ وائز_کوب_روٹ (سرنی): کیوب_روٹ = این پی سی برٹ (سرنی) کیوب_روٹ# مثال usagearray = np.array ([1 ، 8 ، 27]) مکعب_روٹ ([1 ، 8 ، 27]) مکعب_روٹ ([1 ، 8 ، 27]) کیوبی_روٹ۔سرنی: \") پرنٹ (سرنی) پرنٹ (\" \\ nelement-vise مکعب جڑ: \") پرنٹ (مکعب_روٹ) آؤٹ پٹ: ریاضی کاپی کوڈرری: [1 8 27] عنصر کے مطابق مکعب جڑ: [1۔2. 3.] اس مثال میں ، کیلکولیٹ_لیمنٹ وائز_کیوب_روٹ () فنکشن ان پٹ (سرنی) کے طور پر ایک نمی سرنی لیتا ہے۔یہ ان پٹ سرنی پر NP.CBRT () فنکشن کا اطلاق کرتا ہے ، جو ہر عنصر کے مکعب کی جڑ کا حساب لگاتا ہے۔نتیجے میں ہونے والی صف میں ان پٹ سرنی کے عنصر کے مطابق مکعب کی جڑ ہوتی ہے۔"
    }
]