[
    {
        "Question": "oop",
        "Answer": "\"او او پی\" کا مطلب ہے"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں انکیپسولیشن کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "انکپسولیشن آبجیکٹ پر مبنی پروگرامنگ میں ایک بنیادی تصور ہے جس میں بنڈل ڈیٹا اور ان طریقوں کو شامل کیا جاتا ہے جو کسی ایک یونٹ کے اندر اس ڈیٹا پر کام کرتے ہیں جسے کسی شے کے نام سے کہتے ہیں۔اس سے انکپلیسولیٹڈ ڈیٹا تک رسائی حاصل کرنے اور صرف متعین طریقوں یا انٹرفیس کے ذریعہ ہیرا پھیری کی اجازت ملتی ہے ، جبکہ باہر سے داخلی عمل درآمد کی تفصیلات کو چھپاتے ہوئے۔ انکپسولیشن کے اہم فوائد یہ ہیں:"
    },
    {
        "Question": "ساخت اور وراثت میں کیا فرق ہے؟ہر ایک کے لئے ایک مثال دیں۔",
        "Answer": "تشکیل اور وراثت آبجیکٹ پر مبنی پروگرامنگ میں کلاسوں کے مابین کوڈ کے دوبارہ استعمال اور تشکیل کے ل two دو مختلف میکانزم ہیں۔یہ ایک \"HAS-A\" تعلقات کی نمائندگی کرتا ہے ، جہاں کسی شے میں اس کے ممبر کی حیثیت سے دوسری اشیاء شامل ہوتی ہیں۔کمپوزڈ آبجیکٹ اکثر پر مشتمل آبجیکٹ کے کنسٹرکٹر کے اندر شروع کیے جاتے ہیں اور اس تک رسائی حاصل کی جاسکتی ہے اور اس کے طریقوں کے ذریعہ استعمال کی جاسکتی ہے۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں ٹھوس اصولوں کی وضاحت کریں اور بتائیں کہ وہ سافٹ ویئر سسٹم کے معیار کو کس طرح بہتر بناسکتے ہیں۔",
        "Answer": "ٹھوس اصول آبجیکٹ پر مبنی ڈیزائن میں رہنما خطوط کا ایک مجموعہ ہیں جس کا مقصد سافٹ ویئر سسٹم کے معیار ، برقرار رکھنے اور توسیع کو بہتر بنانا ہے۔یہ اصول رابرٹ سی مارٹن (جسے انکل باب بھی کہا جاتا ہے) نے متعارف کرایا تھا اور سافٹ ویئر ڈویلپمنٹ میں بہترین طریقوں کو سمجھا جاتا ہے۔مخفف ٹھوس مندرجہ ذیل اصولوں کا مطلب ہے: سنگل ذمہ داری کا اصول (ایس آر پی): اس اصول میں کہا گیا ہے کہ کلاس کے پاس تبدیل ہونے کی صرف ایک وجہ ہونی چاہئے۔دوسرے لفظوں میں ، ایک کلاس میں سنگل ہونا چاہئے"
    },
    {
        "Question": "\"پش ، پاپ اور جھانکنے کے طریقوں کے ساتھ اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ازگر میں اسٹیک ڈیٹا ڈھانچے کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس اسٹیک: ڈیف __init __ (خود): سیلف اسٹیک = [] ڈیف پش (سیلف ، آئٹم): سیلف اسٹیک.ایپینڈ (آئٹم) ڈیف پاپ (خود):اگر self.is_empty (): انڈیکس ایرر (\"اسٹیک خالی ہے\") کو واپس کریں sell[-1] Def is_empty (self): ریٹرن لین (سیلف اسٹیک) == 0 ڈیف سائز (خود):"
    },
    {
        "Question": "ازگر میں طریقہ اوورلوڈنگ اور طریقہ اوور رائڈنگ کیا ہے؟ہر ایک کے لئے ایک مثال پیش کریں۔",
        "Answer": "ازگر میں ، طریقہ اوورلوڈنگ اور طریقہ اوور رائڈنگ دونوں تکنیک ہیں جو آبجیکٹ پر مبنی پروگرامنگ میں استعمال ہوتی ہیں ، لیکن وہ اپنے مقصد اور طرز عمل میں مختلف ہیں۔ میتھوڈ اوورلوڈنگ: طریقہ اوورلوڈنگ سے مراد ایک ہی نام کے ساتھ متعدد طریقوں کی وضاحت کرنے کی صلاحیت ہے لیکن اے کے اندر مختلف پیرامیٹر کی فہرستیں اے۔کلاسمناسب طریقہ کا انتخاب دلائل کی تعداد ، دلائل کی اقسام ، یا دونوں کی بنیاد پر کیا جاتا ہے۔ازگر مقامی طور پر کچھ دوسری پروگرامنگ زبانوں کی طرح اسی طرح سے زیادہ بوجھ ڈالنے کی حمایت نہیں کرتا ہے ، کیونکہ یہ ایک ہی نام اور مختلف پیرامیٹرز کے ساتھ متعدد طریقوں کی اجازت نہیں دیتا ہے۔تاہم ، ہم اسی طرح کے طرز عمل کو حاصل کرسکتے ہیں"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں پولیمورفزم کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "پولیمورفزم آبجیکٹ پر مبنی پروگرامنگ کا ایک تصور ہے جو مختلف طبقوں کے اشیاء کو عام سپر کلاس یا انٹرفیس کی اشیاء کے طور پر سمجھا جاتا ہے۔یہ کوڈ لکھنے کا ایک طریقہ مہیا کرتا ہے جو متعدد اقسام کی اشیاء کے ساتھ کام کرسکتا ہے ، جس سے زیادہ لچکدار اور قابل توسیع ڈیزائن کو قابل بناتا ہے۔ پولیمورفزم طریقوں یا افعال کو اس طرح لکھنے کی اجازت دیتا ہے جس پر کام کیا جاسکے۔"
    },
    {
        "Question": "\"ایک ازگر کی کلاس کو نافذ کریں جو بائنری سرچ ٹری کی نمائندگی کرتے ہیں جس میں اندراج ، حذف کرنے اور تلاش کے طریقوں کے ساتھ۔\"",
        "Answer": "یقینا!یہاں ازگر میں بائنری سرچ ٹری (بی ایس ٹی) کا ایک مثال عمل ہے ، جس میں اندراج ، حذف کرنے ، اور تلاش کے طریقے بھی شامل ہیں: پائیٹون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، کلید)= نان کلاس بائنری سرچ ٹری: Def __init __ (خود): self.root = کوئی بھی Def داخل نہیں (خود ، کلید): self.root = self._insert_recursive (self.root ،"
    },
    {
        "Question": "ازگر میں وراثت کے تصور کی وضاحت کریں اور ایک مثال پیش کریں جس میں واحد وراثت کا مظاہرہ کیا جائے۔",
        "Answer": "وراثت آبجیکٹ پر مبنی پروگرامنگ (OOP) میں ایک بنیادی تصور ہے جو کسی طبقے کو کسی دوسرے طبقے سے صفات اور طریقوں کا وارث ہونے کی اجازت دیتا ہے۔یہ کوڈ کو دوبارہ استعمال کرنے کے قابل بناتا ہے ، کوڈ تنظیم کو فروغ دیتا ہے ، اور کلاسوں کے مابین تعلقات قائم کرتا ہے۔ ایک کلاس کسی دوسرے طبقے سے وارث ہوسکتا ہے ، جسے سپر کلاس یا والدین کی کلاس کے نام سے جانا جاتا ہے ، اس کی خصوصیات کو حاصل کرنے کے لئے۔کلاس جو سپر کلاس سے وراثت میں ہے اسے سبکلاس یا چائلڈ کلاس کہا جاتا ہے۔ذیلی طبقہ تمام صفات کو وراثت میں ملتا ہے ("
    },
    {
        "Question": "\"اندراج ، حذف کرنے اور ٹریورسل کے طریقوں کے ساتھ منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ازگر میں ایک واحد منسلک فہرست کا ایک مثال عمل ہے ، جس میں اندراج ، حذف کرنے ، اور ٹریورسل کے طریقے بھی شامل ہیں: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا):"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں تجرید کے تصور کی وضاحت کریں اور ازگر میں ایک مثال پیش کریں۔",
        "Answer": "خلاصہ آبجیکٹ پر مبنی پروگرامنگ (OOP) میں ایک بنیادی اصول ہے جو آپ کو حقیقی دنیا کی اشیاء کو کلاس کے طور پر آسان اور ضروری خصوصیات کے ساتھ ماڈل بنانے کی اجازت دیتا ہے۔اس میں غیر ضروری تفصیلات کو چھپاتے ہوئے ضروری خصوصیات پر توجہ مرکوز کرکے پیچیدہ نظاموں یا اداروں کی نمائندگی کرنا شامل ہے۔ تعطل ایک اعلی سطح کا تصور فراہم کرتا ہے اور آپ کو ایسی کلاسیں بنانے کی اجازت دیتا ہے جو ان کی داخلی پیچیدگیوں کو بے نقاب کیے بغیر اشیاء کی ساخت اور طرز عمل کی وضاحت کرتے ہیں۔یہ آپ کو اعلی سطح پر تفہیم کے ساتھ اشیاء کے ساتھ کام کرنے کے قابل بناتا ہے ، اس پر توجہ مرکوز کرتے ہوئے کہ کوئی شے اس کے بجائے کیا کرتا ہے۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی ہوتی ہے جس میں انکیو ، ڈی کیوئو ، اور سائز کے طریقوں سے ہوتا ہے۔\"",
        "Answer": "یقینا!یہاں ایک فہرست کا استعمال کرتے ہوئے ازگر میں قطار کے اعداد و شمار کے ڈھانچے کا ایک مثال عمل ہے: پائیٹون کوپی کوڈکلاس قطار: Def __init __ (خود): self.items = [] Def is_empty (خود): ریٹرن لین (سیلف ڈاٹ آئٹم) == 0 ڈیف انکیو (خود ، آئٹم): self.items.append (آئٹم) Def dequeue (self): اگر خود نہیں ہے۔ IS_EMPTY (): خود واپس کریں۔خود): واپس لین (self.items) اندر"
    },
    {
        "Question": "\"گراف ڈیٹا کے ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور عمودی ، کناروں کو شامل کرنے اور گراف ٹریورسل انجام دینے کے طریقے فراہم کریں۔\"",
        "Answer": "یقینا!ملحقہ فہرست کی نمائندگی کا استعمال کرتے ہوئے ازگر میں گراف ڈیٹا ڈھانچے کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس گراف: ڈیف __init __ (خود): سیلف گراف = {} ڈیف ایڈ_ورٹیکس (سیلف ، ورٹیکس): اگر خود میں نہیں۔. گراف [ورٹیکس] = [] ڈیف ایڈ_ج (سیلف ، ورٹیکس 1 ، ورٹیکس 2): اگر خود کو۔(ورٹیکس 1)"
    },
    {
        "Question": "\"کلیدی قدر کی جوڑی داخل کرنے ، بازیافت اور ہٹانے کے طریقوں کے ساتھ ہیش ٹیبل (لغت) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ازگر میں ہیش ٹیبل (لغت) کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ہیش ٹیبل: ڈیف __init __ (خود): خود۔ سائز = 10 # ہیش ٹیبل کا ابتدائی سائز۔.size)] Def _hash (خود ، کلید): واپسی ہیش (کلید) ٪ خود۔اندراج [0] == کلید:"
    },
    {
        "Question": "ازگر میں جامد طریقے اور مثال کے طریقے کیا ہیں؟وہ کیسے مختلف ہیں؟",
        "Answer": "ازگر میں ، جامد طریقے اور مثال کے طریقے دو اقسام ہیں"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں پولیمورفک ایسوسی ایشن کے تصور کی وضاحت کریں اور ایک مثال پیش کریں۔",
        "Answer": "آبجیکٹ پر مبنی پروگرامنگ میں ، پولیمورفک ایسوسی ایشن مختلف طبقات کی اشیاء کی قابلیت کا حوالہ دیتے ہیں جو ایک عام انٹرفیس یا سپر کلاس کے ذریعہ ایک دوسرے کے ساتھ وابستہ ہوں ، جس سے تبادلہ استعمال اور تعامل کی اجازت ملتی ہے۔اس سے ان کی مخصوص اقسام سے قطع نظر ، اشیاء کو یکساں سلوک کرنے کی اجازت ملتی ہے ، جب تک کہ وہ انٹرفیس یا سپر کلاس کے ذریعہ بیان کردہ طرز عمل کے مشترکہ سیٹ پر عمل پیرا ہوں۔وہ مختلف کلاسوں کو عام اور مستقل انداز میں ایک دوسرے کے ساتھ بات چیت کرنے کی اجازت دیتے ہیں ، ڈیکپلنگ کو فروغ دیتے ہیں اور کم کرتے ہیں"
    },
    {
        "Question": "\"میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوزیشن کے طریقوں کے ساتھ میٹرکس کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یقینا!میٹرکس کے اضافے ، ضرب ، اور ٹرانسپوزیشن کے طریقوں کے ساتھ ازگر میں میٹرکس کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس میٹرکس: Def __init __ (خود ، قطاریں ، کولس): سیلف.روز = قطاریں خود۔[0] * رینج (قطار) میں _ کے لئے کالز] ڈیف __str __ (خود): میٹرکس_سٹر = \"\" خود میں قطار کے لئے۔ ڈیٹا ڈیٹا: میٹرکس_سٹر += \"\"\"\\ n\" واپس میٹرکس_سٹر ڈیف __add __ (خود ، دوسرا): اگر سیلف ڈاٹ آر او!"
    },
    {
        "Question": "ازگر میں طریقہ کس طرح زنجیر ہے؟ایک مثال پیش کریں جس کا مظاہرہ کرنے والے طریقہ کار زنجیروں کو۔",
        "Answer": "ازگر میں زنجیر زنجیروں سے مراد ایک ہی بیان میں کسی ایک بیان میں کسی شے پر متعدد طریقوں کو کال کرنے کا طریقہ ہے جس میں طریقہ کار کالز کو ایک ساتھ زنجیر بناتے ہیں۔زنجیر میں ہر طریقہ کار کو تبدیل کرتا ہے اور ترمیم شدہ آبجیکٹ کو لوٹاتا ہے ، جس سے بعد میں ہونے والے طریقہ کار کو ترمیم شدہ آبجیکٹ پر بنانے کی اجازت دی جاتی ہے۔ میتھوڈ چیننگ انٹرمیڈیٹ متغیرات اور کوڈ کی ایک سے زیادہ لائنوں کی ضرورت کو کم کرکے کوڈ پڑھنے کی اہلیت اور اجتماعی کو بہتر بنانے میں مدد فراہم کرسکتی ہے۔مثال کے طور پر مظاہرے کا مظاہرہ کرنے والا طریقہ: پائیتھون کوپی کوڈکلاس سٹرنگ بلڈر: Def __init __ (خود): سیلف.سٹرنگ = \"\" ڈیف ضمیم. کیپیٹلائز ()"
    },
    {
        "Question": "وراثت سے زیادہ ساخت کے تصور کی وضاحت کریں اور اس کے فوائد کی عکاسی کرنے والی ایک مثال پیش کریں۔",
        "Answer": "وراثت سے زیادہ ساخت آبجیکٹ پر مبنی پروگرامنگ کا ایک اصول ہے جو کوڈ کو دوبارہ استعمال اور لچک کو حاصل کرنے کے لئے وراثت (موجودہ کلاسوں کے ذیلی طبقوں کے طور پر خصوصی اشیاء کی تشکیل) کے حق میں مرکب (پیچیدہ اشیاء کی تعمیر) کے حق میں تجویز کرتا ہے۔دیگر اشیاء میں سے ، اور کمپوزڈ اشیاء کو مخصوص فعالیت فراہم کرنے کے لئے استعمال کیا جاتا ہے۔اس سے وراثت کے مقابلے میں کلاسوں کے مابین زیادہ لچک اور ڈھیلے جوڑے کی اجازت ملتی ہے ، جہاں ذیلی طبقات اپنے والدین کی کلاسوں کے طرز عمل اور ساخت کا وارث ہوتے ہیں۔"
    },
    {
        "Question": "\"اعلی ترجیحی عنصر کی داخل ، حذف کرنے اور بازیافت کے طریقوں کے ساتھ ترجیحی قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں۔\"",
        "Answer": "یقینا!اعلی ترجیحی عنصر کے اندراج ، حذف کرنے ، اور بازیافت کے طریقوں کے ساتھ ازگر میں ترجیحی قطار کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ترجیحی کیوئیو: ڈیف __init __ (خود).): اگر self.is_empty (): انڈیکس ایرر (\"ترجیحی قطار خالی ہے۔\") خود۔"
    },
    {
        "Question": "ازگر میں انٹرفیس کے تصور کی وضاحت کریں اور بتائیں کہ ان کا استعمال متعدد وراثت کے حصول کے لئے کس طرح کیا جاتا ہے۔",
        "Answer": "ازگر میں ، انٹرفیس کسی معاہدے یا قواعد کے ایک سیٹ کی وضاحت کرنے کا ایک طریقہ ہے جو ان طریقوں کی وضاحت کرتا ہے جن کو کلاس پر عمل درآمد کرنا چاہئے۔وہ اس طرز عمل کی وضاحت کرتے ہیں جس پر عمل درآمد کی کوئی تفصیلات فراہم کیے بغیر کلاس پر عمل پیرا ہونا چاہئے۔انٹرفیس کلاسوں کے لئے ایک بلیو پرنٹ کے طور پر کام کرتے ہیں ، اس بات کو یقینی بناتے ہیں کہ ان کے پاس کچھ خاص طریقے دستیاب ہیں۔ ازگر میں ، کچھ دوسری پروگرامنگ زبانوں میں انٹرفیس کی وضاحت کرنے کے لئے کوئی واضح مطلوبہ الفاظ موجود نہیں ہے۔اس کے بجائے ، انٹرفیس کو عام طور پر ازگر کے معیاری لائبریری میں اے بی سی ماڈیول کے ذریعہ فراہم کردہ خلاصہ بیس کلاس (اے بی سی) کا استعمال کرتے ہوئے نمائندگی کی جاتی ہے۔اے بی سی آپ کو تجریدی طریقوں کی وضاحت کرنے کی اجازت دیتے ہیں جن کو کسی بھی کنکریٹ کے ذیلی طبقے کے ذریعہ نافذ کرنا ضروری ہے۔ اے بی سی کا استعمال کرتے ہوئے ازگر میں انٹرفیس بنانے کے ل you ، آپ ایک تجریدی بیس کلاس کی وضاحت کرسکتے ہیں۔"
    },
    {
        "Question": "ازگر میں سپر () فنکشن کا مقصد کیا ہے؟اس کے استعمال کا مظاہرہ کرنے والی ایک مثال فراہم کریں۔",
        "Answer": "ازگر میں ، سپر () فنکشن کا استعمال کسی ذیلی طبقے سے کسی سپر کلاس (یا والدین کی کلاس) میں کسی طریقہ کو کال کرنے کے لئے کیا جاتا ہے۔یہ سبکلاس کو سپر کلاس کے طرز عمل کو برقرار رکھنے کے دوران سپر کلاس کی فعالیت کو بڑھانے یا اس سے زیادہ کرنے کی اجازت دیتا ہے۔سپر () فنکشن عام طور پر superClass کے `__ __init کی درخواست کرنے کے لئے سب کلاس کے __init __ () کے طریقہ کار کے اندر استعمال ہوتا ہے"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی ہوتی ہے جس میں داخل ، حذف کرنے اور کاموں کو ڈھیر کرنے کے طریقوں کے ساتھ۔\"",
        "Answer": "یقینا!یہاں داخل ، حذف کرنے ، اور ہیپائیف آپریشنز کے طریقوں کے ساتھ ازگر میں بائنری ہیپ کلاس کا ایک مثال عمل ہے: پیتھون کوپی کوڈکلاس بائنری ہیپ: ڈیف __init __ (خود): سیلف۔ ہیپ = [] ڈیف آئی ایس_پٹی (خود)) == 0 ڈیف داخل کریں (خود ، آئٹم): سیلف۔ ہیپ.ایپینڈ (آئٹم) خود"
    },
    {
        "Question": "ازگر میں متعدد وراثت میں طریقہ ریزولوشن آرڈر (ایم آر او) کے تصور کی وضاحت کریں اور ایک مثال پیش کریں۔",
        "Answer": "ازگر میں ، میتھڈ ریزولوشن آرڈر (ایم آر او) سے مراد اس ترتیب سے ہوتا ہے جس میں متعدد وراثت کے تناظر میں طریقوں کی تلاش کی جاتی ہے اور ان کی درخواست کی جاتی ہے۔جب ایک کلاس متعدد والدین کی کلاسوں سے وراثت میں ملتی ہے تو ، ایم آر او اس ترتیب کا تعین کرتا ہے جس میں والدین کی کلاسوں کو طریقہ کار کو حل کرنے کے لئے تلاش کیا جاتا ہے۔ایم آر او اس بات کو یقینی بناتا ہے کہ وراثت کے درجہ بندی میں ہر ایک طریقہ کو بالکل ایک بار اور مستقل ترتیب میں ، تنازعات اور ابہاموں سے گریز کرتے ہوئے۔"
    },
    {
        "Question": "وراثت کے سلسلے میں طریقہ کار کے تصور کو بیان کریں اور اس کے استعمال کی مثال پیش کرنے والی ایک مثال پیش کریں۔",
        "Answer": "طریقہ کار اوور رائڈنگ آبجیکٹ پر مبنی پروگرامنگ میں ایک تصور ہے جو ایک ذیلی طبقے کو کسی ایسے طریقہ کار پر عمل درآمد کرنے کی اجازت دیتا ہے جو اس کے سپر کلاس میں پہلے ہی بیان کیا گیا ہے۔جب کسی طریقہ کو زیر کیا جاتا ہے تو ، سبکلاس اس طریقہ کار کا ایک مختلف نفاذ فراہم کرتا ہے جو اس کی اپنی ضروریات سے مخصوص ہے ، جبکہ اب بھی سپر کلاس کے طریقہ کار کے دستخط (نام اور پیرامیٹرز) کو محفوظ رکھتے ہوئے۔ کسی طریقہ کو زیر کرنے سے ، سبکلاس میں ترمیم یا اس میں توسیع کی جاسکتی ہے۔سپر کلاس سے وراثت میں ملا ہوا سلوک ، جس کی تخصیص اور تخصیص کی اجازت دی جاتی ہے۔ یہاں طریقہ کار کو واضح کرنے کے لئے ایک مثال ہے: پیتھون کوپی کوڈکلاس جانور: ڈیف میک_ساؤنڈ (خود): پرنٹ (\"جانور ایک آواز بناتا ہے۔\") کلاس ڈاگ (جانور): ڈیف میک_ساؤنڈ (خود)): پرنٹ (\"ڈاگ بارکس۔\") کلاس بلی"
    },
    {
        "Question": "وراثت سے زیادہ مرکب کے اصولوں کی وضاحت کریں اور ایک حقیقی دنیا کا منظر پیش کریں جہاں مرکب زیادہ مناسب ہوگا۔",
        "Answer": "ساخت کا اصول"
    },
    {
        "Question": "\"سافٹ ویئر کی نشوونما میں ڈیزائن کے نمونوں کے تصور کی وضاحت کریں اور تخلیقی ، ساختی اور طرز عمل کے ڈیزائن کے نمونے کی ایک مثال پیش کریں۔\"",
        "Answer": "سافٹ ویئر ڈویلپمنٹ میں ڈیزائن کے نمونے سافٹ ویئر ڈیزائن میں عام طور پر پائے جانے والے مسائل کے قابل استعمال حل ہیں۔وہ مخصوص ڈیزائن کے مسائل کو مؤثر طریقے سے حل کرنے کے لئے کوڈ کو تشکیل دینے کے لئے ایک ٹیمپلیٹ یا ایک رہنما اصول فراہم کرتے ہیں۔ڈیزائن کے نمونوں کا مقصد بہترین طریقوں اور ثابت شدہ حلوں کو فروغ دے کر کوڈ پڑھنے کی اہلیت ، برقرار رکھنے اور اسکیل ایبلٹی کو بڑھانا ہے۔ یہاں تخلیقی ، ساختی اور طرز عمل کے ڈیزائن کے نمونوں کی مثالیں ہیں۔"
    },
    {
        "Question": "\"دو اسٹیکوں کا استعمال کرتے ہوئے قطار کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں ، جس سے موثر انکیو اور ڈی کیو آپریشنز کو یقینی بنایا جاسکے۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو دو اسٹیکوں کا استعمال کرتے ہوئے قطار کی نمائندگی کرتا ہے ، جس سے موثر انکیو اور ڈی کیو آپریشنز کو یقینی بناتے ہیں: پائیتھونکپی کوڈکلاس قطار: ڈیف __init __ (خود): سیلف.ایک 1 = [] سیلف۔ اسٹیک 2 = [] ڈیف اینکیو (خود ، آئٹم)"
    },
    {
        "Question": "ازگر میں متعدد وراثت کے تصور کی وضاحت کریں اور اس سے وابستہ امکانی چیلنجوں اور حلوں پر تبادلہ خیال کریں۔",
        "Answer": "ازگر میں ایک سے زیادہ وراثت سے مراد ایک سے زیادہ والدین کی کلاسوں سے کسی طبقے کی وارث ہونے کی صلاحیت ہے۔اس کا مطلب یہ ہے کہ بچوں کی کلاس ایک سے زیادہ والدین طبقے سے صفات اور طریقوں کا وارث ہوسکتی ہے۔یہ کلاس ڈیزائن میں کوڈ کو دوبارہ استعمال اور لچک کی اجازت دیتا ہے۔ جب ایک کلاس متعدد والدین کی کلاسوں سے وراثت میں ملتی ہے تو ، یہ والدین کی تمام کلاسوں میں بیان کردہ صفات اور طریقوں تک رسائی اور استعمال کرسکتا ہے۔چائلڈ کلاس تمام والدین کی کلاسوں کا مجموعہ بن جاتا ہے ، ان کی فعالیت کو شامل کرتا ہے۔ تاہم ، متعدد وراثت کچھ چیلنجوں کا تعارف کر سکتی ہے: ابہام"
    },
    {
        "Question": "آبجیکٹ پر مبنی پروگرامنگ میں انحصار انجیکشن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "انحصار انجیکشن آبجیکٹ پر مبنی پروگرامنگ میں ایک ڈیزائن کا نمونہ ہے جو اجزاء کو اندرونی طور پر ان کی انحصار تخلیق کرنے یا ان کا نظم و نسق کرنے کی بجائے بیرونی ذرائع سے انحصار فراہم کرکے اجزاء کو ڈیکپلنگ کی اجازت دیتا ہے۔یہ سافٹ ویئر سسٹمز میں ڈھیلے جوڑے ، ماڈیولریٹی ، اور ٹیسٹیبلٹی کو فروغ دیتا ہے۔ انحصار انجیکشن میں ، کلاس کی انحصار کو باہر سے کلاس میں \"انجکشن\" لگایا جاتا ہے ، عام طور پر کنسٹرکٹر پیرامیٹرز یا سیٹٹر طریقوں کے ذریعے۔اس طرح ، کلاس کو براہ راست اس کے انحصار بنانے یا اس کے بارے میں جاننے کی ضرورت نہیں ہے ، جس سے یہ مختلف نفاذ کے ساتھ زیادہ لچکدار اور آسانی سے تبدیل ہوجاتا ہے۔ یہاں ازگر میں انحصار انجیکشن کو نافذ کرنے کی ایک مثال ہے: پائیٹون کوپی کوڈکلاس ای میل سروس: ڈیف بھیجنے_ میل (خود ، وصول کنندہ ،پیغام):"
    },
    {
        "Question": "\"تھریڈ سے محفوظ سنگلٹن پیٹرن کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں ، اس بات کو یقینی بنائیں کہ کلاس کی صرف ایک مثال تشکیل دی جاسکے۔\"",
        "Answer": "یقینا!یہاں ایک لاک کا استعمال کرتے ہوئے ازگر میں تھریڈ سیف سنگلٹن پیٹرن کا نفاذ یہ ہے کہ اس بات کا یقین کرنے کے لئے کہ کلاس کی صرف ایک مثال تیار کی جاسکتی ہے: پائیتھون کوپی کوڈیمپورٹ تھریڈنگکلاس سنگلٹن: _ ان اسٹینس = کوئی نہیں _ لاک = تھریڈنگ۔ لاک () classmethod def get_instance (CLS): اگر نہیں cls._Instance: cls._lock کے ساتھ: اگر Cls._instance: cls._instance = سنگلٹن () واپس Cls._Instance اس نفاذ کے بارے میں ، سنگلٹن کلاس میں سنگلٹن کی مثال کے طور پر کلاس متغیر _ ان اسٹنس ہے۔مثال کے تخلیق کے دوران تھریڈ سیفٹی کو یقینی بنانے کے لئے _ لاک کلاس متغیر کا استعمال کیا جاتا ہے۔"
    },
    {
        "Question": "ازگر میں اتلی کاپی اور گہری کاپی کے مابین پائے جانے والے اختلافات پر تبادلہ خیال کریں اور اس کی وضاحت کریں کہ ہر ایک کو استعمال کیا جانا چاہئے۔",
        "Answer": "ازگر میں ، اتلی کاپی اور گہری کاپی کے تصورات استعمال ہوتے ہیں جب تغیر پزیر اشیاء ، جیسے فہرستوں ، لغات ، یا کسٹم آبجیکٹ سے نمٹنے کے لئے۔آئیے اتلی کاپی اور گہری کاپی کے مابین اختلافات پر تبادلہ خیال کریں اور جب ہر ایک کو استعمال کیا جانا چاہئے: اتلی کاپی: اتلی کاپی ایک نیا شے تیار کرتی ہے لیکن اصل شے کی طرح ہی عناصر کا حوالہ دیتی ہے۔اس کا مطلب یہ ہے کہ اصل شے میں کی جانے والی تبدیلیاں اتلی کاپی میں ظاہر ہوں گی ، اور اس کے برعکس۔دوسرے لفظوں میں ، ایک اتلی کاپی ایک نئی شے تیار کرتی ہے لیکن ڈیٹا کے حوالہ جات کو اصل شے کے ساتھ شیئر کرتی ہے۔"
    },
    {
        "Question": "فیکٹری کے طریقہ کار کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "فیکٹری کے طریقہ کار کا نمونہ ایک تخلیقی ڈیزائن کا نمونہ ہے جو اشیاء کو بنانے کے لئے ایک انٹرفیس مہیا کرتا ہے لیکن اصل آبجیکٹ کی تخلیق کو ذیلی طبقات میں تفویض کرتا ہے۔اس سے کلائنٹ کوڈ کو فوری طور پر آبجیکٹ کے مخصوص طبقے کو جاننے کے بغیر اشیاء بنانے کی اجازت ملتی ہے۔ فیکٹری کا طریقہ کار کلائنٹ کوڈ کو تخلیق شدہ اشیاء کی مخصوص نفاذ کی تفصیلات سے الگ کرکے ڈھیلے جوڑے کو فروغ دیتا ہے۔یہ فیکٹری کے اندر آبجیکٹ تخلیق منطق کو سمیٹتا ہے"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں سرکلر بفر کی نمائندگی ہوتی ہے جس میں انکیو ، ڈی کیوئو ، اور اس بات کا تعین کرنے کے طریقوں کے ساتھ بفر مکمل یا خالی ہے ، ایک مقررہ سائز کی صف کا استعمال کرتے ہوئے۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو ایک مقررہ سائز کی سرنی کا استعمال کرتے ہوئے سرکلر بفر کی نمائندگی کرتا ہے: پیتھون کوپی کوڈکلاس سرکلر بفر: ڈیف __init __ (خود ، سائز): خود.tail = 0 self.cont = 0 def enqueue (خود ، آئٹم): اگر self.is_full (): استثناء بڑھاؤ (\"بفر بھرا ہوا ہے\") سیلف۔ بفر [سیلف۔ ٹیل] = آئٹم سیلف۔ ٹیل = (خود۔دم + 1) ٪ خود۔"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں حکمت عملی کے طرز کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "حکمت عملی کا نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو آپ کو الگورتھم کے کنبے کی وضاحت کرنے ، ہر ایک کو الگ الگ طبقے کے طور پر متعین کرنے اور رن ٹائم کے وقت ان کو تبادلہ خیال کرنے کی اجازت دیتا ہے۔یہ مؤکل کو کسی خاص الگورتھم یا حکمت عملی کا انتخاب کرنے کے قابل بناتا ہے جس کو اس کے نفاذ کے ساتھ مضبوطی سے جوڑ دیا جائے۔ حکمت عملی کے نمونہ کے پیچھے کلیدی خیال یہ ہے کہ اس کے استعمال کو استعمال کرنے والے مؤکل سے طرز عمل یا الگورتھم کو الگ کیا جائے۔یہ علیحدگی کوڈ بیس کی لچک ، دوبارہ پریوستیت اور برقرار رکھنے کو فروغ دیتی ہے۔کلائنٹ کا کوڈ مختلف حکمت عملیوں یا الگورتھم کے مابین متحرک طور پر اس کے اپنے نفاذ میں کسی ترمیم کی ضرورت کے بغیر تبدیل ہوسکتا ہے۔ یہاں ازگر میں حکمت عملی کے نمونے کی وضاحت کرنے کی ایک مثال ہے: پائیتھون کوپی کوڈکلاس سٹرنگ اسٹریٹی: ڈی ای ایف ترتیب (خود ، ڈیٹا): پاسکلاس کوئکسٹ اسٹریٹیٹی (ترتیب دینے والی جگہ)ترتیب دیں (خود ، ڈیٹا): پرنٹ (\"فوری ترتیب کا استعمال کرتے ہوئے چھانٹ رہا ہے\") # کوئیک ترتیب کلاس انضمام کا نفاذ"
    },
    {
        "Question": "تقسیم شدہ نظاموں میں غلطی رواداری کے تصور پر تبادلہ خیال کریں اور کس طرح نقل اور اتفاق رائے سے الگورتھم جیسی تکنیکوں کو ازگر میں استعمال کیا جاسکتا ہے۔",
        "Answer": "غلطی رواداری ایک تقسیم شدہ نظام کی صلاحیت ہے جو ناکامیوں یا غلطیوں کی موجودگی میں بھی مناسب طریقے سے کام جاری رکھے۔تقسیم شدہ نظاموں میں ، ہارڈ ویئر کے مسائل ، سافٹ ویئر کیڑے ، نیٹ ورک کے مسائل ، یا دیگر غیر متوقع واقعات کی وجہ سے ناکامی ہوسکتی ہے۔غلطی رواداری کے طریقہ کار کو یہ یقینی بنانے کے لئے استعمال کیا جاتا ہے کہ نظام ان ناکامیوں کو خوبصورتی سے سنبھال سکتا ہے اور بغیر کسی مداخلت یا ڈیٹا میں کمی کے بغیر اس کی خدمات کی فراہمی جاری رکھ سکتا ہے۔ تقسیم شدہ نظاموں میں غلطی رواداری کو حاصل کرنے کے لئے استعمال ہونے والی عام تکنیکوں کی نقل اور اتفاق رائے الگورتھم ہیں۔ نقل کی نقل میں متعدد کاپیاں بنانا شامل ہے۔ڈیٹا یا اجزاء اور نظام میں مختلف نوڈس میں تقسیم کرنا۔اگر ایک نوڈ ناکام ہوجاتا ہے تو ، دوسرے نوڈس اقتدار سنبھال سکتے ہیں اور درخواستوں کی خدمت جاری رکھ سکتے ہیں۔نقل فالتو پن فراہم کرتا ہے اور دستیابی اور وشوسنییتا میں اضافہ کرتا ہے۔مختلف نقل کی حکمت عملی ہیں ، جیسے پرائمری بیک اپ کی نقل ، جہاں ایک نوڈ پرائمری کی حیثیت سے کام کرتا ہے اور دوسرے بیک اپ ، یا ہم مرتبہ سے پیر کی نقل کی حیثیت سے کام کرتا ہے ، جہاں تمام نوڈس برابر ہیں اور درخواستوں کو سنبھال سکتے ہیں۔نقل کو تقسیم شدہ نظاموں میں ڈیٹا اور گنتی دونوں پر لاگو کیا جاسکتا ہے۔وہ اس بات کو یقینی بناتے ہیں کہ تمام نوڈس متفق ہوں"
    },
    {
        "Question": "ہدایت والے وزن والے گراف کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور فلائیڈ وارشل الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے طریقے فراہم کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو ہدایت والے وزن والے گراف کی نمائندگی کرتا ہے اور فلائیڈ وارشل الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے ایک طریقہ فراہم کرتا ہے۔"
    },
    {
        "Question": "رد عمل کے سلسلے کے تصور کی وضاحت کریں اور یہ کہ ان کو کس طرح ازگر میں Asyncio جیسے لائبریریوں کا استعمال کیا جاسکتا ہے۔",
        "Answer": "رد عمل کے سلسلے ایک تصریح ہے جو اعداد و شمار کے سلسلے کو سنبھالنے کے لئے ایک معیار فراہم کرتا ہے جو متضاد اور غیر مسدود کرنے والے بیک پریسر کے ساتھ ہے۔یہ انٹرفیس ، قواعد ، کے ایک سیٹ کی وضاحت کرتا ہے ،"
    },
    {
        "Question": "سافٹ ویئر ڈیزائن میں ترجمان کے نمونے کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "ترجمان کا نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو کسی زبان میں جملے کا اندازہ کرنے یا اس کی ترجمانی کرنے کے لئے ایک طریقہ کی وضاحت کرتا ہے۔یہ ڈومین سے متعلق مخصوص زبان (DSL) میں نمائندگی کرنے والے جملوں یا تاثرات کی تجزیہ اور عملدرآمد کے لئے ایک فریم ورک مہیا کرتا ہے۔ ترجمان کے نمونے کے کلیدی اجزاء یہ ہیں: خلاصہ اظہار: DSL میں کسی خاص آپریشن یا اظہار کی ترجمانی کے لئے ایک انٹرفیس کی وضاحت کرتا ہے۔یہ عام طور پر ایک تشریح () طریقہ پر مشتمل ہوتا ہے جو ایک سیاق و سباق کو ان پٹ کے طور پر لیتا ہے اور تشریح کو انجام دیتا ہے۔ ٹرمینل اظہار: DSL میں بنیادی اظہار یا آپریشن کی نمائندگی کرتا ہے۔یہ تشریح () کے طریقہ کار کو نافذ کرتا ہے اور اظہار کا اندازہ کرنے کے لئے منطق فراہم کرتا ہے۔ نون ٹرمینل اظہار: DSL میں ایک جامع اظہار یا ایک پیچیدہ آپریشن کی نمائندگی کرتا ہے۔اس میں عام طور پر دوسرے تاثرات ہوتے ہیں کیونکہ اس کے بچوں کی حیثیت سے اور اس کے بچوں کی تشریحات کو یکجا کرکے تشریح () کے طریقہ کار کو نافذ کرتا ہے۔یہ تشخیص کے دوران تاثرات کو ضروری معلومات فراہم کرتا ہے۔ یہاں"
    },
    {
        "Question": "ایونٹ سے چلنے والے فن تعمیر (ای ڈی اے) کے اصولوں پر تبادلہ خیال کریں اور بتائیں کہ ان کو کس طرح ازگر میں جیانگو اور فلاسک جیسے فریم ورک کا استعمال کیا جاسکتا ہے۔",
        "Answer": "واقعہ سے چلنے والا فن تعمیر (ای ڈی اے) ایک سافٹ ویئر ڈیزائن کا نمونہ ہے جو نظام کے مختلف اجزاء کے مابین واقعات اور پیغامات کے بہاؤ پر زور دیتا ہے۔اس میں سخت درخواست کے جوابی ماڈل پر عمل کرنے کے بجائے اجزاء کو غیر متزلزل واقعات پر رد عمل ظاہر کرنے کی اجازت دے کر ڈھیلے جوڑے اور اسکیل ایبلٹی پر توجہ دی گئی ہے۔ واقعہ سے چلنے والے فن تعمیر کے اصول یہ ہیں: فرسٹ کلاس کے شہریوں کی حیثیت سے واقعات: واقعات میں واقعات کا مرکزی کردار ہوتا ہے۔کارفرما فن تعمیروہ سسٹم میں اہم واقعات یا تبدیلیوں کی نمائندگی کرتے ہیں اور کیا ہوا ہے اس کے بارے میں معلومات رکھتے ہیں۔واقعات کو ان اجزاء سے ڈیکپل کیا جاتا ہے جو ان کو تیار کرتے ہیں ، جس سے دوسرے اجزاء کو واقعات پر سبسکرائب کرنے اور اس پر ردعمل ظاہر کرنے کی اجازت ملتی ہے۔اس سے ڈھیلے جوڑے کو قابل بناتا ہے اور اجزاء کو آزادانہ طور پر چلانے کی اجازت ملتی ہے ، کیونکہ انہیں دوسرے اجزاء سے براہ راست ردعمل کا انتظار کرنے کی ضرورت نہیں ہے۔ ایونٹ سے چلنے والے ورک فلو: نظام کا بہاؤ واقعات کے ذریعہ چلتا ہے۔جب کوئی واقعہ پیش آتا ہے تو ، یہ متحرک ہوجاتا ہے"
    },
    {
        "Question": "بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور عناصر کو شامل کرنے اور ممبرشپ کی جانچ پڑتال کے طریقے فراہم کریں۔",
        "Answer": "یقینا!یہاں ازگر میں ایک بلوم فلٹر کا نفاذ ہے: پیتھون کوپی کوڈیمپورٹ ہیشلیب فریم بِٹرای امپورٹ بلوم فیلٹر: ڈیف __init __ (خود ، سائز ، ہیش_فونکشن): سیلف۔سیٹال (غلط) ڈیف _ ہش (خود ، آئٹم): ہیش_فونک کے لئے خود۔ ہیش_فونکشن کے لئے ہیش = []٪ خود۔آئٹم) ہیش میں انڈیکس کے لئے: اگر خود نہیں۔ بٹ_آرے [انڈیکس]: غلط واپسی سچ# مثال کے استعمال سے"
    },
    {
        "Question": "آبجیکٹ پر مبنی ڈیزائن میں پل پیٹرن کے تصور کی وضاحت کریں اور ازگر میں اس کے نفاذ کی ایک مثال پیش کریں۔",
        "Answer": "پل کا نمونہ ایک ڈیزائن کا نمونہ ہے جو اس کے نفاذ سے ایک تجرید کو گھٹا دیتا ہے تاکہ وہ آزادانہ طور پر مختلف ہوسکیں۔یہ تجریدی اور اس کے نفاذ کے مابین ایک پل بنا کر ڈھیلے جوڑے کو فروغ دیتا ہے ، جس سے وہ آزادانہ طور پر تیار ہوسکتے ہیں۔ پل کے نمونے کے اہم اجزاء یہ ہیں: خلاصہ: یہ اعلی سطحی انٹرفیس یا تجرید کی وضاحت کرتا ہے جس کے ساتھ مؤکل تعامل کرتے ہیں۔اس میں عام طور پر اعلی سطحی کاروائیاں یا طریقے شامل ہوتے ہیں۔یہ نچلی سطح کی کارروائیوں کو مہیا کرتا ہے جس پر تجرید پر انحصار ہوتا ہے۔ کنکریٹ خلاصہ: یہ خلاصہ کے ایک مخصوص نفاذ کی نمائندگی کرتا ہے۔ کنکریٹ نفاذ کنندہ: یہ نفاذ کنندہ انٹرفیس کے ایک مخصوص نفاذ کی نمائندگی کرتا ہے۔ پل کا نمونہ ہمیں تبدیل کرنے یا اس کے مختلف نفاذ کو شامل کرنے کی اجازت دیتا ہے۔تجرید یا عمل کنندہ ایک دوسرے کو متاثر کیے بغیر۔اس سے لچک ، برقرار رکھنے اور توسیع کو فروغ ملتا ہے"
    },
    {
        "Question": "مسلسل انضمام اور مستقل تعیناتی (CI/CD) کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ ازگر منصوبوں میں جینکنز یا گٹ لیب جیسے ٹولز کا استعمال کرتے ہوئے ان کا اطلاق کیسے کیا جاسکتا ہے۔",
        "Answer": "سافٹ ویئر ڈویلپمنٹ میں مسلسل انضمام (CI) اور مسلسل تعیناتی (CD) عمل ہیں جن کا مقصد بلڈنگ ، ٹیسٹنگ اور سافٹ ویئر کی تعیناتی کے عمل کو خودکار اور ہموار کرنا ہے۔یہ طریقوں سے ترقی کی کارکردگی کو بہتر بنانے میں مدد ملتی ہے ،"
    },
    {
        "Question": "بائنری اسپیس پارٹیشننگ (بی ایس پی) کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور خلائی تقسیم اور قریبی پڑوسی کی تلاش کے طریقے فراہم کریں۔",
        "Answer": "یقینا!اسپیس پارٹیشننگ اور قریبی پڑوسی کی تلاش کے طریقوں کے ساتھ بائنری اسپیس پارٹیشننگ (بی ایس پی) کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس کا ایک مثال عمل ہے: پیتھون کوپی کوڈیمپورٹ نیمپی کے طور پر این پی سی ایل اے ایس سی پوائنٹ: ڈیف __INIT __ (خود ، کوآرڈز): سیلف ڈاٹ کوورڈز = این پی آر آرے (((خود ، کوآرڈز)کوآرڈز) ڈیف ڈسٹنس (خود ، دوسرا): واپس NP.LINLG.Norm (self.coords - دوسرے.کورڈز) کلاس BSPNodپوائنٹ سیلف۔کسی بھی طول و عرض کے ساتھ زیادہ سے زیادہ تغیر میکس_ وی آر = -1 اسپلٹ_ڈیم = -1 کے لئے I (لین (پوائنٹس [0] .coords)) میں Ivar> زیادہ سے زیادہ_اار: میکس_ وی آر = var split_dim = i # ترتیب"
    },
    {
        "Question": "ازگر میں میٹاپروگرامنگ کے تصور کی وضاحت کریں اور میٹاکلاس یا سجاوٹ کی ایک مثال پیش کریں۔",
        "Answer": "میٹاپروگرامنگ رن ٹائم کے وقت متحرک طور پر کوڈ میں ترمیم کرنے یا تیار کرنے کے پروگرام کی صلاحیت ہے۔اس سے آپ کو کوڈ لکھنے کی اجازت ملتی ہے جو آپ کے پروگراموں کو زیادہ لچکدار اور موافقت بخش بنائے جانے والے دوسرے کوڈ کا معائنہ ، ترمیم یا تخلیق کرسکتی ہے۔ ازگر میں ، میٹاکلاس یا سجاوٹ کا استعمال کرتے ہوئے میٹاپروگرامنگ حاصل کی جاسکتی ہے۔ میٹاکلاسس: میٹاکلاسس کلاس ہیں جو دوسری کلاسوں کے طرز عمل کی وضاحت کرتی ہیں۔جب آپ کسی کلاس کی وضاحت کرتے ہیں تو ، میٹاکلاس اس کلاس کی تخلیق کو کنٹرول کرتا ہے۔کسٹم میٹاکلاس کی وضاحت کرکے ، آپ طبقاتی تخلیق ، وصف تک رسائی ، طریقہ ریزولوشن اور بہت کچھ کے طرز عمل میں ترمیم کرسکتے ہیں۔میٹاکلاس اکثر فریم ورک بنانے یا ڈیزائن کے نمونوں کو نافذ کرنے کے لئے استعمال ہوتے ہیں۔ یہاں میٹاکلاس کی ایک مثال جو طبقاتی تخلیق کے طرز عمل میں ترمیم کرتی ہے: پائیٹون کوپی کوڈکلاس کسٹومیٹا (قسم):"
    },
    {
        "Question": "ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور گہرائی سے پہلے تلاش (ڈی ایف ایس) کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے طریقے فراہم کریں۔",
        "Answer": "یقینا!گہرائی میں پہلی تلاش (ڈی ایف ایس) کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے طریقوں کے ساتھ ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرنے والی ایک ازگر کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈفرم کلیکشن درآمد ڈیفالٹ ڈکٹکلاس ڈی اے جی: ڈیف __init __ (خود)) ڈیف ایڈ_ج (سیلف ، یو ، وی): سیلف گراف [یو]پڑوسی میں"
    },
    {
        "Question": "ازگر میں ہم آہنگی اور ہم آہنگی کے تصور پر تبادلہ خیال کریں اور ان کے مابین اختلافات کی وضاحت کریں۔",
        "Answer": "ایک خرابی آگئی.یا تو آپ نے جس انجن کی درخواست کی ہے وہ موجود نہیں ہے یا آپ کی درخواست پر کارروائی کرنے میں کوئی اور مسئلہ تھا۔اگر یہ مسئلہ برقرار رہتا ہے تو براہ کرم ہم سے ہیلپ ڈاٹ کام پر ہمارے ہیلپ سنٹر کے ذریعے رابطہ کریں۔"
    },
    {
        "Question": "بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور عناصر کو شامل کرنے اور کم غلط مثبت شرح کے ساتھ ممبرشپ کی جانچ پڑتال کے طریقے فراہم کریں۔",
        "Answer": "یقینا!اندراج ، حذف کرنے ، اور ٹریورسل کے طریقوں کے ساتھ سرکلر سے منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس کا ایک مثال عمل ہے: پائیٹون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا = کوئی بھی نہیں)__init __ (self): self.head = کوئی بھی Def is_empty (self): واپسی سیلف نہیں۔ کوئی بھی Def داخل نہیں ہے (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر self.is_empty (): new_nodاپنے آپ کو ایک سرکلر لسٹ میں خود سے۔اعداد و شمار: اگر self.is_empty (): پرنٹ (\"فہرست خالی ہے۔ حذف ناکام۔\") موجودہ = خود نہیں۔.next اگر موجودہ == سیلف ہیڈ: سیلف ہیڈ = کرنٹ۔ نیکسٹ اور: جبکہ موجودہ۔ نیکسٹ!.Next ریٹرن اگر موجودہ۔ نیکسٹ == سیلف ہیڈ: پرنٹ (ایف \"{ڈیٹا} فہرست میں نہیں ملا۔حذف ناکام ہوگیا۔ \") واپس لوٹیں = موجودہ موجودہ = موجودہ۔ نیکسٹ ڈیف ٹراورس (خود): اگر سیلف۔ آئی ایس_پٹی (): پرنٹ (\" فہرست خالی ہے۔ \") موجودہ = سیلف۔، end = \"\") موجودہ = موجودہ۔ نیکسٹ اگر موجودہ == سیلف ہیڈ: بریک# مثال کے استعمال: clist = سرکلر لنکڈ لسٹ () clist.insert (1) clist.insert (2) clist.insert (3) clist.insert(4) پرنٹ (\"سرکلر لنکڈ فہرست:\" ، اختتام = \"\") کلیسٹ۔ ٹراورس () پرنٹ (\"فہرست سے 2 ڈیلیٹنگ۔\"، end = \"\") Clist.traverse () اس مثال میں ، ہمارے پاس سرکلر لنکڈ لسٹ کے انفرادی نوڈس کی نمائندگی کرنے کے لئے نوڈ کلاس ہے۔ سرکلر لنک لسٹ کلاس میں فہرست داخل کرنے ، حذف کرنے اور عبور کرنے کے طریقے موجود ہیں۔ داخل کرنے کا طریقہ داخل کرتا ہے۔فہرست کے اختتام پر نیا نوڈ۔ اگر فہرست خالی ہے تو ، نیا نوڈ سر بن جاتا ہے اور خود کی طرف اشارہ کرتا ہے۔ بصورت دیگر ، نیا نوڈ آخری نوڈ کے بعد شامل کیا جاتا ہے ، اور اس کا اگلا پوائنٹر سر پر سیٹ ہوجاتا ہے۔طریقہ دیئے گئے ڈیٹا ویلیو کی بنیاد پر فہرست سے نوڈ کو ہٹا دیتا ہے۔اگر نوڈ کو حذف کرنا ہی سر ہے تو ، سر کو اگلے نوڈ میں اپ ڈیٹ کیا جاتا ہے ، اور آخری نوڈ کا اگلا پوائنٹر اسی کے مطابق ایڈجسٹ ہوتا ہے۔اگر نوڈ کو حذف کرنا سر نہیں ہے تو ، اسے پچھلے اور موجودہ نوڈس کے اگلے پوائنٹرز کو ایڈجسٹ کرکے آسانی سے ہٹا دیا جاتا ہے۔ ٹراورس کا طریقہ کار سے شروع ہوتا ہے ، سر سے شروع ہوتا ہے ، اور ہر نوڈ کے ڈیٹا کو پرنٹ کرتا ہے جب تک کہ یہ نہ پہنچ جائے۔ایک بار پھر سر۔ فینلی طور پر ، کلاس کا ایک مثال استعمال دکھایا گیا ہے ، جہاں نوڈس کو سرکلر لنکڈ لسٹ میں داخل کیا جاتا ہے ، ایک کو حذف کردیا جاتا ہے ، اور اس فہرست میں تبدیلیوں کو ظاہر کرنے کے لئے عبور کیا جاتا ہے۔"
    },
    {
        "Question": "\"ازگر میں ڈیزائن کے نمونوں کے تصور کی وضاحت کریں اور سنگلٹن ، فیکٹری ، اور مبصرین کے نمونوں کی مثالیں پیش کریں۔\"",
        "Answer": "آبزرور پیٹرن ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو کسی شے کو ، جس کو مضمون کہا جاتا ہے ، کو اپنے انحصار کرنے والوں کی فہرست کو برقرار رکھنے کی اجازت دیتا ہے ، جسے مبصرین کہا جاتا ہے ، اور انہیں کسی بھی ریاست کی تبدیلیوں کے بارے میں خود بخود مطلع کیا جاتا ہے۔یہ نمونہ اس موضوع اور مبصرین کے مابین ڈھیلے جوڑے کو فروغ دیتا ہے ، جس سے مبصرین کو اس موضوع میں تبدیلیوں پر ردعمل ظاہر کرنے کے قابل بناتا ہے جس میں اس موضوع کے بغیر مخصوص مبصرین کے بارے میں کوئی معلومات نہیں ہے۔جب کوئی تبدیلی واقع ہوتی ہے۔دوسری طرف ، مبصرین ، اس موضوع کے ساتھ اپنے آپ کو رجسٹر کریں اور ایک ایسے طریقہ کی وضاحت کریں جس کو مطلع کیا جاتا ہے۔یہ طریقہ انہیں اپنی ریاست کو اپ ڈیٹ کرنے یا موضوع میں ہونے والی تبدیلیوں کی بنیاد پر کوئی ضروری اقدامات انجام دینے کی اجازت دیتا ہے۔ یہاں ازگر میں آبزرور پیٹرن کی مثال کے طور پر عمل درآمد: پائیتھون کوپی کوڈکلاس مضمون: Def __init __ (خود): self.observers = [] def register_observerser_observers = [] Def register_observers =.) کلاس آبزرور: ڈیف اپ ڈیٹ (خود ، ڈیٹا): پاسکلاس کنکریٹو ایورور (آبزرور): ڈی ای ایف اپ ڈیٹ (خود ، ڈیٹا): پرنٹ (\"موصولہ ڈیٹا:\" ، ڈیٹا)# مثال استعمال: موضوع = موضوع () مشاہدہ () آبزرور 1 = کنکریٹو سروور ()آبزرور 2 = کنکریٹو بائسرور () سبجیکٹ۔ ریگسٹر_بسرور (آبزرور 1) سبجیکٹ۔ ریگیسٹر_بسرور (مبصرین 2) موضوع۔ notify_observers (\"ہیلو ، مبصرین!\") مضمون۔ایک مضمون کی کلاس رکھیں جو مبصر کے نمونہ میں مضمون کی نمائندگی کرتا ہے۔یہ مبصرین کی ایک فہرست کو برقرار رکھتا ہے اور مشاہدین کو رجسٹر کرنے ، اندراج کرنے اور مطلع کرنے کے طریقے مہیا کرتا ہے۔جب نوٹیفائی_بسورز کو بلایا جاتا ہے تو ، یہ مبصرین کی فہرست پر اعادہ کرتا ہے اور ان کے اپ ڈیٹ کے طریقہ کار کو کال کرتا ہے ، جس سے اعداد و شمار کو پیرامیٹر کے طور پر منتقل کیا جاتا ہے۔ آبزرور کلاس ایک خلاصہ بیس کلاس ہے جو مبصرین کے لئے انٹرفیس کی وضاحت کرتا ہے۔اس مثال میں ، اس میں ایک واحد طریقہ اپ ڈیٹ ہے جس کا مقصد کنکریٹ آبزرور کے نفاذ کے ذریعہ اوورراڈ ہونا ہے۔ کنکریٹ اویسرور کلاس آبزرور کلاس کا ٹھوس نفاذ ہے۔جب اپ ڈیٹ موصول ہوتا ہے تو یہ مخصوص سلوک کی وضاحت کرنے کے لئے اپ ڈیٹ کے طریقہ کار کو اوور رائڈ کرتا ہے۔اس مثال میں ، یہ موصولہ ڈیٹا کو آسانی سے پرنٹ کرتا ہے۔ مثال کے طور پر استعمال میں ، ہم ایک مضمون مثال اور دو کنکریٹ اویسرور مثال تیار کرتے ہیں۔مبصرین رجسٹر_بسرور طریقہ استعمال کرکے اس مضمون کے ساتھ رجسٹرڈ ہیں۔اس کے بعد ، ہم کچھ ڈیٹا پاس کرتے ہوئے ، اس موضوع پر نوٹیفائی_بسورز کو کال کرتے ہیں۔اس سے ہر رجسٹرڈ مبصر کی تازہ کاری کے طریقہ کار کو متحرک کیا جاتا ہے ، اور وہ موصولہ ڈیٹا پرنٹ کرتے ہیں۔جب نوٹیفائی_بسورز کو دوبارہ بلایا جاتا ہے تو ، غیر رجسٹرڈ مبصرین کو مطلع نہیں کیا جاتا ہے۔ یہ مثال ظاہر کرتی ہے کہ کس طرح مبصرین کا نمونہ اس موضوع اور مبصرین کے مابین ڈھیلے جوڑے کو قابل بناتا ہے ، جس سے متعدد مبصرین کو مخصوص مبصرین کے بارے میں آگاہ ہونے کے بغیر موضوع میں تبدیلیوں پر رد عمل ظاہر کرنے کی اجازت ملتی ہے۔"
    },
    {
        "Question": "ازگر میں کچرے کے جمع کرنے کے تصور کی وضاحت کریں اور میموری کے انتظام کے لئے استعمال ہونے والی مختلف حکمت عملیوں کی وضاحت کریں۔",
        "Answer": "ازگر میں ، دونوں تجریدی کلاس اور انٹرفیس معاہدوں کی وضاحت کرنے اور کلاسوں میں کچھ طرز عمل کو نافذ کرنے کے طریقہ کار کے طور پر کام کرتے ہیں۔تاہم ، ان کے استعمال اور صلاحیتوں میں کچھ اختلافات ہیں۔آئیے ایک تجریدی کلاس کے استعمال کے فوائد اور خرابیوں اور ازگر میں انٹرفیس پر تبادلہ خیال کرتے ہیں: خلاصہ کلاسوں کے فوائد: کوڈ دوبارہ استعمال: خلاصہ کلاس طریقوں کے لئے پہلے سے طے شدہ نفاذ فراہم کرسکتی ہے ، جس سے اخذ کردہ کلاسوں کو اس کوڈ کا وارث اور دوبارہ استعمال کرنے کی اجازت مل سکتی ہے۔اس سے کوڈ کے دوبارہ استعمال کو فروغ ملتا ہے اور فالتو پن کو کم کیا جاتا ہے۔ جزوی عمل درآمد: خلاصہ کلاسز خلاصہ طریقوں کی وضاحت کرسکتے ہیں جن کو اخذ کردہ کلاسوں کے ذریعہ نافذ کرنا ضروری ہے۔اس سے تجریدی طبقے کو جزوی عمل درآمد فراہم کرنے کی اجازت ملتی ہے جبکہ مخصوص تفصیلات اخذ کردہ کلاسوں کو چھوڑ دیتے ہیں۔ تعی.خلاصہ کلاس خود۔یہ ایک خرابی ہوسکتی ہے اگر کسی کلاس کو اپنی ضروریات کو پورا کرنے کے لئے متعدد تجریدی کلاسوں سے وارث ہونے کی ضرورت ہو۔ذیلی طبقات خلاصہ طبقے کے نفاذ کے لئے مضبوطی سے پابند ہیں ، جس سے ضرورت پڑنے پر مختلف بیس کلاس میں تبدیل ہونا زیادہ مشکل ہوتا ہے۔ انٹرفیس کے قابل عمل: ایک سے زیادہ وراثت: متعدد کلاسوں کے ذریعہ انٹرفیس کو نافذ کیا جاسکتا ہے ، جس سے کلاس درجہ بندی میں زیادہ سے زیادہ لچک پیدا ہوتی ہے۔ایک کلاس متعدد انٹرفیس کو نافذ کرسکتی ہے ، جس سے اسے مختلف معاہدوں کو پورا کرنے اور متعدد طرز عمل پر عمل کرنے کے قابل بناتا ہے۔ لوز جوڑے: انٹرفیس کلاسوں کے مابین ڈھیلے جوڑے کو فروغ دیتے ہیں۔صرف انٹرفیس کی تعریف پر انحصار کرتے ہوئے ، کلاسز ایک دوسرے کے ساتھ مخصوص عمل درآمد کی تفصیلات جاننے کی ضرورت کے بغیر بات چیت کرسکتی ہیں۔ معاہدہ انفورسمنٹ: انٹرفیس ایک واضح معاہدے کی وضاحت کرتے ہیں جس کی کلاسوں پر عمل کرنا چاہئے۔اس سے یہ یقینی بنانے میں مدد ملتی ہے کہ ضروری طریقوں اور طرز عمل کو مختلف کلاسوں میں مستقل طور پر نافذ کیا جاتا ہے۔ انٹرفیس کے ڈرا بیکس: پہلے سے طے شدہ عمل درآمد کی کمی: خلاصہ کلاسوں کے برعکس ، ازگر میں انٹرفیس طریقوں کے لئے پہلے سے طے شدہ عمل درآمد نہیں کرتے ہیں۔کلاسوں کو نافذ کرنے میں انٹرفیس کے ذریعہ بیان کردہ تمام طریقوں کی وضاحت کرنی ہوگی ، یہاں تک کہ اگر ان میں بھی اسی طرح کی فعالیت ہے۔ کوئی کوڈ دوبارہ پریوستیت نہیں: چونکہ انٹرفیس صرف کسی پہلے سے طے شدہ نفاذ کے بغیر طریقہ کار کے دستخطوں کی وضاحت کرتے ہیں ، لہذا اس کوڈ کو نافذ کرنے والے کلاسوں کے مابین دوبارہ استعمال نہیں کیا جاسکتا۔اس سے کوڈ کی نقل پیدا ہوسکتی ہے اگر اسی طرح کے طرز عمل کو متعدد کلاسوں میں نافذ کرنے کی ضرورت ہو۔ خلاصہ میں ، ازگر میں خلاصہ کلاس زیادہ لچک ، کوڈ دوبارہ پریوست اور جزوی عمل درآمد کی صلاحیتوں کو فراہم کرتے ہیں۔دوسری طرف ، انٹرفیس ڈھیلے جوڑے ، متعدد وراثت اور معاہدے کے نفاذ کو فروغ دیتے ہیں۔خلاصہ کلاس یا انٹرفیس کے استعمال کے درمیان انتخاب اس منصوبے کی مخصوص ضروریات اور ڈیزائن کے تحفظات پر منحصر ہے۔"
    },
    {
        "Question": "ایک لاحقہ درخت کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور موثر تزئین کی تلاش کے لئے طریقے فراہم کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا ایک مثال ہے جو ایک کم سے کم کی قطار کی نمائندگی کرتا ہے جس میں ایک کم سے کم کی قطار کی نمائندگی ہوتی ہے: پائیٹون کوپی کوڈکلاس ترجیحی کیو: ڈیف __init __ (خود): سیلف۔ ہیپ = [] Def is_empty (خود)ڈیف داخل کریں (خود ، آئٹم): سیلف۔ ہیپ.ایپینڈ (آئٹم) سیلف۔. \") اگر لین (self.heap) == 1: واپس لوٹائیں۔اعلی ترین_پریویٹی ڈیف جھانکنے (خود) کو واپس کریں: اگر سیلف۔ آئی ایس_پٹی (): انڈیکس ایرر (\"ترجیحی قطار خالی ہے۔\") خود واپس کریں۔2 جبکہ اشاریہ> 0 اور سیلف۔ ہیپ [انڈیکس] <سیلف۔ ہیپ [والدین]: خودوالدین = (انڈیکس - 1) // 2 ڈیف _ ڈاون_ہیپائف (سیلف ، انڈیکس): بچہ = 2 * انڈیکس + 1 جبکہ بچہ <لین (سیلف۔ ہیپ): اگر بچہ + 1 <لین (سیلف۔ ہیپ) اور سیلف۔ ہیپ۔ہیپ [چائلڈ] ، سیلف۔ ہیپ [انڈیکس] انڈیکس = چائلڈ چائلڈ = 2 * انڈیکس + 1 اس پر عمل درآمد میں ، ترجیحی طبقے کی کلاس کم سے کم کی نمائندگی کرنے کے لئے ایک فہرست (سیلف۔ ایچ ای اے پی) استعمال کرتی ہے۔ڈھیر میں موجود عناصر کو ان کی ترجیح کی بنیاد پر حکم دیا جاتا ہے۔ آئی ایس_پٹی طریقہ چیک کرتا ہے کہ آیا ڈھیر کی لمبائی کی جانچ کرکے ترجیحی قطار خالی ہے یا نہیں۔ داخل کرنے کا طریقہ ڈھیر میں کسی شے کو شامل کرتا ہے۔یہ آئٹم کو ڈھیر کے آخر میں شامل کرتا ہے اور پھر اس چیز کو اپنے والدین کے ساتھ تبدیل کرکے کم سے کم پراپرٹی کو بحال کرنے کے لئے \"اپ ہیپائف\" آپریشن انجام دیتا ہے۔ حذف کرنے کا طریقہ ترجیح سے اعلی ترجیحی آئٹم کو ہٹاتا ہے اور واپس کرتا ہے۔قطار.یہ ڈھیر کی جڑ کو آخری آئٹم کے ساتھ بدل دیتا ہے اور پھر اس کے سب سے چھوٹے بچے کے ساتھ اس چیز کو تبدیل کرکے کم سے کم پراپرٹی کو بحال کرنے کے لئے \"ڈاون ہیپائف\" آپریشن انجام دیتا ہے۔ جھانکنے کا طریقہ ترجیح سے اعلی ترجیحی آئٹم کو لوٹاتا ہے۔اسے ہٹائے بغیر قطار۔یہ آسانی سے ڈھیر کی جڑ کو لوٹاتا ہے۔ _up_heapify طریقہ ایک مددگار طریقہ ہے جو اپ ہیپیفائی آپریشن انجام دیتا ہے۔یہ دیئے گئے انڈیکس میں آئٹم کو اپنے والدین سے موازنہ کرتا ہے اور کم سے کم پراپرٹی کو برقرار رکھنے کے لئے اگر ضروری ہو تو ان کو تبدیل کرتا ہے۔یہ اس عمل کو اس وقت تک جاری رکھے گا جب تک کہ شے اپنی صحیح پوزیشن میں نہ ہو یا ڈھیر کی جڑ تک پہنچ جائے۔ _ ڈاون_ہیپائیفائ طریقہ ایک اور مددگار طریقہ ہے جو ڈاون ہیپائف آپریشن انجام دیتا ہے۔یہ دیئے گئے انڈیکس میں اس شے کا موازنہ اپنے بچوں کے ساتھ کرتا ہے اور کم سے کم پراپرٹی کو برقرار رکھنے کے لئے ضروری ہو تو اسے چھوٹے چھوٹے بچے کے ساتھ تبدیل کرتا ہے۔اس عمل کو اس وقت تک جاری رکھا جاتا ہے جب تک کہ شے اپنی صحیح پوزیشن میں نہ ہو یا کسی پتی کے نوڈ تک نہ پہنچے۔ نوٹ کریں کہ اس عمل سے یہ فرض کیا گیا ہے کہ ترجیحی قطار میں داخل ہونے والے عناصر کا موازنہ کیا جاسکتا ہے (یعنی ، وہ <آپریٹر کو نافذ کرتے ہیں)۔"
    },
    {
        "Question": "\"ازگر میں رد عمل پروگرامنگ اور رد عمل کی توسیع (RX) کے اصولوں پر تبادلہ خیال کریں ، اور یہ بتائیں کہ وہ واقعہ سے چلنے والے نظام کو کس طرح آسان بناتے ہیں۔\"",
        "Answer": "ڈیکوریٹر پیٹرن ازگر میں ایک ساختی ڈیزائن کا نمونہ ہے جو آپ کو کسی شے میں ایک یا زیادہ ڈیکوریٹر اشیاء میں لپیٹ کر متحرک طور پر اضافی طرز عمل یا ذمہ داریوں کو شامل کرنے کی اجازت دیتا ہے۔یہ نمونہ \"وراثت سے زیادہ مرکب\" کے اصول کی پیروی کرتا ہے اور کوڈ میں لچک اور توسیع کو فروغ دیتا ہے۔ ڈیکوریٹر پیٹرن میں ، ایک بیس آبجیکٹ موجود ہے جسے اضافی فعالیت کے ساتھ بڑھانے کی ضرورت ہے۔بیس آبجیکٹ میں براہ راست ترمیم کرنے کے بجائے ، سجاوٹ کو بیس آبجیکٹ کو لپیٹنے اور مطلوبہ اضافہ فراہم کرنے کے لئے استعمال کیا جاتا ہے۔ہر ڈیکوریٹر ایک مخصوص طرز عمل کا اضافہ کرتا ہے جبکہ اب بھی بیس آبجیکٹ کے انٹرفیس کو برقرار رکھتے ہیں۔ڈیکوریٹرز کو سجاوٹ یا ایک ساتھ ملایا جاسکتا ہے ، جس سے فعالیت کی متعدد پرتوں کو شامل کیا جاسکتا ہے۔ یہاں ایک ایسی مثال ہے جو ازگر میں ڈیکوریٹر پیٹرن کے استعمال کو ظاہر کرتی ہے: پائیتھون کوپی کوڈکلاس اجزا(خود): واپسی \"کنکریٹکمپینٹ: آپریشن\" کلاس ڈیکوریٹر (اجزاء): ڈیف __init __ (خود ، جزو): سیلف ڈاٹ کامیونٹ = جزو ڈیف آپریشن (خود)آپریشن () return f \"concretedecoratora: {self.compointer.operation ()}\" کلاس کنکریٹڈیکورٹرب (ڈیکوریٹر): ڈیف آپریشن (خود): واپسی f \"concretedecoratorb: {self.compointer.operation ()}\"# استعمال کی مثال: اجزاء = کانکریٹکومیپینٹ () ڈیکوریٹر 1 = کنکریٹڈیکورٹا (جزو) ڈیکوریٹر 2 = کنکریٹڈیکورٹر بی (ڈیکوریٹر 1) پرنٹ (ڈیکوریٹر 2۔آپریشن ()) اس مثال میں ، ہمارے پاس ایک جزو انٹرفیس ہے جو تمام اجزاء کے لئے مشترکہ انٹرفیس کی وضاحت کرتا ہے۔کنکریٹکمپینٹ کلاس جزو انٹرفیس کو نافذ کرتا ہے اور بیس آبجیکٹ کی نمائندگی کرتا ہے جسے ہم بڑھانا چاہتے ہیں۔ ڈیکوریٹر کلاس تمام سجاوٹ کے لئے بیس کلاس ہے۔یہ جزو انٹرفیس کو بھی نافذ کرتا ہے اور لپیٹے ہوئے جزو کا حوالہ برقرار رکھتا ہے۔ڈیکوریٹر کلاس کا آپریشن طریقہ آسانی سے کال کو لپیٹے ہوئے اجزاء پر بھیجتا ہے۔ کنکریٹڈیکورٹرا اور کنکریٹڈیکورٹر بی کلاسز کنکریٹ سجاوٹ ہیں۔وہ ڈیکوریٹر کلاس سے وارث ہوتے ہیں اور لپیٹے ہوئے جزو میں مخصوص فعالیت شامل کرتے ہیں۔ہر ڈیکوریٹر آپریشن کے طریقہ کار کو اوور رائڈ کرتا ہے ، پہلے لپیٹے ہوئے جزو کے آپریشن کے طریقہ کار کو کال کرتا ہے اور پھر اس کے اپنے طرز عمل کو شامل کرتا ہے۔ استعمال کی مثال میں ، ہم کنکریٹکمپمنٹ کلاس کی ایک مثال بناتے ہیں۔اس کے بعد ، ہم اسے کنکریٹڈیکورٹرا اور کنکریٹڈیکورٹر بی آرکائرز سے لپیٹتے ہیں۔جب ہم ڈیکوریٹر 2 آبجیکٹ پر آپریشن کے طریقہ کار کو کال کرتے ہیں تو ، یہ اندرونی ڈیکوریٹر سے شروع کرتے ہوئے اور باہر کی طرف پھیلتے ہوئے ، سجاوٹ کے ذریعہ کال چین کو متحرک کرتا ہے۔ہر ڈیکوریٹر اگلے سجاوٹ یا بیس جزو میں جانے سے پہلے آپریشن میں اپنے مخصوص سلوک کو شامل کرتا ہے۔آخر میں ، ہمیں مطلوبہ نتیجہ تمام اضافی افادیت کے ساتھ ملتا ہے۔ ڈیکوریٹر پیٹرن ہمیں مستحکم وراثت پر بھروسہ کرنے کے بجائے سجاوٹ کے ساتھ اشیاء کو لپیٹ کر رن ٹائم کے وقت متحرک طور پر طرز عمل کو شامل کرنے یا اس میں ترمیم کرنے کی اجازت دیتا ہے۔اس سے کوڈ کی لچک ، دوبارہ پریوستیت ، اور ضرورت کے مطابق فنکشنلٹی کو اختلاط اور میچ کرنے کی صلاحیت کو فروغ ملتا ہے۔"
    },
    {
        "Question": "ڈیٹا بیس میں ہم آہنگی کے کنٹرول کے تصور کی وضاحت کریں اور الگ تھلگ سطح اور ان کے تجارتی تعلقات پر تبادلہ خیال کریں۔",
        "Answer": "ازگر میں ، فنکشن اوورلوڈنگ سے مراد ایک ہی نام کے ساتھ متعدد افعال کی وضاحت کرنے کی صلاحیت ہے لیکن مختلف پیرامیٹرز یا دلیل کی اقسام۔یہ کسی فنکشن کو اس کی تعداد ، آرڈر ، یا دلائل کی اقسام کی بنیاد پر مختلف آپریشن انجام دینے کی اجازت دیتا ہے۔ جاوا یا سی ++ جیسے دیگر پروگرامنگ زبانوں میں ، فنکشن اوورلوڈنگ ایک زبان کی خصوصیت ہے جو ایک ہی نام کے ساتھ متعدد افعال کی وضاحت کرنے کی اجازت دیتی ہے لیکن مختلف پیرامیٹر کی وضاحت کرتی ہے۔فہرستیں۔مرتب یا رن ٹائم سسٹم طے کرتا ہے کہ کال سائٹ پر فراہم کردہ دلائل کی بنیاد پر کون سا فنکشن کال کرنا ہے۔اس خصوصیت کو اکثر \"جامد\" یا \"مرتب وقت\" فنکشن اوورلوڈنگ کہا جاتا ہے۔ تاہم ، ازگر میں ، فنکشن اوورلوڈنگ زبان کی متحرک ٹائپنگ اور بتھ ٹائپنگ نوعیت کی وجہ سے مختلف طریقے سے کام کرتا ہے۔ازگر حقیقی جامد فنکشن اوورلوڈنگ جیسے جاوا یا سی ++ کی حمایت نہیں کرتا ہے۔اس کے بجائے ، ازگر کسی خاص نام کے ساتھ صرف ایک بار ایک فنکشن کی تعریف کرنے کی اجازت دیتا ہے ، اور اسی نام کے ساتھ فنکشن کی تعریفیں صرف پچھلی تعریف کو تبدیل کریں۔تازہ ترین تعریف فنکشن کا موثر نفاذ بن جاتی ہے۔ ازگر میں اوورلوڈنگ جیسے طرز عمل کو حاصل کرنے کے لئے ، ڈویلپرز عام طور پر پہلے سے طے شدہ دلیل کی اقدار ، متغیر لمبائی کی دلیل کی فہرستوں (*آرگس ، ** کوورگس) ، اور اس کے اندر مشروط منطق کا مجموعہ استعمال کرتے ہیں۔فراہم کردہ دلائل کی بنیاد پر مختلف معاملات کو سنبھالنے کے لئے فنکشن۔ یہاں ازگر میں فنکشن اوورلوڈنگ کی وضاحت کرنے کی ایک مثال: پائیتھون کوپی کوڈیڈف کیلکولیٹ_اریہ (لمبائی ، چوڑائی = کوئی نہیں): اگر چوڑائی کوئی نہیں ہے: # مربع واپسی کی لمبائی کا حساب کتاب: #مستطیل واپسی کی لمبائی کے علاقے کا حساب لگائیں * چوڑائی اس مثال کے طور پر ، ہمارے پاس ایک فنکشن کا حساب کتاب ہے جو شکل کے رقبے کا حساب لگاتا ہے۔اس کی وضاحت ایک ہی پیرامیٹر کی لمبائی اور اختیاری پیرامیٹر کی چوڑائی کے ساتھ کی گئی ہے۔اگر چوڑائی فراہم نہیں کی گئی ہے (یعنی یہ کوئی بھی نہیں ہے) ، تو فنکشن یہ فرض کرتا ہے کہ شکل ایک مربع ہے اور اسی کے مطابق اس کے علاقے کا حساب لگاتی ہے۔بصورت دیگر ، اگر چوڑائی فراہم کی جاتی ہے تو ، فنکشن یہ فرض کرتا ہے کہ شکل ایک مستطیل ہے اور لمبائی اور چوڑائی کی بنیاد پر اس کے علاقے کا حساب لگاتی ہے۔ ہم مطلوبہ سلوک کو حاصل کرنے کے لئے مختلف دلیل کے امتزاج کے ساتھ حساب کتاب_یریا فنکشن کو کال کرسکتے ہیں: پائیٹون کوپی کوڈ پرنٹ (حساب کتاب_اریہ (5)) # آؤٹ پٹ: 25 (ایک مربع کا رقبہ) پرنٹ (حساب کتاب_اریہ (5 ، 3)) # آؤٹ پٹ: 15 (مستطیل کا رقبہ) اس طرح سے ، فنکشن کا حساب کتاب_یریا مختلف معاملات کو ہینڈل کرتا ہے جو منظور شدہ دلائل کی تعداد کی بنیاد پر ہوتا ہے اور فراہم کرتا ہےمناسب سلوک۔ خلاصہ کرنے کے لئے ، جبکہ حقیقی جامد فنکشن اوورلوڈنگ ازگر میں دستیاب نہیں ہے ، آپ فنکشن کے اندر ڈیفالٹ دلیل کی اقدار اور مشروط منطق کا استعمال کرکے اسی طرح کی فعالیت حاصل کرسکتے ہیں۔اوورلوڈنگ کے فنکشن کے لئے ازگر کا نقطہ نظر مستحکم قسم کی زبانوں سے مختلف ہے ، لیکن یہ اب بھی فراہم کردہ دلائل کی بنیاد پر لچکدار اور متحرک طرز عمل کی اجازت دیتا ہے۔"
    },
    {
        "Question": "\"ایک ازگر کلاس کو نافذ کریں جس میں خود توازن بائنری تلاش کے درخت کی نمائندگی کی جائے ، جیسے اے وی ایل کا درخت یا سرخ رنگ کا درخت۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا ایک مثال عمل ہے جس میں ہدایت شدہ وزن والے گراف کی نمائندگی ہوتی ہے اور دجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے ایک طریقہ فراہم کرنا: پائیتھونکپی کوڈیمپورٹ ہیپکفورم کلیکشنز درآمد ڈیفالٹ ڈکٹ کلاس گراف: ڈیف __ (خود): سیلف __ (خود)= ڈیفالٹ ڈکٹ (فہرست) سیلف۔ وائٹس = {} ڈیف ایڈ_ورٹیکس (سیلف ، ورٹیکس): سیلف.ورٹیسس۔ ایڈڈ (ورٹیکس) ڈیف ایڈ_ج (سیلف ، سے_ٹوریکس ، ٹو_ورٹیکس ، وزن): سیلف ڈاٹ ای ڈی ایس [منجانب_ٹری ایکس]self.weights [(from_vertex ، to_vertex)] = وزن Def dijkstra (خود ، start_vertex): فاصلوں = {v: فلوٹ ('inf') v کے لئے۔start_vertex)) جبکہ ترجیحی_دق: موجودہ_ڈیسٹینس ، کرنٹ_ورٹیکس = ہیپ کیو.اپپپ (ترجیحی_کیو) اگر موجودہ_ڈسٹنس> فاصلوں [موجودہ_ورٹیکس]: خود پڑوسی میں پڑوسی کے لئے جاری رکھیں۔+ وزن اگر فاصلہ <فاصلوں [پڑوسی]: فاصلوں [پڑوسی] = فاصلہ ہیپ کیو۔ ہیپش (ترجیحی_کیو ، (فاصلہ ، پڑوسی)) واپسی فاصلوں کی واپسی مختصر ترین_پاتھ (سیلف ، اسٹارٹ_ورٹیکس ، اینڈ_ورٹیکس): فاصلوں = سیلف۔ ڈجکسٹرا (اسٹارٹ_ورٹیکس) راستہ =[] کرنٹ_ورٹیکس = اینڈورٹیکس جبکہ کرنٹ_ورٹیکس! = اسٹارٹ_ٹوریکس: پاتھ.سرٹ (0 ، کرنٹ_ٹیکس) خود میں پڑوسی کے لئے۔ [موجودہ_ورٹیکس]: اگر فاصلوں [کرنٹ_ورٹیکس] == فاصلوں [پڑوسی] + سیل۔]: کرنٹ_ورٹیکس = پڑوسی بریک پاتھ۔ INSERT (0 ، اسٹارٹ_ورٹیکس) واپسی کا راستہ# استعمال کی مثال: گراف = گراف () گراف.اڈڈ_ورٹیکس ('اے') گراف.ایڈ_ٹیکس ('بی') گراف.اڈی_ٹٹیکس ('سی') گراف.add_vertex ('d') گراف.ایڈ_ٹٹیکس ('ای') گراف.اڈی_ج ('a' ، 'b' ، 5) گراف.اڈی_ج ('a' ، 'c' ، 3) گراف.اڈی_ج ('بی'..add_edge ('d' ، 'e' ، 2) مختصر ترین_پاتھ = گراف.شورٹیسٹ_پاتھ ('a' ، 'e') پرنٹ (مختصر ترین_پاتھ) # آؤٹ پٹ: ['a' ، 'c' ، 'd' ، 'E'] اس نفاذ میں ، گراف کلاس ہدایت شدہ وزن والے گراف کی نمائندگی کرتا ہے۔اس میں عمودی کا ایک سیٹ ، کناروں کی لغت ، اور وزن کی لغت ہے۔add_vertex کے طریقہ کار کا استعمال کرتے ہوئے عمودی کو شامل کیا جاتا ہے ، اور ان کے متعلقہ وزن والے کناروں کو add_edge کے طریقہ کار کا استعمال کرتے ہوئے شامل کیا جاتا ہے۔ ڈجکسٹرا کا طریقہ گراف میں دیئے گئے اسٹارٹ ورٹیکس سے مختصر ترین راستے تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرتا ہے۔یہ ان کے موجودہ فاصلوں کی بنیاد پر عمودی کی ترجیحی قطار برقرار رکھتا ہے۔یہ کم سے کم فاصلے کے ساتھ تکرار کے طور پر عمودی کا انتخاب کرتا ہے ، اگر کوئی چھوٹا راستہ مل جاتا ہے تو اپنے پڑوسیوں کے فاصلوں کو اپ ڈیٹ کرتا ہے ، اور اس وقت تک جاری رہتا ہے جب تک کہ تمام عمودی عمل پر کارروائی نہ ہو۔ مختصر ترین_پاتھ کا طریقہ ایک دیئے گئے آغاز اور اختتام کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے طریقہ کار کو استعمال کرتا ہے۔ورٹیکس۔یہ اختتام کے اوپر سے اسٹارٹ ورٹیکس تک بیک ٹریک کرتا ہے ، جس کے بعد دجکسٹرا کے الگورتھم کے دوران ریکارڈ کیے گئے کم سے کم فاصلوں کے ساتھ کناروں کے بعد۔ استعمال کی مثال کے طور پر ، ایک گراف آبجیکٹ تیار کیا جاتا ہے ، عمودی طور پر 'ای کے ذریعے' ای 'شامل کیا جاتا ہے ، اور ان کے ساتھ کناروںمتعلقہ وزن شامل کیا جاتا ہے۔مختصر ترین_پاتھ کے طریقہ کار کو 'A' کے ساتھ اسٹارٹ ورٹیکس کے طور پر اور 'E' کو اختتامی حد کے طور پر کہا جاتا ہے۔"
    },
    {
        "Question": "\"فلاسک-دی یا پیینجیکٹ جیسے ازگر میں کنٹرول (IOC) کنٹینرز اور انحصار انجیکشن (DI) فریم ورک کے الٹا کے تصور کی وضاحت کریں۔\"",
        "Answer": "ازگر میں ہم آہنگی سے مراد متعدد کاموں یا عمل کو بیک وقت انجام دینے کی صلاحیت ہے۔یہ کسی پروگرام کے مختلف حصوں کو آزادانہ طور پر چلانے اور بیک وقت پیشرفت کرنے کی اجازت دیتا ہے ، جس کی وجہ سے کارکردگی اور ردعمل میں اضافہ ہوتا ہے۔ پیتھون ہم آہنگی کے حصول کے لئے متعدد میکانزم مہیا کرتا ہے ، جس میں دھاگے اور عمل شامل ہیں۔ تھریڈز: دھاگے کسی عمل کے اندر عمل درآمد کے ہلکے وزن والے اکائی ہیں۔وہ ایک ہی میموری کی جگہ کا اشتراک کرتے ہیں ، جس سے وہ مشترکہ اعداد و شمار کو آسانی سے بات چیت اور رسائی حاصل کرسکتے ہیں۔ازگر کا تھریڈنگ ماڈیول تھریڈز کے ساتھ کام کرنے کے لئے ایک اعلی سطحی انٹرفیس مہیا کرتا ہے۔ یہاں کی ایک مثال جو ہم آہنگی پر عملدرآمد کے لئے دھاگوں کے استعمال کو ظاہر کرتی ہے: پائیٹون کوپی کوڈیمپورٹ تھریڈنگ ڈیف ٹاسک 1 (): I IN RAND (5): پرنٹ (\"ٹاسک 1:\" ، ،i) ڈیف ٹاسک 2 (): رینج (5) میں کے لئے: پرنٹ (\"ٹاسک 2:\" ، i)# تھریڈ آبجیکٹ اسٹریڈ 1 = تھریڈنگ بنائیں۔ تھریڈ (ہدف = ٹاسک 1) تھریڈ 2 = تھریڈنگ۔ تھریڈنگ۔ تھریڈ (ہدف = ٹاسک 2)# اسٹارٹتھریڈ اسٹریڈ 1. اسٹارٹ () تھریڈ 2. اسٹارٹ ()# تھریڈز کو ختم کرنے کا انتظار کریں۔تھریڈنگ۔ تھریڈ کلاس تھریڈ آبجیکٹ بنانے کے لئے استعمال کی جاتی ہے ، جس میں ہر تھریڈ کے لئے ہدف کی تقریب کی وضاحت ہوتی ہے۔دھاگوں کو شروع کے طریقہ کار کے ساتھ شروع کیا گیا ہے ، اور جوائن کے طریقہ کار کو دھاگوں کے مکمل ہونے کا انتظار کرنے کے لئے کہا جاتا ہے۔ اس کوڈ کو چھاننا دونوں کاموں کو بیک وقت انجام دے گا ، اور ان کی آؤٹ پٹ انٹرلیویڈ ہوسکتی ہے۔میموری کی علیحدہ جگہوں میں۔ہر عمل کے اپنے وسائل ہوتے ہیں ، بشمول میموری ، فائل ہینڈلز ، اور بہت کچھ۔ازگر کا ملٹی پروسیسنگ ماڈیول عمل کے ساتھ کام کرنے کے لئے ایک اعلی سطحی انٹرفیس مہیا کرتا ہے۔ یہاں ایک ایسی مثال ہے جو ہم آہنگی پر عملدرآمد کے عمل کے استعمال کو ظاہر کرتی ہے: پائیتھون کوپی کوڈیمپورٹ ملٹی پروسیسنگ ڈیف ٹاسک 1 (): I میں (5) کے لئے: پرنٹ (\"ٹاسک 1:\" ، ، \"ٹاسک 1:\" ،i) ڈیف ٹاسک 2 (): رینج (5) کے لئے: پرنٹ (\"ٹاسک 2:\" ، i)# عمل آبجیکٹ پروسیس 1 = ملٹی پروسیسنگ۔ پروسیس (ہدف = ٹاسک 1) پروسیس 2 = ملٹی پروسیسنگ.پروسیس (ہدف = ٹاسک 2)# شروع کریںپروسیس پروسیس 1. اسٹارٹ () پروسیس 2. اسٹارٹ ()# اس عمل کو ختم کرنے کے عمل کا انتظار کریں۔ملٹی پروسیسنگ۔ پروسیس کلاس پروسیس آبجیکٹ بنانے کے لئے استعمال کیا جاتا ہے ، ہر عمل کے لئے ہدف کی تقریب کی وضاحت کرتے ہوئے۔عمل کو شروع کرنے کے طریقہ کار سے شروع کیا گیا ہے ، اور عمل کو مکمل ہونے کے لئے انتظار کرنے کے لئے جوائن کے طریقہ کار کو بلایا جاتا ہے۔ اس کوڈ کو چھاننا دونوں کاموں کو بیک وقت ، تھریڈز کی طرح ہی انجام دے گا ، لیکن ہر کام کی اپنی الگ الگ میموری کی جگہ ہوگی۔عمل ازگر میں ہم آہنگی فراہم کرتے ہیں ، لیکن اس پر غور کرنے کے لئے کچھ اختلافات موجود ہیں: دھاگے ایک ہی میموری کی جگہ کا اشتراک کرتے ہیں ، جس سے آسانی سے مواصلات اور مشترکہ اعداد و شمار تک رسائی حاصل ہوتی ہے ، لیکن وہ ازگر میں نسل کے حالات اور عالمی ترجمان لاک (جی آئی ایل) جیسے معاملات کے تابع ہوسکتے ہیں۔، جو تھریڈز پر حقیقی متوازی عمل درآمد کو محدود کرتا ہے۔جب آپ کے اطلاق کی مخصوص ضروریات ازگر میں ہم آہنگی کے ل threads دھاگوں اور عمل کے مابین انتخاب کرتے ہیں۔"
    },
    {
        "Question": "\"ازگر میں ڈیٹا سیریلائزیشن اور ڈیسیریلائزیشن کے اصولوں پر تبادلہ خیال کریں ، اور JSON ، XML ، اور پروٹوکول بفر جیسے مختلف فارمیٹس کا موازنہ کریں۔\"",
        "Answer": "ریاستی نمونہ ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو کسی شے کو اس کے طرز عمل کو تبدیل کرنے کی اجازت دیتا ہے جب اس کی داخلی حالت بدل جاتی ہے۔یہ کسی شے کو ظاہر کرنے کے قابل بناتا ہے گویا کہ وہ مختلف ریاستوں کو الگ الگ طبقوں میں گھیرنے اور موجودہ ریاستی آبجیکٹ میں طرز عمل کو تفویض کرکے رن ٹائم کے وقت اپنی کلاس کو تبدیل کرتا ہے۔ جب کسی شے کا طرز عمل اس کی داخلی حالت کی بنیاد پر مختلف ہوتا ہے تو ریاست کا نمونہ مفید ہے ، اور ایسا ہوتا ہے۔بڑے مشروط بیانات یا سوئچ کیسز کا سہارا لئے بغیر متحرک طور پر اپنے طرز عمل کو تبدیل کرنے کی ضرورت ہے۔اس سے شے اور اس کی ریاستوں کے مابین ڈھیلے جوڑے کو فروغ ملتا ہے ، اور ہر ریاست اپنے طرز عمل کو زیادہ ماڈیولر اور برقرار رکھنے کے قابل بنا سکتی ہے۔ یہاں ازگر میں ریاستی پیٹرن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس آرڈسٹیٹ: ڈیف شپ (خود ، آرڈر): پاس ڈیف کینسل (خود ، آرڈر): پاسکلاس نیورڈر اسٹیٹ (آرڈرسٹیٹ): ڈیف شپ (خود ، آرڈر): پرنٹ (\"شپنگ آرڈر ...\") آرڈر۔ اسٹیٹ = شپڈر اسٹیٹ () ڈیف منسوخ (خود ، آرڈر): پرنٹ۔\"بھیجے ہوئے آرڈر کو منسوخ نہیں کرسکتا۔\"کلاس آرڈر: Def __init __ (خود): self.state = newordstate () Def جہاز (خود): self.state.شپ (خود) Def منسوخ (خود): self.state.cancel (خود)# استعمال کی مثال: آرڈر =آرڈر () آرڈر.شپ () # آؤٹ پٹ: شپنگ آرڈر ... آرڈر.کانسیل () # آؤٹ پٹ: منسوخ کرنا آرڈر ... آرڈر.شپ () # آؤٹ پٹ: منسوخ شدہ آرڈر نہیں کرسکتے ہیں۔ اس مثال میں ، ہمارے پاس ایک کلاس ہے۔ایک آرڈر کی مختلف ریاستوں کی نمائندگی کرنے والا درجہ بندی۔آرڈسٹیٹ کلاس بیس کلاس ہے جو تمام آرڈر ریاستوں کے انٹرفیس کی وضاحت کرتی ہے۔ہر کنکریٹ اسٹیٹ سبکلاس ، جیسے نیورڈر اسٹیٹ ، شپڈرڈر اسٹیٹ ، اور کیونڈرورڈر اسٹیٹ ، اس ریاست سے وابستہ طرز عمل کو نافذ کرتا ہے۔ آرڈر کلاس ایک آرڈر آبجیکٹ کی نمائندگی کرتا ہے جو اس کی ریاست کو متحرک طور پر تبدیل کرسکتا ہے۔اس میں طریقے جہاز () اور منسوخ () ہیں جو موجودہ ریاست کے شے کے ساتھ سلوک کو تفویض کرتے ہیں۔ جب ابتدائی طور پر کوئی آرڈر تیار کیا جاتا ہے تو ، یہ نیورڈر اسٹیٹ سے شروع ہوتا ہے۔نیورڈر اسٹیٹ میں جہاز () کا طریقہ ریاست کو شپڈر اسٹیٹ میں تبدیل کرتا ہے ، اور منسوخ () طریقہ ریاست کو منسوخ کرنے والے ڈورڈر اسٹیٹ میں بدل دیتا ہے۔ہر ریاست سلوک کو مناسب طریقے سے سنبھالتی ہے اور ضرورت کے مطابق آرڈر آبجیکٹ کی حالت کو تبدیل کرتی ہے۔ استعمال کی مثال کے طور پر ، ہم ایک آرڈر آبجیکٹ بناتے ہیں اور جہاز () کو کال کرتے ہیں اور () طریقوں کو کال کرتے ہیں ، جو موجودہ کی موجودہ حالت کی بنیاد پر طرز عمل کو متحرک کرتے ہیں۔ترتیب.آؤٹ پٹ یہ ظاہر کرتا ہے کہ ریاست کی بنیاد پر طرز عمل متحرک طور پر کس طرح تبدیل ہوتا ہے۔ ریاست کا نمونہ اشیاء کو اندرونی ریاست کی منتقلی کی بنیاد پر اپنے طرز عمل کو تبدیل کرنے کی اجازت دیتا ہے ، لچک ، توسیع ، اور ماڈیولر کوڈ کو فروغ دیتا ہے۔یہ کسی شے کے طرز عمل کو شے سے ہی الگ کرتا ہے ، جس سے شے کے کوڈ میں ترمیم کیے بغیر ریاستوں کو شامل کرنا یا اس میں ترمیم کرنا آسان ہوجاتا ہے۔"
    },
    {
        "Question": "ہدایت شدہ گراف کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور ترجن کے الگورتھم کا استعمال کرتے ہوئے مضبوطی سے منسلک اجزاء تلاش کرنے کے طریقے فراہم کریں۔",
        "Answer": "یقینا!اندراج ، حذف کرنے ، اور تلاش کے طریقوں کے ساتھ ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ٹرائینوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈین = {} سیلف۔(خود): self.root = trienode () Def داخل کریں (خود ، لفظ): موجودہ = self.root لفظ میں چار کے لئے: اگر کرنٹ میں نہیں۔ بچوں میں نہیں: موجودہ۔ بچوں [چار] = ٹرائینوڈ () موجودہ = موجودہ = کرنٹ.کرین [چار] موجودہ۔ is_end_of_word = سچے ڈیف سرچ (خود ، لفظ): موجودہ = سیلف۔ لفظ میں چار کے لئے۔DEF starts_with (خود ، سابقہ): موجودہ = self.root کے لئے سابقہ میں: اگر کرنٹ میں نہیں ہے۔ اگر موجودہ میں نہیں ہے۔ بچوں کو واپس کریں = موجودہ۔، ورڈ ، انڈیکس): اگر اشاریہ == لین (لفظ): اگر نہیں نوڈ۔ is_end_of_word: غلط نوڈ۔ is_end_of_word = غلط ریٹرن لین (نوڈ.کرینین) == 0 چار = ورڈ [انڈیکس] اگر چار نوڈ میں نہیں ہے۔بچے: غلط واپس لوٹیں = _delete (نوڈ.کرز [چار] ، ورڈ ، انڈیکس + 1) اگر ہونا چاہئے: ڈیل نوڈ۔ بچوں [چار] ریٹرن لین (نوڈ.کائلڈین) == 0 غلط _ ڈیلیٹ (سیلف ڈاٹ لوٹ ، لفظ ،، 0)# استعمال کی مثال: ٹری = ٹری () ٹری۔ انرٹ (\"ایپل\") ٹری.سرٹ (\"کیلے\") ٹری.سرٹ (\"کار\") ٹرائی.سرٹ (\"قالین\") پرنٹ (ٹری۔ سرچ (سرچ (\"\"ایپل\")) # آؤٹ پٹ: ٹروپنٹ (ٹری.سرچ (\"کیلے\")) # آؤٹ پٹ: ٹروپنٹ (ٹری.سرچ (\"کار\")) # آؤٹ پٹ: ٹروپنٹ (ٹری۔ سرچ (\"قالین\")) # آؤٹ پٹ:سچ پرنٹ (trie.search (\"CAT\")) # آؤٹ پٹ: غلط پرنٹ (trie.starts_with (\"app\")) # آؤٹ پٹ: ٹری پرنٹ (trie.starts_with (\"ban\")) # آؤٹ پٹ: ٹری پرنٹ (ٹری پرنٹ (\"کار\") # آؤٹ پٹ: ٹروپنٹ (ٹری.ایسٹرٹس_ وِتھ (\" کارپ \")) # آؤٹ پٹ: ٹروپنٹ (ٹری.ایسٹرٹس_ وِتھ (\" ڈاگ \")) # آؤٹ پٹ: فالسیٹرری.ڈیلیٹ (\" کیلے \") پرنٹ (ٹری۔ سرچ (\" کیلے (\"کیلا\"\") # آؤٹ پٹ: اس پر عمل درآمد کو فالس ، ٹرینیوڈ کلاس ٹری میں ایک نوڈ کی نمائندگی کرتا ہے۔اس میں بچوں کے نوڈس کو ذخیرہ کرنے کے لئے لغت کے بچے شامل ہیں ، اور ایک بولین پرچم IS_END_OF_WORD اس بات کی نشاندہی کرنے کے لئے کہ اگر کوئی لفظ اس نوڈ پر ختم ہوتا ہے۔ ٹری کلاس ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں جڑ کا نوڈ ہے اور اندراج ، حذف کرنے ، تلاش ، اور سابقہ ملاپ کے طریقے فراہم کرتا ہے۔داخل کرنے کا طریقہ لفظ کے ہر ایک کردار کے ذریعے تکرار کرتا ہے ، جس سے ضرورت کے مطابق نئے نوڈس پیدا ہوتے ہیں۔تلاش کا طریقہ ٹری کو عبور کرتا ہے ، جانچ پڑتال کرتا ہے کہ آیا ہر کردار موجود ہے اور کسی درست لفظ پر ختم ہوتا ہے۔شروعات کا طریقہ چیک کرتا ہے اگر ٹری میں دیئے گئے ایک سابقہ موجود ہے۔حذف کرنے کا طریقہ ایک بار بار چلنے والا مددگار فنکشن استعمال کرتا ہے _ ٹری سے ایک لفظ حذف کرنے کے لئے ، نوڈس کو ہٹانے کے لئے جس کی ضرورت نہیں ہے۔ استعمال کی مثال میں ، ایک ٹری آبجیکٹ تیار کیا گیا ہے ، اور \"ایپل ،\" \"کیلے ،\" \"کار جیسے الفاظ ، اور الفاظ\"اور\" قالین \"داخل کیا گیا ہے۔تلاش کے طریقہ کار کو یہ چیک کرنے کے لئے کہا جاتا ہے کہ آیا ٹری میں مخصوص الفاظ موجود ہیں یا نہیں۔starts_with طریقہ یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا کچھ سابقہ موجود ہیں یا نہیں"
    },
    {
        "Question": "\"ازگر میں فنکشنل پروگرامنگ کے تصور کی وضاحت کریں اور اعلی آرڈر کے افعال ، لیمبڈا کے تاثرات ، اور نقشہ/کم/فلٹر آپریشنز کی مثالیں فراہم کریں۔\"",
        "Answer": "ازگر میں ، ورچوئل طریقے بیس کلاس میں بیان کردہ طریقے ہیں لیکن اس کا مقصد ذیلی طبقات کے ذریعہ اوورراڈ ہونا ہے۔\"ورچوئل\" کی اصطلاح اس بات کی نشاندہی کرتی ہے کہ رن ٹائم کے وقت اصل آبجیکٹ کی قسم کی بنیاد پر اس طریقہ کار کے نفاذ کا متحرک طور پر طے کیا جاسکتا ہے۔ورچوئل طریقے پولیمورفزم کے حصول کے لئے ایک بنیادی تصور ہیں ، جو مختلف طبقوں کے اشیاء کو ایک دوسرے کے ساتھ بدلے جانے کا علاج کرنے کی اجازت دیتا ہے۔ ازگر میں ، تمام طریقوں کو بطور ڈیفالٹ ورچوئل سمجھا جاتا ہے۔کچھ دوسری زبانوں (جیسے ، C ++) کے برعکس ، ازگر کو ورچوئل کے طور پر کسی طریقہ کار کے واضح اعلان کی ضرورت نہیں ہے۔اس کے بجائے ، بیس کلاس میں بیان کردہ طریقوں کو اخذ کردہ کلاسوں میں زیر کیا جاسکتا ہے ، اور مناسب عمل کو متحرک طور پر حل کیا جاتا ہے جس کی بنیاد پر اصل شے کا استعمال کیا جارہا ہے۔ پولیمورفزم کسی شے کی صلاحیت ہے کہ وہ بہت سی شکلوں یا اقسام کو لے سکے۔اس سے مختلف طبقوں کی اشیاء کو عام بیس کلاس کی اشیاء کے طور پر سلوک کرنے کی اجازت ملتی ہے ، کوڈ کو دوبارہ استعمال ، لچک اور توسیع کے قابل بناتا ہے۔ یہ سمجھنے کے لئے ایک مثال پر غور کریں کہ کس طرح ورچوئل طریقے ازگر میں پولیمورفزم میں شراکت کرتے ہیں: پائیٹون کاپی کوڈکلاس جانوروں: ڈیف اسپیک (خود): نوٹیمپلیمنٹ ڈیرر (\"سبکلاس کو 'بولنے کے طریقہ کار پر عمل درآمد کرنا چاہئے۔\") کلاس ڈاگ (جانور): ڈیف اسپیک (خود): واپس \"ووف!\" کلاس بلی (جانور): ڈیف اسپیک (خود): واپس \"میو!\"کلاس گائے (جانور): ڈیف اسپیک (خود): جانوروں میں جانوروں کے لئے \"مو!\"# پولیومورفک useageamals = [کتے () ، بلی () ، گائے ()] واپس کریں: اس مثال میں پرنٹ (جانوروں کی جگہ ())، ہمارے پاس ایک بیس کلاس جانور ہے جس میں ورچوئل طریقہ ہے ()۔بیس کلاس میں بولنے والا () طریقہ ایک نوٹیملیئرڈیرر کو اٹھاتا ہے کیونکہ اس کا مقصد ذیلی طبقات میں ختم ہونا ہے۔ ذیلی طبقات کتا ، بلی ، اور گائے جانوروں کی کلاس سے وراثت میں ہیں اور اسپیک () کے طریقہ کار پر ان کا اپنا عمل درآمد فراہم کرتے ہیں۔لوپ کے ل we ، ہم جانوروں کی مختلف اشیاء کی ایک فہرست بناتے ہیں ، بشمول کتے ، بلی اور گائے کی مثالیں۔اس کے بعد ہم فہرست پر تکرار کرتے ہیں اور ہر شے پر بولنے () کے طریقہ کار کو کال کرتے ہیں۔اسی طریقہ کار کے نام (بولنے ()) کو استعمال کرنے کے باوجود ، مناسب نفاذ کو متحرک طور پر اصل آبجیکٹ کی قسم کی بنیاد پر حل کیا جاتا ہے۔ کوڈ کی آؤٹ پٹ یہ ہوگی: کاپی کوڈیوف! میو! مو! یہاں ، پولیمورفزم کا مظاہرہ مختلف اشیاء کا علاج کرکے کیا جاتا ہے (عام بیس کلاس جانوروں کی مثال کے طور پر کتا ، بلی ، گائے)۔ہر شے پر بولنے والے () کا طریقہ کار پر زور دیا جاتا ہے ، اور متعلقہ اوورڈڈ نفاذ پر عمل درآمد کیا جاتا ہے ، جس کے نتیجے میں مختلف آوازیں چھاپتی ہیں۔ خلاصہ میں ، ازگر میں ورچوئل طریقوں سے اخذ کردہ کلاسوں میں طریقوں کو زیر کرنے کی اجازت ہوتی ہے ، اور ان کے نفاذ کا تعین متحرک طور پر اس کی بنیاد پر کیا جاتا ہے۔اصل آبجیکٹ کی قسم۔اس صلاحیت سے پولیمورفزم کے حصول میں ، مختلف طبقوں کی اشیاء کو ایک دوسرے کے ساتھ بدلے جانے کا علاج کرنے اور کوڈ کے دوبارہ استعمال اور لچک کو فروغ دینے میں مدد ملتی ہے۔"
    },
    {
        "Question": "\"ازگر میں واقعہ کی سورسنگ اور سی کیو آر ایس (کمانڈ استفسار کی ذمہ داری کو الگ کرنے) کے تصور کی وضاحت کریں ، اور یہ بتائیں کہ وہ سسٹم اسکیل ایبلٹی اور آڈیٹیبلٹی کو کس طرح بہتر بناسکتے ہیں۔\"",
        "Answer": "ٹیسٹ سے چلنے والی ترقی (ٹی ڈی ڈی) ایک سافٹ ویئر ڈویلپمنٹ اپروچ ہے جو اصل کوڈ کو نافذ کرنے سے پہلے خودکار ٹیسٹ لکھنے پر زور دیتا ہے۔یہ \"سرخ ، سبز ، ریفیکٹر\" کے ایک چکرمک عمل کی پیروی کرتا ہے ، جہاں پہلے ٹیسٹ لکھے جاتے ہیں ، کوڈ کو ٹیسٹ پاس کرنے کے لئے نافذ کیا جاتا ہے ، اور پھر اس کوڈ کو اپنے ڈیزائن اور برقرار رکھنے کو بہتر بنانے کے لئے ریفیکٹر کیا جاتا ہے۔ ٹیسٹ سے چلنے والی ترقی کے اصولوں میں شامل ہیں۔: پہلے ٹیسٹ لکھیں: ٹی ڈی ڈی میں ، ڈویلپرز ایک ناکام ٹیسٹ لکھ کر شروع کرتے ہیں جو مطلوبہ طرز عمل یا فعالیت کی وضاحت کرتا ہے۔یہ ٹیسٹ فیچر کی ضروریات یا وضاحتوں کی بنیاد پر لکھے گئے ہیں جو نافذ کیے جارہے ہیں۔ کم سے کم کوڈ لکھیں: ایک بار جب ٹیسٹ لکھا جاتا ہے تو ، ڈویلپرز پھر ٹیسٹ پاس بنانے کے لئے ضروری کوڈ کی کم سے کم رقم لکھتے ہیں۔اس سے سادگی کو فروغ ملتا ہے اور زیادہ انجینئرنگ کو روکتا ہے۔ رن ٹیسٹ اور ریفیکٹر: کوڈ کے نفاذ کے بعد ، نئے بشمول نئے ٹیسٹ پر عمل درآمد کیا جاتا ہے۔اگر کوئی ٹیسٹ ناکام ہوجاتا ہے تو ، ڈویلپرز اس وقت تک کوڈ کو بہتر بناتے ہیں جب تک کہ تمام ٹیسٹ پاس نہ ہوجائیں۔ایک بار جب ٹیسٹ پاس ہوجاتے ہیں تو ، کوڈ کو اپنے ڈیزائن کو بہتر بنانے ، نقل کو دور کرنے اور برقرار رکھنے کو بڑھانے کے لئے ریفیکٹر کیا جاتا ہے۔ سافٹ ویئر ڈویلپمنٹ پروجیکٹس میں ٹیسٹ سے چلنے والی ترقی کے فوائد یہ ہیں: بہتر کوڈ کا معیار: ٹی ڈی ڈی ڈویلپرز کو اس سے پہلے ڈیزائن اور فعالیت کے بارے میں گہرائی سے سوچنے کی ترغیب دیتا ہے۔لکھنا کوڈ۔پہلے ٹیسٹ لکھنے سے ، تقاضوں کی واضح وضاحت کی جاتی ہے ، جس کے نتیجے میں زیادہ مضبوط اور قابل اعتماد کوڈ ہوتا ہے۔ٹیسٹ ایک حفاظتی جال کے طور پر کام کرتے ہیں ، رجعت پسندوں کو پکڑتے ہیں اور کیڑے کو کوڈ بیس میں رینگنے سے روکتے ہیں۔ بیٹر کوڈ برقرار رکھنے: ٹی ڈی ڈی کوڈ کی بار بار ریفیکٹرنگ کو فروغ دیتا ہے۔ریفیکٹرنگ ڈیزائن کو بہتر بنانے ، نقل کو دور کرنے ، اور موجودہ فعالیت کو توڑے بغیر برقرار رکھنے میں مدد کرتا ہے۔جامع ٹیسٹ سویٹ اس بات کو یقینی بناتا ہے کہ ریفیکٹرنگ کے دوران کی جانے والی کسی بھی تبدیلیوں سے نیا عیب متعارف نہیں ہوتا ہے۔ فائر آراء اور بگ کا پتہ لگانا: ٹی ڈی ڈی کوڈ کی تبدیلیوں پر فوری آراء فراہم کرتا ہے۔ٹیسٹ کثرت سے چلانے سے ، ڈویلپرز فوری طور پر مسائل اور کیڑے کی نشاندہی کرتے ہیں۔چونکہ ٹیسٹ خودکار ہیں ، لہذا وہ مسلسل چلایا جاسکتا ہے ، جس سے مسائل کی جلد پتہ لگانے اور دستی جانچ اور ڈیبگنگ پر خرچ ہونے والے وقت کو کم کرنے کی اجازت ملتی ہے۔ بہت زیادہ اعتماد اور تبدیلی کا خوف کم: ٹیسٹوں کے ایک جامع سوٹ کے ساتھ ، ڈویلپرز اپنے کوڈ پر اعتماد حاصل کرتے ہیں۔وہ غیر اعلانیہ نتائج متعارف کرانے کے خوف کے بغیر تبدیلیاں اور ریفیکٹر کوڈ کرسکتے ہیں۔ٹیسٹ ایک حفاظتی جال مہیا کرتے ہیں ، جو کسی بھی طرح کے رجعت پسندوں کو پکڑتے ہیں۔تصریحات کے طور پر ٹیسٹ لکھنے سے تقاضوں اور توقعات کو واضح کرنے میں مدد ملتی ہے۔ٹیسٹ زندہ دستاویزات کے طور پر کام کرتے ہیں ، جو نظام کے طرز عمل کی مشترکہ تفہیم فراہم کرتے ہیں۔ پائیدار رفتار اور پیداواری صلاحیت: ٹی ڈی ڈی ترقی کے لئے نظم و ضبط کے نقطہ نظر کو فروغ دیتا ہے ، جس سے ڈویلپرز کو بہت دور جانے یا غیر ضروری خصوصیات کو نافذ کرنے سے روکتا ہے۔تحریری ٹیسٹوں پر توجہ مرکوز پہلے ترقیاتی عمل کو زیادہ کنٹرول رکھتی ہے اور کام کی پائیدار رفتار کی اجازت دیتی ہے۔ اوور ، ٹیسٹ سے چلنے والی ترقی ایک قیمتی عمل ہے جو کوڈ کے معیار ، برقرار رکھنے اور ابتدائی بگ کا پتہ لگانے کو فروغ دیتا ہے۔یہ کوڈ بیس پر اعتماد پیدا کرتا ہے ، باہمی تعاون کی سہولت فراہم کرتا ہے ، اور سافٹ ویئر ڈویلپمنٹ منصوبوں میں مجموعی پیداوری کو بہتر بناتا ہے۔"
    },
    {
        "Question": "ایک لاحقہ سرنی کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور موثر تزئین کی تلاش اور پیٹرن مماثلت کے لئے طریقے فراہم کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا ایک مثال ہے جس میں سرکلر بفر (رنگ بفر) کی نمائندگی ہوتی ہے جس میں انکیو ، ڈی کیوئو ، اور سائز کی کارروائی ہوتی ہے: پائیتھون کوپی کوڈکلاس سرکلر بفر: ڈیف __init __ (خود ، صلاحیت): سیلف.ایسپیسٹی = صلاحیت سیلف۔بفر = [کوئی نہیں] *صلاحیت خود۔): اگر self.is_full (): استثناء کو بڑھاؤ (\"بفر بھرا ہوا ہے\") سیلف۔ بفر [سیلف۔ ریئر] = آئٹم سیلف۔dequeue (خود): اگر self.is_empty (): استثناء بڑھاؤ (\"بفر خالی ہے\") آئٹم = سیلف۔ بفر [سیلف۔ فرنٹ] سیلف۔ بفر [سیلف۔ فرنٹ] = کوئی بھی نہیں۔1) ٪ سیلف۔ کیپیسی۔30) بفر۔ انکیو (40) بفر۔ انکیو (50) پرنٹ (بفر.ڈیکیو ()) # آؤٹ پٹ: 10 پرنٹ (بفر.ڈیکیو ()) # آؤٹ پٹ: 20 بفر.نکیو (60) بفر.نکیو (70) پرنٹ (70) پرنٹ (بفر.ڈیکیو ()) # آؤٹ پٹ: 30 پرنٹ (بفر.ڈیکیو ()) # آؤٹ پٹ: 40 پرنٹ (بفر.ڈیکیو ()) # آؤٹ پٹ: 50 پرنٹ (بفر.ڈیکیو ()) # آؤٹ پٹ: 60 پرنٹ (بفر.ڈیکیو ())# آؤٹ پٹ: 70 میں یہ عمل درآمد ، سرکلر بفر کلاس ایک سرکلر بفر کی نمائندگی کرتا ہے۔اس کی ابتدا صلاحیت کے پیرامیٹر کے ساتھ کی گئی ہے ، جو بفر کے پاس رکھنے والے عناصر کی زیادہ سے زیادہ تعداد کا تعین کرتی ہے۔بفر کو ابتدائی صلاحیت کے ساتھ ایک فہرست کے طور پر نافذ کیا جاتا ہے ، اور اضافی عناصر کو تقویت بخش اور اس سے دوچار کیا جاسکتا ہے۔ IS_EMPTY اور IS_FOLL طریقوں کی جانچ پڑتال کریں کہ آیا بفر بالترتیب خالی ہے یا مکمل ہے۔انکیو کا طریقہ بفر میں کسی شے کو شامل کرتا ہے ، جانچ پڑتال کرتے ہوئے کہ یہ شامل کرنے سے پہلے بھرا ہوا ہے یا نہیں۔ڈیکیو کا طریقہ بفر سے آئٹم کو ہٹاتا ہے اور واپس کرتا ہے ، یہ جانچتے ہوئے کہ آیا یہ ہٹانے سے پہلے خالی ہے۔ استعمال کی مثال کے طور پر ، ایک سرکلر بفر آبجیکٹ 5 کی گنجائش کے ساتھ تیار کیا جاتا ہے۔طریقہآؤٹ پٹ اس ترتیب کو ظاہر کرتا ہے جس میں عناصر کو ڈیکویڈ کیا جاتا ہے۔ نوٹ کریں کہ ایک سرکلر بفر میں ، جب بفر اپنی صلاحیت تک پہنچ جاتا ہے تو ، اس کے نتیجے میں سرکلر انداز میں قدیم ترین عناصر کو اوور لکھتے ہیں۔"
    },
    {
        "Question": "\"سافٹ ویئر ٹیسٹنگ کے اصولوں اور جانچ کے مختلف اصولوں پر تبادلہ خیال کریں ، جیسے یونٹ ٹیسٹنگ ، انضمام کی جانچ ، اور سسٹم ٹیسٹنگ۔\"",
        "Answer": "اڈاپٹر پیٹرن ایک ساختی ڈیزائن کا نمونہ ہے جو مختلف کلاسوں کے متضاد انٹرفیس کو مل کر کام کرنے کی اجازت دیتا ہے۔یہ ایک طبقے کے انٹرفیس کو دوسرے انٹرفیس میں تبدیل کرکے دو متضاد انٹرفیس کے مابین ایک پل کے طور پر کام کرتا ہے جس کی کلائنٹ کی توقع ہے۔ اڈاپٹر پیٹرن کے اہم اجزاء یہ ہیں: ہدف: یہ اس انٹرفیس کی نمائندگی کرتا ہے جس کے ساتھ مؤکل کام کرنے کی توقع کرتا ہے۔کلاس جس کو ڈھالنے کی ضرورت ہے۔اس میں ایک متضاد انٹرفیس ہے جسے کلائنٹ کے ذریعہ براہ راست استعمال نہیں کیا جاسکتا۔ ایڈاپٹر: یہ وہ کلاس ہے جو ٹارگٹ انٹرفیس کو نافذ کرتی ہے اور اڈاپٹی کو لپیٹتی ہے۔یہ کلائنٹ کی کالوں کو کالوں میں اڈاپٹی کے انٹرفیس میں ترجمہ کرتا ہے۔ اڈاپٹر کا نمونہ ایسے منظرناموں میں مفید ہے جہاں آپ کے پاس انٹرفیس کے ساتھ موجودہ کوڈ یا تیسری پارٹی کی لائبریری موجود ہیں جو آپ کے باقی کوڈ بیس سے مطابقت نہیں رکھتے ہیں۔موجودہ کوڈ میں ترمیم کرنے یا اسے اپنے انٹرفیس کے مطابق بنانے کی کوشش کرنے کے بجائے ، آپ ایک اڈاپٹر تشکیل دے سکتے ہیں جو دو انٹرفیس کے مابین کالوں کا ترجمہ کرنے کے لئے ایک درمیانی پرت کے طور پر کام کرتا ہے۔ یہاں ازگر میں اڈاپٹر پیٹرن کو نافذ کرنے کی ایک مثال ہے: پائیٹون کوپی کوڈ#ٹارگٹ انٹرفیسکلاس میڈیا پلیئر: ڈیف پلے (خود ، فائل کا نام): پاس# اڈاپٹی کلاس کلاس لیگیسی میسک پلیئر: ڈیف پلے_موسک (خود ، فائل): پرنٹ (\"میراثی میوزک پلیئر کھیلنا:\" ، فائل).ایک میڈیا پلیئر انٹرفیس رکھیں جو کھیل کے طریقہ کار کی وضاحت کرتا ہے۔ہمارے پاس ایک لیگیسی کلاس لیگیسی میسک پلیئر بھی ہے جس میں ایک پلے_موسک طریقہ کے ساتھ ایک مختلف انٹرفیس ہوتا ہے۔ میڈیا پلیئرڈاپٹر کلاس ایک اڈاپٹر کے طور پر کام کرتا ہے ، جس نے میڈیا پلیئر انٹرفیس کو نافذ کیا اور لیگیسی میسک پلیئر کو لپیٹ لیا۔یہ پلے کے طریقہ کار کو لیگیسی میسک پلیئر کے پلے_موسک طریقہ کار کی کال میں ترجمہ کرتا ہے۔ کلائنٹ کوڈ میڈیا پلیئرڈاپٹر کی ایک مثال تیار کرتا ہے ، جس میں اس کے کنسٹرکٹر کو لیگیسی میسک پلیئر آبجیکٹ کو منتقل کرتا ہے۔جب میڈیا_ پلیئر آبجیکٹ پر پلے کے طریقہ کار کو بلایا جاتا ہے تو ، یہ غیر مطابقت پذیر انٹرفیس کو اپناتے ہوئے ، لیگیسی میسک پلیئر کے پلے_موسک طریقہ کو داخلی طور پر کال کرتا ہے۔ کوڈ کی آؤٹ پٹ یہ ہوگی: یامل کوپی کوڈ لیگیسی میوزک پلیئر کھیل رہا ہے: گانا۔ ایم پی 3 اس مثال کے طور پر ، اڈاپٹر پیٹرن اجازت دیتا ہے ، اڈاپٹر پیٹرن اس کی اجازت دیتا ہے۔میڈیا پلیئر انٹرفیس ان کے متضاد انٹرفیس کے باوجود ، موجودہ لیگیسی میسک پلیئر کلاس کے ساتھ بغیر کسی رکاوٹ کے کام کرے گا۔کلائنٹ کوڈ پردے کے پیچھے ہونے والی بنیادی موافقت سے آگاہ کیے بغیر میڈیا_ پلیئر آبجیکٹ کا استعمال کرسکتا ہے۔ اوور ، اڈاپٹر پیٹرن غیر مطابقت پذیر انٹرفیس کو ایک ساتھ کام کرنے ، کوڈ کی دوبارہ استعمال ، لچک ، اور سافٹ ویئر سسٹم میں انضمام میں آسانی کو فروغ دینے کا ایک طریقہ فراہم کرتا ہے۔"
    },
    {
        "Question": "\"تقسیم شدہ نظاموں کے تصور کی وضاحت کریں اور ازگر میں مستقل مزاجی ، دستیابی ، اور تقسیم رواداری (سی اے پی تھیوریم) کے چیلنجوں پر تبادلہ خیال کریں۔\"",
        "Answer": "ازگر میں ، میٹاکلاسس کلاس ہیں جو دوسرے طبقوں کے طرز عمل کی وضاحت کرتے ہیں ، جنھیں عام طور پر ان کی \"کلاس فیکٹریوں\" کہا جاتا ہے۔وہ آپ کو اس بات کی وضاحت کرنے کی اجازت دیتے ہیں کہ کلاسوں کو کس طرح تخلیق کیا جانا چاہئے ، ان کے ساتھ کون سے صفات اور طریقے ہونا چاہئے ، اور انہیں کس طرح برتاؤ کرنا چاہئے۔ میٹاکلاس باقاعدہ کلاسوں سے زیادہ اعلی سطح پر کام کرتے ہیں۔اگرچہ کلاسز واقعات کے طرز عمل اور ساخت کی وضاحت کرتے ہیں ، میٹاکلاسس خود کلاسوں کے طرز عمل اور ساخت کی وضاحت کرتے ہیں۔دوسرے لفظوں میں ، میٹاکلاسس کلاس بنانے کے قواعد کی وضاحت کرتے ہیں۔ میٹاکلاس مختلف طریقوں سے کلاسوں کی تخلیق اور طرز عمل کو اپنی مرضی کے مطابق بنانے کے لئے استعمال ہوتے ہیں۔میٹاکلاسس کے لئے استعمال کے کچھ عام معاملات میں شامل ہیں: کوڈنگ کے معیارات کو نافذ کرنا: میٹاکلاسس کو کسی پروجیکٹ میں مستقل کوڈنگ اسٹائل اور معیارات کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے۔اگر کوڈ ان معیارات کی خلاف ورزی کرتا ہے تو وہ مخصوص رہنما خطوط پر عمل پیرا ہونے کے لئے کلاس کی تعریف کی جانچ پڑتال کرسکتے ہیں اور غلطیاں یا انتباہات اٹھا سکتے ہیں۔اس سے آپ خود بخود کلاسوں میں اضافی فعالیت کو انجیکشن لگاسکتے ہیں۔مثال کے طور پر ، آپ کلاسوں میں خود بخود کچھ افادیت کے طریقوں کو شامل کرنے یا کچھ مخصوص حالتوں پر مبنی اضافی صفات کو انجیکشن لگانے کے لئے میٹاکلاس کا استعمال کرسکتے ہیں۔ کلاس رجسٹریوں کو نافذ کرنا: میٹاکلاس کو کلاس رجسٹری یا ذیلی طبقات کی رجسٹری بنانے کے لئے استعمال کیا جاسکتا ہے۔یہ مددگار ثابت ہوسکتا ہے جب آپ ان تمام کلاسوں کا سراغ لگانا چاہتے ہیں جو کسی خاص بیس کلاس سے وارث ہوں۔میٹاکلاس تمام ذیلی طبقات کی رجسٹری کو برقرار رکھ سکتا ہے ، جو کلاسوں کی پلگ ان سسٹم ، توسیع ، یا متحرک دریافت کے لئے کارآمد ثابت ہوسکتا ہے۔ڈیٹا بیس ٹیبلز۔میٹاکلاس کلاس کی تعریف کا معائنہ کرتا ہے اور ضروری ڈیٹا بیس کے سوالات ، تعلقات ، اور دیگر نقشہ سازی کی تشکیلات تیار کرتا ہے۔ ایک آسان مثال ہے جو ایک کوڈنگ کے معیار کو نافذ کرنے کے لئے میٹاکلاس کے استعمال کو ظاہر کرتی ہے: پائیٹون کوپی کوڈکلاس مائی میٹا (قسم): ڈیف __ نی __ (سی ایل ایس ، نام ، نام ، نام ، نام ، نام ، نام ،اڈے ، اے ٹی آر ایس): # چیک کریں کہ آیا کلاس کی تعریف کوڈنگ کے معیار پر قائم ہے اگر \"توثیق کریں\" اگر اے ٹی ٹی آر میں نہیں ہے تو: ٹائپ ایرر (ایف \"کلاس {نام} کو 'توثیق' کا طریقہ غائب کررہا ہے۔سی ایل ایس ، نام ، اڈے ، اے ٹی آر ایس) کلاس مائکلاس (میٹاکلاس = مائی میٹا): ڈی ای ایف کی توثیق (خود): پرنٹ (\"توثیق کرنا ...\")# 'توثیق' کے طریقہ کار کے بغیر کسی کلاس کی وضاحت کرنے کی کوشش کر رہا ہے۔اس مثال کے طور پر ، مائیمیٹا میٹاکلاس کی وضاحت کی گئی ہے ، جو بلٹ ان ٹائپ میٹاکلاس سے وراثت میں ملتی ہے۔یہ __ new__ طریقہ کار کو زیر کرتا ہے ، جو نئی کلاسیں بنانے کے لئے ذمہ دار ہے۔ __ new__ طریقہ چیک کرتا ہے کہ اگر کلاس کی وضاحت کی جارہی ہے تو اس میں توثیق کا طریقہ ہے۔اگر ایسا نہیں ہوتا ہے تو ، ایک ٹائپ ایرر اٹھایا جاتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ کلاس مطلوبہ طریقہ سے محروم ہے۔ مائکلاس کلاس توثیق کرنے کے طریقہ کار کی وضاحت کرتی ہے اور مائیمیٹا کو اپنے میٹاکلاس کے طور پر استعمال کرتی ہے۔چونکہ یہ میٹاکلاس کے ذریعہ نافذ کوڈنگ کے معیار پر عمل پیرا ہے ، لہذا اس کی وضاحت کسی مسئلے کے بغیر کی جاتی ہے۔ دوسری طرف ، توثیق کے طریقہ کار کے بغیر مائی ویلیڈ کلاس کلاس کی وضاحت کرنے کی کوشش کے نتیجے میں کلاس تخلیق کے دوران ایک ٹائپ ایرر اٹھایا جاتا ہے کیونکہ یہ کوڈنگ کے معیار کی خلاف ورزی کرتا ہے۔میٹاکلاس کے ذریعہ نافذ کیا گیا۔ یہ مثال یہ ظاہر کرتی ہے کہ تخلیق کے وقت طبقاتی تعریف کی توثیق کرکے ایک میٹاکلاس کو کس طرح ایک مخصوص کوڈنگ معیار کو نافذ کرنے کے لئے استعمال کیا جاسکتا ہے۔ میٹاکلاس کو ازگر میں طبقاتی تخلیق پر تخصیص اور کنٹرول کے لئے ایک طاقتور طریقہ کار فراہم کرتا ہے ، جس سے آپ کو درزی کی اجازت ملتی ہے۔مخصوص تقاضوں یا رکاوٹوں کو پورا کرنے کے لئے طبقاتی سلوک۔تاہم ، یہ نوٹ کرنا ضروری ہے کہ میٹاکلاس کو انصاف کے ساتھ استعمال کیا جانا چاہئے ،"
    },
    {
        "Question": "\"اسکیپ لسٹ کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور اوسط کیس کے موثر وقت کی پیچیدگی کے ساتھ داخل ، حذف کرنے اور تلاش کے طریقے فراہم کریں۔\"",
        "Answer": "یقینا!یہاں ایک مثال کے طور پر ایک ازگر کلاس کا نفاذ ہے جو ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کی نمائندگی کرتا ہے اور کاہن کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹنے کے لئے ایک طریقہ فراہم کرتا ہے: پائیتھون کوپی کوڈفرم کلیکشن درآمد ڈیفالٹ ڈکٹ ، ڈیوکلاس ڈی اے جی: ڈیف __init __ (خود): سیلف گراف = ڈیفالٹ ڈکٹ (فہرست)ڈیف ایڈ_ج (سیلف ، یو ، وی): سیلف گراف [یو]: خود میں V کے لئے۔== 0: قطار۔ اپینڈ (یو) # مرحلہ 3: ٹاپولوجیکل چھانٹنے کا نتیجہ انجام دیں = []. گراف [u]: in_deggres [v] -= 1 اگر in_degres [v] == 0: قطار.ایپینڈ (v) # مرحلہ 4: اگر لین (نتیجہ)! = لین (سیلف گراف): چکروں کی جانچ پڑتال کریں:استثناء (\"گراف میں ایک سائیکل ہوتا ہے\") واپسی کا نتیجہ# استعمال کی مثال: ڈی اے جی = ڈی اے جی () ڈی اے جی۔ ایڈ_ج (1 ، 2) ڈی اے جی۔ ایڈ_ج (1 ، 3) ڈی اے جی.اڈی_ج (2 ، 4) ڈی اے جی۔ ایڈ_ج (3 ، 3 ،4) ڈی اے جی.اڈی_ج (4 ، 5) کوشش کریں: چھانٹے ہوئے_اڈر = ڈی اے جی۔ ٹوپولوجیکل_سورٹ () پرنٹ (\"ٹوپولوجیکل آرڈر:\" ، ترتیب شدہ_ آرڈر) سوائے اس کے استثنا کے ای: پرنٹ (\"غلطی:\" ، ایس ٹی آر (ای)) اس عمل میں ،ڈی اے جی کلاس ہدایت شدہ ایسائکلک گراف کی نمائندگی کرتی ہے۔ADD_EDGE کا طریقہ عمودی کے درمیان کناروں کو شامل کرنے کے لئے استعمال ہوتا ہے۔ ٹوپولوجیکل_سورٹ کا طریقہ KAHN کے الگورتھم کا استعمال کرتے ہوئے ٹوپولوجیکل چھانٹ رہا ہے۔یہ تمام عمودی حصے کی ڈگری کا حساب لگاتا ہے ، ڈگری 0 رکھنے والے عمودی کے ساتھ ایک قطار کا آغاز کرتا ہے ، اور جب تک تمام عمودی عمل پر کارروائی نہ ہونے تک ملحقہ عمودی کی ان ڈگری کو کم کرتا ہے۔اگر نتیجے میں آرڈر میں تمام عمودی حصے شامل ہیں تو ، اسے ٹاپولوجیکل آرڈر کے طور پر واپس کردیا جاتا ہے۔بصورت دیگر ، ایک رعایت کو ایک سائیکل کی موجودگی کی نشاندہی کرنے میں اضافہ کیا جاتا ہے۔ استعمال کی مثال کے طور پر ، ایک ڈی اے جی آبجیکٹ تیار کیا جاتا ہے ، اور ADD_EDGE کے طریقہ کار کو استعمال کرتے ہوئے عمودی کے درمیان کناروں کو شامل کیا جاتا ہے۔گراف کے ٹاپولوجیکل آرڈر حاصل کرنے کے لئے ٹوپولوجیکل_سورٹ کا طریقہ کہا جاتا ہے۔اگر گراف میں ایک سائیکل ہوتا ہے تو ، ایک استثناء اٹھایا جاتا ہے۔ نوٹ کریں کہ اس عمل سے یہ فرض کیا گیا ہے کہ ان پٹ گراف ایک ہدایت شدہ ایسائکلک گراف (ڈی اے جی) ہے۔اگر گراف میں سائیکل شامل ہیں تو ، ٹوپولوجیکل_سورٹ کا طریقہ کار ایک استثناء کو بڑھا دے گا۔ کوڈ کی آؤٹ پٹ یہ ہوگی: سی ایس ایس کوپی کوڈیٹوپولوجیکل آرڈر: [1 ، 2 ، 3 ، 4 ، 5] اس مثال سے یہ ظاہر ہوتا ہے کہ ہدایت کی تشکیل کے لئے ڈی اے جی کلاس کو کس طرح استعمال کیا جائے۔Acyclic گراف اور اس ترتیب کو حاصل کرنے کے لئے ٹوپولوجیکل چھانٹ رہا ہے جس میں عمودی عمل پر کارروائی کی جانی چاہئے۔"
    },
    {
        "Question": "سافٹ ویئر ریفیکٹرنگ کے تصور کی وضاحت کریں اور ازگر میں کوڈ کی بو اور ریفیکٹرنگ تکنیک کی مثالیں فراہم کریں۔",
        "Answer": "پہلو پر مبنی پروگرامنگ (اے او پی) ایک پروگرامنگ نمونہ ہے جس کا مقصد سافٹ ویئر سسٹم میں کراس کاٹنے کے خدشات کو ماڈیولرائز کرنا ہے۔کراس کٹنگ کے خدشات ایک ایسے پروگرام کے پہلو ہیں جو متعدد حصوں یا ماڈیولز کو متاثر کرتے ہیں ، جیسے لاگنگ ، غلطی سے نمٹنے ، کیچنگ اور سیکیورٹی۔اے او پی ان خدشات کو بنیادی کاروباری منطق سے الگ کرنے ، ماڈیولریٹی ، برقرار رکھنے ، اور کوڈ کی دوبارہ استعمال سے الگ کرنے کا ایک طریقہ فراہم کرتا ہے۔ اے او پی میں ، کراس کاٹنے والے خدشات کو الگ الگ اکائیوں میں شامل کیا جاتا ہے جسے پہلوؤں کہتے ہیں۔پہلوؤں کو دوبارہ قابل استعمال منطق کی وضاحت کی گئی ہے جو اصل کوڈ میں ترمیم کیے بغیر کسی پروگرام کے متعدد حصوں پر لاگو ہوسکتی ہے۔اے او پی نے پوائنٹ کٹس اور مشورے کے تصور کو متعارف کراتے ہوئے اسے حاصل کیا: پوائنٹ کٹ: ایک پوائنٹ کٹ ایک ایسی تصریح ہے جو کسی پروگرام کے نفاذ کے کچھ نکات کی وضاحت کرتی ہے جہاں پہلو کو لاگو کیا جانا چاہئے۔یہ نکات طریقہ کار کی درخواستوں ، آبجیکٹ کی تخلیقات ، استثناء ہینڈلنگ ، یا کسی بھی دوسرے واقعے پر مبنی ہوسکتے ہیں جو پروگرام پر عمل درآمد کے دوران ہوتا ہے۔ ایڈوائس: مشورہ اس کوڈ کی نمائندگی کرتا ہے جو پوائنٹ کٹ کے ذریعہ متعین کردہ متعین کردہ نکات پر عمل میں لایا جاتا ہے۔یہ کراس کاٹنے والے طرز عمل کو سمیٹتا ہے اور پوائنٹ کٹ سے پہلے ، یا اس کے آس پاس سے پہلے اس پر عمل درآمد کیا جاسکتا ہے۔ اے او پی عام طور پر لاگنگ ، کیچنگ ، کارکردگی کی نگرانی ، ٹرانزیکشن مینجمنٹ ، اور سیکیورٹی جیسے خدشات کو دور کرنے کے لئے استعمال کیا جاتا ہے۔متعدد لائبریریوں اور فریم ورک جو اے او پی کی حمایت کرتے ہیں ، پہلوؤں ، پوائنٹ کٹس اور مشوروں کی وضاحت کے لئے میکانزم مہیا کرتے ہیں۔ازگر میں اے او پی کے لئے کچھ مشہور لائبریریوں میں شامل ہیں: ایسپیکٹلیب: ازگر کے لئے ایک پہلو پر مبنی پروگرامنگ لائبریری جو آپ کو سجاوٹ کا استعمال کرتے ہوئے پہلوؤں ، پوائنٹ کٹس ، اور مشورے کی وضاحت کرنے کی اجازت دیتی ہے۔یہ ڈیکوریٹرز کا استعمال کرتے ہوئے پہلوؤں کی وضاحت کرنے اور طریقوں پر ان کا اطلاق کرنے کا ایک طریقہ فراہم کرتا ہے۔یہ آپ کو ڈیکوریٹرز کا استعمال کرتے ہوئے پہلوؤں کی وضاحت کرنے اور ان کو افعال یا طریقوں پر لاگو کرنے کی اجازت دیتا ہے۔ یہ لائبریری عام طور پر پہلوؤں کی وضاحت کرنے اور سجاوٹ کے استعمال سے افعال یا طریقوں کو نشانہ بنانے کے لئے ان کا اطلاق کرنے کے طریقے فراہم کرتے ہیں۔پہلو مخصوص نکات پر ہدف کوڈ کے نفاذ کو روک سکتے ہیں اور متعین کردہ مشورے پر عملدرآمد کرسکتے ہیں۔یہ مشورہ اضافی کاروائیاں انجام دے سکتا ہے ، ٹارگٹ کوڈ کے طرز عمل میں ترمیم کرسکتا ہے ، یا اضافی فعالیت فراہم کرسکتا ہے۔ یہاں ایک آسان مثال ہے جس میں APTHON میں AOP کا مظاہرہ کرنے کے لئے ASPECTLIB لائبریری کا استعمال کیا جاسکتا ہے: Pythoncopy Codefrom Ashaptlib درآمد AspectClass لاگنگ اساسپیٹ (پہلو).my_function \")# AOP logingmy_function () کے ساتھ فنکشن کو کال کرنا ، اس مثال میں ، ہم اسکیپٹ لِب لائبریری کا استعمال کرتے ہوئے ایک لاگنگ اسپیکٹ پہلو کی وضاحت کرتے ہیں۔اس پہلو کے ارد گرد کے مشورے کی وضاحت کی گئی ہے ، جو ہدف کے فنکشن پر عمل درآمد سے پہلے اور اس کے بعد لاگ پیغام پرنٹ کرتا ہے۔جب my_function کو بلایا جاتا ہے تو ، پہلو عملدرآمد کو روکتا ہے ، متعین مشورے (پرنٹنگ لاگ پیغامات) پر عمل درآمد کرتا ہے ، اور پھر اصل فنکشن کے عمل کے ساتھ آگے بڑھتا ہے۔ کوڈ کی آؤٹ پٹ یہ ہوگی: scsscopy کوڈینٹرنگ my_functionIncide my_function کو کس طرح دکھایا جاسکتا ہےکسی فنکشن کی بنیادی فعالیت سے لاگ ان خدشات کو الگ کرنے کے لئے ازگر میں لاگو ہوتا ہے۔پہلو فنکشن کے عمل کو روکتا ہے اور اصل کوڈ میں ترمیم کیے بغیر لاگنگ سلوک کو شامل کرتا ہے۔"
    },
    {
        "Question": "ڈومین سے متعلق مخصوص زبانوں (DSLs) کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ ان کو PYDSL یا ANTLR جیسی لائبریریوں کا استعمال کرتے ہوئے ازگر میں کیسے نافذ کیا جاسکتا ہے۔",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو مہنگے فنکشن کالوں کے نتائج کو کیچ کرکے اور جب وہی آدانوں کے دوبارہ ہونے پر ان کو دوبارہ استعمال کرکے افعال کو بہتر بنانے کے لئے استعمال کی جاتی ہے۔یہ خاص طور پر تکرار کرنے والے افعال کے ل useful مفید ہے جہاں ایک ہی آدانوں کو متعدد بار استعمال کیا جاتا ہے ، جس کی وجہ سے بے کار کمپیوٹیشن ہوتی ہیں۔وقت طلب گنتی کرنے سے پہلے ، فنکشن پہلے جانچ پڑتال کرتا ہے کہ اگر دیئے گئے آدانوں کا نتیجہ پہلے ہی کیشے میں موجود ہے۔اگر یہ ہے تو ، کیشڈ نتیجہ اس کی دوبارہ گنتی کے بجائے واپس کردیا گیا ہے۔اگر نتیجہ کیشے میں نہیں پایا جاتا ہے تو ، فنکشن حساب کو انجام دیتا ہے ، مستقبل کے استعمال کے لئے کیشے میں نتیجہ کو اسٹور کرتا ہے ، اور اس کا نتیجہ لوٹاتا ہے۔ یہاں ایک ایسی مثال ہے جس سے یہ ظاہر ہوتا ہے کہ کس طرح میموری کو استعمال کیا جاسکتا ہے کہ کس طرح فبونیکی نمبروں کی کمپیوٹنگ کے لئے ایک تکرار فنکشن کو بہتر بنایا جاسکے۔: پائیتھون کوپی کوڈیڈف فبونیکی (این ، کیشے = {}): اگر n <= 1: واپس n اگر n اگر کیشے میں: واپس کیشے [n] نتیجہ = فبونیکی (n - 1) + فبونیکی (n - 2) کیشے [n]= نتیجہ کی واپسی کا نتیجہ # استعمال کی مثال پرنٹ (فبوناکی (5)) # آؤٹ پٹ: 5 پرنٹ (فبونیکی (10)) # آؤٹ پٹ: 55 پرنٹ (فبوناکی (15)) # آؤٹ پٹ: 610 ان مثال کے طور پر ، فبوناکی فنکشن فبونیکی نمبر کی گنتی کے لئے بیان کیا گیا ہے۔دیئے گئے انڈیکس کے لئے n.اس فنکشن میں کیشے کے لئے میموائزیشن کا استعمال کیا جاتا ہے اس سے قبل کیشے کی لغت میں نتائج کے حساب سے نتائج کا استعمال کیا جاتا ہے۔ جب فنکشن کو N کی قیمت کے ساتھ بلایا جاتا ہے تو ، یہ پہلے چیک کرتا ہے کہ اگر اس قدر کا نتیجہ پہلے ہی کیشے میں موجود ہے۔اگر یہ ہے تو ، کیشڈ نتیجہ واپس آجاتا ہے۔بصورت دیگر ، فنکشن اپنے آپ کو چھوٹے چھوٹے اشاریہ جات کے لئے بار بار کال کرکے نتیجہ کی گنتی کرتا ہے ، نتیجہ کیشے میں ہوتا ہے ، اور اسے واپس کرتا ہے۔ نتائج کیچنگ کے ذریعہ ، فنکشن این کی ایک ہی اقدار کے لئے بے کار کمپیوٹیشن سے گریز کرتا ہے۔اس کے نتیجے میں ، فنکشن کے عملدرآمد کے وقت کو نمایاں طور پر کم کیا جاتا ہے ، خاص طور پر N. نوٹ کی بڑی اقدار کے لئے کہ کیشے کو فنکشن کی پہلے سے طے شدہ دلیل میں خالی لغت کے طور پر شروع کیا جاتا ہے۔اس بات کو یقینی بناتا ہے کہ ایک ہی کیشے کی لغت کو فنکشن کے لئے متعدد کالوں میں استعمال کیا جاتا ہے ، جس سے میموائزیشن اثر کو محفوظ رکھتے ہوئے۔ میموئزائزیشن تکرار کرنے والے افعال کی کارکردگی کو بہت بہتر بنا سکتی ہے جو اوورلیپنگ سب پروبلیمز کی نمائش کرتی ہے ، جیسے فبونیکی تسلسل۔بے کار کمپیوٹوں سے گریز کرنے سے ، یہ وقت کی پیچیدگی کو منفرد ان پٹ کی تعداد پر منحصر ہے ، اس وقت کی پیچیدگی کو کم کرتا ہے۔ تاہم ، جب فنکشن میں بار بار فنکشن کالز کی ایک قابل ذکر تعداد ہوتی ہے تو یادداشت سب سے زیادہ موثر ہوتی ہے۔ایسے معاملات میں جہاں آدانوں کو منفرد ہوتا ہے یا کثرت سے تبدیل ہوتا ہے ، کیشے کو برقرار رکھنے کا اوور ہیڈ یادداشت کے فوائد سے کہیں زیادہ ہوسکتا ہے۔"
    },
    {
        "Question": "\"میسج کی قطار کے تصور کی وضاحت کریں اور ازگر میں نمونوں کو شائع کریں ، اور اس پر تبادلہ خیال کریں کہ ان کو غیر متزلزل مواصلات اور واقعہ سے چلنے والے فن تعمیر کے لئے کس طرح استعمال کیا جاسکتا ہے۔\"",
        "Answer": "یقینا!یہاں فائلوں اور ڈائریکٹریز بنانے ، ڈھانچے کو نیویگیٹ کرنے ، اور فائلوں کی تلاش کے طریقوں کے ساتھ فائل سسٹم کی نمائندگی کرنے والے ایک ازگر کلاس کا ایک مثال عمل ہے: پائیٹون کوپی کوڈکلاس فائل: ڈیف __ __init __ (خود ، نام)): واپسی f \"فائل ({self.name})\" کلاس ڈائرکٹری: Def __init __ (خود ، نام): self.name = name self.files = [] sell\"ڈائریکٹری ({self.name})\" Def create_file (خود ، نام): فائل = فائل (نام) سیلف.فائلز.ایپینڈ (فائل) ریٹرن فائل ڈیف کریٹ_ڈ ڈائرکٹری (خود ، نام): ڈائریکٹری = ڈائرکٹری (نام) خود۔ڈائریکٹریز.ایپینڈ (ڈائریکٹری) ریٹرن ڈائریکٹری ڈیف گیٹ_فائل (خود ، نام): فائل میں فائل کے لئے۔ فائل۔ نام = نام == نام: ریٹرن فائل ریٹرن کوئی بھی نہیں ڈیف گیٹ_ڈ ڈائرکٹری (خود ، نام): خود میں ڈائریکٹری کے لئے: ڈائریکٹری کے لئے:اگر ڈائریکٹری۔ نام == نام: ریٹرن ڈائرکٹری واپس کوئی نہیں ڈیف سرچ_فائل (خود ، نام): اگر سیلف ڈاٹ گیٹ_فائل (نام): سیلف ڈائریکٹرز میں ڈائریکٹری کے لئے سیلف۔ گیٹ_فائل (نام)اگر فائل: ریٹرن فائل کوئی نہیں# استعمال کی مثال: روٹ = ڈائرکٹری (\"روٹ\") دستاویزات = روٹ۔ کریٹ_ ڈائریکٹری (\"دستاویزات\") تصاویر = روٹ۔ کریٹ_ ڈائریکٹری (\"تصاویر\") ٹیکسٹ_فائل = دستاویزات۔ کریٹ_فائل (\"نوٹس ڈاٹ ٹی ایکس ٹی\") امیج_فائل = تصاویر۔ کریٹ_فائل (\"امیج. جے پی جی\") پرنٹ (روٹ.گیٹ_ڈائٹریکٹری (\"دستاویزات\"))) # آؤٹ پٹ: ڈائرکٹری (دستاویزات) پرنٹ (روٹ. گیٹ_فائل (\"نوٹس.ٹکسٹ\")) # آؤٹ پٹ: فائل (نوٹ (نوٹس.txt) پرنٹ (روٹ.سارچ_فائل (\"تصویری. جے پی جی\")) # آؤٹ پٹ: فائل (امیج.ج پی جی) اس مثال میں ، ہم دو کلاسوں کی وضاحت کرتے ہیں: فائل اور ڈائریکٹری۔فائل کلاس کسی فائل کی نمائندگی کرتی ہے ، اور ڈائریکٹری کلاس کسی نام کے ساتھ ڈائریکٹری/فولڈر کی نمائندگی کرتی ہے۔ڈائرکٹری کلاس میں فائلیں اور سب ڈائرکٹریاں بنانے کے طریقے ہیں ، نیز ان کے ناموں پر مبنی فائلوں اور ڈائریکٹریوں کو بازیافت کرنے کے طریقے بھی ہیں۔ تخلیق_فائل کا طریقہ دیئے گئے نام کے ساتھ ایک نیا فائل آبجیکٹ تیار کرتا ہے اور اسے ڈائریکٹری کی فائلوں کی فہرست میں شامل کرتا ہے۔تخلیق_ ڈائرکٹری کا طریقہ دیئے گئے نام کے ساتھ ایک نئی ڈائرکٹری آبجیکٹ تیار کرتا ہے اور اسے ڈائریکٹری کی ڈائریکٹریوں کی فہرست میں شامل کرتا ہے۔ get_file کا طریقہ فائل کی فہرست میں فائلوں کی فہرست میں دی گئی فائل کی تلاش کرتا ہے۔اگر مل گیا تو ، یہ فائل آبجیکٹ کو لوٹاتا ہے۔بصورت دیگر ، یہ کوئی نہیں لوٹتا ہے۔get_directory کا طریقہ اسی طرح کام کرتا ہے لیکن ڈائریکٹریوں کی تلاش کرتا ہے۔ سرچ_فائل کا طریقہ ڈائریکٹری اور اس کی سب ڈائرکٹریز میں دیئے گئے نام والی فائل کی تکرار سے تلاش کرتا ہے۔یہ چیک کرنے کے لئے GET_FILE طریقہ کو کال کرتا ہے کہ آیا فائل موجودہ ڈائرکٹری میں موجود ہے یا نہیں۔اگر نہیں ملا تو ، یہ ہر ایک سب ڈائرکٹری پر سرچ_فائل کے طریقہ کار کو بار بار کال کرتا ہے اور فائل کو واپس کرتا ہے۔ اگر استعمال کی مثال کے طور پر ، ہم فراہم کردہ طریقوں کا استعمال کرتے ہوئے ڈائریکٹریز اور فائلیں تشکیل دے کر فائل سسٹم کا ڈھانچہ بناتے ہیں۔اس کے بعد ہم یہ ظاہر کرتے ہیں کہ get_directory اور get_file طریقوں کا استعمال کرتے ہوئے ان کے ناموں سے ڈائریکٹریوں اور فائلوں کو بازیافت کرنے کا طریقہ۔آخر میں ، ہم دکھاتے ہیں کہ سرچ_فائل کے طریقہ کار کا استعمال کرتے ہوئے پورے فائل سسٹم کے ڈھانچے میں فائل کو کس طرح تلاش کرنا ہے۔ کوڈ کی آؤٹ پٹ یہ ہوگی: ایس سی ایس کوپی کوڈڈ ڈائرکٹری (دستاویزات) فائل (نوٹس ڈاٹ ٹی ایکس) فائل (امیج.ج پی جی) اس مثال سے ظاہر ہوتا ہےازگر میں فائل سسٹم کلاس کی بنیادی فعالیت ، آپ کو ڈائریکٹریز اور فائلیں بنانے ، ڈھانچے پر تشریف لے جانے اور ان کے ناموں کی بنیاد پر فائلوں کی تلاش کرنے کی اجازت دیتی ہے۔"
    },
    {
        "Question": "ریڈکس ٹری کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور موثر سٹرنگ پریفکس تلاش اور بازیافت کے لئے طریقے فراہم کریں۔",
        "Answer": "کمانڈ پیٹرن ایک طرز عمل کے ڈیزائن کا نمونہ ہے جو آپریشن کو انجام دینے والے شے سے کسی آپریشن کے متلاشی کو ڈیکول کرتا ہے۔یہ کسی درخواست کو کسی شے کے طور پر شامل کرتا ہے ، جس سے آپ کو مختلف درخواستوں ، قطار یا لاگ ان درخواستوں کے ساتھ مؤکلوں کو پیرامیٹرائز کرنے کی اجازت ملتی ہے ، اور ناقابل تسخیر کارروائیوں کی حمایت کی جاسکتی ہے۔ کمانڈ پیٹرن کے اہم اجزاء یہ ہیں: کمانڈ: یہ ایک انٹرفیس یا تجریدی طبکمانڈ پر عمل کریں۔یہ تمام کنکریٹ کمانڈ کلاسوں کے لئے ایک مشترکہ انٹرفیس فراہم کرتا ہے۔ کنکریٹ کمانڈ: یہ کمانڈ انٹرفیس کے ٹھوس نفاذ ہیں۔ہر کنکریٹ کمانڈ کلاس ایک مخصوص آپریشن یا عمل کو شامل کرتی ہے۔یہ کمانڈ کے وصول کنندہ کی وضاحت کرتا ہے (وہ چیز جو اصل عمل کو انجام دیتی ہے) اور اسی عمل سے متعلق عمل کو عملی جامہ پہنانے کے لئے عملدرآمد کے طریقہ کار کو نافذ کرتی ہے۔اس میں مخصوص کمانڈ کے نفاذ کا علم نہیں ہے لیکن کمانڈ انٹرفیس کے ذریعہ کمانڈ کے ساتھ تعامل کرتا ہے۔جب بھی کمانڈ پر عملدرآمد کرنے کی ضرورت ہوتی ہے تو انووکر کمانڈ آبجیکٹ پر عملدرآمد کے طریقہ کار کو آسانی سے کال کرتا ہے۔ ریسیور: یہ وہ چیز ہے جو کمانڈ سے وابستہ اصل عمل یا آپریشن انجام دیتی ہے۔یہ کمانڈ سے آزاد ہے اور اس کو انکر کا علم نہیں ہے۔ کمانڈ پیٹرن آپ کو کسی شے کے اندر تمام مطلوبہ پیرامیٹرز سمیت طریقہ کار کی درخواست کو سمیٹنے کی اجازت دیتا ہے۔اس سے آپ کو ایکشن (وصول کنندہ) انجام دینے والے آبجیکٹ (وصول کنندہ) سے درخواست (انوکر) بنانے والی چیز کو ڈوپل کرنے کے قابل بناتا ہے ، جس سے سسٹم کو لچک اور توسیع کی فراہمی ہوتی ہے۔ یہاں ازگر میں کمانڈ پیٹرن کی ایک مثال عمل ہے: پائیٹون کوپی کوڈکلاس کمانڈ: ڈیف پر عمل درآمد (خود): پاسکلاس لائٹ: ڈیف آن (خود): پرنٹ (\"لائٹ آن ہے۔\") ڈیف آف (خود): پرنٹ (\"لائٹ آف ہے۔\". لائٹ = لائٹ ڈیف پر عملدرآمد (خود): سیلف لائٹ.ون () کلاس لائٹ آف کامنڈ (کمانڈ): ڈیف __init __ (خود ، روشنی): سیلف۔ لائٹ = لائٹ ڈیف پر عملدرآمد (خود)ریموٹیکنٹرول: ڈیف __init __ (خود): سیلف ڈاٹ کامنڈس = {} ڈیف رجسٹر_کمنڈ (سیلف ، کمانڈ_ نام ، کمانڈ): سیلف ڈاٹ کامنڈس [کمانڈ_ نام] = کمانڈ ڈیف ایگزیکٹو_کومنڈ (خود ، کمانڈ_ نام): کمانڈ = سیلف۔کومینڈس۔ گیٹ (کمانڈ_ نام)اگر کمانڈ: کمانڈ.ایکسیکیٹ ()# استعمال کی مثال کی روشنی = لائٹ () لائٹ_ون_کمنڈ = لائٹون کامنڈ (لائٹ) لائٹ_ف_کومنڈ = لائٹ آف کامنڈ (لائٹ) ریموٹ_کونٹرول = ریموٹکونٹرول (\"ریموٹ_کونٹرول۔ ریگٹرول۔ ریگٹر_کونٹرول۔لائٹ_وف_کمنڈ) ریموٹ_کونٹرول.ایکسیکیٹ_کمنڈ (\"آن\") # آؤٹ پٹ: لائٹ آن. ریموٹ_کونٹرول.ایکسیکیٹ_کومنڈ (\"آف\") # آؤٹ پٹ ہے: روشنی آف ہے۔ اس مثال میں ، ہمارے پاس ہلکی کلاس ہے جو ہلکی بلب کی نمائندگی کرتی ہے۔ہم ایک کمانڈ انٹرفیس کی وضاحت کرتے ہیں جو عملدرآمد کے طریقہ کار کا اعلان کرتا ہے۔لائٹون کمانڈ اور لائٹ آف کامنڈ کلاسز کمانڈ انٹرفیس کے ٹھوس نفاذ ہیں ، ہر ایک کی نمائندگی کرتے ہوئے بالترتیب روشنی کو آن اور آف کرتے ہیں۔وہ لائٹ آبجیکٹ کا ایک حوالہ رکھتے ہیں اور لائٹ آبجیکٹ کے متعلقہ طریقہ کار کے لئے عملدرآمد کے طریقہ کار کو تفویض کرتے ہیں۔ ریموٹ کنٹرول کلاس انویکر کے طور پر کام کرتا ہے۔یہ کمانڈ آبجیکٹ کے ساتھ کمانڈ کا نام جوڑ کر کمانڈ رجسٹر کرتا ہے۔پھانسی_کمنڈ کا طریقہ کمانڈ کا نام لیتا ہے اور رجسٹرڈ کمانڈز سے متعلقہ کمانڈ آبجیکٹ کو بازیافت کرتا ہے۔اس کے بعد اس سے وابستہ ایکشن کو انجام دینے کے لئے کمانڈ آبجیکٹ پر عملدرآمد کے طریقہ کار کو کال کرتا ہے۔ استعمال کی مثال کے طور پر ، ہم ایک لائٹ آبجیکٹ تیار کرتے ہیں اور لائٹون کامانڈ اور لائٹ آف کامنڈ اشیاء کو تیز کرتے ہیں ، اور لائٹ آبجیکٹ کو پیرامیٹر کے طور پر منتقل کرتے ہیں۔اس کے بعد ہم کمانڈز کو `کے ساتھ رجسٹر کرتے ہیں"
    },
    {
        "Question": "ڈیٹا کمپریشن کے تصور کی وضاحت کریں اور ازگر میں کمپریشن الگورتھم جیسے ہف مین کوڈنگ یا لیمپل زیو ویلچ (LZW) کی مثالیں فراہم کریں۔",
        "Answer": "ہم آہنگی والے ماحول میں اعداد و شمار کی درستگی اور مستقل مزاجی کو یقینی بنانے کے لئے ملٹی تھریڈڈ ازگر پروگراموں میں ہم آہنگی پر قابو پانے کے طریقہ کار کا استعمال مشترکہ وسائل تک رسائی کے انتظام اور ہم آہنگ کے لئے کیا جاتا ہے۔عام طور پر استعمال ہونے والے ہم آہنگی پر قابو پانے کے تین میکانزم تالے ، سیمفورس اور حالت متغیر ہیں۔اگرچہ ان سب کا مقصد نسل کے حالات کو روکنا اور مشترکہ وسائل تک رسائی کو مربوط کرنا ہے ، لیکن وہ اپنے طرز عمل اور استعمال کے منظرناموں میں مختلف ہیں۔آئیے ان میں سے ہر ایک پر تبادلہ خیال کریں: تالے: تالے ہم آہنگی پر قابو پانے کے طریقہ کار کی آسان ترین شکل ہیں۔وہ باہمی اخراج فراہم کرتے ہیں ، جس سے صرف ایک دھاگے میں ایک وقت میں تالا حاصل ہوتا ہے۔جب کوئی تھریڈ لاک حاصل کرتا ہے تو ، یہ محفوظ وسائل تک خصوصی رسائی حاصل کرتا ہے ، جب تک کہ تالا جاری ہونے تک دوسرے دھاگوں کو اس تک رسائی سے روکتا ہے۔ازگر میں ، تھریڈنگ ماڈیول سے لاک کلاس کا استعمال کرتے ہوئے تالے عام طور پر نافذ کیے جاتے ہیں۔تالے عام طور پر کوڈ یا ڈیٹا ڈھانچے کے اہم حصوں کی حفاظت کے لئے استعمال ہوتے ہیں جن تک ایک ساتھ متعدد تھریڈز کے ذریعہ رسائی حاصل نہیں کی جانی چاہئے۔ سیمفورز: سیمفورس تالے سے زیادہ ورسٹائل ہیں کیونکہ وہ متعدد دھاگوں کو مشترکہ وسائل تک بیک وقت تک رسائی کی اجازت دے سکتے ہیں۔ایک سیمفور کاؤنٹر کو برقرار رکھتا ہے ، اور تھریڈز سیمفور کو حاصل یا جاری کرسکتے ہیں۔اگر کاؤنٹر مثبت ہے تو ، ایک دھاگہ سیمفور حاصل کرسکتا ہے ، اور کاؤنٹر کم ہوجاتا ہے۔اگر کاؤنٹر صفر ہے تو ، سیمفور درخواست دینے والے دھاگے کو روکتا ہے جب تک کہ کوئی اور دھاگہ سیمفور جاری نہ کرے۔سیمفورس کو بیک وقت وسائل تک رسائی حاصل کرنے والے تھریڈز کی تعداد کو محدود کرنے یا دھاگوں کے مابین سرگرمیوں کو مربوط کرنے کے لئے استعمال کیا جاسکتا ہے۔ازگر میں ، سیمفورس کو تھریڈنگ ماڈیول سے سیمفور کلاس کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔ کنڈیشن متغیرات: متعدد دھاگوں کے مابین مواصلات اور ہم آہنگی کو مربوط کرنے کے لئے حالت متغیرات کا استعمال کیا جاتا ہے۔وہ دھاگوں کو آگے بڑھنے سے پہلے کسی خاص حالت کو مطمئن ہونے تک انتظار کرنے دیتے ہیں۔ایک حالت متغیر ایک تالے کے ساتھ وابستہ ہے اور ویٹ () ، مطلع () ، اور مطلع کرنے والے_ال () جیسے طریقے مہیا کرتا ہے۔دھاگے کسی حالت کے متغیر پر انتظار کرسکتے ہیں ، اور جب کوئی دوسرا دھاگہ سگنل کرتا ہے یا حالت کے متغیر کو مطلع کرتا ہے تو ، انتظار کا دھاگہ جاگتا ہے اور اس سے وابستہ تالے کو دوبارہ حاصل کرتا ہے۔حالت کے متغیرات اکثر پروڈیوسر صارفین کے نمونوں یا منظرناموں کو نافذ کرنے کے لئے استعمال کیے جاتے ہیں جہاں دھاگوں کو کسی مخصوص ریاست کی تبدیلی کا انتظار کرنے کی ضرورت ہوتی ہے۔ازگر میں ، حالت کے متغیرات کو تھریڈنگ ماڈیول سے حالت کلاس کا استعمال کرتے ہوئے نافذ کیا جاتا ہے۔ اختلافات کا خلاصہ کرنے کے لئے: تالے کسی وسائل تک خصوصی رسائی فراہم کرتے ہیں ، جس سے ایک وقت میں صرف ایک دھاگے کی اجازت ہوتی ہے۔وہ کوڈ یا ڈیٹا ڈھانچے کے تنقیدی حصوں کی حفاظت کے لئے موزوں ہیں۔ سیمفورز ایک مخصوص تعداد میں دھاگوں کو بیک وقت وسائل تک رسائی حاصل کرنے کی اجازت دیتے ہیں۔ان کا استعمال بیک وقت وسائل تک رسائی حاصل کرنے والے تھریڈز کی زیادہ سے زیادہ تعداد کو کنٹرول کرنے یا تھریڈز کے مابین سرگرمیوں کو مربوط کرنے کے لئے کیا جاسکتا ہے۔وہ عام طور پر تھریڈ ہم آہنگی اور مواصلات کے لئے استعمال ہوتے ہیں۔ یہ نوٹ کرنا ضروری ہے کہ ازگر کا عالمی ترجمان لاک (جی آئی ایل) صرف ایک ہی دھاگے کو ایک وقت میں ازگر بائیک کوڈ پر عملدرآمد کرنے کی اجازت دیتا ہے ، جو ملٹی تھریڈڈ ازگر پروگراموں کی کارکردگی کو متاثر کرسکتا ہے۔ان حالات میں جہاں کارکردگی ایک تشویش ہے ، متبادل طریقوں جیسے ملٹی پروسیسنگ یا اسینکرونس پروگرامنگ جیسے ہم آہنگی کو حاصل کرنے کے لئے غور کیا جاسکتا ہے۔"
    },
    {
        "Question": "\"تقسیم شدہ نظاموں میں غلطی رواداری اور غلطی سے نمٹنے کے اصولوں پر تبادلہ خیال کریں ، اور ازگر میں فالتو پن ، نقل ، اور غلطی کی بازیابی جیسی تکنیک کی وضاحت کریں۔\"",
        "Answer": "کنٹرول کا الٹا (IOC) اور انحصار انجیکشن (DI) آبجیکٹ پر مبنی پروگرامنگ کے تصورات ہیں جو ڈھیلے جوڑے کو فروغ دیتے ہیں اور کالر سے آبجیکٹ تخلیق اور انحصار کے انتظام پر قابو پانے کے ذریعہ کوڈ برقرار رکھنے اور جانچ کو بہتر بناتے ہیں۔): روایتی پروگرامنگ میں ، ایک شے اپنی انحصار کو براہ راست تخلیق اور انتظام کرتی ہے ، جو سخت جوڑے کا باعث بن سکتی ہے اور کوڈ کو برقرار رکھنے اور جانچنے میں مشکل بنا سکتی ہے۔آئی او سی میں ، کنٹرول الٹا ہے ، اس کا مطلب یہ ہے کہ اشیاء کو بنانے اور ان کا انتظام کرنے کی ذمہ داری کسی بیرونی جزو میں تفویض کی جاتی ہے ، جسے اکثر آئی او سی کنٹینر یا فریم ورک کہا جاتا ہے۔آئی او سی کنٹینر اشیاء کے لائف سائیکل کا انتظام کرتا ہے ، انحصار کو حل کرتا ہے ، اور انہیں درخواست دینے والی اشیاء میں انجکشن کرتا ہے۔خدشات کی یہ علیحدگی اشیاء کو ان کی بنیادی فعالیت پر توجہ دینے کی اجازت دیتی ہے ، جبکہ انحصار کی قرارداد کو بیرونی طور پر سنبھالا جاتا ہے۔ انحصار انجیکشن (ڈی آئی): انحصار انجیکشن ایک مخصوص تکنیک ہے جو کسی بیرونی ماخذ سے کسی شے پر انحصار فراہم کرنے کے لئے آئی او سی میں استعمال ہوتا ہے۔اس شے کے اندر انحصار پیدا کرنے کے بجائے ، وہ باہر سے \"انجکشن لگائے\" ہیں۔ڈی آئی کی تین عام اقسام ہیں: کنسٹرکٹر انجیکشن: انحصار ایک کنسٹرکٹر کے ذریعہ فراہم کیا جاتا ہے۔انحصار کو واضح طور پر کنسٹرکٹر پیرامیٹرز کے طور پر قرار دیا جاتا ہے ، اور آئی او سی کنٹینر آبجیکٹ کی تخلیق کرتے وقت صحیح مثالوں کو حل کرنے اور فراہم کرنے کے لئے ذمہ دار ہے۔ سیٹٹر انجیکشن: انحصار سیٹٹر طریقوں کے ذریعے فراہم کیا جاتا ہے۔آبجیکٹ اپنے انحصار کے لئے سیٹٹر طریقوں کو بے نقاب کرتا ہے ، اور IOC کنٹینر ان سیٹر طریقوں کو کال کرکے انحصار کو انجیکشن دیتا ہے۔ انٹرفیس انجکشن: آبجیکٹ ایک انٹرفیس کو نافذ کرتا ہے جو انحصار کو انجیکشن لگانے کے لئے ایک طریقہ کی وضاحت کرتا ہے۔آئی او سی کنٹینر اس انٹرفیس کو آبجیکٹ پر انحصار فراہم کرنے کے لئے استعمال کرتا ہے۔ ڈی آئی کا استعمال کرتے ہوئے ، اشیاء زیادہ ماڈیولر ہوجاتی ہیں ، کیونکہ وہ ٹھوس نفاذ کے بجائے تجرید/انٹرفیس پر انحصار کرتے ہیں۔اس سے ڈھیلے جوڑے کو فروغ ملتا ہے اور آسانی سے دیکھ بھال کی اجازت ملتی ہے ، کیونکہ انحصار میں تبدیلیاں خود ہی اس چیز میں ترمیم کیے بغیر کی جاسکتی ہیں۔مزید برآں ، ڈی آئی انحصار کو مذاق اڑانے یا ٹیسٹ سے متعلق نفاذ کے ساتھ تبدیل کرنے ، یونٹ کی جانچ میں آسانی پیدا کرنے اور جانچ کی اہلیت کو بہتر بنانے کی اجازت دے کر آسان جانچ کے قابل بناتا ہے۔وہ جانچ کے دوران آسانی سے تنہائی اور انحصار کے متبادل کو چالو کرکے بھی جانچ میں اضافہ کرتے ہیں۔"
    },
    {
        "Question": "\"ازگر میں سافٹ ویئر پروفائلنگ اور کارکردگی کی اصلاح کے تصور کی وضاحت کریں ، اور رکاوٹوں کی نشاندہی کرنے کے لئے CProfile یا میموری_پروفیلر جیسے ٹولز پر تبادلہ خیال کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو ہدایت شدہ گراف کی نمائندگی کرتا ہے اور بیل مین فورڈ الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے ایک طریقہ فراہم کرتا ہے: پائیٹون کوپی کوڈکلاس گراف: ڈیف __ __init __ (خود ، عمودی): سیلف۔ڈیف ایڈ_ج (سیلف ، یو ، وی ، ڈبلیو): سیلف گراف.ایپینڈ ((یو ، وی ، ڈبلیو)) ڈیف بیل مین_فورڈ (خود ، ماخذ): # مرحلہ 1: فاصلاتی اقدار اور پیشرو کی صف کا فاصلہ شروع کریں = [فلوٹ ('inf ')] * self.v فاصلہ [ماخذ] = 0 پیشرو = [-1] * سیلف ڈاٹ وی # مرحلہ 2: تمام کناروں کو آرام کریں | V |- رینج میں _ کے لئے 1 بار (سیلف۔ وی - 1): آپ کے لئے ، آپ ، وی ، ڈبلیو کے لئے۔]: فاصلہ [v] = فاصلہ [u] + ڈبلیو پیشرو [v] = u # مرحلہ 3: خود کے لئے منفی وزن کے چکروں کی جانچ پڑتال کریں۔inf ') اور فاصلہ [u] + w <فاصلہ [v]: ویلیو ایرر (\"گراف میں منفی وزن کا چکر ہوتا ہے\") کی واپسی کا فاصلہ ، پیشرو# استعمال کی مثال جی = گراف (5) g.add_edge (0 ، 1 ، 2)g.add_edge (0 ، 2 ، 4) g.add_edge (1 ، 2 ، -1) g.add_edge (1 ، 3 ، 1) g.add_edge (2 ، 3 ، 3) g.add_edge (3 ، 4 ، -4) ماخذ_نوڈ = 0 ڈسٹینس ، پیشروؤں = g.bellman_ford (Source_node) پرنٹ (\"نوڈ سے مختصر فاصلہ\" ، سورس_نوڈ) میں I میں (لین (فاصلہ)): پرنٹ (\"نوڈ\" ، I ، \"- فاصلہ:\" ، \"فاصلوں [i]) پرنٹ (\"پیش رو:\") کے لئے میں رینج (لین (پیشروؤں)) کے لئے: پرنٹ (\"نوڈ\" ، i ، \"- پیشرو:\" ، پیشروؤں [i]) اس عمل میں ، ہمارے پاس ایک گراف ہے۔کلاس جو ہدایت شدہ گراف کی نمائندگی کرتا ہے۔کنسٹرکٹر پیرامیٹر کے طور پر عمودی کی تعداد لیتا ہے اور خالی گراف کو شروع کرتا ہے۔ADD_EDGE کا طریقہ گراف میں کناروں کو شامل کرنے کے لئے استعمال کیا جاتا ہے ، جس میں ماخذ ورٹیکس ، منزل مقصود ، اور کنارے کے وزن کی وضاحت کی جاتی ہے۔ بیل مین_فورڈ کا طریقہ کسی دیئے گئے ماخذ کی چوٹی سے مختصر ترین راستہ تلاش کرنے کے لئے بیل مین فورڈ الگورتھم کو نافذ کرتا ہے۔یہ سب سے پہلے ماخذ کے سوا تمام عمودیوں کے ل the انفینٹی کے ساتھ فاصلے کی صف کا آغاز کرتا ہے ، جو 0 پر سیٹ کیا جاتا ہے۔اس کے بعد ، یہ v - 1 بار تکرار کرتا ہے ، جہاں V عمودی کی تعداد ہے ، اور اگر کوئی چھوٹا راستہ مل جاتا ہے تو فاصلاتی اقدار کو اپ ڈیٹ کرکے تمام کناروں کو آرام دیتا ہے۔آخر میں ، یہ ایک بار پھر تمام کناروں کے ذریعے تکرار کرکے منفی وزن کے چکروں کی جانچ پڑتال کرتا ہے۔ استعمال کی مثال میں ، ہم ایک گراف بناتے ہیں اور کچھ کناروں کو شامل کرتے ہیں۔ہم ایک ماخذ نوڈ کی وضاحت کرتے ہیں اور ماخذ سے مختصر ترین فاصلوں اور پیشرو تلاش کرنے کے لئے بیل مین_فورڈ کے طریقہ کار کو کال کرتے ہیں۔اس کے بعد نتائج کنسول پر چھاپے جاتے ہیں۔ نوٹ کریں کہ بیل مین فورڈ الگورتھم میں O (v * e) کی وقت کی پیچیدگی ہوتی ہے ، جہاں V عمودی کی تعداد ہے اور E گراف میں کناروں کی تعداد ہے۔"
    },
    {
        "Question": "ایک محدود اسٹیٹ مشین (ایف ایس ایم) کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں اور ریاستوں کے مابین منتقلی اور واقعات کو سنبھالنے کے طریقے فراہم کریں۔",
        "Answer": "عدم استحکام پروگرامنگ میں ایک تصور ہے جس سے مراد ایسی اشیاء ہیں جن کی ریاست کے تخلیق ہونے کے بعد ان میں ترمیم نہیں کی جاسکتی ہے۔ازگر میں ، کچھ اعداد و شمار کی اقسام جیسے ٹیوپلس اور ڈور ناقابل تسخیر ہیں ، مطلب یہ ہے کہ ایک بار تفویض ہونے کے بعد ان کی اقدار کو تبدیل نہیں کیا جاسکتا۔عدم استحکام کئی فوائد لاسکتا ہے ، خاص طور پر ہم آہنگی اور تقسیم شدہ نظاموں میں: تھریڈ سیفٹی: ہم آہنگی نظاموں میں جہاں متعدد دھاگے مشترکہ اعداد و شمار تک رسائی اور ترمیم کرتے ہیں ، غیر منقولہ اشیاء موروثی دھاگے کی حفاظت فراہم کرتی ہیں۔چونکہ غیر منقولہ اشیاء کو تبدیل نہیں کیا جاسکتا ہے ، لہذا وہ تالے یا ہم آہنگی کے طریقہ کار کی ضرورت کے بغیر دھاگوں میں محفوظ طریقے سے شیئر کیے جاسکتے ہیں۔اس سے نسل کے حالات کا خطرہ کم ہوجاتا ہے اور ہم آہنگی پروگرامنگ آسان اور کم غلطی کا خطرہ بناتا ہے۔ہم آہنگی والے نظاموں میں ، لاکنگ اوور ہیڈ کو متعارف کراتا ہے اور کارکردگی کے مسائل کا باعث بن سکتا ہے۔غیر منقولہ اشیاء لاکنگ کی ضرورت کو دور کردیتی ہیں کیونکہ وہ فطری طور پر ہم آہنگی کے ل safe محفوظ ہیں۔ تقسیم شدہ نظاموں میں ہم آہنگی: تقسیم شدہ نظاموں میں ، جہاں اعداد و شمار کو متعدد نوڈس میں تقسیم کیا جاتا ہے ، لہذا عدم استحکام مستقل مزاجی کو یقینی بناتا ہے۔متضاد ترمیمات کے خطرے کے بغیر ناقابل تسخیر اشیاء کو محفوظ طریقے سے نقل کیا جاسکتا ہے اور نوڈس میں شیئر کیا جاسکتا ہے۔اس سے تقسیم شدہ فن تعمیرات میں اعداد و شمار کی مستقل مزاجی اور ہم آہنگی کو سنبھالنے کو آسان بنایا گیا ہے۔چونکہ ناقابل تسخیر اشیاء تبدیل نہیں ہوسکتی ہیں ، لہذا ان کے نتائج کو باطل ہونے کی فکر کیے بغیر کوچ کیا جاسکتا ہے۔اس سے پہلے کے گنتی نتائج کو دوبارہ استعمال کرکے کارکردگی کو بہت بہتر بنایا جاسکتا ہے۔ فنکشنل پروگرامنگ: فنکشنل پروگرامنگ میں عدم استحکام ایک بنیادی اصول ہے۔غیر منقولہ اشیاء خالص افعال جیسے فنکشنل پروگرامنگ کے طریقوں کو فروغ دیتی ہیں ، جہاں کسی فنکشن کا نتیجہ صرف اس کے آدانوں پر منحصر ہوتا ہے اور اس کے کوئی مضر اثرات نہیں ہوتے ہیں۔اس سے کوڈ کے بارے میں استدلال ، جانچ اور ڈیبگنگ اور ٹیسٹنگ میں آسانی پیدا ہوتی ہے: غیر منقولہ اشیاء ڈیبگنگ اور ٹیسٹنگ کو آسان بناتی ہیں۔چونکہ ان کی ریاست تبدیل نہیں ہوسکتی ہے ، لہذا ناقابل تسخیر اشیاء کا طرز عمل پیش گوئی اور مستقل ہے ، جو کیڑے کی شناخت اور پنروتپادن کو آسان بناتا ہے۔جانچ زیادہ سیدھی ہو جاتی ہے کیونکہ آپ کو ٹیسٹ پر عمل درآمد کے دوران آبجیکٹ اسٹیٹ کی تبدیلیوں کا محاسبہ کرنے کی ضرورت نہیں ہوتی ہے۔ تاہم ، یہ نوٹ کرنا ضروری ہے کہ تمام ڈیٹا کو ناقابل تسخیر ہونے کی ضرورت نہیں ہے۔ایسے معاملات ہیں جہاں کارکردگی یا مخصوص فعالیت کے لئے تغیر پزیر ڈیٹا ضروری ہے۔یہ صحیح توازن تلاش کرنے اور عدم استحکام کو استعمال کرنے کے بارے میں ہے جہاں اس سے اہم فوائد ملتے ہیں۔ ازگر میں ، جبکہ کچھ بلٹ میں ڈیٹا اقسام جیسے ٹیوپلس اور ڈور ناقابل تسخیر ہیں ، زیادہ تر اشیاء متغیر ہیں۔تاہم ، آپ پروگرامنگ کے کچھ طریقوں پر عمل کرکے عدم استحکام کو حاصل کرسکتے ہیں ، جیسے کلیکشن ماڈیول سے نامزد ٹپل کا استعمال ، ڈیٹا کلانے جیسے ٹولز کا استعمال کرتے ہوئے ڈیٹا ڈھانچے کو منجمد کرنا ، یا صرف اس بات کو یقینی بنانا کہ اشیاء کو ایک بار تشکیل نہیں دیا جاتا ہے۔تھریڈ سیفٹی کو فروغ دینے ، ہم آہنگی کی ضرورت کو کم کرنے ، مستقل مزاجی کو یقینی بنانا ، کیچنگ کو قابل بنانا ، اور فنکشنل پروگرامنگ کے طریقوں کو سہولت فراہم کرنا۔"
    },
    {
        "Question": "\"بڑے ڈیٹا پروسیسنگ کے ل data ڈیٹا ڈھانچے کے تصور کی وضاحت کریں ، جیسے بلوم فلٹرز ، ہائپرلوگلاگ ، یا گنتی من خاکہ ، اور ازگر میں ان کی درخواستوں پر تبادلہ خیال کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جس میں سرکلر قطار کی نمائندگی ہوتی ہے جس میں قطار مکمل یا خالی ہے یا نہیں اس کی جانچ پڑتال کے طریقوں کے ساتھ سرکلر قطار کی نمائندگی کی جاتی ہے: پائیتھون کوپی کوڈکلاس سرکلر کیوئو: ڈیف __init __ (خود ، کے): سیلف۔ کے۔کوئی نہیں] * k self.head = self.tail = -1 def is_empty (self): واپسی سیل۔ ہیڈ == -1 def is_full (self): واپسی (سیلف۔ ٹیل + 1) ٪ سیلف۔ k.k == خود۔ہیڈ ڈیف انکیو (خود ، قدر): اگر سیلف۔ آئی ایس_فل (): پرنٹ (\"قطار بھری ہوئی ہے۔.tail] = ویلیو اور: سیلف۔خالی۔ہیڈ] سیلف ہیڈ = (سیلف۔ ہیڈ + 1) ٪ سیلف۔ K ریٹرن ویلیو# استعمال کی مثال کیو = سرکلر کیو (5) cq.enqueue (1) cq.enqueue (2) cq.enqueue (3) cq.enqueue (4) cq.enqueue (5) پرنٹ (\"قطار بھری ہوئی ہے؟\" ، cq.is_full ()) پرنٹ (\"قطار خالی ہے؟\" ، cq.is_empty ()) پرنٹ (\"dequeuiing:\" ، cq.dequeue ()))پرنٹ (\"dequeuing:\" ، cq.dequeue ()) پرنٹ (\"dequeuiing:\" ، cq.dequeue ()) پرنٹ (\"قطار بھری ہوئی ہے؟\" ، cq.is_full ()) پرنٹ (\"قطار خالی ہے؟\" ،cq.is_empty ()) cq.enqueue (6) cq.enqueue (7) cq.enqueue (8) پرنٹ (\"dequeuiuing:\" ، cq.dequeue ()) پرنٹ (\"dequeueuing:\" ، cq.dequeue ()))پرنٹ (\"dequeuiing:\" ، cq.dequeue ()) اس نفاذ میں ، ہمارے پاس ایک سرکلر کیو کلاس ہے جو سرکلر قطار کی نمائندگی کرتا ہے۔کنسٹرکٹر ایک پیرامیٹر K لیتا ہے جو قطار کے سائز کی وضاحت کرتا ہے۔قطار کو K عناصر کے ساتھ ازگر کی فہرست کا استعمال کرتے ہوئے نافذ کیا جاتا ہے ، جس کی ابتدا کسی کو بھی نہیں ہوتی ہے۔سر اور دم کے متغیرات قطار کے اگلے اور عقبی حصے کی پوزیشنوں پر نظر رکھتے ہیں۔ IS_EMPTY طریقہ چیک کرتا ہے کہ کیا قطار اس بات کی تصدیق کرکے خالی ہے کہ آیا سر -1 ہے۔آئی ایس_فل طریقہ چیک کرتا ہے کہ اگر قطار کی اگلی پوزیشن سر کے برابر ہے یا نہیں تو یہ چیک کرکے قطار بھری ہوئی ہے۔یہ پہلے چیک کرتا ہے کہ قطار بھری ہوئی ہے ، اور اگر ایسا ہے تو ، یہ ایک پیغام پرنٹ کرتا ہے۔اگر قطار خالی ہے تو ، یہ سر اور دم 0 پر سیٹ کرتا ہے اور قطار میں اسی پوزیشن میں عنصر کو شامل کرتا ہے۔اگر قطار خالی یا بھری نہیں ہے تو ، یہ ماڈیولس آپریٹر ٪ کا استعمال کرتے ہوئے اگلی پوزیشن پر دم کو آگے بڑھاتی ہے اور عنصر کو شامل کرتی ہے۔ ڈیکیو کا طریقہ قطار سے کسی عنصر کو ہٹاتا ہے اور لوٹاتا ہے۔یہ پہلے چیک کرتا ہے کہ قطار خالی ہے یا نہیں ، اور اگر ایسا ہے تو ، یہ ایک پیغام پرنٹ کرتا ہے۔اگر قطار میں صرف ایک عنصر ہوتا ہے (سر اور دم ایک جیسے ہوتے ہیں) ، تو یہ قدر کو بازیافت کرتا ہے ، سر اور دم کو -1 پر دوبارہ سیٹ کرتا ہے ، اور قیمت کو واپس کرتا ہے۔اگر قطار میں ایک سے زیادہ عنصر موجود ہیں تو ، یہ سر کی پوزیشن سے قیمت کو بازیافت کرتا ہے ، ماڈیولس آپریٹر ٪ کا استعمال کرتے ہوئے سر کو اگلی پوزیشن پر پہنچاتا ہے ، اور قیمت کو واپس کرتا ہے۔ استعمال کی مثال کے طور پر ، ہم 5 کے سائز کے ساتھ ایک سرکلر کیو تیار کرتے ہیں۔. ہم عناصر کو 1 سے 5 اور انکیو کرتے ہیں"
    },
    {
        "Question": "رد عمل مائکروسروائسز فن تعمیر کے اصولوں پر تبادلہ خیال کریں اور یہ بتائیں کہ فاسٹ پی آئی یا کوارٹ جیسے فریم ورک کو کس طرح ازگر میں توسیع پزیر اور لچکدار نظام کی تعمیر کے لئے استعمال کیا جاسکتا ہے۔",
        "Answer": "ڈیزائن کے ذریعہ معاہدہ (ڈی بی سی) ایک سافٹ ویئر ڈویلپمنٹ کا طریقہ کار ہے جو سافٹ ویئر سسٹم کے مختلف اجزاء یا ماڈیولز کے مابین باضابطہ معاہدوں کی وضاحت اور ان کو نافذ کرنے پر مرکوز ہے۔یہ معاہدے ، جو معاہدوں کے نام سے جانا جاتا ہے ، ہر جزو کی متوقع طرز عمل ، ذمہ داریوں اور ضمانتوں کی وضاحت کرتے ہیں۔ڈی بی سی واضح وضاحتیں فراہم کرنے اور اس بات کو یقینی بنانے کے ذریعہ سافٹ ویئر کی وشوسنییتا ، برقرار رکھنے اور دوبارہ استعمال کو بہتر بنانے میں مدد کرتا ہے۔ ڈی بی سی میں معاہدے تین اہم عناصر پر مشتمل ہوتے ہیں: پیشگی شرائط ، پوسٹ کنڈیشنس ، اور انویسیئٹیشن۔کسی جزو یا فنکشن کو انجام دینے سے پہلے۔وہ ان پٹ یا سسٹم کی حالت کی ضروریات اور توقعات کی وضاحت کرتے ہیں۔پیشگی شرائط اس بات کو یقینی بناتی ہیں کہ جز کو صحیح طریقے سے استعمال کیا جاتا ہے ، اور وہ غلط یا غیر متوقع آدانوں کو غلطیوں کا سبب بننے سے روکنے میں مدد کرتے ہیں۔اگر کسی پیشگی شرط کی خلاف ورزی کی جاتی ہے تو ، یہ جزو کے مسئلے یا غلط استعمال کی نشاندہی کرتا ہے۔وہ جزو کی وجہ سے متوقع نتائج ، طرز عمل ، یا ریاست کی تبدیلیوں کی وضاحت کرتے ہیں۔پوسٹ کنڈیشنز اس بات کو یقینی بناتے ہیں کہ جزو اپنے مطلوبہ مقصد کو پورا کرے اور مطلوبہ آؤٹ پٹ تیار کرے۔پوسٹ کنڈیشن کی خلاف ورزی اجزاء کے مسئلے یا غلط نفاذ کی نشاندہی کرتی ہے۔وہ ان خصوصیات یا رکاوٹوں کی وضاحت کرتے ہیں جو اجزاء کے پورے عمل میں کوئی تبدیلی نہیں کرتے ہیں۔حملہ آور مستقل مزاجی کو نافذ کرکے اور سسٹم کے قواعد کی غیر متوقع ضمنی اثرات یا خلاف ورزیوں کو روکنے کے ذریعہ نظام کی سالمیت کو یقینی بنانے میں مدد کرتا ہے۔ سافٹ ویئر ڈویلپمنٹ کے عمل میں معاہدوں کو شامل کرکے ، ڈویلپرز واضح طور پر اجزاء کے مابین متوقع طرز عمل اور تعامل کی وضاحت اور تصدیق کرسکتے ہیں۔معاہدے قابل عمل تصریحات کے طور پر کام کرتے ہیں جو دستاویزات کے طور پر کام کرتے ہیں ، جانچ میں مدد کرتے ہیں ، اور ترقیاتی چکر کے اوائل میں کیڑے پکڑنے میں مدد کرتے ہیں۔مزید برآں ، معاہدوں سے کوڈ کو دوبارہ استعمال میں مدد ملتی ہے اور ہر جزو کی انحصار اور توقعات کو واضح طور پر بیان کرکے ماڈیولر ڈیزائن کو فروغ دیتے ہیں۔ جب کہ ازگر کو معاہدوں کے لئے بلٹ ان سپورٹ نہیں ہے ، آپ مختلف تکنیکوں کا استعمال کرتے ہوئے پیشگی شرائط ، پوسٹ کنڈیشنس اور حملہ آوروں کو نافذ کرسکتے ہیں۔ایک مقبول نقطہ نظر دعوے اور تشریحات کا استعمال کرنا ہے۔یہاں ایک مثال پیش کی جارہی ہے کہ آپ ازگر میں معاہدوں کو کس طرح نافذ کرسکتے ہیں: پائیتھون کوپی کوڈفرم ٹائپنگ امپورٹ لسٹکلاس اسٹیک: ڈیف __init __ (خود): سیلف.اٹیئمز = [] ڈیف آئی ایس ای ایم پی (سیلف) -> بول: ریٹرن لین (سیلف۔ آئٹمز) == 0ڈیف پش (خود ، آئٹم: انٹ) -> کوئی نہیں: اسسٹنسٹنس (آئٹم ، انٹ) پر زور دیں ، \"آئٹم ایک عدد ہونا چاہئے\" خود() ، \"کسی خالی اسٹیک سے پاپ نہیں ہوسکتا\" سیلف ڈاٹ آئٹمز.پوپ () ڈیف جھانکنے (خود) -> انٹ: خود پر زور نہ دیں۔ IS_EMPTY () ، \"خود کو خالی نہیں کر سکتے ہیں\"۔] ڈیف سائز (خود) -> انٹ: ریٹرن لین (سیلف ڈاٹ آئٹمز)# استعمال کی مثال کے طور پر اسٹیک = اسٹیک (اسٹیک۔ پش (5) اسٹیک۔ پش (10) پرنٹ (\"اسٹیک سائز:\" ، اسٹیک۔ سائز () ())پرنٹ (\"ٹاپ آئٹم:\" ، اسٹیک.پیک ()) پرنٹ (\"پاپڈ آئٹم:\" ، اسٹیک.پپ ()) پرنٹ (\"کیا اسٹیک خالی ہے؟\" ، اسٹیک.میٹ ()) مذکورہ مثال میں ، ہمارے پاس ہے۔ایک اسٹیک کلاس جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔پش ، پاپ ، جھانکنے اور سائز کے طریقے دعووں کا استعمال کرتے ہوئے کچھ معاہدوں کو نافذ کرتے ہیں: پش طریقہ اس پیشگی شرط کو نافذ کرتا ہے کہ آئٹم کو دھکیل دیا جارہا ہے۔خالی اسٹیکاگر وہ اسٹیک خالی ہے تو وہ ایک دعوی کی غلطی اٹھاتے ہیں۔ سائز کے طریقہ کار میں کوئی پیشگی شرط یا پوسٹ کنڈیشن نہیں ہوتا ہے ، لیکن یہ معاہدوں کے بغیر کسی طریقہ کی مثال کے طور پر کام کرتا ہے۔ دعووں کا استعمال کرتے ہوئے ، ہم جانچ کے دوران معاہدے کی خلاف ورزیوں کو پکڑ سکتے ہیں۔"
    },
    {
        "Question": "\"ایک امکانی اعداد و شمار کے ڈھانچے کی نمائندگی کرنے والی ایک ازگر کلاس کو نافذ کریں ، جیسے بلوم فلٹر ، ہائپرلوگلاگ ، یا گنتی کے منکی خاکہ ، اور موثر اندازے کے مطابق سیٹ ممبرشپ کے سوالات کے لئے طریقے فراہم کریں۔\"",
        "Answer": "سست تشخیص ایک پروگرامنگ کی تکنیک ہے جہاں اس کی قیمت کی حقیقت کی ضرورت ہونے تک کسی اظہار یا حساب کتاب کی تشخیص موخر کردی جاتی ہے۔یہ ایک اصلاح کی حکمت عملی ہے جس کا مقصد غیر ضروری کمپیوٹوں سے گریز کرکے کارکردگی کو بہتر بنانا ہے۔ سست تشخیص میں ، جب ان کی وضاحت یا تفویض کی جاتی ہے تو اظہار یا کمپیوٹیشن کا فوری طور پر اندازہ نہیں کیا جاتا ہے۔اس کے بجائے ، تشخیص میں تاخیر ہوتی ہے جب تک کہ قیمت کو واضح طور پر درخواست نہ کی جائے۔اس کا مطلب یہ ہے کہ اس اظہار کی صرف اس وقت تشخیص کی جاتی ہے جب اس کی ضرورت ہو ، اور اس کے بعد کی تشخیص سے گریز کیا جاسکتا ہے اگر قیمت پہلے ہی حساب کی گئی ہو۔ لیزی تشخیص خاص طور پر ایسے منظرناموں میں مفید ہے جہاں کسی قدر کی گنتی وسائل سے متعلق یا وقت طلب ہے ، اوراس قدر کی ضرورت تمام معاملات میں نہیں ہوسکتی ہے یا اس کی ضرورت نہیں ہوسکتی ہے۔تشخیص کو موخر کرنے تک جب تک کہ یہ ضروری نہ ہو ، غیر ضروری کمپیوٹوں سے بچا جاسکتا ہے ، جس کے نتیجے میں بہتر کارکردگی اور کارکردگی ہوتی ہے۔ مختلف تکنیکوں ، جیسے جنریٹرز ، ایٹریٹرز ، اور سست ڈیٹا ڈھانچے کا استعمال کرتے ہوئے لیزی تشخیص ازگر میں حاصل کیا جاسکتا ہے۔جنریٹرز کا استعمال کرتے ہوئے سست تشخیص کے استعمال کو ظاہر کرنے کی ایک مثال یہ ہے: پائیٹون کوپی کوڈیڈف فبونیکی (): a ، b = 0 ، 1 جبکہ سچ ہے: ایک a ، b = b ، a + bfib = fibonacci ()# پہلے 10 فبونیکی نمبروں پرنٹ کریں _رینج (10) میں: پرنٹ (اگلا (ایف آئی بی)) مذکورہ بالا مثال میں ، ہم ایک جنریٹر فنکشن فبونیکی کی وضاحت کرتے ہیں جو فبونیکی نمبروں کا لامحدود ترتیب پیدا کرتا ہے۔پورے تسلسل کے سامنے کمپیوٹنگ اور اسٹور کرنے کے بجائے ، جنریٹر اگلے فبونیکی نمبر کو صرف اس وقت تیار کرنے کے لئے سست تشخیص کا استعمال کرتا ہے جب اس سے اگلے () فنکشن کا استعمال کرتے ہوئے درخواست کی جاتی ہے۔اس سے ہمیں فبونیکی تسلسل پر تکرار کرنے اور صرف ان نمبروں کو بازیافت کرنے کی اجازت ملتی ہے جس کی ہمیں ضرورت کے بغیر پورے تسلسل کی کمپیوٹنگ کیے بغیر۔ سست تشخیص کا استعمال کرتے ہوئے ، ہم پورے فبونیکی تسلسل کی غیر ضروری گنتی سے گریز کرتے ہیں ، جو وسائل سے متعلق اور وقت ہوسکتا ہے۔استعمالہم صرف فبونیکی نمبروں کی گنتی اور بازیافت کرتے ہیں جیسا کہ ہمیں ان کی ضرورت ہے ، ایک زیادہ موثر نقطہ نظر فراہم کرنا۔ لیزی تشخیص ان حالات میں فائدہ مند ثابت ہوسکتا ہے جہاں کمپیوٹیشن مہنگا پڑیں ، میموری کے استعمال کو بہتر بنانے کی ضرورت ہے ، یا لامحدود یا بڑے ڈیٹا سیٹوں سے نمٹنے کے وقت۔یہ آن ڈیمانڈ کی تشخیص کی اجازت دیتا ہے ، غیر ضروری کمپیوٹوں کو کم کرتا ہے اور مجموعی کارکردگی کو بہتر بناتا ہے۔"
    }
]