[
    {
        "Question": "جاوا اسکرپٹ",
        "Answer": "ڈی ایس اے کا مطلب مختلف سیاق و سباق میں متعدد شرائط ہے۔یہاں ڈی ایس اے کے کچھ عام معنی ہیں: ڈیٹا ڈھانچے اور الگورتھم: کمپیوٹر سائنس میں ، ڈی ایس اے سے مراد اعداد و شمار کے ڈھانچے (جیسے صفوں ، لنکڈ فہرستوں ، درختوں ، گرافوں ، وغیرہ) اور الگورتھم (جیسے چھانٹ رہا ہے ،تلاش ، گراف الگورتھم ، وغیرہ) مسائل کو موثر طریقے سے حل کرنے کے لئے استعمال کیا جاتا ہے۔ ڈیجیٹل دستخط الگورتھم: ڈی ایس اے ایک کریپٹوگرافک الگورتھم ہے جو ڈیجیٹل دستخطوں کو پیدا کرنے اور اس کی تصدیق کے لئے استعمال ہوتا ہے۔یہ ڈیجیٹل دستخطوں کے لئے وسیع پیمانے پر استعمال ہونے والا معیار ہے اور یہ ماڈیولر اخراج اور مجرد لوگریتھم کے ریاضی کے تصورات پر مبنی ہے۔ ڈائرکٹ سیلنگ ایسوسی ایشن: ڈی ایس اے ایک ایسی انڈسٹری ٹریڈ ایسوسی ایشن ہے جو ایسی کمپنیوں کی نمائندگی کرتی ہے جو براہ راست فروخت میں ملوث ہے۔یہ براہ راست فروخت ہونے والی کمپنیوں کے لئے مدد ، وکالت اور تعلیم مہیا کرتا ہے اور صنعت کے اندر اخلاقی کاروباری طریقوں کو فروغ دیتا ہے۔ امریکہ کے جمہوری سوشلسٹ: ڈی ایس اے ریاستہائے متحدہ میں ایک سیاسی تنظیم ہے جو جمہوری سوشلزم کی حمایت کرتی ہے۔یہ ملک کی سب سے بڑی سوشلسٹ تنظیم ہے اور ترقی پسند پالیسی کی تبدیلیوں ، معاشرتی انصاف ، اور معاشی مساوات کی طرف کام کرتی ہے۔ یہ صرف چند مثالیں ہیں کہ ڈی ایس اے کیا حوالہ دے سکتا ہے ، اور اس مخصوص تناظر پر منحصر اور اس کے دوسرے معنی بھی ہوسکتے ہیں جس میںاصطلاح استعمال کی جاتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں لہرانے کے تصور کی وضاحت کریں اور یہ کہ کس طرح متغیر اور فنکشن اعلانات کو متاثر کرتا ہے۔",
        "Answer": "ڈیٹا کا ڈھانچہ کمپیوٹر کی میموری میں ڈیٹا کو منظم اور اسٹور کرنے کا ایک طریقہ ہے تاکہ اس تک رسائی اور موثر انداز میں ہیرا پھیری کی جاسکے۔یہ ایک منطقی نمائندگی فراہم کرتا ہے کہ اعداد و شمار کو کس طرح منظم کیا جاتا ہے ، جس سے موثر اسٹوریج ، بازیافت ، اور معلومات کی ہیرا پھیری کی اجازت ہوتی ہے۔ ڈیٹا ڈھانچے کو دو اہم زمروں میں درجہ بندی کیا جاسکتا ہے: قدیم اعداد و شمار کے ڈھانچے اور جامع ڈیٹا ڈھانچے۔ بنیادی اعداد و شمار کے ڈھانچے: یہ بنیادی ہیںپروگرامنگ زبانوں کے ذریعہ فراہم کردہ بلاکس بلڈنگ۔مثالوں میں شامل ہیں: انٹیجر: پوری تعداد (جیسے ، 1 ، 2 ، 3) اسٹور کرتا ہے۔ فلوٹ: اسٹورز اعشاریہ اعشاریہ (جیسے ، 3.14 ، 2.718)۔ چیریکٹر: ایک ہی حرف (جیسے ، 'اے' ، 'بی' ، 'سی' کو اسٹور کرتا ہے۔.مثالوں میں شامل ہیں: صفیں: ایک ہی قسم کے عناصر کا ایک مجموعہ ، انڈیکس کا استعمال کرتے ہوئے رسائی حاصل کی گئی۔(LIFO) ڈھانچہ جہاں عناصر کو ایک ہی سرے سے شامل اور ہٹا دیا جاتا ہے۔کناروں کے ذریعہ جڑے ہوئے نوڈس ، اوپر کی جڑ نوڈ کے ساتھ۔ گرافس: کناروں کے ذریعہ منسلک نوڈس (عمودی) کا ایک مجموعہ ، پیچیدہ تعلقات کی اجازت دیتا ہے۔ ڈیٹا ڈھانچے کا انتخاب ہاتھ میں مسئلے کی مخصوص ضروریات پر منحصر ہے۔مختلف اعداد و شمار کے ڈھانچے میں مختلف خصوصیات ہیں ، جیسے میموری کے استعمال کے لحاظ سے ان کی کارکردگی ، رسائی کی رفتار ، اندراج اور حذف کرنے کی کارروائیوں ، اور مخصوص قسم کے کاموں کے ل suit مناسبیت۔ڈیٹا کے ڈھانچے اور ان کی خصوصیات کو سمجھنا موثر الگورتھم ڈیزائن اور نفاذ کے لئے بنیادی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں ڈیٹا کی مختلف اقسام کیا ہیں؟مثالوں کے ساتھ ہر قسم کی وضاحت کریں۔",
        "Answer": "صفوں اور لنکڈ فہرستیں دونوں اعداد و شمار کے ڈھانچے ہیں جو عناصر کے مجموعوں کو اسٹور اور منظم کرنے کے لئے استعمال ہوتے ہیں۔تاہم ، وہ اپنے بنیادی ڈھانچے ، میموری کے انتظام اور کارکردگی کی خصوصیات کے لحاظ سے مختلف ہیں۔صفوں اور منسلک فہرستوں کے مابین کلیدی اختلافات یہ ہیں: ڈھانچہ: سرنی: ایک سرنی میموری کا ایک متنازعہ بلاک ہے جو ایک ہی قسم کے عناصر کو اسٹور کرتا ہے۔عنصروں تک انڈیکس کا استعمال کرتے ہوئے رسائی حاصل کی جاتی ہے ، تخلیق کے وقت طے شدہ سائز کا تعین کیا جاتا ہے۔صفوں کی ایک مقررہ لمبائی ہوتی ہے اور ان کے اشاریہ کی بنیاد پر عناصر تک براہ راست رسائی فراہم کرتی ہے۔ لنکڈ فہرست: ایک لنکڈ فہرست نوڈس پر مشتمل ہوتی ہے جہاں ہر نوڈ میں ترتیب میں اگلے نوڈ کے لئے ایک قدر اور حوالہ (یا پوائنٹر) ہوتا ہے۔نوڈس ضروری طور پر میموری کے متضاد مقامات پر محفوظ نہیں ہوتے ہیں ، جس سے متحرک میموری کی مختص کرنے کی اجازت ہوتی ہے۔منسلک فہرستیں لمبائی میں مختلف ہوسکتی ہیں اور عناصر تک ترتیب تک رسائی فراہم کرسکتی ہیں۔ میموری مینجمنٹ: سرنی: صفوں کو تمام عناصر کو ذخیرہ کرنے کے لئے میموری کا پہلے سے مختص بلاک کی ضرورت ہوتی ہے۔سرنی کا سائز طے شدہ ہے اور عناصر کو نقل کرنے اور عناصر کی کاپی کیے بغیر آسانی سے تبدیل نہیں کیا جاسکتا۔ہر نوڈ میں اگلے نوڈ کا حوالہ ہوتا ہے ، جس سے عناصر کو شامل کرنے یا ہٹانے میں لچک کی اجازت ہوتی ہے۔منسلک فہرستیں متضاد میموری کی ضرورت کے بغیر متحرک طور پر بڑھ سکتی ہیں یا سکڑ سکتی ہیں۔ داخلہ اور حذف کرنا: سرنی: ایک سرنی میں داخل کرنا یا حذف کرنا مہنگا ہوسکتا ہے اگر اسے آرڈر کو برقرار رکھنے کے لئے شفٹ کرنے والے عناصر کی ضرورت ہو یا اگر اسے صف کا سائز تبدیل کرنے کی ضرورت ہو۔کسی سرنی کے آغاز یا وسط میں عناصر کو داخل کرنا یا حذف کرنے کے لئے بعد کے عناصر کو تبدیل کرنا ضروری ہے۔ لنکڈ فہرست: منسلک فہرست میں داخل کرنا یا حذف کرنا نسبتا effective موثر ہے۔نوڈ کے اندراج یا حذف کرنے میں دوسرے عناصر کو منتقل کرنے کی ضرورت کے بغیر ، کچھ پوائنٹرز کو ایڈجسٹ کرنا شامل ہے۔تاہم ، لنکڈ فہرست میں کسی مخصوص عنصر تک رسائی کے لئے شروع سے ہی فہرست کو عبور کرنے کی ضرورت ہوتی ہے۔کسی مخصوص انڈیکس میں کسی عنصر تک رسائی موثر ہے اور اس میں مستقل وقت کی پیچیدگی (O (1)) ہے۔ منسلک فہرست: منسلک فہرستیں براہ راست بے ترتیب رسائی فراہم نہیں کرتی ہیں۔کسی مخصوص انڈیکس میں کسی عنصر تک رسائی کے ل the ، فہرست کو شروع سے ہی ترتیب سے گزرنا چاہئے ، جس کے نتیجے میں لکیری ٹائم پیچیدگی (O (n)) ہوتی ہے۔ خلاصہ یہ کہ صفیں بے ترتیب رسائی اور مقررہ سائز کا اسٹوریج فراہم کرتی ہیں لیکن اس میں محدود لچک ہوتی ہے۔متحرک سائز اور اندراج/حذف کرنے کی کارروائیوں کی شرائط۔منسلک فہرستیں سائز اور اندراج/حذف کرنے کے کاموں میں لچک پیش کرتی ہیں لیکن ان تک رسائی کے اوقات سست ہوتے ہیں اور اضافی پوائنٹرز کی وجہ سے زیادہ میموری استعمال کرتے ہیں۔صفوں اور منسلک فہرستوں کے مابین انتخاب مسئلے کی مخصوص ضروریات پر منحصر ہے ، جیسے بے ترتیب رسائی ، بار بار اندراج/حذف کرنے ، یا میموری کی کارکردگی کی ضرورت۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں اشیاء کو کس طرح تخلیق اور استعمال کرتے ہیں؟آبجیکٹ تخلیق اور پراپرٹی تک رسائی کی مثالیں فراہم کریں۔",
        "Answer": "ایک اسٹیک اور قطار دونوں لکیری ڈیٹا ڈھانچے ہیں جو عناصر کو ذخیرہ کرنے اور ان میں ہیرا پھیری کے لئے استعمال ہوتے ہیں۔تاہم ، وہ اس ترتیب کے لحاظ سے مختلف ہیں جس میں عناصر تک رسائی اور ہٹا دیا جاتا ہے۔یہاں اسٹیک اور ایک قطار کے درمیان کلیدی اختلافات ہیں: اسٹیک: آخری ان پہلی آؤٹ (LIFO): ایک اسٹیک میں ، آخری عنصر جو شامل کیا جاتا ہے (دھکا دیا جاتا ہے) پہلے ہی ہٹایا جاتا ہے (پاپڈ)۔اس کے بارے میں پلیٹوں کے اسٹیک کی طرح سوچئے ، جہاں آپ صرف اوپر سے پلیٹوں کو شامل یا ہٹا سکتے ہیں۔اس کو ہٹائے بغیر سب سے اوپر کا عنصر۔ مثال کے طور پر: کتابوں کے ڈھیر پر غور کریں۔جب آپ کسی کتاب کو ہٹاتے ہیں تو سب سے اوپر رکھی گئی آخری کتاب پہلی کتاب ہے۔اس کے بارے میں سوچئے کہ لائن میں انتظار کرنے والے لوگوں کی قطار کی طرح ، جہاں پہلے پہنچنے والا پہلا شخص پیش کیا جائے۔قطار کے سامنے (سر) سے۔جب پہلے پہنچنے والا گاہک پہلے پہنچے گا تو اس کی خدمت کی جائے گی جب ایک کیشیئر صارفین کی خدمت کرتا ہے۔ خلاصہ میں ، اسٹیک اور قطار کے درمیان بنیادی فرق وہ ترتیب ہے جس میں عناصر تک رسائی اور ہٹا دیا جاتا ہے۔ایک اسٹیک آخری ان فرسٹ آؤٹ (LIFO) اصول کی پیروی کرتا ہے ، جبکہ ایک قطار پہلے ان فرسٹ آؤٹ (FIFO) اصول کی پیروی کرتی ہے۔اسٹیک کو ایسے منظرناموں میں استعمال کیا جاتا ہے جہاں حال ہی میں شامل کردہ عناصر دلچسپی رکھتے ہیں (جیسے ، فنکشن کال اسٹیک) ، جبکہ قطاریں منظرناموں میں استعمال ہوتی ہیں جہاں اندراج کا حکم ضروری ہوتا ہے (جیسے ، ملازمت کا نظام الاوقات ، چوڑائی کی پہلی تلاش الگورتھم)۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں NULL اور غیر متعینہ کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "ایک ہیش ٹیبل ، جسے ہیش میپ کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو موثر اندراج ، حذف کرنے اور بازیافت کے کام فراہم کرتا ہے۔اس میں ہیشنگ نامی ایک تکنیک استعمال کی گئی ہے تاکہ وہ اپنی چابیاں پر مبنی عناصر کو ذخیرہ کریں اور بازیافت کریں۔ایک ہیش ٹیبل میں بالٹیوں یا سلاٹوں کی ایک صف شامل ہوتی ہے ، جہاں ہر سلاٹ ایک یا زیادہ کلیدی قدر کے جوڑے کو ذخیرہ کرسکتا ہے۔ ہیش ٹیبل کس طرح کام کرتا ہے: ہیش فنکشن: ایک ہیش فنکشن ان پٹ کے طور پر ایک کلید لیتا ہے اور ہیش کوڈ کی گنتی کرتا ہے ،ایک عدد قیمت ہے۔ہیش کوڈ کو انڈیکس یا بالٹی کا تعین کرنے کے لئے استعمال کیا جاتا ہے جہاں متعلقہ کلیدی قدر کی جوڑی کو صف میں محفوظ کیا جائے گا۔ انڈیکس حساب کتاب: ہیش کوڈ عام طور پر ماڈیولو ڈویژن نامی عمل کا استعمال کرتے ہوئے صف کے اندر انڈیکس کا حساب لگانے کے لئے استعمال ہوتا ہے۔ماڈیولو آپریشن اس بات کو یقینی بناتا ہے کہ انڈیکس سرنی کی درست حد میں آتا ہے۔ کولیشن ہینڈلنگ: ہیش کے افعال مختلف چابیاں کے لئے ایک ہی ہیش کوڈ تیار کرسکتے ہیں ، جس سے تصادم کا باعث بنتا ہے۔تصادم اس وقت ہوتا ہے جب ایک ہی انڈیکس کے دو یا زیادہ کلیدوں کا نقشہ۔تصادم کو سنبھالنے کے ل different ، مختلف تکنیکیں ہیں: الگ الگ زنجیر: ہیش ٹیبل میں ہر بالٹی میں ایک ہی انڈیکس کے ساتھ ایک سے زیادہ کلیدی قیمت کے جوڑے کو ذخیرہ کرنے کے لئے ایک لنکڈ لسٹ یا دوسرا ڈیٹا ڈھانچہ ہوتا ہے۔اگلا دستیاب سلاٹ سرنی میں (لکیری تحقیقات ، چوکور تحقیقات ، یا ڈبل ہیشنگ جیسی تکنیکوں کا استعمال کرتے ہوئے) جب تک کہ اس کو کلیدی قدر کی جوڑی کو ذخیرہ کرنے کے لئے ایک خالی سلاٹ نہیں مل جاتا ہے۔اگر انڈیکس خالی ہے تو ، کلیدی قدر کی جوڑی براہ راست ذخیرہ ہوتی ہے۔تصادم کی صورت میں ، تصادم کی قرارداد کی حکمت عملی مناسب سلاٹ تلاش کرنے کے لئے استعمال کی جاتی ہے۔اگر انڈیکس میں مطلوبہ کلید موجود ہے تو ، اسی قدر واپس کردی جاتی ہے۔اگر تصادم ہیں تو ، سرچ الگورتھم صحیح سلاٹ تلاش کرنے کے لئے تصادم کی قرارداد کی حکمت عملی کی پیروی کرتا ہے۔ لیٹیشن: ہیش فنکشن کلید کے لئے انڈیکس کا حساب لگاتا ہے۔اگر انڈیکس میں کلید ہوتی ہے تو ، متعلقہ کلیدی قدر کی جوڑی کو ہٹا دیا جاتا ہے۔اگر تصادم ہیں تو ، سرچ الگورتھم کو کلید تلاش کرنے کے لئے استعمال کیا جاتا ہے ، اور پھر حذف کرنے کا کام انجام دیا جاتا ہے۔ ہیش ٹیبلز کے کلیدی فوائد ان کے داخلے ، بازیافت اور حذف کرنے کے کاموں کے لئے اوسطا وقت کی اوسط وقت کی پیچیدگی (O (1)) ہیں (O (1))جب ہیش فنکشن چابیاں یکساں طور پر تقسیم کرتا ہے۔تاہم ، بدترین صورت میں ، جب بہت سارے تصادم ہوتے ہیں تو ، وقت کی پیچیدگی O (n) کو کم کر سکتی ہے ، جہاں ہیش ٹیبل میں عناصر کی تعداد ہے۔پروگرامنگ زبانوں میں میزیں ، ڈیٹا بیس کی اشاریہ سازی ، اور ایسوسی ایٹو اریوں یا لغتوں کو نافذ کرنا۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں بندش کیا ہے؟اس کی ایک مثال فراہم کریں کہ کس طرح بندش کو استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک درخت ایک نان لائنر ڈیٹا ڈھانچہ ہے جو منسلک ، ایسائکلک انداز میں درجہ بندی سے عناصر کو منظم کرتا ہے۔اس میں نوڈس اور کناروں پر مشتمل ہے ، جہاں نوڈس عناصر کی نمائندگی کرتے ہیں ، اور کنارے عناصر کے مابین تعلقات کی نمائندگی کرتے ہیں۔کسی درخت میں سب سے اوپر والے نوڈ کو روٹ نوڈ کہا جاتا ہے ، اور ہر نوڈ میں صفر یا اس سے زیادہ بچوں کے نوڈس ہوسکتے ہیں۔نوڈس جن میں ایک ہی والدین کے نوڈ ہوتے ہیں انہیں بہن بھائی کہتے ہیں ، اور بغیر کسی بچے کے نوڈس کے نوڈ کو پتی کا نوڈ کہا جاتا ہے۔ یہاں مختلف قسم کے درخت ہیں: بائنری ٹری: ایک بائنری ٹری ایک درخت ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچوں کے نوڈس ہوتے ہیں۔، بائیں بچے اور دائیں بچے کے طور پر جانا جاتا ہے۔جس ترتیب میں بچوں کے نوڈس کا اہتمام کیا جاتا ہے وہ بائنری درخت کی خصوصیات کو متاثر کرسکتا ہے ، جیسے بائنری سرچ ٹری ، اےول ٹری ، یا ڈھیر۔ بائنری سرچ ٹری (بی ایس ٹی): بائنری سرچ ٹری بائنری درخت کی ایک قسم ہے جس میںنوڈ کے بائیں بچے میں نوڈ سے کم اقدار ہوتی ہیں ، اور دائیں بچے میں نوڈ سے زیادہ اقدار ہوتی ہیں۔یہ موثر تلاشی ، اندراج اور حذف کرنے کے کاموں کو قابل بناتا ہے ، متوازن درختوں کے لئے O (لاگ این) کی اوسط وقت کی پیچیدگی کے ساتھ۔ اے وی ایل درخت: ایک AVL (ایڈیلسن-ویلسکی اور لینڈس) درخت ایک خود توازن بائنری تلاش کا درخت ہے۔یہ یقینی بناتا ہے کہ کسی بھی نوڈ کے بائیں اور دائیں ذیلی حصے کی اونچائی زیادہ سے زیادہ ایک سے مختلف ہوتی ہے۔یہ متوازن جائیداد موثر تلاش ، اندراج ، اور حذف کرنے کے کاموں کو برقرار رکھنے میں مدد کرتی ہے ، جس میں O (لاگ این) کی بدترین وقت کی پیچیدگی ہوتی ہے۔ ریڈ-بلیک ٹری: ایک سرخ سیاہ درخت ایک اور خود توازن بائنری تلاش کا درخت ہے۔یہ قواعد و ضوابط کے ایک سیٹ کا استعمال کرتے ہوئے توازن برقرار رکھتا ہے جو اس بات کی ضمانت دیتا ہے کہ درخت متوازن رہتا ہے۔یہ تلاش ، اندراج ، اور حذف کرنے کے ل O O (لاگ این) کی بدترین وقت کی پیچیدگی کے ساتھ موثر آپریشن فراہم کرتا ہے۔ بی ٹری: ایک بی ٹری ایک خود توازن درخت کا ڈھانچہ ہے جو عام طور پر فائل سسٹم اور ڈیٹا بیس میں استعمال ہوتا ہے۔یہ بڑی مقدار میں ڈیٹا کو سنبھالنے کے لئے ڈیزائن کیا گیا ہے اور تلاش ، اندراج اور حذف کرنے کے لئے موثر آپریشن فراہم کرتا ہے۔بی ٹریوں کے پاس ہر نوڈ میں متعدد چابیاں ہوتی ہیں اور بچوں کے نوڈس کی متغیر تعداد کی اجازت دیتے ہیں۔یہ ان کے مشترکہ سابقہ کے ذریعہ چابیاں کا اہتمام کرتا ہے ، جو اسے سابقہ پر مبنی سرچ آپریشنز کے ل efficient موثر بناتا ہے۔کوششیں عام طور پر خودکار اور لغت کے نفاذ جیسے ایپلی کیشنز میں استعمال ہوتی ہیں۔ ہیپ: ایک ہیپ ایک خاص درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ڈھیر کی پراپرٹی کو پورا کرتا ہے۔بائنری کا ڈھیر ، خاص طور پر ، ایک مکمل بائنری درخت ہے جہاں ہر نوڈ کی قدر اس کے بچے کے نوڈس کی اقدار سے زیادہ یا اس کے برابر (یا اس سے کم یا اس کے برابر) ہوتی ہے۔ڈھیر عام طور پر ترجیحی قطاروں کے موثر نفاذ کے لئے استعمال ہوتے ہیں۔ یہ کچھ عام طور پر مشہور درخت ہیں ، جن میں سے ہر ایک اپنی مخصوص خصوصیات اور استعمال کے معاملات کے ساتھ ہے۔درخت مختلف ایپلی کیشنز میں استعمال ہونے والے ورسٹائل ڈیٹا ڈھانچے ہیں ، بشمول فائل سسٹم ، ڈیٹا بیس ، نیٹ ورک روٹنگ الگورتھم ، درجہ بندی کی نمائندگی اور بہت کچھ۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپل وراثت کیسے کام کرتی ہے؟پروٹو ٹائپ زنجیر کے تصور کی وضاحت کریں۔",
        "Answer": "ایک ترتیب شدہ صف پر بائنری سرچ الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: بالترتیب بائیں اور دائیں پوائنٹرز کو صف کے آغاز اور اختتام پر سیٹ کریں۔ جب بائیں پوائنٹر دائیں پوائنٹر سے کم یا اس کے برابر ہے ، دہرائیں۔مندرجہ ذیل اقدامات: a.درمیانی انڈیکس کا حساب بائیں اور دائیں پوائنٹرز کی اوسط کے طور پر کریں: وسط = (بائیں + دائیں) / 2.b.مڈل انڈیکس کی قیمت کو ہدف کی قیمت کے ساتھ موازنہ کریں: اگر درمیانی قیمت ہدف کے برابر ہے تو ، مڈل انڈیکس کو نتیجہ کے طور پر واپس کریں۔ اگر درمیانی قیمت ہدف سے زیادہ ہے تو ، دائیں پوائنٹر کو وسط میں اپ ڈیٹ کریں - 1.ifدرمیانی قیمت ہدف سے کم ہے ، بائیں پوائنٹر کو مڈ + پر اپ ڈیٹ کریں۔ایک \"نہیں ملا\" اشارے واپس کریں۔ ازگر میں نمونہ عمل درآمد ہے: پائیتھون کوپی کوڈ ڈیف بائنری_سارچ (اے آر آر ، ہدف): بائیں = 0 دائیں = لین (اے آر آر) - 1 جبکہ بائیں <= دائیں: درمیانی = (بائیں + دائیں) //2 اگر آر آر [وسط] == ہدف: مڈ ایلف آر آر [وسط] <ہدف: بائیں = وسط + 1 اور: دائیں = وسط - 1 ریٹرن -1 # ہدف نہیں ملا # مثال کے استعمال: ترتیب_ر = [1 ، 3 ،5 ، 7 ، 9 ، 11 ، 13] ہدف = 9 ریزولٹ = بائنری_سرچ (چھانٹیا_آر ، ہدف) اگر نتیجہ!{ہدف} نہیں ملا \") اس نفاذ میں ، بائنری سرچ الگورتھم سرنی کے درمیانی عنصر کے ساتھ ہدف کی قیمت کا موازنہ کرتا ہے اور اس کے مطابق بائیں یا دائیں پوائنٹر کو اپ ڈیٹ کرکے تلاش کی حد کو نیچے کرتا ہے۔یہ عمل اس وقت تک جاری رہتا ہے جب تک کہ ہدف کی قیمت نہ مل جائے یا تلاش کی حد ختم ہوجائے۔بائنری سرچ الگورتھم کی وقت کی پیچیدگی O (لاگ این) ہے ، جہاں N ترتیب شدہ صف میں عناصر کی تعداد ہے ، کیونکہ یہ بار بار تلاش کی حد کو آدھے حصے میں تقسیم کرتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں واقعہ کا لوپ کیا ہے؟یہ غیر متزلزل کارروائیوں کو کس طرح سنبھالتا ہے؟",
        "Answer": "ایک ٹرائی ، جسے ایک سابقہ درخت بھی کہا جاتا ہے ، درختوں کی طرح کا ڈیٹا ڈھانچہ ہے جو تار کے طور پر ذخیرہ شدہ چابیاں کی موثر بازیافت کے لئے استعمال ہوتا ہے۔یہ خاص طور پر سٹرنگ مماثل اور پریفکس پر مبنی تلاشی سے متعلق مسائل کو حل کرنے کے لئے مفید ہے۔\"ٹری\" کی اصطلاح \"بازیافت\" کے لفظ سے آتی ہے۔ ایک ٹری میں ، ہر نوڈ ایک ہی کردار کی نمائندگی کرتا ہے۔نوڈس کو ایک دوسرے کے ساتھ درخت کی ساخت بنانے کے لئے منسلک کیا جاتا ہے ، جہاں ہر کنارے کلید میں ایک کردار کی نمائندگی کرتا ہے۔جڑ سے کسی خاص نوڈ تک کا راستہ کسی سابقہ یا ایک مکمل کلید کی نمائندگی کرتا ہے۔ یہاں ٹری ڈیٹا ڈھانچے کی کچھ کلیدی خصوصیات اور فوائد ہیں: موثر سٹرنگ بازیافت: سٹرنگ بازیافت کے کاموں میں ایکسل کی کوشش کرتا ہے۔ایک تار کو دیکھتے ہوئے ، آپ جلدی سے یہ طے کرسکتے ہیں کہ آیا یہ ٹری میں موجود ہے یا نہیں۔اس سے یہ ہجے کی جانچ پڑتال ، خود کار طریقے سے ، اور کسی لغت میں الفاظ کی تلاش جیسے کاموں کے ل useful مفید ہے۔آپ کو ٹری میں وہ تمام چابیاں مل سکتی ہیں جو دیئے گئے تار کے ساتھ مشترکہ سابقہ کا اشتراک کرتی ہیں۔یہ خاص طور پر خود کار طریقے سے فعالیت یا کسی مخصوص سابقہ کے ساتھ الفاظ کی تلاش کے ل useful مفید ہے۔ اسپیس کی کارکردگی: مختلف چابیاں میں مشترکہ سابقہ بانٹ کر جگہ کو بہتر بنانے کی کوشش کرتا ہے۔اس سے وہ ایسے منظرناموں میں موثر ہوجاتے ہیں جہاں اسی طرح کے سابقہ کے ساتھ بہت سی چابیاں موجود ہیں۔ٹری کی خلائی پیچیدگی کا انحصار چابیاں کی کل تعداد کے بجائے چابیاں میں منفرد کرداروں کی تعداد پر ہے۔ آرڈرڈ کلیدی بازیافت: کوشش کرتا ہے کہ چابیاں کی ترتیب کو محفوظ رکھیں۔یہ پراپرٹی لغت کے لحاظ سے سب سے چھوٹی یا سب سے بڑی کلید کو تلاش کرنے ، ترتیب شدہ ترتیب میں چابیاں گنتی ، یا کسی خاص حد کے اندر چابیاں تلاش کرنے جیسے کاموں کی اجازت دیتی ہے۔ فاسٹ اندراج اور حذف کرنے کی کوششیں: کوششیں کیز کے لئے موثر اندراج اور حذف کرنے کے کام فراہم کرتی ہیں۔ان کارروائیوں کے لئے وقت کی پیچیدگی عام طور پر کلید کی لمبائی کے متناسب ہوتی ہے۔ ٹری تغیرات: مخصوص ضروریات کی تائید کے ل additional کوششوں کو اضافی خصوصیات کے ساتھ بڑھایا جاسکتا ہے۔مثالوں میں کمپریسڈ کوششیں (جیسے پیٹریسیا کی کوششیں یا ریڈکس کے درخت) شامل ہیں جو جگہ کو مزید بہتر بناتے ہیں ، ترنری تلاش کرنے کی کوشش کرتی ہے جو زیادہ عام حرفوں کو سنبھالتی ہے ، یا ہر کلید سے وابستہ اضافی اعداد و شمار کے ساتھ کوشش کرتی ہے۔ ٹرائی کی اہم تجارت اس کی جگہ کی پیچیدگی ہے ، جیسا کہ ہوسکتا ہے۔دوسرے ڈیٹا ڈھانچے کے مقابلے میں زیادہ میموری کی ضرورت ہوتی ہے۔تاہم ، ایسے منظرناموں کے لئے جہاں موثر سٹرنگ کی بازیافت ، سابقہ تلاش ، یا آرڈر شدہ کلیدی کاروائیاں انتہائی اہم ہیں ، ٹرائی اہم فوائد فراہم کرتی ہے۔کوششوں میں سرچ انجن ، مرتب کرنے والے ، ہجے چیکرس ، آئی پی روٹنگ ٹیبلز ، اور کسی بھی منظر نامے جیسے ایپلی کیشنز میں وسیع پیمانے پر استعمال کیا جاتا ہے جس میں تیز سٹرنگ مماثل یا سابقہ پر مبنی آپریشن شامل ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں وعدوں کے تصور کی وضاحت کریں اور ان کو کس طرح متضاد پروگرامنگ کے لئے استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک ہیپ ڈیٹا ڈھانچہ عام طور پر ایسے منظرناموں میں استعمال ہوتا ہے جس میں ترجیحی قطاروں کے موثر انتظام کی ضرورت ہوتی ہے یا زیادہ سے زیادہ یا کم سے کم عنصر جلد تلاش کرنا ہوتا ہے۔یہاں کچھ ایسے حالات ہیں جہاں ہیپ ڈیٹا کا ڈھانچہ خاص طور پر مفید ہے: ترجیحی قطار: ترجیحی قطار کو موثر انداز میں نافذ کرنے کے لئے ڈھیر کا استعمال کیا جاسکتا ہے۔ترجیحی قطار میں ، عناصر کی ترجیحات سے وابستہ ہیں ، اور سب سے زیادہ (یا سب سے کم) ترجیحی عنصر ہمیشہ قطار کے سامنے رہتا ہے۔ڈھیر پر مبنی ترجیحی قطار موثر وقت (O (1)) یا لوگرتھمک وقت (O (لاگ (لاگ (لاگ (لاگ (O (لاگ (O (1)) میں موجودہ اعلی (یا سب سے کم) ترجیحی عنصر کی موثر اضافے ، سب سے زیادہ (یا سب سے کم) ترجیحی عنصر کو ختم کرنے ، اور موجودہ اعلی (یا سب سے کم) ترجیحی عنصر کی بازیافت کی اجازت دیتی ہے۔n)). چھانٹ رہا ہے: ہیپسورٹ ایک جگہ میں ایک موثر جگہ چھنٹائی کرنے والا الگورتھم ہے جو ڈھیر کا استعمال کرتا ہے۔یہ ان پٹ سرنی سے زیادہ سے زیادہ ہیپ (چڑھائی کے آرڈر کے لئے) یا ایک کم ہیپ (نزول آرڈر کے لئے) بنا کر اور ڈھیر سے زیادہ سے زیادہ (یا کم سے کم) عنصر کو بار بار نکال کر کام کرتا ہے۔ہیپسورٹ میں O (n لاگ این) کی وقت کی پیچیدگی ہوتی ہے اور خاص طور پر مفید ہوتا ہے جب میموری کی جگہ محدود ہوتی ہے یا جب سرنی کا سائز بہت بڑا ہوتا ہے۔ شیڈولنگ: ایونٹ سے چلنے والی نقالی یا شیڈولنگ سسٹم میں ، ایک ڈھیر کو برقرار رکھنے کے لئے استعمال کیا جاسکتا ہےان کے مقررہ وقت سے ترتیب دیئے گئے واقعات کا مجموعہ۔اگلے واقعے پر کارروائی کی جائے گی جس کو ڈھیر سے کم سے کم (یا زیادہ سے زیادہ) عنصر نکال کر موثر انداز میں بازیافت کیا جاسکتا ہے۔یہ نقطہ نظر اس بات کو یقینی بناتا ہے کہ واقعات پر ان کے طے شدہ اوقات کی ترتیب میں کارروائی کی جاتی ہے۔ گراف الگورتھم: مختلف گراف الگورتھم میں ڈھیر استعمال کیے جاتے ہیں جن میں کچھ معیارات کی بنیاد پر اگلے عمودی یا ایج کے موثر انتخاب کی ضرورت ہوتی ہے۔مثال کے طور پر ، گراف میں مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کا الگورتھم کم سے کم فاصلے کے ساتھ ورٹیکس کو منتخب کرنے کے لئے ایک کم سے کم استعمال کرتا ہے۔کم سے کم پھیلے ہوئے درخت کی تعمیر کے لئے پرائم کا الگورتھم بھی کم سے کم وزن والے کنارے کو منتخب کرنے کے لئے ڈھیر کا استعمال کرتا ہے۔ میموری مینجمنٹ: متحرک طور پر مختص میموری کو موثر انداز میں منظم کرنے کے لئے میموری مختص نظام میں ڈھیر استعمال کیے جاتے ہیں۔اس تناظر میں ، ڈھیر سے مراد یادداشت کے خطے ہیں جہاں سے میموری کے بلاکس کو مختص کیا جاتا ہے اور ضرورت کے مطابق ان کو ضائع کیا جاتا ہے۔ہیپ ڈیٹا ڈھانچہ مختص اور مفت بلاکس کے بارے میں معلومات کو برقرار رکھتا ہے ، جس سے موثر مختص اور ڈیل لوکیشن کے کاموں کی اجازت ملتی ہے۔ یہ ان حالات کی صرف چند مثالیں ہیں جہاں ہیپ ڈیٹا کا ڈھانچہ فائدہ مند ہے۔جب بھی آپ کو ترجیحات کا موثر انداز میں انتظام کرنے کی ضرورت ہو ، زیادہ سے زیادہ یا کم سے کم عنصر منتخب کریں ، یا ایونٹ کے شیڈولنگ ، چھانٹنے ، یا گراف الگورتھم سے متعلق مسائل کو حل کریں ، تو ایک ڈھیر پر غور کرنے کا ایک طاقتور ذریعہ ہوسکتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں غلطیوں اور استثناء کو کس طرح سنبھالتے ہیں؟کوشش کیچ فائنل بیان کی وضاحت کریں۔",
        "Answer": "متحرک پروگرامنگ ایک مسئلے کو حل کرنے کی ایک تکنیک ہے جو پیچیدہ مسائل کو حل کرنے کے لئے استعمال کی جاتی ہے تاکہ ان کو توڑ ڈالیں اور صرف ایک بار ہر ذیلی مسئلے کو حل کیا جاسکے۔یہ اوورلیپنگ اسٹرکچرز کے ساتھ مسائل کو موثر حل کرنے ، بے کار کمپیوٹوں کو ختم کرنے اور کارکردگی کو بہتر بنانے کی اجازت دیتا ہے۔ متحرک پروگرامنگ کے پیچھے کلیدی خیال یہ ہے کہ چھوٹے چھوٹے پروبلوں کو حل کرکے اور بڑے مسئلے کے حل کے ل these ان ذیلی پروبلوں کے حل کا استعمال کریں۔ذیلی مسائل کے حل عام طور پر کسی ٹیبل یا میموئزیشن سرنی میں محفوظ کیے جاتے ہیں ، جس سے آسانی سے تلاش اور دوبارہ استعمال کی جاسکتی ہے۔ ڈائنیمک پروگرامنگ میں درج ذیل اقدامات شامل ہیں: مسئلہ کی نشاندہی کریں: مسئلے کو سمجھیں اور اس بات کا تعین کریں کہ آیا یہ متحرک پروگرامنگ کے لئے موزوں خصوصیات کی نمائش کرتا ہے۔ان مسائل جن میں زیادہ سے زیادہ ساخت اور اوورلیپنگ سب پروبلوبل شامل ہیں وہ متحرک پروگرامنگ کے لئے اچھے امیدوار ہیں۔ تکرار کے رشتے کو تشکیل دیں: مسئلے کو چھوٹے چھوٹے مضامین میں توڑ دیں اور سب پروبلوبلز کے حل کے لحاظ سے بڑے مسئلے کے حل کا اظہار کریں۔اس تکرار کا رشتہ بڑے مسئلے اور اس کے ذیلی پروبلوبلز کے مابین تعلقات کی وضاحت کرتا ہے۔ بنیادی معاملات کی وضاحت کریں: آسان ترین ذیلی مشکلات کی نشاندہی کریں جو بغیر کسی خرابی کے براہ راست حل ہوسکتے ہیں۔یہ بنیادی معاملات حل کو بڑھانے کے لئے تکرار یا نقطہ اغاز کے لئے ختم ہونے کی حالت فراہم کرتے ہیں۔ حل نیچے یا اوپر سے نیچے کی تعمیر: متحرک پروگرامنگ کو نیچے یا ٹاپ ڈاون نقطہ نظر کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ بوٹوماپ اپروچ (تکراری): بیس معاملات سے ذیلی مسائل کو حل کرنا شروع کریں اور مطلوبہ حل تک پہنچنے تک بڑے ذیلی مسائل کو حل کرکے حل کو بڑھاؤ۔ذیلی خطوط۔بے کار کمپیوٹیشن سے بچنے کے لئے میموئزیشن سرنی یا ٹیبل میں ذیلی خطوں کے حل ذخیرہ کریں۔کسی ذیلی پروبل کو حل کرنے سے پہلے ، چیک کریں کہ آیا اس کا حل پہلے ہی ٹیبل میں دستیاب ہے یا نہیں۔اگر ایسا ہے تو ، ذخیرہ شدہ حل کو دوبارہ تشکیل دینے کے بجائے استعمال کریں۔ حل کو حل کریں: ایک بار جب تمام متعلقہ ذیلی خطوں کے حل کی گنتی کی جائے تو ، اصل مسئلے کا حتمی حل میموزائزیشن ٹیبل یا نیچے کی گنتی کے نتیجے میں نکالا جاسکتا ہے۔متحرک پروگرامنگ ان مسائل کو حل کرنے میں کارآمد ہے جو اوورلیپنگ سب پروبلوبلز کی نمائش کرتے ہیں ، جس سے بولی تکرار کرنے والے نقطہ نظر کے مقابلے میں کارکردگی میں نمایاں بہتری کی اجازت ملتی ہے۔یہ عام طور پر مختلف شعبوں میں استعمال ہوتا ہے جیسے الگورتھم ڈیزائن ، اصلاح ، امتزاج ، نظام الاوقات ، وسائل کی مختص ، اور بہت سے دوسرے مسئلے والے ڈومینز۔متحرک پروگرامنگ الگورتھم کی مثالوں میں فبونیکی تسلسل کی گنتی ، مختصر ترین راستہ الگورتھم ، نیپسیک مسئلہ ، اور بہت کچھ شامل ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں تیر کے فنکشن کیا ہیں؟وہ باقاعدہ افعال سے کیسے مختلف ہیں؟",
        "Answer": "چوڑائی کی پہلی تلاش (بی ایف ایس) اور گہرائی سے پہلے تلاش (ڈی ایف ایس) گراف میں نوڈس کی کھوج یا تلاش کے لئے استعمال ہونے والے دو مشہور گراف ٹراورسل الگورتھم ہیں۔بی ایف ایس اور ڈی ایف ایس کے مابین اہم اختلافات ان کی حکمت عملیوں میں نوڈس اور اس ترتیب میں ہیں جس میں وہ گراف کی کھوج کرتے ہیں۔ بریڈری فرسٹ فرسٹ سرچ (بی ایف ایس): بی ایف ایس کسی دیئے گئے ماخذ سے شروع ہونے والے گراف کو سطح کے لحاظ سے تلاش کرتا ہے۔گہری سطحوں کا دورہ کرنے سے پہلے نوڈ اور باہر کی طرف اپنے پڑوسی نوڈس کی طرف جانا۔ یہ نوڈ ایکسپلوریشن کی ترتیب کو برقرار رکھنے کے لئے ایک قطار کے ڈیٹا ڈھانچے کا استعمال کرتا ہے۔ بی ایف ایس اگلی سطح پر جانے سے پہلے موجودہ سطح پر تمام نوڈس کا دورہ کرتا ہے۔گہری سطح پر نوڈس سے پہلے ملاحظہ کیا جاتا ہے ، جس کے نتیجے میں چوڑائی کی پہلی ریسرچ پیٹرن ہوتا ہے۔ بی ایف ایس بغیر وزن والے گراف میں مختصر ترین راستہ تلاش کرنے کے لئے موزوں ہے کیونکہ یہ ماخذ سے فاصلے کے بڑھتے ہوئے ترتیب میں نوڈس کی کھوج کرتا ہے۔ بی ایف ایس کا پتہ لگانے کے لئے بھی استعمال کیا جاسکتا ہے۔کسی گراف میں یا کسی غیر ہدایت شدہ گراف کے منسلک اجزاء کو تلاش کرنے کے لئے۔ بی ایف ایس کی وقت کی پیچیدگی O (v + e) ہے ، جہاں v عمودی کی تعداد ہے اور E گراف میں کناروں کی تعداد ہے۔ڈی ایف ایس): ڈی ایف ایس نے بیک ٹریکنگ سے پہلے ہر شاخ کے ساتھ جہاں تک ممکن ہو ٹریورنگ کرکے گراف کی کھوج کی۔ اس میں نوڈس کو تلاش کرنے کے لئے ٹریک (یا تکرار) کا استعمال کیا جاتا ہے۔گراف کی ایک شاخ جب تک قریب ترین غیر تلاش شدہ نوڈ پر بیک ٹریک کرنے سے پہلے کسی پتے کے نوڈ تک نہیں پہنچتی۔ ڈی ایف ایس راستوں کی تلاش اور ایسے حل تلاش کرنے کے لئے مفید ہے جس میں گراف کے ڈھانچے میں گہری تلاش کرنا شامل ہوتا ہے۔ یہ سب سے کم راہ کی ضمانت نہیں دے سکتا ہے کیونکہ یہ پہلے گہری سطح کی کھوج کرتا ہے۔ڈی ایف ایس کا استعمال اس بات کا تعین کرنے کے لئے کیا جاسکتا ہے کہ آیا دو نوڈس کے مابین کوئی راستہ موجود ہے ، کسی چکر کے وجود کی جانچ پڑتال کے لئے ، یا کسی درخت یا گراف کو عبور کرنے کے لئے۔ ڈی ایف ایس کی وقت کی پیچیدگی بھی O (V + E) ہے ، جہاں V ہےعمودی اور ای کی تعداد گراف میں کناروں کی تعداد ہے۔ خلاصہ۔ بی ایف ایس گراف کی سطح کو سطح کے لحاظ سے تلاش کرتا ہے ، جبکہ ڈی ایف ایس ہر شاخ کے ساتھ گہری گراف کی کھوج کرتا ہے۔بی ایف ایس غیر وزن والے گراف میں مختصر ترین راستے کی ضمانت دیتا ہے اور منسلک اجزاء کی تلاش جیسے ایپلی کیشنز کے لئے مفید ہے ، جبکہ ڈی ایف ایس راستوں کی تلاش اور سائیکلوں کے وجود کو جانچنے کے لئے موزوں ہے۔بی ایف ایس اور ڈی ایف ایس کے درمیان انتخاب مخصوص مسئلے اور درخواست کی ضروریات پر منحصر ہے۔"
    },
    {
        "Question": "\"آپ جاوا اسکرپٹ میں متضاد پروگرامنگ کو کس طرح سنبھالتے ہیں؟ کال بیکس ، وعدوں ، اور async/انتظار کے استعمال کی وضاحت کریں۔\"",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ مہنگے فنکشن کالوں کی گنتی کو بہتر بنانے کے لئے ان کے نتائج کو بہتر بنایا جاسکے اور جب وہی ان پٹ دوبارہ ہوتا ہے تو ان کو دوبارہ استعمال کرتے ہوئے ان کا دوبارہ استعمال کرتے ہیں۔اس میں اعداد و شمار کے ڈھانچے میں فنکشن کالز کے نتائج کو ذخیرہ کرنا شامل ہے ، عام طور پر کسی سرنی یا ہیش ٹیبل میں ، تاکہ اسی آدانوں کے ساتھ بعد میں آنے والی کالیں اس کو دوبارہ تشکیل دینے کے بجائے براہ راست پیشگی نتیجہ بازیافت کرسکیں۔ متحرک پروگرامنگ کے تناظر میں ، میمورائزیشن عام طور پر ہوتی ہے۔recursive الگورتھم کے ساتھ استعمال کیا جاتا ہے جو اوورلیپنگ سب پروبلوبلز کی نمائش کرتے ہیں۔اس سے حل شدہ ذیلی مسائل کے نتائج کو ذخیرہ کرکے اور ہر بار جب ان کا سامنا کرنا پڑتا ہے اس کی دوبارہ گنتی کرنے کی بجائے ان کو تلاش کرنے میں بے کار کمپیوٹوں کو ختم کرنے میں مدد ملتی ہے۔ یہاں کہ میموری کو عام طور پر متحرک پروگرامنگ میں کس طرح استعمال کیا جاتا ہے: ذیلی پروبلوں کی شناخت کریں: اس مسئلے کو چھوٹے چھوٹے ذیلی خطوں میں توڑ دیں جو اوورلیپنگ کی نمائش کرتے ہیں۔خصوصیاتیہ ذیلی خطوط اسی مسئلے کی چھوٹی چھوٹی مثالوں میں ہونے چاہئیں۔ میموائزیشن کے اعداد و شمار کے ڈھانچے کی وضاحت کریں: حل شدہ ذیلی پروبلز کے نتائج کو ذخیرہ کرنے کے لئے ڈیٹا ڈھانچہ ، جیسے سرنی یا ہیش ٹیبل کو ترتیب دیں۔فنکشن یا سب پروبلوبل کے آدانوں کے ذریعہ اس ڈھانچے کو ترتیب دیا جانا چاہئے یا اس کی کلید کی جانی چاہئے۔ تکرار کرنے والی تقریب: ایک بار بار چلنے والا فنکشن لکھیں جو ہر ذیلی پروبل کو حل کرتا ہے اور نتائج کو ذخیرہ کرنے اور بازیافت کرنے کے لئے میموائزیشن کا استعمال کرتا ہے۔کسی ذیلی پروبل کی گنتی سے پہلے ، چیک کریں کہ آیا اس کا نتیجہ پہلے سے ہی میمورائزیشن کے ڈھانچے میں موجود ہے یا نہیں۔اگر ایسا ہے تو ، ذخیرہ شدہ نتیجہ کو دوبارہ تشکیل دینے کے بجائے واپس کریں۔ بیس کیسز کو روکنے کے بجائے: بیس مقدمات کی وضاحت کریں یا تکرار کے لئے شرائط ختم کریں۔یہ عام طور پر سب سے چھوٹی ذیلی مسائل ہیں جو مزید خرابی کے بغیر براہ راست حل کی جاسکتی ہیں۔ان کے نتائج کو میمورائزیشن کے ڈھانچے میں بھی اسٹور کریں۔ تکرار کرنے والی تقریب کو شامل کریں: اصل مسئلے کے آدانوں کے ساتھ تکرار کرنے والے فنکشن کا مطالبہ کریں ، جس سے اس سے چھوٹے چھوٹے مضامین کو بار بار حل کرکے مسئلے کو حل کیا جاسکے۔جب دستیاب ہو تو فنکشن بے کار کمپیوٹوں سے بچنے اور پہلے سے موجود نتائج کو بازیافت کرنے کے لئے میموائزیشن کا استعمال کرے گا۔ میموئزیشن بے کار کمپیوٹیشن کو ختم کرکے متحرک پروگرامنگ الگورتھم کی وقت کی پیچیدگی کو کم کرنے میں مدد کرتا ہے۔نتائج کیچنگ اور دوبارہ استعمال کرنے سے ، یہ مجموعی کارکردگی کو نمایاں طور پر بہتر بنا سکتا ہے ، خاص طور پر جب مسئلہ اوورلیپنگ اسٹرکچرز کی نمائش کرتا ہے۔ یہ بات اہم ہے کہ یادداشت متحرک پروگرامنگ کے لئے مخصوص نہیں ہے اور دوسرے سیاق و سباق میں بھی اس کا اطلاق ہوسکتا ہے۔یہ ایک عام تکنیک ہے جو کسی بھی مہنگے یا بار بار فنکشن کالوں کی گنتی کو بہتر بنانے کے لئے استعمال ہوتی ہے جو ان کے نتائج کو اسٹور کرکے اور دوبارہ استعمال کرکے استعمال کرتی ہے۔تاہم ، یہ خاص طور پر متحرک پروگرامنگ میں فائدہ مند ہے کیونکہ اس کی وجہ سے اوورلیپنگ سب پروبلوبلز کو مؤثر طریقے سے سنبھالنے کی صلاحیت ہے۔"
    },
    {
        "Question": "\"جاوا اسکرپٹ میں لیٹ ، کانسٹ ، اور وی آر میں کیا فرق ہے؟ آپ ہر ایک کو کب استعمال کریں گے؟\"",
        "Answer": "یقینا!ایک سرخ رنگ کا درخت ایک خود متوازن بائنری سرچ درخت ہے جو خصوصیات کے ایک سیٹ کو نافذ کرکے توازن کو برقرار رکھتا ہے۔اس کا نام درخت میں ہر نوڈ کو تفویض کردہ رنگ کے نام پر رکھا گیا ہے: سرخ یا سیاہ۔سرخ رنگ کے درخت کی خصوصیات مندرجہ ذیل ہیں: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ کا نوڈ ہمیشہ سیاہ ہوتا ہے۔ ہر پتی (کال) نوڈ سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔ ہر راستہ۔نوڈ سے اس کی اولاد پتی نوڈس میں سیاہ نوڈس کی مساوی تعداد ہوتی ہے۔اس پراپرٹی کو بلیک اونچائی پراپرٹی یا بلیک بیلنس کہا جاتا ہے۔ ان خصوصیات پر عمل پیرا ہونے کے بعد ، ایک سرخ رنگ کا درخت اس بات کو یقینی بناتا ہے کہ جڑ سے کسی بھی پتے تک کا لمبا ترین راستہ مختصر ترین راستے کی لمبائی سے دوگنا نہیں ہوتا ہے ، جس کے نتیجے میں متوازن ہوتا ہے۔درخت۔ سرخ رنگ کے درخت پر انجام دیئے گئے آپریشن ، جیسے اندراج اور حذف کرنا ، درخت کی خصوصیات کو برقرار رکھنا شامل ہے۔یہاں یہ ایک مختصر جائزہ ہے کہ یہ آپریشن کس طرح کام کرتے ہیں: اندراج: نئے نوڈس کو ابتدائی طور پر ریڈ نوڈس کے طور پر داخل کیا جاتا ہے۔ اس کے بعد ، اگر کسی جائیداد کی خلاف ورزی ہوتی ہے تو ، توازن کو بحال کرنے اور تعلقات کو برقرار رکھنے کے لئے درختوں کی گردش اور رنگ کی تبدیلیاں لاگو ہوتی ہیں۔نوڈس کے درمیان ، مختلف معاملات پیدا ہوسکتے ہیں جس میں توازن برقرار رکھنے کے لئے مخصوص گردش اور رنگ کی تبدیلیوں کی ضرورت ہوتی ہے۔ ذخیرہ: جب نوڈ کو حذف کیا جاتا ہے تو ، اسے یا تو اپنے پیش رو یا جانشین نوڈ کے ساتھ تبدیل کیا جاتا ہے۔ اندراج کے عمل کی وجہ سے ، اگر کسی بھی خصوصیات کی خلاف ورزی کی جاتی ہے تو ، گردشوں کی خلاف ورزی ہوتی ہے۔توازن کو بحال کرنے کے لئے رنگین تبدیلیاں کی جاتی ہیں۔ حذف کے دوران مختلف معاملات پیدا ہوسکتے ہیں ، جیسے کسی سیاہ نوڈ کو حذف کرنا ، جس میں پراپرٹیز کو برقرار رکھنے کے لئے اضافی ایڈجسٹمنٹ کی ضرورت پڑسکتی ہے۔ سرخ رنگ کے درخت میں گردش کی کارروائیوں میں ایڈجسٹ کرکے توازن برقرار رکھنے میں مدد ملتی ہے۔نوڈس کی پوزیشنیں۔گردش کی دو اقسام ہیں: بائیں گردش: اس میں اس کی اصل پوزیشن کا بائیں بچہ بننے کے لئے اپنے دائیں بچے کی پوزیشن سے نوڈ منتقل کرنا شامل ہے۔اس سے درخت کو متوازن کرنے میں مدد ملتی ہے جب دائیں سب ٹری بائیں سب ٹری سے لمبا ہوجاتی ہے۔ رائٹ گردش: اس میں اس کی اصل پوزیشن کا دائیں بچہ بننے کے لئے اپنے بائیں بچے کی پوزیشن سے نوڈ منتقل کرنا شامل ہے۔اس سے درخت کو متوازن کرنے میں مدد ملتی ہے جب بائیں سب ٹری دائیں سب ٹری سے لمبا ہوجاتی ہے۔ گردشوں اور رنگ کی تبدیلیاں انجام دینے کے ساتھ ساتھ ، اندراج اور حذف کرنے کے دوران ، ایک سرخ رنگ کا درخت توازن برقرار رکھتا ہے اور موثر تلاش ، اندراج اور حذف کرنے کی کارروائیوں کو یقینی بناتا ہے۔سرخ رنگ کے درخت میں ان کارروائیوں کے لئے بدترین وقت کی پیچیدگی O (لاگ این) ہے ، جہاں درخت میں نوڈس کی تعداد ہے۔ نیچے سیاہ درخت عام طور پر مختلف ایپلی کیشنز میں استعمال ہوتے ہیں جن میں موثر اور متوازن تلاش کے درختوں کی ضرورت ہوتی ہے۔، جیسے ان میموری ڈیٹا بیس ، زبان کے مرتب کرنے والے ، اور ڈیٹا ڈھانچے جیسے سیٹ ، نقشے ، اور وقفہ کے درخت۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں لغوی اسکوپنگ کے تصور کی وضاحت کریں اور یہ کہ کس طرح متغیر مرئیت کو متاثر کرتا ہے۔",
        "Answer": "ترجیحی قطار ایک تجریدی ڈیٹا کی قسم ہے جو عناصر کا مجموعہ محفوظ کرتی ہے ، ہر ایک ترجیح سے وابستہ ہے۔ترجیح مجموعہ کے اندر کسی عنصر کی نسبت کی اہمیت یا عجلت کی نشاندہی کرتی ہے۔اعلی ترجیح کے حامل عناصر کو زیادہ اہم سمجھا جاتا ہے اور کم ترجیح والے عناصر سے پہلے بازیافت یا اس پر کارروائی کی جاتی ہے۔ ترجیحی قطار کے ذریعہ تعاون یافتہ اہم کاروائیاں یہ ہیں: اندراج: عنصر کی ترجیح کی بنیاد پر آرڈر کو برقرار رکھتے ہوئے ترجیحی قطار میں عنصر شامل کرتا ہے۔نیا عنصر مناسب پوزیشن میں رکھا گیا ہے تاکہ یہ یقینی بنایا جاسکے کہ اعلی ترجیح کے حامل عناصر قطار کے سامنے کے قریب ہیں۔ لالچ: یہ عنصر کو ترجیحی قطار سے اعلی ترجیح کے ساتھ ہٹاتا ہے اور واپس کرتا ہے۔اعلی ترجیح والا عنصر عام طور پر قطار کے سامنے واقع ہوتا ہے۔ مختلف اعداد و شمار کے ڈھانچے کا استعمال کرتے ہوئے ترجیحی قطار نافذ کی جاسکتی ہے ، لیکن دو عام طور پر استعمال ہونے والے نفاذ یہ ہیں: بائنری ہیپ: ایک بائنری ہیپ ایک مکمل بائنری درخت ہے جو ہیپ پراپرٹی کو پورا کرتا ہے۔بائنری ڈھیر میں ، والدین نوڈ کی ترجیح ہمیشہ اپنے بچوں کی ترجیحات سے زیادہ یا اس کے برابر ہوتی ہے۔یہ پراپرٹی اس بات کو یقینی بناتی ہے کہ اعلی ترجیحی عنصر ڈھیر کی جڑ میں واقع ہے۔بائنری ڈھیروں کو مؤثر طریقے سے اریوں کے طور پر نافذ کیا جاسکتا ہے۔ متوازن سرچ درخت: متوازن سرچ درخت ، جیسے سرخ رنگ کا درخت یا اے وی ایل درخت ، ترجیحی قطار کو نافذ کرنے کے لئے بھی استعمال کیا جاسکتا ہے۔عناصر درخت میں درخت کے متوازن ڈھانچے کو برقرار رکھتے ہوئے موثر داخل کرنے اور حذف کرنے کی کارروائیوں کی اجازت دیتے ہیں۔ عمل درآمد کا انتخاب درخواست کی مخصوص ضروریات پر منحصر ہے۔بائنری ہیپس عام طور پر بنیادی کارروائیوں جیسے اندراج اور حذف (O (لاگ این)) کے لئے بہتر وقت کی پیچیدگی فراہم کرتے ہیں ، جبکہ متوازن تلاش کے درخت O (لاگ این) وقت میں عنصر کی تلاش جیسے زیادہ لچک اور اضافی آپریشن فراہم کرتے ہیں۔مختلف ایپلی کیشنز جہاں عناصر کو اپنی ترجیحات کی بنیاد پر کارروائی کرنے کی ضرورت ہے۔کچھ مثالوں میں ٹاسک شیڈولنگ ، ایونٹ سے چلنے والی نقالی ، گراف الگورتھم (جیسے ، ڈجکسٹرا کا الگورتھم) ، ڈیٹا کمپریشن الگورتھم (جیسے ، ہف مین کوڈنگ) ، اور وسائل مختص الگورتھم شامل ہیں۔ترجیحی قطاریں ترجیحات کے موثر انتظام کی اجازت دیتی ہیں اور اس بات کو یقینی بناتی ہیں کہ پہلے اعلی ترجیحی عناصر پر عملدرآمد کیا جائے ، جس سے موثر اور بہتر مسئلے کو حل کرنے میں مدد ملے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں ڈوم (دستاویز آبجیکٹ ماڈل) کو کس طرح جوڑ توڑ کرتے ہیں؟ڈوم ہیرا پھیری کی کارروائیوں کی مثالیں فراہم کریں۔",
        "Answer": "بلبلا ترتیب والا الگورتھم ایک سادہ چھانٹنے والا الگورتھم ہے جو بار بار فہرست میں قدم رکھتا ہے ، ملحقہ عناصر کا موازنہ کرتا ہے ، اور اگر وہ غلط ترتیب میں ہیں تو ان کو تبدیل کرتا ہے۔اس عمل کو اس وقت تک دہرایا جاتا ہے جب تک کہ فہرست ترتیب نہ دی جائے۔یہاں آپ سیوڈوکوڈ میں بلبلا ترتیب والے الگورتھم کو کس طرح نافذ کرسکتے ہیں: vbnetcopy کوڈ پروسیڈور بلبلسورٹ (فہرست) n: = لمبائی (فہرست) 0 سے N-1 سے J کے لئے 0 سے N-1-I تک اگر فہرست [j]> فہرست [J+1] پھر تبادلہ (فہرست [j] ، فہرست [j+1]) اختتام کے اختتام پر اختتام پر عمل کے اختتام پر الگورتھم کا ایک مرحلہ بہ قدم خرابی: عناصر کی غیر ترتیب شدہ فہرست کے ساتھ شروع کریں۔فہرست N-1 بار ، جہاں N فہرست کی لمبائی ہے۔اس بات کو یقینی بناتا ہے کہ ہر ایک تکرار میں فہرست کے آخر تک سب سے بڑا عنصر \"بلبل\" بناتا ہے۔ ہر تکرار میں ، فہرست کے آغاز سے شروع ہونے والے ملحقہ عناصر کا موازنہ کریں۔اگر موجودہ عنصر اگلے عنصر سے زیادہ ہے تو ، ان کو تبدیل کریں۔ ملحقہ عناصر کے ہر جوڑے کے لئے فہرست کے اختتام تک اس عمل کو تبدیل کریں۔ ہر تکرار کے بعد ، سب سے بڑے عنصر کو فہرست کے آخر میں ہونے کی ضمانت دی جاتی ہے۔ ان پر عمل کریں۔تکرارات جب تک پوری فہرست کو ترتیب نہیں دیا جاتا ہے۔ بلبلا ترتیب والے الگورتھم کی وقت کی پیچیدگی O (n^2) ہے ، جہاں فہرست میں عناصر کی تعداد ہے۔یہ بڑی فہرستوں کے ل it اسے غیر موثر بنا دیتا ہے۔تاہم ، بلبلے کی طرح کو سمجھنے اور اس پر عمل درآمد کرنے کے لئے آسان ہونے کا فائدہ ہے۔ نوٹ: عملی طور پر ، بلبلا کی طرح کی کارکردگی کی وجہ سے بڑی فہرستوں کو چھانٹنے کے لئے شاذ و نادر ہی استعمال کیا جاتا ہے۔زیادہ موثر ترتیب دینے والے الگورتھم جیسے فوری ترتیب ، انضمام کی ترتیب ، یا ڈھیر ترتیب کو بڑے ڈیٹاسیٹس کے لئے ترجیح دی جاتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں ایونٹ کا وفد کیا ہے؟یہ کیسے کام کرتا ہے اور اس کے کیا فوائد ہیں؟",
        "Answer": "ایک واحد منسلک فہرست اور دوگنا منسلک فہرست کے درمیان بنیادی فرق ہر نوڈ کے پاس موجود حوالوں کی تعداد میں ہے۔ان دونوں کا موازنہ یہاں ہے: اکیلے لنکڈ لسٹ: واحد منسلک فہرست میں ہر نوڈ میں دو فیلڈز شامل ہیں: فہرست میں اگلے نوڈ کا ڈیٹا اور ایک حوالہ (یا پوائنٹر)۔ نوڈس غیر مستقیم انداز میں جڑے ہوئے ہیں ، جہاں ہر نوڈ پوائنٹساگلے نوڈ پر۔ فہرست میں آخری نوڈ NULL کی طرف اشارہ کرتا ہے ، فہرست کے اختتام کی نشاندہی کرتا ہے۔ فہرست کو آگے بڑھانا صرف ایک آگے کی سمت میں کیا جاسکتا ہے ، سر (پہلے نوڈ) سے شروع ہوتا ہے ۔مشار اور حذف کرنے کی کارروائییں ہوسکتی ہیں۔فہرست کے آغاز یا اختتام پر موثر انداز میں کارکردگی کا مظاہرہ کیا ، لیکن وہ وسط میں کم موثر ہیں کیونکہ اس کو سر سے سفر کرنے کی ضرورت ہوتی ہے۔ بڑی حد تک منسلک فہرستوں کو دوگنا منسلک فہرستوں کے مقابلے میں کم میموری کی ضرورت ہوتی ہے کیونکہ وہ صرف ایک ہی حوالہ فی نوڈ کو اسٹور کرتے ہیں۔فہرستیں کم وسائل کو نافذ کرنے اور استعمال کرنے کے لئے آسان ہیں۔ ڈولی سے منسلک فہرست: دوگنا منسلک فہرست میں ہر نوڈ میں تین فیلڈز شامل ہیں: ڈیٹا ، اگلے نوڈ کا حوالہ ، اور پچھلے نوڈ کا حوالہ۔ نوڈس دو طرفہ انداز میں جڑے ہوئے ہیں ،جہاں ہر نوڈ کے پاس اگلے اور پچھلے دونوں نوڈس کا حوالہ ہوتا ہے۔ پہلا نوڈ کا پچھلا حوالہ اور آخری نوڈ کا اگلا حوالہ نول سے ہوتا ہے ، جس میں فہرست کی حدود کی نشاندہی ہوتی ہے۔ فہرست کو آگے بڑھانا آگے اور پسماندہ دونوں سمتوں میں کیا جاسکتا ہے ، جس کی اجازت دی جاسکتی ہے۔عناصر تک رسائی میں لچک کے ل .۔ فہرست میں کسی بھی پوزیشن پر داخل اور حذف کرنے کی کارروائیوں کو موثر انداز میں انجام دیا جاسکتا ہے کیونکہ پچھلے اور اگلے حوالوں سے ہمسایہ نوڈس میں آسانی سے ترمیم کرنے کی اجازت ہے۔اکیلے لنکڈ فہرستوں کے مقابلے میں میموری سے متعلق۔اکیلے لنکڈ فہرستیں اکثر آسان منظرناموں کے لئے کافی ہوتی ہیں جہاں صرف فارورڈ ٹراورسل کی ضرورت ہوتی ہے اور میموری کی کارکردگی ایک تشویش ہے۔دوگنا منسلک فہرستیں افضل ہیں جب پسماندہ ٹریورسل ، وسط میں موثر اندراج/حذف کرنے ، یا اس سے زیادہ جدید کارروائیوں کی ضرورت ہوتی ہے ، میموری کے تھوڑا سا استعمال اور اضافی پیچیدگی کی قیمت پر۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں فارم کی توثیق کو کس طرح سنبھالتے ہیں؟فارم کی توثیق کی تکنیک کی مثالیں فراہم کریں۔",
        "Answer": "ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی کا انحصار مخصوص نفاذ اور تصادم کی موجودگی پر ہوتا ہے۔اوسط صورت میں ، ایک اچھی طرح سے تقسیم شدہ ہیش فنکشن اور کم بوجھ عنصر کے ساتھ ، ہیش ٹیبل میں تلاش کرنے کی وقت کی پیچیدگی O (1) ، یا مستقل وقت ہے۔ یہاں تلاش کرنا ایک خرابی ہے کہ عام طور پر ہیش ٹیبل میں کس طرح کام کرتا ہے:جس عنصر کی تلاش کی جائے اس کی کلید ہیش فنکشن کا استعمال کرتے ہوئے ہیش کی جاتی ہے۔ہیش فنکشن ہیش ٹیبل کے بنیادی سرنی ڈھانچے میں انڈیکس کی کلید کا نقشہ بناتا ہے۔ اگر کوئی تصادم نہیں ہوتا ہے (یعنی ایک ہی انڈیکس میں ایک سے زیادہ چابیاں میپنگ کرتے ہیں) تو ، مطلوبہ عنصر کمپیوٹڈ انڈیکس پر پایا جاتا ہے۔تصادم ہیں ، ان کو حل کرنے کے لئے اضافی اقدامات کی ضرورت ہے: الف۔ایک علیحدہ زنجیروں کے تصادم کی قرارداد کے طریقہ کار میں ، سرنی کے ہر انڈیکس میں ایک منسلک فہرست یا کچھ اور ڈیٹا ڈھانچہ ہوتا ہے جس میں متعدد عناصر ہوتے ہیں جو ایک ہی انڈیکس میں شامل ہوتے ہیں۔اس معاملے میں ، مطلوبہ عنصر کو تلاش کرنے کے لئے لنکڈ فہرست میں ایک لکیری تلاش یا کوئی اور موثر سرچ آپریشن انجام دیا جاتا ہے۔لنکڈ فہرست میں تلاش کی وقت کی پیچیدگی عام طور پر O (K) ہوتی ہے ، جہاں K فی انڈیکس ڈاٹ بی کے عناصر کی اوسط تعداد ہوتی ہے۔کھلے عام تصادم کے حل کے طریقوں (جیسے لکیری تحقیقات ، چوکور تحقیقات ، یا ڈبل ہیشنگ) میں ، تلاش جاری رہتی ہے جب تک کہ کسی پہلے سے طے شدہ الگورتھم کی بنیاد پر اگلے دستیاب انڈیکس کی جانچ پڑتال کی جاتی ہے جب تک کہ مطلوبہ عنصر نہیں مل جاتا یا خالی سلاٹ کا سامنا نہیں ہوتا ہے۔کھلے عام خطاب کرنے کے طریقوں میں تلاش کی وقت کی پیچیدگی کا انحصار مخصوص تحقیقات الگورتھم اور ہیش ٹیبل کے بوجھ عنصر پر ہوتا ہے۔کم بوجھ عنصر کے ساتھ ، بہترین صورتحال میں ، تلاش O (1) کے قریب ہوسکتی ہے۔تاہم ، بدترین صورت میں ، جب بوجھ کا عنصر زیادہ ہوتا ہے اور بہت ساری تحقیقات کی ضرورت ہوتی ہے تو ، وقت کی پیچیدگی O (n) کے قریب آسکتی ہے ، جہاں ہیش ٹیبل میں عناصر کی تعداد ہوتی ہے۔ایک ہیش ٹیبل میں ، ایک اچھی طرح سے تقسیم شدہ ہیش فنکشن اور کم بوجھ عنصر کو فرض کرتے ہوئے ، O (1) ہے۔تاہم ، تصادم کی موجودگی اور تصادم کے حل کے مخصوص طریقہ کار پر غور کرنا ضروری ہے ، کیونکہ وہ بدترین وقت کی پیچیدگی کو متاثر کرسکتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں اعلی آرڈر کے افعال کے تصور کی وضاحت کریں اور ان کے استعمال کی مثالیں فراہم کریں۔",
        "Answer": "ایک سرکلر بفر ، جسے سرکلر قطار یا رنگ بفر کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ایک سرکلر ، مسلسل اسٹوریج ایریا کے طور پر ایک مقررہ سائز کا بفر استعمال کرتا ہے۔اس کو ایک مقررہ صلاحیت اور دو پوائنٹرز کے ساتھ ایک صف کے طور پر نافذ کیا جاتا ہے ، ایک بفر (سامنے) کے آغاز کی طرف اشارہ کرتا ہے اور دوسرا بفر (عقبی) کے اختتام کی طرف اشارہ کرتا ہے۔ سرکلر بفر کی کلیدی خصوصیات اور فوائد مندرجہ ذیل ہیں۔: لپیٹنے والا سلوک: سرکلر بفر جب بفر کے اختتام تک پہنچ جاتا ہے تو اس کے گرد لپیٹ جاتا ہے ، مؤثر طریقے سے ایک سرکلر یا چکرمک نوعیت پیدا کرتا ہے۔اس کا مطلب یہ ہے کہ اگر عقبی پوائنٹر بفر کے اختتام تک پہنچ جاتا ہے تو ، یہ بفر کے آغاز تک لپیٹتا ہے ، جس سے دستیاب جگہ کے موثر استعمال کی اجازت ملتی ہے۔سرکلر بفر مستقل وقت (O (1)) میں بفر کے سائز سے قطع نظر انجام دیا جاسکتا ہے۔یہ ممکن ہے کیونکہ لپیٹے ہوئے سلوک سے عناصر کی مہنگی تبدیلی کی ضرورت ختم ہوجاتی ہے۔ قابل جگہ جگہ کے استعمال: لکیری بفرز یا صفوں کے برعکس ، ایک سرکلر بفر کسی بھی سلاٹ کو ضائع کیے بغیر دستیاب جگہ کو موثر انداز میں استعمال کرسکتا ہے۔یہ خاص طور پر ایسے منظرناموں میں مفید ہے جہاں بفر کا سائز طے ہوتا ہے ، اور جب بفر مکمل ہوتا ہے تو قدیم ترین عناصر اوور رائٹ ہوجاتے ہیں۔اس سے وہ میموری سے مجسم ماحول کے ل suitable موزوں بناتے ہیں جہاں متحرک میموری کی مختص محدود ہے یا مطلوبہ نہیں ہے۔ اسٹریمنگ اور ریئل ٹائم ایپلی کیشنز کے لئے استعمال شدہ: سرکلر بفر عام طور پر ایسے منظرناموں میں استعمال ہوتے ہیں جہاں ڈیٹا کو مستقل طور پر کارروائی یا اسٹریم کرنے کی ضرورت ہوتی ہے۔وہ مختلف نرخوں اور سائز کے ڈیٹا اسٹریمز کو سنبھالنے کے ل well مناسب ہیں ، جس سے موثر بفرنگ اور پروسیسنگ کی اجازت ملتی ہے۔ آسانیاں: سرکلر بفرز کو عملی جامہ پہنانے اور سمجھنے کے لئے نسبتا simple آسان ہے ، جس میں صرف سرنی اشاریہ سازی اور پوائنٹر ہیرا پھیری کے بنیادی علم کی ضرورت ہوتی ہے۔مختلف ڈومینز ، بشمول ایمبیڈڈ سسٹم ، ریئل ٹائم ڈیٹا پروسیسنگ ، آڈیو اور ویڈیو اسٹریمنگ ، نیٹ ورک پروٹوکول ، اور بہت کچھ۔وہ ڈیٹا کے بہاؤ کو سنبھالنے اور ڈیٹا کے مستقل سلسلوں کی ہموار پروسیسنگ کی سہولت فراہم کرنے کے لئے ایک موثر اور قابل اعتماد طریقہ فراہم کرتے ہیں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں ایجیکس کی درخواستیں کیسے کرتے ہیں؟XMLHTTPrequest کے استعمال کی وضاحت کریں اور API بازیافت کریں۔",
        "Answer": "متوازن تلاش کے درختوں کے تناظر میں ، سست لوڈنگ سے مراد ایک ایسی تکنیک ہے جہاں نوڈ کے اعداد و شمار یا قدر کی اصل گنتی یا بازیافت اس وقت تک موخر کردی جاتی ہے جب تک کہ اس کی واضح طور پر درخواست نہ کی جائے۔تعمیر یا اضافے کے دوران درخت میں تمام نوڈس کے لئے اقدار کو پیش کرنے اور ذخیرہ کرنے کے بجائے ، اقدار صرف اس وقت بھری ہوئی یا حساب کی جاتی ہیں جب ضروری ہو۔ لیزی لوڈنگ خاص طور پر منظرناموں میں مفید ثابت ہوسکتی ہے جہاں نوڈ کی قیمت کی گنتی یا بازیافت مہنگا یا وسائل ہے۔گہریجب تک اس کی ضرورت نہ ہو اس وقت تک لوڈنگ کو موخر کرنے سے ، غیر ضروری کمپیوٹیشن یا بازیافتوں سے بچا جاسکتا ہے ، ممکنہ طور پر وقت اور وسائل کی بچت ہوتی ہے۔ جب سست لوڈنگ کو متوازن سرچ درخت پر لگایا جاتا ہے ، جیسے AVL درخت یا سرخ سیاہ درخت ، میں نوڈسدرخت عام طور پر اصل قدر کو براہ راست ذخیرہ کرنے کے بجائے کلید اور قدر کے حوالے سے ذخیرہ کرتا ہے۔نوڈ سے وابستہ قدر صرف اس وقت حاصل کی جاتی ہے یا اس کی گنتی کی جاتی ہے۔ یہاں متوازن سرچ درخت میں سست لوڈنگ کے تصور کو واضح کرنے کے لئے ایک مثال کا منظر ہے: فرض کیج. ہمارے پاس متوازن سرچ ٹری ہے جو طلباء کے بارے میں معلومات کو محفوظ کرتا ہے ، جہاں ہر نوڈ طالب علم کی نمائندگی کرتا ہے۔اور طالب علم کی شناخت (کلید) اور طالب علم کے گریڈ (ویلیو) کو اسٹور کرتا ہے۔ درخت کی تعمیر کرتے وقت تمام طلباء کے درجات کو لوڈ کرنے اور اسٹور کرنے کے بارے میں ، ہم سست لوڈنگ کا استعمال کرتے ہیں۔ہر نوڈ میں صرف طالب علم کے درجات کا حوالہ ہوتا ہے ، بجائے اس کے کہ اصل گریڈ کے بجائے۔ جب درخت پر تلاش یا بازیافت کا کام انجام دیا جاتا ہے ، اور ایک مخصوص طالب علم کے درجات کی درخواست کی جاتی ہے تو ، سست لوڈنگ کھیل میں آجاتی ہے۔صرف اس مقام پر ، گریڈ کے بارے میں نوڈ کے حوالہ کی پیروی کی جاتی ہے ، اور اصل درجات کو بھری ہوئی یا اس کی گنتی کی جاتی ہے۔ سست لوڈنگ میکانزم اس بات کو یقینی بناتا ہے کہ جب ضروری ہو تو گریڈ کی گنتی یا بازیافت صرف اس وقت انجام دی جاتی ہے ، غیر ضروری گنتی اور وسائل کو کم سے کم کرتے ہوئے۔ استعمال کرتے ہوئے۔ استعمال کرتے ہوئے۔متوازن سرچ درخت میں سست لوڈنگ ، ہم میموری کے نقش کو کم کرسکتے ہیں اور ان کارروائیوں کی کارکردگی کو بہتر بناسکتے ہیں جس میں نوڈ کی اقدار تک رسائی کی ضرورت نہیں ہوتی ہے۔صرف اس صورت میں جب اقدار کی واضح طور پر درخواست کی جاتی ہے ، ان کو لوڈ یا حساب کتاب کیا جاتا ہے ، جس سے آن ڈیمانڈ کی بازیافت یا حساب کتاب کی اجازت مل جاتی ہے۔ یہ بات اہم ہے کہ سست لوڈنگ متوازن سرچ درخت کے نفاذ میں کچھ پیچیدگی کا اضافہ کرتی ہے ، کیونکہ اس میں اقدار کی بوجھ کو سنبھالنے کی ضرورت ہوتی ہے۔اور ان حالات کو سنبھالنا جہاں توقع کے وقت اقدار دستیاب نہ ہوں۔تاہم ، جب مناسب طریقے سے لاگو ہوتا ہے تو ، سست لوڈنگ منظرناموں میں ایک قیمتی اصلاح کی تکنیک ہوسکتی ہے جہاں اقدار کی گنتی یا بازیافت مہنگی ہوتی ہے اور بیک وقت تمام اقدار کی ضرورت نہیں ہوتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں صفوں کو لوپ کرنے کے مختلف طریقے کیا ہیں؟ہر طریقہ کی مثالیں فراہم کریں۔",
        "Answer": "ریڈکس ترتیب ایک لکیری ٹائم چھانٹ رہا الگورتھم ہے جو ان کے انفرادی ہندسوں یا ریڈکس کی بنیاد پر عناصر کو ترتیب دیتا ہے۔یہ عناصر کو ہر ہندسے کی قدر کی بنیاد پر بالٹیوں کے ایک سیٹ میں تقسیم کرکے کام کرتا ہے ، کم سے کم اہم ہندسوں (دائیں طرف) سے لے کر انتہائی اہم ہندسے (بائیں طرف) تک۔ریڈکس ترتیب کو عدد ، تاروں ، یا کسی بھی طرح کے اعداد و شمار کو ترتیب دینے کے لئے استعمال کیا جاسکتا ہے جس کو ہندسے کے ذریعہ ہندسے کی نمائندگی کی جاسکتی ہے۔ ریڈکس ترتیب دینے کا ایک جائزہ ہے: ترتیب دینے کے لئے عناصر کی غیر ترتیب شدہ صف سے شروع کریں۔ زیادہ سے زیادہ تعداد کی وضاحت کریں۔صف میں موجود تمام عناصر کے درمیان ہندسے۔اس سے چھانٹنے کے عمل کے لئے درکار پاسوں یا تکرار کی تعداد طے ہوتی ہے۔ ہر ہندسے کے لئے ایک پاس کو کم سے کم اہم ہندسے سے لے کر انتہائی اہم ہندسے تک کا مظاہرہ کریں۔ہر پاس کے لئے ، موجودہ ہندسے کی قیمت کی بنیاد پر عناصر کو 10 بالٹی (0-9) میں تقسیم کریں۔ بالٹیوں میں عناصر کو تقسیم کرنے کے بعد ، بالٹیوں کی ترتیب میں عناصر کو ایک ہی صف میں واپس جمع کریں۔یہ عمل اس بات کو یقینی بناتا ہے کہ ایک ہی ہندسے کی قیمت والے عناصر ایک ہی رشتہ دار ترتیب میں رہیں۔ ہر بعد کے ہندسے کے لئے 3-4 سے کم اقدامات ، کم سے کم اہم ہندسے سے انتہائی اہم ہندسے کی طرف بڑھتے ہوئے۔آخری پاس کے بعد ، سرنی کو ترتیب دیا جائے گا۔ ریڈکس ترتیب میں ایل ایس ڈی (کم سے کم اہم ہندسہ) یا ایم ایس ڈی (انتہائی اہم ہندسہ) نقطہ نظر کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ایل ایس ڈی ریڈکس ترتیب دائیں طرف سے شروع ہوتی ہے اور بائیں طرف آگے بڑھتی ہے ، جبکہ ایم ایس ڈی ریڈکس ترتیب بائیں طرف سے شروع ہوتی ہے اور دائیں طرف آگے بڑھتی ہے۔دونوں طریقوں کے اعداد و شمار کی ترتیب کی خصوصیات پر انحصار کرتے ہوئے ان کے فوائد اور تحفظات ہیں۔ ریڈکس ترتیب کی وقت کی پیچیدگی O (K * N) ہے ، جہاں N عناصر کی تعداد ہے اور K ہندسوں کی اوسط تعداد ہے۔یہ ایک لکیری وقت کو چھانٹ رہا ہے الگورتھم سمجھا جاتا ہے کیونکہ پاس (کے) کی تعداد عام طور پر عناصر کی تعداد (این) سے بہت چھوٹی ہوتی ہے۔ رادکس ترتیب ایک مستحکم چھانٹنے والا الگورتھم ہے ، اس کا مطلب ہے کہ یہ مساوی اقدار کے ساتھ عناصر کے متعلقہ ترتیب کو برقرار رکھتا ہے۔تاہم ، ہر ہندسے کے ل the بالٹیوں کو تھامنے کے ل it اس کو اضافی میموری کی ضرورت ہوتی ہے ، جو اس کی جگہ کی کارکردگی کو متاثر کرسکتی ہے۔یہ عام طور پر انٹیجر چھانٹنے ، سٹرنگ چھانٹنے اور دیگر ایپلی کیشنز کے لئے استعمال ہوتا ہے جہاں عنصر کا ڈھانچہ انفرادی ہندسوں کی بنیاد پر چھانٹنے کی اجازت دیتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں بندشوں اور ماڈیول پیٹرن کے تصور کی وضاحت کریں اور ان کا استعمال نجی متغیرات اور انکسیپسولیشن بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک AVL درخت ایک قسم کا خود توازن بائنری سرچ ٹری (BST) ہے جو موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو یقینی بنانے کے لئے ایک مخصوص توازن کی حالت کو برقرار رکھتا ہے۔اے وی ایل کے درخت اور عمومی بائنری تلاش کے درخت کے درمیان کلیدی فرق بیلنس عنصر اور اس سے وابستہ توازن کے عمل میں ہے۔یہاں اہم اختلافات ہیں: بیلنس فیکٹر: اے وی ایل کے درخت میں ہر نوڈ ایک بیلنس عنصر کو ذخیرہ کرتا ہے ، جو اس نوڈ کے بائیں اور دائیں سب ٹریوں کے درمیان اونچائی کا فرق ہے۔بیلنس عنصر -1 ، 0 ، یا 1 ہوسکتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ آیا سب ٹری بالترتیب بائیں بھاری ، متوازن یا دائیں بھاری ہے۔عام بائنری سرچ ٹری میں ، توازن کے عنصر کا کوئی تصور نہیں ہے۔ متوازن آپریشنز: جب بھی کسی AVL درخت میں اندراج یا حذف کرنے کا عمل انجام دیا جاتا ہے جو توازن کی حالت میں خلل ڈالتا ہے (توازن عنصر -2 یا +2 بن جاتا ہے) ، مخصوص توازن کی کاروائیاں ہوتی ہیں۔توازن کو بحال کرنے کے لئے متحرک.ان کارروائیوں میں درخت کی تنظیم نو اور توازن برقرار رکھنے کے لئے گردش (سنگل یا ڈبل گردش) شامل ہیں۔عام بائنری سرچ ٹری میں ، کوئی خاص توازن عمل نہیں ہوتا ہے ، اور وقت کے ساتھ ساتھ درخت غیر متوازن ہوسکتا ہے۔ خود متوازن پراپرٹی: ایک AVL درخت خود توازن رکھنے والا ڈیٹا ڈھانچہ ہے ، یعنی یہ اندراج اور حذف کرنے کی کارروائیوں کے دوران خود بخود اس کی ساخت کو ایڈجسٹ کرتا ہے۔توازن کی حالت کو برقرار رکھنے کے لئے۔یہ خود توازن رکھنے والی جائیداد اس بات کو یقینی بناتی ہے کہ درخت کی اونچائی O (لاگ این) رہتی ہے ، جہاں N عناصر کی تعداد ہے۔عام بائنری تلاش کے درخت میں ، توازن کی کوئی ضمانت نہیں ہے ، اور درخت کی اونچائی بدترین صورت میں O (n) سے کم ہوسکتی ہے ، جس سے تلاشی کے کاموں کے لئے کم موثر ہوجاتا ہے۔ کارکردگی: خود توازن رکھنے والی املاک کی وجہ سے ،اے وی ایل کے درخت بدترین صورت میں او (لاگ این) کی وقت کی پیچیدگی کے ساتھ موثر تلاش ، اندراج اور حذف کرنے کے کام فراہم کرتے ہیں۔یہ تمام کاموں کے لئے متوازن رسائی کے اوقات کی ضمانت دیتا ہے۔عام بائنری تلاش کے درخت میں ، آپریشنز کی وقت کی پیچیدگی کا انحصار درخت کے ڈھانچے پر ہوتا ہے ، جو بیلنس پر منحصر O (لاگ N) سے O (n) تک مختلف ہوسکتا ہے۔ خلاصہ۔ ایک AVL درخت خود توازن کی ایک قسم ہے۔بائنری سرچ ٹری جو ایک توازن عنصر کو برقرار رکھتا ہے اور درخت کو متوازن رہنے کو یقینی بنانے کے لئے مخصوص توازن کے کام انجام دیتا ہے۔اس سے گارنٹیڈ لوگرتھمک ٹائم پیچیدگی کے ساتھ موثر تلاش ، اندراج اور حذف کرنے کی کارروائیوں کو یقینی بنایا جاتا ہے۔اس کے برعکس ، ایک عام بائنری سرچ ٹری میں توازن عنصر یا مخصوص توازن کے کام نہیں ہوتے ہیں ، اور اس کا ڈھانچہ اندراج کے حکم پر منحصر ہوتا ہے ، جس سے ممکنہ طور پر غیر متوازن درخت اور کم موثر آپریشن ہوتے ہیں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں JSON ڈیٹا کو کس طرح سنبھالتے ہیں؟json.stringify () اور json.parse () طریقوں کے استعمال کی وضاحت کریں۔",
        "Answer": "ایک بلوم فلٹر ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو کسی سیٹ میں کسی عنصر کی رکنیت کو جانچنے کے لئے استعمال ہوتا ہے۔یہ مؤثر طریقے سے یہ طے کرتا ہے کہ آیا کسی عنصر کو سیٹ میں موجود ہونے کا امکان ہے یا یقینی طور پر موجود نہیں ہے ، لیکن یہ کبھی کبھار غلط مثبت نتائج پیدا کرسکتا ہے (اس بات کا اشارہ کرتا ہے کہ عنصر موجود ہوتا ہے جب یہ نہیں ہوتا ہے) ، حالانکہ یہ کبھی بھی غلط منفی پیدا نہیں کرتا ہے (اس بات کی نشاندہی کرتے ہیں کہ ایکعنصر موجود نہیں ہوتا ہے جب یہ ہوتا ہے) .یہ ہے کہ بلوم فلٹر کس طرح کام کرتا ہے: ابتدا: ایک بلوم فلٹر ایک مقررہ سائز بٹ سرنی (عام طور پر ایم بٹس کے) اور K آزاد ہیش فنکشن کا ایک سیٹ کے ساتھ تیار کیا جاتا ہے۔بلوم فلٹر کا عنصر ، یہ K ہیش کے ہر افعال کا استعمال کرتے ہوئے ہیش کیا جاتا ہے ، جس کے نتیجے میں K مختلف ہیش اقدار ہوتی ہیں۔بٹ سرنی میں متعلقہ بٹس ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر 1 پر سیٹ کیے گئے ہیں۔ میمبرشپ ٹیسٹ: یہ چیک کرنے کے لئے کہ عنصر سیٹ میں ہے یا نہیں ، عنصر کو اسی کے ہیش افعال کا استعمال کرتے ہوئے ہیش کیا جاتا ہے۔ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر بٹ سرے میں بٹس کی جانچ کی جاتی ہے۔اگر تمام متعلقہ بٹس 1 پر سیٹ کیے گئے ہیں تو ، عنصر کو سیٹ میں \"ممکنہ طور پر موجود\" سمجھا جاتا ہے۔اگر بٹس میں سے کسی کو 1 پر سیٹ نہیں کیا گیا ہے تو ، عنصر یقینی طور پر سیٹ میں موجود نہیں ہے۔ بلوم فلٹرز کی کلیدی خصوصیات اور استعمال کے معاملات مندرجہ ذیل ہیں: خلائی کارکردگی: بلوم فلٹر دوسرے اعداد و شمار کے مقابلے میں نسبتا small تھوڑی مقدار میں میموری کا استعمال کرتے ہیں۔ہیش ٹیبل جیسے ڈھانچے۔خلائی کارکردگی کو غلط مثبت کی اجازت دے کر حاصل کیا جاتا ہے۔ ممبرشپ کا تخمینہ سیٹ کریں: بلوم فلٹرز بنیادی طور پر کسی سیٹ میں ممبرشپ کو موثر انداز میں جانچنے کے لئے استعمال ہوتے ہیں۔وہ ایسے منظرناموں کے لئے موزوں ہیں جہاں پورے سیٹ کو ذخیرہ کرنے کے لئے میموری یا اسٹوریج کی ضروریات ممنوع ہیں۔ اسپیڈ: بلوم فلٹرز میں ممبرشپ ٹیسٹ بہت تیز ہیں کیونکہ انہیں صرف ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر بٹ سرے کا اندازہ کرنے کی ضرورت ہوتی ہے ، بغیر اصل تک رسائی حاصل کی۔عناصر۔ فالس مثبت: بلوم فلٹرز غلط مثبت پیدا کرسکتے ہیں ، جہاں کسی عنصر کو سیٹ میں موجود کے طور پر غلط طور پر شناخت کیا جاتا ہے۔جھوٹے مثبت کے امکان کا انحصار بٹ سرنی (م) کے سائز ، ہیش افعال (کے) کی تعداد ، اور سیٹ میں عناصر کی تعداد پر ہوتا ہے۔ بلوم فلٹرز مختلف شعبوں میں ایپلی کیشنز تلاش کرتے ہیں ، جیسے نیٹ ورک روٹرز (فلٹر کرنے کے لئےناپسندیدہ ٹریفک) ، ڈیٹا بیس (غیر موجود ریکارڈوں کے لئے ڈسک کی تلاش کو کم کرنے کے لئے) ، ہجے چیکرس ، سرچ انجن (غیر ضروری ڈسک تک رسائی کو کم کرنے کے لئے) ، اور بہت کچھ۔ یہ بات اہم ہے کہ بلوم فلٹرز موثر اور جگہ کی بچت ہیں ، وہ ہیں ، وہ ہیں ، وہ ہیںان ایپلی کیشنز کے ل suitable موزوں نہیں جہاں جھوٹے مثبت ناقابل قبول ہوں یا جب عناصر کے مکمل سیٹ کو درست طریقے سے بازیافت کرنے کی ضرورت ہو۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں اس کلیدی لفظ کا مقصد کیا ہے؟اس کی قدر مختلف سیاق و سباق میں کیسے تبدیل ہوتی ہے؟",
        "Answer": "امورائزڈ تجزیہ ایک ایسی تکنیک ہے جو اعداد و شمار کے ڈھانچے پر آپریشنز کی ترتیب کی اوسط وقت کی پیچیدگی کا تعین کرنے کے لئے استعمال کی جاتی ہے ، چاہے انفرادی کارروائیوں میں مختلف وقت کی پیچیدگیاں ہوسکتی ہیں۔یہ کاموں کی ایک سیریز کے دوران اعداد و شمار کے ڈھانچے یا الگورتھم کی کارکردگی کی خصوصیات کے بارے میں زیادہ درست اور جامع تفہیم فراہم کرتا ہے۔ کچھ معاملات میں ، اعداد و شمار کے ڈھانچے میں کسی ایک آپریشن کی بدترین وقت کی پیچیدگی ناکارہ ہوسکتی ہے ، لیکن جب کسی ترتیب پر غور کریں۔کارروائیوں میں ، اوسط وقت کی پیچیدگی نمایاں طور پر بہتر ہوسکتی ہے۔امورائزڈ تجزیہ ہمیں مہنگے کارروائیوں کے اخراجات کو بڑی تعداد میں سستے کاموں پر تقسیم کرکے کارروائیوں کی مجموعی لاگت کا تجزیہ کرنے میں مدد کرتا ہے۔ امورٹائزڈ تجزیہ میں تین اہم طریقے شامل ہیں: مجموعی تجزیہ: یہ طریقہ کاروں کی ترتیب کی کل لاگت کا تجزیہ کرتا ہے اور اس کو تقسیم کرتا ہے۔کارروائیوں کی تعداد سے۔یہ فی آپریشن اوسط لاگت پر ایک اوپری پابند فراہم کرتا ہے۔ اکاؤنٹنگ طریقہ: اس طریقہ کار میں ، کچھ آپریشنوں کو اضافی \"کریڈٹ\" تفویض کیا جاتا ہے تاکہ دیگر کارروائیوں کی لاگت کو پورا کیا جاسکے جو نسبتا in سستا ہے۔کریڈٹ کو کارروائیوں میں تقسیم کیا جاتا ہے ، اس بات کو یقینی بناتے ہوئے کہ کل لاگت کا حساب کتاب ہے۔ ممکنہ طریقہ: یہ طریقہ امور لاگت کا تجزیہ کرنے کے لئے ممکنہ توانائی کے تصور کو استعمال کرتا ہے۔یہ ایک ممکنہ فنکشن کی وضاحت کرتا ہے جو ہر آپریشن کے بعد ڈیٹا ڈھانچے میں محفوظ \"ممکنہ توانائی\" کی نمائندگی کرتا ہے۔ابتدائی اور آخری ریاستوں کے مابین ممکنہ فرق کو آپریشنز کی لاگت کا حساب کتاب کرنے کے لئے استعمال کیا جاتا ہے۔ عام تجزیہ عام طور پر مختلف ڈیٹا ڈھانچے اور الگورتھم کی کارکردگی کا تجزیہ کرنے کے لئے استعمال کیا جاتا ہے ، جیسے متحرک صفوں (جیسے ، اری لسٹ) ، ہیش ٹیبلز ، خودمتوازن درخت (جیسے ، AVL درخت ، سرخ سیاہ درخت) ، اور بہت کچھ۔اس سے ان ڈھانچے کے اوسط طرز عمل کے بارے میں بصیرت فراہم کرنے میں مدد ملتی ہے ، جس سے ان کی کارکردگی کی خصوصیات کی بہتر تفہیم اور موازنہ کرنے کی اجازت ملتی ہے۔مختلف منظرنامے۔یہ ان معاملات کی نشاندہی کرنے میں ہماری مدد کرتا ہے جہاں ایک مہنگا آپریشن سستے آپریشنوں کی ترتیب سے پیش کیا جاتا ہے ، جس کے نتیجے میں مجموعی طور پر موثر حل ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں واقعہ کے بلبلے اور ایونٹ کی گرفت کے تصور کی وضاحت کریں۔",
        "Answer": "جامد صف اور متحرک صف کے درمیان فرق سائز اور میموری کے انتظام کے لحاظ سے ان کی مختص اور لچک میں ہے۔یہاں ہر ایک کی وضاحت ہے: جامد سرنی: سائز: ایک مستحکم صف کا ایک مقررہ سائز ہوتا ہے جو اعلان کے وقت طے ہوتا ہے۔ایک بار جب سائز کی وضاحت ہوجائے تو ، رن ٹائم کے دوران اسے تبدیل نہیں کیا جاسکتا۔ میموری مختص: جامد صفوں کو اسٹیک پر یا جامد/عالمی متغیر کے طور پر مختص کیا جاتا ہے۔اور کارکردگی: ایک مستحکم صف میں موجود عناصر کو ان کے اشاریہ کے ذریعہ رسائی حاصل کی جاتی ہے ، اور رسائی کا وقت مستقل ہوتا ہے (O (1))۔عناصر کو میموری میں لگاتار ذخیرہ کیا جاتا ہے۔رن ٹائم کے دوران ایڈجسٹ کریں۔جب ضرورت ہو تو پروگرامر میموری کو واضح طور پر مختص کرنے اور اس سے نمٹنے کے لئے ذمہ دار ہے جب اس کو میموری لیک سے بچنے کی ضرورت نہیں ہے۔ دوبارہ استعمال کرنا: مختلف تعداد میں عناصر کو ایڈجسٹ کرنے کے لئے متحرک صفوں کا سائز تبدیل کیا جاسکتا ہے۔عام طور پر دوبارہ بنانے میں میموری کا ایک نیا بلاک مختص کرنا ، موجودہ عناصر کو کاپی کرنا ، اور پرانی میموری کو ختم کرنا شامل ہے۔)). لچک: رن ٹائم کے دوران متحرک صف کے سائز کو تبدیل کرنے کی صلاحیت اسے جامد صف سے زیادہ لچکدار بناتی ہے۔یہ پروگرام کی اصل ضروریات کی بنیاد پر متحرک میموری مختص کرنے کی اجازت دیتا ہے۔ خلاصہ یہ کہ ایک مستحکم سرنی کا ایک مقررہ سائز مرتب وقت پر طے ہوتا ہے ، جبکہ ایک متحرک صف میں لچکدار سائز ہوتا ہے جسے رن ٹائم کے دوران ایڈجسٹ کیا جاسکتا ہے۔متحرک صفیں زیادہ لچک فراہم کرتی ہیں لیکن دستی میموری کے انتظام کی ضرورت ہوتی ہے ، جبکہ جامد صفوں میں ایک مقررہ سائز اور خودکار میموری کا انتظام ہوتا ہے۔جامد اور متحرک صفوں کے مابین انتخاب پروگرام کی مخصوص ضروریات پر منحصر ہے ، بشمول لچک ، میموری کی کارکردگی ، اور کارکردگی کے تحفظات کی ضرورت بھی۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد غلطیوں کو کس طرح سنبھالتے ہیں؟کوشش کے استعمال کی وضاحت کریں ... async/انتظار اور وعدوں کے ساتھ پکڑو۔",
        "Answer": "انضمام ترتیب والے الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: تقسیم کریں: غیر ترتیب شدہ صف کو دو حصوں میں تقسیم کریں۔یہ درمیانی اشاریہ تلاش کرکے اور دو الگ الگ سبریوں کی تشکیل کے ذریعہ کیا جاسکتا ہے ، ایک شروع سے وسط تک عناصر پر مشتمل ہے ، اور دوسرا درمیانی+1 سے آخر تک عناصر پر مشتمل ہے۔پچھلے مرحلے میں تخلیق کردہ دو سبریوں کو۔یہ قدم سبریوں کو تقسیم کرنا جاری رکھے گا جب تک کہ ہر سبری میں صرف ایک عنصر نہ ہو ، جسے پہلے ہی ترتیب دیا جاتا ہے۔یہ دو سبریوں کے عناصر کا موازنہ کرکے اور اصل صف میں رکھے جانے والے چھوٹے عنصر کو منتخب کرکے کیا جاتا ہے۔اس عمل کو اس وقت تک دہرائیں جب تک کہ دونوں سبریوں کے تمام عناصر کو اصل سرنی میں ضم نہیں کردیا گیا ہے۔ یہاں ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈیڈف انضمام_سورٹ (اے آر آر): # بیس کیس: اگر سرنی خالی ہے یا صرف ایک عنصر موجود ہے تو واپس کریں (اے آر آر)) <= 1: آر اے آر # صف کو دو حصوں میں تقسیم کریں وسط = لین (اے آر آر) // 2 بائیں_ہالف = آر اے آر [: وسط] دائیں_ہلف = آر آر [وسط:] # بار بار دو حصوں کو بائیں_ہالف = انضمام_سورٹ (بائیں_ہالف) دائیں_ہلف کو ترتیب دیں۔= انضمام_سورٹ (دائیں_ہالف) # ترتیب شدہ آدھے حص .ے کو ضم کریں<لین (بائیں) اور جے <لین (دائیں): اگر بائیں [i] <دائیں [j]: ضم شدہ۔ اپینڈ (بائیں [i]) i += 1 اور: ضم شدہ۔ اپینڈ (دائیں [j]) جے += 1 # subarrays (اگر کوئی ہے) سے باقی عناصر شامل کریں۔کوڈر = [4 ، 7 ، 2 ، 1 ، 5 ، 9 ، 3 ، 8 ، 6] چھانٹے ہوئے_ر = انضمام_سورٹ (اے آر آر) پرنٹ (چھانٹیا_ر) آؤٹ پٹ ترتیب شدہ صف ہوگا: [1 ، 2 ، 3 ، 4 ، 5 ،6 ، 7 ، 8 ، 9]۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں آبجیکٹ کی خصوصیات پر تکرار کرنے کے مختلف طریقے کیا ہیں؟ہر طریقہ کی مثالیں فراہم کریں۔",
        "Answer": "اسکیپ لسٹ ایک ڈیٹا ڈھانچہ ہے جو عناصر کی ترتیب شدہ فہرست میں عناصر کی تلاش کا ایک موثر طریقہ فراہم کرتا ہے۔یہ ایک منسلک فہرست کی طرح ہے لیکن اس میں متعدد متوازی لنکڈ فہرستیں شامل ہیں ، جن کو \"سطح\" کہا جاتا ہے ، جو تیزی سے تلاش کے کاموں کی اجازت دیتا ہے۔اسکیپ لسٹوں کو موثر تلاش کے اوقات اور عمل درآمد کی سادگی کے مابین توازن فراہم کرنے کے لئے ڈیزائن کیا گیا ہے۔ یہاں یہ ہے کہ اسکیپ لسٹ کس طرح کام کرتی ہے: ڈھانچہ: ایک اسکیپ لسٹ متعدد سطحوں پر مشتمل ہے ، جہاں ہر سطح نوڈس کی ایک منسلک فہرست ہے۔نچلی سطح ایک باقاعدہ ترتیب شدہ منسلک فہرست ہے جس میں تمام عناصر شامل ہیں۔نچلی سطح سے اوپر ہر سطح نچلی سطح کا سب سیٹ ہے ، جو کچھ عناصر کو چھوڑ دیتا ہے۔سب سے اوپر کی سطح میں صرف دو نوڈس ہوتے ہیں: ایک بائیں سینٹینیل اور ایک دائیں سینٹینیل۔ تلاش کرنا: اسکیپ لسٹ میں کسی عنصر کی تلاش کے ل you ، آپ سب سے اوپر کی سطح پر شروع کرتے ہیں اور لنکڈ فہرست کو عبور کرتے ہیں جب تک کہ آپ کو ایسا عنصر نہ مل سکے جو اس سے زیادہ یا برابر ہو۔ہدف عنصر کو۔اس کے بعد ، آپ اگلے درجے پر چلے جائیں اور اس عمل کو دہرائیں جب تک کہ آپ نیچے کی سطح تک نہ پہنچیں یا ہدف کا عنصر تلاش نہ کریں۔یہ اسکیپ ڈاون عمل فہرست کے بڑے حصوں کو چھوڑ کر تیز تر تلاش کرنے کی اجازت دیتا ہے۔ داخل کریں: جب کسی نئے عنصر کو اسکیپ لسٹ میں داخل کرتے ہو تو ، آپ اوپر کی سطح پر شروع کرتے ہیں اور اس پوزیشن کی تلاش کرتے ہیں جہاں نیا عنصر داخل کیا جانا چاہئے۔جب آپ سطحوں کو عبور کرتے ہیں تو ، آپ تصادفی طور پر فیصلہ کرتے ہیں کہ آیا اس سطح میں نئے عنصر کو داخل کرنا ہے یا اسے چھوڑ دینا ہے۔اگر نیا عنصر کسی خاص سطح پر داخل کیا جاتا ہے تو ، آپ ایک نیا نوڈ بناتے ہیں اور نئے نوڈ کو شامل کرنے کے لئے مناسب پوائنٹرز کو اپ ڈیٹ کرتے ہیں۔ ڈائلیشن: کسی عنصر کو اسکیپ لسٹ سے حذف کرنے کے لئے ، آپ اسکیپ لسٹ میں موجود عنصر کو تلاش کرتے ہیں اور اس کو اپ ڈیٹ کرتے ہیں۔عنصر پر مشتمل نوڈ کو نظرانداز کرنے کے لئے اشارے۔یہ ہٹانے کا عمل باقاعدگی سے منسلک فہرست میں حذف ہونے کی طرح ہے۔ اسکیپ لسٹ کی اونچائی کا تعین امکان کی تقسیم کے ذریعہ کیا جاتا ہے ، عام طور پر سکے ٹاس یا بے ترتیب نمبر جنریشن کی بنیاد پر ، جس سے یہ طے ہوتا ہے کہ آیا کسی عنصر کو اگلی سطح پر ترقی دی جانی چاہئے یا نہیں۔نہیں۔عنصر کی سطح جتنی اونچی ہوگی ، اس کے کم عناصر اس کے چھوڑ جاتے ہیں ، جس کے نتیجے میں تیزی سے تلاش کے اوقات ہوتے ہیں۔ ایس کے آئی پی کی فہرستیں تلاش ، اندراج اور حذف کرنے کے کاموں کے لئے اوسطا case وقت کی پیچیدگی فراہم کرتی ہیں ، جہاں این میں عناصر کی تعداد ہوتی ہے۔فہرست.اس سے اسکیپ کی فہرستوں کو زیادہ پیچیدہ متوازن سرچ ٹری ڈھانچے جیسے اے وی ایل کے درختوں یا سرخ سیاہ درختوں کے عملی متبادل بناتا ہے ، خاص طور پر جب سادگی اور عمل درآمد میں آسانی کو ترجیح دی جاتی ہے۔ یہ بات اہم ہے کہ اسکیپ لسٹوں میں متوازن تلاش کے درختوں کی طرح کی کارکردگی کی ضمانت نہیں ہے۔بدترین صورتحال میں۔تاہم ، اسکیپ لسٹوں کی امکانی نوعیت انہیں اوسطا موثر اور بہت سے عملی ایپلی کیشنز کے ل suitable موزوں بنا دیتی ہے جہاں بدترین صورتحال کا منظر کم ہے۔"
    },
    {
        "Question": "",
        "Answer": "ایک لاحقہ درخت ایک ڈیٹا ڈھانچہ ہے جو کسی دیئے گئے تار کے تمام لاحقہ کو موثر انداز میں نمائندگی کرتا ہے۔یہ بنیادی طور پر پیٹرن مماثل اور سٹرنگ سرچ آپریشنز کے لئے استعمال ہوتا ہے۔ایک لاحقہ درخت خاص طور پر ان ایپلی کیشنز میں مفید ہے جس میں بڑے متن یا ڈی این اے کی ترتیب کا تجزیہ کرنا شامل ہے۔ یہاں ایک لاحقہ درخت کس طرح کام کرتا ہے: تعمیر: لاحقہ درخت کی تعمیر کے لئے ، دیئے گئے تار کو کردار کے لحاظ سے پروسس کیا جاتا ہے۔تار کا ہر لاحقہ درخت میں ایک علیحدہ راستے کے طور پر شامل کیا جاتا ہے۔لاحقہ جو مشترکہ سابقہ میں شریک ہیں اسی طرح کا راستہ بانٹتے ہیں جب تک کہ وہ ڈائیورج۔ نوڈس اور ایجز: درخت نوڈس اور کناروں پر مشتمل ہوتا ہے۔ہر نوڈ اصل تار کے ایک ذخیرے کی نمائندگی کرتا ہے ، اور ہر کنارے ایک کردار کی نمائندگی کرتا ہے۔کناروں پر ان حروف کا لیبل لگا ہوا ہے جو اگلے نوڈس کی طرف جاتا ہے۔روٹ نوڈ خالی تار کی نمائندگی کرتا ہے ، اور ہر پتی نوڈ اصل تار کے لاحقہ سے مماثل ہوتا ہے۔ راستہ کمپریشن: جگہ کے استعمال کو بہتر بنانے کے لئے ، لاحقہ درخت اکثر راستے کی کمپریشن کو ملازمت دیتے ہیں۔اس کا مطلب یہ ہے کہ ایک ہی حروف کے ساتھ لگاتار کناروں کو ایک ہی کنارے میں ملایا جاتا ہے ، جس سے درخت میں نوڈس اور کناروں کی تعداد کم ہوجاتی ہے۔ لاحقہ درخت کئی مفید خصوصیات مہیا کرتا ہے: سٹرنگ سرچ: لاحقہ درخت کا بنیادی فائدہ اس کی مؤثر طریقے سے تلاش کرنے کی صلاحیت ہے۔اصل تار کے اندر سبسٹرنگ کے لئے۔استفسار کے تار کو دیکھتے ہوئے ، آپ اصل تار میں استفسار کے تار کے تمام واقعات کو تلاش کرنے کے لئے لاحقہ درخت کو عبور کرسکتے ہیں۔اس آپریشن میں او (ایم) کی وقت کی پیچیدگی ہے ، جہاں ایم استفسار کے تار کی لمبائی ہے۔ پیٹرن ملاپ: لاحقہ درخت پیٹرن مماثل کاموں کے لئے بہترین ہیں۔وہ آپ کو یہ تعین کرنے کی اجازت دیتے ہیں کہ آیا کوئی دیئے گئے نمونہ اصل تار میں موجود ہے اور پیٹرن کے تمام واقعات کو تلاش کرتا ہے۔اس آپریشن میں او (پی) کی وقت کی پیچیدگی ہے ، جہاں پی پیٹرن کی لمبائی ہے۔ عام طور پر عام سٹرنگ: لاحقہ درختوں کو متعدد ڈوروں کے مابین موثر انداز میں سب سے طویل مشترکہ سبسٹرنگ تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔تمام ڈوروں کے لئے ایک ہی لاحقہ درخت کی تعمیر اور درخت کے ڈھانچے کا تجزیہ کرکے ، آپ سب سے طویل عام سبسٹرنگ کی نشاندہی کرسکتے ہیں۔ سفکس درخت مختلف ایپلی کیشنز میں بڑے پیمانے پر استعمال ہوتے ہیں ، بشمول بائیو انفارمیٹکس (ڈی این اے ترتیب تجزیہ ، جینوم اسمبلی ، اور جینوم میں دہرنے کی تلاش)، ٹیکسٹ انڈیکسنگ اور سرچ انجن (الفاظ یا فقرے کے واقعات کی تلاش) ، ڈیٹا کمپریشن الگورتھم ، اور بہت کچھ۔وہ سٹرنگ تجزیہ ، پیٹرن مماثل ، اور سٹرنگ تلاش سے متعلق کاموں کے لئے موثر اور توسیع پذیر حل فراہم کرتے ہیں۔تاہم ، لاحقہ درخت کی تعمیر کمپیوٹیشنل مہنگا ہوسکتی ہے ، عام طور پر O (n) وقت اور جگہ کی پیچیدگی کی ضرورت ہوتی ہے ، جہاں N ان پٹ سٹرنگ کی لمبائی ہوتی ہے۔"
    },
    {
        "Question": "",
        "Answer": "بائنری سرچ ٹری (بی ایس ٹی) میں کسی عنصر کو داخل کرنے کی وقت کی پیچیدگی درخت کی ساخت پر منحصر ہے۔بہترین صورتحال میں ، جہاں درخت متوازن ہے ، وقت کی پیچیدگی O (لاگ این) ہے ، جہاں N درخت میں نوڈس کی تعداد ہے۔تاہم ، بدترین صورتحال میں ، جہاں درخت انتہائی متوازن ہے (لکیری لنکڈ فہرست سے مشابہت) ، وقت کی پیچیدگی O (n) ہوسکتی ہے ، جہاں درخت میں نوڈس کی تعداد ہے۔ اس تغیر کی وجہ یہ ہےکہ متوازن بی ایس ٹی میں ، درخت کی اونچائی نوڈس کی تعداد کے سلسلے میں لاگ ان کی رہتی ہے ، جس سے داخلے کے موثر کاموں کو یقینی بنایا جاتا ہے۔متوازن بی ایس ٹی میں ہر سطح باقی تلاش کی جگہ کو تقریبا half نصف تک تقسیم کرتا ہے ، جس کی وجہ سے عناصر کی متوازن تقسیم ہوتی ہے۔ دوسری طرف ، ایک متوازن بی ایس ٹی ایک لکیری ڈھانچے میں ہراس ڈال سکتا ہے ، جس میں ایک سب ٹری دوسرے سے نمایاں طور پر بڑا ہے۔اس معاملے میں ، کسی عنصر کو داخل کرنے میں درخت کی پوری اونچائی سے گزرنا شامل ہوسکتا ہے ، جس کے نتیجے میں ایک خطی وقت کی پیچیدگی ہوتی ہے۔ موثر اضافے کو یقینی بنانے کے لئے ، خود توازن بائنری سرچ ٹری کی مختلف حالتوں جیسے AVL درختوں یا سرخ سیاہ کو استعمال کرنا عام ہے۔درختیہ اعداد و شمار کے ڈھانچے اضافے اور حذف کرنے کے دوران مخصوص قواعد کو نافذ کرکے توازن برقرار رکھتے ہیں ، تلاش اور اندراج دونوں کاموں کے ل log لاجارتھمک ٹائم پیچیدگی کی ضمانت دیتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں ہم آہنگی اور غیر متزلزل کوڈ میں کیا فرق ہے؟ہر ایک کی مثالیں فراہم کریں۔",
        "Answer": "ایک فبونیکی ہیپ ایک ڈیٹا ڈھانچہ ہے جو ترجیحی قطار کو موثر انداز میں نافذ کرنے کے لئے استعمال ہوتا ہے۔یہ بائنری ہیپس یا بائنومیئل ہیپس جیسے ترجیحی قطار کے نفاذ کے مقابلے میں بعض کارروائیوں کے لئے بہتر امورائزڈ ٹائم پیچیدگی فراہم کرتا ہے۔فیبونیکی ہیپ کی کلیدی خصوصیات میں اس کی انضمام کے ڈھیر پراپرٹی اور مستقل وقت کی کارروائیوں جیسے اندراج اور کمی کی صلاحیت شامل ہے۔ یہاں فیبونیکی ہیپ کس طرح کام کرتا ہے اس کا ایک جائزہ: ساخت: ایک فبونیکی ہیپ کا ایک مجموعہ ہے۔درختوں کا حکم دیا۔ڈھیر میں ہر درخت کم سے کم پراپرٹی کی پیروی کرتا ہے ، جہاں ہر نوڈ کی کلید اس کے والدین کی کلید سے زیادہ یا اس کے برابر ہوتی ہے۔درختوں کی کوئی شکل ہوسکتی ہے ، اور ڈھیر کی نمائندگی خود ہی جڑ کے نوڈس کی دوگنا سے منسلک فہرست کے ذریعہ کی جاتی ہے۔اس کے بعد اس درخت کو جڑ کی فہرست میں شامل کیا جاتا ہے۔اندراج کے عمل میں O (1) کی مستقل وقت کی پیچیدگی ہوتی ہے کیونکہ کسی ضم یا تنظیم نو کی ضرورت نہیں ہوتی ہے۔اگر ضروری ہو تو کم سے کم نوڈ کو اپ ڈیٹ کیا جاتا ہے۔اس آپریشن میں O (1) کی مستقل وقت کی پیچیدگی بھی ہے۔ کم سے کم: کم سے کم آپریشن فبونیکی ہیپ میں سب سے چھوٹی کلید کے ساتھ عنصر کو لوٹاتا ہے۔یہ براہ راست کم سے کم نوڈ تک رسائی حاصل کرکے کیا جاسکتا ہے ، جو ڈھیر کے ڈیٹا ڈھانچے میں محفوظ ہے۔اس آپریشن میں O (1) کی مستقل وقت کی پیچیدگی ہے۔ کم سے کم ایکسٹریکٹ: نچوڑ کم سے کم آپریشن ڈھیر سے کم سے کم نوڈ کو ہٹا دیتا ہے اور ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے باقی درختوں کو مستحکم کرتا ہے۔استحکام کے دوران ، ایک ہی ڈگری (بچوں کی تعداد) کے درخت اس وقت تک ضم ہوجاتے ہیں جب تک کہ ایک ہی ڈگری کے ساتھ دو درخت نہ ہوں۔اس آپریشن میں O (لاگ این) کی وقت کی پیچیدگی ہے ، جہاں فبونیکی ہیپ میں نوڈس کی تعداد ہے۔ ڈیکریز کلید: کلیدی آپریشن میں کمی سے فبونیکی ہیپ میں نوڈ کی کلید میں کمی واقع ہوتی ہے۔اگر کمی کی کلید کم سے کم پراپرٹی کی خلاف ورزی کرتی ہے تو ، نوڈ اس کے والدین سے کاٹ کر روٹ لسٹ میں شامل کیا جاتا ہے۔مزید برآں ، اگر نوڈ کے والدین کے پاس پہلے ہی کسی بچے کو کاٹا گیا تھا تو ، اسے کاٹ کر جڑ کی فہرست میں بھی منتقل کردیا جاتا ہے۔اس آپریشن میں O (1) کی ایک متناسب وقت کی پیچیدگی ہے .مورٹائزڈ ٹائم پیچیدگی: فبونیکی ڈھیر میں زیادہ تر آپریشنوں کی امورائزڈ ٹائم پیچیدگی ممکنہ فنکشن تجزیہ کی وجہ سے مستقل یا قریب ہے۔اگرچہ انفرادی آپریشن جیسے کم سے کم اور کمی کی کلید میں O (لاگ این) کی بدترین وقت کی پیچیدگیاں ہوسکتی ہیں ، لیکن امورائزڈ تجزیہ اس بات کو یقینی بناتا ہے کہ فی آپریشن اوسط لاگت نمایاں طور پر کم ہے۔ فبوناکی ہیپس خاص طور پر ایسی صورتحال میں مفید ہیں جہاں ترجیحی قطار میں بار بار ضرورت ہوتی ہے۔کم سے کم کم سے کم آپریشن کے ساتھ ، اضافے ، یونینوں اور کلیدی کارروائیوں کو کم کرنا۔وہ منظرناموں میں دیگر ترجیحی قطار کے اعداد و شمار کے ڈھانچے کے مقابلے میں بہتر کارکردگی پیش کرتے ہیں جہاں یہ مخصوص کاروائیاں کام کے بوجھ پر حاوی ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں فنکشن کرینگ کے تصور کی وضاحت کریں اور اسے دوبارہ استعمال کے قابل فنکشن فیکٹریوں کو بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک خود توازن بائنری سرچ ٹری (بی ایس ٹی) ایک بائنری سرچ ٹری ہے جو موثر تلاش ، اندراج ، اور حذف کرنے کی کارروائیوں کو یقینی بنانے کے ل intrats داخلوں اور حذف ہونے کے دوران خود بخود متوازن ڈھانچے کو برقرار رکھتی ہے۔توازن کا طریقہ کار درختوں کے نوڈس کو غیر متوازن ڈھانچے میں انحطاط کو روکنے کے لئے دوبارہ تقسیم کرتا ہے ، جو غیر موثر کارروائیوں کا باعث بن سکتا ہے۔ عام طور پر استعمال ہونے والے خود توازن والے بی ایس ٹی میں شامل ہیں: اے وی ایل کا درخت: ایک اے وی ایل کا درخت اونچائی سے متوازن بائنری تلاش کا درخت ہے ، جہاں اونچائی ہے ، جہاں اونچائی ہے۔کسی بھی نوڈ کے بائیں اور دائیں سبٹیز زیادہ سے زیادہ 1 سے مختلف ہیں۔ AVL درخت اونچائی کے توازن کو برقرار رکھنے کے ل rents اضافے اور حذفوں کے دوران گردشیں انجام دے کر اس توازن کو حاصل کرتے ہیں۔یہ تلاش ، اندراج ، اور حذف کرنے کے کاموں کے لئے O (لاگ این) کی بدترین وقت کی پیچیدگی کو یقینی بناتا ہے۔یہ اس بات کو یقینی بناتا ہے کہ سیاہ نوڈس کے مابین توازن برقرار رکھنے اور اضافی خصوصیات کو نافذ کرنے کے ذریعہ درخت متوازن رہتا ہے ، جیسے ملحقہ سرخ نوڈس۔توازن برقرار رکھنے کے ل red اندراجات اور حذف کرنے کے دوران سرخ سیاہ درخت رنگین پلٹیں اور گردش کا استعمال کرتے ہیں۔سرخ رنگ کے درخت تلاش ، اندراج ، اور حذف کرنے کے کاموں کے لئے O (لاگ این) کی بدترین وقت کی پیچیدگی فراہم کرتے ہیں۔جب نوڈ تک رسائی حاصل کی جاتی ہے تو ، اسے درخت کی جڑ میں منتقل کردیا جاتا ہے ، جو قریبی نوڈس تک کے بعد تک رسائی کو بہتر بناتا ہے۔چھڑکنے والے درخت سخت توازن برقرار نہیں رکھتے ہیں بلکہ اس کے بجائے اکثر نوڈس تک رسائی حاصل کرتے ہیں۔وہ کثرت سے رسائی والے عناصر کے ل good اچھ ma ا وقت کی پیچیدگی فراہم کرتے ہیں۔ خود توازن بی ایس ٹی مختلف منظرناموں میں مفید ہیں ، بشمول: آرڈرڈ ڈیٹا: خود توازن بی ایس ٹی موثر ہوتا ہے جب آپ کو ترتیب شدہ ترتیب میں ڈیٹا اسٹور اور بازیافت کرنے کی ضرورت ہوتی ہے۔وہ غیر متوازن بی ایس ٹی کے مقابلے میں تیز تر تلاش ، اندراج اور حذف کرنے کی کارروائیوں کو فراہم کرتے ہیں ، خاص طور پر بڑے ڈیٹاسیٹس کے لئے۔ ڈائنیمک ڈیٹا: جب اعداد و شمار کو اکثر اضافے اور حذف کرنے کے ساتھ اپ ڈیٹ کیا جاتا ہے تو ، خود توازن بی ایس ٹی اس بات کو یقینی بناتا ہے کہ درخت متوازن رہتا ہے ، انحطاط کو روکتا ہے اور موثر برقرار رہتا ہے۔کارکردگی.ایفینٹ آپریشنز: جب آپ کو متوازن ڈھانچے کی ضمانت کے ساتھ موثر تلاش ، اندراج ، اور حذف کرنے کی کارروائیوں کی ضرورت ہوتی ہے تو خود توازن بی ایس ٹی قیمتی ہوتا ہے۔وہ ان کارروائیوں کے لئے ایک متوقع بدترین صورتحال کا وقت کی پیچیدگی فراہم کرتے ہیں ، جو کارکردگی میں مستقل مزاجی کو یقینی بناتے ہیں۔ ہیش ٹیبلز کے لئے مستقل مزاجی: کچھ معاملات میں ، خود توازن رکھنے والے بی ایس ٹی ہیش ٹیبلز کے متبادل کے طور پر کام کرسکتے ہیں جب عناصر کا آرڈر دینے کا حکم ضروری ہے۔وہ ترتیب دیئے گئے آرڈر کو برقرار رکھنے کے اضافی فائدہ کے ساتھ اسی طرح کی تلاش اور اندراج کے وقت کی پیچیدگی فراہم کرتے ہیں۔ تاہم ، یہ نوٹ کرنا ضروری ہے کہ خود توازن رکھنے والے بی ایس ٹی میموری کے استعمال کے لحاظ سے اضافی اوور ہیڈ کے ساتھ آتے ہیں اور سیدھے اعداد و شمار کے ڈھانچے کے مقابلے میں زیادہ پیچیدہ نفاذ جیسے سرے یا منسلک ہوتے ہیں۔فہرستیں۔خود توازن بی ایس ٹی کے استعمال کا انتخاب آپ کی درخواست کی مخصوص ضروریات پر منحصر ہے ، جیسے اعداد و شمار کی نوعیت ، متوقع کام کا بوجھ ، اور وقت کی پیچیدگی اور خلائی پیچیدگی کے مابین تجارت سے متعلق عوامل پر غور کریں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کراس-ارگین ریسورس شیئرنگ (CORS) کو کس طرح سنبھالتے ہیں؟CORS ہیڈر اور CORS- قابل درخواستوں کے استعمال کی وضاحت کریں۔",
        "Answer": "کوئکسورٹ ایک مشہور چھانٹ رہا الگورتھم ہے جو تقسیم اور فتح کرنے والے نقطہ نظر کی پیروی کرتا ہے۔یہ محور عنصر کو منتخب کرنے ، محور کے ارد گرد صف کو تقسیم کرنے ، اور محور کے دونوں طرف سبریوں کو بار بار ترتیب دینے سے کام کرتا ہے۔یہاں کوئیکسٹورٹ الگورتھم کو نافذ کرنے کے طریقوں کی ایک قدم بہ قدم وضاحت ہے: تقسیم: صف سے محور عنصر کا انتخاب کریں۔محور کا انتخاب الگورتھم کی کارکردگی کو متاثر کرسکتا ہے ، اور محور کے انتخاب کے لئے مختلف حکمت عملی موجود ہے (جیسے ، پہلا ، آخری ، یا درمیانی عنصر کا انتخاب کرنا ، یا بے ترتیب نقطہ نظر کا استعمال کرتے ہوئے)۔اس کے بائیں طرف ، اور محور سے زیادہ تمام عناصر اس کے دائیں طرف رکھے جاتے ہیں۔محور خود اس کی آخری ترتیب شدہ پوزیشن میں ہوگا۔اسے تقسیم کرنے والے مرحلے کے نام سے جانا جاتا ہے۔ ریفرنسیشن: محور کے بائیں طرف (چھوٹے عناصر پر مشتمل) اور محور کے دائیں طرف کے سبری (بڑے عناصر پر مشتمل) کے سب اریے پر مذکورہ بالا تقسیم کے عمل کو متنازعہ طور پر لاگو کریں۔سبری خالی ہوجاتے ہیں یا صرف ایک عنصر پر مشتمل ہوتے ہیں ، کیونکہ سنگل عنصر کی صفوں کو پہلے ہی ترتیب دیا جاتا ہے۔ یہاں ازگر میں کوئکسورٹ الگورتھم کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف کوئیکسورٹ (اے آر آر ، کم ، اعلی): اگر کم <اعلی: # تقسیم سرنیPIVOT_INDEX = تقسیم (ARR ، کم ، اونچائی) # بار بار subarrays کوئکسورٹ (ARR ، LOW ، PIVOT_INDEX - 1) کو ترتیب دیں # بائیں subarray Quicksort (ARR ، PIVOT_INDEX + 1 ، اعلی) کو ترتیب دیں۔): # محور کو منتخب کریں (یہاں ، ہم دائیں عنصر کا انتخاب کرتے ہیں) محور = آر اے آر [اعلی] # چھوٹے عنصر کا انڈیکس I = کم - 1 کے لئے رینج (کم ، اعلی): # اگر موجودہ عنصر OR سے چھوٹا ہے یامحور کے برابر اگر err [j] <= محور: # تبادلہ عناصر i = i + 1 arr [i] ، arr [j] = arr [j] ، arr [i] # محور عنصر کو اپنی ترتیب شدہ پوزیشن میں منتقل کریں۔] کوئکسٹورٹ (اے آر آر ، 0 ، لین (اے آر آر) - 1) پرنٹ (اے آر آر) # آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] کوئکسٹورٹ الگورتھم کی وقت کی پیچیدگی O ہے (n لاگ این) اوسطا ، جہاں ن سرے میں عناصر کی تعداد ہے۔تاہم ، بدترین صورتحال میں (جیسے ، جب صف پہلے ہی ترتیب دی گئی ہے یا اس میں مساوی عناصر شامل ہیں) ، وقت کی پیچیدگی O (n^2) تک کم ہوسکتی ہے۔محور کی حکمت عملی اور بے ترتیب جیسے تکنیک کا انتخاب بدترین صورتحال کے واقعات کو کم کرنے اور الگورتھم کی کارکردگی کو بہتر بنانے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں واقعہ سے چلنے والی پروگرامنگ کیا ہے؟ایونٹ کے سننے والوں اور ایونٹ کے اخراج کے استعمال کی وضاحت کریں۔",
        "Answer": "ایک گراف ایک ڈیٹا ڈھانچہ ہوتا ہے جو باہم مربوط نوڈس کے ذخیرے کی نمائندگی کرنے کے لئے استعمال ہوتا ہے ، جہاں نوڈس کو عمودی کہا جاتا ہے ، اور ان کے مابین رابطوں کو کناروں کہتے ہیں۔گراف کو وسیع پیمانے پر اشیاء ، اداروں ، یا تصورات کے مابین تعلقات کو ماڈل کرنے کے لئے استعمال کیا جاتا ہے۔ گراف کی متعدد اقسام ہیں ، جن میں شامل ہیں: غیر ہدایت شدہ گراف: غیر ہدایت شدہ گراف میں ، کناروں کی کوئی سمت نہیں ہے۔دو عمودیوں کے مابین رابطہ توازن ہے ، اس کا مطلب یہ ہے کہ اگر ورٹیکس اے سے لے کر ورٹیکس بی تک کا ایک کنارے موجود ہے تو ، ورٹیکس بی سے لے کر ورٹیکس اے ڈائریکٹڈ گراف (ڈیگراف) تک بھی ایک کنارے موجود ہیں: ہدایت شدہ گراف میں ، کناروں میں ایک سمت ہوتی ہے۔کناروں ایک طرفہ (ماخذ) سے دوسرے ورٹیکس (منزل) سے یکطرفہ رابطے ہیں۔کناروں کی نمائندگی تیر کے ذریعہ کی جاتی ہے ، جس سے کنکشن کی سمت کی نشاندہی ہوتی ہے۔ ویٹ گراف: وزن والے گراف میں ، ہر کنارے کو ایک وزن یا قیمت تفویض کی جاتی ہے جو دو عمودی کے مابین رابطے سے وابستہ کچھ قیمت کی نمائندگی کرتی ہے۔وزن والے گرافوں کا استعمال منظرنامے کے ماڈل کے لئے کیا جاتا ہے جہاں کناروں کے مختلف اخراجات یا فاصلے ہوتے ہیں۔ سائکلک گراف: ایک چکولک گراف میں کم از کم ایک سائیکل ہوتا ہے ، جو ایک ایسا راستہ ہے جو اسی طرح سے شروع ہوتا ہے اور ختم ہوتا ہے۔چکرک گراف میں دہرائے ہوئے عمودی اور کناروں میں ہوسکتا ہے ۔اسیکلک گراف: ایکائیکلک گراف ایک ایسا گراف ہے جس میں کوئی سائیکل نہیں ہوتا ہے۔اسے ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کے نام سے بھی جانا جاتا ہے۔ایسائکلک گراف اکثر ایسے منظرناموں میں استعمال ہوتے ہیں جہاں انحصار یا ترجیحی تعلقات کو ماڈلنگ کرنے کی ضرورت ہوتی ہے۔ منسلک گراف: ایک منسلک گراف وہ ہوتا ہے جس میں ہر جوڑے کے جوڑے کے درمیان راستہ ہوتا ہے۔دوسرے لفظوں میں ، ہر حد تک کناروں کے تسلسل کے ذریعے ہر دوسرے حصے سے قابل رسائ ہوتا ہے۔ متناسب گراف: منقطع گراف میں متعدد منسلک اجزاء پر مشتمل ہوتا ہے ، جہاں ہر جزو ایک سبگراف ہوتا ہے جو خود ہی جڑا ہوتا ہے۔مختلف اجزاء میں عمودی کے درمیان کوئی راستہ نہیں ہے۔ بائپارٹائٹ گراف: ایک دو طرفہ گراف ایک ایسا گراف ہے جس کے عمودی کو دو ناگوار سیٹوں میں تقسیم کیا جاسکتا ہے ، جیسے کہ تمام کناروں کو ایک سیٹ سے دوسرے سیٹ سے جوڑتے ہیں۔دوسرے لفظوں میں ، یہاں کوئی کناروں نہیں ہیں جو ایک ہی سیٹ کے اندر عمودی کو جوڑتے ہیں۔ یہ گراف کی اقسام کی صرف چند مثالیں ہیں ، اور مختلف ڈومینز اور ایپلی کیشنز میں استعمال ہونے والے گراف کی بہت سی دوسری خصوصی اقسام اور مختلف حالتیں ہیں۔گراف مختلف الگورتھم اور مسئلے کو حل کرنے کی تکنیکوں میں استعمال ہونے والے بنیادی اعداد و شمار کے ڈھانچے ہیں ، جیسے گراف ٹراورسل ، مختصر ترین راستہ الگورتھم ، نیٹ ورک فلو الگورتھم ، اور بہت کچھ۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں تاریخ اور وقت کو کس طرح سنبھالتے ہیں؟تاریخ آبجیکٹ کے استعمال اور عام تاریخ میں ہیرا پھیری کے طریقوں کی وضاحت کریں۔",
        "Answer": "ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر کے درمیان بنیادی فرق عناصر اور ان پراپرٹیز کی ترتیب میں ہے جو وہ برقرار رکھتے ہیں: من ڈھیر: ایک منٹ کے ڈھیر میں ، کسی بھی نوڈ کے لئے ، اس نوڈ کی قیمت اقدار سے کم یا اس کے برابر ہے۔اس کے بچے۔دوسرے لفظوں میں ، کم سے کم قیمت ہمیشہ ڈھیر کی جڑ میں رہتی ہے۔یہ پراپرٹی اس بات کو یقینی بناتی ہے کہ کم سے کم عنصر کو ڈھیر سے موثر طریقے سے بازیافت کیا جاسکتا ہے۔ میکس ہیپ: ایک زیادہ سے زیادہ ڈھیر میں ، کسی بھی نوڈ کے لئے ، اس نوڈ کی قدر اس کے بچوں کی اقدار سے زیادہ یا اس کے برابر ہے۔اس کے نتیجے میں ، زیادہ سے زیادہ قیمت ہمیشہ ڈھیر کی جڑ میں رہتی ہے۔یہ پراپرٹی ڈھیر سے زیادہ سے زیادہ عنصر کی موثر بازیافت کی اجازت دیتی ہے۔ دو منٹ کے ڈھیر اور زیادہ سے زیادہ ہیپس مکمل بائنری درخت ہیں ، اس کا مطلب یہ ہے کہ درخت کی تمام سطحیں ممکنہ طور پر آخری سطح کے سوا بھری ہوئی ہیں ، جو بائیں سے دائیں تک بھرا ہوا ہے۔ڈھیر میں عناصر کا حکم دینا ، چاہے کم سے کم ہو یا زیادہ سے زیادہ ، ڈھیر پراپرٹی کے ذریعہ طے کیا جاتا ہے ، جو اندراج اور نکالنے کے کاموں کے دوران برقرار رہتا ہے۔ایک منٹ کے ڈھیر میں ، سب سے چھوٹا عنصر ہمیشہ جڑ میں رہتا ہے ، اور زیادہ سے زیادہ ڈھیر میں ، سب سے بڑا عنصر ہمیشہ جڑ میں ہوتا ہے۔ وہ ای اے پی ایس عام طور پر ترجیحی قطار میں استعمال ہوتے ہیں ، جہاں عناصر کو ترجیحات تفویض کی جاتی ہیں اور ان کی بنیاد پر ان تک رسائی حاصل کرنے کی ضرورت ہوتی ہے۔ترجیحی آرڈرمن ڈھیر اکثر ترجیحی قطاروں کو نافذ کرنے کے لئے استعمال کیے جاتے ہیں جہاں سب سے چھوٹی ترجیح والے عنصر کو موثر انداز میں بازیافت کرنے کی ضرورت ہوتی ہے۔اسی طرح ، زیادہ سے زیادہ ڈھیر استعمال کیے جاتے ہیں جب سب سے زیادہ ترجیح والے عنصر کو موثر طریقے سے رسائی حاصل کرنے کی ضرورت ہوتی ہے۔ یہ نوٹ کرنا ضروری ہے کہ \"من ڈھیر\" اور \"میکس ہیپ\" کی اصطلاحات ڈھیر میں عناصر کی ترتیب کا حوالہ دیتے ہیں اور اعداد و شمار کے الگ الگ ڈھانچے نہیں ہیں۔ڈھیر کی بنیادی ڈھانچہ اور کاروائیاں ایک جیسی ہی رہتی ہیں ، قطع نظر اس سے کہ یہ ایک من ڈھیر ہے یا زیادہ سے زیادہ ڈھیر ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "کسی گراف پر گہرائی کی پہلی تلاش (DFS) الگورتھم کو نافذ کرنے کے ل you ، آپ اسٹیک کا استعمال کرتے ہوئے یا کسی تکرار نقطہ نظر کا استعمال کرتے ہوئے کسی تکراری نقطہ نظر کا استعمال کرسکتے ہیں۔یہاں اسٹیک کا استعمال کرتے ہوئے تکراری نقطہ نظر کی ایک قدم بہ قدم وضاحت ہے: نوڈس کو دیکھنے کے لئے ذخیرہ کرنے کے لئے ایک اسٹیک بنائیں۔اس کو شروع کرنے والے نوڈ کے ساتھ شروع کریں۔ ملاحظہ کرنے والے نوڈس کا ٹریک رکھنے کے لئے ایک سیٹ یا صف تیار کریں۔ جب اسٹیک خالی نہیں ہے: اسٹیک سے ایک نوڈ پاپ کریں۔ چیک کریں اگر نوڈ پہلے ہی ملاحظہ کیا گیا ہے۔اگر ایسا ہے تو ، اگلے تکرار کو جاری رکھیں۔ نوڈ کو ملاحظہ کریں اور اس پر کارروائی کریں۔ موجودہ نوڈ کے ملحقہ تمام نوڈس کو گیٹ کریں جن کا دورہ نہیں کیا گیا ہے اور انہیں اسٹیک پر دھکیلیں۔ازگر میں تکراری نقطہ نظر کا استعمال کرتے ہوئے ڈی ایف ایس الگورتھم کا ایک مثال عمل: پائیتھون کوپی کوڈیڈف ڈی ایف ایس (گراف ، اسٹارٹ_نوڈ): اسٹیک = [اسٹارٹ_نوڈ] ملاحظہ کریں = سیٹ () جبکہ اسٹیک: کرنٹ_نوڈ = اسٹیک.پوپ () اگر موجودہ_ نوڈ میں ملاحظہ کریں: جاری رکھیں۔.add (موجودہ_نوڈ) پرنٹ (کرنٹ_نوڈ) # پروسیس کریں موجودہ نوڈ # موجودہ نوڈ کے تمام ملحقہ نوڈس حاصل کریں اور انہیں گراف میں پڑوسی کے لئے اسٹیک پر دھکیلیں [موجودہ_نوڈ]مثال کے طور پر استعمال: گراف = {'a': ['b' ، 'c'] ، 'b': ['d' ، 'e'] ، 'c': ['f'] ، 'd': [].لغت میں ہر کلید ایک نوڈ سے مساوی ہے ، اور اس سے وابستہ قیمت ملحقہ نوڈس کی ایک فہرست ہے۔ ڈی ایف ایس الگورتھم دیئے گئے اسٹارٹ_نوڈ سے شروع ہوتا ہے اور بیک ٹریکنگ سے پہلے ہر شاخ کے ساتھ جہاں تک ممکن ہو تلاش کرتا ہے۔یہ دورے کے نوڈس کو اس ترتیب میں پرنٹ کرتا ہے جس کا ان کا سامنا کرنا پڑتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ کسی فنکشن کے عمل کو بہتر بنانے کے لئے اس کے نتائج کو بہتر بنائے۔اس میں مہنگے فنکشن کالز کے نتائج کو ذخیرہ کرنا اور جب وہی آدانوں کو دوبارہ ہوتا ہے تو انہیں کیشے سے بازیافت کرنا شامل ہوتا ہے۔یادداشت پہلے کے حساب شدہ نتائج کو دوبارہ استعمال کرکے بے کار کمپیوٹوں کو ختم کرتی ہے ، اس طرح الگورتھم کی مجموعی وقت کی پیچیدگی کو کم کرتی ہے۔یہ افعال کسی مسئلے کو بار بار چھوٹے چھوٹے مضامین میں توڑ کر حل کرتے ہیں۔تاہم ، یادداشت کے بغیر ، ایک ہی ذیلی مسائل کو متعدد بار حل کیا جاسکتا ہے ، جس کی وجہ سے غیر ضروری کمپیوٹوں کا سبب بنتا ہے۔ متحرک پروگرامنگ میں یادداشت کا استعمال کیا جاتا ہے: تکرار کرنے والے فنکشن کی شناخت کریں: ایک تکرار فنکشن کی تلاش کریں جو اوورلیپنگ سب پروبلوبلز کی پراپرٹی کو ظاہر کرتا ہے ، جہاں ایک ہی ذیلی پروبلیس کو ظاہر کرتا ہے۔متعدد بار حل کیے جاتے ہیں۔ ایک کیشے کو تیار کریں: اعداد و شمار کے ڈھانچے کو شروع کریں ، جیسے سرنی یا ہیش ٹیبل ، پہلے کمپیوٹڈ نتائج کو ذخیرہ کرنے کے لئے کیشے کے طور پر کام کریں۔کیشے کو ان پٹ (یا آدانوں کا مجموعہ) ان کے متعلقہ آؤٹ پٹ پر نقشہ بنانے کے قابل ہونا چاہئے۔ فنکشن کو تبدیل کریں: پہلے چیک کرنے کے لئے تکرار کرنے والی تقریب میں ترمیم کریں کہ آیا دیئے گئے ان پٹ کا نتیجہ پہلے ہی کیشے میں موجود ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، کیشڈ نتیجہ کو دوبارہ تشکیل دینے کے بجائے واپس کردیں۔اگر نتیجہ کیشے میں نہیں ہے تو ، اسے معمول کے مطابق حساب کریں اور اسے واپس کرنے سے پہلے کیشے میں اسٹور کریں۔ نتائج کو یاد کرتے ہوئے ، اسی آدانوں کے ساتھ تکرار کرنے والی تقریب میں آنے والی کالوں کو مستقل وقت میں حل کیا جاسکتا ہے ، کیونکہ نتیجہ پہلے ہی موجود ہے۔کیشے میں دستیاب ہے۔یہ بے کار حساب سے گریز کرتا ہے اور الگورتھم کی مجموعی کارکردگی کو نمایاں طور پر بہتر بناتا ہے۔ یہاں ازگر میں ایک سادہ مثال ہے جو ایک بار بار چلنے والی فبونیکی فنکشن کا استعمال کرتے ہوئے یادداشت کا مظاہرہ کرتی ہے: پائیتھونکپی کوڈ# کیچڈف فبونیکی (این ، کیشے = {{}) کے ساتھ میمورائزیشن کا استعمال کرتے ہوئے: اگر این میں این ، کیشے = {})کیشے: واپس کیشے [n] اگر n <= 1: نتیجہ = n else: نتیجہ = fibonacci (n - 1) + fibonacci (n - 2) کیشے [n] = نتیجہ کی واپسی کا نتیجہ# مثال کے طور پر استعمال کے نشان (fibonacci (5))# آؤٹ پٹ: 5 پرنٹ (فبوناکی (10)) # آؤٹ پٹ: 555 اس مثال کے طور پر ، فبونیکی فنکشن کیش لغت میں کمپیوٹڈ فبونیکی نمبروں کو ذخیرہ کرنے کے لئے میموائزیشن کا استعمال کرتا ہے۔اس کے بعد کی کالوں پر ، اگر دیئے گئے انڈیکس کے لئے فبونیکی نمبر پہلے ہی کیشے میں موجود ہے تو ، اسے براہ راست بازیافت کیا جاتا ہے ، جس سے بے کار کمپیوٹیشن کی ضرورت کو ختم کیا جاتا ہے۔ فبونیکی نمبروں کو یاد کرتے ہوئے ، فنکشن کی وقت کی پیچیدگی کو کفایت شعاری سے کم کیا جاتا ہے (O (O (O (O (2^n)) لکیری (O (n))۔ان پٹ ویلیو ن میں اضافے کے ساتھ ہی یہ بہتری زیادہ اہم ہوجاتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "ڈجکسٹرا کا الگورتھم ایک مقبول الگورتھم ہے جو غیر منفی کنارے کے وزن والے گراف میں نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتا ہے۔یہ ہدایت اور غیر ہدایت شدہ دونوں گرافوں پر کام کرتا ہے اور گراف کے دوسرے تمام نوڈس تک ایک ہی ماخذ نوڈ سے کم ترین راستہ تیار کرتا ہے۔ الگورتھم ہر نوڈ کے لئے \"غیر منحصر\" نوڈس اور \"فاصلے\" کی قیمت کا ایک سیٹ برقرار رکھتا ہے ، ابتدائی طور پر انفینٹی پر سیٹ کیا جاتا ہے۔سوائے سورس نوڈ کے جو 0 پر سیٹ کیا گیا ہے۔یہ عمل اس وقت تک جاری ہے جب تک کہ تمام نوڈس کا دورہ نہ کیا جائے یا منزل کا نوڈ پہنچا نہ جائے۔ یہاں ڈجکسٹرا کے الگورتھم کی ایک قدم بہ قدم وضاحت: گراف کو شروع کریں اور ماخذ نوڈ کا فاصلہ 0 اور دیگر تمام نوڈس کو انفینٹی پر سیٹ کریں۔ایک ترجیحی قطار (جو اکثر ایک من ڈھیر کے طور پر نافذ کی جاتی ہے) نوڈس کو ان کے فاصلوں کی بنیاد پر ذخیرہ کرنے کے لئے۔ماخذ نوڈ کو ترجیحی قطار میں داخل کریں۔ جب ترجیحی قطار خالی نہیں ہے: ترجیحی قطار سے کم سے کم فاصلے کے ساتھ نوڈ نکالیں۔یہ نوڈ \"موجودہ\" نوڈ ہے۔ موجودہ نوڈ کو دیکھیں۔نیا فاصلہ پڑوسی کے موجودہ فاصلے سے کم ہے ، پڑوسی کے فاصلے کو اپ ڈیٹ کریں۔ اگر ہمسایہ غیر منحصر ہے تو ، اسے ترجیحی قطار میں داخل کریں۔ ایک بار منزل نوڈ کا دورہ کیا گیا ہے یا ترجیحی قطار خالی ہے ، الگورتھم ختم ہوجاتا ہے۔الگورتھم کے دوران حساب کی جانے والی دوری گراف میں ماخذ نوڈ سے دوسرے تمام نوڈس تک مختصر ترین راستوں کی نمائندگی کرتی ہے۔ ڈیجکسٹرا کا الگورتھم اس بات کی ضمانت دیتا ہے کہ جب الگورتھم ختم ہوجاتا ہے تو منبع نوڈ سے کسی دوسرے نوڈ تک کا مختصر ترین راستہ پایا جاتا ہے۔تاہم ، یہ غیر منفی کنارے کے وزن کو فرض کرتا ہے اور گراف میں منفی چکروں کو نہیں سنبھالتا ہے۔ ڈیجکسٹرا کا الگورتھم مختلف ایپلی کیشنز میں وسیع پیمانے پر استعمال ہوتا ہے جیسے نیٹ ورک روٹنگ پروٹوکول ، جی پی ایس نیویگیشن سسٹم ، اور ٹرانسپورٹیشن نیٹ ورکس میں مختصر ترین راستے کی پریشانیوں کو حل کرنا ، دوسروں کے درمیان۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "اے وی ایل کے درخت اور سرخ رنگ کے دونوں درخت خود کو متوازن کرنے والے بائنری تلاش کے درخت ہیں جو درخت کی اونچائی کو متوازن رکھتے ہوئے موثر کارروائیوں کو یقینی بناتے ہیں۔تاہم ، ان کے مابین کچھ اختلافات موجود ہیں: توازن کے معیار: AVL درخت: ایک AVL درخت میں ، ہر نوڈ کا توازن عنصر ، بائیں subtree مائنس کی اونچائی کے طور پر بیان کیا جاتا ہے ، دائیں سبٹری کی اونچائی ، یا تو -1 ، 0 ہونا چاہئے۔، یا 1. اگر کسی بھی نوڈ کا توازن عنصر اس حد سے باہر ہوجاتا ہے تو ، درخت کو گردش کی کارروائیوں کو انجام دے کر توازن دیا جاتا ہے۔ ریڈ-بلیک ٹری: سرخ رنگ کے درخت میں ، ہر نوڈ کو رنگ تفویض کیا جاتا ہے-یا تو سرخ یا سیاہ۔درخت کو مندرجہ ذیل خصوصیات کو پورا کرنا چاہئے: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ نوڈ سیاہ ہے۔ ہر پتی نوڈ (نیل یا کال) سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔ ہر نوڈ کے لئے ، سب کے لئے ، سبنوڈ سے اس کی اولاد کے پتے تک کے راستوں میں ایک ہی تعداد میں سیاہ نوڈس ہوتے ہیں۔یہ پراپرٹی اس بات کو یقینی بناتی ہے کہ سب سے لمبا راستہ دوگنا سے زیادہ نہیں ہے جب تک کہ کم ترین راستہ۔ متوازن آپریشنز: اے وی ایل ٹری: اے وی ایل کے درختوں میں توازن گھومنے کے ذریعے حاصل کیا جاتا ہے ، بشمول بائیں گردشوں ، دائیں گردشوں ، اور ڈبل گردشوں (بائیں اور ایک مجموعہدائیں گردش) .ڈ-بلیک ٹری: سرخ رنگ کے درختوں میں توازن رکھنے میں رنگین پلٹیاں (نوڈس کے رنگوں کو تبدیل کرنا) اور گردشوں کا ایک مجموعہ شامل ہوتا ہے ، بشمول بائیں گردش ، دائیں گردش ، اور گردشوں کا ایک مجموعہ۔ توازن بمقابلہ سختی: AVLدرخت: AVL درخت سرخ رنگ کے درختوں کے مقابلے میں سخت توازن فراہم کرتے ہیں۔وہ اس بات کی ضمانت دیتے ہیں کہ ہر نوڈ کے بائیں اور دائیں سبٹریوں کے درمیان اونچائی کا فرق زیادہ سے زیادہ 1 ہوتا ہے ، جس کے نتیجے میں اونچائی متوازن درخت ہوتا ہے۔ سرخ رنگ کا درخت: سرخ سیاہ درخت AVL درختوں کے مقابلے میں زیادہ آرام دہ توازن کی حالت فراہم کرتے ہیں۔وہ اس بات کو یقینی بناتے ہیں کہ جڑ سے پتے تک سب سے لمبا راستہ دوگنا نہیں ہے جب تک کہ مختصر ترین راستہ۔اس کے نتیجے میں ، سرخ سیاہ درخت سخت اونچائی کے توازن کے بجائے مجموعی توازن کو ترجیح دیتے ہیں۔ کارکردگی کے اختلافات: اے وی ایل کے درخت: اے وی ایل کے درختوں میں عام طور پر سرخ سیاہ درختوں کے مقابلے میں تیز رفتار دیکھنے کا وقت ہوتا ہے کیونکہ وہ زیادہ سخت توازن فراہم کرتے ہیں۔تاہم ، ان کو اندراج اور حذف کرنے کی کارروائیوں کے دوران زیادہ گردشوں کی ضرورت ہوتی ہے ، جو ان کارروائیوں کو آہستہ آہستہ بناسکتے ہیں۔ ریڈ-بلیک ٹری: سرخ رنگ کے درختوں میں مجموعی طور پر زیادہ متوازن ڈھانچہ ہوتا ہے ، جس کے نتیجے میں AVL درختوں کے مقابلے میں اندراج اور حذف کرنے کے کاموں میں بہتر کارکردگی ہوتی ہے۔کم سخت توازن کی ضروریات کی وجہ سے ان میں تھوڑا سا سست وقت ہوسکتا ہے۔ اے وی ایل کے درختوں اور سرخ سیاہ درختوں کے مابین انتخاب درخواست کی مخصوص ضروریات پر منحصر ہے۔جب تیز نظریں ناگزیر ہوں تو اے وی ایل کے درخت موزوں ہیں ، جب کہ سرخ رنگ کے درختوں کو ترجیح دی جاتی ہے جب تلاش ، اندراج اور حذف کرنے کے کاموں کے مابین اچھا توازن مطلوب ہوتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "ایک ریڈکس درخت ، جسے ٹری یا پریفکس ٹری بھی کہا جاتا ہے ، ایک خاص درخت کے اعداد و شمار کا ڈھانچہ ہے جو موثر اسٹوریج اور تاروں کی بازیافت کے لئے استعمال ہوتا ہے۔یہ خاص طور پر لغت کے نفاذ ، آٹومپلیٹ سسٹم ، اور آئی پی روٹنگ ٹیبلز جیسے ایپلی کیشنز کے لئے مفید ہے۔ ریڈکس ٹری اپنے کرداروں کے ذریعہ تاروں کا اہتمام کرتا ہے ، جس میں ہر نوڈ ایک سابقہ یا مکمل تار کی نمائندگی کرتا ہے۔یہاں ایک جائزہ ہے کہ ایک ریڈکس ٹری کس طرح کام کرتا ہے: نوڈ ڈھانچہ: ریڈکس ٹری میں ہر نوڈ میں کئی اجزاء ہوتے ہیں: کلیدی/کردار: نوڈ سے وابستہ کردار۔مثال کے طور پر ، لغت کے نفاذ میں ، ہر کردار کسی لفظ میں ایک خط کی نمائندگی کرتا ہے۔ بچوں: بچوں کے نوڈس کے اشارے یا حوالہ۔ہر بچہ ایک ممکنہ کردار سے مطابقت رکھتا ہے جو لفظ مارکر کے موجودہ نوڈ کی پیروی کرسکتا ہے: ایک جھنڈا جس سے یہ ظاہر ہوتا ہے کہ آیا نوڈ ایک مکمل لفظ کے اختتام کی نمائندگی کرتا ہے۔ ریڈکس ٹری کی تعمیر: ریڈکس کا درخت ابتدائی طور پر خالی ہے ، جس میں صرف ایک جڑ نوڈ ہے۔چونکہ درخت میں ڈور ڈالے جاتے ہیں ، حروف کو بائیں سے دائیں تک عبور کیا جاتا ہے۔ داخلہ آپریشن: ریڈکس ٹری میں ایک تار داخل کرنا: جڑ نوڈ پر شروع کریں۔ چیک کریں اگر موجودہ کردار موجودہ نوڈ کے بچے کی طرح موجود ہے۔کیا ، متعلقہ بچے کی طرف بڑھیں اور اگلے کردار کی طرف بڑھیں۔ اگر ایسا نہیں ہوتا ہے تو ، موجودہ کردار کے لئے ایک نیا چائلڈ نوڈ بنائیں اور اس بچے کی طرف بڑھیں۔ اس عمل کو اس وقت تک جاری رکھیں جب تک کہ تار کے تمام کرداروں پر کارروائی نہیں کی جاتی ہے۔حتمی نوڈ کسی لفظ کے اختتام کے طور پر۔ سرچ آپریشن: ریڈکس ٹری میں تار تلاش کرنے کے لئے: روٹ نوڈ پر شروع کریں۔ ہدف کے تار میں ہر کردار کے لئے ، چیک کریں کہ آیا کوئی بچہ نوڈ موجود ہے یا نہیں۔، اس بچے کی طرف بڑھیں اور اگلے کردار کی طرف بڑھیں۔ اگر کسی بچے کا نوڈ موجود نہیں ہے تو ، اسٹرنگ ریڈکس ٹری میں موجود نہیں ہے۔ تمام حروف پر کارروائی کرنے کے بعد ، چیک کریں کہ آیا حتمی نوڈ کو کسی لفظ کے اختتام کے طور پر نشان زد کیا گیا ہے۔اگر یہ ہے تو ، تار مل جاتا ہے۔بصورت دیگر ، یہ موجود نہیں ہے۔ ریڈکس ٹری موثر اسٹوریج اور تاروں کی بازیافت فراہم کرتا ہے جو مختلف تاروں میں عام سابقوں کو مؤثر طریقے سے بانٹ کر تاروں کی بازیافت کرتا ہے۔اس سے تار کو ذخیرہ کرنے کے لئے درکار مجموعی جگہ کو کم کیا جاتا ہے اور تلاش کی کارکردگی کو بہتر بنایا جاتا ہے۔ ریڈکس کے درخت میں آپریشن کی وقت کی پیچیدگی ، جیسے اندراج اور تلاش ، تاروں کی لمبائی پر منحصر ہے۔بہترین صورتحال میں ، جہاں ڈوروں کے مابین کوئی مشترکہ سابقہ نہیں ہوتا ہے ، وقت کی پیچیدگی O (M) ہوتی ہے ، جہاں ایم ہدف کے تار کی لمبائی ہوتی ہے۔تاہم ، بدترین صورتحال میں ، جہاں تمام ڈوروں کا ایک ہی سابقہ ہوتا ہے ، وقت کی پیچیدگی O (n) ہوسکتی ہے ، جہاں N تمام تار میں حروف کی کل تعداد ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "بی ٹری ایک خود توازن رکھنے والا درخت ڈیٹا ڈھانچہ ہے جو ڈسک پر یا ثانوی اسٹوریج میں بڑی مقدار میں ڈیٹا کو موثر انداز میں اسٹور کرنے اور بازیافت کرنے کے لئے ڈیزائن کیا گیا ہے۔یہ سست رسائی کے اوقات کے ساتھ نظاموں کے ل optim بہتر ہے ، جیسے ہارڈ ڈرائیوز ، جہاں کم سے کم ڈسک ریڈز کارکردگی کے لئے بہت ضروری ہے۔ایک بی ٹری بائنری سرچ ٹری (بی ایس ٹی) سے کئی طریقوں سے مختلف ہے: نوڈ ڈھانچہ: بائنری سرچ ٹری میں ، ہر نوڈ میں عام طور پر ایک ہی کلید اور دو بچوں کے پوائنٹر ہوتے ہیں ، جو بائیں اور دائیں سبٹریز کی نمائندگی کرتے ہیں۔اس کے برعکس ، بی ٹری نوڈ میں متعدد چابیاں اور بچوں کے پوائنٹرز شامل ہوسکتے ہیں۔نوڈ میں چابیاں کی تعداد ایک خاص حد کے اندر ہے ، جس کا تعین بی ٹری کے حکم سے ہوتا ہے۔بی ٹری کا ترتیب نوڈ میں اجازت دی گئی کم سے کم اور زیادہ سے زیادہ چابیاں کا تعین کرتا ہے۔آرڈر ایم کے ایک بی ٹری میں نوڈ میں زیادہ تر M-1 کیز اور ایم چائلڈ پوائنٹرز ہوسکتے ہیں ، سوائے جڑ کے نوڈ کے ، جس میں کم از کم 1 کلید ہے۔ توازن اور اونچائی: بائنری تلاش کے درخت کے برعکس ، جہاں توازن ہےبائیں اور دائیں سبٹریز میں نوڈس کی تقریبا برابر تعداد کو برقرار رکھتے ہوئے حاصل کیا گیا ، ایک بی ٹری ایک ہی سطح پر پتے کے تمام نوڈس کو رکھ کر توازن حاصل کرتا ہے۔یہ متوازن ڈھانچہ اس بات کو یقینی بناتا ہے کہ درخت کی اونچائی چابیاں کی تعداد کے مقابلے میں نسبتا small چھوٹی رہتی ہے ، جس کی وجہ سے ڈسک تک رسائی حاصل ہوتی ہے۔ تلاش اور داخلہ: بائنری سرچ ٹری میں ، تلاش اور اندراج کی کارروائیوں پر مبنی ایک سخت بائیں دائیں موازنہ کی پیروی کی جاتی ہے۔کلیدی اقدار۔بی ٹری میں ، کلیدی حدود کی بنیاد پر چائلڈ پوائنٹرز کے بعد ، تلاش اور اندراج کے کاموں میں درخت کو نیچے کی طرف جانا شامل ہوتا ہے۔اس سے موثر ڈسک تک رسائی حاصل کرنے کی اجازت ملتی ہے اور مطلوبہ موازنہ کی تعداد کو کم کیا جاتا ہے۔ ڈسک رسائی کی اصلاح: بی ٹری خاص طور پر موثر ڈسک تک رسائی کے ل designed تیار کی گئی ہیں۔ان کا مقصد ڈیٹا تک رسائی یا اس میں ترمیم کرنے کے لئے درکار ڈسک ریڈز کی تعداد کو کم سے کم کرنا ہے۔فی نوڈ کی چابیاں کی تعداد میں اضافہ کرکے ، بی ٹری درخت کی اونچائی کو کم کرتے ہیں ، جس کے نتیجے میں اعداد و شمار تک رسائی یا اس میں ترمیم کرتے وقت کم سطح گزر جاتی ہے۔ درخواستیں: بی ٹری عام طور پر فائل سسٹم ، ڈیٹا بیس اور دیگر اسٹوریج سسٹم میں استعمال ہوتی ہیں جہاںبڑی مقدار میں ڈیٹا کو ڈسک پر ذخیرہ کرنے کی ضرورت ہے۔وہ ایسے منظرناموں کے ل well مناسب ہیں جہاں تیز رسائی اور موثر ڈسک I/O آپریشن ضروری ہیں۔ سب سے زیادہ ، بی ٹری ایک ورسٹائل ڈیٹا ڈھانچہ ہے جو موثر اسٹوریج اور ڈسک پر بڑی مقدار میں ڈیٹا کی بازیافت کی اجازت دیتا ہے۔درخت کی اونچائی کو متوازن کرنے ، ڈسک کے پڑھنے کو کم کرنے ، اور ہر نوڈ کی مختلف قسم کی چابیاں سنبھالنے کی اس کی صلاحیت یہ ڈسک پر مبنی ایپلی کیشنز کے ل an ایک بہترین انتخاب بناتی ہے ، جبکہ بائنری تلاش کے درخت اکثر میموری پر مبنی منظرناموں میں استعمال ہوتے ہیں جہاں تیز کلیدی طور پر مبنی تلاشیبنیادی تشویش ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ڈی ایس اے کا مطلب مختلف سیاق و سباق میں متعدد شرائط ہے۔یہاں ڈی ایس اے کے کچھ عام معنی ہیں: ڈیٹا ڈھانچے اور الگورتھم: کمپیوٹر سائنس میں ، ڈی ایس اے سے مراد اعداد و شمار کے ڈھانچے (جیسے صفوں ، لنکڈ فہرستوں ، درختوں ، گرافوں ، وغیرہ) اور الگورتھم (جیسے چھانٹ رہا ہے ،تلاش ، گراف الگورتھم ، وغیرہ) مسائل کو موثر طریقے سے حل کرنے کے لئے استعمال کیا جاتا ہے۔ ڈیجیٹل دستخط الگورتھم: ڈی ایس اے ایک کریپٹوگرافک الگورتھم ہے جو ڈیجیٹل دستخطوں کو پیدا کرنے اور اس کی تصدیق کے لئے استعمال ہوتا ہے۔یہ ڈیجیٹل دستخطوں کے لئے وسیع پیمانے پر استعمال ہونے والا معیار ہے اور یہ ماڈیولر اخراج اور مجرد لوگریتھم کے ریاضی کے تصورات پر مبنی ہے۔ ڈائرکٹ سیلنگ ایسوسی ایشن: ڈی ایس اے ایک ایسی انڈسٹری ٹریڈ ایسوسی ایشن ہے جو ایسی کمپنیوں کی نمائندگی کرتی ہے جو براہ راست فروخت میں ملوث ہے۔یہ براہ راست فروخت ہونے والی کمپنیوں کے لئے مدد ، وکالت اور تعلیم مہیا کرتا ہے اور صنعت کے اندر اخلاقی کاروباری طریقوں کو فروغ دیتا ہے۔ امریکہ کے جمہوری سوشلسٹ: ڈی ایس اے ریاستہائے متحدہ میں ایک سیاسی تنظیم ہے جو جمہوری سوشلزم کی حمایت کرتی ہے۔یہ ملک کی سب سے بڑی سوشلسٹ تنظیم ہے اور ترقی پسند پالیسی کی تبدیلیوں ، معاشرتی انصاف ، اور معاشی مساوات کی طرف کام کرتی ہے۔ یہ صرف چند مثالیں ہیں کہ ڈی ایس اے کیا حوالہ دے سکتا ہے ، اور اس مخصوص تناظر پر منحصر اور اس کے دوسرے معنی بھی ہوسکتے ہیں جس میںاصطلاح استعمال کی جاتی ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "ڈیٹا کا ڈھانچہ کمپیوٹر کی میموری میں ڈیٹا کو منظم اور اسٹور کرنے کا ایک طریقہ ہے تاکہ اس تک رسائی اور موثر انداز میں ہیرا پھیری کی جاسکے۔یہ ایک منطقی نمائندگی فراہم کرتا ہے کہ اعداد و شمار کو کس طرح منظم کیا جاتا ہے ، جس سے موثر اسٹوریج ، بازیافت ، اور معلومات کی ہیرا پھیری کی اجازت ہوتی ہے۔ ڈیٹا ڈھانچے کو دو اہم زمروں میں درجہ بندی کیا جاسکتا ہے: قدیم اعداد و شمار کے ڈھانچے اور جامع ڈیٹا ڈھانچے۔ بنیادی اعداد و شمار کے ڈھانچے: یہ بنیادی ہیںپروگرامنگ زبانوں کے ذریعہ فراہم کردہ بلاکس بلڈنگ۔مثالوں میں شامل ہیں: انٹیجر: پوری تعداد (جیسے ، 1 ، 2 ، 3) اسٹور کرتا ہے۔ فلوٹ: اسٹورز اعشاریہ اعشاریہ (جیسے ، 3.14 ، 2.718)۔ چیریکٹر: ایک ہی حرف (جیسے ، 'اے' ، 'بی' ، 'سی' کو اسٹور کرتا ہے۔.مثالوں میں شامل ہیں: صفیں: ایک ہی قسم کے عناصر کا ایک مجموعہ ، انڈیکس کا استعمال کرتے ہوئے رسائی حاصل کی گئی۔(LIFO) ڈھانچہ جہاں عناصر کو ایک ہی سرے سے شامل اور ہٹا دیا جاتا ہے۔کناروں کے ذریعہ جڑے ہوئے نوڈس ، اوپر کی جڑ نوڈ کے ساتھ۔ گرافس: کناروں کے ذریعہ منسلک نوڈس (عمودی) کا ایک مجموعہ ، پیچیدہ تعلقات کی اجازت دیتا ہے۔ ڈیٹا ڈھانچے کا انتخاب ہاتھ میں مسئلے کی مخصوص ضروریات پر منحصر ہے۔مختلف اعداد و شمار کے ڈھانچے میں مختلف خصوصیات ہیں ، جیسے میموری کے استعمال کے لحاظ سے ان کی کارکردگی ، رسائی کی رفتار ، اندراج اور حذف کرنے کی کارروائیوں ، اور مخصوص قسم کے کاموں کے ل suit مناسبیت۔ڈیٹا کے ڈھانچے اور ان کی خصوصیات کو سمجھنا موثر الگورتھم ڈیزائن اور نفاذ کے لئے بنیادی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "صفوں اور لنکڈ فہرستیں دونوں اعداد و شمار کے ڈھانچے ہیں جو عناصر کے مجموعوں کو اسٹور اور منظم کرنے کے لئے استعمال ہوتے ہیں۔تاہم ، وہ اپنے بنیادی ڈھانچے ، میموری کے انتظام اور کارکردگی کی خصوصیات کے لحاظ سے مختلف ہیں۔صفوں اور منسلک فہرستوں کے مابین کلیدی اختلافات یہ ہیں: ڈھانچہ: سرنی: ایک سرنی میموری کا ایک متنازعہ بلاک ہے جو ایک ہی قسم کے عناصر کو اسٹور کرتا ہے۔عنصروں تک انڈیکس کا استعمال کرتے ہوئے رسائی حاصل کی جاتی ہے ، تخلیق کے وقت طے شدہ سائز کا تعین کیا جاتا ہے۔صفوں کی ایک مقررہ لمبائی ہوتی ہے اور ان کے اشاریہ کی بنیاد پر عناصر تک براہ راست رسائی فراہم کرتی ہے۔ لنکڈ فہرست: ایک لنکڈ فہرست نوڈس پر مشتمل ہوتی ہے جہاں ہر نوڈ میں ترتیب میں اگلے نوڈ کے لئے ایک قدر اور حوالہ (یا پوائنٹر) ہوتا ہے۔نوڈس ضروری طور پر میموری کے متضاد مقامات پر محفوظ نہیں ہوتے ہیں ، جس سے متحرک میموری کی مختص کرنے کی اجازت ہوتی ہے۔منسلک فہرستیں لمبائی میں مختلف ہوسکتی ہیں اور عناصر تک ترتیب تک رسائی فراہم کرسکتی ہیں۔ میموری مینجمنٹ: سرنی: صفوں کو تمام عناصر کو ذخیرہ کرنے کے لئے میموری کا پہلے سے مختص بلاک کی ضرورت ہوتی ہے۔سرنی کا سائز طے شدہ ہے اور عناصر کو نقل کرنے اور عناصر کی کاپی کیے بغیر آسانی سے تبدیل نہیں کیا جاسکتا۔ہر نوڈ میں اگلے نوڈ کا حوالہ ہوتا ہے ، جس سے عناصر کو شامل کرنے یا ہٹانے میں لچک کی اجازت ہوتی ہے۔منسلک فہرستیں متضاد میموری کی ضرورت کے بغیر متحرک طور پر بڑھ سکتی ہیں یا سکڑ سکتی ہیں۔ داخلہ اور حذف کرنا: سرنی: ایک سرنی میں داخل کرنا یا حذف کرنا مہنگا ہوسکتا ہے اگر اسے آرڈر کو برقرار رکھنے کے لئے شفٹ کرنے والے عناصر کی ضرورت ہو یا اگر اسے صف کا سائز تبدیل کرنے کی ضرورت ہو۔کسی سرنی کے آغاز یا وسط میں عناصر کو داخل کرنا یا حذف کرنے کے لئے بعد کے عناصر کو تبدیل کرنا ضروری ہے۔ لنکڈ فہرست: منسلک فہرست میں داخل کرنا یا حذف کرنا نسبتا effective موثر ہے۔نوڈ کے اندراج یا حذف کرنے میں دوسرے عناصر کو منتقل کرنے کی ضرورت کے بغیر ، کچھ پوائنٹرز کو ایڈجسٹ کرنا شامل ہے۔تاہم ، لنکڈ فہرست میں کسی مخصوص عنصر تک رسائی کے لئے شروع سے ہی فہرست کو عبور کرنے کی ضرورت ہوتی ہے۔کسی مخصوص انڈیکس میں کسی عنصر تک رسائی موثر ہے اور اس میں مستقل وقت کی پیچیدگی (O (1)) ہے۔ منسلک فہرست: منسلک فہرستیں براہ راست بے ترتیب رسائی فراہم نہیں کرتی ہیں۔کسی مخصوص انڈیکس میں کسی عنصر تک رسائی کے ل the ، فہرست کو شروع سے ہی ترتیب سے گزرنا چاہئے ، جس کے نتیجے میں لکیری ٹائم پیچیدگی (O (n)) ہوتی ہے۔ خلاصہ یہ کہ صفیں بے ترتیب رسائی اور مقررہ سائز کا اسٹوریج فراہم کرتی ہیں لیکن اس میں محدود لچک ہوتی ہے۔متحرک سائز اور اندراج/حذف کرنے کی کارروائیوں کی شرائط۔منسلک فہرستیں سائز اور اندراج/حذف کرنے کے کاموں میں لچک پیش کرتی ہیں لیکن ان تک رسائی کے اوقات سست ہوتے ہیں اور اضافی پوائنٹرز کی وجہ سے زیادہ میموری استعمال کرتے ہیں۔صفوں اور منسلک فہرستوں کے مابین انتخاب مسئلے کی مخصوص ضروریات پر منحصر ہے ، جیسے بے ترتیب رسائی ، بار بار اندراج/حذف کرنے ، یا میموری کی کارکردگی کی ضرورت۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "ایک اسٹیک اور قطار دونوں لکیری ڈیٹا ڈھانچے ہیں جو عناصر کو ذخیرہ کرنے اور ان میں ہیرا پھیری کے لئے استعمال ہوتے ہیں۔تاہم ، وہ اس ترتیب کے لحاظ سے مختلف ہیں جس میں عناصر تک رسائی اور ہٹا دیا جاتا ہے۔یہاں اسٹیک اور ایک قطار کے درمیان کلیدی اختلافات ہیں: اسٹیک: آخری ان پہلی آؤٹ (LIFO): ایک اسٹیک میں ، آخری عنصر جو شامل کیا جاتا ہے (دھکا دیا جاتا ہے) پہلے ہی ہٹایا جاتا ہے (پاپڈ)۔اس کے بارے میں پلیٹوں کے اسٹیک کی طرح سوچئے ، جہاں آپ صرف اوپر سے پلیٹوں کو شامل یا ہٹا سکتے ہیں۔اس کو ہٹائے بغیر سب سے اوپر کا عنصر۔ مثال کے طور پر: کتابوں کے ڈھیر پر غور کریں۔جب آپ کسی کتاب کو ہٹاتے ہیں تو سب سے اوپر رکھی گئی آخری کتاب پہلی کتاب ہے۔اس کے بارے میں سوچئے کہ لائن میں انتظار کرنے والے لوگوں کی قطار کی طرح ، جہاں پہلے پہنچنے والا پہلا شخص پیش کیا جائے۔قطار کے سامنے (سر) سے۔جب پہلے پہنچنے والا گاہک پہلے پہنچے گا تو اس کی خدمت کی جائے گی جب ایک کیشیئر صارفین کی خدمت کرتا ہے۔ خلاصہ میں ، اسٹیک اور قطار کے درمیان بنیادی فرق وہ ترتیب ہے جس میں عناصر تک رسائی اور ہٹا دیا جاتا ہے۔ایک اسٹیک آخری ان فرسٹ آؤٹ (LIFO) اصول کی پیروی کرتا ہے ، جبکہ ایک قطار پہلے ان فرسٹ آؤٹ (FIFO) اصول کی پیروی کرتی ہے۔اسٹیک کو ایسے منظرناموں میں استعمال کیا جاتا ہے جہاں حال ہی میں شامل کردہ عناصر دلچسپی رکھتے ہیں (جیسے ، فنکشن کال اسٹیک) ، جبکہ قطاریں منظرناموں میں استعمال ہوتی ہیں جہاں اندراج کا حکم ضروری ہوتا ہے (جیسے ، ملازمت کا نظام الاوقات ، چوڑائی کی پہلی تلاش الگورتھم)۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "ایک ہیش ٹیبل ، جسے ہیش میپ کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو موثر اندراج ، حذف کرنے اور بازیافت کے کام فراہم کرتا ہے۔اس میں ہیشنگ نامی ایک تکنیک استعمال کی گئی ہے تاکہ وہ اپنی چابیاں پر مبنی عناصر کو ذخیرہ کریں اور بازیافت کریں۔ایک ہیش ٹیبل میں بالٹیوں یا سلاٹوں کی ایک صف شامل ہوتی ہے ، جہاں ہر سلاٹ ایک یا زیادہ کلیدی قدر کے جوڑے کو ذخیرہ کرسکتا ہے۔ ہیش ٹیبل کس طرح کام کرتا ہے: ہیش فنکشن: ایک ہیش فنکشن ان پٹ کی حیثیت سے ایک کلید لیتا ہے اور ہیش کوڈ کی گنتی کرتا ہے ،ایک عدد قیمت ہے۔ہیش کوڈ کو انڈیکس یا بالٹی کا تعین کرنے کے لئے استعمال کیا جاتا ہے جہاں متعلقہ کلیدی قدر کی جوڑی کو صف میں محفوظ کیا جائے گا۔ انڈیکس حساب کتاب: ہیش کوڈ عام طور پر ماڈیولو ڈویژن نامی عمل کا استعمال کرتے ہوئے صف کے اندر انڈیکس کا حساب لگانے کے لئے استعمال ہوتا ہے۔ماڈیولو آپریشن اس بات کو یقینی بناتا ہے کہ انڈیکس سرنی کی درست حد میں آتا ہے۔ کولیشن ہینڈلنگ: ہیش کے افعال مختلف چابیاں کے لئے ایک ہی ہیش کوڈ تیار کرسکتے ہیں ، جس سے تصادم کا باعث بنتا ہے۔تصادم اس وقت ہوتا ہے جب ایک ہی انڈیکس کے دو یا زیادہ کلیدوں کا نقشہ۔تصادم کو سنبھالنے کے ل different ، مختلف تکنیکیں ہیں: الگ الگ زنجیر: ہیش ٹیبل میں ہر بالٹی میں ایک ہی انڈیکس کے ساتھ ایک سے زیادہ کلیدی قیمت کے جوڑے کو ذخیرہ کرنے کے لئے ایک لنکڈ لسٹ یا دوسرا ڈیٹا ڈھانچہ ہوتا ہے۔اگلا دستیاب سلاٹ سرنی میں (لکیری تحقیقات ، چوکور تحقیقات ، یا ڈبل ہیشنگ جیسی تکنیکوں کا استعمال کرتے ہوئے) جب تک کہ اس کو کلیدی قدر کی جوڑی کو ذخیرہ کرنے کے لئے ایک خالی سلاٹ نہیں مل جاتا ہے۔اگر انڈیکس خالی ہے تو ، کلیدی قدر کی جوڑی براہ راست ذخیرہ ہوتی ہے۔تصادم کی صورت میں ، تصادم کی قرارداد کی حکمت عملی مناسب سلاٹ تلاش کرنے کے لئے استعمال کی جاتی ہے۔اگر انڈیکس میں مطلوبہ کلید موجود ہے تو ، اسی قدر واپس کردی جاتی ہے۔اگر تصادم ہیں تو ، سرچ الگورتھم صحیح سلاٹ تلاش کرنے کے لئے تصادم کی قرارداد کی حکمت عملی کی پیروی کرتا ہے۔ لیٹیشن: ہیش فنکشن کلید کے لئے انڈیکس کا حساب لگاتا ہے۔اگر انڈیکس میں کلید ہوتی ہے تو ، متعلقہ کلیدی قدر کی جوڑی کو ہٹا دیا جاتا ہے۔اگر تصادم ہیں تو ، سرچ الگورتھم کو کلید تلاش کرنے کے لئے استعمال کیا جاتا ہے ، اور پھر حذف کرنے کا کام انجام دیا جاتا ہے۔ ہیش ٹیبلز کے کلیدی فوائد ان کے داخلے ، بازیافت اور حذف کرنے کے کاموں کے لئے اوسطا وقت کی اوسط وقت کی پیچیدگی (O (1)) ہیں (O (1))جب ہیش فنکشن چابیاں یکساں طور پر تقسیم کرتا ہے۔تاہم ، بدترین صورت میں ، جب بہت سارے تصادم ہوتے ہیں تو ، وقت کی پیچیدگی O (n) کو کم کر سکتی ہے ، جہاں ہیش ٹیبل میں عناصر کی تعداد ہے۔پروگرامنگ زبانوں میں میزیں ، ڈیٹا بیس کی اشاریہ سازی ، اور ایسوسی ایٹو اریوں یا لغتوں کو نافذ کرنا۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "ایک درخت ایک نان لائنر ڈیٹا ڈھانچہ ہے جو منسلک ، ایسائکلک انداز میں درجہ بندی سے عناصر کو منظم کرتا ہے۔اس میں نوڈس اور کناروں پر مشتمل ہے ، جہاں نوڈس عناصر کی نمائندگی کرتے ہیں ، اور کنارے عناصر کے مابین تعلقات کی نمائندگی کرتے ہیں۔کسی درخت میں سب سے اوپر والے نوڈ کو روٹ نوڈ کہا جاتا ہے ، اور ہر نوڈ میں صفر یا اس سے زیادہ بچوں کے نوڈس ہوسکتے ہیں۔نوڈس جن میں ایک ہی والدین کے نوڈ ہوتے ہیں انہیں بہن بھائی کہتے ہیں ، اور بغیر کسی بچے کے نوڈس کے نوڈ کو پتی کا نوڈ کہا جاتا ہے۔ یہاں مختلف قسم کے درخت ہیں: بائنری ٹری: ایک بائنری ٹری ایک درخت ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچوں کے نوڈس ہوتے ہیں۔، بائیں بچے اور دائیں بچے کے طور پر جانا جاتا ہے۔جس ترتیب میں بچوں کے نوڈس کا اہتمام کیا جاتا ہے وہ بائنری درخت کی خصوصیات کو متاثر کرسکتا ہے ، جیسے بائنری سرچ ٹری ، اےول ٹری ، یا ڈھیر۔ بائنری سرچ ٹری (بی ایس ٹی): بائنری سرچ ٹری بائنری درخت کی ایک قسم ہے جس میںنوڈ کے بائیں بچے میں نوڈ سے کم اقدار ہوتی ہیں ، اور دائیں بچے میں نوڈ سے زیادہ اقدار ہوتی ہیں۔یہ موثر تلاشی ، اندراج اور حذف کرنے کے کاموں کو قابل بناتا ہے ، متوازن درختوں کے لئے O (لاگ این) کی اوسط وقت کی پیچیدگی کے ساتھ۔ اے وی ایل درخت: ایک AVL (ایڈیلسن-ویلسکی اور لینڈس) درخت ایک خود توازن بائنری تلاش کا درخت ہے۔یہ یقینی بناتا ہے کہ کسی بھی نوڈ کے بائیں اور دائیں ذیلی حصے کی اونچائی زیادہ سے زیادہ ایک سے مختلف ہوتی ہے۔یہ متوازن جائیداد موثر تلاش ، اندراج ، اور حذف کرنے کے کاموں کو برقرار رکھنے میں مدد کرتی ہے ، جس میں O (لاگ این) کی بدترین وقت کی پیچیدگی ہوتی ہے۔ ریڈ-بلیک ٹری: ایک سرخ سیاہ درخت ایک اور خود توازن بائنری تلاش کا درخت ہے۔یہ قواعد و ضوابط کے ایک سیٹ کا استعمال کرتے ہوئے توازن برقرار رکھتا ہے جو اس بات کی ضمانت دیتا ہے کہ درخت متوازن رہتا ہے۔یہ تلاش ، اندراج ، اور حذف کرنے کے ل O O (لاگ این) کی بدترین وقت کی پیچیدگی کے ساتھ موثر آپریشن فراہم کرتا ہے۔ بی ٹری: ایک بی ٹری ایک خود توازن درخت کا ڈھانچہ ہے جو عام طور پر فائل سسٹم اور ڈیٹا بیس میں استعمال ہوتا ہے۔یہ بڑی مقدار میں ڈیٹا کو سنبھالنے کے لئے ڈیزائن کیا گیا ہے اور تلاش ، اندراج اور حذف کرنے کے لئے موثر آپریشن فراہم کرتا ہے۔بی ٹریوں کے پاس ہر نوڈ میں متعدد چابیاں ہوتی ہیں اور بچوں کے نوڈس کی متغیر تعداد کی اجازت دیتے ہیں۔یہ ان کے مشترکہ سابقہ کے ذریعہ چابیاں کا اہتمام کرتا ہے ، جو اسے سابقہ پر مبنی سرچ آپریشنز کے ل efficient موثر بناتا ہے۔کوششیں عام طور پر خودکار اور لغت کے نفاذ جیسے ایپلی کیشنز میں استعمال ہوتی ہیں۔ ہیپ: ایک ہیپ ایک خاص درخت پر مبنی ڈیٹا ڈھانچہ ہے جو ڈھیر کی پراپرٹی کو پورا کرتا ہے۔بائنری کا ڈھیر ، خاص طور پر ، ایک مکمل بائنری درخت ہے جہاں ہر نوڈ کی قدر اس کے بچے کے نوڈس کی اقدار سے زیادہ یا اس کے برابر (یا اس سے کم یا اس کے برابر) ہوتی ہے۔ڈھیر عام طور پر ترجیحی قطاروں کے موثر نفاذ کے لئے استعمال ہوتے ہیں۔ یہ کچھ عام طور پر مشہور درخت ہیں ، جن میں سے ہر ایک اپنی مخصوص خصوصیات اور استعمال کے معاملات کے ساتھ ہے۔درخت مختلف ایپلی کیشنز میں استعمال ہونے والے ورسٹائل ڈیٹا ڈھانچے ہیں ، بشمول فائل سسٹم ، ڈیٹا بیس ، نیٹ ورک روٹنگ الگورتھم ، درجہ بندی کی نمائندگی اور بہت کچھ۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "ایک ترتیب شدہ صف پر بائنری سرچ الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: بالترتیب بائیں اور دائیں پوائنٹرز کو صف کے آغاز اور اختتام پر سیٹ کریں۔ جب بائیں پوائنٹر دائیں پوائنٹر سے کم یا اس کے برابر ہے ، دہرائیں۔مندرجہ ذیل اقدامات: a.درمیانی انڈیکس کا حساب بائیں اور دائیں پوائنٹرز کی اوسط کے طور پر کریں: وسط = (بائیں + دائیں) / 2.b.مڈل انڈیکس کی قیمت کو ہدف کی قیمت کے ساتھ موازنہ کریں: اگر درمیانی قیمت ہدف کے برابر ہے تو ، مڈل انڈیکس کو نتیجہ کے طور پر واپس کریں۔ اگر درمیانی قیمت ہدف سے زیادہ ہے تو ، دائیں پوائنٹر کو وسط میں اپ ڈیٹ کریں - 1.ifدرمیانی قیمت ہدف سے کم ہے ، بائیں پوائنٹر کو مڈ + پر اپ ڈیٹ کریں۔ایک \"نہیں ملا\" اشارے واپس کریں۔ ازگر میں نمونہ عمل درآمد ہے: پائیتھون کوپی کوڈ ڈیف بائنری_سارچ (اے آر آر ، ہدف): بائیں = 0 دائیں = لین (اے آر آر) - 1 جبکہ بائیں <= دائیں: درمیانی = (بائیں + دائیں) //2 اگر آر آر [وسط] == ہدف: مڈ ایلف آر آر [وسط] <ہدف: بائیں = وسط + 1 اور: دائیں = وسط - 1 ریٹرن -1 # ہدف نہیں ملا # مثال کے استعمال: ترتیب_ر = [1 ، 3 ،5 ، 7 ، 9 ، 11 ، 13] ہدف = 9 ریزولٹ = بائنری_سرچ (چھانٹیا_آر ، ہدف) اگر نتیجہ!{ہدف} نہیں ملا \") اس نفاذ میں ، بائنری سرچ الگورتھم سرنی کے درمیانی عنصر کے ساتھ ہدف کی قیمت کا موازنہ کرتا ہے اور اس کے مطابق بائیں یا دائیں پوائنٹر کو اپ ڈیٹ کرکے تلاش کی حد کو نیچے کرتا ہے۔یہ عمل اس وقت تک جاری رہتا ہے جب تک کہ ہدف کی قیمت نہ مل جائے یا تلاش کی حد ختم ہوجائے۔بائنری سرچ الگورتھم کی وقت کی پیچیدگی O (لاگ این) ہے ، جہاں N ترتیب شدہ صف میں عناصر کی تعداد ہے ، کیونکہ یہ بار بار تلاش کی حد کو آدھے حصے میں تقسیم کرتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک ٹرائی ، جسے ایک سابقہ درخت بھی کہا جاتا ہے ، درختوں کی طرح کا ڈیٹا ڈھانچہ ہے جو تار کے طور پر ذخیرہ شدہ چابیاں کی موثر بازیافت کے لئے استعمال ہوتا ہے۔یہ خاص طور پر سٹرنگ مماثل اور پریفکس پر مبنی تلاشی سے متعلق مسائل کو حل کرنے کے لئے مفید ہے۔\"ٹری\" کی اصطلاح \"بازیافت\" کے لفظ سے آتی ہے۔ ایک ٹری میں ، ہر نوڈ ایک ہی کردار کی نمائندگی کرتا ہے۔نوڈس کو ایک دوسرے کے ساتھ درخت کی ساخت بنانے کے لئے منسلک کیا جاتا ہے ، جہاں ہر کنارے کلید میں ایک کردار کی نمائندگی کرتا ہے۔جڑ سے کسی خاص نوڈ تک کا راستہ کسی سابقہ یا ایک مکمل کلید کی نمائندگی کرتا ہے۔ یہاں ٹری ڈیٹا ڈھانچے کی کچھ کلیدی خصوصیات اور فوائد ہیں: موثر سٹرنگ بازیافت: سٹرنگ بازیافت کے کاموں میں ایکسل کی کوشش کرتا ہے۔ایک تار کو دیکھتے ہوئے ، آپ جلدی سے یہ طے کرسکتے ہیں کہ آیا یہ ٹری میں موجود ہے یا نہیں۔اس سے یہ ہجے کی جانچ پڑتال ، خود کار طریقے سے ، اور کسی لغت میں الفاظ کی تلاش جیسے کاموں کے ل useful مفید ہے۔آپ کو ٹری میں وہ تمام چابیاں مل سکتی ہیں جو دیئے گئے تار کے ساتھ مشترکہ سابقہ کا اشتراک کرتی ہیں۔یہ خاص طور پر خود کار طریقے سے فعالیت یا کسی مخصوص سابقہ کے ساتھ الفاظ کی تلاش کے ل useful مفید ہے۔ اسپیس کی کارکردگی: مختلف چابیاں میں مشترکہ سابقہ بانٹ کر جگہ کو بہتر بنانے کی کوشش کرتا ہے۔اس سے وہ ایسے منظرناموں میں موثر ہوجاتے ہیں جہاں اسی طرح کے سابقہ کے ساتھ بہت سی چابیاں موجود ہیں۔ٹری کی خلائی پیچیدگی کا انحصار چابیاں کی کل تعداد کے بجائے چابیاں میں منفرد کرداروں کی تعداد پر ہے۔ آرڈرڈ کلیدی بازیافت: کوشش کرتا ہے کہ چابیاں کی ترتیب کو محفوظ رکھیں۔یہ پراپرٹی لغت کے لحاظ سے سب سے چھوٹی یا سب سے بڑی کلید کو تلاش کرنے ، ترتیب شدہ ترتیب میں چابیاں گنتی ، یا کسی خاص حد کے اندر چابیاں تلاش کرنے جیسے کاموں کی اجازت دیتی ہے۔ فاسٹ اندراج اور حذف کرنے کی کوششیں: کوششیں کیز کے لئے موثر اندراج اور حذف کرنے کے کام فراہم کرتی ہیں۔ان کارروائیوں کے لئے وقت کی پیچیدگی عام طور پر کلید کی لمبائی کے متناسب ہوتی ہے۔ ٹری تغیرات: مخصوص ضروریات کی تائید کے ل additional کوششوں کو اضافی خصوصیات کے ساتھ بڑھایا جاسکتا ہے۔مثالوں میں کمپریسڈ کوششیں (جیسے پیٹریسیا کی کوششیں یا ریڈکس کے درخت) شامل ہیں جو جگہ کو مزید بہتر بناتے ہیں ، ترنری تلاش کرنے کی کوشش کرتی ہے جو زیادہ عام حرفوں کو سنبھالتی ہے ، یا ہر کلید سے وابستہ اضافی اعداد و شمار کے ساتھ کوشش کرتی ہے۔ ٹرائی کی اہم تجارت اس کی جگہ کی پیچیدگی ہے ، جیسا کہ ہوسکتا ہے۔دوسرے ڈیٹا ڈھانچے کے مقابلے میں زیادہ میموری کی ضرورت ہوتی ہے۔تاہم ، ایسے منظرناموں کے لئے جہاں موثر سٹرنگ کی بازیافت ، سابقہ تلاش ، یا آرڈر شدہ کلیدی کاروائیاں انتہائی اہم ہیں ، ٹرائی اہم فوائد فراہم کرتی ہے۔کوششوں میں سرچ انجن ، مرتب کرنے والے ، ہجے چیکرس ، آئی پی روٹنگ ٹیبلز ، اور کسی بھی منظر نامے جیسے ایپلی کیشنز میں وسیع پیمانے پر استعمال کیا جاتا ہے جس میں تیز سٹرنگ مماثل یا سابقہ پر مبنی آپریشن شامل ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "ایک ہیپ ڈیٹا ڈھانچہ عام طور پر ایسے منظرناموں میں استعمال ہوتا ہے جس میں ترجیحی قطاروں کے موثر انتظام کی ضرورت ہوتی ہے یا زیادہ سے زیادہ یا کم سے کم عنصر جلد تلاش کرنا ہوتا ہے۔یہاں کچھ ایسے حالات ہیں جہاں ہیپ ڈیٹا کا ڈھانچہ خاص طور پر مفید ہے: ترجیحی قطار: ترجیحی قطار کو موثر انداز میں نافذ کرنے کے لئے ڈھیر کا استعمال کیا جاسکتا ہے۔ترجیحی قطار میں ، عناصر کی ترجیحات سے وابستہ ہیں ، اور سب سے زیادہ (یا سب سے کم) ترجیحی عنصر ہمیشہ قطار کے سامنے رہتا ہے۔ڈھیر پر مبنی ترجیحی قطار موثر وقت (O (1)) یا لوگرتھمک وقت (O (لاگ (لاگ (لاگ (لاگ (O (لاگ (O (1)) میں موجودہ اعلی (یا سب سے کم) ترجیحی عنصر کی موثر اضافے ، سب سے زیادہ (یا سب سے کم) ترجیحی عنصر کو ختم کرنے ، اور موجودہ اعلی (یا سب سے کم) ترجیحی عنصر کی بازیافت کی اجازت دیتی ہے۔n)). چھانٹ رہا ہے: ہیپسورٹ ایک جگہ میں ایک موثر جگہ چھنٹائی کرنے والا الگورتھم ہے جو ڈھیر کا استعمال کرتا ہے۔یہ ان پٹ سرنی سے زیادہ سے زیادہ ہیپ (چڑھائی کے آرڈر کے لئے) یا ایک کم ہیپ (نزول آرڈر کے لئے) بنا کر اور ڈھیر سے زیادہ سے زیادہ (یا کم سے کم) عنصر کو بار بار نکال کر کام کرتا ہے۔ہیپسورٹ میں O (n لاگ این) کی وقت کی پیچیدگی ہوتی ہے اور خاص طور پر مفید ہوتا ہے جب میموری کی جگہ محدود ہوتی ہے یا جب سرنی کا سائز بہت بڑا ہوتا ہے۔ شیڈولنگ: ایونٹ سے چلنے والی نقالی یا شیڈولنگ سسٹم میں ، ایک ڈھیر کو برقرار رکھنے کے لئے استعمال کیا جاسکتا ہےان کے مقررہ وقت سے ترتیب دیئے گئے واقعات کا مجموعہ۔اگلے واقعے پر کارروائی کی جائے گی جس کو ڈھیر سے کم سے کم (یا زیادہ سے زیادہ) عنصر نکال کر موثر انداز میں بازیافت کیا جاسکتا ہے۔یہ نقطہ نظر اس بات کو یقینی بناتا ہے کہ واقعات پر ان کے طے شدہ اوقات کی ترتیب میں کارروائی کی جاتی ہے۔ گراف الگورتھم: مختلف گراف الگورتھم میں ڈھیر استعمال کیے جاتے ہیں جن میں کچھ معیارات کی بنیاد پر اگلے عمودی یا ایج کے موثر انتخاب کی ضرورت ہوتی ہے۔مثال کے طور پر ، گراف میں مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کا الگورتھم کم سے کم فاصلے کے ساتھ ورٹیکس کو منتخب کرنے کے لئے ایک کم سے کم استعمال کرتا ہے۔کم سے کم پھیلے ہوئے درخت کی تعمیر کے لئے پرائم کا الگورتھم بھی کم سے کم وزن والے کنارے کو منتخب کرنے کے لئے ڈھیر کا استعمال کرتا ہے۔ میموری مینجمنٹ: متحرک طور پر مختص میموری کو موثر انداز میں منظم کرنے کے لئے میموری مختص نظام میں ڈھیر استعمال کیے جاتے ہیں۔اس تناظر میں ، ڈھیر سے مراد یادداشت کے خطے ہیں جہاں سے میموری کے بلاکس کو مختص کیا جاتا ہے اور ضرورت کے مطابق ان کو ضائع کیا جاتا ہے۔ہیپ ڈیٹا ڈھانچہ مختص اور مفت بلاکس کے بارے میں معلومات کو برقرار رکھتا ہے ، جس سے موثر مختص اور ڈیل لوکیشن کے کاموں کی اجازت ملتی ہے۔ یہ ان حالات کی صرف چند مثالیں ہیں جہاں ہیپ ڈیٹا کا ڈھانچہ فائدہ مند ہے۔جب بھی آپ کو ترجیحات کا موثر انداز میں انتظام کرنے کی ضرورت ہو ، زیادہ سے زیادہ یا کم سے کم عنصر منتخب کریں ، یا ایونٹ کے شیڈولنگ ، چھانٹنے ، یا گراف الگورتھم سے متعلق مسائل کو حل کریں ، تو ایک ڈھیر پر غور کرنے کا ایک طاقتور ذریعہ ہوسکتا ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "متحرک پروگرامنگ ایک مسئلے کو حل کرنے کی ایک تکنیک ہے جو پیچیدہ مسائل کو حل کرنے کے لئے استعمال کی جاتی ہے تاکہ ان کو توڑ ڈالیں اور صرف ایک بار ہر ذیلی مسئلے کو حل کیا جاسکے۔یہ اوورلیپنگ اسٹرکچرز کے ساتھ مسائل کو موثر حل کرنے ، بے کار کمپیوٹوں کو ختم کرنے اور کارکردگی کو بہتر بنانے کی اجازت دیتا ہے۔ متحرک پروگرامنگ کے پیچھے کلیدی خیال یہ ہے کہ چھوٹے چھوٹے پروبلوں کو حل کرکے اور بڑے مسئلے کے حل کے ل these ان ذیلی پروبلوں کے حل کا استعمال کریں۔ذیلی مسائل کے حل عام طور پر کسی ٹیبل یا میموئزیشن سرنی میں محفوظ کیے جاتے ہیں ، جس سے آسانی سے تلاش اور دوبارہ استعمال کی جاسکتی ہے۔ ڈائنیمک پروگرامنگ میں درج ذیل اقدامات شامل ہیں: مسئلہ کی نشاندہی کریں: مسئلے کو سمجھیں اور اس بات کا تعین کریں کہ آیا یہ متحرک پروگرامنگ کے لئے موزوں خصوصیات کی نمائش کرتا ہے۔ان مسائل جن میں زیادہ سے زیادہ ساخت اور اوورلیپنگ سب پروبلوبل شامل ہیں وہ متحرک پروگرامنگ کے لئے اچھے امیدوار ہیں۔ تکرار کے رشتے کو تشکیل دیں: مسئلے کو چھوٹے چھوٹے مضامین میں توڑ دیں اور سب پروبلوبلز کے حل کے لحاظ سے بڑے مسئلے کے حل کا اظہار کریں۔اس تکرار کا رشتہ بڑے مسئلے اور اس کے ذیلی پروبلوبلز کے مابین تعلقات کی وضاحت کرتا ہے۔ بنیادی معاملات کی وضاحت کریں: آسان ترین ذیلی مشکلات کی نشاندہی کریں جو بغیر کسی خرابی کے براہ راست حل ہوسکتے ہیں۔یہ بنیادی معاملات حل کو بڑھانے کے لئے تکرار یا نقطہ اغاز کے لئے ختم ہونے کی حالت فراہم کرتے ہیں۔ حل نیچے یا اوپر سے نیچے کی تعمیر: متحرک پروگرامنگ کو نیچے یا ٹاپ ڈاون نقطہ نظر کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ بوٹوماپ اپروچ (تکراری): بیس معاملات سے ذیلی مسائل کو حل کرنا شروع کریں اور مطلوبہ حل تک پہنچنے تک بڑے ذیلی مسائل کو حل کرکے حل کو بڑھاؤ۔ذیلی خطوط۔بے کار کمپیوٹیشن سے بچنے کے لئے میموئزیشن سرنی یا ٹیبل میں ذیلی خطوں کے حل ذخیرہ کریں۔کسی ذیلی پروبل کو حل کرنے سے پہلے ، چیک کریں کہ آیا اس کا حل پہلے ہی ٹیبل میں دستیاب ہے یا نہیں۔اگر ایسا ہے تو ، ذخیرہ شدہ حل کو دوبارہ تشکیل دینے کے بجائے استعمال کریں۔ حل کو حل کریں: ایک بار جب تمام متعلقہ ذیلی خطوں کے حل کی گنتی کی جائے تو ، اصل مسئلے کا حتمی حل میموزائزیشن ٹیبل یا نیچے کی گنتی کے نتیجے میں نکالا جاسکتا ہے۔متحرک پروگرامنگ ان مسائل کو حل کرنے میں کارآمد ہے جو اوورلیپنگ سب پروبلوبلز کی نمائش کرتے ہیں ، جس سے بولی تکرار کرنے والے نقطہ نظر کے مقابلے میں کارکردگی میں نمایاں بہتری کی اجازت ملتی ہے۔یہ عام طور پر مختلف شعبوں میں استعمال ہوتا ہے جیسے الگورتھم ڈیزائن ، اصلاح ، امتزاج ، نظام الاوقات ، وسائل کی مختص ، اور بہت سے دوسرے مسئلے والے ڈومینز۔متحرک پروگرامنگ الگورتھم کی مثالوں میں فبونیکی تسلسل کی گنتی ، مختصر ترین راستہ الگورتھم ، نیپسیک مسئلہ ، اور بہت کچھ شامل ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "چوڑائی کی پہلی تلاش (بی ایف ایس) اور گہرائی سے پہلے تلاش (ڈی ایف ایس) گراف میں نوڈس کی کھوج یا تلاش کے لئے استعمال ہونے والے دو مشہور گراف ٹراورسل الگورتھم ہیں۔بی ایف ایس اور ڈی ایف ایس کے مابین اہم اختلافات ان کی حکمت عملیوں میں نوڈس اور اس ترتیب میں ہیں جس میں وہ گراف کی کھوج کرتے ہیں۔ بریڈری فرسٹ فرسٹ سرچ (بی ایف ایس): بی ایف ایس کسی دیئے گئے ماخذ سے شروع ہونے والے گراف کو سطح کے لحاظ سے تلاش کرتا ہے۔گہری سطحوں کا دورہ کرنے سے پہلے نوڈ اور باہر کی طرف اپنے پڑوسی نوڈس کی طرف جانا۔ یہ نوڈ ایکسپلوریشن کی ترتیب کو برقرار رکھنے کے لئے ایک قطار کے ڈیٹا ڈھانچے کا استعمال کرتا ہے۔ بی ایف ایس اگلی سطح پر جانے سے پہلے موجودہ سطح پر تمام نوڈس کا دورہ کرتا ہے۔گہری سطح پر نوڈس سے پہلے ملاحظہ کیا جاتا ہے ، جس کے نتیجے میں چوڑائی کی پہلی ریسرچ پیٹرن ہوتا ہے۔ بی ایف ایس بغیر وزن والے گراف میں مختصر ترین راستہ تلاش کرنے کے لئے موزوں ہے کیونکہ یہ ماخذ سے فاصلے کے بڑھتے ہوئے ترتیب میں نوڈس کی کھوج کرتا ہے۔ بی ایف ایس کا پتہ لگانے کے لئے بھی استعمال کیا جاسکتا ہے۔کسی گراف میں یا کسی غیر ہدایت شدہ گراف کے منسلک اجزاء کو تلاش کرنے کے لئے۔ بی ایف ایس کی وقت کی پیچیدگی O (v + e) ہے ، جہاں v عمودی کی تعداد ہے اور E گراف میں کناروں کی تعداد ہے۔ڈی ایف ایس): ڈی ایف ایس نے بیک ٹریکنگ سے پہلے ہر شاخ کے ساتھ جہاں تک ممکن ہو ٹریورنگ کرکے گراف کی کھوج کی۔ اس میں نوڈس کو تلاش کرنے کے لئے ٹریک (یا تکرار) کا استعمال کیا جاتا ہے۔گراف کی ایک شاخ جب تک قریب ترین غیر تلاش شدہ نوڈ پر بیک ٹریک کرنے سے پہلے کسی پتے کے نوڈ تک نہیں پہنچتی۔ ڈی ایف ایس راستوں کی تلاش اور ایسے حل تلاش کرنے کے لئے مفید ہے جس میں گراف کے ڈھانچے میں گہری تلاش کرنا شامل ہوتا ہے۔ یہ سب سے کم راہ کی ضمانت نہیں دے سکتا ہے کیونکہ یہ پہلے گہری سطح کی کھوج کرتا ہے۔ڈی ایف ایس کا استعمال اس بات کا تعین کرنے کے لئے کیا جاسکتا ہے کہ آیا دو نوڈس کے مابین کوئی راستہ موجود ہے ، کسی چکر کے وجود کی جانچ پڑتال کے لئے ، یا کسی درخت یا گراف کو عبور کرنے کے لئے۔ ڈی ایف ایس کی وقت کی پیچیدگی بھی O (V + E) ہے ، جہاں V ہےعمودی اور ای کی تعداد گراف میں کناروں کی تعداد ہے۔ خلاصہ۔ بی ایف ایس گراف کی سطح کو سطح کے لحاظ سے تلاش کرتا ہے ، جبکہ ڈی ایف ایس ہر شاخ کے ساتھ گہری گراف کی کھوج کرتا ہے۔بی ایف ایس غیر وزن والے گراف میں مختصر ترین راستے کی ضمانت دیتا ہے اور منسلک اجزاء کی تلاش جیسے ایپلی کیشنز کے لئے مفید ہے ، جبکہ ڈی ایف ایس راستوں کی تلاش اور سائیکلوں کے وجود کو جانچنے کے لئے موزوں ہے۔بی ایف ایس اور ڈی ایف ایس کے درمیان انتخاب مخصوص مسئلے اور درخواست کی ضروریات پر منحصر ہے۔"
    },
    {
        "Question": "",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ مہنگے فنکشن کالوں کی گنتی کو بہتر بنانے کے لئے ان کے نتائج کو بہتر بنایا جاسکے اور جب وہی ان پٹ دوبارہ ہوتا ہے تو ان کو دوبارہ استعمال کرتے ہوئے ان کا دوبارہ استعمال کرتے ہیں۔اس میں اعداد و شمار کے ڈھانچے میں فنکشن کالز کے نتائج کو ذخیرہ کرنا شامل ہے ، عام طور پر کسی سرنی یا ہیش ٹیبل میں ، تاکہ اسی آدانوں کے ساتھ بعد میں آنے والی کالیں اس کو دوبارہ تشکیل دینے کے بجائے براہ راست پیشگی نتیجہ بازیافت کرسکیں۔ متحرک پروگرامنگ کے تناظر میں ، میمورائزیشن عام طور پر ہوتی ہے۔recursive الگورتھم کے ساتھ استعمال کیا جاتا ہے جو اوورلیپنگ سب پروبلوبلز کی نمائش کرتے ہیں۔اس سے حل شدہ ذیلی مسائل کے نتائج کو ذخیرہ کرکے اور ہر بار جب ان کا سامنا کرنا پڑتا ہے اس کی دوبارہ گنتی کرنے کی بجائے ان کو تلاش کرنے میں بے کار کمپیوٹوں کو ختم کرنے میں مدد ملتی ہے۔ یہاں کہ میموری کو عام طور پر متحرک پروگرامنگ میں کس طرح استعمال کیا جاتا ہے: ذیلی پروبلوں کی شناخت کریں: اس مسئلے کو چھوٹے چھوٹے ذیلی خطوں میں توڑ دیں جو اوورلیپنگ کی نمائش کرتے ہیں۔خصوصیاتیہ ذیلی خطوط اسی مسئلے کی چھوٹی چھوٹی مثالوں میں ہونے چاہئیں۔ میموائزیشن کے اعداد و شمار کے ڈھانچے کی وضاحت کریں: حل شدہ ذیلی پروبلز کے نتائج کو ذخیرہ کرنے کے لئے ڈیٹا ڈھانچہ ، جیسے سرنی یا ہیش ٹیبل کو ترتیب دیں۔فنکشن یا سب پروبلوبل کے آدانوں کے ذریعہ اس ڈھانچے کو ترتیب دیا جانا چاہئے یا اس کی کلید کی جانی چاہئے۔ تکرار کرنے والی تقریب: ایک بار بار چلنے والا فنکشن لکھیں جو ہر ذیلی پروبل کو حل کرتا ہے اور نتائج کو ذخیرہ کرنے اور بازیافت کرنے کے لئے میموائزیشن کا استعمال کرتا ہے۔کسی ذیلی پروبل کی گنتی سے پہلے ، چیک کریں کہ آیا اس کا نتیجہ پہلے سے ہی میمورائزیشن کے ڈھانچے میں موجود ہے یا نہیں۔اگر ایسا ہے تو ، ذخیرہ شدہ نتیجہ کو دوبارہ تشکیل دینے کے بجائے واپس کریں۔ بیس کیسز کو روکنے کے بجائے: بیس مقدمات کی وضاحت کریں یا تکرار کے لئے شرائط ختم کریں۔یہ عام طور پر سب سے چھوٹی ذیلی مسائل ہیں جو مزید خرابی کے بغیر براہ راست حل کی جاسکتی ہیں۔ان کے نتائج کو میمورائزیشن کے ڈھانچے میں بھی اسٹور کریں۔ تکرار کرنے والی تقریب کو شامل کریں: اصل مسئلے کے آدانوں کے ساتھ تکرار کرنے والے فنکشن کا مطالبہ کریں ، جس سے اس سے چھوٹے چھوٹے مضامین کو بار بار حل کرکے مسئلے کو حل کیا جاسکے۔جب دستیاب ہو تو فنکشن بے کار کمپیوٹوں سے بچنے اور پہلے سے موجود نتائج کو بازیافت کرنے کے لئے میموائزیشن کا استعمال کرے گا۔ میموئزیشن بے کار کمپیوٹیشن کو ختم کرکے متحرک پروگرامنگ الگورتھم کی وقت کی پیچیدگی کو کم کرنے میں مدد کرتا ہے۔نتائج کیچنگ اور دوبارہ استعمال کرنے سے ، یہ مجموعی کارکردگی کو نمایاں طور پر بہتر بنا سکتا ہے ، خاص طور پر جب مسئلہ اوورلیپنگ اسٹرکچرز کی نمائش کرتا ہے۔ یہ بات اہم ہے کہ یادداشت متحرک پروگرامنگ کے لئے مخصوص نہیں ہے اور دوسرے سیاق و سباق میں بھی اس کا اطلاق ہوسکتا ہے۔یہ ایک عام تکنیک ہے جو کسی بھی مہنگے یا بار بار فنکشن کالوں کی گنتی کو بہتر بنانے کے لئے استعمال ہوتی ہے جو ان کے نتائج کو اسٹور کرکے اور دوبارہ استعمال کرکے استعمال کرتی ہے۔تاہم ، یہ خاص طور پر متحرک پروگرامنگ میں فائدہ مند ہے کیونکہ اس کی وجہ سے اوورلیپنگ سب پروبلوبلز کو مؤثر طریقے سے سنبھالنے کی صلاحیت ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "یقینا!ایک سرخ رنگ کا درخت ایک خود متوازن بائنری سرچ درخت ہے جو خصوصیات کے ایک سیٹ کو نافذ کرکے توازن کو برقرار رکھتا ہے۔اس کا نام درخت میں ہر نوڈ کو تفویض کردہ رنگ کے نام پر رکھا گیا ہے: سرخ یا سیاہ۔سرخ رنگ کے درخت کی خصوصیات مندرجہ ذیل ہیں: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ کا نوڈ ہمیشہ سیاہ ہوتا ہے۔ ہر پتی (کال) نوڈ سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔ ہر راستہ۔نوڈ سے اس کی اولاد پتی نوڈس میں سیاہ نوڈس کی مساوی تعداد ہوتی ہے۔اس پراپرٹی کو بلیک اونچائی پراپرٹی یا بلیک بیلنس کہا جاتا ہے۔ ان خصوصیات پر عمل پیرا ہونے کے بعد ، ایک سرخ رنگ کا درخت اس بات کو یقینی بناتا ہے کہ جڑ سے کسی بھی پتے تک کا لمبا ترین راستہ مختصر ترین راستے کی لمبائی سے دوگنا نہیں ہوتا ہے ، جس کے نتیجے میں متوازن ہوتا ہے۔درخت۔ سرخ رنگ کے درخت پر انجام دیئے گئے آپریشن ، جیسے اندراج اور حذف کرنا ، درخت کی خصوصیات کو برقرار رکھنا شامل ہے۔یہاں یہ ایک مختصر جائزہ ہے کہ یہ آپریشن کس طرح کام کرتے ہیں: اندراج: نئے نوڈس کو ابتدائی طور پر ریڈ نوڈس کے طور پر داخل کیا جاتا ہے۔ اس کے بعد ، اگر کسی جائیداد کی خلاف ورزی ہوتی ہے تو ، توازن کو بحال کرنے اور تعلقات کو برقرار رکھنے کے لئے درختوں کی گردش اور رنگ کی تبدیلیاں لاگو ہوتی ہیں۔نوڈس کے درمیان ، مختلف معاملات پیدا ہوسکتے ہیں جس میں توازن برقرار رکھنے کے لئے مخصوص گردش اور رنگ کی تبدیلیوں کی ضرورت ہوتی ہے۔ ذخیرہ: جب نوڈ کو حذف کیا جاتا ہے تو ، اسے یا تو اپنے پیش رو یا جانشین نوڈ کے ساتھ تبدیل کیا جاتا ہے۔ اندراج کے عمل کی وجہ سے ، اگر کسی بھی خصوصیات کی خلاف ورزی کی جاتی ہے تو ، گردشوں کی خلاف ورزی ہوتی ہے۔توازن کو بحال کرنے کے لئے رنگین تبدیلیاں کی جاتی ہیں۔ حذف کے دوران مختلف معاملات پیدا ہوسکتے ہیں ، جیسے کسی سیاہ نوڈ کو حذف کرنا ، جس میں پراپرٹیز کو برقرار رکھنے کے لئے اضافی ایڈجسٹمنٹ کی ضرورت پڑسکتی ہے۔ سرخ رنگ کے درخت میں گردش کی کارروائیوں میں ایڈجسٹ کرکے توازن برقرار رکھنے میں مدد ملتی ہے۔نوڈس کی پوزیشنیں۔گردش کی دو اقسام ہیں: بائیں گردش: اس میں اس کی اصل پوزیشن کا بائیں بچہ بننے کے لئے اپنے دائیں بچے کی پوزیشن سے نوڈ منتقل کرنا شامل ہے۔اس سے درخت کو متوازن کرنے میں مدد ملتی ہے جب دائیں سب ٹری بائیں سب ٹری سے لمبا ہوجاتی ہے۔ رائٹ گردش: اس میں اس کی اصل پوزیشن کا دائیں بچہ بننے کے لئے اپنے بائیں بچے کی پوزیشن سے نوڈ منتقل کرنا شامل ہے۔اس سے درخت کو متوازن کرنے میں مدد ملتی ہے جب بائیں سب ٹری دائیں سب ٹری سے لمبا ہوجاتی ہے۔ گردشوں اور رنگ کی تبدیلیاں انجام دینے کے ساتھ ساتھ ، اندراج اور حذف کرنے کے دوران ، ایک سرخ رنگ کا درخت توازن برقرار رکھتا ہے اور موثر تلاش ، اندراج اور حذف کرنے کی کارروائیوں کو یقینی بناتا ہے۔سرخ رنگ کے درخت میں ان کارروائیوں کے لئے بدترین وقت کی پیچیدگی O (لاگ این) ہے ، جہاں درخت میں نوڈس کی تعداد ہے۔ نیچے سیاہ درخت عام طور پر مختلف ایپلی کیشنز میں استعمال ہوتے ہیں جن میں موثر اور متوازن تلاش کے درختوں کی ضرورت ہوتی ہے۔، جیسے ان میموری ڈیٹا بیس ، زبان کے مرتب کرنے والے ، اور ڈیٹا ڈھانچے جیسے سیٹ ، نقشے ، اور وقفہ کے درخت۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "ترجیحی قطار ایک تجریدی ڈیٹا کی قسم ہے جو عناصر کا مجموعہ محفوظ کرتی ہے ، ہر ایک ترجیح سے وابستہ ہے۔ترجیح مجموعہ کے اندر کسی عنصر کی نسبت کی اہمیت یا عجلت کی نشاندہی کرتی ہے۔اعلی ترجیح کے حامل عناصر کو زیادہ اہم سمجھا جاتا ہے اور کم ترجیح والے عناصر سے پہلے بازیافت یا اس پر کارروائی کی جاتی ہے۔ ترجیحی قطار کے ذریعہ تعاون یافتہ اہم کاروائیاں یہ ہیں: اندراج: عنصر کی ترجیح کی بنیاد پر آرڈر کو برقرار رکھتے ہوئے ترجیحی قطار میں عنصر شامل کرتا ہے۔نیا عنصر مناسب پوزیشن میں رکھا گیا ہے تاکہ یہ یقینی بنایا جاسکے کہ اعلی ترجیح کے حامل عناصر قطار کے سامنے کے قریب ہیں۔ لالچ: یہ عنصر کو ترجیحی قطار سے اعلی ترجیح کے ساتھ ہٹاتا ہے اور واپس کرتا ہے۔اعلی ترجیح والا عنصر عام طور پر قطار کے سامنے واقع ہوتا ہے۔ مختلف اعداد و شمار کے ڈھانچے کا استعمال کرتے ہوئے ترجیحی قطار نافذ کی جاسکتی ہے ، لیکن دو عام طور پر استعمال ہونے والے نفاذ یہ ہیں: بائنری ہیپ: ایک بائنری ہیپ ایک مکمل بائنری درخت ہے جو ہیپ پراپرٹی کو پورا کرتا ہے۔بائنری ڈھیر میں ، والدین نوڈ کی ترجیح ہمیشہ اپنے بچوں کی ترجیحات سے زیادہ یا اس کے برابر ہوتی ہے۔یہ پراپرٹی اس بات کو یقینی بناتی ہے کہ اعلی ترجیحی عنصر ڈھیر کی جڑ میں واقع ہے۔بائنری ڈھیروں کو مؤثر طریقے سے اریوں کے طور پر نافذ کیا جاسکتا ہے۔ متوازن سرچ درخت: متوازن سرچ درخت ، جیسے سرخ رنگ کا درخت یا اے وی ایل درخت ، ترجیحی قطار کو نافذ کرنے کے لئے بھی استعمال کیا جاسکتا ہے۔عناصر درخت میں درخت کے متوازن ڈھانچے کو برقرار رکھتے ہوئے موثر داخل کرنے اور حذف کرنے کی کارروائیوں کی اجازت دیتے ہیں۔ عمل درآمد کا انتخاب درخواست کی مخصوص ضروریات پر منحصر ہے۔بائنری ہیپس عام طور پر بنیادی کارروائیوں جیسے اندراج اور حذف (O (لاگ این)) کے لئے بہتر وقت کی پیچیدگی فراہم کرتے ہیں ، جبکہ متوازن تلاش کے درخت O (لاگ این) وقت میں عنصر کی تلاش جیسے زیادہ لچک اور اضافی آپریشن فراہم کرتے ہیں۔مختلف ایپلی کیشنز جہاں عناصر کو اپنی ترجیحات کی بنیاد پر کارروائی کرنے کی ضرورت ہے۔کچھ مثالوں میں ٹاسک شیڈولنگ ، ایونٹ سے چلنے والی نقالی ، گراف الگورتھم (جیسے ، ڈجکسٹرا کا الگورتھم) ، ڈیٹا کمپریشن الگورتھم (جیسے ، ہف مین کوڈنگ) ، اور وسائل مختص الگورتھم شامل ہیں۔ترجیحی قطاریں ترجیحات کے موثر انتظام کی اجازت دیتی ہیں اور اس بات کو یقینی بناتی ہیں کہ پہلے اعلی ترجیحی عناصر پر عملدرآمد کیا جائے ، جس سے موثر اور بہتر مسئلے کو حل کرنے میں مدد ملے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "بلبلا ترتیب والا الگورتھم ایک سادہ چھانٹنے والا الگورتھم ہے جو بار بار فہرست میں قدم رکھتا ہے ، ملحقہ عناصر کا موازنہ کرتا ہے ، اور اگر وہ غلط ترتیب میں ہیں تو ان کو تبدیل کرتا ہے۔اس عمل کو اس وقت تک دہرایا جاتا ہے جب تک کہ فہرست ترتیب نہ دی جائے۔یہاں آپ سیوڈوکوڈ میں بلبلا ترتیب والے الگورتھم کو کس طرح نافذ کرسکتے ہیں: vbnetcopy کوڈ پروسیڈور بلبلسورٹ (فہرست) n: = لمبائی (فہرست) 0 سے N-1 سے J کے لئے 0 سے N-1-I تک اگر فہرست [j]> فہرست [J+1] پھر تبادلہ (فہرست [j] ، فہرست [j+1]) اختتام کے اختتام پر اختتام پر عمل کے اختتام پر الگورتھم کا ایک مرحلہ بہ قدم خرابی: عناصر کی غیر ترتیب شدہ فہرست کے ساتھ شروع کریں۔فہرست N-1 بار ، جہاں N فہرست کی لمبائی ہے۔اس بات کو یقینی بناتا ہے کہ ہر ایک تکرار میں فہرست کے آخر تک سب سے بڑا عنصر \"بلبل\" بناتا ہے۔ ہر تکرار میں ، فہرست کے آغاز سے شروع ہونے والے ملحقہ عناصر کا موازنہ کریں۔اگر موجودہ عنصر اگلے عنصر سے زیادہ ہے تو ، ان کو تبدیل کریں۔ ملحقہ عناصر کے ہر جوڑے کے لئے فہرست کے اختتام تک اس عمل کو تبدیل کریں۔ ہر تکرار کے بعد ، سب سے بڑے عنصر کو فہرست کے آخر میں ہونے کی ضمانت دی جاتی ہے۔ ان پر عمل کریں۔تکرارات جب تک پوری فہرست کو ترتیب نہیں دیا جاتا ہے۔ بلبلا ترتیب والے الگورتھم کی وقت کی پیچیدگی O (n^2) ہے ، جہاں فہرست میں عناصر کی تعداد ہے۔یہ بڑی فہرستوں کے ل it اسے غیر موثر بنا دیتا ہے۔تاہم ، بلبلے کی طرح کو سمجھنے اور اس پر عمل درآمد کرنے کے لئے آسان ہونے کا فائدہ ہے۔ نوٹ: عملی طور پر ، بلبلا کی طرح کی کارکردگی کی وجہ سے بڑی فہرستوں کو چھانٹنے کے لئے شاذ و نادر ہی استعمال کیا جاتا ہے۔زیادہ موثر ترتیب دینے والے الگورتھم جیسے فوری ترتیب ، انضمام کی ترتیب ، یا ڈھیر ترتیب کو بڑے ڈیٹاسیٹس کے لئے ترجیح دی جاتی ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "ایک واحد منسلک فہرست اور دوگنا منسلک فہرست کے درمیان بنیادی فرق ہر نوڈ کے پاس موجود حوالوں کی تعداد میں ہے۔ان دونوں کا موازنہ یہاں ہے: اکیلے لنکڈ لسٹ: واحد منسلک فہرست میں ہر نوڈ میں دو فیلڈز شامل ہیں: فہرست میں اگلے نوڈ کا ڈیٹا اور ایک حوالہ (یا پوائنٹر)۔ نوڈس غیر مستقیم انداز میں جڑے ہوئے ہیں ، جہاں ہر نوڈ پوائنٹساگلے نوڈ پر۔ فہرست میں آخری نوڈ NULL کی طرف اشارہ کرتا ہے ، فہرست کے اختتام کی نشاندہی کرتا ہے۔ فہرست کو آگے بڑھانا صرف ایک آگے کی سمت میں کیا جاسکتا ہے ، سر (پہلے نوڈ) سے شروع ہوتا ہے ۔مشار اور حذف کرنے کی کارروائییں ہوسکتی ہیں۔فہرست کے آغاز یا اختتام پر موثر انداز میں کارکردگی کا مظاہرہ کیا ، لیکن وہ وسط میں کم موثر ہیں کیونکہ اس کو سر سے سفر کرنے کی ضرورت ہوتی ہے۔ بڑی حد تک منسلک فہرستوں کو دوگنا منسلک فہرستوں کے مقابلے میں کم میموری کی ضرورت ہوتی ہے کیونکہ وہ صرف ایک ہی حوالہ فی نوڈ کو اسٹور کرتے ہیں۔فہرستیں کم وسائل کو نافذ کرنے اور استعمال کرنے کے لئے آسان ہیں۔ ڈولی سے منسلک فہرست: دوگنا منسلک فہرست میں ہر نوڈ میں تین فیلڈز شامل ہیں: ڈیٹا ، اگلے نوڈ کا حوالہ ، اور پچھلے نوڈ کا حوالہ۔ نوڈس دو طرفہ انداز میں جڑے ہوئے ہیں ،جہاں ہر نوڈ کے پاس اگلے اور پچھلے دونوں نوڈس کا حوالہ ہوتا ہے۔ پہلا نوڈ کا پچھلا حوالہ اور آخری نوڈ کا اگلا حوالہ نول سے ہوتا ہے ، جس میں فہرست کی حدود کی نشاندہی ہوتی ہے۔ فہرست کو آگے بڑھانا آگے اور پسماندہ دونوں سمتوں میں کیا جاسکتا ہے ، جس کی اجازت دی جاسکتی ہے۔عناصر تک رسائی میں لچک کے ل .۔ فہرست میں کسی بھی پوزیشن پر داخل اور حذف کرنے کی کارروائیوں کو موثر انداز میں انجام دیا جاسکتا ہے کیونکہ پچھلے اور اگلے حوالوں سے ہمسایہ نوڈس میں آسانی سے ترمیم کرنے کی اجازت ہے۔اکیلے لنکڈ فہرستوں کے مقابلے میں میموری سے متعلق۔اکیلے لنکڈ فہرستیں اکثر آسان منظرناموں کے لئے کافی ہوتی ہیں جہاں صرف فارورڈ ٹراورسل کی ضرورت ہوتی ہے اور میموری کی کارکردگی ایک تشویش ہے۔دوگنا منسلک فہرستیں افضل ہیں جب پسماندہ ٹریورسل ، وسط میں موثر اندراج/حذف کرنے ، یا اس سے زیادہ جدید کارروائیوں کی ضرورت ہوتی ہے ، میموری کے تھوڑا سا استعمال اور اضافی پیچیدگی کی قیمت پر۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی کا انحصار مخصوص نفاذ اور تصادم کی موجودگی پر ہوتا ہے۔اوسط صورت میں ، ایک اچھی طرح سے تقسیم شدہ ہیش فنکشن اور کم بوجھ عنصر کے ساتھ ، ہیش ٹیبل میں تلاش کرنے کی وقت کی پیچیدگی O (1) ، یا مستقل وقت ہے۔ یہاں تلاش کرنا ایک خرابی ہے کہ عام طور پر ہیش ٹیبل میں کس طرح کام کرتا ہے:جس عنصر کی تلاش کی جائے اس کی کلید ہیش فنکشن کا استعمال کرتے ہوئے ہیش کی جاتی ہے۔ہیش فنکشن ہیش ٹیبل کے بنیادی سرنی ڈھانچے میں انڈیکس کی کلید کا نقشہ بناتا ہے۔ اگر کوئی تصادم نہیں ہوتا ہے (یعنی ایک ہی انڈیکس میں ایک سے زیادہ چابیاں میپنگ کرتے ہیں) تو ، مطلوبہ عنصر کمپیوٹڈ انڈیکس پر پایا جاتا ہے۔تصادم ہیں ، ان کو حل کرنے کے لئے اضافی اقدامات کی ضرورت ہے: الف۔ایک علیحدہ زنجیروں کے تصادم کی قرارداد کے طریقہ کار میں ، سرنی کے ہر انڈیکس میں ایک منسلک فہرست یا کچھ اور ڈیٹا ڈھانچہ ہوتا ہے جس میں متعدد عناصر ہوتے ہیں جو ایک ہی انڈیکس میں شامل ہوتے ہیں۔اس معاملے میں ، مطلوبہ عنصر کو تلاش کرنے کے لئے لنکڈ فہرست میں ایک لکیری تلاش یا کوئی اور موثر سرچ آپریشن انجام دیا جاتا ہے۔لنکڈ فہرست میں تلاش کی وقت کی پیچیدگی عام طور پر O (K) ہوتی ہے ، جہاں K فی انڈیکس ڈاٹ بی کے عناصر کی اوسط تعداد ہوتی ہے۔کھلے عام تصادم کے حل کے طریقوں (جیسے لکیری تحقیقات ، چوکور تحقیقات ، یا ڈبل ہیشنگ) میں ، تلاش جاری رہتی ہے جب تک کہ کسی پہلے سے طے شدہ الگورتھم کی بنیاد پر اگلے دستیاب انڈیکس کی جانچ پڑتال کی جاتی ہے جب تک کہ مطلوبہ عنصر نہیں مل جاتا یا خالی سلاٹ کا سامنا نہیں ہوتا ہے۔کھلے عام خطاب کرنے کے طریقوں میں تلاش کی وقت کی پیچیدگی کا انحصار مخصوص تحقیقات الگورتھم اور ہیش ٹیبل کے بوجھ عنصر پر ہوتا ہے۔کم بوجھ عنصر کے ساتھ ، بہترین صورتحال میں ، تلاش O (1) کے قریب ہوسکتی ہے۔تاہم ، بدترین صورت میں ، جب بوجھ کا عنصر زیادہ ہوتا ہے اور بہت ساری تحقیقات کی ضرورت ہوتی ہے تو ، وقت کی پیچیدگی O (n) کے قریب آسکتی ہے ، جہاں ہیش ٹیبل میں عناصر کی تعداد ہوتی ہے۔ایک ہیش ٹیبل میں ، ایک اچھی طرح سے تقسیم شدہ ہیش فنکشن اور کم بوجھ عنصر کو فرض کرتے ہوئے ، O (1) ہے۔تاہم ، تصادم کی موجودگی اور تصادم کے حل کے مخصوص طریقہ کار پر غور کرنا ضروری ہے ، کیونکہ وہ بدترین وقت کی پیچیدگی کو متاثر کرسکتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "ایک سرکلر بفر ، جسے سرکلر قطار یا رنگ بفر کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ایک سرکلر ، مسلسل اسٹوریج ایریا کے طور پر ایک مقررہ سائز کا بفر استعمال کرتا ہے۔اس کو ایک مقررہ صلاحیت اور دو پوائنٹرز کے ساتھ ایک صف کے طور پر نافذ کیا جاتا ہے ، ایک بفر (سامنے) کے آغاز کی طرف اشارہ کرتا ہے اور دوسرا بفر (عقبی) کے اختتام کی طرف اشارہ کرتا ہے۔ سرکلر بفر کی کلیدی خصوصیات اور فوائد مندرجہ ذیل ہیں۔: لپیٹنے والا سلوک: سرکلر بفر جب بفر کے اختتام تک پہنچ جاتا ہے تو اس کے گرد لپیٹ جاتا ہے ، مؤثر طریقے سے ایک سرکلر یا چکرمک نوعیت پیدا کرتا ہے۔اس کا مطلب یہ ہے کہ اگر عقبی پوائنٹر بفر کے اختتام تک پہنچ جاتا ہے تو ، یہ بفر کے آغاز تک لپیٹتا ہے ، جس سے دستیاب جگہ کے موثر استعمال کی اجازت ملتی ہے۔سرکلر بفر مستقل وقت (O (1)) میں بفر کے سائز سے قطع نظر انجام دیا جاسکتا ہے۔یہ ممکن ہے کیونکہ لپیٹے ہوئے سلوک سے عناصر کی مہنگی تبدیلی کی ضرورت ختم ہوجاتی ہے۔ قابل جگہ جگہ کے استعمال: لکیری بفرز یا صفوں کے برعکس ، ایک سرکلر بفر کسی بھی سلاٹ کو ضائع کیے بغیر دستیاب جگہ کو موثر انداز میں استعمال کرسکتا ہے۔یہ خاص طور پر ایسے منظرناموں میں مفید ہے جہاں بفر کا سائز طے ہوتا ہے ، اور جب بفر مکمل ہوتا ہے تو قدیم ترین عناصر اوور رائٹ ہوجاتے ہیں۔اس سے وہ میموری سے مجسم ماحول کے ل suitable موزوں بناتے ہیں جہاں متحرک میموری کی مختص محدود ہے یا مطلوبہ نہیں ہے۔ اسٹریمنگ اور ریئل ٹائم ایپلی کیشنز کے لئے استعمال شدہ: سرکلر بفر عام طور پر ایسے منظرناموں میں استعمال ہوتے ہیں جہاں ڈیٹا کو مستقل طور پر کارروائی یا اسٹریم کرنے کی ضرورت ہوتی ہے۔وہ مختلف نرخوں اور سائز کے ڈیٹا اسٹریمز کو سنبھالنے کے ل well مناسب ہیں ، جس سے موثر بفرنگ اور پروسیسنگ کی اجازت ملتی ہے۔ آسانیاں: سرکلر بفرز کو عملی جامہ پہنانے اور سمجھنے کے لئے نسبتا simple آسان ہے ، جس میں صرف سرنی اشاریہ سازی اور پوائنٹر ہیرا پھیری کے بنیادی علم کی ضرورت ہوتی ہے۔مختلف ڈومینز ، بشمول ایمبیڈڈ سسٹم ، ریئل ٹائم ڈیٹا پروسیسنگ ، آڈیو اور ویڈیو اسٹریمنگ ، نیٹ ورک پروٹوکول ، اور بہت کچھ۔وہ ڈیٹا کے بہاؤ کو سنبھالنے اور ڈیٹا کے مستقل سلسلوں کی ہموار پروسیسنگ کی سہولت فراہم کرنے کے لئے ایک موثر اور قابل اعتماد طریقہ فراہم کرتے ہیں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "متوازن تلاش کے درختوں کے تناظر میں ، سست لوڈنگ سے مراد ایک ایسی تکنیک ہے جہاں نوڈ کے اعداد و شمار یا قدر کی اصل گنتی یا بازیافت اس وقت تک موخر کردی جاتی ہے جب تک کہ اس کی واضح طور پر درخواست نہ کی جائے۔تعمیر یا اضافے کے دوران درخت میں تمام نوڈس کے لئے اقدار کو پیش کرنے اور ذخیرہ کرنے کے بجائے ، اقدار صرف اس وقت بھری ہوئی یا حساب کی جاتی ہیں جب ضروری ہو۔ لیزی لوڈنگ خاص طور پر منظرناموں میں مفید ثابت ہوسکتی ہے جہاں نوڈ کی قیمت کی گنتی یا بازیافت مہنگا یا وسائل ہے۔گہریجب تک اس کی ضرورت نہ ہو اس وقت تک لوڈنگ کو موخر کرنے سے ، غیر ضروری کمپیوٹیشن یا بازیافتوں سے بچا جاسکتا ہے ، ممکنہ طور پر وقت اور وسائل کی بچت ہوتی ہے۔ جب سست لوڈنگ کو متوازن سرچ درخت پر لگایا جاتا ہے ، جیسے AVL درخت یا سرخ سیاہ درخت ، میں نوڈسدرخت عام طور پر اصل قدر کو براہ راست ذخیرہ کرنے کے بجائے کلید اور قدر کے حوالے سے ذخیرہ کرتا ہے۔نوڈ سے وابستہ قدر صرف اس وقت حاصل کی جاتی ہے یا اس کی گنتی کی جاتی ہے۔ یہاں متوازن سرچ درخت میں سست لوڈنگ کے تصور کو واضح کرنے کے لئے ایک مثال کا منظر ہے: فرض کیج. ہمارے پاس متوازن سرچ ٹری ہے جو طلباء کے بارے میں معلومات کو محفوظ کرتا ہے ، جہاں ہر نوڈ طالب علم کی نمائندگی کرتا ہے۔اور طالب علم کی شناخت (کلید) اور طالب علم کے گریڈ (ویلیو) کو اسٹور کرتا ہے۔ درخت کی تعمیر کرتے وقت تمام طلباء کے درجات کو لوڈ کرنے اور اسٹور کرنے کے بارے میں ، ہم سست لوڈنگ کا استعمال کرتے ہیں۔ہر نوڈ میں صرف طالب علم کے درجات کا حوالہ ہوتا ہے ، بجائے اس کے کہ اصل گریڈ کے بجائے۔ جب درخت پر تلاش یا بازیافت کا کام انجام دیا جاتا ہے ، اور ایک مخصوص طالب علم کے درجات کی درخواست کی جاتی ہے تو ، سست لوڈنگ کھیل میں آجاتی ہے۔صرف اس مقام پر ، گریڈ کے بارے میں نوڈ کے حوالہ کی پیروی کی جاتی ہے ، اور اصل درجات کو بھری ہوئی یا اس کی گنتی کی جاتی ہے۔ سست لوڈنگ میکانزم اس بات کو یقینی بناتا ہے کہ جب ضروری ہو تو گریڈ کی گنتی یا بازیافت صرف اس وقت انجام دی جاتی ہے ، غیر ضروری گنتی اور وسائل کو کم سے کم کرتے ہوئے۔ استعمال کرتے ہوئے۔ استعمال کرتے ہوئے۔متوازن سرچ درخت میں سست لوڈنگ ، ہم میموری کے نقش کو کم کرسکتے ہیں اور ان کارروائیوں کی کارکردگی کو بہتر بناسکتے ہیں جس میں نوڈ کی اقدار تک رسائی کی ضرورت نہیں ہوتی ہے۔صرف اس صورت میں جب اقدار کی واضح طور پر درخواست کی جاتی ہے ، ان کو لوڈ یا حساب کتاب کیا جاتا ہے ، جس سے آن ڈیمانڈ کی بازیافت یا حساب کتاب کی اجازت مل جاتی ہے۔ یہ بات اہم ہے کہ سست لوڈنگ متوازن سرچ درخت کے نفاذ میں کچھ پیچیدگی کا اضافہ کرتی ہے ، کیونکہ اس میں اقدار کی بوجھ کو سنبھالنے کی ضرورت ہوتی ہے۔اور ان حالات کو سنبھالنا جہاں توقع کے وقت اقدار دستیاب نہیں ہوسکتی ہیں۔تاہم ، جب مناسب طریقے سے لاگو ہوتا ہے تو ، سست لوڈنگ منظرناموں میں ایک قیمتی اصلاح کی تکنیک ہوسکتی ہے جہاں اقدار کی گنتی یا بازیافت مہنگی ہوتی ہے اور بیک وقت تمام اقدار کی ضرورت نہیں ہوتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "ریڈکس ترتیب ایک لکیری ٹائم چھانٹ رہا الگورتھم ہے جو ان کے انفرادی ہندسوں یا ریڈکس کی بنیاد پر عناصر کو ترتیب دیتا ہے۔یہ عناصر کو ہر ہندسے کی قدر کی بنیاد پر بالٹیوں کے ایک سیٹ میں تقسیم کرکے کام کرتا ہے ، کم سے کم اہم ہندسوں (دائیں طرف) سے لے کر انتہائی اہم ہندسے (بائیں طرف) تک۔ریڈکس ترتیب کو عدد ، تاروں ، یا کسی بھی طرح کے اعداد و شمار کو ترتیب دینے کے لئے استعمال کیا جاسکتا ہے جس کو ہندسے کے ذریعہ ہندسے کی نمائندگی کی جاسکتی ہے۔ ریڈکس ترتیب دینے کا ایک جائزہ ہے: ترتیب دینے کے لئے عناصر کی غیر ترتیب شدہ صف سے شروع کریں۔ زیادہ سے زیادہ تعداد کی وضاحت کریں۔صف میں موجود تمام عناصر کے درمیان ہندسے۔اس سے چھانٹنے کے عمل کے لئے درکار پاسوں یا تکرار کی تعداد طے ہوتی ہے۔ ہر ہندسے کے لئے ایک پاس کو کم سے کم اہم ہندسے سے لے کر انتہائی اہم ہندسے تک کا مظاہرہ کریں۔ہر پاس کے لئے ، موجودہ ہندسے کی قیمت کی بنیاد پر عناصر کو 10 بالٹی (0-9) میں تقسیم کریں۔ بالٹیوں میں عناصر کو تقسیم کرنے کے بعد ، بالٹیوں کی ترتیب میں عناصر کو ایک ہی صف میں واپس جمع کریں۔یہ عمل اس بات کو یقینی بناتا ہے کہ ایک ہی ہندسے کی قیمت والے عناصر ایک ہی رشتہ دار ترتیب میں رہیں۔ ہر بعد کے ہندسے کے لئے 3-4 سے کم اقدامات ، کم سے کم اہم ہندسے سے انتہائی اہم ہندسے کی طرف بڑھتے ہوئے۔آخری پاس کے بعد ، سرنی کو ترتیب دیا جائے گا۔ ریڈکس ترتیب میں ایل ایس ڈی (کم سے کم اہم ہندسہ) یا ایم ایس ڈی (انتہائی اہم ہندسہ) نقطہ نظر کا استعمال کرتے ہوئے نافذ کیا جاسکتا ہے۔ایل ایس ڈی ریڈکس ترتیب دائیں طرف سے شروع ہوتی ہے اور بائیں طرف آگے بڑھتی ہے ، جبکہ ایم ایس ڈی ریڈکس ترتیب بائیں طرف سے شروع ہوتی ہے اور دائیں طرف آگے بڑھتی ہے۔دونوں طریقوں کے اعداد و شمار کی ترتیب کی خصوصیات پر انحصار کرتے ہوئے ان کے فوائد اور تحفظات ہیں۔ ریڈکس ترتیب کی وقت کی پیچیدگی O (K * N) ہے ، جہاں N عناصر کی تعداد ہے اور K ہندسوں کی اوسط تعداد ہے۔یہ ایک لکیری وقت کو چھانٹ رہا ہے الگورتھم سمجھا جاتا ہے کیونکہ پاس (کے) کی تعداد عام طور پر عناصر کی تعداد (این) سے بہت چھوٹی ہوتی ہے۔ رادکس ترتیب ایک مستحکم چھانٹنے والا الگورتھم ہے ، اس کا مطلب ہے کہ یہ مساوی اقدار کے ساتھ عناصر کے متعلقہ ترتیب کو برقرار رکھتا ہے۔تاہم ، ہر ہندسے کے ل the بالٹیوں کو تھامنے کے ل it اس کو اضافی میموری کی ضرورت ہوتی ہے ، جو اس کی جگہ کی کارکردگی کو متاثر کرسکتی ہے۔یہ عام طور پر انٹیجر چھانٹنے ، سٹرنگ چھانٹنے اور دیگر ایپلی کیشنز کے لئے استعمال ہوتا ہے جہاں عنصر کا ڈھانچہ انفرادی ہندسوں کی بنیاد پر چھانٹنے کی اجازت دیتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک AVL درخت ایک قسم کا خود توازن بائنری سرچ ٹری (BST) ہے جو موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو یقینی بنانے کے لئے ایک مخصوص توازن کی حالت کو برقرار رکھتا ہے۔اے وی ایل کے درخت اور عمومی بائنری تلاش کے درخت کے درمیان کلیدی فرق بیلنس عنصر اور اس سے وابستہ توازن کے عمل میں ہے۔یہاں اہم اختلافات ہیں: بیلنس فیکٹر: اے وی ایل کے درخت میں ہر نوڈ ایک بیلنس عنصر کو ذخیرہ کرتا ہے ، جو اس نوڈ کے بائیں اور دائیں سب ٹریوں کے درمیان اونچائی کا فرق ہے۔بیلنس عنصر -1 ، 0 ، یا 1 ہوسکتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ آیا سب ٹری بالترتیب بائیں بھاری ، متوازن یا دائیں بھاری ہے۔عام بائنری سرچ ٹری میں ، توازن کے عنصر کا کوئی تصور نہیں ہے۔ متوازن آپریشنز: جب بھی کسی AVL درخت میں اندراج یا حذف کرنے کا عمل انجام دیا جاتا ہے جو توازن کی حالت میں خلل ڈالتا ہے (توازن عنصر -2 یا +2 بن جاتا ہے) ، مخصوص توازن کی کاروائیاں ہوتی ہیں۔توازن کو بحال کرنے کے لئے متحرک.ان کارروائیوں میں درخت کی تنظیم نو اور توازن برقرار رکھنے کے لئے گردش (سنگل یا ڈبل گردش) شامل ہیں۔عام بائنری سرچ ٹری میں ، کوئی خاص توازن عمل نہیں ہوتا ہے ، اور وقت کے ساتھ ساتھ درخت غیر متوازن ہوسکتا ہے۔ خود متوازن پراپرٹی: ایک AVL درخت خود توازن رکھنے والا ڈیٹا ڈھانچہ ہے ، یعنی یہ اندراج اور حذف کرنے کی کارروائیوں کے دوران خود بخود اس کی ساخت کو ایڈجسٹ کرتا ہے۔توازن کی حالت کو برقرار رکھنے کے لئے۔یہ خود توازن رکھنے والی جائیداد اس بات کو یقینی بناتی ہے کہ درخت کی اونچائی O (لاگ این) رہتی ہے ، جہاں N عناصر کی تعداد ہے۔عام بائنری تلاش کے درخت میں ، توازن کی کوئی ضمانت نہیں ہے ، اور درخت کی اونچائی بدترین صورت میں O (n) سے کم ہوسکتی ہے ، جس سے تلاشی کے کاموں کے لئے کم موثر ہوجاتا ہے۔ کارکردگی: خود توازن رکھنے والی املاک کی وجہ سے ،اے وی ایل کے درخت بدترین صورت میں او (لاگ این) کی وقت کی پیچیدگی کے ساتھ موثر تلاش ، اندراج اور حذف کرنے کے کام فراہم کرتے ہیں۔یہ تمام کاموں کے لئے متوازن رسائی کے اوقات کی ضمانت دیتا ہے۔عام بائنری تلاش کے درخت میں ، آپریشنز کی وقت کی پیچیدگی کا انحصار درخت کے ڈھانچے پر ہوتا ہے ، جو بیلنس پر منحصر O (لاگ N) سے O (n) تک مختلف ہوسکتا ہے۔ خلاصہ۔ ایک AVL درخت خود توازن کی ایک قسم ہے۔بائنری سرچ ٹری جو ایک توازن عنصر کو برقرار رکھتا ہے اور درخت کو متوازن رہنے کو یقینی بنانے کے لئے مخصوص توازن کے کام انجام دیتا ہے۔اس سے گارنٹیڈ لوگرتھمک ٹائم پیچیدگی کے ساتھ موثر تلاش ، اندراج اور حذف کرنے کی کارروائیوں کو یقینی بنایا جاتا ہے۔اس کے برعکس ، ایک عام بائنری سرچ ٹری میں توازن عنصر یا مخصوص توازن کے کام نہیں ہوتے ہیں ، اور اس کا ڈھانچہ اندراج کے حکم پر منحصر ہوتا ہے ، جس سے ممکنہ طور پر غیر متوازن درخت اور کم موثر آپریشن ہوتے ہیں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "ایک بلوم فلٹر ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو کسی سیٹ میں کسی عنصر کی رکنیت کو جانچنے کے لئے استعمال ہوتا ہے۔یہ مؤثر طریقے سے یہ طے کرتا ہے کہ آیا کسی عنصر کو سیٹ میں موجود ہونے کا امکان ہے یا یقینی طور پر موجود نہیں ہے ، لیکن یہ کبھی کبھار غلط مثبت نتائج پیدا کرسکتا ہے (اس بات کا اشارہ کرتا ہے کہ عنصر موجود ہوتا ہے جب یہ نہیں ہوتا ہے) ، حالانکہ یہ کبھی بھی غلط منفی پیدا نہیں کرتا ہے (اس بات کی نشاندہی کرتے ہیں کہ ایکعنصر موجود نہیں ہوتا ہے جب یہ ہوتا ہے) .یہ ہے کہ بلوم فلٹر کس طرح کام کرتا ہے: ابتدا: ایک بلوم فلٹر ایک مقررہ سائز بٹ سرنی (عام طور پر ایم بٹس کے) اور K آزاد ہیش فنکشن کا ایک سیٹ کے ساتھ تیار کیا جاتا ہے۔بلوم فلٹر کا عنصر ، یہ K ہیش کے ہر افعال کا استعمال کرتے ہوئے ہیش کیا جاتا ہے ، جس کے نتیجے میں K مختلف ہیش اقدار ہوتی ہیں۔بٹ سرنی میں متعلقہ بٹس ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر 1 پر سیٹ کیے گئے ہیں۔ میمبرشپ ٹیسٹ: یہ چیک کرنے کے لئے کہ عنصر سیٹ میں ہے یا نہیں ، عنصر کو اسی کے ہیش افعال کا استعمال کرتے ہوئے ہیش کیا جاتا ہے۔ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر بٹ سرے میں بٹس کی جانچ کی جاتی ہے۔اگر تمام متعلقہ بٹس 1 پر سیٹ کیے گئے ہیں تو ، عنصر کو سیٹ میں \"ممکنہ طور پر موجود\" سمجھا جاتا ہے۔اگر بٹس میں سے کسی کو 1 پر سیٹ نہیں کیا گیا ہے تو ، عنصر یقینی طور پر سیٹ میں موجود نہیں ہے۔ بلوم فلٹرز کی کلیدی خصوصیات اور استعمال کے معاملات مندرجہ ذیل ہیں: خلائی کارکردگی: بلوم فلٹر دوسرے اعداد و شمار کے مقابلے میں نسبتا small تھوڑی مقدار میں میموری کا استعمال کرتے ہیں۔ہیش ٹیبل جیسے ڈھانچے۔خلائی کارکردگی کو غلط مثبت کی اجازت دے کر حاصل کیا جاتا ہے۔ ممبرشپ کا تخمینہ سیٹ کریں: بلوم فلٹرز بنیادی طور پر کسی سیٹ میں ممبرشپ کو موثر انداز میں جانچنے کے لئے استعمال ہوتے ہیں۔وہ ایسے منظرناموں کے لئے موزوں ہیں جہاں پورے سیٹ کو ذخیرہ کرنے کے لئے میموری یا اسٹوریج کی ضروریات ممنوع ہیں۔ اسپیڈ: بلوم فلٹرز میں ممبرشپ ٹیسٹ بہت تیز ہیں کیونکہ انہیں صرف ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر بٹ سرے کا اندازہ کرنے کی ضرورت ہوتی ہے ، بغیر اصل تک رسائی حاصل کی۔عناصر۔ فالس مثبت: بلوم فلٹرز غلط مثبت پیدا کرسکتے ہیں ، جہاں کسی عنصر کو سیٹ میں موجود کے طور پر غلط طور پر شناخت کیا جاتا ہے۔جھوٹے مثبت کے امکان کا انحصار بٹ سرنی (م) کے سائز ، ہیش افعال (کے) کی تعداد ، اور سیٹ میں عناصر کی تعداد پر ہوتا ہے۔ بلوم فلٹرز مختلف شعبوں میں ایپلی کیشنز تلاش کرتے ہیں ، جیسے نیٹ ورک روٹرز (فلٹر کرنے کے لئےناپسندیدہ ٹریفک) ، ڈیٹا بیس (غیر موجود ریکارڈوں کے لئے ڈسک کی تلاش کو کم کرنے کے لئے) ، ہجے چیکرس ، سرچ انجن (غیر ضروری ڈسک تک رسائی کو کم کرنے کے لئے) ، اور بہت کچھ۔ یہ بات اہم ہے کہ بلوم فلٹرز موثر اور جگہ کی بچت ہیں ، وہ ہیں ، وہ ہیں ، وہ ہیںان ایپلی کیشنز کے ل suitable موزوں نہیں جہاں جھوٹے مثبت ناقابل قبول ہوں یا جب عناصر کے مکمل سیٹ کو درست طریقے سے بازیافت کرنے کی ضرورت ہو۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "امورائزڈ تجزیہ ایک ایسی تکنیک ہے جو اعداد و شمار کے ڈھانچے پر آپریشنز کی ترتیب کی اوسط وقت کی پیچیدگی کا تعین کرنے کے لئے استعمال کی جاتی ہے ، چاہے انفرادی کارروائیوں میں مختلف وقت کی پیچیدگیاں ہوسکتی ہیں۔یہ کاموں کی ایک سیریز کے دوران اعداد و شمار کے ڈھانچے یا الگورتھم کی کارکردگی کی خصوصیات کے بارے میں زیادہ درست اور جامع تفہیم فراہم کرتا ہے۔ کچھ معاملات میں ، اعداد و شمار کے ڈھانچے میں کسی ایک آپریشن کی بدترین وقت کی پیچیدگی ناکارہ ہوسکتی ہے ، لیکن جب کسی ترتیب پر غور کریں۔کارروائیوں میں ، اوسط وقت کی پیچیدگی نمایاں طور پر بہتر ہوسکتی ہے۔امورائزڈ تجزیہ ہمیں مہنگے کارروائیوں کے اخراجات کو بڑی تعداد میں سستے کاموں پر تقسیم کرکے کارروائیوں کی مجموعی لاگت کا تجزیہ کرنے میں مدد کرتا ہے۔ امورٹائزڈ تجزیہ میں تین اہم طریقے شامل ہیں: مجموعی تجزیہ: یہ طریقہ کاروں کی ترتیب کی کل لاگت کا تجزیہ کرتا ہے اور اس کو تقسیم کرتا ہے۔کارروائیوں کی تعداد سے۔یہ فی آپریشن اوسط لاگت پر ایک اوپری پابند فراہم کرتا ہے۔ اکاؤنٹنگ طریقہ: اس طریقہ کار میں ، کچھ آپریشنوں کو اضافی \"کریڈٹ\" تفویض کیا جاتا ہے تاکہ دیگر کارروائیوں کی لاگت کو پورا کیا جاسکے جو نسبتا in سستا ہے۔کریڈٹ کو کارروائیوں میں تقسیم کیا جاتا ہے ، اس بات کو یقینی بناتے ہوئے کہ کل لاگت کا حساب کتاب ہے۔ ممکنہ طریقہ: یہ طریقہ امور لاگت کا تجزیہ کرنے کے لئے ممکنہ توانائی کے تصور کو استعمال کرتا ہے۔یہ ایک ممکنہ فنکشن کی وضاحت کرتا ہے جو ہر آپریشن کے بعد ڈیٹا ڈھانچے میں محفوظ \"ممکنہ توانائی\" کی نمائندگی کرتا ہے۔ابتدائی اور آخری ریاستوں کے مابین ممکنہ فرق کو آپریشنز کی لاگت کا حساب کتاب کرنے کے لئے استعمال کیا جاتا ہے۔ عام تجزیہ عام طور پر مختلف ڈیٹا ڈھانچے اور الگورتھم کی کارکردگی کا تجزیہ کرنے کے لئے استعمال کیا جاتا ہے ، جیسے متحرک صفوں (جیسے ، اری لسٹ) ، ہیش ٹیبلز ، خودمتوازن درخت (جیسے ، AVL درخت ، سرخ سیاہ درخت) ، اور بہت کچھ۔اس سے ان ڈھانچے کے اوسط طرز عمل کے بارے میں بصیرت فراہم کرنے میں مدد ملتی ہے ، جس سے ان کی کارکردگی کی خصوصیات کی بہتر تفہیم اور موازنہ کرنے کی اجازت ملتی ہے۔مختلف منظرنامے۔یہ ان معاملات کی نشاندہی کرنے میں ہماری مدد کرتا ہے جہاں ایک مہنگا آپریشن سستے آپریشنوں کی ترتیب سے پیش کیا جاتا ہے ، جس کے نتیجے میں مجموعی طور پر موثر حل ہوتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "جامد صف اور متحرک صف کے درمیان فرق سائز اور میموری کے انتظام کے لحاظ سے ان کی مختص اور لچک میں ہے۔یہاں ہر ایک کی وضاحت ہے: جامد سرنی: سائز: ایک مستحکم صف کا ایک مقررہ سائز ہوتا ہے جو اعلان کے وقت طے ہوتا ہے۔ایک بار جب سائز کی وضاحت ہوجائے تو ، رن ٹائم کے دوران اسے تبدیل نہیں کیا جاسکتا۔ میموری مختص: جامد صفوں کو اسٹیک پر یا جامد/عالمی متغیر کے طور پر مختص کیا جاتا ہے۔اور کارکردگی: ایک مستحکم صف میں موجود عناصر کو ان کے اشاریہ کے ذریعہ رسائی حاصل کی جاتی ہے ، اور رسائی کا وقت مستقل ہوتا ہے (O (1))۔عناصر کو میموری میں لگاتار ذخیرہ کیا جاتا ہے۔رن ٹائم کے دوران ایڈجسٹ کریں۔جب ضرورت ہو تو پروگرامر میموری کو واضح طور پر مختص کرنے اور اس سے نمٹنے کے لئے ذمہ دار ہے جب اس کو میموری لیک سے بچنے کی ضرورت نہیں ہے۔ دوبارہ استعمال کرنا: مختلف تعداد میں عناصر کو ایڈجسٹ کرنے کے لئے متحرک صفوں کا سائز تبدیل کیا جاسکتا ہے۔عام طور پر دوبارہ بنانے میں میموری کا ایک نیا بلاک مختص کرنا ، موجودہ عناصر کو کاپی کرنا ، اور پرانی میموری کو ختم کرنا شامل ہے۔)). لچک: رن ٹائم کے دوران متحرک صف کے سائز کو تبدیل کرنے کی صلاحیت اسے جامد صف سے زیادہ لچکدار بناتی ہے۔یہ پروگرام کی اصل ضروریات کی بنیاد پر متحرک میموری مختص کرنے کی اجازت دیتا ہے۔ خلاصہ یہ کہ ایک مستحکم سرنی کا ایک مقررہ سائز مرتب وقت پر طے ہوتا ہے ، جبکہ ایک متحرک صف میں لچکدار سائز ہوتا ہے جسے رن ٹائم کے دوران ایڈجسٹ کیا جاسکتا ہے۔متحرک صفیں زیادہ لچک فراہم کرتی ہیں لیکن دستی میموری کے انتظام کی ضرورت ہوتی ہے ، جبکہ جامد صفوں میں ایک مقررہ سائز اور خودکار میموری کا انتظام ہوتا ہے۔جامد اور متحرک صفوں کے مابین انتخاب پروگرام کی مخصوص ضروریات پر منحصر ہے ، بشمول لچک ، میموری کی کارکردگی ، اور کارکردگی کے تحفظات کی ضرورت بھی۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "انضمام ترتیب والے الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: تقسیم کریں: غیر ترتیب شدہ صف کو دو حصوں میں تقسیم کریں۔یہ درمیانی اشاریہ تلاش کرکے اور دو الگ الگ سبریوں کی تشکیل کے ذریعہ کیا جاسکتا ہے ، ایک شروع سے وسط تک عناصر پر مشتمل ہے ، اور دوسرا درمیانی+1 سے آخر تک عناصر پر مشتمل ہے۔پچھلے مرحلے میں تخلیق کردہ دو سبریوں کو۔یہ قدم سبریوں کو تقسیم کرنا جاری رکھے گا جب تک کہ ہر سبری میں صرف ایک عنصر نہ ہو ، جسے پہلے ہی ترتیب دیا جاتا ہے۔یہ دو سبریوں کے عناصر کا موازنہ کرکے اور اصل صف میں رکھے جانے والے چھوٹے عنصر کو منتخب کرکے کیا جاتا ہے۔اس عمل کو اس وقت تک دہرائیں جب تک کہ دونوں سبریوں کے تمام عناصر کو اصل سرنی میں ضم نہیں کردیا گیا ہے۔ یہاں ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈیڈف انضمام_سورٹ (اے آر آر): # بیس کیس: اگر سرنی خالی ہے یا صرف ایک عنصر موجود ہے تو واپس کریں (اے آر آر)) <= 1: آر اے آر # صف کو دو حصوں میں تقسیم کریں وسط = لین (اے آر آر) // 2 بائیں_ہالف = آر اے آر [: وسط] دائیں_ہلف = آر آر [وسط:] # بار بار دو حصوں کو بائیں_ہالف = انضمام_سورٹ (بائیں_ہالف) دائیں_ہلف کو ترتیب دیں۔= انضمام_سورٹ (دائیں_ہالف) # ترتیب شدہ آدھے حص .ے کو ضم کریں<لین (بائیں) اور جے <لین (دائیں): اگر بائیں [i] <دائیں [j]: ضم شدہ۔ اپینڈ (بائیں [i]) i += 1 اور: ضم شدہ۔ اپینڈ (دائیں [j]) جے += 1 # subarrays (اگر کوئی ہے) سے باقی عناصر شامل کریں۔کوڈر = [4 ، 7 ، 2 ، 1 ، 5 ، 9 ، 3 ، 8 ، 6] چھانٹے ہوئے_ر = انضمام_سورٹ (اے آر آر) پرنٹ (چھانٹیا_ر) آؤٹ پٹ ترتیب شدہ صف ہوگا: [1 ، 2 ، 3 ، 4 ، 5 ،6 ، 7 ، 8 ، 9]۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "اسکیپ لسٹ ایک ڈیٹا ڈھانچہ ہے جو عناصر کی ترتیب شدہ فہرست میں عناصر کی تلاش کا ایک موثر طریقہ فراہم کرتا ہے۔یہ ایک منسلک فہرست کی طرح ہے لیکن اس میں متعدد متوازی لنکڈ فہرستیں شامل ہیں ، جن کو \"سطح\" کہا جاتا ہے ، جو تیزی سے تلاش کے کاموں کی اجازت دیتا ہے۔اسکیپ لسٹوں کو موثر تلاش کے اوقات اور عمل درآمد کی سادگی کے مابین توازن فراہم کرنے کے لئے ڈیزائن کیا گیا ہے۔ یہاں یہ ہے کہ اسکیپ لسٹ کس طرح کام کرتی ہے: ڈھانچہ: ایک اسکیپ لسٹ متعدد سطحوں پر مشتمل ہے ، جہاں ہر سطح نوڈس کی ایک منسلک فہرست ہے۔نچلی سطح ایک باقاعدہ ترتیب شدہ منسلک فہرست ہے جس میں تمام عناصر شامل ہیں۔نچلی سطح سے اوپر ہر سطح نچلی سطح کا سب سیٹ ہے ، جو کچھ عناصر کو چھوڑ دیتا ہے۔سب سے اوپر کی سطح میں صرف دو نوڈس ہوتے ہیں: ایک بائیں سینٹینیل اور ایک دائیں سینٹینیل۔ تلاش کرنا: اسکیپ لسٹ میں کسی عنصر کی تلاش کے ل you ، آپ سب سے اوپر کی سطح پر شروع کرتے ہیں اور لنکڈ فہرست کو عبور کرتے ہیں جب تک کہ آپ کو ایسا عنصر نہ مل سکے جو اس سے زیادہ یا برابر ہو۔ہدف عنصر کو۔اس کے بعد ، آپ اگلے درجے پر چلے جائیں اور اس عمل کو دہرائیں جب تک کہ آپ نیچے کی سطح تک نہ پہنچیں یا ہدف کا عنصر تلاش نہ کریں۔یہ اسکیپ ڈاون عمل فہرست کے بڑے حصوں کو چھوڑ کر تیز تر تلاش کرنے کی اجازت دیتا ہے۔ داخل کریں: جب کسی نئے عنصر کو اسکیپ لسٹ میں داخل کرتے ہو تو ، آپ اوپر کی سطح پر شروع کرتے ہیں اور اس پوزیشن کی تلاش کرتے ہیں جہاں نیا عنصر داخل کیا جانا چاہئے۔جب آپ سطحوں کو عبور کرتے ہیں تو ، آپ تصادفی طور پر فیصلہ کرتے ہیں کہ آیا اس سطح میں نئے عنصر کو داخل کرنا ہے یا اسے چھوڑ دینا ہے۔اگر نیا عنصر کسی خاص سطح پر داخل کیا جاتا ہے تو ، آپ ایک نیا نوڈ بناتے ہیں اور نئے نوڈ کو شامل کرنے کے لئے مناسب پوائنٹرز کو اپ ڈیٹ کرتے ہیں۔ ڈائلیشن: کسی عنصر کو اسکیپ لسٹ سے حذف کرنے کے لئے ، آپ اسکیپ لسٹ میں موجود عنصر کو تلاش کرتے ہیں اور اس کو اپ ڈیٹ کرتے ہیں۔عنصر پر مشتمل نوڈ کو نظرانداز کرنے کے لئے اشارے۔یہ ہٹانے کا عمل باقاعدگی سے منسلک فہرست میں حذف ہونے کی طرح ہے۔ اسکیپ لسٹ کی اونچائی کا تعین امکان کی تقسیم کے ذریعہ کیا جاتا ہے ، عام طور پر سکے ٹاس یا بے ترتیب نمبر جنریشن کی بنیاد پر ، جس سے یہ طے ہوتا ہے کہ آیا کسی عنصر کو اگلی سطح پر ترقی دی جانی چاہئے یا نہیں۔نہیں۔عنصر کی سطح جتنی اونچی ہوگی ، اس کے کم عناصر اس کے چھوڑ جاتے ہیں ، جس کے نتیجے میں تیزی سے تلاش کے اوقات ہوتے ہیں۔ ایس کے آئی پی کی فہرستیں تلاش ، اندراج اور حذف کرنے کے کاموں کے لئے اوسطا case وقت کی پیچیدگی فراہم کرتی ہیں ، جہاں این میں عناصر کی تعداد ہوتی ہے۔فہرست.اس سے اسکیپ کی فہرستوں کو زیادہ پیچیدہ متوازن سرچ ٹری ڈھانچے جیسے اے وی ایل کے درختوں یا سرخ سیاہ درختوں کے عملی متبادل بناتا ہے ، خاص طور پر جب سادگی اور عمل درآمد میں آسانی کو ترجیح دی جاتی ہے۔ یہ بات اہم ہے کہ اسکیپ لسٹوں میں متوازن تلاش کے درختوں کی طرح کی کارکردگی کی ضمانت نہیں ہے۔بدترین صورتحال میں۔تاہم ، اسکیپ لسٹوں کی امکانی نوعیت انہیں اوسطا موثر اور بہت سے عملی ایپلی کیشنز کے ل suitable موزوں بنا دیتی ہے جہاں بدترین صورتحال کا منظر کم ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک لاحقہ درخت ایک ڈیٹا ڈھانچہ ہے جو کسی دیئے گئے تار کے تمام لاحقہ کو موثر انداز میں نمائندگی کرتا ہے۔یہ بنیادی طور پر پیٹرن مماثل اور سٹرنگ سرچ آپریشنز کے لئے استعمال ہوتا ہے۔ایک لاحقہ درخت خاص طور پر ان ایپلی کیشنز میں مفید ہے جس میں بڑے متن یا ڈی این اے کی ترتیب کا تجزیہ کرنا شامل ہے۔ یہاں ایک لاحقہ درخت کس طرح کام کرتا ہے: تعمیر: لاحقہ درخت کی تعمیر کے لئے ، دیئے گئے تار کو کردار کے لحاظ سے پروسس کیا جاتا ہے۔تار کا ہر لاحقہ درخت میں ایک علیحدہ راستے کے طور پر شامل کیا جاتا ہے۔لاحقہ جو مشترکہ سابقہ میں شریک ہیں اسی طرح کا راستہ بانٹتے ہیں جب تک کہ وہ ڈائیورج۔ نوڈس اور ایجز: درخت نوڈس اور کناروں پر مشتمل ہوتا ہے۔ہر نوڈ اصل تار کے ایک ذخیرے کی نمائندگی کرتا ہے ، اور ہر کنارے ایک کردار کی نمائندگی کرتا ہے۔کناروں پر ان حروف کا لیبل لگا ہوا ہے جو اگلے نوڈس کی طرف جاتا ہے۔روٹ نوڈ خالی تار کی نمائندگی کرتا ہے ، اور ہر پتی نوڈ اصل تار کے لاحقہ سے مماثل ہوتا ہے۔ راستہ کمپریشن: جگہ کے استعمال کو بہتر بنانے کے لئے ، لاحقہ درخت اکثر راستے کی کمپریشن کو ملازمت دیتے ہیں۔اس کا مطلب یہ ہے کہ ایک ہی حروف کے ساتھ لگاتار کناروں کو ایک ہی کنارے میں ملایا جاتا ہے ، جس سے درخت میں نوڈس اور کناروں کی تعداد کم ہوجاتی ہے۔ لاحقہ درخت کئی مفید خصوصیات مہیا کرتا ہے: سٹرنگ سرچ: لاحقہ درخت کا بنیادی فائدہ اس کی مؤثر طریقے سے تلاش کرنے کی صلاحیت ہے۔اصل تار کے اندر سبسٹرنگ کے لئے۔استفسار کے تار کو دیکھتے ہوئے ، آپ اصل تار میں استفسار کے تار کے تمام واقعات کو تلاش کرنے کے لئے لاحقہ درخت کو عبور کرسکتے ہیں۔اس آپریشن میں او (ایم) کی وقت کی پیچیدگی ہے ، جہاں ایم استفسار کے تار کی لمبائی ہے۔ پیٹرن ملاپ: لاحقہ درخت پیٹرن مماثل کاموں کے لئے بہترین ہیں۔وہ آپ کو یہ تعین کرنے کی اجازت دیتے ہیں کہ آیا کوئی دیئے گئے نمونہ اصل تار میں موجود ہے اور پیٹرن کے تمام واقعات کو تلاش کرتا ہے۔اس آپریشن میں او (پی) کی وقت کی پیچیدگی ہے ، جہاں پی پیٹرن کی لمبائی ہے۔ عام طور پر عام سٹرنگ: لاحقہ درختوں کو متعدد ڈوروں کے مابین موثر انداز میں سب سے طویل مشترکہ سبسٹرنگ تلاش کرنے کے لئے استعمال کیا جاسکتا ہے۔تمام ڈوروں کے لئے ایک ہی لاحقہ درخت کی تعمیر اور درخت کے ڈھانچے کا تجزیہ کرکے ، آپ سب سے طویل عام سبسٹرنگ کی نشاندہی کرسکتے ہیں۔ سفکس درخت مختلف ایپلی کیشنز میں بڑے پیمانے پر استعمال ہوتے ہیں ، بشمول بائیو انفارمیٹکس (ڈی این اے ترتیب تجزیہ ، جینوم اسمبلی ، اور جینوم میں دہرنے کی تلاش)، ٹیکسٹ انڈیکسنگ اور سرچ انجن (الفاظ یا فقرے کے واقعات کی تلاش) ، ڈیٹا کمپریشن الگورتھم ، اور بہت کچھ۔وہ سٹرنگ تجزیہ ، پیٹرن مماثل ، اور سٹرنگ تلاش سے متعلق کاموں کے لئے موثر اور توسیع پذیر حل فراہم کرتے ہیں۔تاہم ، لاحقہ درخت کی تعمیر کمپیوٹیشنل مہنگا ہوسکتی ہے ، عام طور پر O (n) وقت اور جگہ کی پیچیدگی کی ضرورت ہوتی ہے ، جہاں N ان پٹ سٹرنگ کی لمبائی ہوتی ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "بائنری سرچ ٹری (بی ایس ٹی) میں کسی عنصر کو داخل کرنے کی وقت کی پیچیدگی درخت کی ساخت پر منحصر ہے۔بہترین صورتحال میں ، جہاں درخت متوازن ہے ، وقت کی پیچیدگی O (لاگ این) ہے ، جہاں N درخت میں نوڈس کی تعداد ہے۔تاہم ، بدترین صورتحال میں ، جہاں درخت انتہائی متوازن ہے (لکیری لنکڈ فہرست سے مشابہت) ، وقت کی پیچیدگی O (n) ہوسکتی ہے ، جہاں درخت میں نوڈس کی تعداد ہے۔ اس تغیر کی وجہ یہ ہےکہ متوازن بی ایس ٹی میں ، درخت کی اونچائی نوڈس کی تعداد کے سلسلے میں لاگ ان کی رہتی ہے ، جس سے داخلے کے موثر کاموں کو یقینی بنایا جاتا ہے۔متوازن بی ایس ٹی میں ہر سطح باقی تلاش کی جگہ کو تقریبا half نصف تک تقسیم کرتا ہے ، جس کی وجہ سے عناصر کی متوازن تقسیم ہوتی ہے۔ دوسری طرف ، ایک متوازن بی ایس ٹی ایک لکیری ڈھانچے میں ہراس ڈال سکتا ہے ، جس میں ایک سب ٹری دوسرے سے نمایاں طور پر بڑا ہے۔اس معاملے میں ، کسی عنصر کو داخل کرنے میں درخت کی پوری اونچائی سے گزرنا شامل ہوسکتا ہے ، جس کے نتیجے میں ایک خطی وقت کی پیچیدگی ہوتی ہے۔ موثر اضافے کو یقینی بنانے کے لئے ، خود توازن بائنری سرچ ٹری کی مختلف حالتوں جیسے AVL درختوں یا سرخ سیاہ کو استعمال کرنا عام ہے۔درختیہ اعداد و شمار کے ڈھانچے اضافے اور حذف کرنے کے دوران مخصوص قواعد کو نافذ کرکے توازن برقرار رکھتے ہیں ، تلاش اور اندراج دونوں کاموں کے ل log لاجارتھمک ٹائم پیچیدگی کی ضمانت دیتے ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "ایک فبونیکی ہیپ ایک ڈیٹا ڈھانچہ ہے جو ترجیحی قطار کو موثر انداز میں نافذ کرنے کے لئے استعمال ہوتا ہے۔یہ بائنری ہیپس یا بائنومیئل ہیپس جیسے ترجیحی قطار کے نفاذ کے مقابلے میں بعض کارروائیوں کے لئے بہتر امورائزڈ ٹائم پیچیدگی فراہم کرتا ہے۔فیبونیکی ہیپ کی کلیدی خصوصیات میں اس کی انضمام کے ڈھیر پراپرٹی اور مستقل وقت کی کارروائیوں جیسے اندراج اور کمی کی صلاحیت شامل ہے۔ یہاں فیبونیکی ہیپ کس طرح کام کرتا ہے اس کا ایک جائزہ: ساخت: ایک فبونیکی ہیپ کا ایک مجموعہ ہے۔درختوں کا حکم دیا۔ڈھیر میں ہر درخت کم سے کم پراپرٹی کی پیروی کرتا ہے ، جہاں ہر نوڈ کی کلید اس کے والدین کی کلید سے زیادہ یا اس کے برابر ہوتی ہے۔درختوں کی کوئی شکل ہوسکتی ہے ، اور ڈھیر کی نمائندگی خود ہی جڑ کے نوڈس کی دوگنا سے منسلک فہرست کے ذریعہ کی جاتی ہے۔اس کے بعد اس درخت کو جڑ کی فہرست میں شامل کیا جاتا ہے۔اندراج کے عمل میں O (1) کی مستقل وقت کی پیچیدگی ہوتی ہے کیونکہ کسی ضم یا تنظیم نو کی ضرورت نہیں ہوتی ہے۔اگر ضروری ہو تو کم سے کم نوڈ کو اپ ڈیٹ کیا جاتا ہے۔اس آپریشن میں O (1) کی مستقل وقت کی پیچیدگی بھی ہے۔ کم سے کم: کم سے کم آپریشن فبونیکی ہیپ میں سب سے چھوٹی کلید کے ساتھ عنصر کو لوٹاتا ہے۔یہ براہ راست کم سے کم نوڈ تک رسائی حاصل کرکے کیا جاسکتا ہے ، جو ڈھیر کے ڈیٹا ڈھانچے میں محفوظ ہے۔اس آپریشن میں O (1) کی مستقل وقت کی پیچیدگی ہے۔ کم سے کم ایکسٹریکٹ: نچوڑ کم سے کم آپریشن ڈھیر سے کم سے کم نوڈ کو ہٹا دیتا ہے اور ڈھیر کی پراپرٹی کو برقرار رکھنے کے لئے باقی درختوں کو مستحکم کرتا ہے۔استحکام کے دوران ، ایک ہی ڈگری (بچوں کی تعداد) کے درخت اس وقت تک ضم ہوجاتے ہیں جب تک کہ ایک ہی ڈگری کے ساتھ دو درخت نہ ہوں۔اس آپریشن میں O (لاگ این) کی وقت کی پیچیدگی ہے ، جہاں فبونیکی ہیپ میں نوڈس کی تعداد ہے۔ ڈیکریز کلید: کلیدی آپریشن میں کمی سے فبونیکی ہیپ میں نوڈ کی کلید میں کمی واقع ہوتی ہے۔اگر کمی کی کلید کم سے کم پراپرٹی کی خلاف ورزی کرتی ہے تو ، نوڈ اس کے والدین سے کاٹ کر روٹ لسٹ میں شامل کیا جاتا ہے۔مزید برآں ، اگر نوڈ کے والدین کے پاس پہلے ہی کسی بچے کو کاٹا گیا تھا تو ، اسے کاٹ کر جڑ کی فہرست میں بھی منتقل کردیا جاتا ہے۔اس آپریشن میں O (1) کی ایک متناسب وقت کی پیچیدگی ہے .مورٹائزڈ ٹائم پیچیدگی: فبونیکی ڈھیر میں زیادہ تر آپریشنوں کی امورائزڈ ٹائم پیچیدگی ممکنہ فنکشن تجزیہ کی وجہ سے مستقل یا قریب ہے۔اگرچہ انفرادی آپریشن جیسے کم سے کم اور کمی کی کلید میں O (لاگ این) کی بدترین وقت کی پیچیدگیاں ہوسکتی ہیں ، لیکن امورائزڈ تجزیہ اس بات کو یقینی بناتا ہے کہ فی آپریشن اوسط لاگت نمایاں طور پر کم ہے۔ فبوناکی ہیپس خاص طور پر ایسی صورتحال میں مفید ہیں جہاں ترجیحی قطار میں بار بار ضرورت ہوتی ہے۔کم سے کم کم سے کم آپریشن کے ساتھ ، اضافے ، یونینوں اور کلیدی کارروائیوں کو کم کرنا۔وہ منظرناموں میں دیگر ترجیحی قطار کے اعداد و شمار کے ڈھانچے کے مقابلے میں بہتر کارکردگی پیش کرتے ہیں جہاں یہ مخصوص کاروائیاں کام کے بوجھ پر حاوی ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "ایک خود توازن بائنری سرچ ٹری (بی ایس ٹی) ایک بائنری سرچ ٹری ہے جو موثر تلاش ، اندراج ، اور حذف کرنے کی کارروائیوں کو یقینی بنانے کے ل intrats داخلوں اور حذف ہونے کے دوران خود بخود متوازن ڈھانچے کو برقرار رکھتی ہے۔توازن کا طریقہ کار درختوں کے نوڈس کو غیر متوازن ڈھانچے میں انحطاط کو روکنے کے لئے دوبارہ تقسیم کرتا ہے ، جو غیر موثر کارروائیوں کا باعث بن سکتا ہے۔ عام طور پر استعمال ہونے والے خود توازن والے بی ایس ٹی میں شامل ہیں: اے وی ایل کا درخت: ایک اے وی ایل کا درخت اونچائی سے متوازن بائنری تلاش کا درخت ہے ، جہاں اونچائی ہے ، جہاں اونچائی ہے۔کسی بھی نوڈ کے بائیں اور دائیں سبٹیز زیادہ سے زیادہ 1 سے مختلف ہیں۔ AVL درخت اونچائی کے توازن کو برقرار رکھنے کے ل rents اضافے اور حذفوں کے دوران گردشیں انجام دے کر اس توازن کو حاصل کرتے ہیں۔یہ تلاش ، اندراج ، اور حذف کرنے کے کاموں کے لئے O (لاگ این) کی بدترین وقت کی پیچیدگی کو یقینی بناتا ہے۔یہ اس بات کو یقینی بناتا ہے کہ سیاہ نوڈس کے مابین توازن برقرار رکھنے اور اضافی خصوصیات کو نافذ کرنے کے ذریعہ درخت متوازن رہتا ہے ، جیسے ملحقہ سرخ نوڈس۔توازن برقرار رکھنے کے ل red اندراجات اور حذف کرنے کے دوران سرخ سیاہ درخت رنگین پلٹیں اور گردش کا استعمال کرتے ہیں۔سرخ رنگ کے درخت تلاش ، اندراج ، اور حذف کرنے کے کاموں کے لئے O (لاگ این) کی بدترین وقت کی پیچیدگی فراہم کرتے ہیں۔جب نوڈ تک رسائی حاصل کی جاتی ہے تو ، اسے درخت کی جڑ میں منتقل کردیا جاتا ہے ، جو قریبی نوڈس تک کے بعد تک رسائی کو بہتر بناتا ہے۔چھڑکنے والے درخت سخت توازن برقرار نہیں رکھتے ہیں بلکہ اس کے بجائے اکثر نوڈس تک رسائی حاصل کرتے ہیں۔وہ کثرت سے رسائی والے عناصر کے ل good اچھ ma ا وقت کی پیچیدگی فراہم کرتے ہیں۔ خود توازن بی ایس ٹی مختلف منظرناموں میں مفید ہیں ، بشمول: آرڈرڈ ڈیٹا: خود توازن بی ایس ٹی موثر ہوتا ہے جب آپ کو ترتیب شدہ ترتیب میں ڈیٹا اسٹور اور بازیافت کرنے کی ضرورت ہوتی ہے۔وہ غیر متوازن بی ایس ٹی کے مقابلے میں تیز تر تلاش ، اندراج اور حذف کرنے کی کارروائیوں کو فراہم کرتے ہیں ، خاص طور پر بڑے ڈیٹاسیٹس کے لئے۔ ڈائنیمک ڈیٹا: جب اعداد و شمار کو اکثر اضافے اور حذف کرنے کے ساتھ اپ ڈیٹ کیا جاتا ہے تو ، خود توازن بی ایس ٹی اس بات کو یقینی بناتا ہے کہ درخت متوازن رہتا ہے ، انحطاط کو روکتا ہے اور موثر برقرار رہتا ہے۔کارکردگی.ایفینٹ آپریشنز: جب آپ کو متوازن ڈھانچے کی ضمانت کے ساتھ موثر تلاش ، اندراج ، اور حذف کرنے کی کارروائیوں کی ضرورت ہوتی ہے تو خود توازن بی ایس ٹی قیمتی ہوتا ہے۔وہ ان کارروائیوں کے لئے ایک متوقع بدترین صورتحال کا وقت کی پیچیدگی فراہم کرتے ہیں ، جو کارکردگی میں مستقل مزاجی کو یقینی بناتے ہیں۔ ہیش ٹیبلز کے لئے مستقل مزاجی: کچھ معاملات میں ، خود توازن رکھنے والے بی ایس ٹی ہیش ٹیبلز کے متبادل کے طور پر کام کرسکتے ہیں جب عناصر کا آرڈر دینے کا حکم ضروری ہے۔وہ ترتیب دیئے گئے آرڈر کو برقرار رکھنے کے اضافی فائدہ کے ساتھ اسی طرح کی تلاش اور اندراج کے وقت کی پیچیدگی فراہم کرتے ہیں۔ تاہم ، یہ نوٹ کرنا ضروری ہے کہ خود توازن رکھنے والے بی ایس ٹی میموری کے استعمال کے لحاظ سے اضافی اوور ہیڈ کے ساتھ آتے ہیں اور سیدھے اعداد و شمار کے ڈھانچے کے مقابلے میں زیادہ پیچیدہ نفاذ جیسے سرے یا منسلک ہوتے ہیں۔فہرستیں۔خود توازن بی ایس ٹی کے استعمال کا انتخاب آپ کی درخواست کی مخصوص ضروریات پر منحصر ہے ، جیسے اعداد و شمار کی نوعیت ، متوقع کام کا بوجھ ، اور وقت کی پیچیدگی اور خلائی پیچیدگی کے مابین تجارت سے متعلق عوامل پر غور کریں۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": "کوئکسورٹ ایک مشہور چھانٹ رہا الگورتھم ہے جو تقسیم اور فتح کرنے والے نقطہ نظر کی پیروی کرتا ہے۔یہ محور عنصر کا انتخاب ، محور کے ارد گرد صف کو تقسیم کرکے ، اور محور کے دونوں طرف سبریوں کو بار بار ترتیب دے کر کام کرتا ہے۔یہاں کوئیکسٹورٹ الگورتھم کو نافذ کرنے کے طریقوں کی ایک قدم بہ قدم وضاحت ہے: تقسیم: صف سے محور عنصر کا انتخاب کریں۔محور کا انتخاب الگورتھم کی کارکردگی کو متاثر کرسکتا ہے ، اور محور کے انتخاب کے لئے مختلف حکمت عملی موجود ہے (جیسے ، پہلا ، آخری ، یا درمیانی عنصر کا انتخاب کرنا ، یا بے ترتیب نقطہ نظر کا استعمال کرتے ہوئے)۔اس کے بائیں طرف ، اور محور سے زیادہ تمام عناصر اس کے دائیں طرف رکھے جاتے ہیں۔محور خود اس کی آخری ترتیب شدہ پوزیشن میں ہوگا۔اسے تقسیم کرنے والے مرحلے کے نام سے جانا جاتا ہے۔ ریفرنسیشن: محور کے بائیں طرف (چھوٹے عناصر پر مشتمل) اور محور کے دائیں طرف کے سبری (بڑے عناصر پر مشتمل) کے سب اریے پر مذکورہ بالا تقسیم کے عمل کو متنازعہ طور پر لاگو کریں۔سبری خالی ہوجاتے ہیں یا صرف ایک عنصر پر مشتمل ہوتے ہیں ، کیونکہ سنگل عنصر کی صفوں کو پہلے ہی ترتیب دیا جاتا ہے۔ یہاں ازگر میں کوئکسورٹ الگورتھم کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف کوئیکسورٹ (اے آر آر ، کم ، اعلی): اگر کم <اعلی: # تقسیم سرنیPIVOT_INDEX = تقسیم (ARR ، کم ، اونچائی) # بار بار subarrays کوئکسورٹ (ARR ، LOW ، PIVOT_INDEX - 1) کو ترتیب دیں # بائیں subarray Quicksort (ARR ، PIVOT_INDEX + 1 ، اعلی) کو ترتیب دیں۔): # محور کو منتخب کریں (یہاں ، ہم دائیں عنصر کا انتخاب کرتے ہیں) محور = آر اے آر [اعلی] # چھوٹے عنصر کا انڈیکس I = کم - 1 کے لئے رینج (کم ، اعلی): # اگر موجودہ عنصر OR سے چھوٹا ہے یامحور کے برابر اگر err [j] <= محور: # تبادلہ عناصر i = i + 1 arr [i] ، arr [j] = arr [j] ، arr [i] # محور عنصر کو اپنی ترتیب شدہ پوزیشن میں منتقل کریں۔] کوئکسٹورٹ (اے آر آر ، 0 ، لین (اے آر آر) - 1) پرنٹ (اے آر آر) # آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] کوئکسٹورٹ الگورتھم کی وقت کی پیچیدگی O ہے (n لاگ این) اوسطا ، جہاں ن سرے میں عناصر کی تعداد ہے۔تاہم ، بدترین صورتحال میں (جیسے ، جب صف پہلے ہی ترتیب دی گئی ہے یا اس میں مساوی عناصر شامل ہیں) ، وقت کی پیچیدگی O (n^2) تک کم ہوسکتی ہے۔محور کی حکمت عملی اور بے ترتیب جیسے تکنیک کا انتخاب بدترین صورتحال کے واقعات کو کم کرنے اور الگورتھم کی کارکردگی کو بہتر بنانے کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "ایک گراف ایک ڈیٹا ڈھانچہ ہوتا ہے جو باہم مربوط نوڈس کے ذخیرے کی نمائندگی کرنے کے لئے استعمال ہوتا ہے ، جہاں نوڈس کو عمودی کہا جاتا ہے ، اور ان کے مابین رابطوں کو کناروں کہتے ہیں۔گراف کو وسیع پیمانے پر اشیاء ، اداروں ، یا تصورات کے مابین تعلقات کو ماڈل کرنے کے لئے استعمال کیا جاتا ہے۔ گراف کی متعدد اقسام ہیں ، جن میں شامل ہیں: غیر ہدایت شدہ گراف: غیر ہدایت شدہ گراف میں ، کناروں کی کوئی سمت نہیں ہے۔دو عمودیوں کے مابین رابطہ توازن ہے ، اس کا مطلب یہ ہے کہ اگر ورٹیکس اے سے لے کر ورٹیکس بی تک کا ایک کنارے موجود ہے تو ، ورٹیکس بی سے لے کر ورٹیکس اے ڈائریکٹڈ گراف (ڈیگراف) تک بھی ایک کنارے موجود ہیں: ہدایت شدہ گراف میں ، کناروں میں ایک سمت ہوتی ہے۔کناروں ایک طرفہ (ماخذ) سے دوسرے ورٹیکس (منزل) سے یکطرفہ رابطے ہیں۔کناروں کی نمائندگی تیر کے ذریعہ کی جاتی ہے ، جس سے کنکشن کی سمت کی نشاندہی ہوتی ہے۔ ویٹ گراف: وزن والے گراف میں ، ہر کنارے کو ایک وزن یا قیمت تفویض کی جاتی ہے جو دو عمودی کے مابین رابطے سے وابستہ کچھ قیمت کی نمائندگی کرتی ہے۔وزن والے گرافوں کا استعمال منظرنامے کے ماڈل کے لئے کیا جاتا ہے جہاں کناروں کے مختلف اخراجات یا فاصلے ہوتے ہیں۔ سائکلک گراف: ایک چکولک گراف میں کم از کم ایک سائیکل ہوتا ہے ، جو ایک ایسا راستہ ہے جو اسی طرح سے شروع ہوتا ہے اور ختم ہوتا ہے۔چکرک گراف میں دہرائے ہوئے عمودی اور کناروں میں ہوسکتا ہے ۔اسیکلک گراف: ایکائیکلک گراف ایک ایسا گراف ہے جس میں کوئی سائیکل نہیں ہوتا ہے۔اسے ہدایت شدہ ایسائکلک گراف (ڈی اے جی) کے نام سے بھی جانا جاتا ہے۔ایسائکلک گراف اکثر ایسے منظرناموں میں استعمال ہوتے ہیں جہاں انحصار یا ترجیحی تعلقات کو ماڈلنگ کرنے کی ضرورت ہوتی ہے۔ منسلک گراف: ایک منسلک گراف وہ ہوتا ہے جس میں ہر جوڑے کے جوڑے کے درمیان راستہ ہوتا ہے۔دوسرے لفظوں میں ، ہر حد تک کناروں کے تسلسل کے ذریعے ہر دوسرے حصے سے قابل رسائ ہوتا ہے۔ متناسب گراف: منقطع گراف میں متعدد منسلک اجزاء پر مشتمل ہوتا ہے ، جہاں ہر جزو ایک سبگراف ہوتا ہے جو خود ہی جڑا ہوتا ہے۔مختلف اجزاء میں عمودی کے درمیان کوئی راستہ نہیں ہے۔ بائپارٹائٹ گراف: ایک دو طرفہ گراف ایک ایسا گراف ہے جس کے عمودی کو دو ناگوار سیٹوں میں تقسیم کیا جاسکتا ہے ، جیسے کہ تمام کناروں کو ایک سیٹ سے دوسرے سیٹ سے جوڑتے ہیں۔دوسرے لفظوں میں ، یہاں کوئی کناروں نہیں ہیں جو ایک ہی سیٹ کے اندر عمودی کو جوڑتے ہیں۔ یہ گراف کی اقسام کی صرف چند مثالیں ہیں ، اور مختلف ڈومینز اور ایپلی کیشنز میں استعمال ہونے والے گراف کی بہت سی دوسری خصوصی اقسام اور مختلف حالتیں ہیں۔گراف مختلف الگورتھم اور مسئلے کو حل کرنے کی تکنیکوں میں استعمال ہونے والے بنیادی اعداد و شمار کے ڈھانچے ہیں ، جیسے گراف ٹراورسل ، مختصر ترین راستہ الگورتھم ، نیٹ ورک فلو الگورتھم ، اور بہت کچھ۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر کے درمیان بنیادی فرق عناصر اور ان پراپرٹیز کی ترتیب میں مضمر ہے جو ان کی برقرار رکھتے ہیں: من ڈھیر: ایک منٹ کے ڈھیر میں ، کسی بھی نوڈ کے لئے ، اس نوڈ کی قدر اقدار سے کم یا اس کے برابر ہے۔اس کے بچے۔دوسرے لفظوں میں ، کم سے کم قیمت ہمیشہ ڈھیر کی جڑ میں رہتی ہے۔یہ پراپرٹی اس بات کو یقینی بناتی ہے کہ کم سے کم عنصر کو ڈھیر سے موثر طریقے سے بازیافت کیا جاسکتا ہے۔ میکس ہیپ: ایک زیادہ سے زیادہ ڈھیر میں ، کسی بھی نوڈ کے لئے ، اس نوڈ کی قدر اس کے بچوں کی اقدار سے زیادہ یا اس کے برابر ہے۔اس کے نتیجے میں ، زیادہ سے زیادہ قیمت ہمیشہ ڈھیر کی جڑ میں رہتی ہے۔یہ پراپرٹی ڈھیر سے زیادہ سے زیادہ عنصر کی موثر بازیافت کی اجازت دیتی ہے۔ دو منٹ کے ڈھیر اور زیادہ سے زیادہ ہیپس مکمل بائنری درخت ہیں ، اس کا مطلب یہ ہے کہ درخت کی تمام سطحیں ممکنہ طور پر آخری سطح کے سوا بھری ہوئی ہیں ، جو بائیں سے دائیں تک بھرا ہوا ہے۔ڈھیر میں عناصر کا حکم دینا ، چاہے کم سے کم ہو یا زیادہ سے زیادہ ، ڈھیر پراپرٹی کے ذریعہ طے کیا جاتا ہے ، جو اندراج اور نکالنے کے کاموں کے دوران برقرار رہتا ہے۔ایک منٹ کے ڈھیر میں ، سب سے چھوٹا عنصر ہمیشہ جڑ میں رہتا ہے ، اور زیادہ سے زیادہ ڈھیر میں ، سب سے بڑا عنصر ہمیشہ جڑ میں ہوتا ہے۔ وہ ای اے پی ایس عام طور پر ترجیحی قطار میں استعمال ہوتے ہیں ، جہاں عناصر کو ترجیحات تفویض کی جاتی ہیں اور ان کی بنیاد پر ان تک رسائی حاصل کرنے کی ضرورت ہوتی ہے۔ترجیحی آرڈرمن ڈھیر اکثر ترجیحی قطاروں کو نافذ کرنے کے لئے استعمال کیے جاتے ہیں جہاں سب سے چھوٹی ترجیح والے عنصر کو موثر انداز میں بازیافت کرنے کی ضرورت ہوتی ہے۔اسی طرح ، زیادہ سے زیادہ ڈھیر استعمال کیے جاتے ہیں جب سب سے زیادہ ترجیح والے عنصر کو موثر طریقے سے رسائی حاصل کرنے کی ضرورت ہوتی ہے۔ یہ نوٹ کرنا ضروری ہے کہ \"من ڈھیر\" اور \"میکس ہیپ\" کی اصطلاحات ڈھیر میں عناصر کی ترتیب کا حوالہ دیتے ہیں اور اعداد و شمار کے الگ الگ ڈھانچے نہیں ہیں۔ڈھیر کی بنیادی ڈھانچہ اور کاروائیاں ایک جیسی ہی رہتی ہیں ، قطع نظر اس سے کہ یہ ایک من ڈھیر ہے یا زیادہ سے زیادہ ڈھیر ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "کسی گراف پر گہرائی کی پہلی تلاش (DFS) الگورتھم کو نافذ کرنے کے ل you ، آپ اسٹیک کا استعمال کرتے ہوئے یا کسی تکرار نقطہ نظر کا استعمال کرتے ہوئے کسی تکراری نقطہ نظر کا استعمال کرسکتے ہیں۔یہاں اسٹیک کا استعمال کرتے ہوئے تکراری نقطہ نظر کی ایک قدم بہ قدم وضاحت ہے: نوڈس کو دیکھنے کے لئے ذخیرہ کرنے کے لئے ایک اسٹیک بنائیں۔اس کو شروع کرنے والے نوڈ کے ساتھ شروع کریں۔ ملاحظہ کرنے والے نوڈس کا ٹریک رکھنے کے لئے ایک سیٹ یا صف تیار کریں۔ جب اسٹیک خالی نہیں ہے: اسٹیک سے ایک نوڈ پاپ کریں۔ چیک کریں اگر نوڈ پہلے ہی ملاحظہ کیا گیا ہے۔اگر ایسا ہے تو ، اگلے تکرار کو جاری رکھیں۔ نوڈ کو ملاحظہ کریں اور اس پر کارروائی کریں۔ موجودہ نوڈ کے ملحقہ تمام نوڈس کو گیٹ کریں جن کا دورہ نہیں کیا گیا ہے اور انہیں اسٹیک پر دھکیلیں۔ازگر میں تکراری نقطہ نظر کا استعمال کرتے ہوئے ڈی ایف ایس الگورتھم کا ایک مثال عمل: پائیتھون کوپی کوڈیڈف ڈی ایف ایس (گراف ، اسٹارٹ_نوڈ): اسٹیک = [اسٹارٹ_نوڈ] ملاحظہ کریں = سیٹ () جبکہ اسٹیک: کرنٹ_نوڈ = اسٹیک.پوپ () اگر موجودہ_ نوڈ میں ملاحظہ کریں: جاری رکھیں۔.add (موجودہ_نوڈ) پرنٹ (کرنٹ_نوڈ) # پروسیس کریں موجودہ نوڈ # موجودہ نوڈ کے تمام ملحقہ نوڈس حاصل کریں اور انہیں گراف میں پڑوسی کے لئے اسٹیک پر دھکیلیں [موجودہ_نوڈ]مثال کے طور پر استعمال: گراف = {'a': ['b' ، 'c'] ، 'b': ['d' ، 'e'] ، 'c': ['f'] ، 'd': [].لغت میں ہر کلید ایک نوڈ سے مساوی ہے ، اور اس سے وابستہ قیمت ملحقہ نوڈس کی ایک فہرست ہے۔ ڈی ایف ایس الگورتھم دیئے گئے اسٹارٹ_نوڈ سے شروع ہوتا ہے اور بیک ٹریکنگ سے پہلے ہر شاخ کے ساتھ جہاں تک ممکن ہو تلاش کرتا ہے۔یہ دورے کے نوڈس کو اس ترتیب میں پرنٹ کرتا ہے جس کا ان کا سامنا کرنا پڑتا ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ کسی فنکشن کے عمل کو بہتر بنانے کے لئے اس کے نتائج کو بہتر بنائے۔اس میں مہنگے فنکشن کالز کے نتائج کو ذخیرہ کرنا اور جب وہی آدانوں کو دوبارہ ہوتا ہے تو انہیں کیشے سے بازیافت کرنا شامل ہوتا ہے۔یادداشت پہلے کے حساب شدہ نتائج کو دوبارہ استعمال کرکے بے کار کمپیوٹوں کو ختم کرتی ہے ، اس طرح الگورتھم کی مجموعی وقت کی پیچیدگی کو کم کرتی ہے۔یہ افعال کسی مسئلے کو بار بار چھوٹے چھوٹے مضامین میں توڑ کر حل کرتے ہیں۔تاہم ، یادداشت کے بغیر ، ایک ہی ذیلی مسائل کو متعدد بار حل کیا جاسکتا ہے ، جس کی وجہ سے غیر ضروری کمپیوٹوں کا سبب بنتا ہے۔ متحرک پروگرامنگ میں یادداشت کا استعمال کیا جاتا ہے: تکرار کرنے والے فنکشن کی شناخت کریں: ایک تکرار فنکشن کی تلاش کریں جو اوورلیپنگ سب پروبلوبلز کی پراپرٹی کو ظاہر کرتا ہے ، جہاں ایک ہی ذیلی پروبلیس کو ظاہر کرتا ہے۔متعدد بار حل کیے جاتے ہیں۔ ایک کیشے کو تیار کریں: اعداد و شمار کے ڈھانچے کو شروع کریں ، جیسے سرنی یا ہیش ٹیبل ، پہلے کمپیوٹڈ نتائج کو ذخیرہ کرنے کے لئے کیشے کے طور پر کام کریں۔کیشے کو ان پٹ (یا آدانوں کا مجموعہ) ان کے متعلقہ آؤٹ پٹ پر نقشہ بنانے کے قابل ہونا چاہئے۔ فنکشن کو تبدیل کریں: پہلے چیک کرنے کے لئے تکرار کرنے والی تقریب میں ترمیم کریں کہ آیا دیئے گئے ان پٹ کا نتیجہ پہلے ہی کیشے میں موجود ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، کیشڈ نتیجہ کو دوبارہ تشکیل دینے کے بجائے واپس کردیں۔اگر نتیجہ کیشے میں نہیں ہے تو ، اسے معمول کے مطابق حساب کریں اور اسے واپس کرنے سے پہلے کیشے میں اسٹور کریں۔ نتائج کو یاد کرتے ہوئے ، اسی آدانوں کے ساتھ تکرار کرنے والی تقریب میں آنے والی کالوں کو مستقل وقت میں حل کیا جاسکتا ہے ، کیونکہ نتیجہ پہلے ہی موجود ہے۔کیشے میں دستیاب ہے۔یہ بے کار حساب سے گریز کرتا ہے اور الگورتھم کی مجموعی کارکردگی کو نمایاں طور پر بہتر بناتا ہے۔ یہاں ازگر میں ایک سادہ مثال ہے جو ایک بار بار چلنے والی فبونیکی فنکشن کا استعمال کرتے ہوئے یادداشت کا مظاہرہ کرتی ہے: پائیتھونکپی کوڈ# کیچڈف فبونیکی (این ، کیشے = {{}) کے ساتھ میمورائزیشن کا استعمال کرتے ہوئے: اگر این میں این ، کیشے = {})کیشے: واپس کیشے [n] اگر n <= 1: نتیجہ = n else: نتیجہ = fibonacci (n - 1) + fibonacci (n - 2) کیشے [n] = نتیجہ کی واپسی کا نتیجہ# مثال کے طور پر استعمال کے نشان (fibonacci (5))# آؤٹ پٹ: 5 پرنٹ (فبوناکی (10)) # آؤٹ پٹ: 555 اس مثال کے طور پر ، فبونیکی فنکشن کیش لغت میں کمپیوٹڈ فبونیکی نمبروں کو ذخیرہ کرنے کے لئے میموائزیشن کا استعمال کرتا ہے۔اس کے بعد کی کالوں پر ، اگر دیئے گئے انڈیکس کے لئے فبونیکی نمبر پہلے ہی کیشے میں موجود ہے تو ، اسے براہ راست بازیافت کیا جاتا ہے ، جس سے بے کار کمپیوٹیشن کی ضرورت کو ختم کیا جاتا ہے۔ فبونیکی نمبروں کو یاد کرتے ہوئے ، فنکشن کی وقت کی پیچیدگی کو کفایت شعاری سے کم کیا جاتا ہے (O (O (O (O (2^n)) لکیری (O (n))۔ان پٹ ویلیو ن میں اضافے کے ساتھ ہی یہ بہتری زیادہ اہم ہوجاتی ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "ڈجکسٹرا کا الگورتھم ایک مقبول الگورتھم ہے جو غیر منفی کنارے کے وزن والے گراف میں نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتا ہے۔یہ ہدایت اور غیر ہدایت شدہ دونوں گرافوں پر کام کرتا ہے اور گراف کے دوسرے تمام نوڈس تک ایک ہی ماخذ نوڈ سے کم ترین راستہ تیار کرتا ہے۔ الگورتھم ہر نوڈ کے لئے \"غیر منحصر\" نوڈس اور \"فاصلے\" کی قیمت کا ایک سیٹ برقرار رکھتا ہے ، ابتدائی طور پر انفینٹی پر سیٹ کیا جاتا ہے۔سوائے سورس نوڈ کے جو 0 پر سیٹ کیا گیا ہے۔یہ عمل اس وقت تک جاری ہے جب تک کہ تمام نوڈس کا دورہ نہ کیا جائے یا منزل کا نوڈ پہنچا نہ جائے۔ یہاں ڈجکسٹرا کے الگورتھم کی ایک قدم بہ قدم وضاحت: گراف کو شروع کریں اور ماخذ نوڈ کا فاصلہ 0 اور دیگر تمام نوڈس کو انفینٹی پر سیٹ کریں۔ایک ترجیحی قطار (جو اکثر ایک من ڈھیر کے طور پر نافذ کی جاتی ہے) نوڈس کو ان کے فاصلوں کی بنیاد پر ذخیرہ کرنے کے لئے۔ماخذ نوڈ کو ترجیحی قطار میں داخل کریں۔ جب ترجیحی قطار خالی نہیں ہے: ترجیحی قطار سے کم سے کم فاصلے کے ساتھ نوڈ نکالیں۔یہ نوڈ \"موجودہ\" نوڈ ہے۔ موجودہ نوڈ کو دیکھیں۔نیا فاصلہ پڑوسی کے موجودہ فاصلے سے کم ہے ، پڑوسی کے فاصلے کو اپ ڈیٹ کریں۔ اگر ہمسایہ غیر منحصر ہے تو ، اسے ترجیحی قطار میں داخل کریں۔ ایک بار منزل نوڈ کا دورہ کیا گیا ہے یا ترجیحی قطار خالی ہے ، الگورتھم ختم ہوجاتا ہے۔الگورتھم کے دوران حساب کی جانے والی دوری گراف میں ماخذ نوڈ سے دوسرے تمام نوڈس تک مختصر ترین راستوں کی نمائندگی کرتی ہے۔ ڈیجکسٹرا کا الگورتھم اس بات کی ضمانت دیتا ہے کہ جب الگورتھم ختم ہوجاتا ہے تو منبع نوڈ سے کسی دوسرے نوڈ تک کا مختصر ترین راستہ پایا جاتا ہے۔تاہم ، یہ غیر منفی کنارے کے وزن کو فرض کرتا ہے اور گراف میں منفی چکروں کو نہیں سنبھالتا ہے۔ ڈیجکسٹرا کا الگورتھم مختلف ایپلی کیشنز میں وسیع پیمانے پر استعمال ہوتا ہے جیسے نیٹ ورک روٹنگ پروٹوکول ، جی پی ایس نیویگیشن سسٹم ، اور ٹرانسپورٹیشن نیٹ ورکس میں مختصر ترین راستے کی پریشانیوں کو حل کرنا ، دوسروں کے درمیان۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں متضاد تکرار کو کس طرح سنبھالتے ہیں؟ویو آف لوپ کے استعمال کی وضاحت کریں۔",
        "Answer": ""
    },
    {
        "Question": "جاوا اسکرپٹ میں مختلف قسم کی غلطیاں کیا ہیں؟عام غلطی کی اقسام کی مثالیں فراہم کریں۔",
        "Answer": "ایک ریڈکس درخت ، جسے ٹری یا پریفکس ٹری بھی کہا جاتا ہے ، ایک خاص درخت کے اعداد و شمار کا ڈھانچہ ہے جو موثر اسٹوریج اور تاروں کی بازیافت کے لئے استعمال ہوتا ہے۔یہ خاص طور پر لغت کے نفاذ ، آٹومپلیٹ سسٹم ، اور آئی پی روٹنگ ٹیبلز جیسے ایپلی کیشنز کے لئے مفید ہے۔ ریڈکس ٹری اپنے کرداروں کے ذریعہ تاروں کا اہتمام کرتا ہے ، جس میں ہر نوڈ ایک سابقہ یا مکمل تار کی نمائندگی کرتا ہے۔یہاں ایک جائزہ ہے کہ ایک ریڈکس ٹری کس طرح کام کرتا ہے: نوڈ ڈھانچہ: ریڈکس ٹری میں ہر نوڈ میں کئی اجزاء ہوتے ہیں: کلیدی/کردار: نوڈ سے وابستہ کردار۔مثال کے طور پر ، لغت کے نفاذ میں ، ہر کردار کسی لفظ میں ایک خط کی نمائندگی کرتا ہے۔ بچوں: بچوں کے نوڈس کے اشارے یا حوالہ۔ہر بچہ ایک ممکنہ کردار سے مطابقت رکھتا ہے جو لفظ مارکر کے موجودہ نوڈ کی پیروی کرسکتا ہے: ایک جھنڈا جس سے یہ ظاہر ہوتا ہے کہ آیا نوڈ ایک مکمل لفظ کے اختتام کی نمائندگی کرتا ہے۔ ریڈکس ٹری کی تعمیر: ریڈکس کا درخت ابتدائی طور پر خالی ہے ، جس میں صرف ایک جڑ نوڈ ہے۔چونکہ درخت میں ڈور ڈالے جاتے ہیں ، حروف کو بائیں سے دائیں تک عبور کیا جاتا ہے۔ داخلہ آپریشن: ریڈکس ٹری میں ایک تار داخل کرنا: جڑ نوڈ پر شروع کریں۔ چیک کریں اگر موجودہ کردار موجودہ نوڈ کے بچے کی طرح موجود ہے۔کیا ، متعلقہ بچے کی طرف بڑھیں اور اگلے کردار کی طرف بڑھیں۔ اگر ایسا نہیں ہوتا ہے تو ، موجودہ کردار کے لئے ایک نیا چائلڈ نوڈ بنائیں اور اس بچے کی طرف بڑھیں۔ اس عمل کو اس وقت تک جاری رکھیں جب تک کہ تار کے تمام کرداروں پر کارروائی نہیں کی جاتی ہے۔حتمی نوڈ کسی لفظ کے اختتام کے طور پر۔ سرچ آپریشن: ریڈکس ٹری میں تار تلاش کرنے کے لئے: روٹ نوڈ پر شروع کریں۔ ہدف کے تار میں ہر کردار کے لئے ، چیک کریں کہ آیا کوئی بچہ نوڈ موجود ہے یا نہیں۔، اس بچے کی طرف بڑھیں اور اگلے کردار کی طرف بڑھیں۔ اگر کسی بچے کا نوڈ موجود نہیں ہے تو ، اسٹرنگ ریڈکس ٹری میں موجود نہیں ہے۔ تمام حروف پر کارروائی کرنے کے بعد ، چیک کریں کہ آیا حتمی نوڈ کو کسی لفظ کے اختتام کے طور پر نشان زد کیا گیا ہے۔اگر یہ ہے تو ، تار مل جاتا ہے۔بصورت دیگر ، یہ موجود نہیں ہے۔ ریڈکس ٹری موثر اسٹوریج اور تاروں کی بازیافت فراہم کرتا ہے جو مختلف تاروں میں عام سابقوں کو مؤثر طریقے سے بانٹ کر تاروں کی بازیافت کرتا ہے۔اس سے تار کو ذخیرہ کرنے کے لئے درکار مجموعی جگہ کو کم کیا جاتا ہے اور تلاش کی کارکردگی کو بہتر بنایا جاتا ہے۔ ریڈکس کے درخت میں آپریشن کی وقت کی پیچیدگی ، جیسے اندراج اور تلاش ، تاروں کی لمبائی پر منحصر ہے۔بہترین صورتحال میں ، جہاں ڈوروں کے مابین کوئی مشترکہ سابقہ نہیں ہوتا ہے ، وقت کی پیچیدگی O (M) ہوتی ہے ، جہاں ایم ہدف کے تار کی لمبائی ہوتی ہے۔تاہم ، بدترین صورتحال میں ، جہاں تمام ڈوروں کا ایک ہی سابقہ ہوتا ہے ، وقت کی پیچیدگی O (n) ہوسکتی ہے ، جہاں N تمام تار میں حروف کی کل تعداد ہے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں یادداشت کے تصور کی وضاحت کریں اور یہ کہ فنکشن پر عمل درآمد کو بہتر بنانے کے لئے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "بی ٹری ایک خود توازن رکھنے والا درخت ڈیٹا ڈھانچہ ہے جو ڈسک پر یا ثانوی اسٹوریج میں بڑی مقدار میں ڈیٹا کو موثر انداز میں اسٹور کرنے اور بازیافت کرنے کے لئے ڈیزائن کیا گیا ہے۔یہ سست رسائی کے اوقات کے ساتھ نظاموں کے ل optim بہتر ہے ، جیسے ہارڈ ڈرائیوز ، جہاں کم سے کم ڈسک ریڈز کارکردگی کے لئے بہت ضروری ہے۔ایک بی ٹری بائنری سرچ ٹری (بی ایس ٹی) سے کئی طریقوں سے مختلف ہے: نوڈ ڈھانچہ: بائنری سرچ ٹری میں ، ہر نوڈ میں عام طور پر ایک ہی کلید اور دو بچوں کے پوائنٹر ہوتے ہیں ، جو بائیں اور دائیں سبٹریز کی نمائندگی کرتے ہیں۔اس کے برعکس ، بی ٹری نوڈ میں متعدد چابیاں اور بچوں کے پوائنٹرز شامل ہوسکتے ہیں۔نوڈ میں چابیاں کی تعداد ایک خاص حد کے اندر ہے ، جس کا تعین بی ٹری کے حکم سے ہوتا ہے۔بی ٹری کا ترتیب نوڈ میں اجازت دی گئی کم سے کم اور زیادہ سے زیادہ چابیاں کا تعین کرتا ہے۔آرڈر ایم کے ایک بی ٹری میں نوڈ میں زیادہ تر M-1 کیز اور ایم چائلڈ پوائنٹرز ہوسکتے ہیں ، سوائے جڑ کے نوڈ کے ، جس میں کم از کم 1 کلید ہے۔ توازن اور اونچائی: بائنری تلاش کے درخت کے برعکس ، جہاں توازن ہےبائیں اور دائیں سبٹریز میں نوڈس کی تقریبا برابر تعداد کو برقرار رکھتے ہوئے حاصل کیا گیا ، ایک بی ٹری ایک ہی سطح پر پتے کے تمام نوڈس کو رکھ کر توازن حاصل کرتا ہے۔یہ متوازن ڈھانچہ اس بات کو یقینی بناتا ہے کہ درخت کی اونچائی چابیاں کی تعداد کے مقابلے میں نسبتا small چھوٹی رہتی ہے ، جس کی وجہ سے ڈسک تک رسائی حاصل ہوتی ہے۔ تلاش اور داخلہ: بائنری سرچ ٹری میں ، تلاش اور اندراج کی کارروائیوں پر مبنی ایک سخت بائیں دائیں موازنہ کی پیروی کی جاتی ہے۔کلیدی اقدار۔بی ٹری میں ، کلیدی حدود کی بنیاد پر چائلڈ پوائنٹرز کے بعد ، تلاش اور اندراج کے کاموں میں درخت کو نیچے کی طرف جانا شامل ہوتا ہے۔اس سے موثر ڈسک تک رسائی حاصل کرنے کی اجازت ملتی ہے اور مطلوبہ موازنہ کی تعداد کو کم کیا جاتا ہے۔ ڈسک رسائی کی اصلاح: بی ٹری خاص طور پر موثر ڈسک تک رسائی کے ل designed تیار کی گئی ہیں۔ان کا مقصد ڈیٹا تک رسائی یا اس میں ترمیم کرنے کے لئے درکار ڈسک ریڈز کی تعداد کو کم سے کم کرنا ہے۔فی نوڈ کی چابیاں کی تعداد میں اضافہ کرکے ، بی ٹری درخت کی اونچائی کو کم کرتے ہیں ، جس کے نتیجے میں اعداد و شمار تک رسائی یا اس میں ترمیم کرتے وقت کم سطح گزر جاتی ہے۔ درخواستیں: بی ٹری عام طور پر فائل سسٹم ، ڈیٹا بیس اور دیگر اسٹوریج سسٹم میں استعمال ہوتی ہیں جہاںبڑی مقدار میں ڈیٹا کو ڈسک پر ذخیرہ کرنے کی ضرورت ہے۔وہ ایسے منظرناموں کے ل well مناسب ہیں جہاں تیز رسائی اور موثر ڈسک I/O آپریشن ضروری ہیں۔ سب سے زیادہ ، بی ٹری ایک ورسٹائل ڈیٹا ڈھانچہ ہے جو موثر اسٹوریج اور ڈسک پر بڑی مقدار میں ڈیٹا کی بازیافت کی اجازت دیتا ہے۔درخت کی اونچائی کو متوازن کرنے ، ڈسک کے پڑھنے کو کم کرنے ، اور ہر نوڈ کی مختلف قسم کی چابیاں سنبھالنے کی اس کی صلاحیت یہ ڈسک پر مبنی ایپلی کیشنز کے ل an ایک بہترین انتخاب بناتی ہے ، جبکہ بائنری تلاش کے درخت اکثر میموری پر مبنی منظرناموں میں استعمال ہوتے ہیں جہاں تیز کلیدی طور پر مبنی تلاشیبنیادی تشویش ہے۔"
    },
    {
        "Question": "آپ جاوا اسکرپٹ میں کوکیز کو کس طرح سنبھالتے ہیں؟دستاویز کے استعمال کی وضاحت کریں۔ کوکی پراپرٹی اور کوکی ہیرا پھیری کے طریقوں۔",
        "Answer": "ہف مین کوڈنگ ایک لچکدار ڈیٹا کمپریشن الگورتھم ہے جو درخت پر مبنی ڈیٹا ڈھانچہ استعمال کرتا ہے ، جسے ہف مین ٹری کے نام سے جانا جاتا ہے ، ان کی موجودگی کی تعدد کی بنیاد پر حروف کو متغیر لمبائی کے کوڈ تفویض کرنے کے لئے۔یہ عام طور پر فائل کمپریشن اور ڈیٹا ٹرانسمیشن جیسے ایپلی کیشنز میں استعمال ہوتا ہے۔ یہاں ایک قدم بہ قدم وضاحت ہے کہ ہف مین کوڈنگ درختوں پر مبنی ڈیٹا ڈھانچے کا استعمال کرتے ہوئے کس طرح کام کرتی ہے: تعدد تجزیہ: ہف مین کوڈنگ میں پہلا قدم فریکوئینسی تجزیہ کرنا ہے۔ان پٹ ڈیٹا ، جیسے ٹیکسٹ دستاویز یا حروف کی ترتیب۔ہر کردار کی فریکوئنسی گنتی کی جاتی ہے ، اور ایک فریکوینسی ٹیبل تیار کیا جاتا ہے۔ ہف مین درخت کی تعمیر: فریکوینسی ٹیبل سے ہر کردار کو ابتدائی طور پر ایک پتی نوڈ کے طور پر سمجھا جاتا ہے۔ سب سے کم تعدد والے دو نوڈس کو ایک نئے والدین نوڈ میں ملایا جاتا ہے ، جس میں مشترکہ طور پر ایک نئے والدین کے نوڈ میں مل جاتا ہے۔تعدد دو بچوں کے نوڈس کی تعدد کا مجموعہ ہونے کی وجہ سے۔ یہ عمل اس وقت تک دہرایا جاتا ہے جب تک کہ تمام نوڈس کو ایک ہی جڑ کے نوڈ میں جوڑ دیا جاتا ہے ، جس سے ہف مین درخت پیدا ہوتا ہے۔درخت نیچے کی طرح بنایا گیا ہے ، جس میں پتیوں کے قریب کم سے کم کثرت سے حروف ہوتے ہیں اور جڑ کے قریب اکثر حروف۔کسی کردار کو تفویض کردہ بائنری کوڈ کا تعین جڑ سے اس کردار کے پتی نوڈ تک کے راستے سے ہوتا ہے۔ ہر بائیں ٹریورسل بائنری کوڈ میں \"0\" کا اضافہ کرتا ہے ، اور ہر دائیں ٹریورسل میں \"1\" شامل ہوتا ہے۔ اس کے نتیجے میں بائنری کوڈ ہوتے ہیں۔متغیر لمبائی ، زیادہ کثرت سے حروف کو تفویض کردہ مختصر کوڈز کے ساتھ ، ان کے اعلی کمپریشن کی صلاحیت کا فائدہ اٹھاتے ہوئے۔بٹس ، جس میں اصل نمائندگی کے مقابلے میں کم بٹس کی ضرورت ہوتی ہے اگر ہف مین کوڈ کو مناسب طریقے سے ڈیزائن کیا گیا ہو۔ ڈیکمپریشن: اعداد و شمار کو ڈیمپریس کرنے کے لئے ، ہف مین ٹری کو اسی فریکوینسی ٹیبل یا کمپریسڈ ڈیٹا میں محفوظ کردہ معلومات کا استعمال کرتے ہوئے دوبارہ تشکیل دیا جاتا ہے۔ جڑ سے شروع کرنا ،ہر تھوڑا سا ترتیب سے پڑھا جاتا ہے۔جب ایک پتی نوڈ پہنچ جاتا ہے تو ، اس سے متعلقہ کردار آؤٹ پٹ ہوتا ہے ، اور اس عمل میں اس وقت تک جاری رہتا ہے جب تک کہ تمام بٹس پر کارروائی نہ ہو۔ ہف مین کوڈنگ کرنے سے کثرت سے ہونے والے حروف کو مختصر کوڈ تفویض کرکے کمپریشن حاصل ہوتا ہے ، جس کے نتیجے میں زیادہ کمپیکٹ نمائندگی ہوتی ہے۔دوسری طرف ، کبھی کبھار حروف کو طویل کوڈ ملتے ہیں ، جو کوڈز کی سابقہ فری پراپرٹی کو برقرار رکھنے میں مدد کرتا ہے ، اس بات کو یقینی بناتا ہے کہ کوئی کوڈ کسی دوسرے کوڈ کا سابقہ نہیں ہے۔ ہف مین کوڈنگ مختلف ایپلی کیشنز اور کمپریشن الگورتھم میں وسیع پیمانے پر استعمال ہوتا ہے ، جیسے زپفائلوں اور MP3 آڈیو کمپریشن ، معلومات کے کم سے کم نقصان کے ساتھ موثر ڈیٹا کمپریشن حاصل کرنے کے لئے۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں == اور === آپریٹرز کے درمیان کیا فرق ہے؟فرق کو واضح کرنے کے لئے مثالیں فراہم کریں۔",
        "Answer": "ایک ملحقہ میٹرکس دو جہتی میٹرکس کا استعمال کرتے ہوئے گراف کی نمائندگی کرنے کا ایک عام طریقہ ہے۔یہ گراف میں عمودی کے مابین تعلقات کی ایک کمپیکٹ اور موثر نمائندگی فراہم کرتا ہے۔ ایک ملحقہ میٹرکس میں ، میٹرکس کی قطاریں اور کالم گراف کے عمودی کی نمائندگی کرتے ہیں۔میٹرکس کا ہر سیل دو عمودی کے درمیان ایک کنارے کی نمائندگی کرتا ہے۔ہر سیل میں ذخیرہ شدہ قیمت اسی طرح کے عمودی کے درمیان کنارے کی موجودگی یا عدم موجودگی کی نشاندہی کرتی ہے۔ ملحقہ میٹرکس میں کناروں کی موجودگی یا عدم موجودگی کی نمائندگی کرنے کے لئے دو عام نقطہ نظر ہیں: غیر وزن والے گرافوں کے لئے ، بغیر وزن والے گراف کے لئے ، ملحقہ میٹرکس میں ہر سیلبائنری ویلیو (0 یا 1) ہوسکتا ہے۔1 کی قیمت اسی طرح کے عمودی کے مابین ایک کنارے کی موجودگی کی نشاندہی کرتی ہے ، جبکہ 0 کی قیمت نہیں کی نشاندہی کرتی ہے۔ وزن والے گراف: وزن والے گراف کے لئے ، ملحقہ میٹرکس میں ہر سیل میں اسی طرح کے عمودی کے درمیان کنارے سے وابستہ وزن یا لاگت ہوتی ہے۔اگر دو عمودی کے درمیان کوئی کنارے نہیں ہے تو ، اس سے متعلقہ سیل کی نمائندگی کسی خاص قدر جیسے انفینٹی یا سینٹینل ویلیو کے ذریعہ کی جاسکتی ہے۔ ایک مثال کے طور پر کسی ملحقہ میٹرکس کے تصور کو واضح کرنے کے لئے ایک مثال: 4 عمودی کے ساتھ ایک گراف پر غور کریں جس میں A ، B ، C کا لیبل لگا ہوا ہے۔، اور D. اس گراف کے لئے ملحقہ میٹرکس 4x4 میٹرکس ہوگا: CSSCOPY کوڈ A B C DA [0 1 0 1] B [1 0 1 0] C [0 1 0 0] D [1 0 0] D [1 0 0 0]، میٹرکس میں 1 کی قیمت اسی طرح کے عمودی کے مابین ایک کنارے کی موجودگی کی نشاندہی کرتی ہے ، جبکہ 0 کی قیمت کسی کنارے کی نشاندہی نہیں کرتی ہے۔مثال کے طور پر ، A اور B ، A اور D ، B اور C کے درمیان ایک کنارے موجود ہے ، اور اسی طرح۔ ایڈجنسی میٹرکس میں کئی فوائد اور استعمال کے معاملات ہیں: موثر کنارے کے سوالات: ملحقہ میٹرک مستقل وقت کے سوالات کی اجازت دیتے ہیں کہ آیا ہے یا نہیں۔دو عمودی کے درمیان ایک کنارے۔میٹرکس انڈیکسنگ کنارے کی نمائندگی کرنے والے سیل تک براہ راست رسائی فراہم کرتی ہے ، جس سے کنارے کے وجود کو موثر بناتا ہے۔ اسپیس کی کارکردگی: ملحقہ میٹرکس دیگر گراف کی نمائندگیوں ، جیسے ملحقہ فہرستوں کے مقابلے میں زیادہ جگہ سے موثر ہوسکتی ہے ، جب گراف گھنے ہوتا ہے یا جب کی تعداد کی تعداد ہوتی ہے۔عمودی نسبتا small چھوٹا ہے۔ میٹرکس آپریشنز: میٹرکس کی نمائندگی گراف کا تجزیہ یا ہیرا پھیری کے لئے میٹرکس آپریشنز کے استعمال کو قابل بناتی ہے۔مثال کے طور پر ، میٹرکس ضرب کا استعمال گراف میں کسی خاص لمبائی کے راستے تلاش کرنے کے لئے کیا جاسکتا ہے۔ تاہم ، ملحقہ میٹرکس میں کچھ حدود ہیں ، خاص طور پر بہت سے عمودی اور کچھ کناروں والے ویرل گرافوں کے لئے۔انہیں O (v^2) جگہ کی ضرورت ہوتی ہے ، جہاں v کناروں کی تعداد سے قطع نظر ، v عمودی کی تعداد ہے۔یہ غیر موثر ہوسکتا ہے جب بڑے گرافوں سے نمٹنے کے لئے جس میں نسبتا few کم کناروں ہوتے ہیں۔ خلاصہ میں ، ایک ملحقہ میٹرکس گراف میں عمودی تعلقات کے مابین تعلقات کی نمائندگی کرنے کا ایک جامع اور موثر طریقہ فراہم کرتا ہے۔یہ خاص طور پر گھنے گراف یا حالات کے لئے مفید ہے جہاں مستقل وقت کے کنارے کے سوالات اور میٹرکس کے کام اہم ہیں۔"
    },
    {
        "Question": "جاوا اسکرپٹ میں پروٹو ٹائپ آبجیکٹ کے تصور کی وضاحت کریں اور یہ کس طرح آبجیکٹ وراثت کے لئے استعمال ہوتا ہے۔",
        "Answer": "کسی گراف پر چوڑائی کی پہلی تلاش (بی ایف ایس) الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: ایک ابتدائی ورٹیکس کا انتخاب کریں: ایک ایسا ابتدائی حد کا انتخاب کریں جس سے آپ بی ایف ایس ٹریورزال کو شروع کرنا چاہتے ہیں۔ ڈیٹا ڈھانچے کو بہتر بنائیں: عمودی حصے کو ذخیرہ کرنے کے لئے ایک قطار بنائیںملاحظہ کرنے کے لئے اور ایک سیٹ یا سرنی کا دورہ کرنے والے عمودی کو ٹریک کرنے کے لئے۔ ابتدائی ورٹیکس کو تلاش کریں: ابتدائی ورٹیکس کو قطار میں شامل کریں اور اسے ملاحظہ کی طرح نشان زد کریں۔قطار کے سامنے کا حصہازگر: پائیتھون کوپی کوڈفرم کلیکشن درآمد ڈیکیڈف بی ایف ایس (گراف ، اسٹارٹ): ملاحظہ کریں = سیٹ () قطار = ڈیک () قطار۔ اپینڈ (اسٹارٹ) ملاحظہ کریں۔ ایڈڈ (اسٹارٹ) جبکہ قطار: ورٹیکس = قطار ۔پوفٹ () پرنٹ (ورٹیکس)# گراف [ورٹیکس] میں پڑوسی کے لئے ورٹیکس (جیسے ، کچھ آپریشن پرنٹ کریں یا انجام دیں) پر کارروائی کریں: اگر پڑوسی ملاحظہ نہیں کیا گیا: قطار۔ اپینڈ (پڑوسی) ملاحظہ کریں۔ (پڑوسی) مذکورہ عمل میں ، گراف ایک لغت ہے جس کی نمائندگی کرتی ہےگراف ، جہاں ہر کلید ایک عمودی کی نمائندگی کرتی ہے ، اور اس سے متعلقہ قیمت ہمسایہ خطوط کی ایک فہرست ہے۔ مثال کے طور پر ، مندرجہ ذیل گراف پر غور کریں جس کی نمائندگی ملحقہ فہرست کے طور پر کی گئی ہے: پائیٹون کوپی کوڈ گراف = {'A': ['B' ، 'C'].'،' f '] ،' f ': [' C '،' E '] vert ورٹیکس' A 'سے شروع ہونے والے BFS traversal انجام دینے کے لئے ، آپ BFS فنکشن کو مندرجہ ذیل کہتے ہیں: پائیٹون کوپی کوڈ بی ایف ایس (گراف ،' اے ')یہ گراف کو چوڑائی کے پہلے انداز میں عبور کرے گا ، ہر ایک چوٹی اور اس کے ہمسایہ ممالک کی سطح سے سطح پر جاتا ہے ، 'A' ورٹیکس سے شروع ہوتا ہے۔ بی ایف ایس الگورتھم کی وقت کی پیچیدگی O (V + E) ہے ، جہاں V نمبر ہےعمودی اور ای گراف میں کناروں کی تعداد ہے۔"
    },
    {
        "Question": "لنکڈ فہرست کو جگہ پر الٹ کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "ایک لاحقہ سرنی ایک ڈیٹا ڈھانچہ ہے جو دیئے گئے تار کے تمام لاحقہ کی ترتیب شدہ صف کو محفوظ کرتا ہے۔یہ اصل سٹرنگ ، جیسے پیٹرن مماثل ، سٹرنگ سرچ ، اور سب سے طویل عام پریفکس کمپیوٹیشن پر اسٹرنگ سے متعلقہ کاروائیاں انجام دینے کا ایک موثر طریقہ فراہم کرتا ہے۔ لاحقہ سرنی کی تعمیر کے ل the ، اصل تار پہلے لاحقہ کی ایک صف میں تبدیل ہوجاتا ہے۔ہر لاحقہ اصل تار کے ایک مخصوص انڈیکس سے شروع ہونے والا اور اختتام تک پھیلتا ہے۔اس کے بعد لاحقہ لاحقہ سرنی بنانے کے لئے لغت کے مطابق ترتیب دیا جاتا ہے۔ لاحقہ سرنی میں کئی ایپلی کیشنز اور فوائد ہیں: سٹرنگ سرچ: ایک لاحقہ سرنی کے ساتھ ، آپ مؤثر طریقے سے کسی نمونہ یا اصل تار کے اندر اسٹرنگ تلاش کرسکتے ہیں۔ترتیب شدہ لاحقہ سرنی پر بائنری سرچ یا دیگر موثر تلاش الگورتھم کا استعمال کرکے ، آپ سٹرنگ میں پیٹرن کے تمام واقعات کی ابتدائی پوزیشنوں کا تعین کرسکتے ہیں۔ سب سے زیادہ عام مشترکہ پریفکس: لاحقہ سرنی کو طویل عرصے سے عام پریفکس (LCP) کی گنتی کے لئے استعمال کیا جاسکتا ہے (LCP)اصل تار میں کسی بھی دو لاحقہ کے درمیان۔ایل سی پی ترتیب شدہ لاحقہ سرنی میں اسی لاحقہ کے ذریعہ مشترکہ سب سے طویل عام سابقہ ہے۔اس میں مختلف سٹرنگ مماثل الگورتھم اور ڈیٹا کمپریشن تکنیکوں میں ایپلی کیشنز ہیں۔ پیٹرن مماثل: لاحقہ اریوں کو بروز وہیلر ٹرانسفارم (بی ڈبلیو ٹی) اور ایف ایم انڈیکس جیسے اعلی درجے کے پیٹرن مماثل الگورتھم میں استعمال کیا جاتا ہے ، جو ڈیٹا کمپریشن اور بائیو انفارمیٹکس ایپلی کیشنز میں اہم ہیں۔یہ الگورتھم بڑے متن یا جینومک ڈیٹاسیٹس کے موثر پیٹرن مماثل اور کمپریشن کے حصول کے ل luth لاحقہ صفوں کی خصوصیات کا فائدہ اٹھاتے ہیں۔ اسپیس کی کارکردگی: لاحقہ درختوں جیسے سٹرنگ سے متعلق دیگر اعداد و شمار کے ڈھانچے کے مقابلے میں ، لاحقہ سرنیوں میں زیادہ کمپیکٹ نمائندگی ہوتی ہے۔ان کو کم میموری کی ضرورت ہوتی ہے جبکہ اب بھی موثر اسٹرنگ آپریشنز کو قابل بناتے ہیں۔اس سے لاحقہ صفوں کو خاص طور پر میموری سے منسلک ماحول میں مفید بناتا ہے۔ پریپروسیسنگ کی کارکردگی: ایک لاحقہ سرنی کی تعمیر میں عام طور پر لاحقہ درخت کی تعمیر کے مقابلے میں کم وقت اور کمپیوٹیشنل وسائل کی ضرورت ہوتی ہے۔جب بڑے ڈوروں کو پیش کرتے ہو یا جب بار بار آنے والے سبسٹرنگ آپریشنوں کی پیش گوئی کی جاتی ہے تو اس سے لاحقہ آریوں کو ایک پرکشش انتخاب ہوتا ہے۔ یہ بات قابل غور ہے کہ جب لاحقہ سرنی موثر تھرسٹنگ آپریشن مہیا کرتا ہے تو ، ان میں لاحقہ درختوں کی اضافی فعالیت کا فقدان ہے ، جیسے تیزی سے اندراج اور ذیلی ذخیروں کو حذف کرنا۔لاحقہ درخت بھی لاحقہ اریوں کے مقابلے میں زیادہ میموری استعمال کرتے ہیں۔ خلاصہ میں ، ایک لاحقہ سرنی دیئے گئے تار کے تمام لاحقہ کی ایک ترتیب شدہ صف ہے۔یہ موثر سٹرنگ سرچ ، سب سے طویل عام پریفکس کمپیوٹیشن ، اور اصل تار پر پیٹرن مماثل کاموں کو قابل بناتا ہے۔ان کی جگہ کی کارکردگی اور پری پروسیسنگ کی رفتار کی وجہ سے لاحقہ سرنی سٹرنگ الگورتھم ، بائیو انفارمیٹکس ، اور ڈیٹا کمپریشن میں بڑے پیمانے پر استعمال ہوتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں شروع سے ایک واحد منسلک فہرست کو نافذ کریں۔",
        "Answer": "ایک ہیش ٹیبل میں ، ہیش تصادم اس وقت ہوتا ہے جب بنیادی صف میں ایک ہی انڈیکس یا بالٹی کا دو مختلف چابیاں نقشہ بنائیں۔چونکہ ہیش کے افعال مختلف چابیاں کے لئے ایک ہی ہیش ویلیو پیدا کرسکتے ہیں ، لہذا زیادہ تر عملی منظرناموں میں تصادم ناگزیر ہوتے ہیں ، خاص طور پر جب چابیاں کی تعداد بالٹیوں کی تعداد سے کہیں زیادہ بڑی ہوتی ہے۔ ہیش کے تصادم کو سنبھالنے کے لئے دو عام حکمت عملی: علیحدہ زنجیروں کے ساتھ: ساتھعلیحدہ زنجیر ، ہیش ٹیبل میں ہر بالٹی میں ایک لنکڈ لسٹ یا کچھ اور ڈیٹا ڈھانچہ شامل ہے جس میں ایک ہی انڈیکس میں ہیش ہیش کو ایک سے زیادہ کلیدی قیمت کے جوڑے ذخیرہ کرنے کے ل. ہیں۔جب تصادم ہوتا ہے تو ، اس انڈیکس میں موجودہ زنجیر میں نئی کلیدی قدر کی جوڑی کو شامل کیا جاتا ہے۔اس طرح ، متعدد اقدار ایک دوسرے کو اوور رائٹ کیے بغیر ایک ہی انڈیکس میں محفوظ کی جاسکتی ہیں۔کسی تلاش یا بازیافت کے دوران ، مطلوبہ کلید ویلیو جوڑی کو تلاش کرنے کے لئے مناسب زنجیر کو عبور کیا جاتا ہے۔ اوپن ایڈریسنگ: اوپن ایڈریسنگ میں ، جب تصادم ہوتا ہے تو ، الگورتھم ہیش ٹیبل میں اگلی دستیاب (غیر منقولہ) سلاٹ کی تلاش کرتا ہے۔مقام کا تعین اصل ہیش ویلیو پر جانچ پڑتال کی ترتیب کو لاگو کرکے کیا جاتا ہے۔تحقیقات کے سلسلے میں مختلف ہوسکتے ہیں ، لیکن عام طریقوں میں لکیری پروبنگ (لکیری فیشن میں اگلے سلاٹ میں منتقل ہونا) ، چوکور کی تحقیقات (اگلی سلاٹ کا تعین کرنے کے لئے ایک چوکور فنکشن کا استعمال کرتے ہوئے) ، یا ڈبل ہیشنگ (قدم کا حساب لگانے کے لئے دوسرا ہیش فنکشن استعمال کرنا) شامل ہیں۔سائز)۔اس کا مقصد ایک خالی سلاٹ تلاش کرنا ہے جہاں آپس میں ٹکراؤ والی کلید قدر کی جوڑی داخل کی جاسکتی ہے۔ ہینڈنگ ہینڈنگ ہیش ٹیبل کی کارکردگی اور کارکردگی کو برقرار رکھنے کے لئے مؤثر طریقے سے تصادم بہت ضروری ہے۔علیحدہ زنجیروں اور کھلے عام خطاب کے درمیان انتخاب مختلف عوامل پر منحصر ہے ، جیسے تصادم کی متوقع تعداد ، بوجھ عنصر (مقبوضہ سلاٹوں کا تناسب سلاٹوں کی کل تعداد میں) ، اور بازیافت اور اندراج کی کارکردگی کی مطلوبہ سطح۔ یہ اہم ہے۔نوٹ کرنے کے لئے کہ یہاں تک کہ ایک اچھی طرح سے ڈیزائن کردہ ہیش فنکشن اور تصادم کی مناسب ریزولوشن حکمت عملی کے ساتھ بھی ، تصادم اب بھی ہیش ٹیبلز میں ہوسکتے ہیں۔لہذا ، مناسب بوجھ کے عنصر کو برقرار رکھنے اور کارکردگی کے انحطاط کو روکنے کے لئے ہیش ٹیبل کی نگرانی اور وقتا فوقتا ریشیش (سائز تبدیل کرنا) ضروری ہے۔ ہیش کے تصادم کو صحیح طریقے سے سنبھالنے کے بعد ، ہیش ٹیبلز O کی اوسط وقت کی پیچیدگی کے ساتھ موثر کلیدی قدر کی تلاش فراہم کرسکتے ہیں۔) ، ان کو مختلف ایپلی کیشنز جیسے ڈیٹا بیس ، کیچز اور زبان کے نفاذ میں وسیع پیمانے پر استعمال کرنا۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی صف پر بائنری تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "خود تنظیم سازی کی فہرست ایک ڈیٹا ڈھانچہ ہے جو خود بخود رسائی کی تعدد کی بنیاد پر اپنے عناصر کی تنظیم نو کرتا ہے۔خود تنظیم سازی کی فہرست کا ہدف مہنگا کاموں کی تعداد کو کم کرکے ، جیسے عناصر کی تلاش یا بازیافت کرنے کے ذریعہ کثرت سے رسائی والے عناصر تک رسائی کی کارکردگی کو بہتر بنانا ہے۔ عناصر کو خود تنظیم سازی کی فہرست میں منظم کرنے کے لئے مختلف حکمت عملی ہیں۔یہاں دو مشترکہ نقطہ نظر ہیں: منتقل سے سامنے (ایم ٹی ایف): موو ٹو فرنٹ حکمت عملی میں ، جب بھی کسی عنصر تک رسائی حاصل کی جاتی ہے (تلاش یا بازیافت) ، اسے فہرست کے سامنے میں منتقل کردیا جاتا ہے۔اس کا مطلب یہ ہے کہ حال ہی میں تک رسائی حاصل کرنے والا عنصر ہمیشہ فہرست کے سر پر رہے گا۔ایسا کرنے سے ، اکثر رسائی حاصل کرنے والے عناصر آہستہ آہستہ محاذ کی طرف بڑھتے ہیں ، جس سے تلاش کی مجموعی کارکردگی کو بہتر بنایا جاتا ہے۔تاہم ، اس حکمت عملی سے یہ فرض کیا گیا ہے کہ مستقبل میں رسائی کا نمونہ حالیہ ماضی تک رسائی کے نمونہ سے مشابہت رکھتا ہے۔ ٹرانسپوز: ٹرانسپوز حکمت عملی اس خیال پر مبنی ہے کہ حال ہی میں رسائی حاصل کرنے والے عناصر کو مستقبل قریب میں دوبارہ رسائی حاصل کرنے کا امکان ہے۔جب کسی عنصر تک رسائی حاصل کی جاتی ہے تو ، اس کی فہرست میں فوری طور پر اس سے پہلے عنصر کے ساتھ تبدیل ہوجاتا ہے۔اس طرح ، حال ہی میں رسائی کا عنصر سامنے کے قریب جاتا ہے ، جو مستقبل کے موازنہ کی تعداد کو ممکنہ طور پر کم کرتا ہے۔اس حکمت عملی کا مقصد ایم ٹی ایف کی حکمت عملی کے مقابلے میں رسائی کے نمونوں کو تبدیل کرنے میں زیادہ تیزی سے ڈھالنا ہے۔ خود تنظیم سازی کی فہرست کی تاثیر عناصر کے رسائی کے نمونوں پر منحصر ہے۔اگر رسائی کے نمونے نسبتا مستحکم ہیں اور حوالہ کے ایک اعلی مقام کی نمائش کرتے ہیں (جہاں حال ہی میں رسائی حاصل کرنے والے عناصر کو جلد ہی دوبارہ رسائی حاصل کرنے کا امکان ہے) ، تو خود تنظیم سازی کی فہرست کارکردگی میں نمایاں بہتری فراہم کرسکتی ہے۔تاہم ، اگر رسائ کے نمونے انتہائی غیر متوقع ہیں یا حوالہ کے کم علاقے کی نمائش کرتے ہیں تو ، خود کو منظم کرنے کی فہرستوں کے فوائد کم ہوسکتے ہیں۔ یہ بات اہم ہے کہ خود منظم کرنے والی فہرستوں میں منتقل کرنے والے عناصر اور آرڈر کو برقرار رکھنے کے معاملے میں اضافی اوور ہیڈ لگایا جاتا ہے۔لہذا ، ان کی تاثیر کا احتیاط سے جائزہ لینے کے مخصوص نمونوں اور ایپلی کیشن کی ضروریات کی بنیاد پر جائزہ لیا جانا چاہئے۔ خود تنظیم سازی کی فہرستیں عام طور پر ایسے منظرناموں میں استعمال کی جاتی ہیں جہاں وقت کے ساتھ ساتھ رسائی کے نمونے تبدیل ہوتے ہیں یا جہاں بار بار رسائی کی کارکردگی انتہائی ضروری ہے۔مثالوں میں دوسروں کے درمیان کیچنگ میکانزم ، ویب سرورز ، ڈیٹا بیس سسٹم ، اور فائل سسٹم شامل ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں لنکڈ فہرست کا استعمال کرتے ہوئے اسٹیک کو نافذ کریں۔",
        "Answer": "ڈھیر ڈیٹا ڈھانچے میں کم سے کم عنصر کی تلاش میں وقت کی پیچیدگی مستقل وقت ہے ، O (1)۔ایک کم سے کم ہیپ میں ، کم سے کم عنصر ہمیشہ روٹ نوڈ پر محفوظ کیا جاتا ہے ، جو اسے آسانی سے قابل رسائی اور بازیافت کرتا ہے۔ڈھیر کے سائز سے قطع نظر ، آپ مستقل وقت میں کم سے کم عنصر کو بازیافت کرنے کے لئے براہ راست روٹ نوڈ تک رسائی حاصل کرسکتے ہیں۔ یہ کم سے کم عنصر کی مستقل وقت کی بازیافت ہیپ ڈیٹا ڈھانچے کی ایک اہم خصوصیت ہے اور اس کی ایک وجہ ہے۔ترجیحی قطار میں موثر آپریشن اور الگورتھم کو چھانٹ رہا ہے۔دیگر کارروائیوں کی وقت کی پیچیدگی ، جیسے اندراج اور حذف کرنا ، ڈھیر کے مخصوص نفاذ پر منحصر ہے ، عام طور پر O (لاگ N) سے لے کر O (n) تک بدترین صورت میں ، جہاں N ڈھیر میں عناصر کی تعداد ہے۔.یہ قابل غور ہے کہ کم سے کم عنصر کو ہٹانے کے بعد ہیپ پراپرٹی کو برقرار رکھنا (عام طور پر ہیپائیفائ یا دوبارہ ہیپائیفائ کے عمل کے ذریعے) اضافی وقت کی ضرورت پڑسکتی ہے ، لیکن کم سے کم عنصر کی اصل بازیافت خود مستقل وقت کا عمل ہے۔"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ دیئے گئے بائنری ٹری ٹائپ اسکرپٹ میں متوازن بائنری سرچ ٹری ہے یا نہیں۔",
        "Answer": "ایک سپلی ٹری ایک خود کو ایڈجسٹ کرنے والا بائنری سرچ درخت ہے جو عناصر کے رسائی کے انداز کی بنیاد پر خود کو تنظیم نو کرتا ہے۔اس کا مقصد کثرت سے رسائی والے عناصر کی جڑ کے قریب لاکر ، مستقبل تک رسائی کے اوقات کو کم کرکے ، ایک سپلینگ کے درخت میں ، جب بھی کسی عنصر تک رسائی حاصل کی جاتی ہے (تلاش ، داخل کی جاتی ہے یا حذف) کو بہتر بنانا ہے ، اس کی جڑ میں لایا جاتا ہے۔گردشوں اور تنظیم نو کی کارروائیوں کی ایک سیریز کے ذریعے درخت۔اس عمل کو \"چھڑکنے\" کہا جاتا ہے۔چھڑکنے والا آپریشن درختوں کے ڈھانچے کو جڑوں میں رکھنے کے لئے ایڈجسٹ کرتا ہے ، جس سے بعد میں ہونے والی کارروائیوں میں رسائی آسان اور تیز تر ہوجاتی ہے۔ اسپلائنگ آپریشن عام طور پر تین اہم اقدامات پر مشتمل ہوتا ہے: زگ زگ یا زیگ زگ گردش: اگر رسائی حاصل شدہ عنصرایک پوتے یا پوتے کا بچہ ہے ، اس کو جڑ تک لانے کے لئے گردشوں کا ایک سلسلہ انجام دیا جاتا ہے۔اس میں یا تو زگ زگ گردش یا زگ زگ گردش شامل ہوسکتی ہے ، جو رسائی والے عنصر ، اس کے والدین اور اس کے دادا والدین کی نسبتہ پوزیشنوں پر منحصر ہے۔ زیگ گردش: اگر رسائی کا عنصر جڑ کا بچہ ہے تو ، ایک ہی گردش ہے۔، جسے زیگ گردش کہا جاتا ہے ، اسے جڑ تک لانے کے لئے انجام دیا جاتا ہے۔یہ غیر متوازن سبٹریز کو مزید تنظیم نو کی جاتی ہے تاکہ یہ یقینی بنایا جاسکے کہ درخت متوازن رہے۔ اسپلائنگ کا عمل درخت کو رسائی کے نمونہ کی بنیاد پر ایڈجسٹ کرتا ہے ، جس کا مقصد اکثر رسائی والے عناصر کو جڑ کے قریب لانا ہے۔اس سے ان عناصر کے لئے اوسط تک رسائی کا وقت کم ہوجاتا ہے کیونکہ انہیں کم موازنہ اور ٹریورلز کی ضرورت ہوتی ہے۔وہ رسائی کے نمونہ کے مطابق ڈھال لیتے ہیں اور اس کے مطابق خود کو تنظیم نو کرتے ہیں ، اس کے نتیجے میں ہونے والی کارروائیوں کی کارکردگی کو بہتر بناتے ہیں۔ انفرادی طور پر چھڑکنے والی کارروائیوں کی وقت کی پیچیدگی عام طور پر O (لاگ این) ہوتی ہے ، جہاں N درخت میں عناصر کی تعداد ہوتی ہے۔تاہم ، سپلی کے درخت متوازن اونچائیوں کی ضمانت نہیں دیتے ہیں جیسے اے وی ایل کے درخت یا سرخ رنگ کے درخت ، لہذا بدترین صورت میں ، آپریشنز کی ترتیب کی وقت کی پیچیدگی O (n) تک پہنچ سکتی ہے۔اس کے باوجود ، اسپیلے درخت اکثر عملی طور پر موثر ہوتے ہیں کیونکہ ان تک رسائی کے نمونہ کو اپنانے اور کثرت سے رسائی کے اوقات کو کم کرنے کی صلاحیت کی وجہ سے۔الگورتھم۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو اسٹیکس کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "اسکیپ گراف ایک احتمالی اعداد و شمار کا ڈھانچہ ہے جو متوازن سرچ درخت کی طرح موثر تلاش اور اشاریہ سازی کی صلاحیتوں کو فراہم کرتا ہے لیکن ایک آسان ساخت کے ساتھ۔یہ موثر تلاش اور اندراج کے کاموں کو حاصل کرنے کے ل Sk اسکیپ لسٹوں اور بائنری سرچ درختوں کے فوائد کو جوڑتا ہے۔ ایک اسکیپ گراف پرتوں کے ایک درجہ بندی پر مشتمل ہوتا ہے ، جس میں ہر نوڈس کی ایک منسلک فہرست ہوتی ہے۔اسکیپ گراف کی نچلی پرت ڈیٹا ڈھانچے میں موجود تمام عناصر کی ترتیب شدہ منسلک فہرست ہے۔اونچی پرتیں نچلی پرت کے کچھ عناصر پر انتخابی طور پر \"اسکیپنگ\" کے ذریعہ تخلیق کی جاتی ہیں ، جس میں شارٹ کٹ تشکیل دیتے ہیں جو تیز تر تلاشی کی اجازت دیتے ہیں۔ یہاں اسکیپ گراف کس طرح کام کرتا ہے: تعمیراتی: ابتدائی طور پر ، تمام عناصر کو اسکیپ گراف کی نیچے کی پرت میں داخل کیا جاتا ہے ،ترتیب شدہ لنکڈ فہرست تشکیل دینا۔ہر نوڈ میں ایک کلیدی قدر کی جوڑی ہوتی ہے اور اس میں ایک یا زیادہ فارورڈ پوائنٹر ہوسکتے ہیں جو اگلی اعلی پرت میں نوڈس کی طرف اشارہ کرتے ہیں۔ اسکپ کنکشن: اعلی پرتوں کو بنانے کے لئے ، ایک احتمال کا طریقہ استعمال کیا جاتا ہے۔نچلی پرت میں ہر نوڈ کے ل a ، ایک سکے ٹاس طے کرتا ہے کہ آیا اس میں اگلی اعلی پرت کا فارورڈ پوائنٹر ہوگا۔فارورڈ پوائنٹر رکھنے کا امکان کم ہوتا ہے کیونکہ پرت اونچی ہوتی ہے۔اس عمل سے ایک اسکیپ کنکشن پیدا ہوتا ہے جو نچلی پرت میں متعدد عناصر کو نظرانداز کرتا ہے ، جس سے تیز رفتار تلاشی کی اجازت ملتی ہے۔ تلاش کی آپریشن: کسی خاص کلید کی تلاش کے ل the ، تلاش اوپر کی پرت سے شروع ہوتی ہے اور فارورڈ پوائنٹرز پر عمل کرکے اسکیپ گراف کے ذریعے ٹریورس ہوتی ہے۔اگر فارورڈ پوائنٹر ہدف کی کلید سے زیادہ کلید کے ساتھ نوڈ کی طرف جاتا ہے تو ، تلاش اگلی نچلی پرت تک گرتی ہے اور جاری رہتی ہے۔یہ عمل اس وقت تک دہراتا ہے جب تک کہ ہدف کی کلید نہ مل جائے یا نیچے کی پرت پہنچ جاتی ہے۔ داخل اور حذف کرنا: اسکیپ گراف میں اندراج اور حذف کرنے کی کارروائییں سرچ آپریشنز کی طرح ہیں۔داخل کرنے یا حذف کرنے کے لئے نوڈ تلاش کے عمل کا استعمال کرتے ہوئے واقع ہے ، اور اسکیپ گراف کے ترتیب شدہ ترتیب کو برقرار رکھنے اور اس کے مطابق فارورڈ پوائنٹرز کو اپ ڈیٹ کرنے کے لئے مناسب ایڈجسٹمنٹ کی گئی ہیں۔ اسکیپ گراف کا کلیدی فائدہ سرچ آپریشنز میں اس کی کارکردگی ہے۔اسکیپ کنکشن روایتی لنکڈ فہرستوں کے مقابلے میں تیز رفتار تلاش کے اوقات کو قابل بناتے ہیں ، کیونکہ وہ شارٹ کٹ فراہم کرتے ہیں جو مطلوبہ موازنہ کی تعداد کو کم کرتے ہیں۔مزید برآں ، اسکیپ گراف میں اے وی ایل یا سرخ سیاہ درختوں جیسے متوازن تلاش کے درختوں کے مقابلے میں ایک آسان سا ڈھانچہ ہوتا ہے ، جس سے ان کو نافذ کرنا اور برقرار رکھنا آسان ہوجاتا ہے۔ تاہم ، اسکیپ کنیکشن کو برقرار رکھنے کے اوور ہیڈ کو برقرار رکھنے کی وجہ سے دوسرے ڈیٹا ڈھانچے کے مقابلے میں اسکیپ گراف کو اضافی میموری کی ضرورت پڑسکتی ہے۔میموری اوور ہیڈ اور تلاش کی کارکردگی کے مابین توازن کو تعمیر کے دوران اسکیپ کنکشن بنانے کے امکانات کو ٹیون کرکے ایڈجسٹ کیا جاسکتا ہے۔ ایس کے آئی پی گراف میں تقسیم شدہ نظام ، ہم مرتبہ سے پیر نیٹ ورکس ، اور کلیدی قیمت والے اسٹورز میں ایپلی کیشنز موجود ہیں جہاں موثر اشاریہ سازی اور تلاش کی ضرورت ہوتی ہے۔وہ تلاش کی اچھی کارکردگی کو برقرار رکھتے ہوئے روایتی تلاش کے درختوں کے لئے ایک توسیع پذیر اور विकेंद्रीकृत متبادل فراہم کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے سٹرنگ میں الفاظ کی ترتیب کو الٹا کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ایک اسٹیک اور قطار دونوں لکیری ڈیٹا ڈھانچے ہیں جو عناصر کو اسٹور اور منظم کرنے کے لئے استعمال ہوتے ہیں۔اسٹیک اور ایک قطار کے درمیان بنیادی فرق اس میں ہے کہ کس طرح عناصر کو شامل کیا جاتا ہے اور ہر ڈھانچے سے ہٹایا جاتا ہے ، جس کے نتیجے میں مختلف رسائی کے نمونوں اور طرز عمل کا نتیجہ ہوتا ہے۔ اسٹیک: ایک اسٹیک آخری ان فرسٹ آؤٹ (LIFO) اصول کی پیروی کرتا ہے ، اس کا مطلب ہے کہآخری عنصر داخل کیا گیا پہلا ایک ہے جس کو ہٹا دیا جاتا ہے۔ عنصر کو اسی سرے سے شامل اور ہٹا دیا جاتا ہے ، جسے اکثر اسٹیک کا \"اوپر\" کہا جاتا ہے۔ اسٹیک پر انجام دی جانے والی کارروائیوں کو عام طور پر \"پش\" کہا جاتا ہے (عنصر شامل کرتے ہوئے عنصر شامل کرتے ہیں۔اسٹیک کے اوپری حصے میں) اور \"پاپ\" (اسٹیک سے اوپر والے عنصر کو ہٹانا)۔ ایک اسٹیک کو عمودی ڈھانچے کے طور پر دیکھا جاسکتا ہے ، جہاں نئے عناصر ایک دوسرے کے اوپر کھڑے ہیں۔پہلے سے باہر (FIFO) اصول ، اس کا مطلب یہ ہے کہ پہلا عنصر داخل کیا گیا پہلا عنصر ہے جس کو ہٹا دیا جاتا ہے۔ عنصروں کو ایک سرے میں شامل کیا جاتا ہے ، جسے اکثر قطار کا \"عقبی\" یا \"پیچھے\" کہا جاتا ہے ، اور دوسرے سے ہٹا دیا جاتا ہےاختتام ، جسے اکثر قطار کا \"فرنٹ\" کہا جاتا ہے۔ قطار میں انجام دی جانے والی کارروائیوں کو عام طور پر \"انکیو\" (قطار کے عقبی حصے میں عنصر شامل کرنا) اور \"ڈی کیوئو\" (قطار سے سامنے والے عنصر کو ہٹانا) کہا جاتا ہے۔. ایک قطار کو افقی ڈھانچے کے طور پر تصور کیا جاسکتا ہے ، جہاں نئے عناصر کو عقبی حصے میں شامل کیا جاتا ہے اور سامنے سے ہٹا دیا جاتا ہے۔ خلاصہ کریں: اسٹیک: LIFO اصول ، عناصر شامل اور اسی سرے سے ہٹا دیئے جاتے ہیں ، آپریشن پش اور پاپ ہوتے ہیں۔. کیوئو: ایف آئی ایف او اصول ، عناصر کو عقب میں شامل کیا گیا اور سامنے سے ہٹا دیا گیا ، آپریشن انکیو اور ڈیکیو ہیں۔ اسٹیک یا قطار کے استعمال کے درمیان انتخاب اس مسئلے کی مخصوص ضروریات پر منحصر ہے جس کو آپ حل کرنے کی کوشش کر رہے ہیں۔اگر آپ کو \"آخری ان ، پہلے آؤٹ\" سلوک کو نافذ کرنے کی ضرورت ہے یا آپریشنز کے آرڈر (جیسے ، فنکشن کال اسٹیک ، کالعدم/دوبارہ فعالیت) کو ٹریک کرنے کی ضرورت ہے تو ، ایک اسٹیک زیادہ مناسب ہے۔دوسری طرف ، اگر آپ کو عناصر کی ترتیب کو برقرار رکھنے اور اسی ترتیب سے ان پر کارروائی کرنے کی ضرورت ہے تو وہ داخل کردیئے گئے تھے (جیسے ، ٹاسک شیڈولنگ ، میسج پروسیسنگ) ، ایک قطار ایک بہتر انتخاب ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک کم سے کم میکس ہیپ ڈیٹا ڈھانچہ نافذ کریں۔",
        "Answer": "ایک فینوک درخت ، جسے بائنری انڈیکسڈ ٹری (BIT) بھی کہا جاتا ہے ، ایک ایسا ڈیٹا ڈھانچہ ہے جو مؤثر طریقے سے سابقہ رقم کے سوالات کو انجام دینے اور کسی صف میں انفرادی عناصر کو اپ ڈیٹ کرنے کے لئے استعمال ہوتا ہے۔یہ متحرک صف میں عناصر کی مجموعی رقم کی گنتی اور اس میں ترمیم کرنے کا ایک موثر طریقہ فراہم کرتا ہے۔ فینوک کے درخت میں ایک سرنی پر مبنی نمائندگی ہے جو بائنری درخت کے ڈھانچے کو استعمال کرتی ہے۔یہ کیسے کام کرتا ہے: سرنی نمائندگی: فینوک ٹری کو سائز N+1 کی ایک صف کے طور پر پیش کیا جاتا ہے ، جہاں N اصل صف کا سائز ہے۔انڈیکس 0 میں اضافی عنصر 0. بائنری درختوں کے ڈھانچے کے طور پر شروع کیا گیا ہے: فینوک درخت میں ہر عنصر اصل صف میں عناصر کی ایک حد سے مساوی ہے۔خاص طور پر ، فینوک درخت میں انڈیکس I کے عنصر کے لئے ، اصل صف میں عناصر کی اسی رینج [i - lsone (i) + 1 ، i] ہے ، جہاں LSONE (i) کم سے کم اہمیت کی قدر ہے۔i.prefix SUM حساب کتاب کی بائنری نمائندگی: اصل صف میں دیئے گئے انڈیکس I تک عناصر کے سابقہ مجموعہ کی گنتی کرنے کے لئے ، آپ فینوک کے درخت کو انڈیکس I سے اس کے والدین کے نوڈس تک منتقل کرتے ہیں جب تک کہ آپ جڑ (انڈیکس 0) تک نہ پہنچیں۔ہر مرحلے میں ، آپ موجودہ نوڈ کی قیمت کو مجموعی رقم میں شامل کرتے ہیں۔ اپ ڈیٹ آپریشن: اصل صف میں کسی مخصوص انڈیکس I میں کسی عنصر کو اپ ڈیٹ کرنے کے ل you ، آپ انڈیکس I سے فینوک کے درخت کو اس وقت تک اس کے والدین کے نوڈس تک پہنچاتے ہیں جب تک کہ آپ اس کے والدین نوڈس تک نہ پہنچیںزیادہ سے زیادہ انڈیکس این.ہر مرحلے میں ، آپ موجودہ نوڈ کی قیمت کو اپ ڈیٹ کرنے کی قیمت کو شامل کرکے اپ ڈیٹ کرتے ہیں۔ فینوک درخت کا کلیدی فائدہ دونوں سابقہ رقم کے سوالات اور اپ ڈیٹس میں اس کی کارکردگی ہے۔سابقہ رقم کی کمپیوٹنگ اور اپ ڈیٹ آپریشن انجام دینے کے لئے وقت کی پیچیدگی O (لاگ این) ہے ، جہاں N اصل صف کا سائز ہے۔اس سے یہ ایک بولی نقطہ نظر کا استعمال کرتے ہوئے کمپیوٹنگ پریفکس کی رقم کی نسبت نمایاں طور پر تیز تر ہوجاتا ہے جس میں ہر استفسار یا اپ ڈیٹ کے لئے O (n) وقت کی ضرورت ہوتی ہے۔ فینوک درخت مختلف علاقوں میں ایپلی کیشنز تلاش کرتے ہیں ، جیسے رینج سم سے متعلق سوالات ، رینج اپ ڈیٹس ، اور الٹا گنتی کے حساب کتاب۔وہ خاص طور پر ایسے منظرناموں میں کارآمد ہیں جہاں صف متحرک ہے ، اور بار بار سابقہ رقم کے سوالات یا انفرادی عنصر کی تازہ کاریوں کی ضرورت ہوتی ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو ڈوروں کے مابین سب سے طویل عام حصول تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "گنتی کی طرح ایک موثر الگورتھم ہے جو ایک معروف حد کے ساتھ عددیوں کے ذخیرے کو ترتیب دینے کے لئے استعمال ہوتا ہے۔یہ ان پٹ سرنی میں ہر عنصر کے لئے طے کرکے کام کرتا ہے ، عناصر کی تعداد جو اس سے چھوٹے ہیں۔ان گنتیوں کی بنیاد پر ، یہ ہر عنصر کو اپنی صحیح ترتیب والی پوزیشن میں رکھتا ہے۔ یہاں گنتی کی طرح کام کرتا ہے: گنتی کا مرحلہ: ان پٹ سرنی کو عبور کریں اور ہر انوکھے عنصر کی موجودگی کو گنیں۔ان گنتیوں کو ذخیرہ کرنے کے لئے \"گنتی سرنی\" یا \"فریکوئینسی سرنی\" کے نام سے ایک معاون سرنی بنائیں۔گنتی کی صف کا سائز ان پٹ سرنی میں اقدار کی حد سے طے کیا جاتا ہے۔ اجتماعی گنتی: ہر گنتی کے مجموعی رقم کا حساب کتاب کرکے گنتی کی صف میں ترمیم کریں۔یہ مجموعی رقم ان عناصر کی تعداد کی نمائندگی کرتی ہے جو ان پٹ صف میں ہر عنصر سے کم یا اس کے برابر ہوتے ہیں۔مجموعی طور پر ہر عنصر کی صحیح ترتیب شدہ پوزیشن کا تعین کرنے کے لئے مجموعی رقم کا استعمال کیا جاتا ہے۔ ترتیب دینے والے مرحلے: ان پٹ سرنی کو ایک بار پھر عبور کریں اور ، ہر عنصر کے لئے ، ترتیب شدہ آؤٹ پٹ سرنی میں اس کی صحیح پوزیشن تلاش کرنے کے لئے گنتی کی صف میں اس کی قیمت کو انڈیکس کے طور پر استعمال کریں۔کمی گنتی کی صف میں گنتی کے لئے اس کی ترتیب شدہ پوزیشن میں رکھے جانے والے عنصر کا محاسبہ کرنے کے لئے۔، جہاں این ان پٹ سرنی میں عناصر کی تعداد ہے اور K اقدار کی حد ہے۔چھانٹنے کے عمل میں لکیری وقت کی پیچیدگی ہوتی ہے کیونکہ یہ ایک بار ان پٹ سرنی اور گنتی کی صف میں ایک بار ہوتا ہے۔تاہم ، گنتی کی طرح کی خلائی پیچیدگی O (n + k) ہے کیونکہ اس میں گنتی کی صف کو ذخیرہ کرنے کے لئے اضافی میموری کی ضرورت ہوتی ہے۔ حساب کتاب کرنا اس وقت سب سے زیادہ موثر ہوتا ہے جب ان پٹ ویلیوز کی حد کو ترتیب دینے والے عناصر کی تعداد سے نمایاں طور پر بڑا نہیں ہوتا ہے۔یہ اکثر دوسرے چھانٹنے والے الگورتھم میں یا ان حالات میں سبروٹائن کے طور پر استعمال ہوتا ہے جہاں ان پٹ عناصر غیر منفی عدد ہیں جس میں ایک چھوٹی سی رینج ہوتی ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ڈجکسٹرا کے مختصر ترین راستے الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا ایک مثال ہے جس میں ایک واحد منسلک فہرست کو تبدیل کرنے کے لئے ایک فنکشن کا نفاذ ہے: پائیتھون کوپی کوڈکلاس لسٹنوڈ: ڈیف __init __ (خود ، قدر): سیلف.وال = ویلیو سیلف۔ نیکسٹ = نون ایڈف ریورس_ لنکڈ_ لسٹ (ہیڈ): # چیک کریں کہ آیا لنکڈ لسٹ ہے یا نہیںخالی یا صرف ایک نوڈ پر مشتمل ہے اگر سر نہیں ہے یا ہیڈ نہیں ہے۔ نیکسٹ: ریٹرن ہیڈ # موجودہ ، پچھلے ، اور اگلے نوڈس کو ٹریک رکھنے کے لئے تین پوائنٹرز کو شروع کریں = ہیڈ پچھلا = کوئی بھی # لنکڈ فہرست کے ذریعے نہیں ، لنکس کو تبدیل کرتے ہوئے ، جبکہ لنکس کو تبدیل کرتے ہوئے لنک کو تبدیل کرتے ہیں۔موجودہ: next_node = موجودہ۔ نیکسٹ # اگلے نوڈ کے حوالہ کو محفوظ کریں۔ nedext = پچھلا # الٹ لنک # پوائنٹرز کو اگلے نوڈس میں منتقل کریں پچھلے = موجودہ موجودہ = اگلے_نوڈ # ٹریورسل کے بعد ، پچھلا پوائنٹر اشارہ کرے گاالٹ لنکڈ لسٹ لسٹ ریٹرن کا نیا سربراہ پچھلا آپ لنکڈ فہرست بنا کر اور اس کے سر نوڈ کو بطور دلیل پاس کرکے ریورس_ لنکڈ_ لسٹ فنکشن استعمال کرسکتے ہیں۔فنکشن لنکڈ فہرست کو جگہ پر پلٹ دے گا اور نیا ہیڈ نوڈ واپس کرے گا۔ نوٹ کریں کہ یہ عمل درآمد ایک واحد منسلک فہرست سنبھالتا ہے جہاں ہر نوڈ میں ایک ویل وصف ہوتا ہے جس میں نوڈ کی قیمت کی نمائندگی ہوتی ہے اور اگلی وصف کی فہرست میں اگلے نوڈ کی طرف اشارہ ہوتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو ترتیب شدہ صفوں کے وسط تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا بائنری ٹری بائنری سرچ ٹری (بی ایس ٹی) ہے ، آپ مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک مددگار فنکشن کی وضاحت کریں ، آئیے اس کو IS_BST_UTIL کہتے ہیں ، جو بائنری ٹری نوڈ لیتا ہے ، اس کے ساتھ کم از کم اور زیادہ سے زیادہ قیمت بھی ہے کہ نوڈ کی قیمت ہے۔اندر آنا چاہئے۔یہ فنکشن بار بار جانچ پڑتال کرتا ہے کہ اگر درخت میں ہر نوڈ بی ایس ٹی پراپرٹی کو مطمئن کرتا ہے۔ IS_BST_UTIL فنکشن میں: بیس کیس: اگر نوڈ کوئی نہیں ہے تو ، سچ واپس لوٹیں (ایک خالی درخت ایک درست BST سمجھا جاتا ہے) ۔کیک کریں اگر نوڈ کی قیمت اس کے اندر ہے تو چیک کریںکم سے کم اور زیادہ سے زیادہ اقدار کے ذریعہ بیان کردہ حد۔اگر یہ حد سے باہر ہے تو ، غلط کو واپس کریں۔ موجودہ نوڈ کی قیمت کے طور پر تازہ ترین زیادہ سے زیادہ قیمت کے ساتھ بائیں بچے کے لئے IS_BST_UTIL پر کال کریں (بائیں سبٹری میں موجود تمام اقدار موجودہ نوڈ سے چھوٹی ہونی چاہئیں)۔موجودہ نوڈ کی قدر کے طور پر تازہ ترین کم سے کم قیمت (دائیں سب ٹری میں موجود تمام اقدار موجودہ نوڈ سے زیادہ ہونی چاہئیں)۔ اگر دونوں بار بار آنے والی کالیں درست لوٹ آئیں تو ، درست لوٹ آئیں ، اس بات کی نشاندہی کرتے ہیں کہ موجودہ نوڈ پر جڑے ہوئے سب ٹری ایک درست bst.finally ہے۔، ایک ریپر فنکشن بنائیں ، آئیے اس کو is_binary_search_tree کہتے ہیں ، جو بائنری ٹری کی جڑ کے ساتھ is_bst_util فنکشن کہتے ہیں اور مناسب ابتدائی کم سے کم اور زیادہ سے زیادہ اقدار (جیسے ، منفی انفینٹی اور مثبت انفینٹی) ۔جھون میں ایک مثال کے طور پر عمل درآمد: پائیٹھونکپی کوڈیلاس ٹرینوڈ: Def __init __ (خود ، قدر): سیلف.وال = ویلیو سیلف۔ لیفٹ = کوئی بھی نہیں۔ خود نہیں۔ رائٹ = نونیڈف is_bst_util (نوڈ ، من_وال ، میکس_وال): اگر نوڈ کوئی نہیں ہے تو: اگر نوڈ <= من_وال یا نوڈ ہو تو سچ واپس کریں۔ویل> = میکس_وال: غلط بائیں_بسٹ = is_bst_util (نوڈ.لفٹ ، من_وال ، نوڈ.ول) واپس لوٹیں۔ رائٹ_بسٹ = is_bst_util (نوڈ.ایٹ ، نوڈ.ول ، میکس_وال) ریٹرن بائیں_بسٹ اور رائٹ_بسٹڈف is_binary_search_tree (جڑ).اس کے بعد ، آپ بائنری درخت کی جڑ سے گزرتے ہوئے ، is_binary_search_tree فنکشن کو کال کرسکتے ہیں۔اگر درخت ایک درست بائنری تلاش کا درخت ہے ، اور دوسری صورت میں غلط ہے تو یہ سچ واپس آئے گا۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں خود توازن رکھنے والے AVL درخت کو نافذ کریں۔",
        "Answer": "دو قطاریں استعمال کرتے ہوئے اسٹیک کو نافذ کرنے کے ل you ، آپ مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک اسٹیک کلاس بنائیں جو اندرونی طور پر دو قطاریں برقرار رکھے۔ پش آپریشن کے لئے: نئے عنصر کو قطار میں داخل کریں۔ پاپ آپریشن کے لئے: تمام عناصر کو قطار 1 سے لے جائیںقطار 2 ، سوائے آخری عنصر کے۔قطار 1 سے قطار 2 تک تمام عناصر ، سوائے آخری عنصر کے۔قطار 1 اور قطار 2 خالی ہیں۔ ازگر میں ایک مثال کے طور پر عمل درآمد: پائیتھون کوپی کوڈفرم قطار کی درآمد کوئوکلاس اسٹیک: Def __init __ (خود): self.q1 = قطار () سیلف. کیو 2 = قطار () ڈیف پش (خود ، قیمت):self.q1.put (ویلیو) ڈیف پاپ (خود): اگر self.empty (): استثناء بڑھاؤ (\"اسٹیک خالی ہے\") جبکہ سیلف۔.get ()) top_element = self.q1.get () self.q1 ، self.q2 = self.q2 ، self.Q1 ریٹرن ٹاپ_یلیمنٹ ڈیف ٹاپ (خود): اگر سیلف ڈاٹ ایپی (): استثناء بڑھاؤ (\"اسٹیک ہےخالی \") جبکہ سیلف۔.q2 = self.q2 ، self.q1 ریٹرن ٹاپ_یلیمنٹ ڈیف خالی (خود): واپس کریں سیل۔اسٹیک کلاس کے ذریعہ فراہم کردہ سب سے اوپر ، اور خالی طریقے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ٹری پر آرڈر میں درختوں کی سیر کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "انٹیجرز کی ایک صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے ل you ، آپ کڈانے کے الگورتھم کا استعمال کرسکتے ہیں ، جس میں O (n) کی وقت کی پیچیدگی ہوتی ہے۔ازگر میں یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف Find_max_subarray_sum (نمبر): اگر نمبر نہیں ہے تو: 0 میکس_سم = نمبرز [0] موجودہ_سم = نمبر [0] رینج (1 ، لین (نمبر)): کرنٹ_سم = میکس (نمبر (نمبر (نمبر)۔یہ دو متغیرات کی ابتدا کرتا ہے: میکس_سم اب تک کا زیادہ سے زیادہ رقم کا پتہ لگانے کے لئے ، اور موجودہ سبری کے جوڑے کو ٹریک کرنے کے لئے موجودہ_سم۔ دوسرے عنصر سے شروع ہونے والی صفوں کے ذریعے الگورتھم تکرار کرتا ہے۔ہر عنصر کے ل it ، یہ موازنہ کرتا ہے کہ آیا موجودہ عنصر سے نیا سبری شروع کرنا یا موجودہ عنصر کو شامل کرکے موجودہ سبری کو بڑھانا زیادہ فائدہ مند ہے۔یہ موجودہ_سم کو اس کے مطابق اپ ڈیٹ کرتا ہے اور میکس_سم میں درپیش زیادہ سے زیادہ رقم پر نظر رکھتا ہے۔ اس کے بعد پوری صف میں تکرار کرتے ہوئے ، فنکشن میکس_سم کو لوٹاتا ہے ، جو زیادہ سے زیادہ سبری کی نمائندگی کرتا ہے۔یہ دیئے گئے صف کے اندر سبری کی زیادہ سے زیادہ رقم واپس کردے گا۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ازگر میں کوئکسورٹ الگورتھم کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف کوئکسورٹ (اے آر آر): اگر لین (اے آر آر) <= 1: ریٹرن ارا پائیوٹ = آر آر [لین (اے آر آر) // 2] # درمیانی عنصر کو محور چھوٹے کے طور پر منتخب کریں۔= [x کے لئے x in arr اگر x <pivot] # محور برابر سے چھوٹے عناصر = [x کے لئے x x کے لئے x == محور] # پائیوٹ زیادہ کے برابر # عناصر = [x کے لئے x کے لئے اگر x> Pivot] # محور ریٹرن کوئکسورٹ (چھوٹا) + برابر + کوئکسورٹ (زیادہ) سے زیادہ عناصر # بار بار ترتیب دیں سباریسورٹ فنکشن ان پٹ کے طور پر ایک سرنی آر آر لیتا ہے اور سرنی کو ترتیب دینے کے لئے کوئکسورٹ الگورتھم کو بار بار انجام دیتا ہے۔ الگورتھم ایک پائیوٹ عنصر کا انتخاب کرتا ہے ،اس معاملے میں ، صف کا درمیانی عنصر۔اس کے بعد یہ سرنی کو تین حصوں میں تقسیم کرتا ہے: محور سے چھوٹے عناصر ، محور کے برابر عناصر ، اور محور سے زیادہ عناصر۔ فنکشن نے کوئکسورٹ الگورتھم کو چھوٹے اور بڑے ذیلی حصے میں بار بار لاگو کیا ہے ، اور اس کے ساتھ چھانٹے ہوئے سبریوں کو بھی جوڑ دیا ہے۔آخری ترتیب شدہ صف تیار کرنے کے لئے مساوی عناصر۔ کوئکسورٹ فنکشن کا استعمال کرنے کے ل you ، آپ اسے ایک دلیل کے طور پر عدد کی صف کے ساتھ کال کرسکتے ہیں۔یہ ایک نئی صف لوٹائے گا جس میں عناصر کو چڑھایا ہوا ترتیب میں ترتیب دیا گیا ہے۔مثال کے طور پر: پائیتھون کوپی کوڈیرر = [8 ، 3 ، 1 ، 5 ، 9 ، 2] چھانٹیا_آر = کوئکورٹ (اے آر آر) پرنٹ (چھانٹیا_ر) # آؤٹ پٹ: [1 ، 2 ، 3 ، 5 ، 8 ، 9] نوٹ کریں کہ مذکورہ بالا عمل کو نوٹ کریں۔چھوٹے ، مساوی اور زیادہ سبریوں کے ل new نئی فہرستیں تخلیق کرتا ہے۔عملی طور پر ، سبری کی حدود کو ٹریک رکھنے کے لئے دو پوائنٹرز کا استعمال کرکے اپنی جگہ میں ترمیم کرنا ممکن ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو عملی جامہ پہنانے کے ل you ، آپ مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک MINHEAP کلاس بنائیں جو کم سے کم ڈیٹا ڈھانچے کی نمائندگی کرے۔من ڈھیر کو سرنی پر مبنی نمائندگی کا استعمال کرتے ہوئے نافذ کیا جائے گا۔ مینی ہاپ کلاس کے پاس مندرجہ ذیل طریقے ہونا چاہئے: __ init__: ایک خالی من ڈھیر شروع کرتا ہے۔ سائز: من ہیپ میں عناصر کی تعداد واپس کرتا ہے۔خالی ہے ، دوسری صورت میں غلط ہے۔ پش: ڈھیر پراپرٹی کو برقرار رکھتے ہوئے من ڈھیر میں کسی عنصر کو داخل کرتا ہے۔ پاپ: ڈھیر پراپرٹی کو برقرار رکھتے ہوئے کم سے کم عنصر کو من ڈھیر سے ہٹاتا ہے اور واپس کرتا ہے۔اس کو ہٹانا۔ عمل درآمد کے ل you ، آپ ڈھیر میں نوڈ کے والدین اور بچوں کے اشاریوں کا حساب لگانے کے لئے معیاری اشاریہ سازی فارمولوں کا استعمال کرسکتے ہیں: والدین انڈیکس: (انڈیکس - 1) // 2 لیفٹ چائلڈ انڈیکس: 2 * انڈیکس + 1 رائٹ چائلڈ انڈیکس:2 * انڈیکس + 2 ہیری میں ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈکلاس منہیپ: ڈیف __ __init __ (خود): سیلف۔ ہیپ = [] ڈیف سائز (خود).HEAP) == 0 DEF PUSH (خود ، قدر): self.heap.append (ویلیو) سیلف۔\"ترجیحی قطار خالی ہے\") # آخری عنصر کے ساتھ جڑ (کم سے کم) عنصر کو تبدیل کریں۔# جڑ عنصر کو خود سے نیچے ڈال کر ہیپ پراپرٹی کو بحال کریں۔_SIFT_UP (خود ، انڈیکس): پیرنٹ_ انڈیکس = (انڈیکس - 1) // 2 اگر انڈیکس> 0 اور سیلف۔ ہیپ [انڈیکس] <سیلف۔ ہیپ [والدین_ انڈیکس]: سیلف ۔_سوپ (انڈیکس ، پیرنٹ_ انڈیکس) سیلف ۔_سفٹ_پ (والدین_ انڈیکس)DEF _SIFT_DOWN (خود ، انڈیکس): بائیں_چلیڈ_ انڈیکس = 2 * انڈیکس + 1 رائٹ_چلیڈ_ انڈیکس = 2 * انڈیکس + 2 سب سے چھوٹا = انڈیکس اگر بائیں_چڈ_ انڈیکس <سیلف۔ سائز () اور سیلف۔ ہیپ [بائیں_چند_ انڈیکس] <سیلف۔ ہیپ [سب سے چھوٹا]: سب سے چھوٹا =بائیں_کلیڈ_ انڈیکس <سیلف۔خود ، i ، j): self.heap [i] ، self.heap [j] = self.heap [j] ، self.heap [i] آپ منھیپ کلاس کا استعمال کرکے ترجیحی قطار تشکیل دے سکتے ہیں اور پش جیسے کام انجام دے سکتے ہیں۔، پاپ ، اور ان کی ترجیحات کے مطابق عناصر کا انتظام کرنے کے لئے اوپر۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں سرخ سیاہ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں ، آپ ان کے نوڈس کا متناسب موازنہ کرسکتے ہیں۔ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، کوئی بھی نہیں): سیلف.وال = ویل سیلف۔: # بیس کیس: اگر دونوں درخت خالی ہیں تو ، وہ ایک جیسے ہیں اگر ٹری 1 کوئی نہیں ہے اور ٹری 2 کوئی نہیں ہے: سچ واپس # اگر درختوں میں سے ایک ہی خالی ہے تو ، وہ ایک جیسے نہیں ہیں اگر ٹری 1 کوئی نہیں ہے یا ٹری 2 کوئی نہیں ہے: غلط واپس کریں غلط# چیک کریں کہ آیا موجودہ نوڈس کی اقدار برابر ہیں اگر درخت 1۔ول!.آئی ایس_جینیکل فنکشن ان پٹ کے طور پر دو بائنری درخت (ٹری 1 اور ٹری 2) لیتا ہے اور بار بار ان کے نوڈس کا موازنہ کرتا ہے۔ اگر دونوں درخت خالی ہیں تو فنکشن پہلے چیک کرتا ہے۔اگر ایسا ہے تو ، یہ سچ واپس آجاتا ہے کیونکہ خالی درختوں کو یکساں سمجھا جاتا ہے۔اگر درختوں میں سے صرف ایک ہی خالی ہے تو ، یہ غلط لوٹتا ہے کیونکہ وہ ایک جیسے نہیں ہوسکتے ہیں۔ Next ، یہ چیک کرتا ہے کہ کیا دونوں درختوں میں موجودہ نوڈس کی اقدار برابر ہیں۔اگر نہیں تو ، یہ غلط لوٹتا ہے کیونکہ درخت ایک جیسے نہیں ہوتے ہیں۔نتیجہ صرف اس صورت میں درست ہے جب دونوں سبٹری ایک جیسے ہوں۔ آپ دو بائنری درخت بنا سکتے ہیں اور اس بات کا تعین کرنے کے لئے کہ وہ ایک جیسے ہیں یا نہیں ، IS_IDENTICAL فنکشن کو کال کرسکتے ہیں۔مثال کے طور پر: پائیتھون کوپی کوڈ# مثال ٹریسٹری 1 = ٹرینوڈ (1) ٹری 1. لیفٹ = ٹرینوڈ (2) ٹری 1. رائٹ = ٹرینوڈ (3) ٹری 2 = ٹرینوڈ (1) درخت 2. لیفٹ = ٹرینوڈ (2) ٹری 2. رائٹ = ٹرینوڈ (3)# چیک کریں کہ آیا درخت ایک جیسے ہیں۔، آؤٹ پٹ \"درخت ایک جیسے ہیں\" ہوں گے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ٹری پر پری آرڈر ٹری ٹریورسل انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "شروع سے ایک مکمل ہیش ٹیبل پر عمل درآمد کرنا ایک پیچیدہ کام ہوسکتا ہے۔تاہم ، میں آپ کو ایک بنیادی تفہیم فراہم کرنے کے لئے آپ کو ازگر میں ہیش ٹیبل کا آسان نفاذ فراہم کرسکتا ہوں۔یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ہیش ٹیبل: ڈیف __init __ (خود ، سائز): سیلف۔ سائز = سائز سیلف۔ ٹیبل = [] _ میں _ کے لئے (سائز)] Def _hash_function (خود ، کلید): ریٹرن ہیش (کلید)٪ سیلف ڈف داخل کریں (خود ، کلید ، قدر): انڈیکس = سیلف۔بالٹی [i] = (کلیدی ، قدر) لوٹ بکٹ.ایپینڈ ((کلیدی ، قدر)) ڈیف سرچ (خود ، کلید): انڈیکس = سیلف۔بالٹی: اگر k == key: واپسی v واپس کوئی نہیں ڈیف ڈیلیٹ (خود ، کلید): انڈیکس = سیلف۔اگر K == KEY: ڈیل بالٹی [i] ریٹرن ڈیف ڈسپلے (خود): I کے لئے ، بالٹی میں گنتی (خود. ٹیبل): پرنٹ (f \"بالٹی {i}: {بالٹی}\") اس عمل میں ، ہیش ٹیبلکلاس ایک بنیادی ہیش ٹیبل کی نمائندگی کرتا ہے۔اس میں بالٹیوں کو ذخیرہ کرنے کے لئے ایک فہرست استعمال کی گئی ہے ، جہاں ہر بالٹی کلیدی قدر کے جوڑے کی ایک فہرست ہے۔ _hash_function کا طریقہ بلٹ میں ہیش فنکشن کا استعمال کرتے ہوئے دیئے گئے کلید کی ہیش ویلیو کا حساب لگاتا ہے اور ہیش ٹیبل کے سائز کے ذریعہ ماڈیولو ڈویژن انجام دیتا ہے۔اس انڈیکس کا تعین کریں جہاں کلیدی قدر کی جوڑی کو ذخیرہ کرنا چاہئے۔ داخل کرنے کا طریقہ ہیش ٹیبل میں کلیدی قدر کی جوڑی داخل کرتا ہے۔یہ سب سے پہلے ہیش فنکشن کا استعمال کرتے ہوئے انڈیکس کا حساب لگاتا ہے ، پھر بالٹی کے ذریعے تکرار کرتا ہے تاکہ یہ معلوم کیا جاسکے کہ کلید پہلے سے موجود ہے یا نہیں۔اگر مل گیا تو ، یہ اسی قدر کو اپ ڈیٹ کرتا ہے۔اگر نہیں ملا تو ، یہ نئی کلیدی قدر کی جوڑی کو بالٹی میں شامل کرتا ہے۔ تلاش کا طریقہ ہیش ٹیبل میں کسی کلید کی تلاش کرتا ہے اور اگر مل گیا تو اس کی اسی قدر کو لوٹاتا ہے۔یہ ہیش فنکشن کا استعمال کرتے ہوئے انڈیکس کا حساب لگاتا ہے اور کلید کے لئے بالٹی کو تلاش کرتا ہے۔ حذف کرنے کا طریقہ ہیش ٹیبل سے کلیدی قدر کی جوڑی کو ہٹا دیتا ہے۔یہ ہیش فنکشن کا استعمال کرتے ہوئے انڈیکس کا حساب لگاتا ہے اور حذف کرنے کے لئے کلید کے لئے بالٹی کو تلاش کرتا ہے۔ ڈسپلے کا طریقہ ہیش ٹیبل کے مندرجات کو پرنٹ کرتا ہے ، بالٹی کے ذریعہ بالٹی ، بصری اور ڈیبگنگ مقاصد کے لئے۔ آپ ہیش ٹیبل کلاس اور استعمال کی مثال بنا سکتے ہیں۔ہیش ٹیبل کے ساتھ بات چیت کرنے کے اس کے طریقے۔یہاں ایک مثال کا استعمال ہے: پائیتھون کوپی کوڈ ہش_ٹیبل = ہیش ٹیبل (10) ہیش_ٹیبل.نسرٹ (\"ایپل\" ، 5) ہیش_ٹیبل.نسرٹ (\"کیلے\" ، 7) ہیش_ٹیبل.نسرٹ (\"سنتری\" ، 3) پرنٹ (ہیش_ٹیبل.چارچ (\"ایپل (\" ایپل)\") # آؤٹ پٹ: 5 پرنٹ (ہیش_ٹیبل.سارچ (\" انگور \")) # آؤٹ پٹ: کوئی بھی نہیں ہاش_ٹیبل.ڈیلیٹ (\" کیلے \") ہیش_ٹیبل.ڈیس پلے () اس مثال میں ، ہم 10 کے سائز کے ساتھ ہیش ٹیبل بناتے ہیں۔ ہم داخل کرتے ہیں۔کلیدی قدر کے تین جوڑے ، کلیدی \"ایپل\" (جو 5 لوٹتے ہیں) سے وابستہ قدر کی تلاش کریں ، غیر موجود کلید \"انگور\" (جو کوئی نہیں لوٹتے ہیں) کی تلاش کریں ، اور کلیدی \"کیلے\" کو حذف کریں۔آخر میں ، ہم ہیش ٹیبل کے مندرجات کو ظاہر کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے ل you ، آپ \"کوئیک سلیکٹ\" الگورتھم نامی کوئکسورٹ الگورتھم کی مختلف حالتوں کا استعمال کرسکتے ہیں۔خیال یہ ہے کہ محور عنصر کا استعمال کرتے ہوئے صف کو تقسیم کیا جائے اور پیوٹ کی نسبتہ پوزیشن کی بنیاد پر تقسیم کے مطلوبہ پہلو پر بار بار توجہ مرکوز کی جائے۔ ہر کی مثال ازگر میں ایک مثال کے طور پر عمل درآمد: پائیتھون کوپی کوڈ ڈیف فائنڈ_ کےتھ_لارجسٹ (نمبر ، کے): # صف کو دوبارہ ترتیب دیںکوئیک سلیکٹ الگورتھم # کا استعمال کرتے ہوئے # جب تک کہ کے ٹی ایچ کا سب سے بڑا عنصر اپنی ترتیب شدہ پوزیشن میں نہ ہو تو کوئیک_ سلیکٹ (نمبرز ، 0 ، لین (نمبر) - 1 ، کے) ڈیف کوئیک_ سلیکٹ (نمبرز ، کم ، اونچائی ، کے): # تقسیم کریں سرنی اور اس کو حاصل کریںپیوٹ انڈیکس PIVOT_INDEX = پارٹیشن (نمبر ، کم ، اونچا) # محور انڈیکس کی پوزیشن چیک کریں اگر Pivot_index == لین (نمبر) - K: # محور KTH کا سب سے بڑا عنصر ریٹرن نمبر ہے [Pivot_index] Elif Pivot_index> len (nums (nums) - K: # KTH کا سب سے بڑا عنصر محور کے بائیں طرف ہے quick_select (nums ، low ، Pivot_index - 1 ، k) اور: # کے ٹی ایچ کا سب سے بڑا عنصر محور کے دائیں طرف ہے quick_select (nums ،PIVOT_INDEX + 1 ، اعلی ، کے) ڈیف پارٹیشن (نمبرز ، کم ، اونچائی): # آخری عنصر کو پیوٹ پائیوٹ = نمبر [اعلی] i = J کے لئے کم (کم ، اعلی) کے طور پر منتخب کریں: # منتقل عناصر سے چھوٹے سے چھوٹے سے منتقل کریںبائیں طرف محور اگر نمبر [j] <محور: نمبر [i] ، nums [j] = nums [j] ، nums [i] i += 1 # محور کو اس کی ترتیب شدہ پوزیشن نمبر [i] ، nums میں رکھیں[اعلی] = نمبر [اعلی] ، نمبر [i] واپسی کی مثال کے طور پر استعمال کریں: پائیتھون کوپی کوڈینومز = [3 ، 1 ، 8 ، 4 ، 6 ، 2] K = 3Result = Find_kth_largest (نمبر ، K) پرنٹ (F \"f\" m \"{K} ویں سب سے بڑا عنصر یہ ہے: {نتیجہ} \") اس مثال میں ، ان پٹ سرنی [3 ، 1 ، 8 ، 4 ، 6 ، 2] ہے ، اور ہم تیسرا سب سے بڑا عنصر تلاش کرنا چاہتے ہیں۔پیداوار 4 ہوگی ، جو صف میں تیسرا سب سے بڑا عنصر ہے۔کوئیک سلیکٹ الگورتھم مؤثر طریقے سے محور کے گرد صفوں کو تقسیم کرتا ہے اور جب تک کے ٹی ایچ ٹی کا سب سے بڑا عنصر نہیں مل جاتا ہے اس وقت تک اس کی تلاش کو تقسیم کے مطلوبہ پہلو تک پہنچاتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ٹیکسٹ سٹرنگ میں پیٹرن کے واقعات کی تعداد کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ازگر میں سرکلر بفر ڈیٹا ڈھانچے کا نفاذ ہے: پائیتھون کوپی کوڈکلاس سرکلر بفر: ڈیف __ __init __ (خود ، صلاحیت): خود کی صلاحیت = صلاحیت خود ۔بفر = [کوئی نہیں] * صلاحیت سیلف ہیڈ = 0 سیلف۔ ٹیل = 0 خود۔سائز = 0 Def is_empty (self): sellسرکلر بفر بھرا ہوا ہے \") سیلف۔ بفر [خود۔ ٹیل] = آئٹم سیلف۔استثناء کو بڑھاؤ (\"سرکلر بفر خالی ہے\") آئٹم = سیلف.بفر [سیلف ہیڈ] سیلف۔ بفر [خود۔ ہیڈ] = کوئی نہیں۔ خود نہیں۔1 ریٹرن آئٹم ڈیف جھانکنے (خود): اگر سیلف۔ آئی ایس_پٹی (): استثناء بڑھاؤ (\"سرکلر بفر خالی ہے\") سیلف۔ بفر [سیلف ہیڈ] ڈیف ڈسپلے (خود): پرنٹ (سیلف۔ بفر) سرکلر بفر کلاسسرکلر بفر ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس کی ابتدا کسی صلاحیت کے ساتھ کی گئی ہے ، اور بفر مخصوص صلاحیت کے حامل کسی بھی قدر کی فہرست کے طور پر تشکیل دیا گیا ہے۔ آئی ایس_پٹی () طریقہ چیک کرتا ہے اگر بفر 0. سے سائز کا موازنہ کرکے۔سائز کی صلاحیت سے موازنہ کرکے بھرا ہوا ہے۔ انکیو (آئٹم) کا طریقہ بفر میں کسی شے کو شامل کرتا ہے۔یہ چیک کرتا ہے کہ آیا بفر پہلے ہی بھرا ہوا ہے اور اگر یہ ہے تو اس میں استثناء اٹھاتا ہے۔آئٹم ٹیل انڈیکس پر رکھا گیا ہے ، اور اس کے مطابق دم کو اپ ڈیٹ کیا جاتا ہے۔سائز میں اضافہ کیا جاتا ہے۔ ڈی کیوئ () کا طریقہ بفر کے سر پر آئٹم کو ہٹاتا ہے اور لوٹاتا ہے۔یہ چیک کرتا ہے کہ آیا بفر خالی ہے اور اگر یہ ہے تو اس میں استثناء اٹھاتا ہے۔ہیڈ انڈیکس میں موجود آئٹم کو بازیافت کیا جاتا ہے ، اور اس کے مطابق سر کو اپ ڈیٹ کیا جاتا ہے۔سائز میں کمی کی جاتی ہے۔ جھانکنے والا () طریقہ بفر کے سر پر آئٹم کو اسے ہٹائے بغیر لوٹاتا ہے۔یہ جانچ پڑتال کرتا ہے کہ اگر بفر خالی ہے اور اگر یہ ہے تو یہ استثناء اٹھاتا ہے۔ اگر ڈسپلے () کا طریقہ بفر کے مندرجات کو آسانی سے پرنٹ کرتا ہے۔ یہاں ایک مثال استعمال ہے: پائیتھون کوپی کوڈبفر = سرکلر بفر (5) بفر.نکیو (1) بفر.نکیو (بفر.نکیو ((1) بفر.نکیو (1)2) بفر۔ انکیو (3) بفر۔ انکیو (4) بفر۔ انکیو (5) بفر۔ ڈس پلے () # آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 4 ، 5] آئٹم = بفر.ڈیکیو () پرنٹ (ایف \"dequeued آئٹم: {آئٹم} \") # آؤٹ پٹ: dequeued آئٹم: 1buffer.enqueue (6) بفر۔ ڈس پلے () # آؤٹ پٹ: [6 ، 2 ، 3 ، 4 ، 5] جھانکنے والا_ آئٹم = بفر.پیک () پرنٹ (ایف\"جھانکنے والی شے: {جھانکنے والا_ آئٹم} \") # آؤٹ پٹ: جھانکنے والی شے: 6 ان مثال کے طور پر ، 5 کی گنجائش والا سرکلر بفر تشکیل دیا گیا ہے۔اشیا لگائے جاتے ہیں ، ڈیکوئڈ اور جھانکتے ہیں۔اس عمل کے مختلف مقامات پر بفر کے مندرجات دکھائے جاتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ریڈکس ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ازگر میں چوڑائی کی پہلی تلاش (بی ایف ایس) الگورتھم کا ایک مثال ہے: پائیتھون کوپی کوڈفرم کلیکشن درآمد ڈیکیڈف بی ایف ایس (گراف ، اسٹارٹ): ملاحظہ کریں = سیٹ () قطار = ڈیک ([اسٹارٹ]) ملاحظہ کریں۔نوڈ = قطار.پوپلفٹ () پرنٹ (نوڈ ، اینڈ = \"\") # گراف میں پڑوسی کے لئے نوڈ (یا کوئی مطلوبہ آپریشن کریں) پر کارروائی کریں [نوڈ]: اگر پڑوسی میں نہیں ملاحظہ کریں: قطار۔ اپینڈ (پڑوسی) ملاحظہ کریں۔(پڑوسی)# مثال گراف جس کی نمائندگی ملحقہ فہرست گراف = {'A': ['B' ، 'C'] ، 'B': ['a' ، 'd' ، 'e'] ، 'C': ['a' ، 'f'] ، 'd': ['b'] ، 'e': ['b' ، 'f'] ، 'f': ['c' ، 'e']} start_node = 'a'print (\"BFS Traversal:\") BFS (گراف ، اسٹارٹ_نوڈ) اس مثال میں ، ہمارے پاس ایک گراف ہے جس کی نمائندگی ملحقہ فہرست کے طور پر کی جاتی ہے۔گراف ڈکشنری عمودی کو چابیاں اور ان سے ملحقہ ملحقہ عمودی کو اقدار کے طور پر اسٹور کرتی ہے۔بی ایف ایس فنکشن مخصوص اسٹارٹ نوڈ سے شروع ہونے والے گراف پر چوڑائی کی پہلی تلاش انجام دیتا ہے۔ الگورتھم نوڈس کو دیکھنے کے لئے ٹریک رکھنے کے لئے ایک قطار (ڈیک کا استعمال کرتے ہوئے) استعمال کرتا ہے۔اس کا آغاز قطار میں اسٹارٹ نوڈ کو شامل کرکے اور اسے ملاحظہ کے ساتھ نشان زد کرکے شروع ہوتا ہے۔جب قطار میں نوڈس موجود ہیں ، تو یہ نوڈ کی حمایت کرتا ہے ، اس پر کارروائی کرتا ہے (یا کوئی مطلوبہ آپریشن انجام دیتا ہے) ، اور اس کے غیر منحصر پڑوسیوں کو قطار میں شامل کرتا ہے۔پڑوسیوں کو بھی ان پر نظر ثانی کرنے سے بچنے کے لئے بھی نشان زد کیا جاتا ہے۔ مثال کے طور پر ، بی ایف ایس ٹریورسل نوڈ 'اے' سے شروع ہوتا ہے۔آؤٹ پٹ چوڑائی کے پہلے ترتیب میں نوڈس کا دورہ کیا جائے گا: 'A' ، 'B' ، 'C' ، 'D' ، 'E' ، 'F'۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "ایک ترتیب شدہ لنکڈ فہرست میں بائنری سرچ الگورتھم کو نافذ کرنے کے ل we ، ہمیں فہرست کی ترتیب شدہ نوعیت سے فائدہ اٹھانے اور بائنری تلاش کا ایک ترمیم شدہ ورژن انجام دینے کی ضرورت ہے۔ازگر میں ایک مثال کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس لسٹنوڈ: ڈیف __init __ (خود ، ویل = 0 ، اگلا = کوئی نہیں): سیلف.وال = ویل سیلف۔ نیکسٹ = نیکسٹ ڈیف بائنری_سرچ (سر ، ہدف): بائیں ، دائیں = سر ، جبکہ کوئی نہیںبائیں! = دائیں: درمیانی = get_middle (بائیں ، دائیں) اگر درمیانی.اول == ہدف: مڈ ایلیف مڈ.ول <ہدف: بائیں = وسط۔ نیکسٹ لوٹ کریں: دائیں = وسط ریٹرن نونیڈف گیٹ_مڈل (بائیں ، دائیں): سست= بائیں بازو کے دوران بائیں بازو کی بائیں!> 4 -> 5 ہیڈ = لسٹنوڈ (1) نوڈ 2 = لسٹنوڈ (2) نوڈ 3 = لسٹنوڈ (3) نوڈ 4 = لسٹنوڈ (4) نوڈ 5 = لسٹنوڈ (5) ہیڈ. نیکسٹ = نوڈ 2 نوڈ 2. نوڈ 3 نوڈ 3. نیکسٹ = نوڈ 4 نوڈ 4. نیکسٹ =نوڈ 5 ٹارجٹ = 3result = بائنری_سرچ (ہیڈ ، ہدف) اگر نتیجہ: پرنٹ (f \"found: {نتیجہ. Val}\") اور: پرنٹ (\"نہیں ملا\") اس مثال میں ، ہم پہلے نوڈس کی نمائندگی کرنے کے لئے لسٹنوڈ کلاس کی وضاحت کرتے ہیں۔منسلک فہرستہر نوڈ میں ایک ویلیو (ویل) اور اگلے نوڈ (اگلا) کا حوالہ ہوتا ہے۔ بائنری_سرچ فنکشن ترتیب شدہ لنکڈ فہرست اور ان پٹ کے بطور ہدف کی قیمت کا سر لیتا ہے۔یہ دو پوائنٹرز ، بائیں اور دائیں کو برقرار رکھتے ہوئے بائنری سرچ الگورتھم کو انجام دیتا ہے۔بائیں پوائنٹر ابتدائی طور پر اس فہرست کے سربراہ کی طرف اشارہ کرتا ہے ، اور دائیں پوائنٹر ابتدائی طور پر کسی کو بھی مقرر کیا جاتا ہے۔الگورتھم تکراری طور پر بائیں یا دائیں پوائنٹر کو ہدف کی قیمت کے ساتھ درمیانی نوڈ کی قیمت کے موازنہ کی بنیاد پر اپ ڈیٹ کرتا ہے۔درمیانی نوڈ get_middle فنکشن کا استعمال کرتے ہوئے حاصل کیا جاتا ہے۔ get_middle فنکشن سست اور فاسٹ پوائنٹر تکنیک کا استعمال کرتے ہوئے لنکڈ فہرست کا درمیانی نوڈ تلاش کرتا ہے۔سست پوائنٹر ایک وقت میں ایک قدم آگے بڑھتا ہے ، جبکہ تیز رفتار پوائنٹر ایک وقت میں دو قدم آگے بڑھتا ہے۔جب فاسٹ پوائنٹر فہرست کے اختتام یا نوڈ کے اختتام سے عین قبل پہنچ جاتا ہے تو ، سست پوائنٹر مڈل نوڈ پر ہوگا۔ مثال کے طور پر ، ہم اقدار 1 ، 2 ، 3 ، 4 ، اور 5 کے ساتھ ایک ترتیب شدہ منسلک فہرست بناتے ہیں۔. ہم 3 کی ہدف کی قیمت تلاش کرنے کے لئے بائنری تلاش کرتے ہیں۔ آؤٹ پٹ \"پایا: 3\" ہوگا کیونکہ لنکڈ فہرست میں ہدف کی قیمت موجود ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں ایک پروگرام یہ ہے کہ اس بات کا تعین کرنے کے لئے کہ آیا دیئے گئے سٹرنگ ایک پالندرووم ہے: پائیتھون کوپی کوڈیڈف is_palindrome (s): s = s.lower () # کیس کو غیر حساس موازنہ کے لئے چھوٹے حصے میں تبدیل کریں = 0 دائیں = لین (s) - 1جبکہ بائیں <دائیں: اگر نہیں [بائیں] .isalnum (): # بائیں بائیں طرف سے غیر الفانومرک حروف کو نظرانداز کریں += 1 الیف نہیں ہے [دائیں] .isalnum (): # دائیں دائیں طرف سے غیر الفینومیرک حروف کو نظرانداز کریں-=1 الیف ایس [بائیں]! = s [دائیں]: # حرفوں کا موازنہ غلط لوٹتے ہیں اور: بائیں += 1 دائیں -= 1 سچائی # مثال usagestring1 = \"ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما\" پرنٹ (is_palindrome (is_palindrome (سٹرنگ 1)) # آؤٹ پٹ: truestring2 = \"ریسکار\" پرنٹ (is_palindrome (string2)) # آؤٹ پٹ: truestring3 = \"ہیلو\" پرنٹ (is_palindrome (string3)) # آؤٹ پٹ: اس پروگرام کو فالین کریں ، is_palindrome فنکشن ان پٹ کے طور پر سٹرنگ لیتا ہے اوراگر سٹرنگ ایک پیلنڈرووم ہے ، اور غلط ہے تو سچائی لوٹتی ہے۔ یہ فنکشن دو پوائنٹرز ، بائیں اور دائیں استعمال کرتا ہے ، جو بالترتیب سٹرنگ کے آغاز اور اختتام تک شروع ہوتا ہے۔یہ تار کے مرکز کی طرف اندر کی طرف بڑھتے ہوئے بائیں اور دائیں اشاریہ کے حروف کا موازنہ کرتا ہے۔ الگورتھم مندرجہ ذیل اقدامات انجام دیتا ہے: کیس کو غیر حساس موازنہ انجام دینے کے لئے نچلے () کے طریقہ کار کا استعمال کرتے ہوئے سٹرنگ کو لوئر کیس میں تبدیل کریں۔یہ جانچ پڑتال کرتا ہے کہ آیا بائیں اور دائیں انڈیکس کے حروف isalnum () کے طریقہ کار کا استعمال کرتے ہوئے حرفی عمر کے ہیں۔غیر الفانومرک کرداروں کو نظرانداز کیا جاتا ہے اور اس کے مطابق متعلقہ پوائنٹر کو بڑھایا جاتا ہے یا اس کے مطابق کم کیا جاتا ہے۔ اگر بائیں اور دائیں اشاریہ کے حروف حرفی ہیں اور برابر نہیں ہیں تو ، یہ جھوٹا لوٹتا ہے کیونکہ تار نہیں ہوتا ہے۔برابر بنیں ، یہ سچ واپس آتا ہے کیونکہ تار ایک palindrome ہے۔ مثال کے طور پر ، ہم مختلف تار کے ساتھ IS_Palindrome فنکشن کی جانچ کرتے ہیں۔پہلے دو ڈور ، \"ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما\" اور \"ریسکار\" ، پیلیندرووم ہیں اور سچائی لوٹتے ہیں۔تیسرا تار ، \"ہیلو\" ، کوئی پیلنڈرووم نہیں ہے اور غلط لوٹتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا کوئی گراف ٹائپ اسکرپٹ کا استعمال کرتے ہوئے درخت ہے یا نہیں۔",
        "Answer": "یقینا!ازگر میں بائنری ہیپ کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس بائنری ہیپ: ڈیف __init __ (خود): سیلف۔ ہیپ = [] ڈیف سائز (خود): ریٹرن لین (سیلف۔ ہیپ) ڈیف آئی ایس ای ایم پی (سیلف): ریٹرن لین (واپس (خود)self.heap) == 0 Def داخل کریں (خود ، آئٹم): سیلف.اپ.اپی اینڈ (آئٹم) سیلف۔اگر سیلف۔..heap [والدین] ، سیلف۔ ہیپ [اشاریہ] انڈیکس = والدین والدین = (انڈیکس - 1) // 2 ڈیف _ ہیپائیف_ ڈاون (سیلف ، انڈیکس): بائیں_چند = 2 * انڈیکس + 1 رائٹ_چلڈ = 2 * انڈیکس + 2 سب سے چھوٹا = انڈیکساگر بائیں_چھال <سیلف۔ سائز () اور سیلف۔ ہیپ [بائیں_چھا] <سیلف پی ایچ ای اے پی [سب سے چھوٹا]: سب سے چھوٹا = بائیں_چھال اگر دائیں_چال <سیلف۔= دائیں_چند اگر سب سے چھوٹا ہے! = انڈیکس: سیلف۔ ہیپ [انڈیکس] ، سیلف۔ ہیپ [سب سے چھوٹا] = سیلف۔ ہیپ [سب سے چھوٹا] ، سیلف۔ ہیپ [انڈیکس] سیلف۔بائنری منڈی۔ڈھیر کو ایک فہرست کے طور پر محفوظ کیا جاتا ہے ، جہاں ہر عنصر ڈھیر میں ایک نوڈ کی نمائندگی کرتا ہے۔ کلاس مندرجہ ذیل طریقے مہیا کرتا ہے: سائز (): ہیپ میں عناصر کی تعداد لوٹاتا ہے۔ IS_EMPTY (): اگر ڈھیر خالی ہے تو چیک کرتا ہے۔(آئٹم): ڈھیر کی پراپرٹی کو برقرار رکھتے ہوئے ڈھیر میں کسی شے کو داخل کرتا ہے۔یہ آئٹم کو فہرست کے آخر میں شامل کرتا ہے اور ہیپائیو_پ آپریشن کو انجام دیتا ہے تاکہ یہ یقینی بنایا جاسکے کہ ہیپ پراپرٹی کو محفوظ بنایا گیا ہے۔ ڈیلیٹ_مین (): ڈھیر سے کم سے کم (جڑ) عنصر کو ہٹا کر واپس کرتا ہے۔یہ فہرست میں آخری عنصر کے ساتھ جڑ عنصر کی جگہ لے لیتا ہے ، آخری عنصر کو ہٹاتا ہے ، اور ہیپ پراپرٹی کو برقرار رکھنے کے لئے ہیپیفائی_ ڈاون آپریشن انجام دیتا ہے۔یہ دیئے گئے انڈیکس کے عنصر کا اپنے والدین کے ساتھ موازنہ کرتا ہے اور اگر ضروری ہو تو ان کو تبدیل کرتا ہے ، بار بار ڈھیر کو اوپر منتقل کرتا ہے جب تک کہ عنصر اپنی صحیح پوزیشن میں نہ ہو۔یہ دیئے گئے انڈیکس کے عنصر کا موازنہ اپنے بچوں کے ساتھ کرتا ہے اور اگر ضروری ہو تو ان کو تبدیل کرتا ہے ، جب تک کہ عنصر اپنی صحیح پوزیشن میں نہ ہو اس وقت تک ڈھیر سے نیچے منتقل ہوتا ہے۔مثال کے طور پر: پائیٹون کوپی کوڈ# ایک بائنری ہیپیپ = بائنری ہیپ ()# ہیپیپ. Insert (5) ہیپ.نسرٹ (3) ہیپ.سرٹ (8) ہیپ.سانٹ (1) ہیپ.سرٹ (9)# میں عنصر بنائیںکم سے کم عنصر مین_ایلیمنٹ = ہیپ.ڈیلیٹ_مین () پرنٹ (MIN_ELENTME) # آؤٹ پٹ کو حذف کریں: 1 # ہیپرنٹ (ہیپ.سائز ()) # آؤٹ پٹ کا سائز چیک کریں: 4 # چیک کریں کہ ہیپ خالی پرنٹ ہے (ہیپ.س_پٹی ())# آؤٹ پٹ: غلط"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں فبونیکی ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں ایک پروگرام یہ ہے کہ اگر دیئے گئے بائنری ٹری متوازن ہے تو اس بات کا تعین کرنے کے لئے کہ پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، قدر): سیلف ویلیو = ویلیو خود۔کوئی نہیں: سچ # # بائیں اور دائیں subtres کے درمیان اونچائی کے فرق کو چیک کریںسبٹریز متوازن ہیں۔نوڈ۔ رائٹ)# موجودہ نوڈ ریٹرن میکس (بائیں_ہائٹ ، رائٹ_ہائٹ) کے لئے بائیں اور دائیں سبٹریس کے درمیان زیادہ سے زیادہ اونچائی واپس کریں + 1# مثال کے استعمال# بائنری ٹریروٹ = ٹرینوڈ (1) روٹ. لیفٹ = ٹرینوڈ (ٹرینیوڈ بنائیں (1)2) جڑ۔ٹرینوڈ (2) روٹ۔ رائٹ = ٹرینوڈ (3) روٹ. لیفٹ.لیفٹ = ٹرینوڈ (4) روٹ. رائٹ. رائٹ۔ رائٹ = ٹرینوڈ (5) پرنٹ (is_balanced (روٹ)) # آؤٹ پٹ: یہ پروگرام سچ ہے ، ٹرینوڈ کلاس نمائندگی کرتا ہےبائنری درخت میں ایک نوڈ۔ہر نوڈ کی ایک قدر اور اس کے بائیں اور دائیں بچوں کا حوالہ ہوتا ہے۔ آئی ایس_بلنسڈ فنکشن بائنری درخت کی جڑ کو ان پٹ کے طور پر لے جاتا ہے اور اگر درخت متوازن ہے ، اور غلط ہے تو وہ سچ ہے۔اس فنکشن میں درخت کے توازن کی جانچ پڑتال کے لئے ایک تکرار نقطہ نظر کا استعمال ہوتا ہے۔ get_height فنکشن ایک مددگار فنکشن ہے جو درخت میں نوڈ کی اونچائی کا حساب لگاتا ہے۔یہ بار بار بائیں اور دائیں سبٹریس کی اونچائی کا حساب لگاتا ہے اور موجودہ نوڈ کے لئے زیادہ سے زیادہ اونچائی کے علاوہ 1 کو لوٹاتا ہے۔ اگر موجودہ نوڈ کے بائیں اور دائیں سب ٹریوں کے درمیان اونچائی میں مطلق فرق 1. سے زیادہ ہے تو آئی ایس_ بیلنس فنکشن چیک کرتا ہے۔ہے ، درخت متوازن نہیں ہے ، اور فنکشن غلط لوٹتا ہے۔بصورت دیگر ، یہ بار بار بائیں اور دائیں دونوں ذیلی ذیلی ذخیروں کے توازن کی جانچ پڑتال کرتا ہے۔پہلا درخت متوازن نہیں ہے ، کیوں کہ جڑ کے بائیں اور دائیں ذیلی ذیلی حصے کے درمیان اونچائی کا فرق 1 سے زیادہ ہے۔ دوسرا درخت متوازن ہے ، کیونکہ سب ٹریوں کے مابین اونچائی کا فرق زیادہ سے زیادہ 1 ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ٹری پر پوسٹ آرڈر ٹری ٹریورسل کو انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ازگر میں ٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس ٹرائینوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈین = {} sellخود ، لفظ): موجودہ = خود۔، لفظ): کرنٹ = سیلف۔ لفظ میں چار کے لئے: اگر کرنٹ میں نہیں ہے۔ اگر موجودہ میں نہیں۔ بچوں کو واپس کریں = موجودہ = موجودہ۔ چائلڈین [چار] واپس کریں۔پریفکس میں چار: اگر کرنٹ میں نہیں۔ بچوں کو واپس کریں۔\") trie.insert (\" CAR \") trie.Insert (\" CAT \") # ٹری پرنٹ (trie.search (\" ایپل \")) میں الفاظ تلاش کریں # آؤٹ پٹ: ٹروپنٹ (trie.search (\" کیلے \")) #آؤٹ پٹ: ٹروپنٹ (ٹری.سرچ (\"کار\")) # آؤٹ پٹ: ٹروپنٹ (ٹری.سرچ (\"بلی\")) # آؤٹ پٹ: ٹروپنٹ (ٹری.سرچ (\"کتا\")) # آؤٹ پٹ: غلط # چیک کریں کہ آیا سابقہ موجود ہے یا نہیںٹری پرنٹ میں (trie.starts_with (\"ap\")) # آؤٹ پٹ: ٹری پرنٹ (trie.starts_with (\"BA\")) # آؤٹ پٹ: ٹری پرنٹ (trie.starts_with (\"CA\")) # آؤٹ پٹ: ٹری پرنٹ (ٹری پرنٹ (trie.starts_with (trie.starts_with\"D\")) # آؤٹ پٹ: اس پر عمل درآمد کو فالس ، ٹرائنوڈ کلاس ٹری میں ایک نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں ایک لغت کے بچے ہوتے ہیں جو ان کے متعلقہ بچوں کے نوڈس کے کرداروں کا نقشہ بناتے ہیں ، اور ایک بولین پرچم is_end_of_word کی نشاندہی کرتا ہے کہ آیا نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔ ٹری کلاس ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں ایک روٹ نوڈ ہے جو ٹرائی کے داخلی نقطہ کے طور پر کام کرتا ہے۔ داخل کرنے کا طریقہ ٹرائی میں ایک لفظ داخل کرتا ہے۔یہ لفظ میں ہر کردار پر تکرار کرتا ہے ، جس سے ضروری طور پر نئے نوڈس تیار ہوتے ہیں اور موجودہ نوڈ کو اپ ڈیٹ کرتے ہیں۔آخر میں ، یہ آخری نوڈ کے is_end_of_word پرچم کو سچ پر سیٹ کرتا ہے۔ تلاش کا طریقہ چیک کرتا ہے کہ اگر کوئی لفظ ٹرائی میں موجود ہے۔یہ ٹری کردار کو کردار کے لحاظ سے عبور کرتا ہے ، اگر موجودہ نوڈ کے بچوں میں کوئی کردار نہیں ملتا ہے تو جھوٹے کو واپس کرتا ہے۔اگر ٹریورسل کامیابی کے ساتھ مکمل ہوجاتی ہے اور آخری نوڈ کا is_end_of_word پرچم سچ ہے تو ، یہ سچ ہے۔یہ تلاش کے طریقہ کار کی طرح اسی طرح کی منطق کی پیروی کرتا ہے ، لیکن یہ is_end_of_word پرچم کی جانچ نہیں کرتا ہے اور اس کے بجائے اس وقت تک درست واپس آجاتا ہے جب تک کہ سابقہ ٹراورسل کامیاب ہوتا ہے۔ مثال کے طور پر ، ہم ایک سہ رخی بناتے ہیں اور اس میں متعدد الفاظ داخل کرتے ہیں۔اس کے بعد ، ہم مخصوص الفاظ کی تلاش کرتے ہیں اور چیک کرتے ہیں کہ آیا ٹرائی میں کچھ سابقہ موجود ہیں یا نہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ہدایت شدہ ایسائکلک گراف کے لئے ایک ٹوپولوجیکل ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!ملحقہ فہرست کا استعمال کرتے ہوئے نمائندگی کرنے والے گراف پر گہرائی سے پہلے تلاش (ڈی ایف ایس) انجام دینے کے لئے ازگر میں ایک پروگرام ہے: پائیتھون کوپی کوڈکلاس گراف: ڈیف __INIT __ (خود ، عمودی): سیلف.ورٹیس = ورٹیسس سیلف۔رینج میں (عمودی)] ڈیف ایڈ_ج (خود ، ایس آر سی ، ڈسٹ): سیلف ڈاٹ ایڈج_ لسٹ [ایس آر سی]] * سیلف .ورٹیسس سیلف۔ملاحظہ [پڑوسی]: سیلف۔، 4) گراف.اڈی_ج (2 ، 4) گراف.اڈی_ج (3 ، 4) گراف.اڈی_ج (3 ، 5) پرنٹ (\"گہرائی سے پہلے ٹراورسل (ڈی ایف ایس):\") اس پروگرام میں گراف ڈاٹ ڈی ایف ایس (0) ،گراف کلاس ملحقہ فہرست کا استعمال کرتے ہوئے غیر ہدایت شدہ گراف کی نمائندگی کرتا ہے۔عمودی وصف گراف میں عمودی کی تعداد کو ذخیرہ کرتا ہے ، اور ایڈ_ لسٹ وصف فہرستوں کی ایک فہرست ہے جہاں ہر سبلسٹ ایک عمودی کے پڑوسیوں کی نمائندگی کرتا ہے۔ ایڈ_ج کا طریقہ ملحقہ فہرست کو اپ ڈیٹ کرکے دو عمودی کے درمیان ایک کنارے کا اضافہ کرتا ہے۔ ڈی ایف ایس کا طریقہ کار پرفارم کرتا ہے۔گراف پر گہرائی کی پہلی تلاش۔یہ دورے کی فہرست کا آغاز کرتا ہے تاکہ ملاحظہ کی گئی فہرستوں کا سراغ لگایا جاسکے۔طریقہ کار _dfs_util کے طریقہ کار کو کال کرتا ہے ، جس میں ابتدائی عمودی اور ملاحظہ کی گئی فہرست کو دلائل کے طور پر منتقل کیا جاتا ہے۔یہ موجودہ چشم کشی کو نشان زد کرتا ہے ، اسے پرنٹ کرتا ہے ، اور پھر موجودہ ورٹیکس کے تمام غیر منحصر پڑوسیوں کے لئے خود کو بار بار کال کرتا ہے۔اس کے بعد ہم ورٹیکس 0 سے شروع ہونے والی گہرائی کی پہلی تلاش کرتے ہیں اور ٹراورسل آرڈر پرنٹ کرتے ہیں۔ آؤٹ پٹ گہرائی کا پہلا ٹراورسل آرڈر ہوگا: 0 1 3 4 2 5"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عدد کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "خود توازن رکھنے والے بائنری سرچ درخت کو نافذ کرنا ، جیسے اے وی ایل درخت یا سرخ رنگ کا درخت ، ایک پیچیدہ کام ہوسکتا ہے۔اس کے لئے درختوں کی گردشوں پر محتاط غور کرنے اور اضافے اور حذف ہونے کے دوران درخت کے توازن کے معیار کو برقرار رکھنے کی ضرورت ہے۔ذیل میں ازگر میں اے وی ایل کے درخت کا ایک آسان عمل درآمد ہے: پیتھون کوپی کوڈکلاس Avlnode: Def __Init __ (خود ، کلید): self.key = key self.left = کوئی بھی نہیں۔ کوئی خود نہیں۔): self.root = کوئی بھی Def get_height (سیلف ، نوڈ): اگر نوڈ کوئی نہیں ہے: واپس 0 واپسی نوڈ۔..y.left y.left = z z.right = t2 self.update_height (z) self.update_height (y) ریٹرن Y def داخل کریں (خود ، کلید): سیلف.روٹ = سیلف۔_ INSERT (خود ، نوڈ ، کلید): اگر نوڈ کوئی نہیں ہے: avlnode (key) واپس کریں اگر key <node.key: node.left = self._insert (node.left ، key) else: node.right = self._insert (نوڈ۔ رائٹ ، کلیدی) سیلف۔ اپ ڈیٹ_ہائٹ (نوڈ) بیلنس = سیلف۔گیٹ_ بیلنس (نوڈ) اگر توازن> 1: # بائیں سب ٹری بھاری ہے تو اگر کلید <نوڈ.لفٹ.کی: # بائیں بائیں کیس واپس کریں سیلف۔ رائٹ_روٹیٹ (نوڈ (نوڈ) دوسری: # بائیں دائیں کیس نوڈ۔حق کیس واپس سیلف۔ لیفٹ_روٹیٹ (نوڈ) اور: # دائیں بائیں کیس نوڈ۔) Def _inorder_traversal (خود ، نوڈ): اگر نوڈ کوئی نہیں ہے: سیلف۔.insert (10) درخت. insert (20) درخت. insert (30) درخت. insert (40) درخت. insert (50) درخت. insert (25) پرنٹ (\"inorder traversal:\") درخت. inorder_traversal () اس میںسادہ شدہ AVL درختوں کا نفاذ ، Avlnode کلاس درخت میں ایک نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں ایک کلید ، بائیں اور دائیں بچہ ہوتا ہے ، اور اس نوڈ پر جڑے ہوئے سب ٹری کی اونچائی کو ذخیرہ کرنے کے لئے اونچائی کا وصف ہوتا ہے۔ Avltree کلاس AVL درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے۔اس میں روٹ نوڈ کو ذخیرہ کرنے کے لئے ایک جڑ وصف ہے۔ get_height طریقہ نوڈ کی اونچائی کو لوٹاتا ہے ، اور اپ ڈیٹ_ہائٹ طریقہ اپنے بائیں اور دائیں سبٹریز کی اونچائی پر مبنی نوڈ کی اونچائی کو اپ ڈیٹ کرتا ہے۔ get_blance کا طریقہ توازن کا حساب لگاتا ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں لاحقہ سرنی ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہ ایک ازگر پروگرام ہے جو عددیوں کی ایک صف پر انضمام کی ترتیب الگورتھم کو انجام دیتا ہے: پائیتھون کوپی کوڈیڈف انضمام_سورٹ (اے آر آر): اگر لین (آر آر) <= 1: آر اے آر آر # آر # سرے کو دو حصوں میں تقسیم کریں = لین (آر اے آر) // 2بائیں_ہالف = آر [: وسط] دائیں_ہلف = آر آر [وسط:] # بار بار دو حصوں کو بائیں_ہالف = انضمام_سورٹ (بائیں_ہالف) کو ترتیب دیں۔، دائیں): ضم شدہ = [] i = j = 0 جبکہ میں <لین (بائیں) اور جے <لین (دائیں): اگر بائیں [i] <= دائیں [j]: ضم شدہ۔ اپینڈ (بائیں [i]) i+= 1 اور: ضم شدہ۔ اپینڈ (دائیں [j]) j += 1 # بائیں یا دائیں صف سے باقی عناصر شامل کریں جبکہ میں <لین (بائیں): ضم شدہ۔ اپینڈ (بائیں [i]) i += 1جبکہ جے <لین (دائیں): انضمام۔ اپینڈ (دائیں [j]) j += 1 واپسی ضم شدہ# مثال usagearr = [8 ، 2 ، 4 ، 1 ، 6 ، 9 ، 3 ، 5 ، 7 ، 7] shard_arr = انضمام_سورٹ (اے آر آر) پرنٹ (\"ترتیب شدہ سرنی:\" ، ترتیب شدہ_ار) اس پروگرام میں ، انضمام_سورٹ فنکشن انضمام کی ترتیب الگورتھم کو نافذ کرتا ہے۔یہ ان پٹ کے طور پر ایک سرنی آر آر لیتا ہے اور اسے بار بار دو حصوں میں تقسیم کرتا ہے جب تک کہ ہر آدھے میں ایک یا صفر عناصر نہ ہوں۔اس کے بعد ، یہ انضمام کے فنکشن کا استعمال کرتے ہوئے ترتیب شدہ آدھے حصے کو ضم کرتا ہے۔ انضمام کی تقریب دو ترتیب دی گئی صفوں ، بائیں اور دائیں لیتی ہے ، اور انہیں ایک ہی ترتیب شدہ صف میں ضم کرتی ہے۔اس میں بالترتیب بائیں اور دائیں صفوں میں تکرار کرنے کے لئے دو پوائنٹرز ، میں اور جے کا استعمال ہوتا ہے۔یہ موجودہ پوزیشنوں پر عناصر کا موازنہ کرتا ہے اور ضم شدہ صف میں چھوٹے عنصر کو شامل کرتا ہے۔صفوں میں سے ایک کے مکمل عمل کے بعد ، فنکشن دوسری صف سے باقی عناصر کو ضم شدہ صف میں شامل کرتا ہے۔ مثال کے طور پر استعمال میں ، ہم عدد کی ایک صف تیار کرتے ہیں ، [8 ، 2 ، 4 ، 1 ، 6 ، 9 ، 3، 5 ، 7] ، اور اس پر انضمام کی ترتیب الگورتھم انجام دیں۔ترتیب شدہ سرنی [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9] پھر پرنٹ کی جاتی ہے۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری درخت کا قطر تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "اسکیپ لسٹ ڈیٹا ڈھانچے پر عمل درآمد پیچیدہ ہوسکتا ہے اور اس میں مختلف اسکیپ لیول کے ساتھ منسلک فہرستوں کی متعدد پرتیں شامل ہیں۔ذیل میں ازگر میں اسکیپ لسٹ کا ایک آسان عمل درآمد ہے: پائیتھون کوپی کوڈیمپورٹ رینڈمکلاس اسکیپلسٹنوڈ: ڈیف __init __ (خود ، کلیدی ، قدر): سیلف ککی = کلیدی خود۔ ویلیو = ویلیو سیلف۔ نیکسٹ۔ نونکلاس اسکپلسٹ: ڈیف: ڈیف__init __ (خود): self.head = اسکیپلسٹنوڈ (کوئی نہیں ، کوئی بھی نہیں) سیلف۔ میکس_ لیول = 1 ڈیف سرچ (خود ، کلید): موجودہ = سیلف ہیڈ جبکہ موجودہ: اگر موجودہ نہیں ہے۔ نیکسٹ کوئی نہیں ہے یا موجودہ ہے۔: اگر موجودہ۔ ڈاون: موجودہ = موجودہ۔ ڈاون اور: توڑ ایلف کرنٹ۔ نیکسٹ.کی == کلید: ریٹرن کرنٹ۔ نیکسٹ۔ ویلیو اور: موجودہ = کرنٹ۔ نیکسٹ واپس کوئی نہیں ڈیف داخل کریں (خود ، کلیدی ، قیمت): سطح: سطح: سطح: سطح: سطح:= self.random_level () if level> max_level: self.max_level = سطح self.head.next = self.add_level (self.head.next ، کوئی بھی نہیں) موجودہ = سیل. ہیڈ نوڈس_پڈیٹ = [] جبکہ موجودہ: اگر موجودہ: اگر موجودہ: اگر موجودہ: اگر موجودہ:.next کوئی بھی نہیں ہے یا موجودہ نہیں۔ نیکسٹ.کی> کلید: اگر سطح> = لین (نوڈس_ٹو_پڈیٹ): نوڈ = سیلف۔ ایڈڈ_لیول (موجودہ۔ نیکسٹ ، کوئی بھی نہیں) نوڈس_ٹو_پیڈیٹ.ایپینڈ۔سطح] = self.add_level (nodes_to_update [سطح] ، کوئی نہیں) nodes_to_update [سطح] .key = key = key اگر سطح == 0: nodes_to_update [سطح]سطح - 1] اگر سطح <self.max_level: nodes_to_update [سطح]لوٹ لوٹ: کرنٹ = کرنٹ۔ نیکسٹ ڈیف ڈیلیٹ (خود ، کلید): موجودہ = سیلف ہیڈ جبکہ موجودہ کے دوران: اگر موجودہ نہیں ہے۔ نیکسٹ کوئی بھی نہیں ہے یا موجودہ نہیں ہے۔ نیکسٹ۔ ککی> کلید: موجودہ = موجودہ۔== کلید: موجودہ۔ نیکسٹ = کرنٹ۔ نیکسٹ۔ نیکسٹ۔ موجودہ = موجودہ۔ ڈاون اور: موجودہ = کرنٹ۔ نیکسٹ ڈیف بے ترتیب_لیول (خود): سطح = 1 جبکہ بے ترتیب۔ رینڈم () <0.5 اور سطح <سیلف۔ میکس_ لیول + 1: لیول += 1 ریٹرن لیول @اسٹیٹیمیٹوڈ ڈیف ایڈ_لیول (پریو_نوڈ ، نیکسٹ_نوڈ): نیا_نوڈ = اسکیپلسٹنوڈ (کوئی نہیں ، کوئی نہیں) نیا_نوڈ۔ نیکسٹ = اگلا_نوڈ اگر پریو_نوڈ: نیا_نوڈ ریٹرن نیو_نوڈ ڈیف پرنٹ_ لسٹ (خود): موجودہ = خود۔موجودہ کے دوران سر: نوڈ = موجودہ جبکہ نوڈ: پرنٹ (f \"({node.key}: {node.value})\" ، end = \" ->\") نوڈ = نوڈ۔ نیکسٹ پرنٹ (\"کوئی نہیں\") موجودہ = کرنٹ.down# مثال usageskip_list = skiplist () skip_list.insert (10 ، \"a\") skip_list.insert (5 ، \"b\") skip_list.insert (15 ، \"c\") skip_list.insert (7 ، \"d\") اسکیپ_ لسٹ.INSERT (12 ، \"E\") اسکیپ_ لسٹ.پرنٹ_ لسٹ () پرنٹ (\"تلاش 10:\" ، اسکیپ_ لسٹ.سارچ (10)) پرنٹ (\"تلاش 7:\" ، اسکیپ_ لسٹ (7)) اسکیپ_ لسٹ.ڈیلیٹ (7)پرنٹ (\"حذف کرنے کے بعد:\") اسکیپ_ لسٹ.پرنٹ_ لسٹ () اس آسان اسکیپ لسٹ پر عمل درآمد میں ، اسکیپلسٹنوڈ کلاس اسکیپ لسٹ میں ایک نوڈ کی نمائندگی کرتی ہے۔ہر نوڈ ہوتا ہے a"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بی+ ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں: پائیتھون کوپی کوڈیڈف ARE_ANAGRAMS (STR1 ، STR2): # وائٹ اسپیس کو ہٹا دیں اور تار کو لوئر کیس STR1 = str1.repleas (\"\" \") میں تبدیل کریں۔str2.replace (\"\" ، \"\") .lower () # چیک کریں کہ آیا تار کی لمبائی برابر ہے اگر لین (str1)! = لین (str2): غلط # دونوں تار کے لئے فریکوئینسی لغت بنائیں freq_dict1 = {} freq_dict2= {} # str1 میں str1 میں ہر کردار کی فریکوئنسی کو str1 میں شمار کریں: freq_dict1 [چار] = freq_dict1.get (چار ، 0) + 1 # str2 میں str2 میں ہر کردار کی فریکوئنسی کو str2 میں: freq_dict2 [چار]= freq_dict2.get (CHAR ، 0) + 1 # فریکوئنسی لغت کا موازنہ کریں freq_dict1 == freq_dict2 # مثال usagestring1 = \"سنیں\" سٹرنگ 2 = \"خاموش\" اگر ARE_ANAGRAMS (سٹرنگ 1 ، سٹرنگ 2): پرنٹ (F \"{سٹرنگ 1} اور {سٹرنگ 2 ag اناگرامس ہیں۔ \") اور: پرنٹ (ایف\" {سٹرنگ 1} اور {سٹرنگ 2 an اناگرام نہیں ہیں۔ \") یہ ہے کہ دو تار ، ایس ٹی آر 1 اور ایس ٹی آر 2 ، ایک دوسرے کے اناگرام ہیں۔یہ پہلے کسی بھی وائٹ اسپیس کو ہٹاتا ہے اور تاروں کو چھوٹے کیس میں تبدیل کرتا ہے تاکہ کیس غیر سنجیدہ موازنہ کو یقینی بنایا جاسکے۔ Next ، یہ ڈور کی لمبائی کا موازنہ کرتا ہے۔اگر لمبائی برابر نہیں ہے تو ، ڈور اناگرام نہیں ہوسکتے ہیں ، لہذا فنکشن غلط لوٹتا ہے۔ اس کے بعد ، فنکشن بالترتیب STR1 اور STR2 میں ہر کردار کی فریکوئینسی کو ذخیرہ کرنے کے لئے فریکوینسی لغات ، freq_dict1 اور freq_dict2 تخلیق کرتا ہے۔یہ تار میں ہر کردار پر تکرار کرتا ہے اور متعلقہ لغت میں تعدد میں اضافہ کرتا ہے۔اگر وہ برابر ہیں تو ، ڈور اناگرام ہیں ، لہذا فنکشن درست ہوجاتا ہے۔بصورت دیگر ، یہ جھوٹی کو لوٹاتا ہے۔ مثال کے طور پر استعمال میں ، فنکشن چیک کرتا ہے کہ اگر \"سنتے ہیں\" اور \"خاموش\" اینگرام ہیں تو فنکشن چیک کرتا ہے۔چونکہ ڈور ایک ہی تعدد کے ساتھ ایک ہی کرداروں پر مشتمل ہیں ، لہذا فنکشن پرنٹ کرتا ہے کہ وہ اناگرام ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیئے گئے اسٹرنگ ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک پیلنڈرووم ہے۔",
        "Answer": "یقینا!ازگر میں ایک واحد منسلک فہرست کا نفاذ یہاں ہے: پیتھون کوپی کوڈکلاس نوڈ: Def __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ = نان کلاس لنکڈ لسٹ: ڈیف __init __ (خود)): ریٹرن سیلف۔ ہیڈ کوئی بھی نہیں ہے۔.is_empty (): self.head = new_node else: موجودہ = سیلف ہیڈ جبکہ موجودہ۔ نیکسٹ: کرنٹ = کرنٹ۔ نیکسٹ موجودہ۔ نیکسٹ = نیا_نوڈ ڈیف داخل کریں_ٹ_پوزیشن (خود ، ڈیٹا ، پوزیشن): اگر پوزیشن <= 0: خود۔INSERT_AT_BEGINNNING (ڈیٹا) ایلف پوزیشن> = سیلف.گیٹ_لنتھ (): سیلف۔ INSERT_AT_END (ڈیٹا) دوسری: NEW_NODE = نوڈ (ڈیٹا) موجودہ = سیلف۔ _ کے لئے _ کے لئے _ (پوزیشن - 1): موجودہ = موجودہ۔ نیکسٹ نیا_نوڈ۔اگلا = کرنٹ۔ نیکسٹ موجودہ۔ نیکسٹ = نیا_نوڈ ڈیف ڈیلیٹ_ٹ_بگیننگ (خود): اگر سیلف۔ آئس_پٹی (): پرنٹ (\"فہرست خالی ہے۔حذف کرنے سے قاصر۔) اگر self.head.next کوئی بھی نہیں ہے: ڈیٹا = سیلف ہیڈ ڈاٹ ڈی اے ٹی اے خود نہیں۔.next = کوئی نہیں واپس ڈیٹا Def ڈیلیٹ_ٹ_پوزیشن (خود ، پوزیشن): اگر sell= 0: واپس _ کے لئے _ کے لئے _ کے لئے _ کے لئے _ کے لئے موجودہ = خود سے head (post - 1): واپس کریں۔خود): گنتی = 0 موجودہ = خود۔self.head موجودہ کے دوران: پرنٹ (موجودہ.ڈیٹا ، اختتام = \" ->\") موجودہ = موجودہ۔ نیکسٹ پرنٹ (\"کوئی نہیں\")# مثال useagelinked_list = لنکڈ لسٹ () لنکڈ_لسٹ۔ insert_at_end (10) لنکڈ_لسٹ.نسٹ_اینڈ (20) لنکڈ_لسٹ.INSERT_AT_END (30) لنکڈ_لسٹ.ڈیس پلے () # آؤٹ پٹ: 10 -> 20 -> 30 -> غیر لنکڈ_لسٹ.ڈیلیٹ_ٹ_پوزیشن (1) لنکڈ_لسٹ.ڈیس پلے () # آؤٹ پٹ: 10 -> 30 -> نوڈ کلاس کی نمائندگی کرتی ہے ، نوڈ کلاس نمائندگی کرتا ہےمنسلک فہرست میں ایک نوڈ۔ہر نوڈ میں قیمت کو ذخیرہ کرنے کے لئے ایک ڈیٹا وصف ہوتا ہے اور فہرست میں اگلے نوڈ کی طرف اشارہ کرنے کے لئے اگلی وصف ہوتا ہے۔ لنکڈ لسٹ کلاس واحد منسلک فہرست کی نمائندگی کرتی ہے۔اس فہرست میں پہلے نوڈ کی طرف اشارہ کرنے کے لئے اس کا سر صفت ہے۔اگر فہرست خالی ہے تو IS_EMPTY طریقہ چیک کرتا ہے۔داخل_اٹ_بیگیننگ ، داخل_ایٹ_ینڈ ، اور داخل_ایٹ_پوزیشن کے طریقے فہرست کی شروعات ، اختتام اور مخصوص پوزیشن میں بالترتیب ایک نیا نوڈ داخل کرتے ہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کریں۔",
        "Answer": "یقینا!انٹیجرز کی ترتیب شدہ صف پر بائنری تلاش کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈ ڈیف بائنری_سارچ (اے آر آر ، ہدف): کم = 0 ہائی = لین (اے آر آر) - 1 جبکہ کم <= اعلی: درمیانی = (کم + اعلی) // 2 اگر err [وسط] == ہدف: مڈ ایلف آر آر [وسط] <ہدف: کم = وسط + 1 اور: اعلی = وسط - 1 ریٹرن -1# مثال usagearr = [2 ، 4 ، 6 ، 8 ، 10.عنصر {ہدف} صف میں نہیں ملا \") اس پروگرام میں ، بائنری_سرچ فنکشن ان پٹ کے طور پر ایک سرنی آر آر اور ایک ہدف عنصر کا ہدف لیتا ہے۔تلاش کی حد کو ٹریک رکھنے کے ل It یہ دو پوائنٹرز ، کم اور اونچائی کا آغاز کرتا ہے۔ فنکشن ایک لوپ میں داخل ہوتا ہے جہاں یہ موجودہ حد کے درمیانی انڈیکس وسط کا حساب لگاتا ہے۔یہ ARR [MID] کے عنصر کا ہدف عنصر کے ساتھ موازنہ کرتا ہے۔اگر وہ برابر ہیں تو ، ہدف عنصر پایا جاتا ہے اور فنکشن انڈیکس کو لوٹاتا ہے۔ اگر درمیانی عنصر ہدف سے کم ہے تو ، تلاش کی حد کم = وسط + 1. کو اپ ڈیٹ کرکے صف کے اوپری نصف حصے تک محدود کردی جاتی ہے۔عنصر ہدف سے زیادہ ہوتا ہے ، تلاش کی حد اعلی = وسط - 1. کو اپ ڈیٹ کرکے صف کے نچلے حصے تک محدود کردی جاتی ہے۔صف میںاس معاملے میں ، فنکشن -1 کو عنصر کی نشاندہی کرنے کے لئے لوٹتا ہے۔ مثال کے طور پر استعمال میں ، پروگرام ترتیب شدہ صف [2 ، 4 ، 6 ، 8 ، 10 ، 12 ، 14 ، 16 ، 18 پر بائنری تلاش کرتا ہے۔، 20] ہدف عنصر تلاش کرنے کے لئے 12. چونکہ 12 صف میں موجود ہے ، پروگرام انڈیکس 5 پرنٹ کرتا ہے جہاں عنصر پایا جاتا ہے۔"
    },
    {
        "Question": "اس بات کا پتہ لگانے کے لئے ایک پروگرام لکھیں کہ آیا بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری سرچ ٹری ہے۔",
        "Answer": "یقینا!لنکڈ لسٹ کا استعمال کرتے ہوئے اسٹیک کا ایک ازگر کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیل۔ نیکسٹ = نانکلاس اسٹیک: ڈیف __init __ (خود): سیلف۔ ٹوپ = کوئی بھی نہیں ہے۔خود): ریٹرن سیلف نہیں۔\"اسٹیک خالی ہے۔ پاپ کرنے سے قاصر ہے۔\") کوئی بھی ڈیٹا = سیلف ٹوپ.ڈیٹا سیلف۔ ٹاپ = سیلف۔ ٹوپ۔ نیکسٹ ڈیٹا ڈیف جھانکنے والا (خود): اگر سیلف۔ آئی ایس_پٹی (): پرنٹ (\"اسٹیک خالی ہے. جھانکنے سے قاصر۔ \") کوئی بھی واپس نہیں لوٹ کر۔ڈیٹا ، اختتام = \" ->\") موجودہ = موجودہ۔ نیکسٹ پرنٹ (\"کوئی نہیں\")# مثال یوس ایگسٹیک = اسٹیک () اسٹیک۔ پش (10) اسٹیک.پش (20) اسٹیک.پش (30) اسٹیک۔ ڈسپلے ()# آؤٹ پٹ: 30 -> 20 -> 10 -> نان اسٹیک.پپ () اسٹیک.پپ () اسٹیک. ڈس پلے () # آؤٹ پٹ: 10 -> اس نفاذ میں ، نوڈ کلاس لنکڈ فہرست میں ایک نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں قیمت کو ذخیرہ کرنے کے لئے ایک ڈیٹا وصف ہوتا ہے اور فہرست میں اگلے نوڈ کی طرف اشارہ کرنے کے لئے اگلی وصف ہوتا ہے۔ اسٹیک کلاس اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔اس میں اسٹیک میں سب سے اوپر والے نوڈ کی طرف اشارہ کرنے کے لئے ایک ٹاپ وصف ہے۔اگر اسٹیک خالی ہے تو IS_EMPTY طریقہ چیک کرتا ہے۔پش طریقہ اسٹیک کے اوپری حصے میں دیئے گئے ڈیٹا کے ساتھ ایک نیا نوڈ شامل کرتا ہے۔پاپ کا طریقہ اسٹیک کے اوپری حصے سے ڈیٹا کو ہٹاتا ہے اور واپس کرتا ہے۔جھانکنے کا طریقہ اسٹیک کے اوپری حصے سے ڈیٹا کو ہٹائے بغیر اسے واپس کرتا ہے۔ڈسپلے کا طریقہ اسٹیک کے عناصر کو اوپر سے نیچے تک پرنٹ کرتا ہے۔ مثال کے طور پر استعمال میں ، پروگرام ایک اسٹیک تیار کرتا ہے اور اسٹیک پر عناصر (10 ، 20 ، 30) کو آگے بڑھانے ، اسٹیک سے پاپنگ عناصر جیسے کچھ آپریشن کرتا ہے ، اور ڈسپلے کرتا ہے۔اسٹیک کے مندرجات"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں شروع سے ہیش ٹیبل کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جس کا تعین کرنے کے لئے کہ آیا بائنری ٹری ایک متوازن بائنری سرچ ٹری ہے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __ __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ سیلف = کوئی بھی نہیں۔اگر جڑ کوئی نہیں ہے: سچ واپس کریں # چیک کریں کہ آیا بائیں subtree بائیں_ہائٹ = get_height (روٹ. لیفٹ) ہے اگر بائیں_ہائٹ == -1: غلط واپس کریں # دیکھیں # چیک کریں کہ آیا دائیں سب ٹری متوازن ہے۔== -1: غلط واپس لوٹیں # چیک کریں کہ اگر موجودہ نوڈ متوازن ہے تو اگر ABS (بائیں_ہائٹ - دائیں_ہائٹ)> 1: غلط واپسی ٹرایڈف گیٹ_ہائٹ (نوڈ) واپس کریں: اگر نوڈ کوئی نہیں ہے تو: واپس 0 بائیں_ہائٹ = get_height (نوڈ۔= get_height (node.right) # اگر کوئی سب ٹری غیر متوازن ہے تو ، واپس -1 -1 اگر بائیں_ہائٹ == -1 یا دائیں_ہائٹ == -1: واپسی -1 # اگر موجودہ نوڈ متوازن ہے تو ، واپس -1 -1 اگر ABS (بائیں_ہائٹ -دائیں_ صحت سے متعلق ہے۔)> 1: واپسی -1 # موجودہ نوڈ کی اونچائی کو زیادہ سے زیادہ (بائیں_ہائٹ ، رائٹ_ہائٹ) + 1 # مثال کے طور پر یوزیگروٹ = نوڈ (4) روٹ۔ لیفٹ = نوڈ (2) جڑ۔ رائٹ = نوڈ (6) جڑ۔بائیں. لیفٹ = نوڈ (1) روٹ۔ لیفٹ. رائٹ = نوڈ (3) جڑ۔ رائٹ.لیفٹ = نوڈ (5) روٹ۔ رائٹ۔ رائٹ = نوڈ (7) اگر is_balanced_bst (جڑ): پرنٹ (\"بائنری ٹری (\" بائنری ٹری)ایک متوازن بائنری تلاش کا درخت ہے۔ \") اور: پرنٹ (\" بائنری ٹری متوازن بائنری تلاش کا درخت نہیں ہے۔ \") اس پروگرام میں ، نوڈ کلاس بائنری درخت میں ایک نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں بالترتیب بائیں اور دائیں بچے کے نوڈس کی طرف اشارہ کرنے کے لئے قیمت اور بائیں اور دائیں صفات کو ذخیرہ کرنے کے لئے ڈیٹا کا وصف ہوتا ہے۔ اگر دیئے گئے بائنری ٹری کی جڑ ایک متوازن بائنری تلاش کا درخت ہے تو IS_BLANCED_BST فنکشن چیک کرتا ہے۔یہ ہر سب ٹری کی اونچائی کا حساب کتاب کرنے کے لئے ایک مددگار فنکشن get_height کا استعمال کرتا ہے۔اگر کوئی سب ٹری غیر متوازن ہے (اونچائی کا فرق> 1) یا درخت میں کوئی نوڈ غیر متوازن ہے تو ، فنکشن غلط لوٹتا ہے۔بصورت دیگر ، یہ سچ لوٹتا ہے۔ get_height فنکشن بائنری درخت کی اونچائی کا حساب لگاتا ہے یا دیئے گئے نوڈ پر جڑے ہوئے سب ٹری۔یہ باضابطہ طور پر بائیں اور دائیں سبٹریز کی اونچائیوں کا حساب لگاتا ہے اور اگر وہ متوازن ہیں تو چیک کرتے ہیں۔اگر کوئی سب ٹری غیر متوازن ہے یا موجودہ نوڈ غیر متوازن ہے تو ، وہ -1 لوٹتا ہے۔بصورت دیگر ، یہ موجودہ نوڈ کی اونچائی (بائیں اور دائیں سبٹریز کی زیادہ سے زیادہ اونچائی) کو لوٹاتا ہے + 1. مثال کے استعمال میں ، پروگرام ایک بائنری ٹری تیار کرتا ہے اور چیک کرتا ہے کہ اگر یہ IS_BLANCED_BST فنکشن کا استعمال کرتے ہوئے متوازن بائنری تلاش کا درخت ہے۔بائنری درخت اقدار [4 ، 2 ، 6 ، 1 ، 3 ، 5 ، 7] کے ساتھ تعمیر کیا گیا ہے۔اس کے بعد پروگرام پرنٹ کرتا ہے کہ آیا بائنری ٹری متوازن ہے یا نہیں۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں دو اسٹیکس کا استعمال کرتے ہوئے قطار کا ایک ازگر کا نفاذ ہے: پائیتھون کوپی کوڈکلاس قطار: ڈیف __init __ (خود): سیلف۔ ان_ اسٹیک = [] سیلف۔ آؤٹ_ اسٹیک = [] ڈیف آئی ایس ای پی آئی ایس پی (سیلف): ریٹرن لین (سیلف۔ ان_ اسٹیک) == 0 اورلین (self.out_stack) == 0 def enqueue (خود ، ڈیٹا): سیلف.این_سٹیک.ایپینڈ (ڈیٹا) ڈیف ڈی کیوئو (خود): اگر سیلف.س_پٹی (): پرنٹ (\"قطار خالی ہے۔ ڈی کیوئو سے قاصر ہے۔\") اگر لین (self.out_stack) == 0: # in_stack سے out_stack پر عناصر کی منتقلی کریں جبکہ لین (self.in_stack)> 0: سیلف۔ آؤٹ_سٹیک.ایپینڈ (self.in_stack.pop ()) سیلف۔ آؤٹ_ اسٹیک واپس کریں۔پاپ () ڈیف پیک (خود): اگر سیلف۔ آئی ایس_پٹی (): پرنٹ (\"قطار خالی ہے۔ جھانکنے سے قاصر ہے۔لین (self.in_stack)> 0: self.out_stack.append (self.in_stack.pop ()) واپس لوٹیں۔. \") واپسی پرنٹ (\" فرنٹ -> \"، اینڈ =\" \") پرنٹ (*سیلف آؤٹ_ اسٹیک [:: -1] ، ستمبر =\" -> \"، اینڈ =\" \") پرنٹ (\" < -پیچھے \")# مثال کے طور پر استعمال کیوئو = قطار () قطار۔ enqueue (10) قطار۔ enqueue (20) قطار۔قطار.Dequeue () قطار۔ ڈسپلے () # آؤٹ پٹ: فرنٹ -> 30 < - اس عمل کو دوبارہ جاری کریں ، قطار کلاس دو اسٹیکوں کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کی نمائندگی کرتی ہے۔آنے والے عناصر کو ذخیرہ کرنے کے لئے اس میں ایک IN_STACK ہے اور باہر جانے والے عناصر کو ذخیرہ کرنے کے لئے ایک آؤٹ_ اسٹیک ہے۔اگر دونوں اسٹیک خالی ہیں تو IS_EMPTY طریقہ چیک کرتا ہے۔انکیو طریقہ IN_stack میں ایک عنصر کو شامل کرتا ہے۔ڈیکو طریقہ کار عناصر کو IN_stack سے باہر_ اسٹیک (اگر ضروری ہو تو) میں منتقل کرتا ہے اور عنصر کو آؤٹ_ اسٹیک سے ہٹاتا ہے اور واپس کرتا ہے۔جھانکنے کا طریقہ کار کو قطار کے سامنے والے حصے میں لوٹاتا ہے بغیر اسے ہٹائے۔ڈسپلے کا طریقہ قطار کے عناصر کو سامنے سے پیچھے تک چھاپتا ہے۔ مثال کے طور پر استعمال میں ، پروگرام ایک قطار تیار کرتا ہے اور قطار میں داخل ہونے والے عناصر (10 ، 20 ، 30) جیسے کام کرتا ہے ، قطار سے عناصر کو ختم کرتا ہے ، اور اس کو ظاہر کرتا ہےقطار کے مشمولات"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں سرکلر بفر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!الفاظ کی ترتیب کو تار میں تبدیل کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف ریورس_ ورڈز (سٹرنگ): # انفرادی الفاظ میں سٹرنگ کو انفرادی الفاظ میں تقسیم کریں۔# ایک نئے سٹرنگ الٹ الٹ_سٹرنگ = '' کی تشکیل کے لئے الٹ الفاظ میں شامل ہوں۔ join (الٹ_ ورڈز) واپسی الٹ_سٹرنگ# مثال کے طور پر استعمال کریں۔فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اس میں الفاظ کی ترتیب کو تبدیل کرتا ہے۔سب سے پہلے ، اسٹرنگ کو تقسیم کے طریقہ کار کا استعمال کرتے ہوئے انفرادی الفاظ میں تقسیم کیا جاتا ہے ، جو الفاظ کی فہرست بناتا ہے۔اس کے بعد ، الفاظ کی فہرست [::-1] سلائسنگ تکنیک کا استعمال کرتے ہوئے الٹ ہے۔آخر میں ، الٹ الفاظ میں شامل ہونے کے طریقہ کار کا استعمال کرتے ہوئے ، ایک جگہ کے ساتھ ، ایک نیا الٹ سٹرنگ تشکیل دینے کے لئے ، ایک ساتھ مل کر شامل ہوجاتے ہیں۔، اس کے ساتھ ریورس_ورڈز فنکشن کو کال کرتا ہے ، اور الٹ سٹرنگ کو پرنٹ کرتا ہے۔آؤٹ پٹ \"خوفناک ہے۔ اوپن آئی ورلڈ ہے! ہیلو\" ، الٹ ترتیب میں الفاظ کے ساتھ۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر چوڑائی کی پہلی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک ٹائپ اسکرپٹ پروگرام کی ایک مثال ہے جو گراف پر چوڑائی کی پہلی تلاش کرتی ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: ریکارڈ <سٹرنگ ، سٹرنگ []> ؛کنسٹرکٹر () {this.adjacencyList = {} ؛} ایڈورٹیکس (ورٹیکس: سٹرنگ) {if (! this.adjacencyList [vertex]) {this.adjacencyList [vertex] = [] ؛}} ایڈج (ورٹیکس 1: سٹرنگ ، ورٹیکس 2: سٹرنگ) {this.adjacencyList [vertex1] .push (vertex2) ؛this.adjacencyList [vertex2] .Push (vertex1) ؛} بریڈھفیرسٹ سرچ (اسٹارٹورٹیکس: سٹرنگ) {کنسٹ ملاحظہ کریں: ریکارڈ <سٹرنگ ، بولین> = {} ؛کانسٹ قطار:"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ترتیب شدہ منسلک فہرست میں بائنری سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "نافذ کرنے کے لئے a"
    },
    {
        "Question": "اس بات کا تعین کرنے کے لئے ایک پروگرام لکھیں کہ آیا دو بائنری درخت ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ایک جیسے ہیں یا نہیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہ ہے کہ اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "اسکیپ لسٹ ڈیٹا ڈھانچے کو نافذ کرنا پیچیدہ ہوسکتا ہے ، لیکن میں آپ کو شروع کرنے کے لئے ایک آسان عمل درآمد فراہم کروں گا۔یہاں ٹائپ اسکرپٹ میں نافذ ہونے والی اسکیپ لسٹ کی ایک مثال ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسکیپلسٹنوڈ {قدر: نمبر ؛اگلا: اسکیپلسٹنوڈ |خالی؛نیچے: اسکیپلسٹنوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.next = null ؛this.down = null ؛class} کلاس اسکیپلسٹ {سر: اسکیپلسٹنوڈ |خالی؛میکسلیول: نمبر ؛سطح پروبییبلٹی: نمبر ؛کنسٹرکٹر () {this.head = null ؛this.maxlevel = 16 ؛// اسکیپ کے لئے زیادہ سے زیادہ سطح"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر گہرائی سے پہلے تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک ٹائپ اسکرپٹ پروگرام کی ایک مثال ہے جو گراف پر گہرائی سے پہلے تلاش کرتی ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: ریکارڈ <سٹرنگ ، سٹرنگ []> ؛کنسٹرکٹر () {this.adjacencyList = {} ؛} ایڈورٹیکس (ورٹیکس: سٹرنگ) {if (! this.adjacencyList [vertex]) {this.adjacencyList [vertex] = [] ؛}} ایڈج (ورٹیکس 1: سٹرنگ ، ورٹیکس 2: سٹرنگ) {this.adjacencyList [vertex1] .push (vertex2) ؛this.adjacencyList [vertex2] .Push (vertex1) ؛} ڈیپٹفیرسٹ سرچ (اسٹارٹورٹیکس: سٹرنگ) {کنسٹٹ ملاحظہ:"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں خود توازن بائنری تلاش کے درخت کو نافذ کریں۔",
        "Answer": "خود توازن بائنری سرچ درخت ، جیسے AVL درخت یا سرخ رنگ کے درخت کو نافذ کرنا کافی پیچیدہ ہوسکتا ہے۔اس کے بجائے ، میں آپ کو ٹائپ اسکرپٹ میں AVL درخت کا مثال فراہم کروں گا۔اے وی ایل کا درخت خود سے متوازن بائنری سرچ ٹری ہے جو موثر تلاش کو یقینی بنانے کے لئے متوازن ڈھانچے کو برقرار رکھتا ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی صف پر انضمام کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!انٹیگرس کی ایک صف پر انضمام کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن انضمام انضمام (ARR: نمبر []): نمبر [] {اگر (arr.length <= 1) {واپسی ARR ؛} کانٹ مڈل = ریاضی۔ فلور (arr.length / 2) ؛کانسٹ لیفٹار = آر آر ایس سلائس (0 ، درمیانی) ؛کونٹ رائٹ آر = آر آر ایس سلائس (درمیانی) ؛const sootdleftarr = انضمام (بائیں بازو) ؛const shordrightArr = انضمام (رائٹ آر) ؛واپسی کا انضمام (shartedleftarr ، shortedrightArr) ؛} فنکشن انضمام (لیفٹار: نمبر [] ، رائٹ آر: نمبر []): نمبر [] {{"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ میں ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینی کوڈ {بچے: نقشہ <سٹرنگ ، ٹرائینوڈ> ؛isendofword: بولین ؛کنسٹرکٹر () {this.children = نیا نقشہ () ؛this.isendofword = غلط ؛class} کلاس ٹری {جڑ: ٹرائنوڈ ؛کنسٹرکٹر () {this.root = نیا"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ آیا بائنری ٹری ٹائپ اسکرپٹ کا استعمال کرتے ہوئے متوازن ہے یا نہیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں یہاں ایک مثال پروگرام ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں دو قطاروں کا استعمال کرتے ہوئے اسٹیک کو نافذ کریں۔",
        "Answer": "دو قطاروں کا استعمال کرتے ہوئے اسٹیک پر عمل درآمد عناصر کے مرکزی ذخیرہ کرنے کے لئے ایک قطار اور معاون کارروائیوں کے لئے دوسری قطار کا استعمال کرکے حاصل کیا جاسکتا ہے۔ٹائپ اسکرپٹ میں دو قطاروں کا استعمال کرتے ہوئے اسٹیک پر عمل درآمد یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسٹیک {مین کیوئو: نمبر [] ؛auxqueue: نمبر [] ؛کنسٹرکٹر () {this.mainqueue = [] ؛this.auxqueue = [] ؛دہ"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کڈنے کے الگورتھم کا استعمال کرتے ہوئے عددی کی ایک صف میں زیادہ سے زیادہ سبریے کا مجموعہ تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن میکسبرسم (اے آر آر: نمبر []): نمبر {آئیے میکسم = آر آر [0] ؛آئیے کرینٹسم = آر آر [0] ؛کے لئے (i = 1"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ٹائپ اسکرپٹ میں بائنری ہیپ ڈیٹا ڈھانچے (خاص طور پر ایک کم سے کم ہیپ) کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بائنری ہیپ {ہیپ: نمبر [] ؛کنسٹرکٹر () {this.heap = [] ؛} getleftChildIndex (پیرنٹ انڈیکس: نمبر): نمبر {واپسی 2 * پیرنٹ انڈیکس + 1 ؛} getRightChildIndex (پیرنٹ انڈیکس: نمبر): نمبر {واپسی 2 * پیرنٹ انڈیکس + 2 ؛} getParentIndex (چائلڈ انڈیکس: نمبر): نمبر"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک سٹرنگ تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل عرصے سے پالندروومکسبسٹرنگ (ایس: سٹرنگ): سٹرنگ {آئیے شروع کریں = 0 ؛آئیے زیادہ سے زیادہ = 0 ؛// ایک سینٹر کانسٹرینڈ سینٹر = (بائیں: نمبر ، دائیں: نمبر) کے ارد گرد پھیلانے کے لئے ہیلپر فنکشن: باطل => {جبکہ (بائیں> = 0 && دائیں <s.length && s [بائیں] === s [دائیں]) {Const موجودہ لمبائی = دائیں - بائیں + 1 ؛اگر (موجودہ لمبائی> زیادہ سے زیادہ لمبائی) {اسٹارٹ = بائیں ؛maxlength = موجودہ لمبائی ؛}      بائیں--؛حق ++ ؛}} ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے درخت پر گہرائی سے پہلے تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!گہرائی میں پہلی تلاش (DFS) پر انجام دینے کے لئے ٹائپ اسکرپٹ میں ایک مثال کا پروگرام یہاں ہے"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں راہ کمپریشن کے ساتھ ایک ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں راہ کے کمپریشن کے ساتھ ایک ناگوار سیٹ ڈیٹا ڈھانچے (جسے یونین-فنڈ ڈیٹا ڈھانچہ بھی کہا جاتا ہے) کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.palent = [] ؛this.rank = [] ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {this.palent [x] = this.find (this.palent [x]) ؛// راستہ کمپریشن} اس کو واپس کریں۔ پیرنٹ [x] ؛} یونین (x: نمبر ، Y: نمبر): باطل {"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیئے گئے گراف ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دو طرفہ ہے۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک مثال پروگرام یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی گراف بائپارٹائٹ ہے: ٹائپ اسکرپٹ کوپی کوڈینم رنگ {غیر رنگین = 0 ، سرخ = 1 ، بلیو = 2 ،} فنکشن آئس بپارٹائٹ (گراف: نمبر [] []): بولین {کانسٹ این = گراف. لمبائی ؛رنگین رنگ: رنگ [] = سرنی (این)کانسٹ ڈی ایف ایس = (نوڈ: نمبر ، رنگ: رنگ): بولین => {رنگ [نوڈ] = رنگ ؛کے لئے (گراف کے پڑوسی [نوڈ]) {اگر (رنگ [پڑوسی] === رنگ) {غلط لوٹیں ؛// ایک ہی رنگ کے ساتھ ملحقہ نوڈس پائے گئے ، بائپارٹائٹ نہیں} if (رنگ [پڑوسی] === رنگین۔"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک سے زیادہ ہیش افعال کے ساتھ بلوم فلٹر ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس بلوم فلٹر {بٹیرے: بولین [] ؛numhashfunctions: نمبر ؛کنسٹرکٹر (سائز: نمبر ، نمبر ہاشفکشن: نمبر) {this.bitarray = نیا سرنی (سائز). فل (غلط) ؛this.numhashfunctions = numhashfunctions ؛} شامل کریں (عنصر: سٹرنگ): باطل {کانسٹ ہیش = this.gethashes (عنصر) ؛کے لئے (ہیشوں کے کانسٹ ہیش)"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف پر ٹوپولوجیکل ترتیب دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ہدایت شدہ ایسائکلک گراف (ڈی اے جی) پر ٹوپولوجیکل ترتیب دینے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {ملحقہ لسٹ: نقشہ <نمبر ، نمبر []> ؛کنسٹرکٹر () {this.adjacencyList = نیا نقشہ <نمبر ، نمبر []> () ؛} ایڈورٹیکس (ورٹیکس: نمبر): باطل {if (! this.adjacencylist.has (vertex)) {this.adjacencylist.set (vertex ، []) ؛}} ایڈج (سے: نمبر ، سے: نمبر): باطل {اگر (! this.adjacencylist.has (منجانب) ||گراف. ') ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں K-D درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں K-D ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {نقطہ: نمبر [] ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (نقطہ: نمبر []) {this.Point = نقطہ ؛this.left = null ؛this.right = null ؛}} کلاس kdtree {جڑ: Treenode |خالی؛طول و عرض: نمبر ؛کنسٹرکٹر (طول و عرض: نمبر) {this.root = null ؛this.dimensions = طول و عرض ؛} داخل کریں (نقطہ: نمبر []): باطل {this.root = this.insertnode (this.root ، نقطہ ، 0) ؛} نجی داخلہ (نوڈ"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے بائنری درخت میں دو نوڈس کے سب سے کم عام اجداد کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!بائنری درخت میں دو نوڈس کے سب سے کم عام اجداد کو تلاش کرنے کے لئے ٹائپ اسکرپٹ میں ایک مثال پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {قدر: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} فنکشن سب سے کم کامونانسیسٹر (جڑ: ٹرینوڈ | نول ، پی: ٹرینوڈ ، Q: ٹرینوڈ): ٹرینوڈ |null {if (جڑ === null || جڑ === p || جڑ === Q) {روٹ روٹ ؛دہ"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ایک سپلی ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ایک سپلیپ ٹری ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {کلید: نمبر ؛بائیں: ٹرینوڈ |خالی؛دائیں: ٹرینوڈ |خالی؛کنسٹرکٹر (کلید: نمبر) {this.key = key ؛this.left = null ؛this.right = null ؛}} کلاس splaytree {جڑ: Treenode |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (کلید: نمبر): باطل {اگر (this.root === null) {this.root = نیا ٹرینوڈ (کلید) ؛واپسی ؛} this.splay (کلید) ؛اگر (کلید <this.root.key) {const newnode = نیا ٹرینوڈ (کلید) ؛newnode.left = this.root.left ؛newnode.right = this.root ؛this.root.left = null ؛this.root = newnode ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے نیٹ ورک کے بہاؤ میں زیادہ سے زیادہ بہاؤ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "نیٹ ورک کے بہاؤ کے مسئلے میں زیادہ سے زیادہ بہاؤ تلاش کرنے کے ل you ، آپ فورڈ فلکرسن الگورتھم یا اس کی ایک مختلف حالتوں ، جیسے ایڈمنڈس-کارپ الگورتھم یا ڈائنک کے الگورتھم کا استعمال کرسکتے ہیں۔یہاں ٹائپ اسکرپٹ میں ایڈمنڈس کارپ الگورتھم کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {نجی گراف: نمبر [] [] ؛کنسٹرکٹر (گراف: نمبر [] []) {this.graph ="
    },
    {
        "Question": "ٹائپ اسکرپٹ میں مستقل ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں مستقل اسٹیک ڈیٹا ڈھانچے کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس اسٹیک نوڈ <T> {قدر: t ؛اگلا: اسٹیک نوڈ <t> |خالی؛کنسٹرکٹر (ویلیو: ٹی ، اگلا: اسٹیک"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دو ڈوروں کے مابین مختصر ترین مشترکہ بالادستی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دو ڈوروں کے مابین مختصر ترین مشترکہ بالادستی تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ استعمال کرسکتے ہیں۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن شارسٹ کامنس اپرسیونسی (str1: سٹرنگ ، str2: سٹرنگ): سٹرنگ {const m = str1.length ؛const n = str2.length ؛// مشترکہ سپرسیوینسس کانس ڈی پی کی لمبائی کو ذخیرہ کرنے کے لئے ایک ٹیبل بنائیں: نمبر [] [] = [] ؛// ٹیبل کو شروع کریں (آئیے i = 0 ؛ i <= m ؛ i ++) {dp [i] = نئی سرنی (n+1). فل (0) ؛} // کے لئے ٹیبل بھریں (i = 1 ؛ i <= m ؛ i ++) {for (j دو"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں لاحقہ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "لاحقہ درخت کو نافذ کرنا ایک پیچیدہ کام ہے ، لیکن میں آپ کو شروع کرنے کے لئے ایک جائزہ اور کوڈ ٹیمپلیٹ فراہم کرسکتا ہوں۔ٹائپ اسکرپٹ میں ایک لاحقہ درخت کا بنیادی نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس لاحقہ لاحقہ لاحقہ {بچے: {[کلید: سٹرنگ]: لاحقہ اسٹرینوڈ} ؛شروع کریں: نمبر ؛اختتام: نمبر ؛کنسٹرکٹر (شروع: نمبر ، اختتام: نمبر) {this.children = {} ؛this.start = start ؛this.end = end ؛} ایڈائلڈ (کلید: سٹرنگ ، نوڈ: لاحقہ): باطل {this.children [key] = نوڈ ؛} گیٹائڈ (کلید: سٹرنگ): لاحقہ اسٹرینوڈ |غیر وضاحتی {اس کو واپس کریں۔ بچوں [کلید] ؛} ہاسچلڈ (کلید: سٹرنگ): بولین {اس میں ریٹرن کلید۔ بچوں ؛}}"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ استعمال کرسکتے ہیں۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن سب سے طویل پالندرمکسوبسینس (ایس ٹی آر: سٹرنگ): سٹرنگ {const n = str.length ؛کانسٹ ڈی پی: نمبر [] [] = [] ؛// شروع کریں"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں درجہ بندی اور راستے کے کمپریشن کے ذریعہ یونین کے ساتھ ایک ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں رینک اور راہ کے کمپریشن کے ذریعہ یونین کے ساتھ ڈس ڈیسیٹ سیٹ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛درجہ: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.rank = نئی صف (سائز) ؛کے لئے (آئیے i = 0 ؛ i <سائز ؛ i ++) {this.peart [i] = i ؛this.rank [i] = 0 ؛}} تلاش کریں (x: نمبر): نمبر {if (this.palent [x]! == x) {// راستہ کمپریشن: پایا جانے والی جڑ کو x کا والدین بنائیں"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے 2D جگہ میں پوائنٹس کے ایک سیٹ میں پوائنٹس کی قریب ترین جوڑی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "2D جگہ میں پوائنٹس کے ایک سیٹ میں پوائنٹس کی قریب ترین جوڑی تلاش کرنے کے ل you ، آپ تقسیم اور فتح الگورتھم کو \"قریب ترین جوڑی پوائنٹس\" الگورتھم کے نام سے جانا جاتا ہے۔ٹائپ اسکرپٹ میں ایک مثال کے نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈ انٹرفیس پوائنٹ {x: نمبر ؛Y: نمبر ؛} فنکشن کا فاصلہ (P1: نقطہ ، P2: نقطہ): نمبر {const Dx = p2.x - p1.x ؛const dy = p2.y - p1.y ؛واپس میتھ۔ ایس کیو آر ٹی (dx * dx + dy * dy) ؛} فنکشن برٹفورس (پوائنٹس: پوائنٹ [] ، شروع: نمبر ، اختتام: نمبر): نمبر {آئیے ذہنیت = لامحدودیت ؛کے لئے (i = start ؛ i <= end ؛ i ++) {for (j = i+1 ؛ j <= end ؛ j ++) {کانسٹنٹ"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر کرسکل کے کم سے کم پھیلے ہوئے درخت الگورتھم کو انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں گراف کے کم سے کم پھیلنے والے درخت (MST) تلاش کرنے کے لئے کرسکل کے الگورتھم کا ایک مثال عمل ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس یونین فائنڈ {والدین: نمبر [] ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ٹریپ ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں ٹریپ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹریپ نوڈ <T> {کلید: نمبر ؛قیمت: ٹی ؛ترجیح: نمبر ؛بائیں: ٹریپ نوڈ <t> |خالی؛دائیں: ٹریپ نوڈ <t> |خالی؛کنسٹرکٹر (کلید: نمبر ، قدر: t) {this.key = key ؛this.value = value ؛this.priority = math.random () ؛this.left = null ؛this.right = null ؛class} کلاس ٹریپ <t> {جڑ: ٹریپ نوڈ <t> |خالی؛کنسٹرکٹر () {this.root = null ؛} پرائیویٹ روٹیٹ لفٹ (نوڈ: ٹریپ نوڈ <ٹی>): ٹریپ نوڈ <ٹی> {"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تار کی صفوں میں سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تاروں کی ایک صف کے درمیان سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے ایک مثال کا پروگرام یہ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل ترین کامومن پریفکس (ایس ٹی آر ایس: سٹرنگ []): سٹرنگ {اگر (str.length === 0) {واپسی '' ؛pref لیٹ پریفکس = strs [0] ؛کے لئے (i = 1 ؛ i <str.length ؛ i ++) {جبکہ (strs [i]. indexof (سابقہ)! == 0) {پریفکس = پریفکس.سوبسٹرنگ (0 ، سابقہ۔ لمبائی - 1) ؛اگر (سابقہ === '') {واپس '' ؛}}} واپسی پریفکس ؛} // مثال کے طور پر استعمال: کانسٹنگ اسٹرنگز = ['پھول' ، 'فلو' ، 'فلائٹ'] ؛ کانسٹ کامن پرفکس = طویل ترین کامومن پریفکس (ڈور) ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں رسی کے ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس روپینوڈ {بائیں: روپینوڈ |تار ؛دائیں: روپینوڈ |تار ؛وزن: تعداد ؛کنسٹرکٹر (بائیں: روپینوڈ | سٹرنگ ، دائیں: روپینوڈ | سٹرنگ) {this.left = بائیں ؛this.right = دائیں ؛this.weight = this.calculateweitt () ؛} نجی حساب کتاب (): نمبر {if (type of this.left === 'سٹرنگ') {اس کو واپس کریں۔} دوسری {اس کو واپس کریں۔}}} کلاس"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں وقفہ کے درخت کے اعداد و شمار کے ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں وقفہ کے درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس وقفہ {کم: نمبر ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں ایک متضاد سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!انٹیجرز کی ایک صف میں ایک متضاد سبری کا زیادہ سے زیادہ مجموعہ تلاش کرنے کے لئے ٹائپ اسکرپٹ میں کڈانے کے الگورتھم کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈ فینکشن فائنڈ میکس سوسبرسم (اے آر آر: نمبر []): نمبر {آئیے میکسم = آر آر [0] ؛آئیے کرینٹسم = آر آر [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {کرینٹسم = math.max (arr [i] ، کرینٹسم+arr [i]) ؛میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛} میکسم لوٹائیں ؛} //"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں ترتیب دیئے گئے سرنی پر فبونیکی سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں فبوناکی سرچ الگورتھم کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن فبونیکسیسرچ (اے آر آر: نمبر [] ، کلید: نمبر): نمبر {کانسٹنٹ این = ارل لمبائی ؛آئیے fibminus2 = 0 ؛// (M-2) th fibonacci نمبر fibminus1 = 1 ؛// (M-1) th fibonacci نمبر fib = fibminus2 + fibminus1 ؛// mth fibonacci نمبر جبکہ (fib <n) {fibminus2 = fibminus1 ؛fibminus1 = fib ؛fib = fibminus2 + fibminus1 ؛} اجازت دیں آفسیٹ = -1 ؛جبکہ (fib> 1)"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں سائز اور راستے کے کمپریشن کے ذریعہ یونین کے ساتھ ایک ناپسندیدہ سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں سائز اور پاتھ کمپریشن کے ذریعہ یونین کے ساتھ ناپسندیدہ سیٹ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ڈسوائٹ سیٹ {والدین: نمبر [] ؛سائز: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.Pearnt = نیا سرنی (سائز) ؛this.size = نئی صف"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے متحرک پروگرامنگ کے ساتھ سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کا ایک نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن سب سے طویل ترین پالنڈوم (ایس: سٹرنگ): سٹرنگ {کانسٹنٹ این = ایس لمبائی ؛کانسٹ ڈی پی: بولین [] [] = [] ؛// ڈی پی ٹیبل کو شروع کریں (آئیے i = 0 ؛ i <n ؛ i ++) {dp [i] = نیا سرنی (n). فل (غلط) ؛max میکس لمبائی = 1 ؛// زیادہ سے زیادہ لمبائی 1 کی شروعات کریں = شروع کریں ="
    },
    {
        "Question": "ٹائپ اسکرپٹ میں کواڈٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں کواڈٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس پوائنٹ {x: نمبر ؛Y: نمبر ؛کنسٹرکٹر (x: نمبر ، Y: نمبر) {this.x = x ؛this.y = y ؛}} کلاس مستطیل {x: نمبر ؛Y: نمبر ؛چوڑائی: نمبر ؛اونچائی: نمبر ؛کنسٹرکٹر (x: نمبر ، Y: نمبر ، چوڑائی: نمبر ، اونچائی: نمبر) {this.x = x ؛this.y = y ؛this.width = چوڑائی ؛this.height = اونچائی ؛دہ"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں متحرک پروگرامنگ کا استعمال کرتے ہوئے طویل ترین بڑھتی ہوئی تقویم تلاش کرنے کا ایک نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل عرصے سے متعلقہ عمل (نمبر: نمبر []): نمبر {const n = nums.length ؛کانسٹ ڈی پی: نمبر [] = نئی سرنی (این). فل (1) ؛// ڈی پی ٹیبل کو تمام اقدار کے ساتھ شروع کریں 1 // ہر انڈیکس کے لئے سب سے طویل عرصے تک بڑھتی ہوئی لمبائی کا حساب لگائیں (i = 1 ؛ i <n ؛ i ++) {کے لئے (j = 0 ؛ j <i ؛ j ++) {کے لئے.}}} // ڈی پی ٹیبل میں زیادہ سے زیادہ لمبائی تلاش کریں زیادہ سے زیادہ = 0 ؛کے لئے (آئیے i = 0 ؛ i <n ؛ i ++) {اگر"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں وزن میں متوازن درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں وزن سے متوازن درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس نوڈ {کلید: نمبر ؛بائیں: نوڈ |خالی؛دائیں: نوڈ |خالی؛وزن: تعداد ؛کنسٹرکٹر (کلید: نمبر) {this.key = key ؛this.left = null ؛this.right = null ؛یہ۔ ویٹ = 1 ؛class} کلاس ویٹ بیلنسڈ ٹری {جڑ: نوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} نجی اپ ڈیٹ ویٹ (نوڈ: نوڈ | NULL): نمبر {اگر (نوڈ ==== null) {واپس 0 ؛} کونٹ لیفٹ ویٹ = this.updatewiet (node.left) ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ تین عدد کی مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں زیادہ سے زیادہ تین عدد کی تلاش کا ایک نفاذ ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن زیادہ سے زیادہ پروڈکٹ (نمبر: نمبر []): نمبر {const n = nums.length ؛اگر (n <3) {نئی غلطی پھینک دیں (\"سرنی میں کم از کم 3 عدد پر مشتمل ہونا چاہئے۔\") ؛} // چڑھائی ترتیب میں صف کو ترتیب دیں"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں وان ایمڈے بوس ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "وان ایمڈے بوس ٹری کائنات U = {0 ، 1 ، ... ، M-1} سے عدد کے متحرک سیٹ کو برقرار رکھنے کے لئے ایک خصوصی ڈیٹا ڈھانچہ ہے ، جہاں ایم کی طاقت ہے۔مختلف اجزاء اور کاموں کو شامل کرنے میں پیچیدہ ہوسکتا ہے۔ٹائپ اسکرپٹ میں وان ایمڈے بوس درخت کا ایک آسان عمل درآمد یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس وینیمڈیبوسٹریہ {u: نمبر ؛// کائنات کا سائز کم سے کم: نمبر |خالی؛زیادہ سے زیادہ: نمبر |خالی؛خلاصہ: وینیمڈیباسٹری |خالی؛کلسٹرز: نقشہ <نمبر ، وینمڈیبوسٹریٹ> ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر فلائیڈ وارشل مختصر ترین راستہ الگورتھم انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں فلائیڈ وارشال مختصر ترین راستے الگورتھم کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈیکونسٹ انف = نمبر.میکس_ساف_ٹیجر ؛ فنکشن فلوڈورشال (گراف: نمبر [] []): نمبر [] [] {کانسٹ این = گراف۔ لمبائی ؛کنسٹ ڈسٹرکٹ: نمبر [] [] = [] ؛// دیئے گئے گراف کے ساتھ فاصلہ میٹرکس شروع کریں (آئیے i = 0 ؛ i <n ؛ i ++) {ڈسٹ [i] = [] ؛کے لئے (j = 0 ؛ j <n ؛ j ++) {اگر (i === j) {ڈسٹ [i] [j] = 0 ؛// ایک ورٹیکس سے اپنے آپ تک فاصلہ 0} ورنہ ہے (اگر ("
    },
    {
        "Question": "ٹائپ اسکرپٹ میں رابن کارپ یا نوتھ مورس پریٹ جیسے سٹرنگ مماثل الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں سٹرنگ مماثلت کے لئے نوتھ مورس پراٹ (کے ایم پی) الگورتھم کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن کمپیوٹیلپس (پیٹرن: سٹرنگ): نمبر [] {const m = پیٹرن۔ لمبائی ؛کانسٹ ایل پی ایس: نمبر [] = [] ؛لین = 0 ؛آئیے i = 1 ؛ایل پی ایس [0] = 0 ؛جبکہ (i <m) {اگر (پیٹرن [i] === پیٹرن [لین]) {لین ++ ؛ایل پی ایس [i] = لین ؛i ++ ؛} دوسری {اگر (لین! == 0) {لین = ایل پی ایس [لین - 1] ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے 1s اور 0s کے میٹرکس میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے 1s اور 0s کے میٹرکس میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن Numislands (گرڈ: نمبر [] []): نمبر {اگر (گرڈ === null || grid.length === 0) {واپسی 0 ؛} قطاریں = grid.length ؛CONS COLS = گرڈ [0]. لمبائی ؛آئیے گنتی = 0 ؛فنکشن ڈی ایف ایس (قطار: نمبر ، کرنل: نمبر): باطل {اگر (قطار <0 || col <0 || قطار> = قطار || col> = cols || گرڈ [قطار] [کرنل]! == 1){"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں فینوک ٹری (بائنری انڈیکسڈ ٹری) ڈیٹا ڈھانچہ کو لاگو کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں فینوک ٹری (بائنری انڈیکسڈ ٹری) کے ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس فین وِک ٹری {نجی درخت: نمبر [] ؛کنسٹرکٹر (سائز: نمبر) {this.tree = نیا سرنی (سائز + 1). فل (0) ؛} نجی getParent (انڈیکس: نمبر): نمبر {ریٹرن انڈیکس - (انڈیکس اور انڈیکس) ؛}  نجی"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تار کی صفوں میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے تاروں کی صفوں میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے ایک پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن طویل ترین کامومونفکس (اسٹرنگز: سٹرنگ []): سٹرنگ {اگر (ڈور (ڈور"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بی*ٹری ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں B*ٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس Bstartree {نجی جڑ: Bstarnode ؛نجی آرڈر: نمبر ؛کنسٹرکٹر (آرڈر: نمبر) {this.root = null ؛this.order = آرڈر ؛} داخل کریں (کلید: نمبر): باطل {اگر (this.root === null) {this.root = نیا Bstarnode (سچ) ؛this.root.insert (کلید) ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر جانسن کا مختصر ترین راستہ الگورتھم انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے گراف پر جانسن کے مختصر ترین راستے الگورتھم کو انجام دینے کے لئے یہاں ایک پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس گراف {نجی ریڈونلی ورٹیسس: نمبر ؛نجی پڑھنے والے کناروں: ایج [] ؛کنسٹرکٹر (عمودی: نمبر) {this.vertices = عمودی ؛this.edges = [] ؛} ایڈج (ماخذ: نمبر ، منزل: نمبر ، وزن: نمبر): باطل {this.edges.push (نیا کنارے (ماخذ ، منزل ، وزن)) ؛} بیل مین فورڈ (ماخذ: نمبر): نمبر [] {کنسٹ ڈسٹنس: نمبر [] = سرنی (یہ ۔ورٹیکس)فاصلہ [ماخذ] = 0 ؛کے لئے (آئیے i = 0 ؛ i <"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں اسکیپ کواڈ لسٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں اسکیپ کوڈ لسٹ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس نوڈ <T> {ڈیٹا: ٹی ؛اگلا: نوڈ <t> ؛پچھلا: نوڈ <t> ؛یوپی: نوڈ <t> ؛نیچے: نوڈ <t> ؛کنسٹرکٹر (ڈیٹا: ٹی) {this.data = ڈیٹا ؛this.next = null ؛this.prev = null ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عددی عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے عددی عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے یہاں ایک پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈ فینکشن فائنڈ میکسم (اے آر آر: نمبر []): نمبر {اگر (ارل لمبائی ==== 0) {واپس 0 ؛} if (arr.length === 1) {واپسی arr [0] ؛incluss شامل ہونے دیں = arr [0] ؛آئیے خصوصی = 0 ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {const temp = شامل ؛شامل = math.max (شامل ، خصوصی + arr [i]) ؛خصوصی = عارضی ؛math ریاضی کی واپسی۔ میکس (شامل ، خصوصی) ؛} // مثال کے طور پر استعمال: کانسٹ آر آر: نمبر [] = [2 ،"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں اسکیو ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں اسکیو ہیپ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس سکی وہپ"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل بٹونک سبری کی لمبائی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں لمبے لمبے بٹونک سبری کی لمبائی تلاش کرنے کے لئے ایک پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈفکشن فائنڈ لاؤنگسٹ بٹیونکسوبرائیلینتھ (اے آر آر: نمبر []): نمبر {کانسٹ این = آر ایل لمبائی ؛if (n === 0"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں کارٹیسین درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں کارٹیسین درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس ٹرینوڈ <t> {ڈیٹا: ٹی ؛بائیں: Treenode <T> |خالی؛دائیں: ٹرینوڈ <t> |خالی؛کنسٹرکٹر (ڈیٹا: ٹی) {this.data = ڈیٹا ؛this.left = null ؛this.right = null ؛class} کلاس کارٹیسیان ٹری <t> {جڑ: ٹرینوڈ <t> |خالی؛کنسٹرکٹر () {this.root = null ؛} نجی بلڈ ٹری (آر آر: ٹی []): ٹرینوڈ <ٹی"
    },
    {
        "Question": "ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف میں دو نوڈس کے مابین ہر ممکن راہیں تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف میں دو نوڈس کے مابین ہر ممکن راہیں تلاش کرنے کے لئے ایک پروگرام ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس نوڈ {ID: سٹرنگ ؛پڑوسی: نوڈ [] ؛کنسٹرکٹر (ID: سٹرنگ) {this.id = id ؛this.neighbors = [] ؛} ایڈجیببر (نوڈ: نوڈ): باطل {this.neighbors.push (نوڈ) ؛}} فنکشن فائنڈال پاتھ (شروع: نوڈ ، اختتام: نوڈ): سٹرنگ [] [] {کنٹ راہیں: سٹرنگ [] [] = [] ؛فنکشن ڈی ایف ایس (موجودہ: نوڈ ، راہ: سٹرنگ []): باطل {راستہ.پش (موجودہ. id) ؛اگر (موجودہ === اختتام) {pags.push (path.slice ()) ؛} else {for کے لئے (موجودہ پڑوسی کے.}} path.pop () ؛} ڈی ایف ایس (شروع ، []) ؛واپسی کے راستے ؛} // مثال کے طور پر استعمال: کانسٹ a = نیا نوڈ (\"a\") ؛ کانسٹ بی = نیا نوڈ (\"بی\") ؛ کانسٹ سی = نیا نوڈ (\"سی\") ؛ کانسٹنٹ"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں بائنری انڈیکسڈ ٹری ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں بائنری انڈیکسڈ ٹری کا نفاذ (جس کو بٹ وائز ٹری یا ایک سابقہ درخت بھی کہا جاتا ہے) ڈیٹا ڈھانچہ: ٹائپ اسکرپٹ کوپی کوڈکلاس بائنری انڈیکسیڈٹری {جڑ: ٹرائینوڈ ؛کنسٹرکٹر () {this.root = new trienode () ؛} داخل کریں (کلید: نمبر): باطل {آئیے موجودہ = this.root ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں فیوژن ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں فیوژن ٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈیکلاس فیوژن اسٹرینوڈ {قدر: نمبر ؛بائیں: فیوژن اسٹرینوڈ |خالی؛دائیں: فیوژن اسٹرینوڈ |خالی؛کنسٹرکٹر (قدر: نمبر) {this.value = value ؛this.left = null ؛this.right = null ؛}} کلاس فیوژن ٹری {جڑ: فیوژن اسٹرینوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} داخل کریں (قیمت: نمبر): باطل {اگر (! this.root) {this.root = نیا فیوژن اسٹرینوڈ (قدر) ؛واپسی ؛current موجودہ = this.root ؛والدین کو چلیں: فیوژن اسٹرینوڈ |null = null ؛"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں طبقہ کے درخت کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں طبقہ کے درخت کا استعمال کرتے ہوئے انٹیجرز کی ایک صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کی تلاش کا ایک نفاذ ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس سیگمنٹٹرینوڈ {بائیں: سیگمنٹٹرینوڈ |خالی؛دائیں: سیگمنٹٹرینوڈ |خالی؛شروع کریں: نمبر ؛اختتام: نمبر ؛زیادہ سے زیادہ لمبائی: نمبر ؛کنسٹرکٹر (شروع: نمبر ، اختتام: نمبر) {this.left = null ؛this.right = null ؛this.start = start ؛this.end = end ؛this.maxlength = 1 ؛// زیادہ سے زیادہ لمبائی 1}} کلاس سیگمنٹ ٹری {جڑ: سیگمنٹٹرینوڈ |خالی؛کنسٹرکٹر () {this.root = null ؛} بلڈ (اے آر آر: نمبر []): باطل {this.root = this.buildhelper (arr ، 0 ، arr.length - 1) ؛} بلڈ ہیلپر (ARR: نمبر [] ،"
    },
    {
        "Question": "ٹائپ اسکرپٹ میں مستقل طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ٹائپ اسکرپٹ میں مستقل طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: ٹائپ اسکرپٹ کوپی کوڈکلاس پرسنٹسمنٹٹیجٹرینوڈ {بائیں: پرسنٹسمنٹٹرینوڈ |خالی؛دائیں: پرسنٹسمنٹٹرینوڈ |خالی؛رقم: نمبر ؛کنسٹرکٹر (رقم: نمبر) {this.left = null ؛this.right = null ؛this.sum = sum ؛class} کلاس پرسینسیگمنٹ ٹری {جڑیں: (پرسنٹسمنٹٹرینوڈ | null) [] ؛اقدار: نمبر [] ؛ورژن اکاؤنٹ: نمبر ؛کنسٹرکٹر (اقدار: نمبر []) {this.roots = [] ؛this.values = اقدار ؛this.versionCount = 0 ؛"
    },
    {
        "Question": "کرداروں کو دہرانے کے بغیر سب سے طویل عروج تلاش کرنے کے لئے جاوا اسکرپٹ فنکشن لکھیں۔",
        "Answer": "یقینا!حروف کو دہرانے کے بغیر سب سے طویل عروج تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفیککشن فائنل لونجسٹسبسٹرنگ (ایس ٹی آر) {آئیے زیادہ سے زیادہ لمبائی = 0 ؛آئیے شروع کریں = 0 ؛آئیے چیرپ = نیا نقشہ () ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {چلو کرنٹچار = str [i] ؛if (churmap.has (موجودہ چیر) && churap.get (موجودہچار)> = شروع) {start = charmap.get (موجودہچار) + 1 ؛} Charmap.set (موجودہچار ، i) ؛maxlength = math.max (زیادہ سے زیادہ لمبائی ، i - شروع + 1) ؛} میکس لمبائی کی واپسی ؛} //"
    },
    {
        "Question": "کسی ایسے فنکشن کو نافذ کریں جو عددیوں کی ایک صف کو قبول کرے اور ان دو نمبروں کو واپس کرے جو ایک مخصوص ہدف کی رقم میں اضافہ کرتے ہیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جس میں ایک صف میں دو نمبر ملتے ہیں جو ایک مخصوص ہدف کے مطابق شامل کرتے ہیں: ٹائپ اسکرپٹ کوپی کوڈفکشن فائنٹونمبر (اے آر آر: نمبر [] ، ہدف: نمبر): نمبر [] |null {const nummap = نیا نقشہ <نمبر ، نمبر> () ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {کانسٹ تکمیل = اہداف - arr [i] ؛اگر (nummap.has (تکمیل)) {واپسی [nummap.get (تکمیل)! ، i] ؛} nummap.set (arr [i] ، i) ؛} واپس کال کریں"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو کارڈوں کے ڈیک کی نمائندگی کرے۔ڈیک کو تبدیل کرنے اور کارڈ ڈرا کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس کا نفاذ ہے جو ڈیک کو تبدیل کرنے اور کارڈ کھینچنے کے طریقوں کے ساتھ کارڈوں کی ایک ڈیک کی نمائندگی کرتا ہے: جاوا اسکرپٹ کوپی کوڈکلاس ڈیکوف کارڈز {کنسٹرکٹر () {this.deck = [] ؛this.resetdeck () ؛} ری سیٹ ڈیک () {کانسٹ سوٹ = ['دل' ، 'ہیرے' ، 'کلب' ، 'اسپیڈز'] ؛کانسٹینٹس = ['اککا' ، '2' ، '3' ، '4' ، '5' ، '6' ، '6' ، '7' ، '8' ، '9' ، '10' ، 'جیک' ، 'ملکہ'،' بادشاہ '] ؛this.deck = [] ؛کے لئے (سوٹ کا سوٹ) {کے لئے (صفوں کے عہدے کے مطابق) {this.deck.push ($ $ {رینک} of $ {سوٹ} `) ؛}}} شفل () {const {ڈیک} = یہ ؛"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے سٹرنگ ایک پیلنڈرووم ہے (وہی فارورڈز اور پیچھے کی طرف پڑھتا ہے)۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک پیلیندرووم ہے: جاوا اسکرپٹ کوپی کوڈفکشن آئسپلنڈرووم (ایس ٹی آر) {// اسٹرنگ کو چھوٹے حصے میں تبدیل کریں اور غیر الفانومرک حروف کو ہٹا دیں اور معمول کے مطابق = str.tolowerce ()۔z0-9]/g ، '') ؛// چیک کریں کہ آیا معمول کی تار اس کے الٹ ریٹرن کے برابر ہے نارملائزڈ اسٹسٹر === معمول کے مطابق۔، ایک منصوبہ ، ایک نہر ، پاناما ')) ؛// آؤٹ پٹ: trueconsole.log (ispalindrome ('ریسکار')) ؛// آؤٹ پٹ: trueconsole.log (ispalindrome ('ہیلو ، دنیا!')) ؛// آؤٹ پٹ: اس پر عمل درآمد کو فال کریں ، ispalindrome فنکشن ان پٹ کے طور پر سٹرنگ str لے جاتا ہے۔یہ تار کو اس کو چھوٹے اور نان-اے ایل کو ہٹا کر معمول بناتا ہے"
    },
    {
        "Question": "ایک مخصوص لمبائی اور پیچیدگی کے ساتھ بے ترتیب پاس ورڈ تیار کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!'، نمبر:' 0123456789 '، علامتیں:'!@##$ ٪^&*() _-+= <>؟ '} ؛// استعمال کرنے کے لئے کیریکٹر سیٹ کو اسٹور کرنے کے لئے ایک صف بنائیں"
    },
    {
        "Question": "کسی بھی گہرائی کے گھریلو سرے کو چپٹا کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں کسی بھی گہرائی کی گھوںسلا صف کو چپٹا کرنے کے لئے جاوا اسکرپٹ کا ایک تکرار کرنے والا فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفکشن فلیٹینرری (اے آر آر) {چپٹا ہونے دیں = [] ؛کے لئے (i = 0 ؛ i <arr.length ؛ i ++) {اگر (array.isarray (arr [i])) {flateded = flattened.concat (flattenarray (arr [i])) ؛} else {flattened.push (arr [i]) ؛}} واپس فلیٹڈ ؛} // مثال کے طور پر استعمال: کنسول.لوگ (فلیٹناراے ([1 ، 2 ، 3 ، 4 ، [5 ، 6]] ، 7])) ؛// آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7] کنسول.لوگ (فلیٹناری ([1 ، [2 ، [3 ، [4]]] ، 5]))) ؛// آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5] کنسول.لاگ (فلیٹینری ([1 ، [[1 ، ["
    },
    {
        "Question": "کسی صف سے نقل کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں اور انوکھی اقدار کے ساتھ ایک نئی صف واپس کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جس کے لئے ایک صف سے نقلیں ہٹائیں اور انوکھی اقدار کے ساتھ ایک نئی صف واپس کریں: جاوا اسکرپٹ کوپی کوڈفکشن کو ہٹا دیا گیا (ARR) {CONTINCE UNIQUERRAY = [] ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {if (! uniquearray.includes (arr [i])) {uniquearray.push (arr [i]) ؛}} لوٹ ان uniqueArray ؛} // مثال کے طور پر استعمال: کانسٹ سرنی = [1 ، 2 ، 3 ، 4 ، 2 ، 3 ، 5 ، 1] const کانسٹنگ نتیجہ = ہٹائے گئے (سرنی) ؛ کنسول.لاگ (نتیجہ) ؛// آؤٹ پٹ: [1 ، 2 ،"
    },
    {
        "Question": "اعشاریہ کی تعداد کو بائنری نمائندگی میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!ایک اعشاریہ نمبر کو اس کی بائنری نمائندگی میں تبدیل کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن ڈیسمالٹوبری (اعشاریہ) {اگر (اعشاریہ === 0) {واپسی '0' ؛// اعشاریہ نمبر 0 کے لئے '0' واپسی} آئیے بائنری = '' ؛جبکہ (اعشاریہ> 0) {بائنری = (اعشاریہ ٪ 2) + بائنری ؛اعشاریہ = ریاضی۔ فلور (اعشاریہ / 2) ؛brance بائنری واپسی ؛} // مثال کے طور پر استعمال: کنسول.لوگ (اعشاریہ (10)) ؛// آؤٹ پٹ: \"1010\" کنسول.لوگ (ڈیسمل ٹوبینری (27)) ؛// آؤٹ پٹ: \"11011\" کنسول.لاگ (ڈیسمالٹوبینری (0)) ؛// آؤٹ پٹ: \"0\" اس نفاذ میں ، اعشاریہ اعشاریہ فعل ایک اعشاریہ لیتا ہے"
    },
    {
        "Question": "کسی دیئے گئے جملے میں الفاظ کی ترتیب کو پلٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!کسی دیئے گئے جملے میں الفاظ کی ترتیب کو الٹ کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن ریورسورڈس (جملہ) {کونسٹ الفاظ = جملے.سپلٹ ('') ؛کانسٹ الٹ ورڈز = الفاظ۔ ریورس () ؛const الٹاالٹ الٹینسیٹینس} // مثال کے استعمال: کانسٹ جملہ = \"ہیلو ، دنیا! جاوا اسکرپٹ میں خوش آمدید۔\" ؛ کانسٹیٹ ریورسنٹنس = ریورسورڈس (جملہ) ؛ کنسول.لوگ (الٹ سنٹینس) ؛ // آؤٹ پٹ: \"جاوا اسکرپٹ۔ خوش آمدید دنیا!، \"اس نفاذ میں ، ریورسورڈز فنکشن ان پٹ کے طور پر ایک جملہ لیتا ہے۔یہ پہلے `استعمال کرتا ہے"
    },
    {
        "Question": "کسی دیئے گئے عدد میں تمام ہندسوں کی رقم کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے عدد میں تمام ہندسوں کی رقم کا حساب لگانے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفیککشن سموف ڈیجٹس (نمبر) {اجازت دیں = 0 ؛کانسٹ ہندسے = ریاضی۔ اے بی ایس (نمبر). ٹوسٹرنگ (). اسپلٹ ('') ؛کے لئے (آئیے i = 0 ؛ i <ہندسوں کی لمبائی ؛ i ++) {رقم+= پارسنٹ (ہندسے [i]) ؛} واپسی کی رقم ؛} // مثال کے استعمال: کنسول.لوگ (سموف ڈائیگٹس (123)) ؛// آؤٹ پٹ: 6 (1 + 2 + 3) کنسول.لاگ (سوموفڈیجٹس (-456)) ؛// آؤٹ پٹ: 15 (4 + 5 + 6) کنسول.لاگ (سوموفڈیجٹس (0)) ؛// آؤٹ پٹ: 0 اس نفاذ میں ، Sumofdigits فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے۔یہ پہلے نمبر کو اپنی مطلق قیمت میں تبدیل کرتا ہے"
    },
    {
        "Question": "\"ایک جاوا اسکرپٹ کلاس بنائیں جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ دھکے ، پاپ اور جھانکنے کے ل methods طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو اسٹیک ڈیٹا ڈھانچے کی نمائندگی کرتی ہے جس کے طریقوں کے ساتھ دھکا ، پاپ ، اور جھانکنے والے عناصر: جاوا اسکرپٹ کوپی کوڈکلاس اسٹیک {کنسٹرکٹر () {this.items = [] ؛} پش (عنصر) {this.items.push (عنصر) ؛} پاپ () {اگر (this.isempty ()) {واپس کالعدم ؛this اس کو واپس کریں۔} جھانکنے () {if (this.isempty ()) {واپس کالعدم ؛this اس کو واپس کریں۔ آئٹمز [this.items.length - 1] ؛} isempty () {اس کو لوٹائیں۔ آئٹمز۔ لمبائی === 0 ؛} سائز () {اس کو واپس کریں۔} واضح () {"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا کوئی دیئے گئے نمبر پرائم ہیں یا نہیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے نمبر پرائم ہیں: جاوا اسکرپٹ کوپی کوڈفکشن آئی ایس پرائم (نمبر) {// چیک کریں کہ آیا نمبر 2 (پرائم نہیں) سے کم ہے یا نہیں اگر (نمبر <2) {غلط واپس ؛} // چیک کریں کہ آیا نمبر کسی بھی عدد کے ذریعہ 2 سے نمبر کے مربع جڑ تک (i = 2 ؛ i <= math.sqrt (نمبر) ؛ i ++) {اگر (نمبر ٪ i === 0 0) {جھوٹا لوٹ ؛}} // نمبر بنیادی ہے اگر یہ تمام چیکوں کو درست کرتا ہے تو صحیح واپسی ؛} // مثال کے طور پر استعمال: کنسول.لوگ (isprime (17)) ؛// آؤٹ پٹ: trueconsole.log (isprime (24)) ؛// آؤٹ پٹ: falseconsole.log (isprime (1)) ؛// آؤٹ پٹ: اس پر عمل درآمد کو فال کریں ، آئی ایس پرائم فنکشن لیتا ہے"
    },
    {
        "Question": "کسی خاص پراپرٹی ویلیو کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک مخصوص پراپرٹی ویلیو پر مبنی اشیاء کی ایک صف کو ترتیب دینے کے لئے جاوا اسکرپٹ پروگرام ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن سٹر اری فوف آبجیکٹس (اے آر آر ، پراپرٹی) {ریٹرن آر آر ایسٹ ((اے ، بی) => اے [پراپرٹی] - بی [پراپرٹی]) ؛}// مثال کے استعمال: کونسٹ لوگ = [{نام: 'ایلس' ، عمر: 25} ، {نام: 'باب' ، عمر: 30} ، {نام: 'چارلی' ، عمر: 20} ،] ؛ کنسول.لوگ.باب '، عمر: 30} ، //] اس نفاذ میں ، سٹر ایری فووبیکٹس فنکشن ایک سرنی آر آر اور ایک پراپرٹی کو ان پٹ کے طور پر لیتا ہے۔یہ استعمال کرتا ہے"
    },
    {
        "Question": "\"کسی صف سے غلط اقدار (غلط ، کالعدم ، 0 ،\" \"\" \"، غیر متعینہ ، نان) کو دور کرنے کے لئے کسی فنکشن کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک صف سے جعلی اقدار کو دور کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن کو ریماسفالسی ویلیوز (اے آر آر) {ریٹرن ارا. فلٹر (بولین) ؛} // مثال کے استعمال: کانسٹ ویلیوز = [غلط ، نول ، 0 ، '' ، غیر متعینہ ، نان ،42 ، 'ہیلو'] ؛ کنسول.لوگ (ریمو فالسی ویلیوز (اقدار)) ؛ // آؤٹ پٹ: [42 ، 'ہیلو'] اس نفاذ میں ، ریماسٹ فالسی ویلیوس فنکشن ان پٹ کے طور پر ایک سرنی آر آر لیتا ہے۔یہ فلٹرنگ کے معیار کے طور پر بولین فنکشن کے ساتھ ساتھ سرنی کے فلٹر کا طریقہ استعمال کرتا ہے۔ بولین فنکشن فلٹر کے طریقہ کار کے لئے کال بیک کے طور پر استعمال ہوتا ہے۔یہ سرنی کے ہر عنصر کو خود بخود اس کی متعلقہ بولین قدر میں تبدیل کردیتا ہے۔کوئی بھی قیمت جسے غلط سمجھا جاتا ہے (غلط ، کالعدم ، 0 ، \"\" ، غیر متعینہ ، نان)"
    },
    {
        "Question": "آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!آر جی بی فارمیٹ میں بے ترتیب رنگ پیدا کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفونکشن جنریٹرینڈومکولر () {کونٹ ریڈ = ریاضی۔ فلور (ریاضی.راینڈوم () * 256) ؛کانسٹ گرین = ریاضی۔ فلور (ریاضی۔ رینڈم () * 256) ؛const بلیو = ریاضی۔ فلور (ریاضی.راینڈوم () * 256) ؛واپسی `RGB ($ {red} ، $ {گرین} ، $ {بلیو})` ؛} // مثال کے طور پر استعمال: کنسول.لوگ (جنریٹرینڈم کلر ()) ؛ // آؤٹ پٹ: \"آر جی بی (123 ، 45 ،"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار کسی اور تار کا اناگرام ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے تار کسی اور تار کا اناگرام ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن اسانگگرام (ایس ٹی آر 1 ، ایس ٹی آر 2) {// دونوں تار کو لوئر کیس میں تبدیل کریں اور غیر الفابیٹک حروف کو تشکیل دیں جو فارمیٹڈسٹر 1 = str1.tolowerse () کو تبدیل کریں۔/[^a-z]/g ، '') ؛const formattedstr2 = str2.tolowerce (). تبدیل کریں (/[^a-z]/g ، '') ؛// اگر فارمیٹڈ ڈوروں کی لمبائی برابر نہیں ہے تو ، وہ اناگرام نہیں ہوسکتے ہیں اگر (formattedstr1.length! == فارمیٹڈسٹر 2. لمبائی"
    },
    {
        "Question": "کسی دیئے گئے تار میں ہر کردار کی موجودگی کو گننے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کا فنکشن ہے جس میں ہر کردار کی موجودگی کو دیئے گئے تار میں گننے کے لئے: جاوا اسکرپٹ کوپی کوڈفکشن کاؤنٹ چیراکٹرکیسی (ایس ٹی آر) {کونٹ چیرکونٹ = {} ؛کے لئے (کانسٹ آف آف اسٹر) {اگر (چارکاؤنٹ [چار]) {چارکاؤنٹ [چار] ++ ؛} else {چارکاؤنٹ [چار] = 1 ؛}} واپس چارہ}} // مثال کے طور پر استعمال: کنسول.لاگ (کاؤنٹی چیراکٹرکیسی ('ہیلو')) ؛// آؤٹ پٹ: {H: 1 ، E: 1 ، L: 2 ، O: 1} اس نفاذ میں ، کاؤنٹ چیراکروکیسی فنکشن ان پٹ کے طور پر اسٹرنگ ایس ٹی آر لیتا ہے۔یہ شروع کرتا ہے"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو بائنری سرچ ٹری کی نمائندگی کرتا ہے۔ نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کے ساتھ بائنری سرچ ٹری کی نمائندگی کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس نوڈ {کنسٹرکٹر (قدر) {this.value = value ؛this.left = null ؛this.right = null ؛}} کلاس بائنری سرچ ٹری {کنسٹرکٹر () {this.root = null ؛} داخل کریں (قدر) {کونسٹ نیونوڈ = نیا نوڈ (قدر) ؛اگر (! this.root) {this.root = newnode ؛} else {this.insertnode (this.root ، newnode) ؛}} insertnode (نوڈ ، نیو نوڈ) {if (newnode.value <node.value) {if (! node.left) {node.left = newnode ؛} else {this.insertnode (node.left ، newnode) ؛}} else {if (! node.right) {node.right = newnode ؛"
    },
    {
        "Question": "انٹیجرز کے دیئے گئے سلسلے میں گمشدہ نمبر تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!انٹیجرز کے ایک دیئے گئے تسلسل میں گمشدہ نمبر تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام یہ ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن فائنڈ میسنگ نمبر (ترتیب) {// 1 سے n + 1 کانسٹ n = تسلسل. لمبائی + 1 سے لے کر تمام انٹیگروں کی رقم کا حساب لگائیں۔Const Constedsum = (n * (n + 1)) / 2 ؛// تسلسل کے اصل مجموعہ کا حساب لگائیں const const actionsum = sequence.reduce.reduce ((رقم ، نمبر) => رقم + نمبر ، 0) ؛// گمشدہ تعداد متوقع رقم اور اصل رقم کی واپسی کی متوقع - حقیقت کے درمیان فرق ہے"
    },
    {
        "Question": "کسی بھی نمبر کو کسی سرے سے ہٹانے اور ایک نئی صف واپس کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کا فنکشن ہے جس کے لئے تمام نمبروں کو ایک سرنی سے ہٹائیں اور ایک نئی صف کو واپس کریں: جاوا اسکرپٹ کوپی کوڈ فینکشن ہٹانے کے لئے ایوانمبرس (اے آر آر) {// صرف عجیب تعداد کے ساتھ ایک نئی سرنی بنانے کے لئے فلٹر کا طریقہ استعمال کریں۔=> نمبر ٪ 2! == 0) ؛اوڈنمبرس کی واپسی} // مثال کے طور پر استعمال: کانسٹ نمبر = [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، 10] ؛ کانسٹر کا نتیجہ = ہٹانے والے ایونبر (نمبر) ؛ کنسول.لاگ (نتیجہ) ؛// آؤٹ پٹ: [1 ، 3 ، 5 ، 7 ، 9] اس فنکشن میں ، ہم فلٹر کا طریقہ استعمال کرتے ہیں"
    },
    {
        "Question": "کسی دیئے گئے تار کو چھوٹا کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں اور ایک ایلپسس (...) شامل کریں اگر یہ ایک مخصوص لمبائی سے زیادہ ہے۔",
        "Answer": "یقینا!یہاں دیئے گئے تار کو چھوٹا کرنے کے لئے جاوا اسکرپٹ کا فنکشن ہے اور ایلپسس (...) شامل کرنے کے لئے یہ ایک مخصوص لمبائی سے زیادہ ہے: جاوا اسکرپٹ کوپی کوڈفونکشن ٹرنکیٹسٹرینگ (ایس ٹی آر ، میکس لینتھ) {// چیک کریں کہ تار کی لمبائی زیادہ سے زیادہ یا اس کے برابر ہے اگر اس کی لمبائی زیادہ سے زیادہ ہے یا اس کے برابر ہے اگر اس سے کم یا اس کے برابر ہے اگر(str.length <= maxlength) {واپسی str ؛// اصل تار کو واپس کریں کیونکہ یہ} else {// مخصوص میکس لمبائی میں تار کو چھوٹا کریں اور ایک بیضوی ریٹرن str.slice (0 ، میکس لمبائی) + '...' شامل کریں ؛}} // مثال کے طور پر استعمال: کانسٹیٹ ٹیکسٹ = 'لوریم آئپسم ڈولر بیٹھے امیٹ ، کونسیکٹٹور اڈیپیسکنگ ایلٹ۔// آؤٹ پٹ: \"لوریم آئیپسم ڈولر بیٹھم ہوں ...\" اس فنکشن میں ، ہم پہلے چیک کرتے ہیں کہ آیا"
    },
    {
        "Question": "فبونیکی تسلسل کا حساب کتاب کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!فیبونیکی تسلسل کا حساب کتاب کرنے کے لئے یہاں جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفکشن fibonaccisequence (n) {کانٹیشن تسلسل = [0 ، 1] ؛// پہلی دو شرائط کے ساتھ ترتیب کو شروع کریں // fibonacci ترتیب کا حساب لگائیں (i = 2 ؛ i <n ؛ i ++) {کونسٹ اگلے ٹرم = ترتیب [i - 1]+تسلسل [i- سے."
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے اسٹرنگ ایک درست ای میل ایڈریس ہے۔",
        "Answer": "مختلف قواعد اور رکاوٹوں کی وجہ سے ای میل پتوں کی توثیق کرنا پیچیدہ ہوسکتا ہے۔تاہم ، ہم ایک بنیادی نفاذ تشکیل دے سکتے ہیں جو مشترکہ نمونوں اور ضروریات کی جانچ پڑتال کرتا ہے۔یاد رکھیں کہ یہ آسان ورژن تمام کنارے کا احاطہ نہیں کرسکتا ہے"
    },
    {
        "Question": "\"ایک جاوا اسکرپٹ کلاس بنائیں جو قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہو۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو انکیو ، ڈی کیو ، اور جھانکنے والے طریقوں کے ساتھ ایک قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس قطار {کنسٹرکٹر () {this.items = [] ؛} enqueue (عنصر) {this.items.push (عنصر) ؛} dequeue () {if (this.isempty ()) {واپس کالعدم ؛this اس کو واپس کریں۔ آئٹم.شفٹ () ؛} جھانکنے () {if (this.isempty ()) {واپس کالعدم ؛this اس کو واپس کریں۔ آئٹمز [0] ؛} isempty () {اس کو لوٹائیں۔ آئٹمز۔ لمبائی === 0 ؛} سائز () {اس کو واپس کریں۔} واضح () {this.items = [] ؛}}// مثال"
    },
    {
        "Question": "اس کے رداس کے ذریعہ کسی دائرے کے علاقے اور فریم کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!اس کے رداس کو دیکھتے ہوئے کسی دائرے کے علاقے اور طواف کا حساب لگانے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفیککشن کیلکولیٹ سرکل (رداس) {کونٹ ایریا = ریاضی.پی * رداس * رداس ؛کونسٹ فریم = 2 * math.pi * رداس ؛واپسی {ایریا ، فریم} ؛} // مثال کے طور پر استعمال: کانسٹ رداس = 5 ؛ کانسٹنگ کا نتیجہ = کیلکولیٹ سرکل (رداس) ؛ کنسول.لوگ (نتیجہ.اریہ) ؛// آؤٹ پٹ: 78.53981633974483CONSOLE.log (نتیجہ.سری۔// آؤٹ پٹ: 31.41592653589793 اس فنکشن میں ، ہم ایک فنکشن کیلکولیٹ سرکل کی وضاحت کرتے ہیں جو اس کے رداس کو لے جاتا ہے"
    },
    {
        "Question": "کسی دیئے گئے تار کو عنوان کیس میں تبدیل کرنے کے لئے ایک فنکشن لکھیں (ہر لفظ کا پہلا خط سرمایہ کاری)۔",
        "Answer": "یقینا!کسی دیئے گئے تار کو عنوان کیس میں تبدیل کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفکشن ٹوٹلیکیس (ایس ٹی آر) {// تار کو الفاظ کی ایک صف میں تقسیم کریں۔// ہر لفظ کے پہلے خط کو costlecasevords = words.map (لفظ => {ریٹرن ورڈ.چارات (0) .touppercase () + ورڈ.سیلائس (1) ؛}) کیپیٹائز کریں ؛// الفاظ کو واپس سٹرنگ کرنٹ ٹائٹلیکاسیسٹر = ٹائٹلیکاس وورڈز.جوئن (\"\") میں شامل کریں۔ٹائٹلیکاسیسٹر} // مثال کے طور پر استعمال: کانسٹ جملہ = \"ہیلو ورلڈ ، آپ کیسے ہیں؟\" ؛ کنسٹ ٹائٹلیکیسیسنسٹینس = ٹاٹ لیٹکیس (جملہ) ؛ کنسول.لوگ (ٹائٹلیکیسیسنٹینس) ؛// آؤٹ پٹ: \"ہیلو ورلڈ ، آپ کیسے ہیں؟\" اس فنکشن میں ، ہم سب سے پہلے ان پٹ اسٹرنگ کو ٹولور کیس () کے طریقہ کار کا استعمال کرتے ہوئے لوئر کیس میں تبدیل کرتے ہیں۔پھر ، ہم تار کو `کا استعمال کرتے ہوئے الفاظ کی ایک صف میں تقسیم کرتے ہیں"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کو ایک نئی ترتیب شدہ صف میں ضم کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!دو ترتیب دیئے گئے صفوں کو ایک نئی ترتیب شدہ صف میں ضم کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفونکشن انضمام (ARR1 ، ARR2) {CONT انضمام کی شکل = [] ؛آئیے i = 0 ؛آئیے j = 0 ؛جبکہ (i <arr1.length && j <arr2.length) {if (arr1 [i] <= arr2 [j]) {انضمام array.push (arr1 [i]) ؛i ++ ؛} else {wargedarray.push (arr2 [j]) ؛J ++ ؛}} جبکہ (i <arr1.length) {wargedarray.push (arr1 [i]) ؛i ++ ؛} جبکہ (j <arr2.length) {wergedarray.push (arr2 [j]) ؛J ++ ؛} واپس انضمام}} // مثال کے طور پر استعمال: کانسٹ آر آر 1 = [1 ، 3 ، 5 ، 7] ؛ کانسٹ آر آر 2 = [2 ، 4 ، 6 ، 8] ؛ کانسٹ انضمام = انضمام"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو ایک منسلک فہرست کے ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔ نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کے ساتھ منسلک فہرست کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس نوڈ {کنسٹرکٹر (ویلیو) {this.value = value ؛this.next = null ؛}} کلاس لنکڈ لسٹ {کنسٹرکٹر () {this.head = null ؛} داخل کریں (قدر) {کونسٹ نیونوڈ = نیا نوڈ (قدر) ؛اگر (! this.head) {this.head = newnode ؛} دوسری {موجودہ = this.head ؛جبکہ (موجودہ۔ نیکسٹ) {موجودہ = موجودہ۔ نیکسٹ ؛} موجودہ۔ نیکسٹ = نیونوڈ ؛}} حذف (قدر) {اگر (! this.head) {واپسی ؛} if (this.head.value === ویلیو) {this.head = this.head.next ؛واپسی ؛} موجودہ = this.head ؛آئیے پچھلا = null ؛جبکہ (موجودہ && موجودہ۔ ویلیو! == ویلیو) {پچھلا = موجودہ ؛موجودہ = موجودہ۔ نیکسٹ ؛} if (موجودہ) {پچھلی. نیکسٹ = موجودہ. نیکسٹ ؛}} تلاش (قدر) {موجودہ = this.head ؛"
    },
    {
        "Question": "کسی صف میں اکثر اوقات عنصر تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک صف میں سب سے زیادہ کثرت سے عنصر تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام ہے: جاوا اسکرپٹ کوپی کوڈفکشن فائنموسٹ فروری کنینٹیلیمنٹ (اے آر آر) {کونسٹ فریکوینسی میپ = نیا نقشہ () ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {کانسٹ عنصر = arr [i] ؛اگر (فریکوینسی میپ.ہاس (عنصر)) {فریکوینسی میپ.سیٹ (عنصر ، فریکوینسی میپ.یٹ (عنصر) + 1) ؛} دوسری {فریکوینسی میپ.سیٹ (عنصر ، 1) ؛}} آئیے سب سے زیادہ ffrequentelement ؛چلو زیادہ سے زیادہ = 0 ؛فریکوینسی میپ۔ فاروچ ((تعدد ، عنصر) => {اگر (تعدد> زیادہ سے زیادہ فریکونسی) {سب سے زیادہ فری ایبلینٹیلیمنٹ = عنصر ؛ میکسفری کنوینسی = فریکوئنسی ؛}}) ؛سب سے زیادہ ffrequentelement} // مثال کے طور پر استعمال: const arr = [1 ، 3 ، 5 ، 3 ، 2 ، 1 ، 3 ، 2 ،"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر ایک بہترین مربع ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ کوئی دیئے گئے نمبر ایک کامل مربع ہے: جاوا اسکرپٹ کوپی کوڈفینکشن isperfectsquare (num) {اگر (num <0) {غلط واپس ؛// منفی تعداد کامل مربع نہیں ہیں} اگر (num === 0 || num === 1) {سچ واپس ؛// 0 اور 1 کامل مربع ہیں} چھوڑ دیں = 1 ؛آئیے دائیں = ریاضی۔ فلور (نمبر / 2) ؛جبکہ (بائیں <= دائیں) mid درمیانی = ریاضی۔ فلور ((بائیں + دائیں) / 2) ؛مربع = وسط * وسط ؛اگر (مربع === num) {سچ واپس ؛// ایک کامل مربع ملا} دوسری صورت میں اگر (مربع <نمبر) {بائیں = وسط + 1 ؛// دائیں نصف میں دیکھو"
    },
    {
        "Question": "بے ترتیب UUID (عالمی سطح پر منفرد شناخت کنندہ) پیدا کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!بے ترتیب UUID پیدا کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن جنریٹیوئڈ () {// لمبائی کی لمبائی کی ایک بے ترتیب ہیکساڈیسیمل تار تیار کریں 'لین' فنکشن جنریٹ ہیکس (لین) {لیٹ ہیکس = '' ؛کے لئے (آئیے i = 0 ؛ i <لین ؛ i ++) {ہیکس+= ریاضی۔ فلور (ریاضی.راینڈوم () * 16) .ٹوسٹرنگ (16) ؛} ہیکس کی واپسی ؛} // چار بے ترتیب ہیکساڈیسیمل ڈور پیدا کریں جو ہائفنس ریٹرن (جنریٹ ہیکس (8) + '-' + جنریٹہیکس (4) + '-' + جنریٹ ہیکس (4) + '-' + جنریٹ ہیکس (4) + '-' + جنریٹ ہیکس(12)) ؛} // مثال کے طور پر استعمال: کنسول.لوگ (جنریٹیوئڈ ()) ؛ اس فنکشن میں ، ہمارے پاس ایک اندرونی فنکشن ہے جسے `کہتے ہیں۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار غیر الفینومیرک کرداروں کو نظرانداز کرتے ہوئے ایک درست پیلنڈرووم ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو چیک کرتا ہے کہ اگر کسی دیئے گئے تار کو غیر الفاینومرک حرفوں کو نظرانداز کرتے ہوئے ایک درست پیلنڈرووم ہے: جاوا اسکرپٹ کوپی کوڈفکشن آئسپالینڈوم (ایس ٹی آر) {// غیر الفینومیرک حروف کو ہٹا دیں اور لوئر کیس کانسٹیٹ الفانومرکسٹر = str.replect (/[^a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a-za-Z0-9]/g ، '') .tolowercase () ؛// چیک کریں کہ آیا الفانومیرک اسٹرنگ ایک پیلنڈرووم ہے (آئیے i = 0 ؛ i <الفانومرکسٹر. لمبائی / 2 ؛ i ++) {اگر (الفانومرکسٹر [i]! == الفانومرکسٹر [الفانومرکسٹر۔ لمبائی - 1 - i]) {واپسیجھوٹا ؛}} سچ واپس ؛} // مثال کے طور پر استعمال: کنسول.لوگ (ispalindrome (\"ایک آدمی ، ایک منصوبہ ، ایک نہر ، پاناما!\")) ؛// trueconsole.log (ispalindrome (\"ریس کار\")) ؛// trueconsole.log (ispalindrome (\"ہیلو ، دنیا!\")) ؛// اس فنکشن کو رطوبہ کریں ، ہم پہلے تمام غیر الفانومرک کرداروں کو ہٹا دیتے ہیں"
    },
    {
        "Question": "ترتیب دیئے گئے صف کی اوسط قیمت تلاش کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ایک ترتیب شدہ سرنی کی درمیانی قیمت کو تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفکشن فائنڈ میڈیم (ترتیب وارے) {کانسٹنگ لمبائی = shartedarray.length ؛کانسٹ مڈ انڈیکس = ریاضی۔ فلور (لمبائی / 2) ؛اگر (لمبائی ٪ 2 === 0) {// صف کی لمبائی بھی ہے ، لہذا اوسطا دو درمیانی عناصر مڈ ویلیو 1 = ترتیب دیں [مڈ انڈیکس - 1] ؛MIDValue2 = shartedarray [MidIndex] ؛واپسی (مڈولیو 1 + مڈوالو 2) / 2 ؛} دوسری {// سرنی کی لمبائی عجیب ہے ، لہذا درمیانی عنصر کو لوٹائیں ترتیب دیں ترتیب دیں [مڈ انڈیکس] ؛}} // مثال کے طور پر استعمال: کانسٹ آر آر 1 = [1 ، 2 ، 3 ، 4 ، 5] ؛ کنسول.لوگ (فائنڈ میڈین (آر آر 1)) ؛// 3Const arr2 = [1 ، 2 ، 3 ، 4 ، 5 ، 6] ؛ کنسول.لاگ (فائنڈ میڈین"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو میٹرکس (2D سرنی) کی نمائندگی کرے۔میٹرک کو منتقل کرنے اور ضرب لگانے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو میٹرکس کی نمائندگی کرتی ہے اور میٹرکس کو منتقل کرنے اور ضرب لگانے کے طریقوں کو نافذ کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس میٹرکس {کنسٹرکٹر (قطاریں ، کولس) {this.rows = قطاریں ؛this.cols = COLS ؛this.data = [] ؛کے لئے (آئیے i = 0 ؛ i <قطاریں ؛ i ++) {this.data [i] = [] ؛کے لئے (j = 0 ؛ j <cols ؛ j ++) {this.data [i] [j] = 0 ؛}}} // ایک مخصوص قطار اور کالم سیٹ (قطار ، کرنل ، ویلیو) پر قدر طے کرنے کا طریقہ {this.data [قطار] [کرنل] = ویلیو ؛} // ایک مخصوص قطار اور کالم حاصل کریں (قطار ، کرنل) پر قیمت حاصل کرنے کا طریقہ {اس کو واپس کریں۔ ڈیٹا [قطار] [کرنل] ؛} // میٹرکس ٹرانسپوز () transposs کو ٹرانسپوز کرنے کا طریقہ (const const transpused = نیا میٹرکس (this.cols ، this.rows) ؛کے لئے (آئیے i = 0 ؛ i <this.rows ؛ i ++) {"
    },
    {
        "Question": "تار کے ایک سیٹ میں سب سے طویل عام پریفکس تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!تار کے ایک سیٹ کے درمیان سب سے طویل عام پریفکس تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن طویل ترین کامومن پریفکس (ڈور) {اگر (اسٹرنگس۔ لمبائی === 0) {واپسی \"\" ؛pref لیٹ پریفکس = ڈور [0] ؛کے لئے (آئیے i = 1 ؛ i <strings.length ؛ i ++) {جبکہ (تار [i]. indexof (سابقہ)! == 0) {پریفکس = پریفکس.سیلیس (0 ، سابقہ۔ لمبائی - 1) ؛اگر (سابقہ === \"\") {واپس \"\" ؛}}} واپسی کا سابقہ ؛} // مثال کے استعمال: کانسٹنگ اسٹرنگز = [\"پھول\" ، \"فلو\" ، \"فلائٹ\"] ؛ کانسٹنٹ"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا دیئے گئے نمبر دو کی طاقت ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد دو کی طاقت ہے: جاوا اسکرپٹ کوپی کوڈفکشن آئس پاوروفٹ وو (نمبر) {اگر (نمبر <1) {غلط واپس ؛} // اس نمبر کو 2 سے تقسیم کرتے رہیں جب تک کہ یہ 1 نہ ہوجائے یا اب تقسیم نہ ہو جبکہ (نمبر> 1) {"
    },
    {
        "Question": "دیئے گئے تار سے تمام HTML ٹیگز کو ہٹانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو ہٹاتا ہے"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!کڈانے کے الگورتھم کا استعمال کرتے ہوئے عددیوں کی ایک دی گئی صف میں زیادہ سے زیادہ سبریے کی رقم تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن فائنڈ میکسسوبارسم (اے آر آر) {آئیے میکسوفر = آر آر [0] ؛آئیے maxundHere = arr [0] ؛کے لئے (آئیے i = 1 ؛ i <arr.length ؛ i ++) {maxinderHere = math.max (arr [i] ، maxinderhere+arr [i]) ؛میکسوفر = میتھ.میکس (میکسوفر ، میکسینڈیئر) ؛max میکسفار کی واپسی ؛} // مثال کے طور پر استعمال: کانسٹ سرنی = [-2 ، 1 ، -3 ، 4 ، -1 ، 2 ، 1 ، -5 ، 4] ؛ کانسٹ میکسم = فائنڈ میکس سوسبرسم (سرنی) ؛ کنسول.لاگ (میکسم (میکسم)) ؛// آؤٹ پٹ: 6 فائنڈ میکسسبرسم فنکشن ایک صف لیتا ہے (`"
    },
    {
        "Question": "جاوا اسکرپٹ کلاس بنائیں جو بائنری ہیپ ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔کم سے کم عنصر کو داخل کرنے اور نکالنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ میں بائنری ہیپ کلاس کا ایک مثال ہے جس میں کم سے کم عنصر ڈالنے اور نکالنے کے طریقوں کے ساتھ: جاوا اسکرپٹ کوپی کوڈکلاس بائنری ہیپ {کنسٹرکٹر () {this.heap = [] ؛} داخل کریں (قدر) {this.heap.push (ویلیو) ؛this.heapifyup (this.heap.length - 1) ؛} ایکسٹریکٹ مین () {if (this.heap.length === 0) {واپس واپس ؛} if (this.heap.length === 1) {اس کو واپس کریں۔} const min = this.heap [0] ؛this.heap [0] = this.heap.pop () ؛this.heapifydown (0) ؛واپسی منٹ ؛} ہیپیف اپ (انڈیکس) {Cont ParentIndex = math.floor ((انڈیکس - 1) / 2) ؛if (index> 0 && this.heap [index] <this.heap [parentindex]) {"
    },
    {
        "Question": "دیئے گئے تار میں پہلا غیر بار بار ہونے والا کردار تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ پروگرام ہے جس میں کسی دیئے گئے تار میں پہلا غیر ریپیٹنگ کردار مل جاتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن فائنفورسٹن رائپیٹنگچارٹر (ایس ٹی آر) {// ہر کردار کی گنتی کو ذخیرہ کرنے کے لئے ایک نقشہ بنائیں = نیا نقشہ () نیا نقشہ () ؛// تار کے ذریعے تکرار کریں اور کردار کی گنتی کو اپ ڈیٹ کریں (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛اگر (چارکاؤنٹ.ہاس (چار)) {چارکاؤنٹ.سیٹ (چار ، چارکاؤنٹ.جیٹ (چار) + 1) ؛} else {charcount.set (چار ، 1) ؛}} // ایک بار پھر تار کے ذریعے تکرار کریں اور کاؤنٹ 1 کے ساتھ پہلا کردار تلاش کریں (i = 0 ؛ i <str.length ؛ i ++) {const char = str [i] ؛if (charcount.get (چار) === 1) {واپسی چار ؛دہ"
    },
    {
        "Question": "موجودہ عنصر کے علاوہ کسی صف میں تمام عناصر کی مصنوعات کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو موجودہ عنصر کے سوا تمام عناصر کی مصنوعات کا حساب لگاتا ہے: جاوا اسکرپٹ کوپی کوڈفیکیشن کیلکولیٹ پروڈکٹ ایکسپیکسیپٹیکورینٹ (اے آر آر) {کانٹ پروڈکٹری = [] ؛// موجودہ عنصر کے بائیں طرف تمام عناصر کی مصنوعات کا حساب لگائیں پروڈکٹ آفر = 1 ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {پروڈکٹ ایری [i] = پروڈکٹس آفر ؛پروڈکٹس آفر *= آر آر [i] ؛} // موجودہ عنصر کی مصنوعات کو موجودہ عنصر کی مصنوعات کے دائیں طرف کا حساب لگائیں = 1 ؛کے لئے (آئیے i = arr.length-1 ؛ i> = 0 ؛ i--) {پروڈکٹ ایری [i] *= پروڈکٹس آفر ؛پروڈکٹس آفر *= آر آر [i] ؛} واپس پروڈکٹ ایری ؛} //"
    },
    {
        "Question": "\"دیئے گئے تار کو اونٹ کیس میں تبدیل کرنے کے لئے جاوا اسکرپٹ کا فنکشن بنائیں (اس کے بعد کے ہر لفظ کے لئے لوئر کیس فرسٹ لیٹر ، اپر کیس)۔\"",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو دیئے گئے تار کو اونٹ کے معاملے میں تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن کنورٹٹوکیملیس (ایس ٹی آر) {// تار کو خالی جگہوں یا انڈر سکور کے ذریعہ تقسیم کرتا ہے = str.split (/[\\ s _]+/) ؛// پہلے لفظ کو لوئر کیس میں تبدیل کریں اور اس کے بعد کے الفاظ کو سرمایہ کاری کریں۔(0) .touppercase () + ورڈ.سلائس (1) .tolowercase () ؛}}) ؛// الفاظ میں شامل ہوں اور اونٹ کیس سٹرنگ کو لوٹائیں constaccasestr = comelcasewords.join ('') ؛کیمیلکاسسٹر واپس ؛} // مثال کے طور پر استعمال: کانسٹ ان پٹ = 'ہیلو_ورلڈ_وہ_ر_آئو' ؛ const comelcasestr = converttocam"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا کوئی دیئے گئے نمبر ایک پیلنڈرووم ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے نمبر ایک پیلیندرووم ہے: جاوا اسکرپٹ کوپی کوڈفکشن ispalindromenmumber (num) {// نمبر کو اسٹرنگ کانسٹ اسٹٹر = سٹرنگ (نمبر) میں تبدیل کریں ؛// تار کے آغاز اور اختتام سے حروف کا موازنہ کرنے کے لئے دو پوائنٹر استعمال کریں = 0 چھوڑ دیں۔آئیے دائیں = str.length - 1 ؛جبکہ (بائیں <دائیں) {اگر (str [بائیں]! == str [دائیں]) {غلط لوٹ ؛// اگر حروف مماثل نہیں ہوتے ہیں تو ، یہ ایک پیلنڈرووم نہیں ہے} بائیں ++ ؛ٹھیک ہے-؛} سچ واپس ؛// تمام حروف کے مماثل ، یہ ایک پیلیندرووم ہے} // مثال کے طور پر استعمال: کنسول.لوگ (ispalindromenumber (12321)) ؛// آؤٹ پٹ: trueconsole.log (ispalindromenumber (12345)) ؛// آؤٹ پٹ: غلط"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں سب سے طویل عرصے تک بڑھتے ہوئے حصول کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی صف میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفکشن فائنلنگسٹین کریزنگسوبسینس (نمبر) {const n = nums.length ؛کانسٹ ڈی پی = نئی سرنی (این). فل (1) ؛آئیے زیادہ سے زیادہ = 1 ؛کے لئے (آئیے i = 1 ؛ i <n ؛ i ++) {for (j = 0 ؛ j <i ؛ j ++) {اگر (nums [i]> nums [j]) {dp [i] = math.max (ڈی پی [i] ، dp [j] + 1) ؛maxlength = math.max (زیادہ سے زیادہ لمبائی ، DP [i]) ؛}}} const constance = [] ؛آئیے موجودہ لمبائی = زیادہ سے زیادہ لمبائی ؛کے لئے"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو گراف ڈیٹا ڈھانچے کی نمائندگی کرے۔چوڑائی کے لئے پہلے اور گہرائی میں سب سے پہلے ٹراورسل کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو گراف کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے اور چوڑائی کے پہلے اور گہرائی کے پہلے ٹراورسل کے طریقوں کو نافذ کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس گراف {کنسٹرکٹر () {this.adjacencyList = نیا نقشہ () ؛} ایڈورٹیکس (ورٹیکس) {if (! this.adjacencylist.has (vertex)) {this.adjacencyList.set (vertex ، []) ؛}} ایڈجڈ (ورٹیکس 1 ، ورٹیکس 2) {if (this.adjacencylist.has (vertex1) && this.adjacencylist.has (vertex2)) {this.adjacencylist.get (vertex1) .push (vertex2) ؛this.adjacencylist.get (vertex2) .Push (vertex1) ؛}} بریڈھفیرسٹ ٹراورسال (اسٹارٹورٹیکس) {کنسٹ ملاحظہ کریں = نیا سیٹ () ؛کانسٹ قطار = [اسٹارٹورٹیکس] ؛کانسٹنگ نتیجہ = [] ؛ملاحظہ کیا گیا۔ ایڈ (اسٹارٹورٹیکس) ؛جبکہ (قطار۔ لمبائی> 0) {کونٹ کرنٹورٹیکس = قطار۔ شفٹ () ؛نتیجہ۔ پش (کرنٹورٹیکس) ؛کنسٹ پڑوسی = this.adjacencyList.get (موجودہورٹیکس) ؛"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ پروگرام ہے جس میں کوئیک سلیکٹ الگورتھم کا استعمال کرتے ہوئے غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو پایا جاتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن فائنڈ کےٹلرجسٹ (نمبرز ، کے) {// مددگار فنکشن کو تبدیل کرنے والے عناصر کو تبدیل کرنے کے لئے فنکشن سویپ (آر آر ، آئی ، جے) {[آر آر [آئی آر [آئی آر []]، arr [j]] = [arr [j] ، arr [i]] ؛} // سرنی فنکشن پارٹیشن (آر آر ، اسٹارٹ ، اینڈ) کو تقسیم کرنے کے لئے مددگار فنکشن {کانسٹ پائیوٹ = آر آر [اختتام] ؛چلو pivotindex = start ؛کے لئے (i = شروع کریں"
    },
    {
        "Question": "الفاظ کی ترتیب کو الٹ کرنے اور ہر کردار کے معاملے کو کسی مقررہ جملے میں رکھنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو ہر ایک کردار کے معاملے کو برقرار رکھتے ہوئے کسی جملے میں الفاظ کی ترتیب کو تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن ریورس وورڈسویت کیس (جملہ) {// ہیلپر فنکشن کو کسی لفظ کو الٹا کرنے کے لئے ایک لفظ کو الٹ کرنے کے ساتھ"
    },
    {
        "Question": "جاوا اسکرپٹ کا فنکشن بنائیں تاکہ یہ معلوم کیا جاسکے کہ دیئے گئے سٹرنگ ایک درست یو آر ایل ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو چیک کرتا ہے کہ اگر دیئے گئے سٹرنگ ایک درست یو آر ایل ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن isvalidurl (url) {کوشش کریں {نیا url (url) ؛واپس سچ ؛} کیچ"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کے وسط کو تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "دو ترتیب شدہ صفوں کے میڈین کو تلاش کرنے کے ل you ، آپ صفوں کو ایک ترتیب شدہ صف میں ضم کر سکتے ہیں اور پھر مربوط صف کی لمبائی کی بنیاد پر میڈین کا حساب لگاسکتے ہیں۔یہاں جاوا اسکرپٹ کا ایک فنکشن ہے جو اس نقطہ نظر کو نافذ کرتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن فائنڈ میڈیمیسورٹری (Nums1 ، nums2) {Cont wetmeredarray = مرجورٹری (nums1 ، nums2) ؛کانسٹ لمبائی = مرجیرے۔ لمبائی ؛اگر (لمبائی ٪ 2 === 0) {"
    },
    {
        "Question": "کسی دیئے گئے تار سے تمام وائٹ اسپیس حروف کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "کسی دیئے گئے تار سے تمام وائٹ اسپیس حروف کو ہٹانے کے ل you ، آپ باقاعدہ اظہار اور تبدیل کرنے کا طریقہ استعمال کرسکتے ہیں۔یہاں جاوا اسکرپٹ کا ایک فنکشن ہے جو اس کو نافذ کرتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن کو ہٹانے والی جگہ (str) {واپس str.replace (/\\ s/g ، '' ') ؛} // مثال کے طور پر استعمال: کونسٹ جملہ =' ہیلو ورلڈ! '؛ کنسول۔(جملہ))؛// آؤٹ پٹ: ہیلوورلڈ! ہٹانے والی جگہ کے فنکشن میں ، ہم ریپلیٹ طریقہ کو باقاعدہ اظہار کے ساتھ استعمال کرتے ہیں \\ s اور G پرچم کے ساتھ تمام وائٹ اسپیس کرداروں سے ملنے کے لئے۔ہم تمام میچوں کو خالی تار '' کے ساتھ تبدیل کرتے ہیں ، اور سٹرنگ سے وائٹ اسپیس حروف کو مؤثر طریقے سے ہٹا دیتے ہیں۔ مثال کے طور پر استعمال میں۔"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو ترجیحی قطار کے اعداد و شمار کے ڈھانچے کی نمائندگی کرے۔ترجیح کی بنیاد پر عناصر کو ختم کرنے اور ان کی تزئین و آرائش کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!جاوا اسکرپٹ میں ترجیحی قطار کا ایک مثال عمل ہے: جاوا اسکرپٹ کوپی کوڈکلاس کی ترجیح کیوئو {کنسٹرکٹر () {this.queue = [] ؛} enqueue (عنصر ، ترجیح) {const queselement = {عنصر ، ترجیح} ؛آئیے isnserted = غلط ؛کے لئے (آئیے i = 0 ؛ i <this.queue.length ؛ i ++) {اگر (this.queue [i] .priority> ppriority.priority) {this.queue.splice (i ، 0 ، poxelement) ؛isinserted = سچ ؛بریک ؛}} اگر (! ہے"
    },
    {
        "Question": "\"ایک دی گئی صف میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں ، جہاں چھوٹا عنصر بڑے عنصر سے پہلے ظاہر ہوتا ہے۔\"",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ پروگرام کا ایک مثال عمل ہے جس میں ایک صف میں دو عناصر کے درمیان زیادہ سے زیادہ فرق پایا جاتا ہے ، جہاں چھوٹا عنصر بڑے عنصر سے پہلے ظاہر ہوتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن فائنڈ میکس ڈفینفینس (ARR) {اگر (arr.length <2) {واپسی 0 ؛} آئیے میکسڈف = آر آر [1] - آر اے آر [0] ؛"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں پہلا گمشدہ مثبت عدد تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک نفاذ ہے"
    },
    {
        "Question": "کسی دیئے گئے نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ فنکشن کا نفاذ ہے جو ایک دیئے گئے نمبر کو رومن ہندسوں میں تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن کنورٹورٹورومن (نمبر) {کانسٹ رومانومیرلز = {ایم: 1000 ، سی ایم: 900 ، ڈی: 500 ، سی ڈی: 400 ، سی: 100 ، ایکس سی: 90، l: 50 ، xl: 40 ، x: 10 ، ix: 9 ، V: 5 ، iv: 4 ، i: 1} ؛آئیے نتیجہ = '' ؛کے لئے (رومانومیرلز میں علامت) {جبکہ (num> = رومانومیرلز [علامت]) {نتیجہ += علامت ؛نمبر -= رومانومیرلز [علامت] ؛}} واپسی کا نتیجہ ؛} // مثال کے استعمال: کانسٹنٹ"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا کسی دیئے ہوئے تار میں صرف انوکھے حرف ہوتے ہیں۔",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ فنکشن کا نفاذ ہے جس میں یہ چیک کیا جاتا ہے کہ اگر کسی دیئے گئے تار میں صرف انوکھے کردار ہوتے ہیں: جاوا اسکرپٹ کوپی کوڈفکشن ہاس یونیکیچاریکٹرز (ایس ٹی آر) {کانسٹنٹ"
    },
    {
        "Question": "دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ فنکشن کا نفاذ ہے جو کسی دیئے گئے تار کے تمام اجازت نامے تیار کرتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن جنریٹپرپرموٹیشن (ایس ٹی آر) {کونٹ پرمٹیشن = [] ؛فنکشن بیک ٹریک (کرنٹپرموٹیشن ، بقیہ چیرس) {اگر (بقیہ چیرس۔ لمبائی === 0) {پرمٹیشنز۔ پش (کرنٹپرموٹیشن) ؛واپسی ؛} کے لئے (آئیے i = 0 ؛ i <باقی chars.length ؛ i ++) {const CHAR = بقیہ چاروں [i] ؛کانسٹ اپڈیٹڈچارس = بقیہ چیرس۔ سلیئس (0 ، i) + بقیہ چیرس.سیلیس (i + 1) ؛بیک ٹریک (کرنٹپرموٹیشن + چار ، اپ ڈیٹ شدہچارس) ؛}} بیک ٹریک ('' ، str) ؛واپسی کی اجازت ؛} // مثال کے طور پر استعمال: کانسٹ ان پٹ اسٹرنگ = 'اے بی سی' ؛ کانسٹنگ رزلٹ = جنریٹ پیرمیٹیشن (ان پٹ اسٹرنگ) (کنسول.لاگ (نتیجہ) ؛ اس پروگرام میں ، جنریٹ پیرمیٹیشن فنکشن ان پٹ کے طور پر سٹرنگ ایس ٹی آر لیتا ہے اور ایک صف کو واپس کرتا ہےاس تار کی اجازت"
    },
    {
        "Question": "\"ایک جاوا اسکرپٹ کلاس بنائیں جو ٹری ڈیٹا ڈھانچے کی نمائندگی کرے۔ الفاظ داخل کرنے ، تلاش کرنے اور حذف کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ کلاس کا نفاذ ہے جو الفاظ کو داخل کرنے ، تلاش کرنے اور حذف کرنے کے طریقوں کے ساتھ ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے: جاوا اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {تعمیر کنندہ () {this.children = نیا نقشہ () ؛this.isendofword = غلط ؛}} کلاس ٹری {کنسٹرکٹر () {this.root = نیا ٹرائینوڈ () ؛} داخل کریں (لفظ) {آئیے موجودہ نوڈ = this.root ؛کے لئے (آئیے i = 0 ؛ i <ورڈ.لنتھ ؛ i ++) {const Char = ورڈ [i] ؛"
    },
    {
        "Question": "زیادہ تر K الگ الگ کرداروں کے ساتھ سب سے طویل تر سٹرنگ تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ پروگرام ہے جس میں زیادہ تر K الگ الگ کرداروں کے ساتھ سب سے طویل عرصہ کا حص find ہ مل جاتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن طویل عرصے سے سوسٹرنگ وِٹ ڈسٹنٹچارس (str ، k) {آئیے زیادہ سے زیادہ = 0 ؛آئیے شروع کریں = 0 ؛آئیے الگ الگ = 0 ؛آئیے Charmap = {} ؛کے لئے (اجازت دیں = 0 ؛ اختتام <str.length ؛ end ++) {const Char = str [end] ؛if (! Charmap [Char]) {الگ الگ اکاؤنٹ ++ ؛"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دی گئی تعداد ایک بہترین نمبر ہے (اس کے تقسیم کاروں کا مجموعہ اس نمبر کے برابر ہے)۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد ایک بہترین نمبر ہے: جاوا اسکرپٹ کوپی کوڈفینکشن isperfectNumber (num) {اگر (num <= 1) {غلط واپس ؛} اجازت دیں = 1 ؛کے لئے (آئیے i = 2 ؛ i * i <= num ؛ i ++) {اگر (num ٪ i === 0) {رقم+= i ؛اگر (i * i! == num) {رقم += num / i ؛}}} واپسی SUM === NUM"
    },
    {
        "Question": "کسی دیئے گئے تار میں اسٹرنگ کے واقعات کی تعداد کو گننے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو کسی دیئے گئے تار میں کسی سٹرنگ کے واقعات کی تعداد کو گنتا ہے: جاوا اسکرپٹ کوپی کوڈفیککشن کاؤنٹسوبسٹرنگوکورینس (سٹرنگ ، سٹرنگ) {اگر (! سٹرنگ ||! سبسٹرنگ) {واپسی 0 ؛counting آئیے گنتی = 0 ؛آئیے انڈیکس = 0 ؛جبکہ (سچ) {انڈیکس = سٹرنگ۔ انڈیکسف (سٹرنگ ، انڈیکس) ؛اگر (انڈیکس === -1) {بریک ؛} گنتی ++ ؛اشاریہ += string.length ؛} واپسی کی گنتی ؛} // مثال کے طور پر استعمال: کنسول.لوگ (کاؤنٹسبسٹرنگوکورینس (\"ہیلو ہیلہیلو\" ، \"ہیلو\")) ؛// آؤٹ پٹ: 3console.log (کاؤنٹیوبسٹرنگوکورینس (\"ابابابابا\" ، \"اے بی اے\")) ؛// آؤٹ پٹ: 3console.log (کاؤنٹیوبسٹرنگوکورینس (\"ABCDE"
    },
    {
        "Question": "دیئے گئے بائنری نمبر کو اعشاریہ میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو بائنری نمبر کو اعشاریہ میں تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن بائنری ٹوڈیسیمل (بائنری) {اگر (! بائنری || ٹائپ آف بائنری! == 'سٹرنگ') {واپسی 0 ؛dec اعشاریہ = 0 ؛کانسٹ لمبائی = بائنری۔ لمبائی ؛کے لئے (آئیے i = لمبائی-1 ؛ i> = 0 ؛ i--) {const بٹ = بائنری [i] ؛اگر (بٹ === '1') {اعشاریہ += ریاضی.پو (2 ، لمبائی - 1 - i) ؛}} اعشاریہ واپسی ؛} // مثال کے طور پر استعمال: کنسول.لوگ (بائنری ٹوڈیسیمل ('101010')) ؛// آؤٹ پٹ: 42"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو ایک سیٹ ڈیٹا ڈھانچے کی نمائندگی کرے۔ شامل کرنے ، ہٹانے اور چیک کرنے کے طریقوں کو نافذ کریں کہ آیا کوئی عنصر موجود ہے یا نہیں۔\"",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو ایک سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس سیٹ {کنسٹرکٹر () {this.items = {} ؛} شامل کریں (عنصر) {if (! this.has (عنصر)) {this.items [عنصر] = عنصر ؛واپس سچ ؛} جھوٹی لوٹ ؛} حذف (عنصر) {اگر (this.has (عنصر)) {اس کو حذف کریں۔ آئٹم [عنصر] ؛واپس سچ ؛} جھوٹی لوٹ ؛} ہے (عنصر) {واپسی آبجیکٹ.پروٹوٹائپ.ہاسون پروپرٹی.کال (یہ.ایومس ، عنصر) ؛"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار ایک درست قوسین کی ترتیب ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو چیک کرتا ہے کہ اگر دیئے گئے سٹرنگ ایک درست قوسین کی ترتیب ہے تو: جاوا اسکرپٹ کوپی کوڈفکشن isvalidparentheses (str) {const اسٹیک = [] ؛کے لئے (آئیے i = 0 ؛ i <str.length ؛ i ++) {const Char = str [i] ؛اگر (چار === '(' || چار === '[' || چار === '{') {اسٹیک.پش (چار) ؛} else {اگر (اسٹیک۔ لمبائی === 0) {جھوٹا واپس ؛} const top = stack.pop () ؛ if ((چار === ')' && اوپر! == '(') || (چار === ']' && اوپر! == '[') || (چار === '}' && ٹاپ! == '{')) {"
    },
    {
        "Question": "میمورائزیشن کا استعمال کرتے ہوئے N-TH Fibonacci نمبر کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو N-Th fibonacci نمبر کا حساب لگانے کے لئے میمورائزیشن کا استعمال کرتا ہے: جاوا اسکرپٹ کوپی کوڈفونکشن fibonacci (n ، میمو = {}) {اگر (n <= 1) {واپسی n ؛} if (میمو [n]) {ریٹرن میمو [n] ؛} میمو [n] = fibonacci (n - 1 ، میمو) + fibonacci (n - 2 ، میمو) ؛میمو کی واپسی [n] ؛} // مثال کے طور پر استعمال: کنسول.لوگ (fibonacci (0)) ؛// آؤٹ پٹ:"
    },
    {
        "Question": "تار کے ایک سیٹ میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!تار کے ایک سیٹ میں سب سے طویل عام لاحقہ تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن طویل عرصے سے کامنسفکس (ڈور) {اگر (تار کی لمبائی ==== 0) {واپسی '' ؛} آئیے لاحقہ = تار [0] ؛کے لئے (آئیے i = 1 ؛ i <strings.length ؛ i ++) {constreststring = strings [i] ؛آئیے j = 0 ؛جبکہ (j <لاحقہ۔ لمبائی && j <crentstring.length && لاحقہ [j] === کرینٹسٹنگ [j])"
    },
    {
        "Question": "جاوا اسکرپٹ کلاس بنائیں جو خود کار طریقے سے فعالیت کے ل tr ٹری ڈیٹا ڈھانچے کی نمائندگی کرے۔الفاظ داخل کرنے اور سابقہ تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو خود کار طریقے سے فعالیت کے لئے ٹری ڈیٹا ڈھانچے کی نمائندگی کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {کنسٹرکٹر () {this.children = نیا نقشہ () ؛یہ"
    },
    {
        "Question": "کسی دیئے گئے صف میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!ایک دیئے گئے صف میں دو عددیوں کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام یہ ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن فائنڈ میکس پروڈکٹ (اے آر آر) {اگر (ارل لمبائی <2) {نئی غلطی پھینک دیں ('سرے میں کم از کم دو عناصر ہونا ضروری ہے') ؛max میکس پروڈکٹ = آر آر [0] * آر آر [1] ؛کے لئے (آئیے i = 0 ؛ i <arr.length ؛ i ++) {for (j = i+1 ؛ j <arr.length ؛ j ++) {کانٹ پروڈکٹ = arr [i] * arr [j] ؛اگر (پروڈکٹ> میکس پروڈکٹ) {میکس پروڈکٹ = پروڈکٹ ؛}}}"
    },
    {
        "Question": "کسی دیئے گئے اعشاریہ نمبر کو 2 اور 36 کے درمیان کسی بھی اڈے میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جس میں اعشاریہ کو 2 اور 36 کے درمیان کسی بھی اڈے میں تبدیل کرنے کے لئے: جاوا اسکرپٹ کوپی کوڈفکشن اعشاریہ اعشاریہ (نمبر ، بیس) {اگر (بیس <2 || بیس> 36) {نئی غلطی ('بیس کو 2 اور 36 کے درمیان ہونا چاہئے۔') ؛} if (نمبر === 0) {واپسی '0' ؛} آئیے نتیجہ = '' ؛کانسٹ ہندسے = '0123456789ABCDEFGHIJKLMNOPQRSTUVWWXYZ' ؛جبکہ (نمبر> 0) {کونسٹ بقیہ = نمبر ٪ بیس ؛نتیجہ = ہندسے۔ چیرات (باقی) + نتیجہ ؛نمبر = ریاضی۔ فلور (نمبر / بیس) ؛"
    },
    {
        "Question": "کسی مخصوص رینج میں تمام نمبروں کے جوڑے کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک مخصوص رینج میں تمام نمبروں کی رقم کا حساب لگانے کے لئے جاوا اسکرپٹ کا فنکشن ہے: جاوا اسکرپٹ کوپی کوڈفیکیشن کیلکولیٹیرینجسم (اسٹارٹ ، اختتام) {اجازت دیں = 0 ؛کے لئے (آئیے i = start ؛ i <= end ؛ i ++) {رقم+= i ؛} واپسی SUM ؛} // مثال کے استعمال: کانسٹ اسٹارٹ = 1 ؛ کنسٹ اینڈ = 10 ؛ کانسٹ سم = کیلکولیٹرینجسم (اسٹارٹ ، اینڈ) ؛ کنسول.لوگ (رقم) ؛// آؤٹ پٹ: 55 کیلکولیٹرینجسم فنکشن دو دلائل لیتا ہے: شروع کریں (رینج کی ابتدائی تعداد) اور اختتام (حد کی اختتامی تعداد)اختتام (شامل)ہر تکرار میں ، یہ موجودہ نمبر کو متغیر میں شامل کرتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن isvalidipv4Address (IPAddress) {Const پیٹرن = /^(\\ d {1،3}) \\. (\\ d {1،3}) \\.(\\ d {1،3}) \\. (\\ d {1،3}) $/؛کانسٹ میچ = پیٹرن.ایکسیک (آئی پی ایڈریس) ؛اگر (! میچ) {جھوٹی لوٹیں ؛} کے لئے (آئیے i = 1 ؛ i <= 4 ؛ i ++) {const octet = parseint (میچ [i] ، 10) ؛اگر (isnan (Octet) || آکٹٹ"
    },
    {
        "Question": "متعدد خصوصیات اور ترتیب کے احکامات کی بنیاد پر اشیاء کی ایک صف کو ترتیب دینے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو متعدد خصوصیات اور ترتیب کے احکامات پر مبنی اشیاء کی ایک صف کو ترتیب دے سکتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن ترتیب ترتیب سے متعلقہ بائی پروپرٹیز (اے آر آر ، پراپرٹیز) {ریٹرن آر آر ایسورٹ ((اے ، بی) => {کے لئے (i = 0 ؛ i <<<<properties.length ؛ i ++) {const {prop ، آرڈر} = پراپرٹیز [i] const const avalue = a [prop] ؛ const balue = b [prop] ؛ if (avalue <balve) {واپسی آرڈر === 'asc'؟ -1: 1 ؛} دوسری صورت میں (avalue> bvalue) {واپسی کا آرڈر === 'asc'؟ 1: -1 ؛}}}} 0 ؛}) ؛} // مثال کے استعمال: کانسٹنٹ لوگ = [{نام"
    },
    {
        "Question": "\"جاوا اسکرپٹ کلاس بنائیں جو سرکلر منسلک فہرست کی نمائندگی کرتی ہے۔ نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو نوڈس کو داخل کرنے ، حذف کرنے اور تلاش کرنے کے طریقوں کے ساتھ سرکلر منسلک فہرست کی نمائندگی کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس نوڈ {کنسٹرکٹر (ڈیٹا) {this.data = ڈیٹا ؛this.next = null ؛}} کلاس سرکلر لنکڈ لسٹ {کنسٹرکٹر () {this.head = null ؛this.tail = null ؛} داخل کریں (ڈیٹا) {کونسٹ نیو نوڈ = نیا نوڈ (ڈیٹا) ؛اگر (! this.head) {this.head = newnode ؛this.tail = newnode ؛newnode.next = newnode ؛} else {newnode.next = this.head ؛this.tail.next = newnode ؛this.tail = newnode ؛}} حذف (ڈیٹا) {اگر (! this.head) {واپسی ؛current موجودہ نوڈ = this.head ؛آئیے پری نوڈ = null ؛"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی صف میں سب سے طویل عرصہ تک بڑھتی ہوئی سبری کو تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک پروگرام یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن فائنلنگسٹینکریزنگسنگ بورے (اے آر آر) {آئیے زیادہ سے زیادہ لمبائی = 1 ؛// طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی اسٹارٹ انڈیکس = 0 ؛// طویل ترین بڑھتی ہوئی سبری کا آغاز انڈیکس موجودہ لمبائی = 1 ؛// موجودہ بڑھتی ہوئی سبری کی لمبائی موجودہ اسٹارٹ انڈیکس = 0 ؛// موجودہ بڑھتی ہوئی سبری کا آغاز انڈیکس (آئیے i = 1 ؛ i <arr.length ؛ i ++) {اگر (arr [i]> arr [i - 1]) {// موجودہ بڑھتے ہوئے سبارے کی لمبائی میں اضافہ کریںموجودہ لمبائی ++ ؛} else {// اگر ضروری ہو تو طویل عرصے تک بڑھتے ہوئے سبیرے کی لمبائی اور شروعاتی انڈیکس کو اپ ڈیٹ کریں"
    },
    {
        "Question": "کسی دیئے گئے تار سے ڈپلیکیٹ حروف کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!کسی دیئے گئے تار سے نقل کے حروف کو دور کرنے کے لئے جاوا اسکرپٹ کا ایک فنکشن یہ ہے: جاوا اسکرپٹ کوپی کوڈفکشن کو ہٹا دیا گیا (str) {لیٹ انکیکچرس = \"\" ؛// سٹرنگ کے لئے منفرد حروف کو ذخیرہ کرنے کے لئے (i = 0 ؛ i <str.length ؛ i ++) {if (uniquechars.indexof (str [i]) === -1) {// کردار کو uniquechars میں شامل کریں اگر یہ ہے توپہلے سے موجود نہیں یوکیچارس += str [i] ؛}} انویکچرس کی واپسی ؛} // مثال کے طور پر استعمال: کانسٹٹر = \"ہیلو\" ؛ کانسٹنگ نتیجہ = ہٹانے والے (ایس ٹی آر) ؛ کنسول.لاگ (نتیجہ) ؛// آؤٹ پٹ: \"ہیلو\" اس فنکشن میں ، ہٹا دیا جاتا ہے ، ان پٹ سٹرنگ ایس ٹی آر کردار کے ذریعہ کردار سے گزرتا ہے۔ہر کردار کے ل it ، یہ چیک کرتا ہے کہ آیا پہلے سے"
    },
    {
        "Question": "کسی دیئے گئے نمبر کو اس کے متعلقہ رومن ہندسوں کی نمائندگی میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو ایک دیئے گئے نمبر کو اس کے متعلقہ رومن ہندسے کی نمائندگی میں تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن کنورٹورٹورومن (نمبر) {کانسٹنٹ رومانومیرلز = {1000: \"ایم\" ، 900: \"سی ایم\" ، 500: \"ڈی\" ، 400: \"سی ڈی\"، 100: \"C\" ، 90: \"XC\" ، 50: \"L\" ، 40: \"XL\" ، 10: \"X\" ، 9: \"IX\" ، 5: \"V\" ، 4: \"iv\" ، 1: \"میں\"  }؛آئیے رومن = \"\" ؛کے لئے (رومانومیرلز میں قدر دیں) {جبکہ (نمبر> = ویلیو) {رومن += رومانومیرلز [قدر] ؛نمبر -= قیمت ؛}} رومن واپس کریں ؛} // مثال کے استعمال: کنسول.لاگ (کنورٹٹو"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے اسٹرنگ صرف حرفیومیرک کرداروں پر غور کرنے اور کیس کو نظرانداز کرنے پر غور کرنے کے لئے ایک درست پلنڈرووم ہے۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو چیک کرتا ہے کہ اگر کوئی دیئے گئے تار صرف حرفی حروف پر غور کرنے اور کیس کو نظرانداز کرنے پر ایک درست پلنڈرووم ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن آئسپالینڈوم (ایس ٹی آر) {// غیر الفانومرک حروف کو ہٹا دیں اور لوئر کیسنس کلینٹر = str.replace (/[^ میں تبدیل کریں۔A-za-Z0-9]/g ، \"\") .tolowercase () ؛// چیک کریں کہ آیا صاف ستھرا تار اس کے الٹ ریٹرن کلینٹر === کلینٹر.سپلٹ (\"\") کے برابر ہے یا نہیں۔ ریورس (). شامل ہوں (\"\") ؛} // مثال کے طور پر استعمال: کنسول.لوگ (ispalindrome (\"ایک آدمی، ایک منصوبہ ، ایک نہر: پاناما \")) ؛// آؤٹ پٹ: trueconsole.log (ispalindrome (\"ریس ایک کار\")) ؛// آؤٹ پٹ: اس فنکشن ، ispalindrome ، ہم ان پٹ اسٹرنگ سے تمام غیر الفانومرک حرفوں کو تبدیل کرنے کے طریقہ کار اور باقاعدہ اظہار (/[^A-ZA-Z0-9]/g) کا استعمال کرتے ہوئے ان پٹ سٹرنگ سے ہٹا کر شروع کرتے ہیں۔ہم ٹولور کیس کے طریقہ کار کا استعمال کرتے ہوئے نتیجے میں ہونے والے تار کو چھوٹے سے بھی تبدیل کرتے ہیں۔اس کو حاصل کرنے کے ل we ، ہم `کا استعمال کرتے ہوئے اسٹرنگ کو کرداروں کی ایک صف میں تقسیم کرتے ہیں"
    },
    {
        "Question": "تاروں کے ایک سیٹ میں سب سے طویل عام سٹرنگ تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جس میں تار کے ایک سیٹ میں سب سے طویل مشترکہ تزئین و آرائش ملتی ہے: جاوا اسکرپٹ کوپی کوڈفکشن سب سے طویل عرصے سے کامنسوبسٹرنگ (ڈور) {اگر (ڈور۔ لمبائی === 0) {واپسی '' ؛const // سیٹ میں مختصر ترین تار تلاش کریں۔آئیے طویل عرصے سے کام کریں = '' ؛آئیے کرینٹسوبسٹرنگ = '' ؛// سب سے کم تار کے ہر کردار پر تکرار کریں (i = 0 ؛ i <مختصر ترین. لمبائی ؛ i ++) {// ہر کردار کے لئے موجودہ سبسٹرنگ کو دوبارہ ترتیب دیں = '' ؛// چیک کریں"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو گراف ڈیٹا ڈھانچے کی نمائندگی کرے۔دو نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے اور ٹوپولوجیکل چھانٹنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ کلاس ہے جو گراف کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتی ہے اور ڈجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے دو نوڈس کے مابین مختصر ترین راستہ تلاش کرنے اور ٹوپولوجیکل چھانٹنے کے طریقوں کو نافذ کرتی ہے: جاوا اسکرپٹ کوپی کوڈکلاس گراف {کنسٹرکٹر () {this.vertices = نیا نقشہ () ؛} ایڈورٹیکس (ورٹیکس) {اگر (! this.vertices.has (vertex)) {this.vertices.set (ورٹیکس ، نیا نقشہ ()) ؛}} ایڈج (ورٹیکس 1 ، ورٹیکس 2 ، وزن) {اگر (this.vertices.has (vertex1) && this.vertices.has (vertex2)) {this.vertices.get (vertex1). سیٹ (ورٹیکس 2 ، وزن) ؛}} ٹوپولوجسٹسورٹ () {کنسٹ ملاحظہ = نیا سیٹ () ؛کانسٹ اسٹیک = [] ؛کے لئے (this.vertices.keys ()) {اگر (! ملاحظہ کیا گیا۔ ہاس (ورٹیکس)) {this.topologicalsortutil (ورٹیکس ، ملاحظہ کیا گیا ، اسٹیک) ؛}}"
    },
    {
        "Question": "بائنری درخت میں بائیں بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!بائنری درخت میں بائیں بائیں پتیوں کا مجموعہ تلاش کرنے کے لئے جاوا اسکرپٹ کا ایک پروگرام یہ ہے: جاوا اسکرپٹ کوپی کوڈکلاس ٹرینوڈ {کنسٹرکٹر (ویل ، بائیں = NULL ، دائیں = NULL) {this.val = ویل ؛this.left = بائیں ؛this.right = دائیں ؛}} فنکشن سموفلیفٹ لیف (جڑ) {اگر (جڑ ==== null) {واپس 0 ؛} دو رقم ="
    },
    {
        "Question": "عددی کی ایک مخصوص صف میں کم از کم K عناصر کے ساتھ سبری کی سب سے بڑی رقم تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جس میں ایک سب سے سب سے بڑی رقم ملتی ہے جس میں کم سے کم K عناصر کے ساتھ عددیوں کی ایک صف میں موجود ہیں: جاوا اسکرپٹ کوپی کوڈفکشن فائنلرجسٹسم (اے آر آر ، کے) {کانسٹ این = آر ایل لمبائی ؛// چیک کریں کہ آیا سرنی میں کافی عناصر موجود ہیں اگر (n <K) {واپس کال کریں ؛} آئیے کرینٹسم = 0 ؛آئیے میکسم = 0 ؛// پہلے K عناصر کے مجموعہ کی گنتی کریں (آئیے i = 0 ؛ i <k ؛ i ++) {کرنٹسم+= آر [i] ؛} میکسم = کرینٹسم ؛// ونڈو کو سلائیڈ کریں اور (i = k ؛ i <n ؛ i ++) کے لئے رقم کو اپ ڈیٹ کریں {کرینٹسم+= ار [i] - arr [i - k] ؛میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛max میکسم واپسی} // مثال کے استعمال: کانسٹ آر آر آر"
    },
    {
        "Question": "دیئے گئے رومن ہندسے کو اس کے اسی اعشاریہ نمبر میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جو ایک دیئے گئے رومن ہندسے کو اس کے متعلقہ اعشاریہ میں تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن رومانٹوڈیسیمل (رومانومرل) {کانسٹ رومان میپ = {i: 1 ، V: 5 ، X: 10 ، L: 50 ، C: 100 ، D: 500 ، ایم: 1000 ،} ؛آئیے نتیجہ = 0 ؛آئیے پریوالو = 0 ؛کے لئے (آئیے i = رومانومیرل۔ لمبائی-1 ؛ i> = 0 ؛ i--) const const curtentsymbol = رومانومرل [i] ؛Const موجودہ ویلیو = رومان میپ [کرینٹسمبول] ؛اگر (کرنٹ ویلیو> = پریویلیو)"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار متوازن قوسین کے ساتھ ریاضی کا اظہار ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جو چیک کرتا ہے کہ اگر دیئے گئے تار متوازن قوسین کے ساتھ ایک ریاضی کا اظہار ہے: جاوا اسکرپٹ کوپی کوڈفکشن isbalancedarithmeticexpression (اظہار) st اسٹیک = [] ؛کے لئے (آئیے i = 0 ؛ i <اظہار۔ لمبائی ؛ i ++) {const char = اظہار [i] ؛اگر (چار === '(') {اسٹیک.پش (چار) ؛} else اگر (چار === ')') {اگر (اسٹیک۔ لمبائی === 0) {غلط واپس ؛} else {stack.pop () ؛}}} ریٹرن اسٹیک۔ لمبائی === 0 ؛} // مثال کے طور پر استعمال: کنسول.لاگ (isbalancedarithmeticexpression ('(3 + 4) * (5 - 2)')) ؛// آؤٹ پٹ: trueconsole.log (isbalancedarithmeticexpression ('3 + 4) * (5 - 2)')) ؛// آؤٹ پٹ: falseconsole.log (isbalancedarithmeticexpression ('(3 + 4 * (5 - 2)')) ؛ // آؤٹ پٹ: غلط ``"
    },
    {
        "Question": "الفاظ کی ترتیب کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں اور کسی جملے میں ہر کردار کے معاملے کو متبادل بنائیں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جو الفاظ کی ترتیب کو تبدیل کرتا ہے اور کسی جملے میں ہر کردار کے معاملے کو تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈفکشن ریورسورڈسینڈرنیٹیکیس (جملہ) {الفاظ = جملے۔ اسپلٹ ('') ؛کانسٹ الٹ ورڈز = الفاظ۔ نقشہ ((لفظ ، انڈیکس) => {کانسٹ الٹ = ورڈ.سپلٹ (''): الٹ. ٹولور کیس () ؛}) ؛واپس الٹ ورڈز۔ join ('') ؛} // مثال کے استعمال: کنسول.لوگ (ریورسورڈسینڈرنیٹیکیس ('ہیلو ورلڈ!')) ؛// آؤٹ پٹ: \"اولیہ ڈلرو!\" کنسول.لوگ (ریورسورورڈسینڈنٹریٹیکیس ('یہ ایک امتحان ہے')) ؛// آؤٹ پٹ: \"سیہٹ ایک TSET ہے\" اس نفاذ میں ، ہم سب سے پہلے ان پٹ جملہ کو الفاظ کی صف میں تقسیم کرتے ہیں"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو ہیش ٹیبل ڈیٹا ڈھانچے کی نمائندگی کرے۔کلیدی قدر کے جوڑے داخل کرنے اور بازیافت کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں جاوا اسکرپٹ کلاس کا نفاذ ہے جو ہیش ٹیبل کی نمائندگی کرتا ہے: جاوا اسکرپٹ کوپی کوڈکلاس ہیش ٹیبل {کنسٹرکٹر (سائز = 100) {this.size = سائز ؛this.buckets = نیا سرنی (سائز)} ہیش (کلید) {آئیے ہیش ویلیو = 0 ؛کے لئے (آئیے i = 0 ؛ i <key.length ؛ i ++) {ہیش ویلیو+= key.charcodeat (i) ؛} ہیش ویلیو ٪ اس کو واپس کریں۔ سائز ؛} داخل کریں (کلید ، قدر) {"
    },
    {
        "Question": "تار کے ایک سیٹ میں سب سے طویل عام مشترکہ حصول تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "یقینا!تاروں کے ایک سیٹ کے درمیان سب سے طویل عام مشترکہ حصول تلاش کرنے کے لئے جاوا اسکرپٹ فنکشن کا نفاذ یہاں ہے: جاوا اسکرپٹ کوپی کوڈفکشن طویل ترین کامنسوبسینس (ڈور) {اگر (ڈور۔ لمبائی ==== 0) {واپسی '' ؛} // سب سے طویل عام مشترکہ ٹیبل کونٹ ٹیبل ٹیبل = سرنی۔// (آئیے i = 1 ؛ i <= strings.length ؛ i ++) کے لئے سب سے طویل عام مشترکہ حصول کا حساب لگائیں۔"
    },
    {
        "Question": "کسی دیئے گئے اعشاریہ نمبر کو رومن ہندسوں میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!اعشاریہ کو رومن ہندسوں میں تبدیل کرنے کے لئے جاوا اسکرپٹ فنکشن کا نفاذ یہاں ہے: جاوا اسکرپٹ کوپی کوڈفکشن ڈیسمٹلٹورومان (اعشاریہ) {کنسٹ ڈیسمال ویلیوس = [1000 ، 900 ، 500 ، 400 ، 100 ، 90 ، 50 ، 40 ، 10 ، 9 ، 5 ، 4 ، 400، 1] ؛Const romansymbols = ['M' ، 'CM' ، 'D' ، 'CD' ، 'C' ، 'xc' ، 'L' ، 'xl' ، 'x' ، 'ix' ، 'v' ، 'iv''، 'میں']؛آئیے نتیجہ = '' ؛کے لئے"
    },
    {
        "Question": "کسی بھی حد میں یہاں تک کہ تمام نمبروں کی رقم کا حساب لگانے کے لئے جاوا اسکرپٹ فنکشن بنائیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو ایک مخصوص حد میں یہاں تک کہ تمام تعداد کے مجموعہ کا حساب لگاتا ہے: جاوا اسکرپٹ کوپی کوڈفونکشن sumofevenumbers (شروع ، اختتام) {اجازت دیں = 0 ؛// یقینی بنائیں کہ شروع کریں یہاں تک کہ اگر (شروع کریں 2! == 0) {اسٹارٹ ++ ؛} کے لئے (i = start ؛ i <= end ؛ i += 2) {رقم += i ؛} رقم واپسی ؛} // مثال کے استعمال: کنسول.لوگ (سموفی ایوینمبرس (1 ، 10)) ؛// آؤٹ پٹ: 30 (2 + 4 + 6 + 8 + 10 = 30) کنسول.لاگ (سموف ایونمبرس (2 ، 20)) ؛// آؤٹ پٹ: 110 (2 + 4 + 6 + 8 + 10 + 12 + 14 + 14 + 16 + 18 + 20 = 110) اس نفاذ میں ، سموفی ایونومبرس فنکشن دو پیرامیٹرز لیتا ہے: شروع اور اختتام ، جو تعداد کی حد کی نمائندگی کرتا ہےغور کریں۔ فنکشن ٹریک رکھنے کے لئے ایک SUM متغیر کی ابتدا کرتا ہے"
    },
    {
        "Question": "عدد کی ایک دی گئی صف میں زیادہ تر K عناصر کے ساتھ سب سے زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جس میں ایک سب سے زیادہ کے عناصر کے ساتھ ایک سب سے زیادہ کے عناصر کے ساتھ زیادہ سے زیادہ رقم ملتی ہے جس میں عددیوں کی ایک مخصوص صف میں: جاوا اسکرپٹ کوپی کوڈ فینکشن میکسبراسم (اے آر آر ، کے) {آئیے میکسم = 0 ؛آئیے کرینٹسم = 0 ؛آئیے شروع کریں = 0 ؛کے لئے (end = 0 ؛ اختتام <arr.length ؛ end ++) {کرینٹسم+= arr [end] ؛اگر (اختتام - اسٹارٹ + 1> K) {کرینٹسم - = آر آر [شروع] ؛شروع ++ ؛} میکسم = ریاضی۔ میکس (میکسم ، کرینٹسم) ؛max میکسم}} // مثال کے طور پر استعمال: کنسول.لوگ (میکسبرارسم ([1 ، 2 ، 3 ، 4 ، 5] ، 3)) ؛"
    },
    {
        "Question": "الفاظ کی ترتیب کو الٹ کرنے اور کسی جملے میں ہر کردار کے معاملے کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک جاوا اسکرپٹ فنکشن ہے جو الفاظ کی ترتیب کو تبدیل کرتا ہے اور کسی دیئے گئے جملے میں ہر کردار کے معاملے کو تبدیل کرتا ہے: جاوا اسکرپٹ کوپی کوڈفینکشن ریورسورڈسینڈری ورسیکیس (جملہ) {// جملے کو الفاظ کی صف میں تقسیم کریں۔// الفاظ کی ترتیب کو الٹ دیں اور ہر کردار کے معاملے کو الٹ الٹ ورڈز = ورڈز۔ میپ (لفظ => {ریٹرن ورڈ .split ('' '). میپ (چار => {اگر (چار === چار.ٹوپر کیس ((چار ===؟)) {ریٹرن چار.ٹولور کیس () ؛} else {ریٹرن چار. ٹوپپر کیس () ؛}})// الٹ الفاظ کو کسی جملے میں شامل کریں۔الٹ الٹینسیٹینس} // مثال کے طور پر استعمال: کنسول.لوگ (ریورسورڈسینڈریورسیکیس (\"ہیلو ورلڈ!\")) ؛// آؤٹ پٹ: \"ڈیلرو اولیہ!\" کنسول.لوگ (ریورسورورڈسینڈریورسیکیس (\"میں اوپن آئی ہوں۔\")) ؛// آؤٹ پٹ: \"I MA iaepna.\" کنسول.لوگ (ریورسورورڈسینڈریورسیکیس (\"جاوا اسکرپٹ تفریح ہے\")) ؛// آؤٹ پٹ: \"nuf si tpirscsavaj\" ``"
    },
    {
        "Question": "ایک جاوا اسکرپٹ کلاس بنائیں جو لاحقہ درخت کے اعداد و شمار کے ڈھانچے کی نمائندگی کرتا ہو۔سبسٹرنگز کو تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "ایک مکمل لاحقہ درخت کے اعداد و شمار کے ڈھانچے کو اس کی تمام خصوصیات کے ساتھ نافذ کرنا ایک سادہ ردعمل کے دائرہ کار سے باہر ہے۔تاہم ، میں آپ کو جاوا اسکرپٹ میں ایک لاحقہ ٹری کلاس کا بنیادی نفاذ فراہم کرسکتا ہوں جو سبسٹرنگز کی تلاش میں مدد کرتا ہے۔یہاں ایک مثال ہے: جاوا اسکرپٹ کوپی کوڈکلاس لاحقہ لاحقہ {"
    },
    {
        "Question": "دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے جاوا اسکرپٹ پروگرام لکھیں۔",
        "Answer": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے ل you ، آپ ماناچر کے الگورتھم کو استعمال کرسکتے ہیں۔یہاں ایک مثال جاوا اسکرپٹ پروگرام ہے جو اس الگورتھم کو نافذ کرتا ہے: جاوا اسکرپٹ کوپی کوڈ فینکشن Findlongestpalindromicsbstring (سٹرنگ) {// خصوصی حروف کو شامل کرنے کے لئے سٹرنگ کو پریپروسیس کرتے ہیں۔// متغیرات کو شروع کریں مرکز = 0 ؛چلو دائیں = 0 ؛کونٹ پیلنڈروومل لمبائی = نئی سرنی (ترمیم شدہ اسٹرنگ.لنتھ). فل (0) ؛کے لئے (آئیے i = 1 ؛ i <modifiedString.length - 1 ؛ i ++) {// اصل اسٹرنگ کانسٹنگ آئینہ = 2 * سینٹر میں اسی کردار کا انڈیکس تلاش کریں - i ؛// چیک کریں کہ آیا موجودہ انڈیکس موجودہ پیلنڈرووم کی حدود میں ہے اگر (i <صحیح) {palindromelengths [i] = math.min (دائیں - i ، palindromelengths [آئینہ]) ؛} // موجودہ انڈیکس کے ارد گرد پیلینڈرووم کو وسعت دیں جبکہ (ترمیم شدہ اسٹرنگ [i + 1 + palindromelengths [i]] === ترمیم شدہ سٹرنگ"
    },
    {
        "Question": "عدد کے دھارے کے وسط کو تلاش کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "عدد کے دھارے کے وسط کو تلاش کرنے کے ل you ، آپ دو ڈھیر استعمال کرسکتے ہیں: نمبروں کے نچلے نصف حصے (بائیں ڈھیر) کو ذخیرہ کرنے کے لئے ایک زیادہ سے زیادہ ہیپ ، اور نمبروں کے اوپری نصف حصے (دائیں ہیپ) کو ذخیرہ کرنے کے لئے ایک کم سے کم ہیپ (دائیں ڈھیر)یہ نقطہ نظر آپ کو میڈین پر موثر انداز میں ٹریک رکھنے کی اجازت دیتا ہے کیونکہ نئی تعداد شامل کی جاتی ہے۔ یہاں ایک ایسی تقریب کا نفاذ ہے جس میں عددیوں کے دھارے کا درمیانی درجے کا پتہ چلتا ہے: جاوا اسکرپٹ کوپی کوڈیکلاس میڈین فائنڈر {کنسٹرکٹر () {this.leftheap = نیا میکس ہیپ ()؛// زیادہ سے زیادہ تعداد میں تعداد کے نچلے حصے کو ذخیرہ کرنے کے لئے۔// کم سے کم تعداد کے اوپری نصف حصے} ایڈنمبر (نمبر) {اگر (this.leftheap.isempty () || num <this.leftheap.peek ()) {this.leftheap.insert (num) ؛} else {this.rightEAT.insert (num) ؛} // ڈھیروں کو متوازن کریں اگر ان کے سائز کا فرق 1 سے زیادہ ہے تو (this.leftheap.size () - یہ"
    }
]