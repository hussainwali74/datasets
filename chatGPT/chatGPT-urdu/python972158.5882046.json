[
    {
        "Question": "ازگر",
        "Answer": "ہیلو!میں آپ کو ازگر کے ساتھ کس طرح مدد کرسکتا ہوں؟"
    },
    {
        "Question": "فہرست میں تمام نمبروں کا مجموعہ تلاش کرنے کے لئے ایک ازگر پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک مثال ازگر پروگرام ہے جو ایک فہرست میں تمام تعداد کے مجموعہ کا حساب لگاتا ہے: پائیٹون کوپی کوڈ ڈیف SUM_OF_LIST (نمبر): تعداد میں نمبر کے لئے کل = 0: کل += نمبر ریٹرن کل# مثال کے طور پر usagemy_list = [1 ، 2 ، 3 ، 4 ،5] نتیجہ = sum_of_list (my_list) پرنٹ (\"فہرست کا مجموعہ:\" ، نتیجہ) اس پروگرام میں ، Sum_of_list فنکشن ایک دلیل کے طور پر نمبروں کی فہرست لیتا ہے۔یہ ایک متغیر `کل کو شروع کرتا ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا دیئے گئے تار ایک پیلنڈرووم ہے۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو چیک کرتا ہے کہ اگر دیئے گئے تار ایک پالندرووم ہے تو: پائیتھون کوپی کوڈیڈف آئی ایس_پالندرووم (سٹرنگ):"
    },
    {
        "Question": "کسی دیئے گئے نمبر تک تمام پرائم نمبر تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جو کسی مخصوص نمبر تک تمام بنیادی تعداد تیار کرتا ہے: پائیتھون کوپی کوڈ ڈیف جنریٹ_پرائمز (این): پرائمز = [] رینج میں نمبر (2 ، این + 1) کے لئے: is_prime = in range کے لئے سچ (2 ، int (int (int (int (2 ، int (intنمبر ** 0.5) + 1): اگر نمبر ٪ i == 0: is_prime = غلط بریک اگر is_prime: primes.append (num) واپسی پرائمز# مثال usagelimit = 30prime_numbers = جنریٹ_پرائمز (حد) پرنٹ (\"پرائم نمبر اپ اپ"
    },
    {
        "Question": "ایک فنکشن بنائیں جو ان پٹ کے طور پر تار لیتا ہے اور تار میں ہر کردار کی فریکوئنسی لوٹاتا ہے۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو کسی دیئے گئے تار میں ہر کردار کی فریکوئنسی کا حساب لگاتا ہے: پائیتھون کوپی کوڈیڈف کریکٹر_فری کنوینسی (سٹرنگ): تعدد = {string سٹرنگ میں چار کے لئے: اگر فریکوینسی میں چار: فریکوینسی [چار] += 1 اور: فریکوینسی [چار]= 1 ریٹرن فریکوئینسی# مثال usagemy_string = \"ہیلو ، دنیا!\" نتیجہ = کریکٹر_فریونسی (my_string) پرنٹ (\"کریکٹر فریکوینسی:\" ، نتیجہ) اس پروگرام میں ، کریکٹر_فریکونسی فنکشن دلیل کے طور پر ایک تار لیتا ہے۔یہ ہر کردار کی تعدد کو ذخیرہ کرنے کے لئے تعدد نامی ایک خالی لغت کا آغاز کرتا ہے۔ فنکشن پھر تار میں ہر کردار پر تکرار کرتا ہے `کے لئے` کا استعمال کرتے ہوئے"
    },
    {
        "Question": "ترتیب شدہ فہرست میں کسی عنصر کی پوزیشن تلاش کرنے کے لئے بائنری سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!ایک ترتیب شدہ فہرست میں کسی عنصر کی پوزیشن تلاش کرنے کے لئے بائنری سرچ الگورتھم کا ایک ازگر کا نفاذ یہاں ہے: پائیتھون کوپی کوڈ ڈیف بائنری_سارچ (ترتیب شدہ_ لسٹ ، ہدف): کم = 0 ہائی = لین (ترتیب شدہ_ لسٹ) - 1 جبکہ کم <= اعلی: درمیانی = (اعلی:کم + اعلی) // 2 اگر چھانٹیا_ لسٹ [درمیانی] == ہدف: مڈ ایلف کو ترتیب دیں [وسط] <ہدف: کم = وسط + 1 اور: اعلی = وسط - 1 ریٹرن -1# مثال usagemy_list = [1 ، 3 ،5 ، 7 ،"
    },
    {
        "Question": "لنکڈ فہرست کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کو پلٹنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو ایک منسلک فہرست کی نمائندگی کرتی ہے اور اس کو الٹ کرنے کے لئے کسی طریقہ کار پر عمل درآمد کرتی ہے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ = نون کلاس لنکڈ لسٹ"
    },
    {
        "Question": "ایک ایسا فنکشن بنائیں جس میں تار کی فہرست میں سب سے طویل عام پریفکس سٹرنگ مل جائے۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو تار کی فہرست میں سب سے طویل عام پریفکس سٹرنگ تلاش کرتا ہے: پائیٹون کوپی کوڈ ڈیف طویل ترین_کومون_پریفکس (اسٹرنگز): اگر تار نہیں ہے تو: واپس \"مختصر ترین_سٹرنگ = منٹ (سٹرنگ ، کلید = لین) پریفکس =\" \"I کے لئے I (In Range کے لئے (لین (مختصر ترین_اسٹرنگ)): کرنٹ_چار = مختصر ترین_سٹرنگ [i] تار میں تار کے لئے: اگر سٹرنگ [i]! = موجودہ_چار: ریٹرن پریفکس پریفکس += کرنٹ_چار ریٹرن پریفکس# مثال usagemy_strings = [\"ایپل\" ، \"ایپ\" ، \"ایپلی کیشن\"، \"اہلیت\"] نتیجہ = طویل ترین_کومون_پریفکس (my_strings) پرنٹ (\"سب سے طویل مشترکہ سابقہ:\" ، نتیجہ) اس پروگرام میں ، طویل ترین_کومون_پریفکس فنکشن"
    },
    {
        "Question": "ایک ایسے سجاوٹ کو نافذ کریں جو کسی فنکشن کے عمل کے وقت کی پیمائش کرے۔",
        "Answer": "یقینا!یہاں ایک ازگر ڈیکوریٹر ہے جو کسی فنکشن کے عملدرآمد کے وقت کی پیمائش کرتا ہے: پائیتھون کوپی کوڈیمپورٹ ٹائم ڈیف پیمائش_ ٹائم (فنک): ڈیف ریپر (*آرگس ، ** کوورگس): اسٹارٹ ٹائم = ٹائم ٹائم (وقت () نتیجہ = فنک (*آرگس ، ** KWARGS)end_time = وقت۔"
    },
    {
        "Question": "کسی خاص کلید کی بنیاد پر لغت کی فہرست ترتیب دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جو ایک مخصوص کلید پر مبنی لغات کی فہرست کو ترتیب دیتا ہے: پائیتھون کوپی کوڈڈف ترتیب_لسٹ_ف_ ڈکٹ (فہرست_ او ایف_ ڈکٹ ، کلید): ترتیب شدہ_ لسٹ = ترتیب دیا گیا (فہرست_ف_ ڈکٹ ، کلیدی = لیمبڈا ایکس: x [x [key]نام \":\" ایلس \"،\" عمر \": 25} ، {\" نام \":\" باب \"،\" عمر \": 30} ، {\" نام \":\" چارلی \"،\" عمر \": 20}] ترتیب شدہ_ لسٹ = ترتیب دیں"
    },
    {
        "Question": "کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ایک تکرار والی تقریب کو نافذ کریں۔",
        "Answer": "یقینا!یہاں دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ایک ازگر تکرار کرنے والا فنکشن ہے: پائیتھون کوپی کوڈیڈف فیکٹوریئل (این): اگر n == 0: واپسی 1 اور: ریٹرن این * فیکٹوریئل (این - 1)# مثال کے طور پر استعمال کی گئیاس پروگرام میں پرنٹ (\"فیکٹوریل آف\" ، نمبر ، \"ہے\" ، \"ہے) ، حقیقت پسندانہ فنکشن ایک دلیل کے طور پر ایک نمبر N لے جاتا ہے۔یہ حقیقت کا حساب لگانے کے لئے ایک تکرار نقطہ نظر کا استعمال کرتا ہے۔ تکرار کا بنیادی معاملہ اس وقت ہوتا ہے جب ن کے برابر ہوتا ہے۔فنکشن بار بار N - 1 کے ساتھ کال کرتا ہے اور نتیجہ کو N کے ذریعہ ضرب دیتا ہے۔اس کی وجہ یہ ہے کہ حقیقت پسند ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک ازگر پروگرام لکھیں کہ آیا اسٹرنگ میں صرف ہندسے ہوتے ہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام یہ ہے کہ آیا کسی تار میں صرف ہندسے ہوتے ہیں: پائیتھون کوپی کوڈ ڈیف پر مشتمل ہے_ونلی_ڈیجٹس (سٹرنگ): ریٹرن سٹرنگ۔ آئی ایس ڈیگٹ ()# مثال usagemy_string = \"12345\" نتیجہ = پر مشتمل ہے۔. \") اور: پرنٹ (\" اسٹرنگ میں صرف ہندسے نہیں ہوتے ہیں۔ \") اس پروگرام میں ، Contiss_only_digits فنکشن ایک دلیل کے طور پر تار تار لیتا ہے۔اس میں یہ معلوم کرنے کے لئے isdigit () کا طریقہ استعمال کیا جاتا ہے کہ آیا تار میں موجود تمام حرف ہندسے ہیں۔ اگر سٹرنگ میں موجود تمام حروف ہندسے ہیں ، تو isdigit () طریقہ درست لوٹتا ہے ،"
    },
    {
        "Question": "فہرست میں دوسرا سب سے بڑا عنصر تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ایک فہرست میں دوسرا سب سے بڑا عنصر تلاش کرتا ہے: پائیتھون کوپی کوڈیڈف Find_second_larget (LST): اگر لین (LST) <2: کوئی بھی نہیں سب سے بڑا = فلوٹ ('-INF') دوسرا_لارسٹ = فلوٹ ('-inf') کے لئے واپسایل ایس ٹی میں نمبر: اگر نمبر> سب سے بڑا: دوسرا_لارسٹ = سب سے بڑا سب سے بڑا = نمبر ایلف نمبر> دوسرا_لرجسٹ اور نمبر <سب سے بڑا: دوسرا_لارسٹ = نمبر ریٹرن سیکنڈ_لارسٹ# مثال usagemy_list = [5 ، 9 ، 2 ، 7 ، 3 ،"
    },
    {
        "Question": "انفرادی الفاظ کو تبدیل کیے بغیر دیئے گئے جملے کو الٹ کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!انفرادی الفاظ کو تبدیل کیے بغیر دیئے گئے جملے کو الٹا کرنے کے لئے ایک ازگر پروگرام یہ ہے: پائیتھون کوپی کوڈ ڈیف ریورس_سینٹینس (جملہ): الفاظ = جملہ۔ اسپلٹ () الٹ_ ورڈز = الٹ (الفاظ) الٹ_سینٹینس = \"\"\"ہیلو ، دنیا! آپ کیسے ہیں؟\" نتیجہ = ریورس_سینٹینس (my_sentence) پرنٹ (\"الٹ جملہ:\" ، نتیجہ) اس پروگرام میں ، ریورس_سینٹینس فنکشن ان پٹ کے طور پر ایک جملہ لیتا ہے۔یہ سب سے پہلے اسپلٹ () کے طریقہ کار کا استعمال کرتے ہوئے انفرادی الفاظ میں جملے کو تقسیم کرتا ہے ، جو وائٹ اسپیس پر مبنی الفاظ کو الگ کرتا ہے۔الٹ_ ورڈز آبجیکٹ ایک ایسا ایٹریٹر ہے جو الٹ ترتیب میں الفاظ حاصل کرتا ہے۔"
    },
    {
        "Question": "\"اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کے پش ، پاپ اور جھانکنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو اسٹیک کی نمائندگی کرتی ہے اور اس کے پش ، پاپ ، اور جھانکنے کے طریقوں کو نافذ کرتی ہے: پیتھون کوپی کوڈکلاس اسٹیک: Def __init __ (خود): self.items = [] Def is_empty (self): واپسی لین (سیلف۔ آئٹم) == 0ڈیف پش (خود ، آئٹم): سیلف ڈاٹ آئی ایم ایس۔ اے پی پینڈ (آئٹم) ڈیف پاپ (خود): اگر سیلف۔ آئی ایس_پٹی (): انڈیکس ایرر (\"اسٹیک خالی ہے\") کو واپس کریں۔): اگر self.is_empty (): انڈیکس ایرر کو بڑھاؤ (\"اسٹیک خالی ہے\") خود واپس کریں۔ آئٹم [-1] اس پروگرام میں ،"
    },
    {
        "Question": "آرڈر کو محفوظ رکھتے ہوئے کسی فہرست سے نقل کو ہٹانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو آرڈر کو محفوظ رکھتے ہوئے ایک فہرست سے نقل کو ہٹا دیتا ہے: پائیٹون کوپی کوڈ ڈیف ہٹ_ ڈوپلیکیٹس (LST): دیکھا = سیٹ () نتیجہ = [] LST میں آئٹم کے لئے: اگر آئٹم نہیں دیکھا گیا: دیکھا ہوا (آئٹم) نتیجہ۔ضمیمہ (آئٹم) واپسی کا نتیجہ# مثال کے طور پر usagemy_list = [10 ، 20 ، 30 ، 20 ، 40 ، 10 ، 50] نتیجہ = ہٹائیں_ڈوپلیکیٹس (my_list) پرنٹ (\"ڈپلیکیٹ کے ساتھ فہرست:\" ، نتیجہ) اس پروگرام میں ، ہٹائیں_ڈوپلیکیٹس فنکشنایک دلیل کے طور پر ایک فہرست LST لیتا ہے۔یہ ایک خالی سیٹ کا آغاز کرتا ہے جسے دیکھا جاتا ہے اب تک کا سامنا کرنے والی انوکھی اشیاء کو ٹریک رکھنے کے لئے دیکھا جاتا ہے۔یہ ایک خالی فہرست کو بھی شروع کرتا ہے جسے `کہتے ہیں"
    },
    {
        "Question": "کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!ایک مقررہ نمبر تک فیبونیکی تسلسل کا حساب لگانے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈڈیف fibonacci_secence (n): تسلسل = [0 ، 1] جبکہ تسلسل [-1] + ترتیب [-2] <= nember = ترتیب [--ترتیب [--1] + تسلسل [-2] تسلسل.ایپینڈ (اگلا_نبر) ریٹرن تسلسل# مثال usagenumber = 1000fib_secoence = fibonacci_section (نمبر) پرنٹ (\"fibonacci ترتیب\" ، نمبر ، \":\") پرنٹ (fib_secence) ،`fibonacci_secence"
    },
    {
        "Question": "بائنری درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کی اونچائی کا حساب لگانے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو بائنری درخت کی نمائندگی کرتی ہے اور اس کی اونچائی کا حساب لگانے کے لئے ایک طریقہ کار پر عمل درآمد کرتی ہے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، قدر): خود کی قیمت = قدر۔): sell.root = کوئی بھی Def داخل (خود ، قدر): اگر self.root کوئی نہیں ہے: self.root = نوڈ (قدر) اور: سیلف۔): اگر قدر <موجودہ_نوڈ.والیو: اگر موجودہ_نوڈ.لفٹ کوئی نہیں ہے: موجودہ_نوڈ.لفٹ = نوڈ (قدر) اور: سیلف۔ _ insert_recursive (ویلیو ، کرنٹ_نوڈ.لفٹ) اور: اگر موجودہ_نوڈ نہیں ہے۔"
    },
    {
        "Question": "نمبروں کی فہرست کے وسط کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!نمبروں کی فہرست کا اوسط تلاش کرنے کے لئے یہاں ایک ازگر کا فنکشن ہے: پائیتھون کوپی کوڈیڈف Find_median (نمبر): ترتیب شدہ_نمبرز = ترتیب شدہ (نمبر) لمبائی = لین (ترتیب شدہ_نومبر) اگر لمبائی ٪ 2 == 0: مڈ 1 = لمبائی // 2 مڈ 2 = مڈ 1- 1 میڈین = (چھانٹے ہوئے_نمبرز [مڈ 1] + چھانٹے ہوئے_نمبرز [مڈ 2]) / 2 اور: درمیانی = لمبائی // 2 میڈین = چھانٹے ہوئے_نیمبرز [وسط] واپسی میڈین# مثال usagemy_list = [5 ، 9 ، 2 ، 7 ، 3 ، 8 ، 8 ، 8 ،6] نتیجہ = find_median (my_list) پرنٹ (\"میڈین:\" ، نتیجہ) اس پروگرام میں ، `find_median"
    },
    {
        "Question": "کسی دیئے گئے ٹیکسٹ فائل میں ہر لفظ کے واقعات کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے ٹیکسٹ فائل میں ہر لفظ کے واقعات کو گننے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈ ڈیف گنتی_ ورڈ_کورینس (فائل_پاتھ): ورڈ_کاؤنٹس = {} کے ساتھ اوپن (فائل_پاتھ ، 'آر') فائل کے طور پر: لائن میں لائن کے لئے: الفاظ = لائن.سپلٹ() الفاظ میں لفظ کے لئے: اگر ورڈ_کاؤنٹس میں لفظ: ورڈ_کاؤنٹس [ورڈ] += 1 اور: ورڈ_کاؤنٹس [ورڈ] = 1 ریٹرن ورڈ_کاؤنٹس# مثال کے طور پر استعمال کریں۔ورڈ_کورینسز میں گنتی کریں۔ آئٹم (): پرنٹ (ایف"
    },
    {
        "Question": "ایک فنکشن بنائیں جو چیک کرتا ہے کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو چیک کرتا ہے کہ اگر دو ڈور ایک دوسرے کے اناگرام ہیں: پائیتھون کوپی کوڈ ڈیف ARE_ANAGRAMS (سٹرنگ 1 ، سٹرنگ 2): # دونوں تار کو چھوٹے سے کیس میں تبدیل کریں اور وائٹ اسپیس سٹرنگ 1 = سٹرنگ 1.lower (\"\" ، \"\") سٹرنگ 2 کو ہٹائیں۔= string2.lower (). تبدیل کریں (\"\" ، \"\") # چیک کریں کہ آیا تار کی لمبائی برابر ہے اگر لین (سٹرنگ 1)! = لین (سٹرنگ 2): غلط # لوٹائیں # لغت کو ذخیرہ کرنے کے لئے لغت کو اسٹور کریں۔shar_counts2 = {} # سٹرنگ 1 میں سٹرنگ 1 میں حرف 1 میں چار_کاؤنٹس 1: چار_کاؤنٹس 1 [چار] += 1 اور: چار_ اکاؤنٹس 1 [چار] = 1 # گنتی حروف"
    },
    {
        "Question": "کسی مثبت عدد میں ہندسوں کی رقم کا حساب لگانے کے لئے ایک تکرار فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ایک مثبت عدد میں ہندسوں کے جوڑے کا حساب لگانے کے لئے یہاں ایک بار بار چلنے والا ازگر فنکشن ہے: پائیتھون کوپی کوڈڈیف SUM_OF_DIGITS (n): اگر n <10: واپسی N اور: last_digit = n ٪ 10 باقی_ڈیجٹس = n // 10 ریٹرن آخری_ڈیجٹ (بقیہ_ڈیگیٹس)# مثال usagenumber = 12345Result = sum_of_digits (نمبر) پرنٹ (\"ہندسوں کا مجموعہ:\" ، نتیجہ) اس پروگرام میں ، sum_of_digits فنکشن ایک مثبت عدد لیتا ہے `"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سب سے بڑی مستقل رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں سب سے بڑی مستقل رقم تلاش کرنے کے لئے ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈڈیف find_largest_continuous_sum (nums): اگر NUSS نہیں: واپس 0 کرنٹ_سم = نمبر [0] میکس_سم = نمبر [0] نمبر میں نمبر [1:]: کرنٹ_سم = زیادہ سے زیادہ (NUM ، موجودہ_سم + نمبر) میکس_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) میکس_سم# مثال کے طور پر esagemy_list = [2 ، -1 ، 3 ، -4 ، 2 ، 0 ، -5 ، 6] نتیجہ = find_largest_continuous_sum (my_list (my_list) اس پروگرام میں پرنٹ (\"سب سے بڑی مسلسل رقم:\" ، نتیجہ) ،"
    },
    {
        "Question": "ایک قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور اس کے تزئین و آرائش اور dequeue طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو قطار کی نمائندگی کرتی ہے اور انکیو () اور ڈی کیو () طریقوں کو نافذ کرتی ہے: پیتھون کوپی کوڈکلاس قطار: ڈیف __init __ (خود): سیلف.کوئو = [] ڈیف انکیو (خود ، آئٹم)) Def dequeue (self): اگر self.is_empty (): استثناء بڑھاؤ (\"قطار خالی ہے\") سیلف ڈاٹ پی او پی (0) ڈیف آئی ایس ای ایم پی (خود)(خود): ریٹرن لین (self.queue)# مثال usagemy_queue = قطار () my_queue.enqueue (\"a\") my_queue.enqueue (\"b\") my_queue.enqueue (\"c\") پرنٹ (\"قطار کا سائز:\"my_queue.size ()) آئٹم = my_queue.dequeue () پرنٹ"
    },
    {
        "Question": "اعشاریہ نمبر کو اس کی بائنری نمائندگی میں تبدیل کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ایک اعشاریہ کو اس کی بائنری نمائندگی میں تبدیل کرنے کے لئے ایک ازگر پروگرام یہ ہے: پائیتھون کوپی کوڈ ڈیف اعشاریہ_ٹو_بائنری (اعشاریہ): بائنری = \"\" اگر اعشاریہ == 0: واپسی \"0\" جبکہ اعشاریہ> 0: بائنری = ایس ٹی آر (اعشاریہ ٪ 2) + بائنریاعشاریہ // = 2 ریٹرن بائنری# مثال usagenumber = 25result = declimal_to_binary (نمبر) پرنٹ (f \"بائنری نمائندگی {نمبر}: {نتیجہ}\") اس پروگرام میں ، اعشاریہ_ٹو_بائنری فنکشن ایک دلیل کے طور پر اعشاریہ اعشاریہ اعشاریہ اعشاریہ اعضاء کی حیثیت رکھتا ہے۔یہ بائنری نمائندگی کو ذخیرہ کرنے کے لئے خالی سٹرنگ بائنری کا آغاز کرتا ہے۔ اگر اعشاریہ نمبر 0 ہے تو ، یہ بائنری نمائندگی کے طور پر \"0\" کو فوری طور پر لوٹاتا ہے۔ فنکشن اعشاریہ کی تعداد کو بائنری میں تبدیل کرنے کے لئے تھوڑی دیر کا استعمال کرتا ہے۔"
    },
    {
        "Question": "ایک فنکشن بنائیں جو ایک فہرست کو ایک دیئے گئے تعداد کے ذریعہ دائیں طرف گھومتا ہے۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو ایک فہرست کو دائیں طرف ایک مخصوص تعداد کے ذریعہ گھومتا ہے: پائیٹون کوپی کوڈ ڈیف روٹیٹ_ لسٹ_ رائٹ (ایل ایس ٹی ، اقدامات): اگر نہیں تو ایل ایس ٹی: ریٹرن ایل ایس ٹی لمبائی = لین (ایل ایس ٹی) اقدامات ٪ = لمبائی # اقدامات کی تعداد کو ایڈجسٹ کریں۔فہرست کی لمبائی میں گھومے ہوئے_لسٹ = lst [-STEPS:] + LST [:-اقدامات] گھومنے والی_لسٹ# مثال usagemy_list = [1 ، 2 ، 3 ، 4 ، 5] num_steps = 2result = Rotate_list_right (my_list ،"
    },
    {
        "Question": "کسی دیئے گئے نمبر کے حقیقت کا حساب لگانے کے لئے ایک تکرار والی تقریب کو نافذ کریں۔",
        "Answer": "یقینا!کسی دیئے گئے نمبر کی حقیقت کا حساب لگانے کے لئے یہاں ایک بار بار بار بار چلنے والا فنکشن ہے: پائیتھون کوپی کوڈیڈف فیکٹوریال (این): اگر n == 0 یا n == 1: واپسی 1 اور: واپسی n * فیکٹوریئل (n - 1)# مثال usagenumber = 5result = 5result= فیکٹوریل (نمبر) پرنٹ (f \"اس پروگرام میں {نمبر} کا حقیقت ہے: {نتیجہ}\") ، اس پروگرام میں ،"
    },
    {
        "Question": "گراف کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور گہرائی کی پہلی تلاش کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو گراف کی نمائندگی کرتی ہے اور گہرائی سے پہلے تلاش (DFS) انجام دینے کے لئے ایک طریقہ کار پر عمل درآمد کرتی ہے: پیتھون کوپی کوڈکلاس گراف: Def __Init __ (خود): خود. adjacency_list = {} def add_vertex (سیلف ، ورٹیکس): اگر عمودی میں نہیں ہےself.adjacency_list: self.adjacency_list [vertex] = [] Def add_edge (خود ، ورٹیکس 1 ، ورٹیکس 2): اگر خود میں۔۔"
    },
    {
        "Question": "دو فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!دو فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈڈیف Find_common_elements (List1 ، List2): عام_ایلیاں = [] فہرست 1 میں آئٹم کے لئے: اگر لسٹ 2 میں آئٹم اور آئٹم عام_ایلمنٹ میں نہیں ہے۔مثال کے طور پر useagelist_a = [1 ، 2 ، 3 ، 4 ، 5] فہرست_ب = [4 ، 5 ، 6 ، 7 ، 8] عام_ایلمنٹ = Find_common_elements (فہرست_ا ، فہرست_بی) پرنٹ (\"عام عناصر:\" ، عام_ایلیشن) ،Find_common_elements فنکشن دلائل کے طور پر دو فہرستیں ، فہرست 1 اور List2 لیتا ہے۔یہ مشترکہ عناصر کو ذخیرہ کرنے کے لئے ایک خالی فہرست کامن_لیمنٹس کی ابتدا کرتا ہے۔ فنکشن تک پہنچ جاتا ہے"
    },
    {
        "Question": "کسی فنکشن کو نافذ کریں جو چیک کرتا ہے کہ آیا تار ایک درست ای میل ایڈریس ہے۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو جانچ پڑتال کرتا ہے کہ اگر کوئی تار باقاعدہ اظہار کا استعمال کرتے ہوئے ایک درست ای میل ایڈریس ہے: پائیٹون کوپی کوڈیمپورٹ ریڈف IS_Valid_email (ای میل): پیٹرن = r '^[\\ w \\ .-]+@[\\ w \\ .-]+\\۔\\ w+$ 'میچ = re.Match (پیٹرن ، ای میل) ریٹرن میچ کوئی بھی نہیں# مثال کے استعمال کے میل_اڈریس = \"مثال@example.com\" نتیجہ = is_valid_email (ای میل_اڈریس) پرنٹ (F \"{ای میل_اڈریس} ایک درست ای میل ایڈریس ہے؟ {کیا ایک درست ای میل ایڈریس ہے؟ {نتیجہ} \") اس پروگرام میں ، is_valid_email فنکشن ایک دلیل کے طور پر ایک ای میل ایڈریس ای میل لیتا ہے۔یہ دوبارہ ماڈیول سے دوبارہ میچ کرنے کے لئے RE.Match فنکشن کا استعمال کرتا ہے"
    },
    {
        "Question": "انٹیجرز کی دی گئی فہرست میں گمشدہ نمبر تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں گمشدہ نمبر تلاش کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈڈیف Find_missing_number (نمبر): n = len (nums) + 1 متوقع_سم = (n * (n + 1)) // 2 اصل_سم = سم (نمبر (نمبر (نمبر)) لاپتہ_نبر = متوقع_سم - اصل_سم لاپتہ_نبر# مثال کے طور پر یوسجینمبرز = [1 ، 2 ، 4 ، 6 ، 3 ، 7 ، 8] لاپتہ_نبر = تلاش_مشنگ_نمبر (نمبر) پرنٹ (\"گمشدہ نمبر:\" ، لاپتہ_نبر) `` `` `` `` `"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا کوئی دیئے گئے تار ایک درست پیلنڈرووم ہے ، غیر الفینومرک کرداروں کو نظرانداز کرتے ہوئے۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو چیک کرتا ہے کہ اگر کوئی دیئے گئے تار ایک درست پالندرووم ہے ، غیر الفانومیرک حروف کو نظرانداز کرتے ہوئے: پائیتھون کوپی کوڈیمپورٹ ریڈف آئی ایس_والیڈ_پالینڈرووم (سٹرنگ): الفانومیرک_سٹرنگ = ری.سوب (آر '[^A-za-Z0-9]' ، '،''، string.lower ()) الٹ_سٹرنگ = الفانومیرک_سٹرنگ [::-1] واپس الفانومیرک_سٹرنگ == الٹ_سٹرنگ# مثال کے طور پر یوس ایج ٹیکسٹ = \"ایک آدمی ، ایک منصوبہ ، ایک کینال: پاناما\" نتیجہ = is_valid_palindrome (متن) پرنٹ (f \"{متنa ایک درست پیلنڈرووم ہے؟ {نتیجہ} \") اس پروگرام میں ، is_valid_palindrome فنکشن ایک دلیل کے طور پر تار تار کرتا ہے۔یہ RE.SUB فنکشن کو RE ماڈیول سے استعمال کرتا ہے تاکہ تمام غیر الفانومرک کرداروں کو تار سے دور کیا جاسکے۔باقاعدہ اظہار کا نمونہ [^a-z-Z0-9] کسی بھی کردار سے میل کھاتا ہے جو ایک نہیں ہے"
    },
    {
        "Question": "ایک قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور اس کے سائز اور is_empty طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو قطار کی نمائندگی کرتی ہے اور اس کے سائز اور isempty طریقوں کو نافذ کرتی ہے: پائیٹون کوپی کوڈکلاس قطار: Def __init __ (خود): self.items = [] Def is_empty (خود)"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دو ڈور ایک دوسرے کی گردش ہیں یا نہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دو ڈور ایک دوسرے کی گردش ہیں: پائیتھون کوپی کوڈیڈف ARE_ROTATIONS (str1 ، str2): اگر لین (str1)! = لین (str2): جھوٹی کنکیٹیٹڈ = str1 + str1 واپسی str2 میں شامل#= \"ABCD\" سٹرنگ 2 = \"CDAB\" نتیجہ = ARE_ROTATIONS (سٹرنگ 1 ، سٹرنگ 2) پرنٹ (F \"{سٹرنگ 1} اور {سٹرنگ 2} گردش ہیں؟، جیسا کہ دلائل کے طور پر۔ پہلے ، یہ چیک کرتا ہے کہ آیا دونوں ڈوروں کی لمبائی مختلف ہے۔اگر وہ مختلف ہیں تو ، اس کا مطلب ہے کہ وہ ایک دوسرے کی گردش نہیں ہوسکتے ہیں ، اور فنکشن غلط کو لوٹاتا ہے۔ Next ، یہ Str1 کو خود سے جوڑتا ہے تاکہ ایک نیا تار تیار کیا جاسکے جس کو کہتے ہیں۔"
    },
    {
        "Question": "تکرار کا استعمال کرتے ہوئے کسی نمبر کی طاقت کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو تکرار کا استعمال کرتے ہوئے کسی تعداد کی طاقت کا حساب لگاتا ہے: پائیتھون کوپی کوڈیڈف پاور (بیس ، ایکسپینٹ): اگر ایکسپینٹ == 0: واپسی 1 ایلف ایکسپینٹ <0: واپسی 1 / پاور (بیس ، -ایکسپینٹ) دوسری: واپسی کی بنیاد: واپسی کی بنیاد: واپسی کی بنیاد* پاور (بیس ، ایکسپینٹ - 1)# مثال کے طور پر استعمال کی بیس = 2 ایکسپینٹ = 3result = پاور (بیس ، ایکسپینٹ) پرنٹ (f \"{بیس {{ایکسپینٹ} کی طاقت میں اٹھایا {نتیجہ} ہے {نتیجہ}\") ، اس پروگرام میں ، طاقت ، طاقتفنکشن دو دلائل لیتا ہے: بیس اور اخراج۔یہ تکرار کا استعمال کرتے ہوئے اخراج کنندہ کو اٹھائے جانے والے اڈے کی طاقت کا حساب لگاتا ہے۔ فنکشن میں تین ہیں"
    },
    {
        "Question": "تار سے تمام نقلیں ہٹانے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں ایک سٹرنگ سے تمام نقلوں کو ہٹانے کے لئے ایک ازگر پروگرام ہے: پائیٹون کوپی کوڈیڈف ہٹ_ ڈوپلیکیٹس (سٹرنگ): منفرد_چارس = [] نتیجہ = \"\" اسٹرنگ میں چار کے لئے: اگر چار منفرد_چارس میں نہیں ہے: منفرد_چارس۔# مثال usagetext = \"ہیلو ، ورلڈ!\" نتیجہ = ہٹائیں_ڈوپلیکیٹس (متن) پرنٹ (\"ڈپلیکیٹ کو ہٹانے کے بعد تار:\" ، نتیجہ) اس پروگرام میں ، ہٹ_ ڈوپلیکیٹس فنکشن ایک دلیل کے طور پر تار تار کرتا ہے۔یہ تار میں درپیش انوکھے کرداروں کو ذخیرہ کرنے کے لئے منفرد_چار نامی ایک خالی فہرست کی ابتدا کرتا ہے۔یہ نقل کو ہٹانے کے بعد حتمی سٹرنگ بنانے کے لئے نتائج نامی ایک خالی تار کا آغاز بھی کرتا ہے۔ فنکشن پھر تار میں ہر کردار پر تکرار کرتا ہے۔اگر کردار پہلے سے ہی منفرد_چارس میں موجود نہیں ہے تو ، وہ اسے فہرست میں شامل کرتا ہے اور اسے نتیجہ کے تار میں شامل کرتا ہے۔"
    },
    {
        "Question": "بائنری سرچ ٹری کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور نوڈ داخل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو بائنری سرچ ٹری (بی ایس ٹی) کی نمائندگی کرتی ہے اور نوڈ داخل کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرتی ہے: پائیٹون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، قدر): سیلف۔ ویلیو = ویلیو خود۔Def __init __ (خود): self.root = کوئی بھی Def داخل (خود ، قدر): اگر self.root کوئی نہیں ہے: self.root = نوڈ (قدر) اور: سیلف۔، نوڈ ، قدر):"
    },
    {
        "Question": "کسی دیئے گئے تار میں کرداروں کو دہرائے بغیر سب سے طویل عروج تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو کسی دیئے گئے تار میں کرداروں کو دہرانے کے بغیر سب سے طویل عرصہ تک تلاش کرتا ہے: پائیتھون کوپی کوڈڈیف طویل عرصے تک_سبسٹرنگ_ٹیٹ_ رپیٹنگ_چارس (تار): اگر تار نہیں ہے تو: واپسی \"\" میکس_سبسٹرنگ = \"\" موجودہ_بسٹرنگ = \"\" ملاحظہ کی گئی_چارس = \"\" ملاحظہ کی گئی_چارس = \"\"دورے میں نہیں ملاحظہ کریں_چارس: ملاحظہ کریں_چارس۔ اے ڈی ڈی (چار) کرنٹ_سبسٹرنگ += چار اگر لین (کرنٹ_سبسٹرنگ)> لین (میکس_سبسٹرنگ): میکس_سبسٹرنگ = کرنٹ_سبسٹرنگ"
    },
    {
        "Question": "کسی دیئے گئے جملے میں الفاظ کی ترتیب کو پلٹانے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!کسی دیئے گئے جملے میں الفاظ کی ترتیب کو پلٹانے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈ ڈیف ریورس_سینٹینس (جملہ): الفاظ = جملہ۔ اسپلٹ () الٹ_ ورڈز = الفاظ [::-1] الٹ_سینٹینس = \"\"مثال کے طور پر استعمال کریں = \"ہیلو ، آج آپ کیسے ہیں؟\" الٹ_سینٹینس = ریورس_سینٹینس (جملہ) پرنٹ (\"الٹ جملہ:\" ، الٹ_سینٹینس) اس پروگرام میں ، ریورس_سینٹینس فنکشن ایک جملے کو تار کے جملے کے طور پر لیتا ہے اور اس کے حکم کے ساتھ جملے کو واپس کرتا ہے۔الفاظ الٹ جاتے ہیں۔ فنکشن سب سے پہلے جملے کو تقسیم کے طریقہ کار کو استعمال کرتے ہوئے الفاظ کی فہرست میں تقسیم کرتا ہے۔اس کے بعد یہ سلائسنگ اشارے [::-1] کا استعمال کرتے ہوئے الفاظ کی ترتیب کو تبدیل کرتا ہے ،"
    },
    {
        "Question": "ایک فنکشن لکھیں جو متحرک پروگرامنگ کا استعمال کرتے ہوئے NTH Fibonacci نمبر لوٹائے۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو نویں فبونیکی نمبر کا حساب لگانے کے لئے متحرک پروگرامنگ کا استعمال کرتا ہے: پائیتھون کوپی کوڈیڈف فائبونیکی (این): اگر این <= 0: ویلیو ایرر (\"این ایک مثبت انٹیجر ہونا ضروری ہے۔\") # فبونیکی سلسلہ کو پہلے دو کے ساتھ شروع کریں جس میں فبونیکی سلسلہ کو شروع کریں۔نمبر fib = [0 ، 1] # رینج (2 ، n + 1) کے لئے NTH نمبر تک فبونیکی نمبروں کا حساب لگائیں (2 ، n + 1): fib.append (fib [i - 1] + fib [i - 2]) # ریٹرنNTH Fibonacci نمبر ریٹرن Fib [n]# مثال کے طور پر usagen = 6result = fibonacci (n)"
    },
    {
        "Question": "میٹرکس ضرب انجام دینے کے لئے ایک پروگرام نافذ کریں۔",
        "Answer": "یقینا!میٹرکس ضرب کو انجام دینے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف میٹرکس_مولٹیکشن (میٹرکس 1 ، میٹرکس 2): روس 1 = لین (میٹرکس 1) کولس 1 = لین (میٹرکس 1 [0]) روز 2 = لین (میٹرکس 2) کولس 2 = لین (میٹرکس 2) کولس 2 = لین (میٹرکس 2) کولس 2 = لین (میٹرکس 2)اگر میٹرکس کو بڑھایا جاسکتا ہے اگر COLS1! = ROWS2: value error کو بڑھاو (\"میٹرکس 1 میں کالموں کی تعداد میٹرکس 2 میں قطار کی تعداد کے برابر ہونی چاہئے۔\")(COLS2)] رینج میں _ کے لئے (ROWS1)] # میٹرکس ضرب پرفارم کریں"
    },
    {
        "Question": "دو نمبروں میں سے کم سے کم عام ایک سے زیادہ (LCM) تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!دو نمبروں میں سے کم سے کم عام ایک سے زیادہ (LCM) تلاش کرنے کے لئے ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف Find_lcm (Num1 ، Num2): # دو نمبروں میں سے زیادہ سے زیادہ میکس_نم = زیادہ سے زیادہ (نمبر 1 ، نمبر 2) # زیادہ سے زیادہ تعداد سے تلاش کریں اور چیک کریں۔عام طور پر ایک سے زیادہ LCM = MAX_NUM کے لئے جبکہ سچ ہے: اگر LCM ٪ NUM1 == 0 اور LCM ٪ NUM2 == 0: بریک LCM += MAX_NUM ریٹرن LCM# مثال USAGENUMBER1 = 12Number2 = 18LCM = Find_LCM (نمبر 1 ، نمبر 2) پرنٹ (\"LCM) پرنٹ (\" LCM)اس پروگرام میں \"، نمبر 1 ،\" اور \"، نمبر 2 ،\" ہے: \"، ایل سی ایم)"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے۔",
        "Answer": "یقینا!یہ چیک کرنے کے لئے ایک ازگر فنکشن ہے کہ آیا دیئے گئے سٹرنگ ایک درست IPv4 ایڈریس ہے: پائیتھون کوپی کوڈیڈف IS_Valid_ipv4 (ایڈریس): # ایڈریس کو اس کے اجزاء میں تقسیم کریں"
    },
    {
        "Question": "دیئے گئے نمبر کا سب سے بڑا بنیادی عنصر تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!کسی دیئے گئے نمبر کا سب سے بڑا بنیادی عنصر تلاش کرنے کے لئے ایک ازگر پروگرام یہ ہے: پائیتھون کوپی کوڈ ڈیف سب سے بڑا_پائم_ فیکٹر (نمبر): # سب سے بڑے پرائم فیکٹر کو 1 سب سے بڑے_ فیکٹر کے طور پر شروع کریں"
    },
    {
        "Question": "سرکلر سے منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور شروع میں نوڈ داخل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو سرکلر سے منسلک فہرست کی نمائندگی کرتی ہے اور شروع میں نوڈ داخل کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرتی ہے: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیل۔ نیکسٹ سرکلر لنکڈ لسٹ: ڈیف __INIT __ (خود): self.head = کوئی بھی Def insert_at_beginning (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) # چیک کریں کہ اگر فہرست خالی ہے تو اگر خود نہیں ہے۔self.head جبکہ موجودہ۔ نیکسٹ! = self.head: موجودہ = موجودہ۔ نیکسٹ موجودہ۔ نیکسٹ = نیا_نوڈ new_node.next = self.head"
    },
    {
        "Question": "دو فہرستوں کا چوراہا تلاش کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!دو فہرستوں کے چوراہے کو تلاش کرنے کے لئے یہاں ایک ازگر فنکشن ہے: پائیتھون کوپی کوڈیڈف Find_Intersection (List1 ، List2): سیٹ 1 = سیٹ (لسٹ 1) سیٹ 2 = سیٹ (لسٹ 2) چوراہا = سیٹ 1.ٹریشن (سیٹ 2) ریٹرن لسٹ (چوراہے)# مثال یوسیلسٹ 1 =[1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [4 ، 5 ، 6 ، 7 ، 8] نتیجہ = Find_Intersection (فہرست 1 ، فہرست 2) پرنٹ (\"دو کا چوراہا)"
    },
    {
        "Question": "دیئے گئے لمبائی کا بے ترتیب پاس ورڈ تیار کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں دیئے گئے لمبائی کا بے ترتیب پاس ورڈ تیار کرنے کے لئے ایک ازگر پروگرام ہے: پائیٹون کوپی کوڈیمپورٹ رینڈم پورٹ سٹرنگ ڈف جنریٹ_رینڈوم_ پاس ورڈ (لمبائی): # حرفوں کی وضاحت کریں حرف = string.ascii_letters + سٹرنگ۔'. join (بے ترتیب۔ چوائس (حروف) _ کے لئے _ میں حد (لمبائی)) ریٹرن پاس ورڈ# مثال useagelength = 10 پاس ورڈ = 10 پاس ورڈ = جنریٹ_رینڈوم_ پاس ورڈ (لمبائی) پرنٹ (\"بے ترتیب پاس ورڈ:\" ، پاس ورڈ) اس پروگرام میں ، جنریٹ_رینڈوم_ پاس ورڈ فنکشن لمبائی لیتا ہےپیرامیٹر اور اس لمبائی کا تصادفی طور پر تیار کردہ پاس ورڈ واپس کرتا ہے۔ فنکشن پہلے اسٹرنگ ماڈیول کے استعمال سے انتخاب کرنے کے لئے حرفوں کی وضاحت کرتا ہے۔اس میں لوئر کیس شامل ہیں"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا ایک دیئے گئے نمبر ایک کامل مربع ہے۔",
        "Answer": "یقینا!یہ چیک کرنے کے لئے ایک ازگر فنکشن ہے کہ آیا کوئی دیئے گئے نمبر ایک کامل مربع ہے: پائیٹون کوپی کوڈیڈف"
    },
    {
        "Question": "بلبلا ترتیب والے الگورتھم کا استعمال کرتے ہوئے عددیوں کی فہرست کو ترتیب دینے کے لئے ایک پروگرام کو نافذ کریں۔",
        "Answer": "یقینا!بلبلا ترتیب والے الگورتھم کا استعمال کرتے ہوئے عددیوں کی فہرست کو ترتیب دینے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف بلبلا_سورٹ (نمبر): n = لین (نمبرز) میں I کے لئے (n - 1): # پرچم چیک کرنے کے لئے کہ آیا کوئی تبادلہ ہوا ہے یا نہیںرینج میں موجودہ پاس تبدیل = J کے لئے غلط (n - 1 - i): # ملحقہ عناصر کا موازنہ کریں اور اگر ضروری ہو تو اگر ضروری ہو تو تبدیل کریں [j]> نمبر [j + 1]: نمبر [j] ، نمبر [j + 1] =نمبر [J + 1] ، نمبر [j] تبدیل شدہ = سچ # اگر موجودہ پاس میں کوئی تبادلہ نہیں کیا گیا ہے تو ، فہرست پہلے ہی ترتیب دی گئی ہے اگر تبدیل نہیں کیا گیا ہے: توڑ"
    },
    {
        "Question": "ہدایت نامہ گراف کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور چوڑائی کی پہلی تلاش کرنے کے لئے ایک طریقہ کار پر عمل درآمد کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو ہدایت شدہ گراف کی نمائندگی کرتی ہے اور چوڑائی کی پہلی تلاش (بی ایف ایس) پر عمل درآمد کرتی ہے (بی ایف ایس) کا طریقہ: پائیتھون کوپی کوڈفرم کلیکشن درآمد ڈیفالٹ ڈکٹکلاس ہدایت نامہ: ڈیف __init __ (خود): سیلف گراف = ڈیفالٹ ڈکٹ (فہرست) ڈیف_ ایڈج (خود ، ماخذ ، منزل): سیلف گراف [ماخذ]0) پرنٹ (نوڈ ، اختتام = \"\") خود پڑوسی میں پڑوسی کے لئے۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں سروں کی تعداد گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے تار میں سروں کی تعداد کو گننے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف COUNT_VOWELS (سٹرنگ): سروں میں چار کے لئے حرف = 'aeiouaeioiouo' avel_count = 0\"ہیلو ، ورلڈ!\" واول_کاؤنٹ = گنتی_اوولس (سٹرنگ) پرنٹ (\"سروں کی تعداد:\" ، سر_کاؤنٹ) اس پروگرام میں ، گنتی_اوولس فنکشن ایک دلیل کے طور پر ایک تار لیتا ہے اور تار میں سروں کی گنتی کو واپس کرتا ہے۔متغیر سروں کے ساتھ ایک تار جس میں تمام چھوٹے اور بڑے سروں پر مشتمل ہوتا ہے۔یہ ایک متغیر حرف_ اکاؤنٹ 0 سے بھی شروع کرتا ہے ، جو سروں کی گنتی کو ذخیرہ کرے گا۔ فنکشن پھر تکرار کرتا ہے"
    },
    {
        "Question": "دیئے گئے عدد کو الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ایک دیئے گئے عدد کو الٹ کرنے کے لئے یہاں ایک ازگر فنکشن ہے: پائیتھون کوپی کوڈیڈف ریورس_ٹیجر (نمبر): # نمبر کو آسانی سے جوڑ توڑ نمبر_سٹر = ایس ٹی آر (نمبر) کے لئے تار میں تبدیل کریں # چیک کریں کہ آیا نمبر منفی ہے۔'-': is_negative = true num_str = num_str [1:] # سٹرنگ الٹ الٹ_سٹر = num_str [::-1] # الٹ سٹرنگ کو کسی عدد الٹ الٹ_نوم = انٹ (الٹ_سٹر) میں تبدیل کریں اگر ضروری ہو تو منفی علامت کو بحال کریں اگر ضروری ہو تو منفی علامت کو بحال کریں۔is_negative: الٹ_نوم *= -1 واپسی الٹ_نم# مثال usagenum = 12345reversed_num = revers_integer (num) پرنٹ"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام بنائیں کہ آیا کوئی دیئے گئے نمبر آرمسٹرونگ نمبر ہے۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد آرمسٹرونگ نمبر ہے: پائیتھون کوپی کوڈیڈف آئی ایس_آرم اسٹرانگ_نمبر (نمبر): # آسانی سے ہیرا پھیری کے لئے نمبر کو ایک تار میں تبدیل کریں num_str = str (num) # نمبر نمبر میں ہندسوں کی تعداد کا حساب لگائیں = لن.اور:"
    },
    {
        "Question": "ترجیحی قطار کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اس کے انکیو اور ڈی کیو طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو ترجیحی قطار کی نمائندگی کرتی ہے اور اس کے انکیو اور ڈی کیو طریقوں کو نافذ کرتی ہے: پائیتھون کوپی کوڈکلاس ترجیحی کیو: ڈیف __init __ (خود): سیلف.کیو = [] ڈیف انکیو (خود ، آئٹم ، ترجیحی)، ترجیح)) self.queue.sort (key = lambda x: x [1]) Def dequeue (خود): اگر self.is_empty (): واپس کوئی نہیں واپس کریں۔خود): ریٹرن لین (سیلف۔ کیوئو) == 0# مثال کے استعمال سے متعلق، 3) پرنٹ (\"dequeue:\" ، قطار۔ ڈیکوئ ()) پرنٹ (\"dequeue:\" ، قطار.ڈیکیو ()) پرنٹ (\"dequeue:\" ، قطار.ڈیکیو ()) پرنٹ (\"خالی ہے:\" ، \"،قطار.IS_EMPTY ()) ``"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کے چوراہے کو تلاش کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!دو ترتیب شدہ صفوں کے چوراہے کو تلاش کرنے کے لئے یہاں ایک ازگر فنکشن ہے: پائیتھون کوپی کوڈیڈف Find_Intersection (ARR1 ، ARR2): چوراہا = [] i = j = 0 جبکہ میں <لین (ARR1) اور J <LEN (ARR2): اگر ARR1 [i] <arr2 [j]: i += 1 Elif arr1 [i]> arr2 [j]: j += 1 اور: چوراہا. append (arr1 [i]) i += 1 j += 1 واپسی چوراہے# مثال usagearray1= [1 ، 3 ، 4 ، 5 ، 7 ، 9] سرنی 2 = [2 ، 3 ، 5 ، 6 ، 8 ، 9] چوراہا = Find_Intersection (array1 ، array2) پرنٹ (\"چوراہے:\" ، چوراہے) اس پروگرام میں ،Find_intersction فنکشن دو ترتیب شدہ صفوں ، `arr1 لیتا ہے"
    },
    {
        "Question": "بائنری نمبر کو اس کے اعشاریہ نمائندگی میں تبدیل کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!بائنری نمبر کو اس کے اعشاریہ نمائندگی میں تبدیل کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈ ڈیف بائنری_ٹو_ڈیسیمل (بائنری): اعشاریہ = 0 پاور = 0 # بائنری ہندسوں پر ریورس ترتیب میں ریورس ترتیب میں (بائنری): # ہندسے کو ایک میں تبدیل کریںانٹیجر ہندسہ = انٹ (ہندسہ) # اعشاریہ کی قیمت اعشاریہ اعشاریہ اعشاریہ += ہندسہ * (2 ** میں شامل کریں"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دیئے گئے تار ایک درست پیلنڈرووم ہے ، کیس کی حساسیت پر غور کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک درست پیلنڈرووم ہے ، کیس کی حساسیت پر غور کرتے ہوئے: پائیتھون کوپی کوڈیڈف آئی ایس_پالنڈرووم (سٹرنگ): # کسی بھی سفید جگہ کو سٹرنگ سٹرنگ = سٹرنگ سے ہٹا دیں۔اس کے الٹ ریٹرن اسٹرنگ == سٹرنگ کے برابر ہے [::-1]# مثال کے طور پر استعمال کے استعمال کے استعمال کے برابر ہے۔درست پالندرووم \") اس پروگرام میں ، IS_Palindrome فنکشن ایک دلیل کے طور پر تار لیتا ہے اور بولین کو واپس کرتا ہے جس سے یہ ظاہر ہوتا ہے کہ آیا سٹرنگ ایک درست پیلنڈرووم ہے ، کیس کی حساسیت پر غور کرتے ہوئے"
    },
    {
        "Question": "کسی دیئے گئے نمبر کی حقیقت میں ہندسوں کے جوڑے کا حساب لگانے کے لئے ایک پروگرام کو نافذ کریں۔",
        "Answer": "یقینا!کسی مخصوص نمبر کے حقیقت میں ہندسوں کے جوڑے کا حساب لگانے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف فیکٹوریال_سم (این): فیکٹوریئل = 1 رینج میں I کے لئے (2 ، n+1): فیکٹوریل *= i ہندسہ_سم = 0 جبکہ حقیقت پسندانہ> 0: ہندسوں_سم += فیکٹوریئل ٪ 10 فیکٹوریال // = 10 ریٹرن ہندسے_سم# مثال usagenumber = 5sum_of_digits = فیکٹوریل_سم (نمبر) پرنٹ (\"حقیقت پسندانہ رقم\" ، نمبر ، \":\" ، Sum_of_digits)"
    },
    {
        "Question": "ایک سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور اس کے enqueue اور dequeue طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو سرکلر قطار کی نمائندگی کرتی ہے جس میں سرکلر قطار اور ڈیکیو طریقوں کے ساتھ: پائیتھون کوپی کوڈکلاس سرکلر کیوئو: ڈیف __init __ (خود ، صلاحیت): خود کی صلاحیت = صلاحیت خود = [کوئی نہیں] * صلاحیت خود۔1 سیلف۔(\"قطار بھری ہوئی ہے۔ آئٹم کو ختم کرنے سے قاصر ہے:\" ، آئٹم) سیلف۔ ریئر = (سیلف۔ ریئر + 1) ٪ سیلف۔ کیپیسیٹی سیلف۔انکیوئڈ آئٹم: \"، آئٹم)"
    },
    {
        "Question": "دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ایک دیئے گئے فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف میکس_ ڈفیفینس (نمبر): اگر لین (نمبرز) <2: کوئی بھی نہیں منٹ_نوم = نمبر [0] میکس_ ڈف = نمبر [1] - نمبر [1] [0] میں رینج (1 ، لین (نمبر)) میں I کے لئے: اگر nums [i] - min_num> max_diff: max_diff = nums [i] - min_num if nums [i] <min_num: min_num = nums [i] میکس_ ڈف واپس کریں# مثالusagenumbers = [7 ، 2 ، 3 ، 10 ، 4 ، 1 ، 8 ، 6] نتیجہ = زیادہ سے زیادہ_ڈیفینس (نمبر) پرنٹ (\"زیادہ سے زیادہ فرق:\" ، نتیجہ) اس پروگرام میں ، میکس_ ڈفیفینس فنکشن نمبروں کی فہرست لیتا ہے ، `نمبر"
    },
    {
        "Question": "تار میں پہلا غیر بار بار کردار تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!تار میں پہلا غیر بار بار ہونے والے کردار کو تلاش کرنے کے لئے یہاں ایک ازگر کا فنکشن ہے: پائیتھون کوپی کوڈیڈف Find_first_non_repeated_char (سٹرنگ): چار_کاؤنٹ = {} # ہر کردار کے واقعات کو تار کے لئے تار میں شمار کریں: اگر چار_ کاؤنٹ میں چار_کاؤنٹ: چار_ کاؤنٹ میں چار] += 1 اور: چار_کاؤنٹ [چار] = 1 # اسٹرنگ میں چار کے لئے پہلا غیر بار بار نہ ہونے والا کردار تلاش کریں: اگر چار_کاؤنٹ [چار] == 1: واپسی چار # کوئی نہیں اگر کوئی بار بار نہ ہونے والا کردار نہیں ہے تو کوئی بھی نہیں #مثال کے طور پر usageInput_str = \"Abacabad\" نتیجہ = find_first_non_repeated_char (ان پٹ_سٹر) اگر نتیجہ: پرنٹ (\"پہلا غیر بار بار کردار:\" ، نتیجہ) دوسری صورت میں: پرنٹ (\"کوئی بار بار نہ ہونے والے کردار نہیں ملے۔\")ایک تار ،"
    },
    {
        "Question": "متعدد فہرستوں میں مشترکہ عناصر کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!متعدد فہرستوں میں مشترکہ عناصر کو تلاش کرنے کے لئے ایک ازگر پروگرام یہ ہے: پائیتھون کوپی کوڈیڈف Find_common_elements (*فہرستیں): # پہلی فہرست عام_ایلمنٹ = سیٹ (فہرستوں [0]) کے عناصر کے ساتھ ایک سیٹ شروع کریں LST میں باقی فہرستوں پر دوبارہ عمل کریں۔فہرستیں [1:]: # ہر فہرست کے ساتھ چوراہے کو مشترکہ_ایلمنٹس کے ساتھ چوراہا لے کر سیٹ کو اپ ڈیٹ کریں۔ Intersection_update (LST) ریٹرن لسٹ (کامن_لیمنٹس) # مثال useagelist1 = [1 ، 2 ، 3 ، 4 ، 5] لسٹ 2 = [4 ، 5 ،6 ، 7] لسٹ 3 = [5 ، 6 ، 7 ، 8 ، 9] لسٹ 4 = [5 ، 10] نتیجہ = Find_common_elements (لسٹ 1 ، لسٹ 2 ، لسٹ 3 ، لسٹ 4) پرنٹ (\"عام عناصر:\" ، نتیجہ) اس پروگرام میں ،`تلاش کریں"
    },
    {
        "Question": "کسی پروگرام کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے اسٹرنگ کسی پیلنڈرووم کا اناگرام ہے۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار کسی پالنڈرووم کا اناگرام ہے: پائیتھون کوپی کوڈڈیف is_anagram_of_palindrome (سٹرنگ): چار_کاؤنٹ = {} # ہر کردار کے واقعات کو تار کے لئے تار میں گنتی کریں: اگر چار_کونٹ میں چار_کاؤنٹ [چار_کاؤنٹ [چار] += 1 اور: چار_کاؤنٹ [چار] = 1 اوڈ_کاؤنٹ = 0 # ہر کردار کی گنتی کے لئے چار_کاؤنٹ میں گنتی کے لئے چیک کریں۔عجیب و غریب گنتی کے ساتھ ایک حرف ، # تار کو ایک پیلیندرووم میں دوبارہ نہیں لگایا جاسکتا ہے اگر عجیب_کاؤنٹ> 1: غلط واپسی سچ #Palindrome. \") اور:"
    },
    {
        "Question": "دوگنا منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور قیمت کے لحاظ سے نوڈ کو حذف کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو دوگنا منسلک فہرست کی نمائندگی کرتی ہے اور نوڈ کو قدر کے لحاظ سے حذف کرنے کے لئے ایک طریقہ کار پر عمل درآمد کرتی ہے: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا پریو = کوئی بھی نہیں۔ نونکس ڈبل لنکڈ لسٹ: ڈیف ڈیف__init __ (self): self.head = کوئی بھی Def ضمیمہ (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر سیلف ہیڈ کوئی نہیں ہے: سیلف۔ ہیڈ = نیا_نوڈ اور: موجودہ = سیلف ہیڈ جبکہ موجودہ۔ موجودہ: موجودہ =موجودہ۔ نیکسٹ کرنٹ۔ نیکسٹ = نیا_نوڈ نیا_نوڈ.پریو = موجودہ ڈیف ڈیلیٹ_بی_ویلیو (خود ، قدر): موجودہ = سیلف۔ ہیڈ # کو حذف کرنے کے لئے نوڈ کو تلاش کرنے کے لئے فہرست کو عبور کریں"
    },
    {
        "Question": "لغت (لغت) آرڈر میں تاروں کی فہرست ترتیب دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!لغت (لغت) آرڈر میں تاروں کی فہرست کو ترتیب دینے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈ ڈیف ترتیب_سٹرنگس_لیکسوگرافک (سٹرنگ_ لسٹ): ترتیب شدہ_ لسٹ = ترتیب شدہ (سٹرنگ_ لسٹ) کو ترتیب دیا گیا ہے۔کتا '،' ہاتھی '] ترتیب شدہ_سٹرنگز = ترتیب_سٹرنگز_لیکسوگرافک (اسٹرنگس) پرنٹ (\"ترتیب شدہ تار:\") ترتیب شدہ_سٹرنگز میں تار کے لئے: اس پروگرام میں پرنٹ (سٹرنگ) ، ترتیب_سٹرنگ_لیکسیگرافک طور پر فنکشن ، اسٹرنگز ، سٹرنگ_ لسٹ کے طور پر ، ایک دلیل اور ترتیب کے طور پر ، تار کی فہرست لیتا ہے۔یہ ترتیب شدہ فنکشن کا استعمال کرتے ہوئے لغت میں ترتیب میں ہے۔ ترتیب شدہ فنکشن ایک نئی فہرست لوٹاتا ہے جس میں لغت (لغت) کے آرڈر کے مطابق چڑھائی ترتیب میں ترتیب دیئے گئے ڈوروں پر مشتمل ایک نئی فہرست لوٹتی ہے۔ اس کے بعد ترتیب دی گئی فہرست کو فنکشن کے ذریعہ واپس کردیا جاتا ہے۔ مثال کے طور پر استعمال سے یہ ظاہر ہوتا ہے کہ کس طرح کال کیا جائےتاروں کی نمونہ کی فہرست کے ساتھ کام ، `"
    },
    {
        "Question": "اعشاریہ کی تعداد کو بائنری فریکشن میں تبدیل کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!اعشاریہ کی تعداد کو بائنری فریکشن میں تبدیل کرنے کے لئے یہاں ایک ازگر کا فنکشن ہے: پائیتھون کوپی کوڈ ڈیف اعشاریہ_و_بائنری_فراکشن (اعشاریہ_نبر ، صحت سے متعلق = 8)(لازمی_پارٹ) [2:] + \".\"# اعشاریہ کی تعداد کے جزوی حصے کو بائنری فریکشنل_پارٹ = اعشاریہ_نمبر میں تبدیل کریں -انٹیگرل_پارٹ جبکہ صحت سے متعلق> 0: فریکشنل_پارٹ *= 2 بٹ = انٹ (فریکشنل_پارٹ) بائنری_فراکشن += ایس ٹی آر (بٹ) فریکشنل_پارٹ -= 1 ریٹرن بائنری_فراکشن#usagenumber = 6.75binary_fraction = decimal_to_binary_fraction (نمبر) پرنٹ (f \"بائنری حصہ {نمبر} کا ہے: {بائنری_فراکشن}\") اس پروگرام میں ، اعشاریہ_ٹو_بائنری_فراکشن فنکشن ایک اعشاریہ نمبر لیتا ہے"
    },
    {
        "Question": "ایک مقررہ نمبر تک بنیادی تعداد کا مجموعہ تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں ایک مقررہ نمبر تک بنیادی نمبروں کا مجموعہ تلاش کرنے کے لئے ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف آئی ایس_پرائم (این): اگر این <= 1: رینج میں I کے لئے غلط لوٹائیں (2 ، انٹ (این ** 0.5) + 1): اگر n ٪ i == 0: غلط واپسی trudef sum_of_primes (حد) واپس کریں: پرائم_سم = 0 نمبر کے لئے (2 ، حد + 1): اگر is_prime (num): prime_sum + = num واپسی پرائم_سم# مثال usagenumber = 100 premime_sum= sum_of_primes (نمبر) پرنٹ (f \"{نمبر} تک بنیادی تعداد کا مجموعہ ہے: {prime_sum}\") اس پروگرام میں ، IS_PRIME فنکشن یہ چیک کرنے کے لئے استعمال کیا جاتا ہے کہ آیا کوئی نمبر N پرائم ہے یا نہیں۔یہ 2 سے ن کے مربع جڑ تک پہنچتا ہے اور چیک کرتا ہے کہ اگر n اس حد میں کسی بھی تعداد کے ذریعہ تقسیم ہوتا ہے۔اگر n کسی بھی تعداد کے ذریعہ تقسیم ہے تو ، یہ غلط لوٹتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ N بنیادی نہیں ہے۔بصورت دیگر ، یہ سچ لوٹتا ہے ، اس بات کی نشاندہی کرتا ہے کہ N پرائم ہے"
    },
    {
        "Question": "ہیش ٹیبل کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور کلیدی قدر کے جوڑے ڈالنے اور بازیافت کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جس میں ہیش ٹیبل کی نمائندگی کی گئی ہے جس میں کلیدی قدر کے جوڑے ڈالنے اور بازیافت کرنے کے طریقوں کے ساتھ ہیں: پائیٹون کوپی کوڈکلاس ہیش ٹیبل: ڈیف __init __ (خود ، سائز): سیلف۔ سائز = سائز سیلف۔ ٹیبل = [[] _ کے لئے _ (سائز) کے لئے (سائز)] Def _hash (خود ، کلید): واپسی ہیش (کلید) ٪ خود۔v) انیمریٹ (بالٹی) میں: اگر k == key: بالٹی [i] = (کلیدی ، قدر) واپس بالٹی.ایپینڈ ((کلیدی ، قدر)) ڈیف بازیافت (خود ، کلید): انڈیکس = سیلف۔) بالٹی = سیلف. ٹیبل [انڈیکس] کے لئے ، K ، B بالٹی میں: اگر K == کلید: ریٹرن وی رائز کلیدرر (F \"key '{key}' ہیش ٹیبل میں نہیں ملا۔\") Def __str __ (خود):عناصر = []"
    },
    {
        "Question": "کسی بھی بلٹ ان طریقوں کو استعمال کیے بغیر دیئے گئے تار کو پلٹنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں کسی بھی بلٹ ان طریقوں کا استعمال کیے بغیر دیئے گئے تار کو الٹا کرنے کے لئے یہاں ایک فنکشن ہے: پائیتھون کوپی کوڈیڈف ریورس_سٹرنگ (سٹرنگ): ریورسڈ_سٹرنگ = \"\" میں رینج (لین (سٹرنگ) -1 ، -1 ، -1) کے لئے: الٹ_سٹرنگ += سٹرنگ [i] اس فنکشن کو الٹ_سٹرینگن لوٹائیں ، ہم الٹ سٹرنگ کو ذخیرہ کرنے کے لئے خالی سٹرنگ الٹ_سٹرنگ کا آغاز کرتے ہیں۔ہم لوپ کے لئے A کا استعمال کرتے ہوئے ریورس آرڈر میں ان پٹ سٹرنگ کے کرداروں پر تکرار کرتے ہیں۔سٹرنگ (لین (سٹرنگ) - 1) کے آخری انڈیکس سے شروع کرتے ہوئے ، ہم انڈیکس کے ذریعہ کمی کرتے ہیں"
    },
    {
        "Question": "دو ترتیب شدہ فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!دو ترتیب شدہ فہرستوں کے مابین مشترکہ عناصر کو تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیٹون کوپی کوڈ ڈیف Find_common_elements (List1 ، List2): کامن_لیمنٹس = [] i ، j = 0 ، 0 جبکہ میں <لین (لسٹ 1) اور جے <لین (لسٹ 2): اگر لسٹ 1[i] == لسٹ 2 [j]: کامن_لیمنٹس۔ اپینڈ (لسٹ 1 [i]) i += 1 J += 1 الیف لسٹ 1 [i] <فہرست 2 [j]: i += 1 اور: j += 1 عام_ایلمنٹ واپس کریں# مثال useagelist1 = [1 ، 2 ، 3 ، 4 ، 6 ، 8] فہرست 2 = [2 ، 4 ، 5 ، 6 ، 6 ، 7 ، 8] عام_ایلمنٹ = find_common_elements (لسٹ 1 ، لسٹ 2) اس پروگرام میں پرنٹ (کامن_لیمنٹس) ، find_common_elementsفنکشن دو ترتیب دیتا ہے"
    },
    {
        "Question": "ایک ازگر کلاس بنائیں جس میں بائنری من-ہیپ کی نمائندگی کی جائے اور کم سے کم عنصر کو داخل کرنے اور نکالنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جس میں بائنری من-کم سے کم عنصر داخل کرنے اور نکالنے کے طریقوں کے ساتھ بائنری من-ہیپ کی نمائندگی کی جاتی ہے: پائیٹون کوپی کوڈکلاس منہیپ: ڈیف __init __ (خود): سیلف.ہپ = [] ڈیف داخل (خود ، قدر): سیلف.ایپ.ایپینڈ (خودویلیو) سیلف۔self.heap) - 1) min_value = self.heap.pop () self._down_heapify (0) واپسی min_value def _up_heapify (سیلف ، انڈیکس): پیرنٹ_ انڈیکس = (انڈیکس - 1) // 2 اگر والدین_ انڈیکس> = 0 اور خود۔ہیپ [پیرنٹ_ انڈیکس]> سیلف۔ ایچ ای اے پی [انڈیکس]: سیلف ۔_سوپ (پیرنٹ_ انڈیکس ، انڈیکس) سیلف۔+ 2 سب سے چھوٹا"
    },
    {
        "Question": "تار میں پہلا غیر بار بار ہونے والے کردار کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!اسٹرنگ میں پہلا غیر بار بار ہونے والے کردار کو تلاش کرنے کے لئے کسی فنکشن کا نفاذ یہاں ہے: پائیتھون کوپی کوڈ ڈیف Find_first_non_repeating_character (سٹرنگ): چار_کاؤنٹ = {string تار میں چار کے لئے: چار_ کاؤنٹ [چار] = چار_کاؤنٹ.جیٹ (چار ، 0) + 1 کے لئے + 1سٹرنگ میں چار: اگر چار_کاؤنٹ [چار] == 1: ریٹرن چار ریٹرن کوئی بھی نہیں # مثال کے طور پر usagestring = \"ہیلو ورلڈ\" نتیجہ = find_first_non_repeating_character (سٹرنگ) پرنٹ (نتیجہ) # آؤٹ پٹ: \"h\" اس عمل میں ، find_first_non_repeating_character فنکشن A لیتا ہے۔ان پٹ کے طور پر اسٹرنگ اور پہلا غیر بار بار ہونے والے کردار کو واپس کرتا ہے۔ سب سے پہلے ، ہم اسٹور کو اسٹور کرنے کے لئے ایک لغت چار_کاؤنٹ بناتے ہیں"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیئے گئے اسٹرنگ ایک درست URL ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار ایک درست URL ہے ، آپ ازگر میں urllib.parse ماڈیول استعمال کرسکتے ہیں۔یہاں ایک مثال کا پروگرام ہے: پائیتھون کوپی کوڈفرم urllib.parse درآمد urlparsedef is_valid_url (url): کوشش کریں: نتیجہ = urlperse (url) سب واپس کریں ([نتیجہ. scheme ، result.netloc]) سوائے value error کے سوا: غلط# مثال کے طور پر استعمال کرنے والا# مثال استعمال کریں//www.example.com\"url2 = \"http: // مثال\" url3 = \"invalid_url\" پرنٹ (is_valid_url (url1)) # آؤٹ پٹ: سچ پرنٹ (is_valid_url (url2)) # آؤٹ پٹ: غلط پرنٹ (is_valid_url (url3)) #آؤٹ پٹ: اس پروگرام کو باطل ، IS_Valid_URL فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور urllib.parse سے urlprese فنکشن کو URL کی تجزیہ کرنے اور اس کے اجزاء کو بازیافت کرنے کے لئے استعمال کرتا ہے۔"
    },
    {
        "Question": "متعدد سیٹوں کا چوراہا تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!متعدد سیٹوں کا چوراہا تلاش کرنے کے لئے یہاں ایک مثال کا پروگرام ہے: پائیٹون کوپی کوڈیڈف Find_intersection (*سیٹ): اگر لین (سیٹ) <2: واپسی سیٹ () چوراہا"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر ایک پیلنڈرووم ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا کوئی دیئے گئے نمبر ایک پالندرووم ہے: پائیتھون کوپی کوڈیڈف is_palindrome (نمبر): اگر نمبر <0: غلط ریورس = 0 ٹیمپ = نمبر جبکہ ٹیمپ> 0: ہندسہ = ٹیمپ ٪ 10 ریورس = ریورس *10 + ہندسے کی عارضی = عارضی // 10 ریٹرن ریورس == نمبر # مثال usagenum1 = 12321num2 = 12345 پرنٹ (is_palindrome (num1)) # آؤٹ پٹ: ٹروپنٹ (is_palindrome (num2)) # آؤٹ پٹ: یہ عمل درآمد ، is_palindrome فنکشن ایک نمبر لیتا ہے۔جیسا کہ ان پٹ اور چیک کرتا ہے کہ آیا یہ palindrome.first ہے ، ہم چیک کرتے ہیں کہ آیا نمبر منفی ہے یا نہیں۔اگر ایسا ہے تو ، ہم اسے پیلینڈرووم نہیں سمجھتے ہیں اور جھوٹی لوٹتے ہیں۔ماڈیولس کو 10 کے ساتھ لے جانا ، اور اس کو 10 سے ضرب دے کر ریورس متغیر کو اپ ڈیٹ کریں"
    },
    {
        "Question": "سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور یہ چیک کرنے کے لئے کسی طریقہ کو نافذ کریں کہ آیا یہ بھرا ہوا ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو سرکلر قطار کی نمائندگی کرتی ہے جس کی جانچ پڑتال کرنے کے لئے کسی طریقہ کے ساتھ یہ ہے کہ آیا یہ مکمل ہے: پیتھون کوپی کوڈکلاس سرکلر کیوئو: ڈیف __init __ (خود ، صلاحیت): خود کی صلاحیت = صلاحیت خود۔.front = 0 self.reare = -1 def is_full (self): خود واپس کریں۔.enqueue (20) قطار. enqueue (30) قطار. enqueue (40) قطار. enqueue (50) پرنٹ (قطار. is_full ()) # آؤٹ پٹ: اس پر عمل درآمد کو سچ ، سرکلر کیو کلاس ایک سرکلر قطار کی نمائندگی کرتا ہے۔اس میں قطار کی زیادہ سے زیادہ صلاحیت کو محفوظ کرنے کے لئے ایک وصف کی گنجائش ہے ، ایک وصف `"
    },
    {
        "Question": "سب سے بڑا پرائم پیلنڈرووم کسی دیئے گئے نمبر سے کم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!سب سے بڑے پرائم پیلنڈرووم کو کسی مخصوص تعداد سے کم تلاش کرنے کے لئے ایک پروگرام ہے: پائیتھون کوپی کوڈیڈف آئی ایس_پائم (نمبر): اگر نمبر <2: رینج میں I کے لئے جھوٹی لوٹیں (2 ، INT (نمبر ** 0.5) + 1): اگر نمبر ٪)i == 0: واپس جھوٹی ریٹرن ٹریوڈف آئی ایس_پالنڈرووم (نمبر): ریٹرن ایس ٹی آر (نمبر) == ایس ٹی آر (نمبر) [:: -1] ڈیف سب سے بڑا_پائم_پالینڈرووم (حد): حد میں نمبر کے لئے (حد -1 ، 1 ، -1): اگر is_prime (num) اور is_palindrome (num): واپسی نمبر کوئی نہیں # کوئی بھی نہیں # مثال کے طور پر اسجیلیمٹ = 1000larist_prime_palindrome_num = سب سے بڑے_پائیم_پالینڈرووم (حد) پرنٹ: یہ فنکشن (سب سے بڑے_پائرم_پالینڈرووم_نوم) # آؤٹ پٹ: 929 میں یہ پروگرام ہے: 929 میں ہمارے پاس تین ہیلیپر پرائم ہیں۔ایک نمبر پرائم ہے یا نہیں۔یہ 2 سے مربع جڑ تک تکرار کرتا ہے"
    },
    {
        "Question": "کسی فہرست سے کسی مخصوص عنصر کے تمام واقعات کو دور کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن ہے جو کسی فہرست سے کسی مخصوص عنصر کے تمام واقعات کو ہٹاتا ہے: پائیتھون کوپی کوڈیڈف ریمو_لیمنٹ (ایل ایس ٹی ، عنصر): واپسی [X کے لئے X کے لئے X! = عنصر] اس فنکشن میں ، LST ان پٹ لسٹ ہے اور عنصر ہے اور عنصر وہ ہے وہ ہےعنصر کو ہٹا دیا جائے۔فنکشن LST میں ہر عنصر پر تکرار کرنے کے لئے فہرست کی تفہیم کا استعمال کرتا ہے اور اس میں صرف وہ عناصر شامل ہیں جو نتیجے میں فہرست میں عنصر کے برابر نہیں ہیں۔اس کی فہرست سے عنصر کے تمام واقعات کو مؤثر طریقے سے دور کیا جاتا ہے۔ یہاں فنکشن کا ایک مثال استعمال ہے: پائیتھون کوپی کوڈمی_ لسٹ = [1 ، 2 ، 3 ، 4 ، 3 ، 5 ، 3] نتیجہ = ہٹائیں_لیمنٹ (my_list ، 3) پرنٹ (نتیجہ) #آؤٹ پٹ: [1 ، 2 ، 4 ، 5] اس مثال میں ، ہمارے پاس ایک فہرست ہے جس میں عنصر 3 کے متعدد واقعات کے ساتھ My_list ہے۔"
    },
    {
        "Question": "کسی دیئے گئے نمبر کے ہندسوں کی رقم کا حساب لگانے کے لئے ایک پروگرام لکھیں جب تک کہ یہ ایک ہندسہ نمبر نہ بن جائے۔",
        "Answer": "یقینا!یہاں ایک دیئے گئے نمبر کے ہندسوں کے مجموعہ کا حساب لگانے کے لئے ایک پروگرام ہے جب تک کہ یہ واحد ہندسہ نمبر نہ بن جائے: پائیٹون کوپی کوڈڈیف SUM_OF_DIGITS (نمبر): جبکہ نمبر> = 10: نمبر = رقم (INT (INT (ہندسہ))) ریٹرن نمبر # مثال usagenumber = 12345Result = sum_of_digits (نمبر) پرنٹ (نتیجہ) پرنٹ (نتیجہ) # آؤٹ پٹ: 6 پروگرام میں ، sum_of_digits فنکشن ان پٹ کے طور پر ایک نمبر لیتا ہے اور اس کے ہندسوں کی رقم کا حساب لگاتا ہے جب تک کہ اس کے اعداد و شمار کو ایک ہندسہ نہ بن جائے۔نمبر۔ فنکشن تھوڑی دیر کا استعمال کرتا ہے جب تک کہ تعداد 10 سے کم نہ ہوجائے اس وقت تک رقم کا حساب لگاتے رہیں۔) ہند (نمبر) میں ہندسے کے لئے۔اس کے بعد ہندسوں کی رقم کا حساب لگانے کے لئے رقم کا کام استعمال کیا جاتا ہے۔یہ عمل اس وقت تک جاری رہتا ہے جب تک کہ نتیجے میں رقم ایک ہندسے کا نمبر نہ بن جائے۔ ایک بار جب خلا ایک واحد ہندسے کا نمبر بن جاتا ہے ، لوپ سے باہر نکل جاتا ہے اور فنکشن لوٹتا ہے"
    },
    {
        "Question": "ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور الفاظ کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو ایک ٹری (سابقہ درخت) کی نمائندگی کرتی ہے اور الفاظ کو داخل کرنے اور تلاش کرنے کے ل methods طریقوں کو نافذ کرتی ہے: پیتھون کوپی کوڈکلاس ٹرائینوڈ: ڈیف __Init __ (خود): سیلف۔ چائلڈین = {{} سیلف_ینڈ_ف_ ورڈ = فالسکلاس ٹری: ڈیف __Init __ (خود):self.root = trienode () Def داخل کریں (خود ، لفظ): لفظ میں چار کے لئے نوڈ = سیلف۔] node.is_end_of_word = سچے ڈیف سرچ (خود ، لفظ): نوڈ = سیلف۔ لفظ میں چار کے لئے: اگر چار نہیں نوڈ میں نہیں۔دو کلاسیں ہیں: ٹرائینوڈ: یہ کلاس ٹری میں ایک نوڈ کی نمائندگی کرتی ہے۔اس میں چائلڈ نوڈس کو ذخیرہ کرنے کے لئے لغت کے بچے ہیں ، اور ایک بولین IS_END_OF_WORD پرچم اس بات کی نشاندہی کرنے کے لئے کہ اگر کوئی لفظ اس نوڈ پر ختم ہوتا ہے۔مثال کے طور پر اس میں جڑ کا نوڈ ہوتا ہے۔داخل کرنے کا طریقہ تکرار کرکے ٹرائی میں ایک لفظ داخل کرتا ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے اسٹرنگ کسی اور تار کا اناگرام ہے۔",
        "Answer": "یقینا!یہاں ایک فنکشن یہ ہے کہ آیا دیئے گئے تار کسی اور تار کا اناگرام ہے یا نہیں: پائیتھون کوپی کوڈیڈف آئی ایس_نگگرام (ایس ٹی آر 1 ، ایس ٹی آر 2): # دونوں تاروں کو لوئر کیس میں تبدیل کریں اور وائٹ اسپیس str1 = str1.lower () کو تبدیل کریں (\"\" ، \"،\" \")str2 = str2.lower (). تبدیل کریں (\"\" ، \"\") # چیک کریں کہ کیا تار کی لمبائی برابر ہے اگر لین (str1)! = لین (str2): دونوں تار میں کردار کی تعدد کی گنتی کے لئے غلط # لغت بنائیںچار_کاؤنٹ_1 =}} چار_کاؤنٹ_2 = {} # ایس ٹی آر 1 میں ایس ٹی آر 1 میں ہر کردار کی فریکوئنسی کو ایس ٹی آر 1 میں شمار کریں: چار_کاؤنٹ_1 [چار] = چار_کاؤنٹ_1.بیٹ (چار ، 0) + 1 # ایس ٹی آر 2 میں ایس ٹی آر 2 میں ہر کردار کی فریکوئنسی کو ایس ٹی آر 2 میں شمار کریں۔: چار_کاؤنٹ_2 [چار] = چار_کاؤنٹ_2. گیٹ (چار ، 0) + 1 # چیک کریں کہ کیا دونوں ڈوروں میں کردار کی تعدد مساوی واپسی چار_کاؤنٹ_1 == چار_کاؤنٹ_2 ان پر عمل درآمد ہے ، آئی ایس_انگرم فنکشن دو اسٹرنگز ایس ٹی آر 1 اور ایس ٹی آر 2 کو ان پٹ اور چیک کے طور پر لیتا ہے اگر"
    },
    {
        "Question": "ایک مقررہ مقدار میں تبدیلی کرنے کے ل neede کم سے کم سکے کی تلاش کے ل a ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک مقررہ رقم تلاش کرنے کے لئے ایک پروگرام ہے جس میں کم سے کم تعداد میں تبدیلی کی ضرورت ہے: پائیٹون کوپی کوڈیڈف کم سے کم_کوائنز (سکے ، رقم): # ہر رقم کے لئے درکار سککوں کی کم سے کم تعداد کو ذخیرہ کرنے کے لئے ایک فہرست بنائیں۔')] * (رقم + 1) # بیس کیس: 0 COINS 0 رقم DP بنانے کے لئے درکار ہے [0] = 0 # تمام مقدار میں 1 سے لے کر ہدف کی رقم میں I کے لئے ہدف کی رقم (1 ، رقم + 1): #سکے میں سکے کے لئے تمام دستیاب سککوں پر تکرار کریں: # اگر موجودہ سکے کی قیمت موجودہ رقم سے کم یا اس کے برابر ہے تو ، # موجودہ رقم کے لئے درکار سککوں کی کم سے کم تعداد کو اپ ڈیٹ کریں اگر سکے <= i: dp [i] = منٹ."
    },
    {
        "Question": "فہرست میں دوسرا چھوٹا عنصر تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!ایک فہرست میں دوسرا سب سے چھوٹا عنصر تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیتھون کوپی کوڈیڈف Find_second_smallest (نمبر): اگر لین (نمبرز) <2: کوئی بھی چھوٹا نہیں = فلوٹ ('انف') سیکنڈ_سمالسٹ = فلوٹ ('انف') نمبر میں نمبر کے لئے نمبر: اگر نمبر <سب سے چھوٹا: دوسرا_سمالسٹ = سب سے چھوٹا سب سے چھوٹا = نمبر ایلف نمبر <سیکنڈ_سمالسٹ اور نمبر! = سب سے چھوٹا: دوسرا_سمالسٹ = نمبر اگر سیکنڈ_سمالسٹ == فلوٹ ('انف'): واپس کوئی اور نہیں: واپس نہیں: سیکنڈ_سمالسٹٹ_سیکنڈ_سمالسٹ فنکشن نمبر نمبر کی فہرست لیتا ہے۔جیسا کہ ان پٹ اور دوسرا سب سے چھوٹا عنصر لوٹاتا ہے۔یہ کیسے کام کرتا ہے: ہم دو متغیرات کو زیادہ سے زیادہ ممکنہ ویلیو فلوٹ ('INF') کے ساتھ سب سے چھوٹے اور دوسرے_سمالسٹ شروع کرتے ہیں۔ ہم ان پٹ لسٹ نمبر میں ہر نمبر نمبر پر تکرار کرتے ہیں۔ اگر موجودہ نمبر اگر موجودہ نمبر ہے۔"
    },
    {
        "Question": "میٹرکس کے اضافے کے ل a ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!میٹرکس کے اضافے کو انجام دینے کے لئے ایک پروگرام یہ ہے: پائیٹون کوپی کوڈیڈف میٹرکس_اڈیشن (میٹرکس 1"
    },
    {
        "Question": "ایک ہیش سیٹ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور عناصر کو داخل کرنے اور اسے دور کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو عناصر کو داخل کرنے اور اسے دور کرنے کے طریقوں کے ساتھ ہیش سیٹ کی نمائندگی کرتا ہے: پیتھون کوپی کوڈکلاس ہیشسیٹ: ڈیف __init __ (خود): سیل. بوکیٹ_کاؤنٹ = 16 سیلف بوکٹس = [[] _ کے لئے _ (سیلف بوکیٹ_کاؤنٹ)] Def _hash_function (خود ، قدر): ریٹرن ہیش (قدر) ٪ سیلف۔ بوکیٹ_کاؤنٹ ڈیف داخل (خود ، قدر): ہیش_ ویلیو = سیلف۔ضمیمہ (قدر) ڈیف کو ہٹائیں (خود ، قدر): ہیش_ویلیو = سیلف۔._hash_function (ویلیو) بالٹی = خود"
    },
    {
        "Question": "عدد کی ایک دی گئی فہرست میں طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں سب سے طویل عرصے تک بڑھتے ہوئے سبری کی لمبائی تلاش کرنے کے لئے ایک پروگرام ہے: پائیٹون کوپی کوڈ ڈیف Find_longest_increasing_subarray_length (نمبر): اگر نمبر نہیں تو: رینج میں 0 طویل ترین_لنتھ = 1 موجودہ_ لمبائی = 1 رینج (1 ، لین (نمبر)): اگر نمبر [i]> نمبر [i - 1]: کرنٹ_ لمبائی += 1 لمبی ترین_ لمبائی = زیادہ سے زیادہ (طویل ترین_ لمبائی ، موجودہ_ لمبائی) اور: موجودہ_ لمبائی = 1 طویل ترین_ لمبائی کے فنکشن کی ایک مثال کے استعمال: پائیٹون کوپی کوڈینومز = [1 ، 2 ، 3 ، 3 ،2 ، 4 ، 5 ، 1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 6 ، 7] نتیجہ = find_longest_increasing_subarray_length (nums) پرنٹ (نتیجہ) # آؤٹ پٹ: 6 ان مثال کے طور پر ، پروگرام `find_long کی وضاحت کرتا ہے۔"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا کوئی دیئے گئے اسٹرنگ ایک درست پیلنڈرووم ہے ، صرف حفانومیرک کرداروں پر غور کریں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جو چیک کرتا ہے کہ اگر کسی دیئے گئے تار ایک درست پالندرووم ہے ، صرف حرفیومیرک حرفوں پر غور کرتے ہوئے: پائیتھون کوپی کوڈیڈف آئی ایس_والیڈ_پالنڈرووم (ایس): # غیر الفانومیرک حروف کو ہٹا دیں اور لوئر کیس ایس = '' میں تبدیل کریں۔) CH IN s if if ch.isalnum ()) # چیک کریں کہ آیا تار ایک palindrome ہے s == s [::-1] فنکشن کی ایک مثال استعمال ہے: پائیٹون کوپی کوڈسٹرینگ 1 = \"ایک آدمی ، ایک منصوبہ ، aکینال: پاناما \"نتیجہ 1 = is_valid_palindrome (سٹرنگ 1) پرنٹ (نتیجہ 1) # آؤٹ پٹ: Truestring2 =\" ریس ایک کار \"کا نتیجہ 2 = is_valid_palindrome (String2) پرنٹ (نتیجہ 2) # آؤٹ پٹ: فالین اس مثال کے طور پر ، پروگرام is_valid_palindrome فنکشن کی وضاحت کرتا ہے جس میں A لیتا ہے۔اسٹرنگ ایس ان پٹ کے طور پر۔یہ فہرست کی تفہیم اور کنورٹ کا استعمال کرتے ہوئے سٹرنگ سے تمام غیر الفانومرک کرداروں کو ہٹا دیتا ہے"
    },
    {
        "Question": "دیئے گئے تار کے ہر ممکن اجازت نامے تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں دیئے گئے تار کے ہر ممکنہ اجازت نامے تیار کرنے کے لئے ایک پروگرام ہے: پائیٹون کوپی کوڈ ڈیف جنریٹ_پرمیوٹیشنز (زبانیں): # بیس کیس: اگر اسٹرنگ میں صرف ایک ہی کردار ہے تو ، اسے سنگل عنصر کی فہرست کے طور پر واپس کریں اگر لین (ایس) == 1: واپسی[s] # recursive کیس: سٹرنگ پرمٹیشنز = [] میں ہر کردار کے لئے اجازت نامہ تیار کریں (len (s)): # موجودہ کردار کو سٹرنگ سے بقیہ_چارز = s [i] + s [i] [ + + + + سے ہٹا دیں1:] # باقی حروف کے لئے اجازت نامہ تیار کریں۔فنکشن: پائیتھون کوپی کوڈسٹریننگ = \"اے بی سی\" پرمٹیشن = جنریٹ_پرموٹیشن"
    },
    {
        "Question": "سرکلر سے منسلک فہرست کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو سرکلر منسلک فہرست کی نمائندگی کرتی ہے جس میں کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے طریقہ کار کے ساتھ ایک طریقہ ہے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، اعداد و شمار): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ سرکلر لنکڈ لسٹ: ڈیف __ __init __ (خود).. نیکسٹ!= 1 # نوڈ کو حذف کرنے کے ل find تلاش کریں جبکہ گنتی <پوزیشن: سابقہ = موجودہ موجودہ = کرنٹ۔ نیکسٹ"
    },
    {
        "Question": "کسی فہرست میں اکثریت عنصر (N/2 بار سے زیادہ ظاہر ہوتا ہے) تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!کسی فہرست میں اکثریت کے عنصر کو تلاش کرنے کے لئے کسی فنکشن کا نفاذ یہاں ہے: پائیتھون کوپی کوڈیڈف Find_majority_element (نمبر): گنتی = 0 اکثریت = نمبر میں نمبر کے لئے کوئی بھی نہیں: اگر گنتی == 0: اکثریت = نمبر گنتی = 1 الیف نمبر == اکثریت: گنتی += 1 اور: گنتی -= 1 # تصدیق کریں کہ اگر اکثریت کا عنصر N /2 بار سے زیادہ ظاہر ہوتا ہے nums میں نمبر کے لئے نمبر = 0: اگر نمبر == اکثریت: گنتی += 1 اگر گنتی> لین (نمبر) // 2: اکثریت کی واپسی: کوئی بھی نہیں# مثال کے استعمال: nums = [1 ، 2 ، 3 ، 2 ، 2 ، 2 ، 2 ، 5] نتیجہ = find_majority_element (nums) اگر نتیجہ کوئی نہیں ہے تو: پرنٹ (f \"اکثریت عنصر میںاس فہرست میں {نتیجہ} \") اور: پرنٹ (\" فہرست میں کوئی اکثریت کا عنصر نہیں ہے \") اس عمل میں ،"
    },
    {
        "Question": "یہاں تک کہ کسی بھی حد تک فبونیکی نمبروں کی رقم کا حساب لگانے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہ ایک پروگرام ہے جو کسی بھی حد تک تمام یہاں تک کہ فبونیکی نمبروں کے مجموعہ کا حساب لگاتا ہے: پائیتھون کوپی کوڈڈیف SUM_EVEN_FIBONACCI (حد): # متغیرات کو شروع کریں ، کرر = 0 ، 1 SUM_EVEN = 0 # کا حساب کتاب کریں اور یہاں تک کہ <<= حد: اگر کرر ٪ 2 == 0: sum_even + = curr # اگلی فبونیکی نمبر پرو ، کرر = کرور ، پری + کرر ریٹرن سوم_ ایوین # مثال کے استعمال: حد = 4000000Result = som_even_fibonacci (حد) پرنٹ (f \"Sum\" کا خلاصہ کریںیہاں تک کہ fibonacci نمبر {حد} تک ہے: {نتیجہ} \") اس پروگرام میں ، ہم فبونیکی نمبروں کا حساب لگانے اور یہاں تک کہ ان کا بھی خلاصہ کرنے کے لئے تھوڑی دیر لوپ کا استعمال کرتے ہیں۔ہم ابتدائی اقدار پرو = 0 اور کرر = 1. کے ساتھ شروع کرتے ہیں۔ ہر تکرار میں ، ہم چیک کرتے ہیں کہ کیا کرور ماڈیولو آپریٹر (کرر ٪ 2 == 0) بھی استعمال کررہا ہے۔اگر یہ ہے تو ، ہم اسے `رقم میں شامل کریں"
    },
    {
        "Question": "اندراج ترتیب والے الگورتھم کا استعمال کرتے ہوئے تاروں کی فہرست کو ترتیب دینے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جو اندراج کی ترتیب والے الگورتھم کا استعمال کرتے ہوئے تاروں کی ایک فہرست کو ترتیب دیتا ہے: پائیتھون کوپی کوڈیڈف داخلہ_سورٹ (اسٹرنگز): # رینج (1 ، لین (اسٹرنگز)) کے لئے فہرست کے ذریعے گزرنا: کلیدی = تار [i] j = i -1 # موجودہ عنصر کو عناصر سے پہلے اس سے پہلے موازنہ کریں جبکہ j> = 0 اور تار [j]> کلید: ڈور [j + 1] = تار [j] j -= 1 # موجودہ عنصر کو اس کی صحیح پوزیشن کے تار پر رکھیں [J + 1] = کلیدی واپسی کے تاروں# مثال کے استعمال: ڈور = [\"کیلے\" ، \"ایپل\" ، \"چیری\" ، \"تاریخ\" ، \"بزرگ بیری\"] ترتیب شدہ_سٹرنگز = اندراج_سورٹ (ڈور) پرنٹ (\"تاروں کی ترتیب شدہ فہرست:\") ترتیب شدہ_سٹرنگز میں سٹرنگ کے لئے: اس پروگرام میں پرنٹ (سٹرنگ) ، اندراج_سورٹ فنکشن اندراج ترتیب الگورتھم کو نافذ کرتا ہے۔یہ دوسرے عنصر (i = 1) سے شروع ہونے والی فہرست میں تکرار کرتا ہے اور ہر عنصر کو عناصر سے پہلے (j) سے موازنہ کرتا ہے۔اگر کوئی عنصر چھوٹا ہے تو ، یہ عناصر کو دائیں طرف منتقل کرتا ہے جب تک کہ اسے موجودہ عنصر کے لئے صحیح پوزیشن نہ مل جائے۔آخر میں ، یہ موجودہ عنصر کو رکھتا ہے"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن ہے جس میں کڈانے کے الگورتھم کا استعمال کرتے ہوئے عددی کی ایک دی گئی فہرست میں زیادہ سے زیادہ سبریے کا مجموعہ مل جاتا ہے: پائیتھون کوپی کوڈڈف میکس_سوبری_سم (نمبر): اگر نمبر نہیں تو: واپس 0 میکس_سم = نمبر [0] # زیادہ سے زیادہ رقم موجودہ_سم = نمبر [0] # شروع کریں۔Nums [1:] میں NUM کے لئے موجودہ رقم کو شروع کریں: موجودہ_سم = زیادہ سے زیادہ (NUM ، موجودہ_سم + نمبر) زیادہ سے زیادہ_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) واپسی زیادہ سے زیادہ_سم# مثال کے استعمال: نمبر = [-2 ، 1 ، -3 ، 4 ، 4 ، 4 ،-1 ، 2 ، 1 ، -5 ، 4] نتیجہ = میکس_سوبری_سم (نمبر) پرنٹ (\"زیادہ سے زیادہ سبری رقم:\" ، نتیجہ) اس پروگرام میں ، میکس_سوبری_سم فنکشن کڈانے کے الگورتھم کو نافذ کرتا ہے۔یہ زیادہ سے زیادہ رقم (میکس_سم) اور شروع کرکے شروع ہوتا ہے"
    },
    {
        "Question": "ایک ازگر کی کلاس لکھیں جو ہدایت شدہ وزن والے گراف کی نمائندگی کرتے ہیں اور کناروں کو شامل کرنے اور ڈجکسٹرا کے الگورتھم کو انجام دینے کے لئے طریقوں کو نافذ کرتے ہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کی ایک مثال ہے جو ہدایت والے وزن والے گراف کی نمائندگی کرتی ہے اور ایجکسٹرا کے الگورتھم کو شامل کرنے کے لئے ہدایت شدہ وزن والے گراف اور اس پر عمل درآمد کرنے کے طریقوں کی نمائندگی کرتی ہے: پائیتھون کوپی کوڈفوم ہیپ کیو امپورٹ ہیپپپ ، ہیپشکلاس ڈائریکٹ ویٹ گراف: ڈیف __init __ (خود)، منزل مقصود ، وزن): اگر ماخذ سیلف گراف میں نہیں ہے: سیلف گراف [ماخذ] = [] سیلف گراف [ماخذ]: سیلف گراف میں نوڈ کے لئے فلوٹ ('انف')} فاصلوں [ماخذ] = 0 ترجیحی_کیو = [(0 ، ماخذ)] جبکہ ترجیحی_کیو: کرنٹ_ڈیسٹینس ، کرنٹ_نوڈ = ہیپپپ (ترجیحی_کیو) اگر موجودہ_ڈسٹنس> دوری [موجودہ_نوڈ]: کے لئے جاری رکھیں: کے لئے جاری رکھیں۔پڑوسی ، خود میں وزن۔"
    },
    {
        "Question": "تار سے تمام ڈپلیکیٹ حروف کو ہٹانے اور اصل ترتیب کو برقرار رکھنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جو اصل ترتیب کو برقرار رکھتے ہوئے سٹرنگ سے تمام ڈپلیکیٹ حروف کو ہٹا دیتا ہے: پائیتھون کوپی کوڈ ڈیف ہٹ_ ڈوپلیکیٹس (سٹرنگ): دیکھا = سیٹ () نتیجہ = [] تار میں چار کے لئے: اگر چار نہیں دیکھا گیا: دیکھا گیا۔ ایڈ (چار)نتیجہ.ایپینڈ (چار) واپسی '' .جوئن (نتیجہ)# مثال کے استعمال: ان پٹ_سٹرنگ = \"ہیلو ، ورلڈ!\" آؤٹ پٹ_سٹرنگ = ہٹائیں_ ڈوپلیکیٹس (ان پٹ_اسٹرنگ) پرنٹ (آؤٹ پٹ_سٹرنگ) اس پروگرام میں ، ہٹائیں_ ڈوپلیکٹس ان پٹ کے طور پر تار لیتا ہے اور ہٹاتا ہےآرڈر کو محفوظ رکھتے ہوئے ڈپلیکیٹ حروف۔یہ ایک سیٹ استعمال کرتا ہے ، دیکھا ، ان کرداروں کا سراغ لگانے کے لئے جن کا پہلے ہی سامنا کرنا پڑا ہے۔یہ غیر ڈپلیکیٹ حروف کو اصل ترتیب میں ذخیرہ کرنے کے لئے ایک فہرست ، نتیجہ بھی استعمال کرتا ہے۔ ان پٹ سٹرنگ میں ہر کردار پر فنکشن تکرار ہوتا ہے۔اگر کسی کردار کو پہلے نہیں دیکھا گیا ہے (یعنی ، دیکھا ہوا سیٹ میں نہیں) ، تو یہ کردار کو سیٹ میں شامل کرتا ہے اور اسے نتائج کی فہرست میں شامل کرتا ہے۔آخر میں ، نتائج کی فہرست میں شمولیت کے طریقہ کار کا استعمال کرتے ہوئے ایک تار میں شامل ہو جاتا ہے اور واپس آ جاتا ہے۔ مثال کے طور پر استعمال میں ، ہٹ_ ڈوپلیکیٹس فنکشن کو ان پٹ سٹرنگ \"ہیلو ، ورلڈ!\" کے ساتھ کہا جاتا ہے۔نتیجے میں تار چھپی ہوئی ہے ، جو \"ہیلو ، ڈبلیو آر ڈی!\" ہوگی۔چونکہ تمام ڈپلیکیٹ حروف"
    },
    {
        "Question": "\"کسی مخصوص تعداد میں سیڑھی پر چڑھنے کے طریقوں کی تعداد تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں ، اس بات پر غور کرتے ہوئے کہ آپ ایک وقت میں 1 یا 2 قدم اٹھاسکتے ہیں۔\"",
        "Answer": "یقینا!آپ اس مسئلے کو حل کرنے کے لئے ایک تکرار نقطہ نظر استعمال کرسکتے ہیں۔یہاں ایک فنکشن کا نفاذ ہے جو ایک مخصوص تعداد کے ساتھ سیڑھیاں چڑھنے کے طریقوں کی تعداد کا حساب لگاتا ہے: پائیٹون کوپی کوڈ ڈیف گنتی"
    },
    {
        "Question": "کسی دیئے گئے تار میں ہر کردار کے واقعات کی تعداد کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جو کسی دیئے گئے تار میں ہر کردار کے واقعات کی تعداد کی گنتی کرتا ہے: پائیٹون کوپی کوڈیڈف گنتی_چارٹرز (سٹرنگ): چار_ اکاؤنٹ = {string تار میں چار کے لئے: اگر چار_ کاؤنٹ میں چار_کاؤنٹ: چار_کاؤنٹ [چار] += 1 کوئی اور: چار_کاؤنٹ [چار_کاؤنٹ [چار_کاؤنٹ] = 1 ریٹرن چار_کاؤنٹ# مثال کے استعمال: ان پٹ_سٹرنگ = \"ہیلو ، ورلڈ!\" کریکٹر_کاؤنٹ = گنتی_چارٹرز (ان پٹ_سٹرنگ) چار کے لئے ، کریکٹر_کاؤنٹ میں گنتی کریں۔، Count_characters فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور ایک لغت چار_کاؤنٹ لوٹاتا ہے جہاں چابیاں تار میں کردار ہوتی ہیں اور اقدار ہر کردار کی گنتی ہوتی ہیں۔ فنکشن ہر کردار میں تکرار کرتا ہے۔"
    },
    {
        "Question": "ایک ازگر کلاس بنائیں جس میں سرکلر دوگنا منسلک فہرست کی نمائندگی کی جائے اور آخر میں نوڈ داخل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کی ایک مثال ہے جو سرکلر دوگنا منسلک فہرست کی نمائندگی کرتی ہے اور داخل_ایٹ_اینڈ طریقہ کا نفاذ: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔Def __init __ (self): self.head = کوئی بھی Def داخل_ایٹ_ینڈ (خود ، ڈیٹا): new_node = نوڈ (ڈیٹا) اگر سیلف نہیں ہے تو کوئی بھی نہیں ہے: سیلف۔= self.head.prev last_node.next = new_node new_node.prev ="
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے سٹرنگ ایک درست قوسین کا اظہار ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا کسی دیئے گئے سٹرنگ اسٹیک کا استعمال کرتے ہوئے ایک درست قوسین کا اظہار ہے یا نہیں: پائیتھون کوپی کوڈڈیف is_valid_parentheses (اظہار): اسٹیک = [] اوپننگ_براکیٹس = ['(' ، '،' ['،' {'] کلوزنگ_برکیٹس = [')' ، ']' ، '}'] اظہار کے لئے چار کے لئے: اگر اوپننگ_ بریکٹ میں چار: اسٹیک.ایپینڈ (چار) الیف چار میں بند_برکیٹس میں: اگر لین (اسٹیک) == 0: غلط لوٹنا: آخری_ اوپننگ_برکیٹ = اسٹیک۔پاپ () اگر اوپننگ_برکیٹس۔ انڈیکس (آخری_ اوپننگ_برکیٹ)! = کلوزنگ_براکیٹس۔ انڈیکس (چار): غلط ریٹرن لین (اسٹیک) == اس پر عمل درآمد لوٹائیں تو ، ہم افتتاحی قوسین کا سامنا کرنے کے لئے اسٹیک ڈیٹا ڈھانچہ استعمال کرتے ہیں۔ہم اظہار میں ہر کردار پر تکرار کرتے ہیں اور مندرجہ ذیل اقدامات انجام دیتے ہیں: اگر کردار افتتاحی بریکٹ ہے (یعنی ، '(' ، '،' ['، یا' {') ، تو ہم اسے اسٹیک پر دھکیل دیتے ہیں۔ اگر کردار ایک ہے۔بریکٹ کو بند کرنا (یعنی ، ')' ، ']' ، یا '}') ، ہم چیک کرتے ہیں کہ آیا اسٹیک خالی ہے یا نہیں۔اگر یہ ہے تو ، ہم جانتے ہیں کہ موجودہ اختتامی بریکٹ کے لئے کوئی افتتاحی بریکٹ نہیں ہے ،"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "انٹیجرز کی دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے ل you ، آپ مندرجہ ذیل ازگر پروگرام کا استعمال کرسکتے ہیں: پائیتھون کوپی کوڈڈیف Find_smallest_missing_positive (Nums): n = len (nums) # فہرست کے بائیں جانب تمام مثبت انڈیجرز کو منتقل کریں j = 0رینج (n) میں I کے لئے: اگر نمبر [i] <= 0: nums [i] ، nums [j] = nums [j] ، nums [i] j += 1 # ترمیم شدہ فہرست میں صرف مثبت عدد پر غور کریںnums = nums [j:] n = len (nums) # رینج (n) کے لئے متعلقہ انڈیکس کی نفی کرتے ہوئے ایک مثبت عدد کی موجودگی کو نشان زد کریں: num = abs (nums [i])"
    },
    {
        "Question": "وائٹ اسپیس کو محفوظ رکھتے ہوئے دیئے گئے تار میں الفاظ کے ترتیب کو پلٹنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "وائٹ اسپیس کو محفوظ رکھتے ہوئے دیئے گئے تار میں الفاظ کی ترتیب کو پلٹانے کے ل you ، آپ مندرجہ ذیل ازگر پروگرام کا استعمال کرسکتے ہیں: پائیتھون کوپی کوڈیڈف ریورس_ ورڈز (سٹرنگ): الفاظ = سٹرنگ.سپلٹ (\"\") الٹ_ ورڈز = الفاظ [::-1] الٹ_سٹرنگ = \"\".جین (الٹ_ورڈز) واپس الٹ_سٹرینگ ہیئر کا ریورس_ورڈز فنکشن کا ایک مثال استعمال: پائیتھون کوپی کوڈسٹرینگ =\" ہیلو ورلڈ! آپ کیسے ہیں؟اس مثال میں ، ریورس_ورڈز فنکشن ان پٹ کے طور پر تار لیتا ہے۔یہ سٹرنگ کو وائٹ اسپیس کا استعمال کرتے ہوئے ڈیمیمٹر کے طور پر استعمال کرتے ہوئے الفاظ میں تقسیم کرتا ہے ، الفاظ کی ترتیب کو تبدیل کرتا ہے ، اور پھر اس میں شامل ہوتا ہے"
    },
    {
        "Question": "دی گئی فہرست میں دو عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن ہے جس میں دیئے گئے فہرست میں دو عدد کی زیادہ سے زیادہ پیداوار ملتی ہے: پائیٹون کوپی کوڈیڈف میکس_ پروڈکٹ (نمبر): اگر لین (نمبر) <2: ویلیو ایرر کو بڑھاؤ (\"فہرست میں کم از کم دو عدد پر مشتمل ہونا چاہئے۔\") میکس_ پروڈکٹ = فلوٹ (\")\"-inf\") میں ان رینج (لین (nums)) کے لئے: رینج میں جے کے لئے (i + 1 ، لین (نمبر)): پروڈکٹ = nums [i] * nums [j] اگر پروڈکٹ> میکس_ پروڈکٹ: میکس_ پروڈکٹ = پروڈکٹ"
    },
    {
        "Question": "ایک اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور مستقل وقت میں کم سے کم عنصر تلاش کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!مستقل وقت میں کم سے کم عنصر کی تلاش کے ل a ایک طریقہ کے ساتھ اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس یہاں ہے: پائیٹون کوپی کوڈکلاس اسٹیک ویتھ مین: ڈیف __init __ (خود): سیلف اسٹیک = [] سیلف۔ مین_ اسٹیک = [] ڈیف پش (خود ، قیمت): خود ، قیمت: خود ، قیمت).stack.append (value) اگر سیلف نہیں ہے۔خالی۔اسٹیک خالی ہے۔ \") سیلف۔ اسٹیک [-1] ڈیف آئی ایس ای ایم پی (خود): ریٹرن لین (سیلف اسٹیک) == 0 ڈیف گیٹ_مین (خود): اگر خود نہیں۔ مین_ اسٹیک: انڈیکس ایرر کو بڑھاؤ (\" اسٹیک خالی ہے۔\") سیلف ڈاٹ ایم این_ اسٹیک [-1] اس پر عمل درآمد میں ، ہم دو اسٹیکس استعمال کرتے ہیں: موجودہ کم سے کم عنصر پر نظر رکھنے کے لئے عناصر اور MIN_STACK کو ذخیرہ کرنے کے لئے اسٹیک۔جب بھی ہم کسی عنصر کو اسٹیک پر دھکیلتے ہیں ، ہم یہ بھی چیک کرتے ہیں کہ آیا یہ MIN_STACK کے اوپری عنصر سے کم یا اس کے برابر ہے۔اگر یہ ہے تو ، ہم اسے MIN_STACK پر دھکیلتے ہیں۔جب ہم اسٹیک سے کسی عنصر کو پاپ کرتے ہیں تو ہم چیک کرتے ہیں"
    },
    {
        "Question": "عدد کی ایک دی گئی فہرست میں متناسب سبری کی سب سے بڑی رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں متنازعہ سبری کی سب سے بڑی رقم تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیتھون کوپی کوڈڈیف میکس_سوبری_سم (اے آر آر): اگر نہیں آر آر: اگر نہیں ہے تو 0 کرنٹ_سم = میکس_سم = ار [0] رینج (1 ، اے آر آر (اے آر آر (اے آر آر (اے آر آر))): کرنٹ_سم = زیادہ سے زیادہ (arr [i] ، کرنٹ_سم + آر آر [i]) میکس_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) میکس_سومن واپس کریں ، ہم کڈنے کے الگورتھم کا استعمال کرتے ہیں تاکہ کسی متضاد سبری کی سب سے بڑی رقم تلاش کی جاسکے۔ہم سرنی کے ذریعے تکرار کرتے ہیں اور دو متغیرات کو ٹریک کرتے ہیں: موجودہ_سم اور میکس_سم۔کرنٹ_سم موجودہ انڈیکس پر ختم ہونے والے سبری کی زیادہ سے زیادہ رقم کو ذخیرہ کرتا ہے ، اور میکس_سم اب تک کا سامنا کرنے والی مجموعی طور پر زیادہ سے زیادہ رقم اسٹور کرتا ہے۔ سرے میں ہر عنصر کے لئے ، ہم"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر خوش کن نمبر ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا کوئی دیئے گئے نمبر خوش کن نمبر ہے: پائیتھون کوپی کوڈڈیف is_happy_number (n): ملاحظہ کریں = سیٹ () جبکہ n! = 1: اگر n میں ملاحظہ کریں: غلط ملاحظہ کریں۔ add (n) n = =کیلکولیٹ_نیکسٹ_نمبر (n) ریٹرن ٹریوڈف کا حساب کتاب_نکسٹ_نمبر (این): نیکسٹ_نمبر = 0 جبکہ n> 0: ہندسہ = n ٪ 10 اگلا_نمبر += ہندسہ * ہندس * // = 10 ریٹرن نیکسٹ_نبرن اس عمل کو ، is_happy_number فنکشن چیک اگر ایک دی گئی تعداد ہے اگر دی گئی تعداد ہے توخوش نمبرحساب کتاب کے دوران درپیش نمبروں پر نظر رکھنے کے لئے یہ ایک سیٹ استعمال کیا گیا ہے۔فنکشن بار بار حساب کتاب_ نیکسٹ_نمبر فنکشن کا استعمال کرتے ہوئے اگلے نمبر کا حساب لگاتا ہے جب تک کہ یہ یا تو 1 تک نہ پہنچ جاتا ہے (ایک خوش نمبر کی نشاندہی کرتا ہے) یا کسی ایسی تعداد کا سامنا کرتا ہے جس کا پہلے ہی دورہ کیا گیا ہے (ایک چکر کی نشاندہی کرنا اور خوشگوار نمبر نہیں)۔"
    },
    {
        "Question": "سککوں کے سیٹ کا استعمال کرتے ہوئے دیئے گئے رقم میں تبدیلی لانے کے طریقے کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!سککوں کے ایک سیٹ کا استعمال کرتے ہوئے دیئے گئے رقم کے ل change تبدیلی کے ل to کس طرح کے طریقے تلاش کرنے کے لئے ایک پروگرام ہے: پائیٹون کوپی کوڈ ڈیف گنتی_چینج (سکے ، رقم): ڈی پی = [0] * (رقم + 1) ڈی پی [0] = 1 سکے کے لئےسککوں میں: میں رینج میں (سکے ، رقم +) کے لئے)"
    },
    {
        "Question": "بائنری AVL درخت کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کے ساتھ ازگر میں بائنری AVL درخت کا نفاذ یہاں ہے: پائیٹون کوپی کوڈکلاس Avlnode: Def __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف = کوئی بھی نہیں۔1 کلاس avltree: def __init __ (خود): self.root = کوئی بھی نہیں ڈف داخل کریں (خود ، ڈیٹا): سیلف.روٹ = سیلف = سیلف ۔_ انرٹ (سیل.روٹ ، ڈیٹا) ڈیف _ انرٹ (خود ، نوڈ ، ڈیٹا): اگر نوڈ کوئی نہیں ہے: avlnode (ڈیٹا) واپس کریں اگر ڈیٹا <node.data: node.left = self._insert (node.left ، ڈیٹا) دوسری: node.right = سیلف۔(سیلف۔node.left = self._rotate_left (node.left) خود واپس"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے یا نہیں۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا دیئے گئے تار میں قوسین کی مختلف اقسام پر غور کیا گیا ہے: پائیتھون کوپی کوڈ ڈیف is_valid_parentheses (s): اسٹیک = [] میپنگ = {')': '(' ، '}': '(' ، '،' ،'{' ، ']': '['} چار کے لئے S: اگر میپنگ میں چار چار: اسٹیک.ایپینڈ (چار) الیف چار میپنگ میں۔"
    },
    {
        "Question": "سب سے چھوٹی گمشدہ مثبت عددی تلاش کرنے کے لئے ایک پروگرام لکھیں جو عددی کی دی گئی فہرست میں ظاہر نہیں ہوتا ہے۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں سب سے چھوٹی گمشدہ مثبت عدد تلاش کرنے کے لئے ایک پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈڈیف Find_smallest_missing_positive (Nums): n = len (nums) # مرحلہ 1: فہرست I کے بائیں طرف تمام مثبت انٹیجرز کو منتقل کریں I= 0 جبکہ i <n: اگر 1 <= nums [i] <= n اور nums [nums [i] - 1]! = nums [i]: nums [nums [i] - 1] ، نمبر [i] =nums [i] ، nums [nums [i] - 1] اور: i + = 1 # مرحلہ 2: پہلا انڈیکس تلاش کریں جہاں قیمت in in in range (n) کے لئے انڈیکس + 1 کے برابر نہیں ہے: اگر nums [i]! = i + 1: واپسی I + 1 # اگر 1 سے N کے تمام مثبت عدد موجود ہیں تو ، سب سے چھوٹی چھوٹی چھوٹی مثبت ہے n + 1 ریٹرن n +"
    },
    {
        "Question": "کسی دیئے گئے تار میں زیادہ تر K الگ الگ حروف کے ساتھ سب سے طویل تر اسٹرنگ تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!کسی مخصوص تار میں زیادہ تر K الگ الگ حروف کے ساتھ سب سے طویل عرصہ تلاش کرنے کے لئے ایک پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈڈیف طویل ترین_سبسٹرینگ_ وِٹ_ڈسٹنٹ_چارس (ایس ، کے): این = لین (ایس) اگر K == 0 یا N == 0: واپسی\"\" چار_کاؤنٹ = {} میکس_لن = 0 میکس_ اسٹارٹ = 0 اسٹارٹ = 0 رینج کے اختتام کے لئے (n): # موجودہ کردار کو لغت میں شامل کریں اور اس کی گنتی چار_کاؤنٹ [s [end]] = چار_کاؤنٹ.جیٹ (s [end]، 0) + 1 #"
    },
    {
        "Question": "\"کسی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں ، دوسرے عنصر کے ساتھ پہلے کے بعد ظاہر ہوتا ہے۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جس میں کسی مخصوص فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق پائے جاتے ہیں ، دوسرے عنصر کے ساتھ پہلے کے بعد: پائیتھون کوپی کوڈڈیف Find_max_diference (ARR): اگر لین (ARR) <2: کوئی بھی نہیں MIN_ELEMENT = arr [0] میکس_ ڈفینفرنس = آر آر [1] - ار [0] میں رینج (1 ، لین (اے آر آر)) کے لئے: اگر آر آر [آئی] - من_ایلیمنٹ> زیادہ سے زیادہ_ڈیفینس: زیادہ سے زیادہ_ڈیفینس: میکس_ ڈفینس = آر [i] - من_ایلمنٹ اگر آر آر [i] <منٹ_یلیمنٹ: MIN_ELEMENT = ARR [i] اس عمل کو نفاذ کریں ، ہم MIN_ELEMENT کو فہرست کے پہلے عنصر کے طور پر شروع کرتے ہیں اور دوسرے عنصر اور پہلے عنصر کے مابین فرق کے طور پر MAX_DIFFENCE کو شروع کرتے ہیں۔اس کے بعد ہم دوسرے عنصر سے شروع ہونے والی فہرست میں تکرار کرتے ہیں۔ ہر تکرار ، ہم"
    },
    {
        "Question": "\"ہیش نقشہ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور کلیدی قیمت کے جوڑے داخل کرنے ، بازیافت کرنے اور ان کو ہٹانے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جس میں ہیش کے نقشے کی نمائندگی کی جاتی ہے (جسے لغت یا ایسوسی ایٹیو سرنی بھی کہا جاتا ہے) کے ساتھ کلیدی قدر کی جوڑیوں کو داخل کرنے ، بازیافت کرنے اور ان کو دور کرنے کے طریقوں کے ساتھ: پائیٹون کوپی کوڈکلاس ہیش میپ: ڈیف __init __ (خود): خود۔ سائز = 10# ہیش نقشہ کا ابتدائی سائز سیلف۔ میپ = [[] _ کے لئے رینج (سیلف۔ سائز)] # تصادموں سے نمٹنے کے لئے فہرستوں کی فہرست ڈیف _ گیٹ_ ہش (خود ، کلید): # دیئے گئے کلیدی واپسی ہیش کے لئے ہیش ویلیو کا حساب لگائیں(کلیدی) self خود۔، اگر خود میں جوڑی کے لئے تو قیمت کو اپ ڈیٹ کریں۔"
    },
    {
        "Question": "یہ پروگرام بنائیں کہ آیا دیئے گئے اسٹرنگ ایک درست سوڈوکو حل ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ایک پروگرام یہ ہے کہ آیا کسی دیئے گئے سٹرنگ ایک درست سوڈوکو حل کی نمائندگی کرتی ہے: پائیٹون کوپی کوڈیڈف is_valid_sudoku (بورڈ): # بورڈ میں قطار کے لئے قطاریں چیک کریں: اگر نہیں is_valid_row (قطار): رینج میں کال کالم واپس کریں (9):کالم = [بورڈ [قطار] [کرن] قطار میں قطار کے لئے (9)] اگر نہیں is_valid_row (کالم): رینج (0 ، 9 ، 3) میں قطار کے لئے غلط # چیک سبگریڈز کو واپس کریں (0 ، 9) (0 ، 9)، 3): subgrid = [بورڈ [r] [c] رینج میں R کے لئے (قطار ، قطار + 3) سی کے لئے رینج (کرنل ، کرنل + 3)] اگر نہیں is_valid_row (subgrid): غلط واپسی truedef is_valid_row (واپس کریںقطار): # چیک کریں کہ آیا دی گئی قطار (یا کالم یا سبگریڈ) درست ہے = سیٹ () قطار میں نمبر کے لئے: اگر نمبر! = \"۔# مثال کے استعمال: درست_سولوشن = [[\"5\" ، \"3\" ، \".\" ،"
    },
    {
        "Question": "بلٹ ان افعال کا استعمال کیے بغیر دیئے گئے نمبر کے مربع جڑ کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "بلٹ ان افعال کا استعمال کیے بغیر دیئے گئے نمبر کے مربع جڑ کا حساب لگانے کے ل we ، ہم نیوٹن کے طریقہ کار جیسے تکراری نقطہ نظر کو استعمال کرسکتے ہیں۔ایک مربع روٹ فنکشن کا نفاذ یہاں ہے: پائیٹون کوپی کوڈیڈف اسکوائر_روٹ (نمبر ، صحت سے متعلق = 0.0001): اگر نمبر <0: ویلیو ایرر کو بڑھاؤ (\"منفی نمبر کے مربع روٹ کا حساب نہیں لگا سکتا\") اندازہ = نمبر / 2 # ابتدائی اندازہ کے ساتھ شروع کریں۔جبکہ ABS (اندازہ لگائیں * اندازہ - نمبر)> صحت سے متعلق: اندازہ = (اندازہ + نمبر / اندازہ) / 2 # نیوٹن کے طریقہ کار کا استعمال کرتے ہوئے اندازہ کی تازہ کاری کریں"
    },
    {
        "Question": "دی گئی فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی دی گئی فہرست میں الگ الگ عناصر کی تعداد تلاش کرنے کے ل you ، آپ ایک سیٹ ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔یہاں ایک سادہ پروگرام ہے جو اس کو ظاہر کرتا ہے: پائیتھون کوپی کوڈیڈف COUNT_DISTINCT_ELEMENTS (LST): الگ الگ_لیمنٹس = سیٹ (LST) # نقل کو ہٹانے کے لئے فہرست سے ایک سیٹ بنائیں (الگ الگ عناصر) # واضح عناصر کی گنتی # مثال کے طور پر: نمبر = [[نمبر = [1 ، 2 ، 3 ، 4 ، 4 ، 5 ، 6 ، 6 ، 7 ، 8 ، 8 ، 9] پرنٹ (COUNT_DISTINCT_ELEMENTS (نمبرز)) # آؤٹ پٹ: 8 اس پروگرام میں ، COUNT_DISTINCT_ELEMENTS فنکشن ان پٹ کے طور پر ایک فہرست لیتا ہے۔یہ فہرست سے ایک سیٹ تیار کرتا ہے ، جو خود بخود ڈپلیکیٹ عناصر کو ہٹاتا ہے۔اس کے بعد سیٹ میں عناصر کی تعداد کو الگ الگ عناصر کی گنتی کے طور پر واپس کردیا گیا ہے۔ آپ اس فنکشن کو عناصر کی کسی بھی فہرست کے ساتھ الگ عناصر کی تعداد تلاش کرنے کے لئے استعمال کرسکتے ہیں۔"
    },
    {
        "Question": "ایک ازگر کی کلاس بنائیں جس میں ایک ہدایت شدہ وزن والے گراف کی نمائندگی کی جائے اور ٹوپولوجیکل قسم کو انجام دینے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کی ایک مثال ہے جو ایک ٹوپولوجیکل ترتیب دینے کے طریقوں کے ساتھ ہدایت شدہ وزن والے گراف کی نمائندگی کرتی ہے: پائیٹون کوپی کوڈفرم کلیکشن درآمد ڈیفالٹ ڈکٹکلاس گراف: ڈیف __init __ (خود): سیلف ڈاٹ گراف = ڈیفالٹ ڈکٹ (فہرست) ڈیف ایڈ_ج (خود ، یو ، وی ، وی ، وی ، وی ، وی ، خود ، یو ، وی ،وزن): سیلف گراف [u] .append ((v ، وزن)) Def topological_sort_util (خود ، v ، ملاحظہ کیا گیا ، اسٹیک): ملاحظہ کیا [v] = پڑوسی کے لئے سچ ، _ سیلف گراف [v]: اگر نہیں تو نہیںملاحظہ [پڑوسی]: سیلف۔ ٹوپولوجیکل_سورٹ_ٹیل (پڑوسی ، ملاحظہ کیا گیا ، اسٹیک) اسٹیک۔ انرٹ (0 ، وی) ڈیف ٹاپولوجیکل_سورٹ (خود): ملاحظہ کریں = ڈیفالٹ ڈکٹ (بول) اسٹیک = [] سیلف گراف میں: اگر نہیں ملاحظہ کیا گیا تو [اگر نہیں ملاحظہ کیا گیا تو [ورٹیکس]: سیلف ٹوپولوجیکل_سورٹ_ٹیل (ورٹیکس ، ملاحظہ کیا ، اسٹیک) ریٹرن اسٹیک# مثال کے استعمال: جی"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین کے ساتھ ایک درست اظہار ہے یا نہیں۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا ایک مثال عمل ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار متوازن قوسین کے ساتھ ایک درست اظہار ہے: پائیتھون کوپی کوڈڈیف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_براکیٹس = {'(' ، '،' ، '{'} کلوزنگ_برکیٹس = {')' ، ']' ، '}'} بریکٹ_پیئرز = {'(': ')' ، '[': ']' ، '{': '}': '}'} اظہار میں چار کے لئے: اگر اوپننگ_ بریکٹ میں چار: اسٹیک.append (CHAR) الیف چار کو بند کرنے کا سلسلہ: اگر اسٹیک نہیں ہے تو: جھوٹی ٹاپ = اسٹیک ۔پوپ () اگر بریکٹ_پیئرز [اوپر]! = چار: غلط ریٹرن لین (اسٹیک) == 0# مثال کے استعمال: اظہار 1 = \"(a + b) * (c - d)) \"اظہار 2 =\" ((a + b) * (c - d)} \"اظہار 3 =\" (a + b) * (c - d)) \"اظہار 4 =\" {۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!عدد کی ایک دی گئی فہرست میں غیر ایڈجسٹ عناصر کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے یہاں ایک مثال کا پروگرام ہے: پائیتھون کوپی کوڈڈیف میکس_سوم_نون_اڈجینٹ (نمبر): اگر نمبر نہیں تو: واپس 0 n = لین (نمبر) اگر n == 1: واپسی نمبر [0 واپس کریں [0] # پچھلے عنصر پر زیادہ سے زیادہ رقم پر نظر رکھنے کے لئے دو متغیرات کی ابتدا کریں اور پچھلے عنصر پر غور کرنے کے بغیر # پچھلے عنصر پر غور کریں۔رینج (2 ، این): # موجودہ عنصر # اور زیادہ سے زیادہ رقم پر غور کرکے زیادہ سے زیادہ رقم کا حساب لگائیں بغیر پچھلے عنصر کی ٹیمپ = زیادہ سے زیادہ (curr_max_sum ، prev_max_sum + nums [i])= curr_max_sum curr_max_sum = عارضی # آخری دو رقم کی زیادہ سے زیادہ واپسی"
    },
    {
        "Question": "کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک سٹرنگ تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے لئے کسی فنکشن کا ایک مثال عمل ہے: پائیٹون کوپی کوڈیڈف طویل ترین_پالینڈرووم (ایس): اگر نہیں تو: واپسی \"\" این = لین (ایس) اسٹارٹ ، اختتام = 0 ، 0 کے لئے I کے لئے رینج میں (n): len1 = expense_from_center (s ، i ، i) # عجیب لمبائی کے لئے palindromes len2 = approx_from_center (s ، i ، i + 1) # یہاں تک کہ لمبائی پیلنڈروومس میکس_لن = زیادہ سے زیادہ (LEN1 ، LEN2) اگر زیادہ سے زیادہ_لین> اختتام-ختم-اسٹارٹ + 1: اسٹارٹ = i - (میکس_لن - 1) // 2 اختتام = i + میکس_لن // 2 ریٹرن ایس [اسٹارٹ: اینڈ + 1] ڈیف ایکسپینشن_فرم_ سینٹر (ایس ، بائیں ، دائیں): جبکہ بائیں> = 0 اور دائیں<len (s) اور s [بائیں] == s [دائیں]: بائیں -= 1"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ کم سے کم حرفوں کی کم سے کم تعداد کو کسی تار سے نکال دیا جاسکے تاکہ اسے پیلنڈرو کر دیا جاسکے۔",
        "Answer": "اس کو ایک پیلنڈرووم بنانے کے ل a کسی تار سے ہٹانے کے لئے کم سے کم حروف کی تعداد تلاش کرنے کے ل you ، آپ اس مسئلے کو موثر انداز میں حل کرنے کے لئے متحرک پروگرامنگ استعمال کرسکتے ہیں۔یہاں ایک مثال عمل ہے: پائیٹون کوپی کوڈڈف من_چارس_ ریمووڈ (ایس): اگر نہیں تو: واپس 0 n = لین (s) dp = [[0] * n _ _ کے لئے _ _ میں حد (n)] میں (n - 1 ، -"
    },
    {
        "Question": "بائنری میکس ہیپ کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور زیادہ سے زیادہ عنصر کو داخل کرنے اور نکالنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو بائنری میکس ہیپ کی نمائندگی کرتا ہے جس میں زیادہ سے زیادہ عنصر داخل کرنے اور نکالنے کے طریقوں کے ساتھ ہوتا ہے: پیتھون کوپی کوڈکلاس میکس ہیپ: ڈیف __init __ (خود): سیلف ۔ہپ = [] ڈیف داخل کریں (خود ، قیمت): سیلف۔ ہیپ.append (قدر) سیلف۔"
    },
    {
        "Question": "کسی فہرست میں پہلا دہرانے والے عنصر کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جو کسی دیئے گئے فہرست میں پہلا دہرانے والا عنصر تلاش کرتا ہے: پائیتھون کوپی کوڈڈیف Find_first_repeating_element (نمبر): nums میں نمبر کے لئے دیکھا = سیٹ ()فنکشن ان پٹ کے طور پر ایک فہرست نمبر لیتا ہے اور اب تک کا سامنا کرنے والے عناصر کو ٹریک رکھنے کے لئے ایک سیٹ کا استعمال کرتا ہے۔یہ فہرست میں ہر عنصر کے ذریعے تکرار کرتا ہے اور چیک کرتا ہے کہ آیا عنصر سیٹ میں پہلے سے موجود ہے۔اگر یہ ہے تو ، پھر یہ پہلا دہرانے والا عنصر ہے اور واپس آگیا ہے۔اگر نہیں تو ، اسے سیٹ میں شامل کیا جاتا ہے۔اگر کوئی دہرانے والا عنصر نہیں پایا جاتا ہے تو ، فنکشن کوئی بھی نہیں لوٹاتا ہے۔ یہاں Find_first_repeating_element فنکشن کی ایک مثال استعمال ہے: پائیتھون کوپی کوڈینومز = [2 ، 3 ، 4 ، 5 ، 2 ، 6 ، 7 ، 4] نتیجہ = find_first_repeating_element (نمبر) پرنٹ"
    },
    {
        "Question": "دو ڈوروں کے مابین سب سے طویل عام مشترکہ حصول کی لمبائی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک ایسے پروگرام کا نفاذ ہے جس میں متحرک پروگرامنگ کا استعمال کرتے ہوئے دو تاروں کے مابین طویل ترین مشترکہ حصول کی لمبائی تلاش کی جاتی ہے: پائیتھون کوپی کوڈ ڈیف طویل ترین_کومون_سوبسینس_لنتھ (str1 ، str2): ایم = لین (str1) n = لین (str2) # اسٹور کرنے کے لئے ایک ٹیبل بنائیں۔لمبائی کی لمبائی dp = [[0] * (n + 1) _ کے لئے _ کے لئے (m + 1)] # رینج (1 ، m + 1) کے لئے سب سے طویل عام مشترکہ کی لمبائی کی گنتی کریں (1 ، m + 1)حد (1 ، n + 1): اگر str1 [i - 1] == str2 [j - 1]: dp [i] [j] = dp [i - 1] [j - 1] + 1 اور: dp [i] [j] = زیادہ سے زیادہ (dp [i - 1] [j] ، dp [i] [j - 1]) # سب سے طویل عام مشترکہ اجتماعی واپسی کی لمبائی DP [m] [n] `طویل ترین_کومون"
    },
    {
        "Question": "فہرست سے تمام ڈپلیکیٹ عناصر کو ہٹانے اور اصل ترتیب کو برقرار رکھنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں ایک ایسے پروگرام کا نفاذ ہے جو اصل ترتیب کو برقرار رکھتے ہوئے تمام ڈپلیکیٹ عناصر کو فہرست سے ہٹاتا ہے: پائیتھون کوپی کوڈ ڈیف ہٹ_ ڈوپلیکیٹس (ایل ایس ٹی): دیکھا = سیٹ () نتیجہ = [] ایل ایس ٹی میں آئٹم کے لئے: اگر آئٹم نہیں دیکھا گیا: دیکھا گیا۔(آئٹم)"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے اسٹرنگ مختلف قسم کے قوسین کے ساتھ ایک درست قوسین کا اظہار ہے یا نہیں ، آپ اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔فنکشن کا ایک نفاذ یہاں ہے: پائیٹون کوپی کوڈڈف is_valid_palenthesis (اظہار): اسٹیک = [] افتتاحی = سیٹ (['' ، '،' ['،' {']) بند = سیٹ ([') '،'] '،'} ']) جوڑے = {') ':' ('،'] ':' ['،'} ':' {'} اظہار کے لئے چار کے لئے: اگر اوپننگ میں چار: اسٹیک.اپینڈ (چار) ایلف چار اناختتامی: اگر لین (اسٹیک) == 0 یا اسٹیک [-1]! = جوڑے [چار]: غلط اسٹیک۔ پاپ () واپس لین (اسٹیک) واپساسٹیک ، اوپننگ سیٹ جس میں افتتاحی قوسین پر مشتمل ہے ، اختتامی سیٹ پر مشتمل سیٹ ، اور ایک لغت کے جوڑے جو ان کے متعلقہ افتتاحی قوسین کو بند کرنے والے قوسین کا نقشہ بناتے ہیں۔ اس کے بعد فنکشن۔"
    },
    {
        "Question": "سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور سامنے والے عنصر کو ہٹائے بغیر اسے حاصل کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو سرکلر قطار کی نمائندگی کرتی ہے جس کے بغیر کسی طریقہ کار کو ختم کرنے کے بغیر کسی سرکلر قطار کی نمائندگی ہوتی ہے: پائیتھون کوپی کوڈکلاس سرکلر کیوئو: ڈیف __init __ (خود ، صلاحیت): خود کی صلاحیت = صلاحیت خود = [کوئی نہیں] * صلاحیت سیلف۔ فرنٹ =-1 self.reare = -1 def is_empty (self): واپسی سیل۔آئٹم): اگر self.is_full (): پرنٹ (\"قطار بھری ہوئی ہے۔ آئٹم کو ختم کرنے سے قاصر۔.REAR + 1) ٪ self.capacity self.queue [self.reare] = آئٹم ڈیف ڈی کیوئو (خود): اگر sell. کیوئو [سیلف۔ فرنٹ] اگر sell"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں غیر خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں غیر خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام یہ ہے: پائیٹون کوپی کوڈڈیف میکس_سوبری_سم (اے آر آر): اگر نہیں آر آر: واپس 0 کرنٹ_سم = میکس_سم = آر آر [0] ارٹ میں نمبر کے لئے [1:]: کرنٹ_سم = زیادہ سے زیادہ (NUM ، موجودہ_سم + نمبر) زیادہ سے زیادہ_سم = زیادہ سے زیادہ (زیادہ سے زیادہ_سم ، کرنٹ_سم) میکس_سومٹے میکس_سوبری_سم فنکشن انٹیجرز کی فہرست لیتا ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دی گئی تعداد ایک بہترین نمبر ہے یا نہیں۔",
        "Answer": "یقینا!ایک کامل نمبر ایک مثبت عدد ہے جو اس کے مناسب تفریقوں کے جوڑے کے برابر ہے (خود کو چھوڑ کر)۔یہاں ایک فنکشن یہ ہے کہ آیا ایک دیئے گئے نمبر ایک کامل نمبر ہے یا نہیں: پائیتھون کوپی کوڈیڈف is_perfect_number (num): اگر num <= 0: غلط ڈویژن_سم = رقم واپس کریں ([رینج میں تقسیم کے لئے تقسیم (1 ، نمبر) اگر num ٪ divisor ==0]) واپسی divisor_sum == numthe is_perfect_number فنکشن ان پٹ کے طور پر ایک عدد نمبر لیتا ہے اور اگر سچ ہوتا ہے اگر"
    },
    {
        "Question": "کسی دی گئی فہرست میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے فہرست میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام یہ ہے: پائیتھون کوپی کوڈیڈف Find_kth_largest (نمبر ، کے): اگر K <1 یا K> LEN (نمبر): کسی بھی فہرست کو نزول ترتیب نمبر میں ترتیب دیں۔سچ) نمبر [K - 1] find_kth_larget فنکشن نمبر نمبروں اور ایک انٹیجر K کی فہرست لیتا ہے اور ان پٹ کے طور پر ایک انٹیجر K کی فہرست سے کے ٹی ایچ کے سب سے بڑے عنصر کو لوٹاتا ہے۔اگر K غلط ہے (فہرست کی لمبائی سے 1 یا اس سے کم سے کم) ، تو فنکشن کوئی بھی نہیں لوٹاتا ہے۔ الگورتھم مندرجہ ذیل کام کرتا ہے: پہلے ، ہم چیک کرتے ہیں کہ کیا K فہرست کی حد میں ایک درست انڈیکس ہے یا نہیں۔اگر"
    },
    {
        "Question": "ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور الفاظ کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!الفاظ داخل کرنے اور الفاظ کی تلاش کے طریقوں کے ساتھ ازگر میں ایک ٹری (پریفکس ٹری) کلاس کا نفاذ یہاں ہے: پیتھون کوپی کوڈکلاس ٹرائینوڈ: ڈیف __Init __ (خود): سیلف۔ چائلڈین = {{} سیلف۔): self.root = trienode () Def داخل کریں (خود ، لفظ): لفظ میں چار کے لئے نوڈ = سیلف۔[چار] نوڈ.IS_END_OF_WORD = حقیقی ڈیف سرچ (خود ، لفظ): نوڈ = سیلف۔ لفظ میں چار کے لئے۔ٹری میں ایک نوڈ کی نمائندگی کرتا ہے۔اس میں بچوں کو نوڈس اور ایک بولین is_end_of_word کو ذخیرہ کرنے کے ل a ایک لغت کے بچے شامل ہیں اگر اس بات کی نشاندہی کریں کہ اگر نوڈ کسی لفظ کے اختتام کی نمائندگی کرتا ہے۔ ٹری کلاس مرکزی طبقہ ہے جو ٹری ڈیٹا ڈھانچے کی نمائندگی کرتا ہے۔اس میں ایک مثال متغیر جڑ ہے جو اشارہ کرتی ہے"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین اور بریکٹ کے ساتھ ایک درست اظہار ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ازگر میں ایک فنکشن کا نفاذ یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے اسٹرنگ متوازن قوسین اور بریکٹ کے ساتھ ایک درست اظہار ہے: پائیتھون کوپی کوڈیڈف آئی ایس_والیڈ_ ایکسپریشن (ایس): اسٹیک = [] اوپننگ_برکیٹس = ['(' ، '،' '] کلوزنگ_بریکٹ = [[' ') '،'] '] مماثل_برکیٹس = {' (':') '،' [':'] '} چار میں چار کے لئے: اگر اوپننگ_بریکٹ میں چار: اسٹیک.اپینڈ (چار) الیف چار میں بند_بریکٹ: اگر اسٹیک نہیں ہے تویا مماثل_برکیٹس [اسٹیک.پپ ()]! = چار: غلط ریٹرن لین (اسٹیک) == 0 IS_Valid_expression فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور چیک کرتا ہے اگر یہ متوازن قوسین اور بریکٹ کے ساتھ ایک درست اظہار ہے۔یہ اب تک کا سامنا کرنے والے ابتدائی بریکٹوں کو ٹریک رکھنے کے لئے اسٹیک ڈیٹا ڈھانچے کا استعمال کرتا ہے۔تار کے ہر کردار کے ل it ، یہ مندرجہ ذیل اعمال انجام دیتا ہے: اگر کردار افتتاحی بریکٹ ('(' یا '[')) ہے تو ، اسے اسٹیک میں شامل کیا جاتا ہے۔ اگر کردار ایک اختتامی بریکٹ (')' یا 'ہے'۔] '') ، یہ چیک کرتا ہے کہ آیا اسٹیک خالی ہے یا اگر اس کے لئے اسی افتتاحی بریکٹ"
    },
    {
        "Question": "دی گئی فہرست میں تین عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے فہرست میں تین عدد کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے ازگر میں ایک پروگرام کا نفاذ ہے: پائیٹون کوپی کوڈڈیف زیادہ سے زیادہ_ پروڈکٹ_ف_تھار (نمبرز): نمبرز.سورٹ () این = لین (نمبر) # دو منفی نمبر اور ایک مثبت تعداد حاصل کرسکتی ہے۔زیادہ سے زیادہ مصنوعات کا آپشن 1 = نمبر [0] * نمبر [1] * نمبر [n - 1] # تین مثبت تعداد میں زیادہ سے زیادہ مصنوعات کا اختیار حاصل ہوتا ہے 2 = nums [n - 3] * نمبر [n - 2] * نمبر [n - 1]میکس ریٹرن میکس (آپشن 1 ، آپشن 2) زیادہ سے زیادہ_ پروڈکٹ_ف_تھری فنکشن ان پٹ کے طور پر انٹیجر نمبروں کی ایک فہرست لیتا ہے اور فہرست سے تین عدد کی زیادہ سے زیادہ مصنوعات تلاش کرتا ہے۔یہ اوپر کی ترتیب میں فہرست کو چھانٹ کر شروع کرتا ہے۔اس کے بعد ، یہ دو ممکنہ اختیارات پر غور کرتا ہے: آپشن 1: آخری نمبر (سب سے بڑے) کے ساتھ پہلے دو نمبر (سب سے چھوٹے) کو ضرب دینا۔اس معاملے میں اس وقت ہوتا ہے جب زیادہ سے زیادہ مصنوعات میں دو منفی تعداد اور ایک مثبت نمبر شامل ہوتا ہے۔ اوپشن 2: آخری تین نمبروں (سب سے بڑے) کو ضرب دینا۔اس معاملے میں اس کا محاسبہ ہوتا ہے جب زیادہ سے زیادہ مصنوعات میں تین مثبت شامل ہوتے ہیں"
    },
    {
        "Question": "الگ الگ انٹیجرز کی دی گئی فہرست کی ہر ممکنہ اجازت نامے تیار کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!تکرار کا استعمال کرتے ہوئے الگ الگ عدد کی مخصوص فہرست کی ہر ممکنہ اجازت نامے تیار کرنے کے لئے ازگر میں ایک پروگرام کا نفاذ ہے: پائیتھون کوپی کوڈیڈف پرمٹیشن (نمبر): نتیجہ = [] جنریٹ_پرمیٹیشن (نمبر ، [[] ، نتیجہ) واپسی کے نتیجے میں جنریٹ ڈف جنریٹ_پرموٹیشن (موجودہ_پرموٹیشن (کرنٹ_پرموٹیشن، نتیجہ: اگر نہیں نمبر: نتیجہ۔.یہ اجازت نامے کو ذخیرہ کرنے کے لئے خالی فہرست کے نتائج کی ابتدا کرتا ہے۔اس کے بعد ، یہ ابتدائی پرمٹیشن کرنٹ_پرموٹیشن کے ساتھ ایک خالی فہرست کے طور پر جنریٹ_پرموٹیشن فنکشن کو کال کرتا ہے۔ جنریٹ_پرموٹیشن فنکشن ایک مددگار فنکشن ہے جو ہر ممکن ترتیب کو پیدا کرنے کے لئے تکرار کا استعمال کرتا ہے۔اس میں تین پیرامیٹرز لگتے ہیں: نمبر ، باقی نمبروں کو اجازت دینے کے لئے۔موجودہ_پرموٹیشن ، موجودہ اجازت نامہ تیار کیا جارہا ہے۔اور"
    },
    {
        "Question": "دو نمبروں کے جی سی ڈی (سب سے بڑے عام تقسیم کار) کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں یوکلیڈین الگورتھم کا استعمال کرتے ہوئے دو نمبروں کے سب سے بڑے عام ڈویژن (جی سی ڈی) کا حساب لگانے کے لئے یہاں ایک فنکشن کا نفاذ ہے: پائیٹون کوپی کوڈیڈف جی سی ڈی (اے ، بی): جبکہ بی! = 0: اے ، بی = بی ، اے ٪ بی ریٹرنATH GCD فنکشن دو نمبر A اور B لیتا ہے جیسے ان پٹ کے طور پر اور یوکلیڈین الگورتھم کا استعمال کرتے ہوئے ان کے GCD کا حساب لگاتا ہے۔الگورتھم بار بار A کو B کے ذریعہ تقسیم کرتا ہے اور باقی کو A کو تفویض کرتا ہے ، اور B کی اصل قیمت B کو تفویض کرتا ہے۔یہ عمل اس وقت تک جاری رہتا ہے جب تک کہ بی صفر نہ ہوجائے ، اس مقام پر اصل A کا جی سی ڈی ہوگا اور بی۔ ہر کی جی سی ڈی فنکشن کا ایک مثال استعمال ہوگا: پائیٹون کوپی کوڈینم 1 = 36num2 = 48 پرنٹ (جی سی ڈی (نمبر 1 ، نمبر 2)) # آؤٹ پٹ: 12 اناس مثال کے طور پر ، ہم نمبروں کے ساتھ جی سی ڈی فنکشن کو کہتے ہیں"
    },
    {
        "Question": "\"ایک ہیش سیٹ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور داخل کرنے ، ہٹانے اور جانچنے کے طریقوں کو نافذ کریں کہ آیا عنصر موجود ہے یا نہیں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو ہیش سیٹ کی نمائندگی کرتا ہے جس میں داخل ، ہٹانے اور چیک کریں کہ آیا عنصر موجود ہے یا نہیں: پیتھون کوپی کوڈکلاس ہیشسیٹ: ڈیف __init __ (خود): خود کی گنجائش = 16 خود۔[] رینج میں _ کے لئے (سیلف۔ کیپسٹی)] ڈیف داخل کریں (خود ، قدر): Bucket_index = self._hash (قدر) بالٹی = سیلف. بوکیٹس [Bucket_index] I کے لئے ، آئٹم (بالٹی): اگر آئٹم ==قدر: واپس بکٹی۔ اپینڈ (قدر) سیلف۔ سائز += 1 اگر خود۔self.buckets [Bucket_index] I کے لئے ، آئٹم میں آئٹم (بالٹی): اگر آئٹم == ویلیو: ڈیل بالٹی [i] سیلف۔ سائز -= 1 ریٹرن ڈیف پر مشتمل ہوتا ہے (خود ، قدر)بالٹی = سیلف بوکیٹس [بالٹی_ انڈیکس] بالٹی ڈیف _ ہش (خود ، قدر) میں واپسی کی قیمت:"
    },
    {
        "Question": "\"اوپر بائیں کونے سے گرڈ کے نیچے دائیں کونے تک راستوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، صرف دائیں یا نیچے منتقل ہو۔\"",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جو گرڈ کے نیچے دائیں کونے سے لے کر گرڈ کے نیچے دائیں کونے تک کے راستوں کی تعداد کا حساب لگاتا ہے ، صرف دائیں یا نیچے منتقل ہوتا ہے: پائیٹون کوپی کوڈیڈف کاؤنٹ_پاتھ (گرڈ): اگر گرڈ نہیں ہے یا گرڈ نہیں ہے [0]قطاریں = لین (گرڈ) COLS = لین (گرڈ [0]) # راستوں کی تعداد کو ذخیرہ کرنے کے لئے 2D سرنی کو شروع کریں = [[0] * رینج (قطار) میں _ کے لئے کالس] # پہنچنے کے لئے صرف ایک ہی راستہ ہےرینج (قطار) میں I کے لئے پہلی قطار یا کالم میں کوئی بھی سیل: راستے [i] [0] = 1 J کے لئے رینج (COLs): راستے [0] [j] = 1 # ہر ایک کے لئے راستوں کی تعداد کا حساب لگائیںرینج (1 ، قطاریں) میں I کے لئے سیل: رینج (1 ، COLs) کے لئے: راستے [i] [j] = راستے [i-1] [j] + راستے [i] [J-1] # واپسینیچے دائیں کونے تک پہنچنے کے لئے راستوں کی تعداد"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جو چیک کرتا ہے کہ اگر کسی دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے: پائیتھون کوپی کوڈیڈف آئی ایس_والیڈ_ ایکسپریشن (اظہار): اسٹیک = [] میپنگ = {')' ('،' ، ']]':' ['،'} ':' {'} اظہار کے لئے چار کے لئے: اگر چار ان [' ('،' ['،' ، '{']: اسٹیک.ایپینڈ (چار) الیف چار میں [')' ،']' ، '}']: اگر اسٹیک یا اسٹیک نہیں ہے [-1]! = میپنگ [چار]: غلط اسٹیک واپس کریں۔ پاپ () واپس لین (اسٹیک) ==="
    },
    {
        "Question": "لکیری وقت میں نمبروں کی فہرست کا اوسط تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "لکیری وقت میں نمبروں کی فہرست کے درمیانی حصے کو تلاش کرنے کے ل we ، ہم کوئیک سلیکٹ الگورتھم استعمال کرسکتے ہیں۔کوئیک سلیکٹ الگورتھم کوئکسورٹ الگورتھم کی ایک تغیر ہے جو ہمیں اوسطا لکیری وقت میں ایک فہرست میں کے ٹی ایچ کے سب سے چھوٹے عنصر کو تلاش کرنے کی اجازت دیتا ہے۔ یہاں ایک ایسے فنکشن کا نفاذ ہے جس میں لکیری وقت میں نمبروں کی فہرست کا درمیانی حصہ مل جاتا ہے: پائیٹون کوپی کوڈیمپورٹ رینڈم ڈفfind_median (nums): اگر نہیں nums: کوئی بھی Dif پارٹیشن (Nums ، کم ، اونچائی) واپس نہیں: Pivot_index = randint.randint (کم ، اعلی) پائیوٹ = nums [pivot_index] نمبر [pivot_index] ، nums [اعلی] = نمبر [اعلی [اعلی]] ، نمبر [Pivot_index] i = J کے لئے کم (کم ، اونچائی): اگر نمبر [j] <Pivot: nums [i] ، nums [j] = nums [j] ، nums [i] i += 1نمبر [i] ، نمبر [اعلی] = نمبر [اعلی] ، نمبر [i] واپسی I def quickelect (nums ، کم ، اونچائی ، k): اگر کم == اعلی: واپسی نمبر [کم] Pivot_index = پارٹیشن"
    },
    {
        "Question": "بائنری سرچ ٹری کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور نوڈ کو حذف کرنے اور کے ٹی ایچ ٹی کا سب سے چھوٹا عنصر تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!نوڈ کو حذف کرنے اور KTH کا سب سے چھوٹا عنصر تلاش کرنے کے طریقوں کے ساتھ بائنری سرچ ٹری (بی ایس ٹی) کی نمائندگی کرنے والی ایک ازگر کلاس کا نفاذ ہے: پیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل)self.right = Noneclass Bst: def __init __ (خود): self.root = کوئی بھی Def داخل نہیں (خود ، ویل): اگر سیلف نہیں ہے۔ویل) ڈیف _ Insert_recursive (خود ، نوڈ ، ویل): اگر ویل <نوڈ.ول: اگر نہیں node.left: node.left = treenod. رائٹ: نوڈ۔ رائٹ = ٹرینوڈ (ویل) اور: سیلف۔"
    },
    {
        "Question": "عددیوں کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے ایک فنکشن کا نفاذ ہے: پائیٹون کوپی کوڈڈیف Find_longest_increasing_subsecence (Nums): n = len (nums) اگر n == 0: واپسی [] # لمبائی کو ذخیرہ کرنے کے لئے ایک صف شروع کریںسب سے طویل عرصہ تک بڑھتی ہوئی متناسب DP = [1] * n # پچھلے عناصر کے اشاریوں کو ماضی میں پریفنس میں شامل کرنے کے لئے ایک صف کی ابتدا کریں = [-1] * n # ان پٹ لسٹ میں رینج (1 ، این) کے لئے تکرار کریں:رینج (i) میں جے کے لئے: اگر نمبر [i]> نمبر [j] اور dp [i] <dp [j] + 1: dp [i] = dp [j] + 1 prep [i] = j # تلاش کریںزیادہ سے زیادہ لمبائی کا انڈیکس میکس_لین_یڈکس = 0 میں I کے لئے (1 ، این): اگر ڈی پی [i]> ڈی پی [میکس_لین_ آئی ڈی ایکس]: میکس_لین_ آئی ڈی ایکس = i # سب سے طویل عرصے تک بڑھتی ہوئی بڑھتی ہوئی متضاد لیز = [] کرن_یڈ ایکس = میکس_لین_ آئی ڈی ایکس جبکہ کرن_یڈکس!= -1: lis.append (nums [curr_idx]) curr_idx = prev [curr_idx] # صحیح آرڈر حاصل کرنے کے لئے متضاد کو الٹ دیں۔"
    },
    {
        "Question": "تکرار کا استعمال کرتے ہوئے دیئے گئے غیر منفی عددی کے حقیقت کا حساب لگانے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جو تکرار کا استعمال کرتے ہوئے دیئے گئے غیر منفی عددی کے حقیقت کا حساب لگاتا ہے: پائیٹون کوپی کوڈیڈف فیکٹریئل (این): # بیس کیس: 0 یا 1 کا حقیقت 1 ہے اگر n == 0 یا n == 1: واپس 1 # recursiveمعاملہ: ن کی حقیقت پسندی (N-1) ریٹرن این * فیکٹوریئل (N-1) کے حقیقت سے بڑھ جاتی ہے اس کی ایک مثال یہ ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیٹون کوپی کوڈن = 5result = فیکٹوریل (n) پرنٹ (f \"فیکٹوریال)کا {n} ہے {نتیجہ} \") # آؤٹ پٹ: 5 کی حقیقت پسندی 120in ہے اس مثال کے طور پر ، فنکشن فیکٹوریل ایک غیر منفی عددی n لیتا ہے"
    },
    {
        "Question": "\"2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں '1' زمین کی نمائندگی کرتا ہے اور '0' پانی کی نمائندگی کرتا ہے۔\"",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جس میں 2D گرڈ میں جزیروں کی تعداد کو گہرائی سے پہلے تلاش (ڈی ایف ایس) کا استعمال کرتے ہوئے مل گیا ہے: پائیٹون کوپی کوڈیڈف نمیس لینڈز (گرڈ): اگر گرڈ نہیں ہے تو: واپس 0 قطار = لین (گرڈ) کولس = لین (گرڈ [0])گنتی = 0 ڈیف ڈی ایف ایس (قطار ، کرنل): اگر قطار <0 یا قطار> = قطاریں یا کول <0 یا کول> = کولس یا گرڈ [قطار] [کرن]! = '1': گرڈ لوٹ کر [قطار] [کرنل] = '0' ڈی ایف ایس (قطار+1 ، کرنل) ڈی ایف ایس (قطار -1 ، کرنل) ڈی ایف ایس (قطار ، کرنل+1) ڈی ایف ایس (قطار ، کرنل 1) میں رینج (قطاروں) کے لئے (قطار) (قطار): رینج میں جے کے لئے (COLS): اگر گرڈ [i] [j] == '1': گنتی += 1 ڈی ایف ایس (i ، j) کونسل کی ایک مثال واپس کریں کہ فنکشن کو کس طرح استعمال کیا جائے: پائیٹون کوپی کوڈگریڈ = [['1' ، '1'، '0' ، '0' ، '0'] ، ['1' ، '1' ، '0' ، '0' ، '0'] ، ['0' ، '0' ، '1' ، '0 '،' 0 '] ،"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی اور قیمت درج کرنے کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، اور قیمت درج کرنے کے ساتھ ایک درست اظہار ہے ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔ازگر میں ایک عمل یہ ہے: پائیتھون کوپی کوڈیڈف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_براکیٹس = \"([{\" بند_برکیٹس = \")]}\" کوئٹ_چارس = \"'\\\" \"اظہار کے لئے چار کے لئے: اگر اوپننگ_بریکٹ میں چار: اسٹیک۔بند (چار) الیف چار کو بند کرنے والے_ برکیٹس میں: اگر اسٹیک یا اوپننگ_برکیٹس نہیں۔ انڈیکس (اسٹیک.پپ ())!چار: اسٹیک.اپینڈ (چار) اور: اسٹیک.پپ () ریٹرن لین (اسٹیک) == 0 اس کی ایک مثال ہے کہ فنکشن کو کس طرح استعمال کیا جائے: پائیٹون کوپی کوڈیکسپریشن = \"(3 + 5) * [2 - 4]\" نتیجہ =is_valid_expression (اظہار) پرنٹ (f \"اظہار درست ہے: {نتیجہ}\") # آؤٹ پٹ: اظہار درست ہے: trueinvalid_expression = \"{(2 + 3) * \\\" ہیلو \\ \"}\" نتیجہ"
    },
    {
        "Question": "ایک اسٹیک کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور مستقل وقت میں کم سے کم عنصر تلاش کرنے کے لئے طریقوں کو نافذ کریں اور لوگرتھمک وقت میں زیادہ سے زیادہ عنصر کو بازیافت کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو مستقل وقت میں کم سے کم عنصر تلاش کرنے اور لوگرتھمک وقت میں زیادہ سے زیادہ عنصر کو بازیافت کرنے کے طریقوں کے ساتھ اسٹیک کی نمائندگی کرتی ہے: پیتھون کوپی کوڈکلاس اسٹیک: ڈیف __init __ (خود): سیلف۔ اسٹیک = [] سیلف.مین_ اسٹیک = [] خود۔میکس_ اسٹیک = [] ڈیف پش (خود ، قدر): سیلف ڈاٹ اسٹیک.ایپینڈ (قدر) اگر سیلف نہیں ہے۔یا ویلیو> = سیلف۔ میکس_ اسٹیک [-1]: سیلف۔میکس_ اسٹیک۔ اے پی پیینڈ (ویلیو) ڈیف پاپ (خود): اگر خود نہیں ہے۔ اسٹیک: کوئی بھی نہیں۔.اسٹیک [-1] ڈیف get_min (خود): اگر خود نہیں۔ min_stack: کوئی بھی واپس نہیں لوٹ کر خود واپس کریں۔اسٹیک کلاس کو کس طرح استعمال کرنے کی ایک مثال: پائیٹون کوپی کوڈ اسٹیک = اسٹیک () اسٹیک۔ پش ("
    },
    {
        "Question": "مختلف سائز کی دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "مختلف سائز کی دو ترتیب شدہ صفوں کے میڈین کو تلاش کرنے کے ل you ، آپ دونوں صفوں کو ایک ہی ترتیب شدہ صف میں ضم کرسکتے ہیں اور پھر ضم شدہ صف کی لمبائی کی بنیاد پر میڈین کا حساب لگاسکتے ہیں۔یہاں ایک ازگر پروگرام ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھون کوپی کوڈیڈف Find_median (nums1 ، nums2): ضم شدہ = انضمام_سورٹڈ_ریز (Nums1 ، nums2) لمبائی = لین (ضم شدہ) اگر لمبائی ٪ 2 == 0: درمیانی = لمبائی // 2 ریٹرن (ضم شدہ [مل گیا [ضموسط 1] + ضم شدہ [وسط]) / 2 اور: درمیانی = لمبائی // 2 واپسی ضم شدہ [وسط] ڈیف انضمام_سورٹ_ریز (نمبر 1 ، نمبر 2): ضم شدہ = [] i = j = 0 جبکہ میں <لین (نمبر 1) اورj <len (nums2): اگر nums1 [i] <nums2 [j]: ضم شدہ۔ append (nums1 [i]) i += 1 اور: ضم شدہ۔ append (nums2 [j]) j += 1 جبکہ میں <لین <."
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دیئے گئے نمبر ایک نرگسسٹک نمبر ہے۔",
        "Answer": "ایک منشیات کی تعداد ، جسے آرمسٹرونگ نمبر بھی کہا جاتا ہے ، ایک ایسی تعداد ہے جو ہندسوں کی تعداد کی طاقت کے لئے اٹھائے جانے والے اپنے ہندسوں کے جوہر کے برابر ہے۔مثال کے طور پر ، 153 ایک نرگسسٹک تعداد ہے کیونکہ 1^3 + 5^3 + 3^3 = 153. یہاں ایک ازگر کا فنکشن ہے جو چیک کرتا ہے کہ اگر کسی دیئے گئے نمبر کی نشہ آور نمبر ہے: پائیتھون کوپی کوڈ ڈیف is_narcissist_number (num): num_str = str (num_str = str (num_str = str (num_str = str (num)) num_digits = len (num_str) sum_of_powers = sum (int (ہندسہ) ** num_str میں ہندسے کے لئے num_digits) واپسی"
    },
    {
        "Question": "\"ایک پروگرام لکھیں تاکہ اوپر کے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک کے راستوں کی تعداد تلاش کی جاسکے ، صرف دائیں ، نیچے یا اخترن میں منتقل ہو۔\"",
        "Answer": "اوپر سے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک راستوں کی تعداد تلاش کرنے کے ل only ، صرف دائیں ، نیچے ، یا اخترن کے ساتھ ، ہم متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ایک ازگر پروگرام ہے جو اس کو نافذ کرتا ہے: پائیٹون کوپی کوڈڈف کاؤنٹ_پاتھ (گرڈ): قطاریں = لین (گرڈ) کولس = لین (گرڈ [0]) # ہر سیل تک پہنچنے کے لئے راستوں کی تعداد کو ذخیرہ کرنے کے لئے 2D ٹیبل بنائیں = [[[0] * رینج (قطار) میں _ کے لئے COLs] # اوپر والے کونے والے DP تک پہنچنے کا ہمیشہ ایک طریقہ ہوتا ہے [0] [0] [0] = 1 # رینج (قطار) میں I کے لئے ٹیبل نیچے بھریں: J کے لئےرینج (COLS) میں: # ہر سیل کے ل the ، ملحقہ خلیوں سے راستوں کی تعداد شامل کریں اگر i> 0: dp [i] [j] += dp [i - 1] [j] اگر j> 0: dp [i] [j] += dp [i] [j - 1] اگر i> 0 اور j> 0: dp [i] [j] += dp [i - 1] [j - 1] #"
    },
    {
        "Question": "ایک ازگر کلاس بنائیں جس میں سرکلر دوگنا منسلک فہرست کی نمائندگی کی جائے اور کسی مخصوص پوزیشن پر نوڈ کو حذف کرنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو سرکلر دوگنا منسلک فہرست کی نمائندگی کرتا ہے جس میں کسی نوڈ کو حذف کرنے کے طریقہ کار کے ساتھ ایک نوڈ کو حذف کرنے کے طریقہ کار کے ساتھ: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹا = ڈیٹا سیل۔ سیل۔ سیل۔ نیکسٹ۔ نیکسٹ۔= نانکلاس سرکلرڈوبلی لنکڈ لسٹ: ڈیف __init __ (خود): سیلف ہیڈ = کوئی بھی نہیں ڈیف ضمیم"
    },
    {
        "Question": "کوئکسورٹ الگورتھم کا استعمال کرتے ہوئے عدد کی فہرست کو ترتیب دینے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ازگر میں کوئکسورٹ الگورتھم کا نفاذ ہے: پائیتھون کوپی کوڈیڈف کوئکسورٹ (اے آر آر): اگر لین (آر آر) <= 1: واپس آر او آر ایل: پیوٹ = آر آر [0] چھوٹا = [ایکس کے لئے x [1:]<= pivot] زیادہ = [x کے لئے x کے لئے [1:] اگر x> محور] واپس کوئکسٹورٹ (چھوٹا) + [پیوٹ] + کوئکسٹورٹ (زیادہ)# مثال کے طور پر usagenumbers = [7 ، 2 ، 1 ، 6 ، 8 ،5 ، 3 ، 4] ترتیب شدہ_نمبرز = کوئکسورٹ (نمبرز) پرنٹ (ترتیب شدہ_نمبرز) # آؤٹ پٹ: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8] اس نفاذ میں ، کوئکسورٹ فنکشن ان پٹ کے طور پر ایک فہرست ARR لے جاتا ہے اورکوئکسورٹ الگورتھم کا استعمال کرتے ہوئے اسے بار بار ترتیب دیتا ہے۔ بیس معاملہ اس وقت ہوتا ہے جب فہرست کی لمبائی 1 سے کم یا اس کے برابر ہوتی ہے۔ اس معاملے میں ، فہرست پہلے ہی ترتیب دی گئی ہے ، لہذا اسے واپس کردیا گیا ہے۔، ایک محور کا انتخاب کیا گیا ہے (اس میں"
    },
    {
        "Question": "\"کسی دی گئی فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق تلاش کرنے کے لئے ایک پروگرام لکھیں ، دوسرا عنصر پہلے کے بعد ظاہر ہوتا ہے ، اور پہلا عنصر چھوٹا ہوتا ہے۔\"",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جس میں کسی مخصوص فہرست میں دو عناصر کے مابین زیادہ سے زیادہ فرق پایا جاتا ہے ، جہاں پہلا عنصر پہلے اور پہلا عنصر چھوٹا ہوتا ہے: پائیتھون کوپی کوڈیڈف میکس_ ڈفیفنس (اے آر آر): اگر لین (آر آر) <2: کوئی بھی نہیں من_ق۔= arr [0] max_diff = arr [1] - arr [0] i in range (1 ، len (arr)) کے لئے: if arr [i] - min_value> زیادہ سے زیادہ_ڈیف: میکس_ ڈف = آرب [i] - من_ ویلیو if arr [i] <MIN_Value: min_value = arr [i] میکس_ ڈف ریٹرن # مثال usagenumbers = [7 ، 2 ، 5 ، 3 ، 9 ، 1 ، 6] نتیجہ = زیادہ سے زیادہ_ڈیفینس (نمبر) پرنٹ (نتیجہ) # آؤٹ پٹ: 7 اس پروگرام میں ،زیادہ سے زیادہ فرق تلاش کرنے کے لئے میکس_ ڈفینفرنس فنکشن ان پٹ کے طور پر ایک فہرست اے آر آر لیتا ہے اور عناصر کے ذریعے تکرار کرتا ہے۔ پروگرام دو متغیرات کی ابتدا کرتا ہے: اب تک نظر آنے والی کم سے کم قیمت کو ذخیرہ کرنے کے لئے MIN_Value ، اور زیادہ سے زیادہ فرق کو محفوظ کرنے کے لئے میکس_ ڈف۔دوسرے عنصر سے شروع ہونے والی فہرست۔یہ چیک کرتا ہے کہ آیا موجودہ عنصر اور MIN_Value کے درمیان فرق موجودہ زیادہ سے زیادہ فرق (MAX_DIFF) سے زیادہ ہے۔اگر ایسا ہے تو ، یہ میکس_ ڈف کو نئے زیادہ سے زیادہ فرق کے ساتھ اپ ڈیٹ کرتا ہے۔"
    },
    {
        "Question": "عدد کی فہرست میں دیئے گئے ہدف کے ساتھ کسی خالی خالی سبری کی سب سے بڑی رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جس میں عددیوں کی فہرست میں دیئے گئے ہدف کے ساتھ ایک غیر خالی سبری کی سب سے بڑی رقم ملتی ہے: پائیتھون کوپی کوڈیڈف سب سے بڑا_سوبری_سم (اے آر آر ، ٹارگٹ_سم): اگر نہیں آر آر: اگر کوئی نہیں میکس_سم = فلوٹ ('-انف') واپس نہیں آتا ہے تو واپس نہیں آتا ہے۔موجودہ_سم = 0 اسٹارٹ = 0 اختتام = 0 جبکہ اختتام <لین (اے آر آر): کرنٹ_سم += اے آر آر [اختتام] جبکہ موجودہ_سم> ٹارگٹ_سم اور اسٹارٹ <= اختتام: موجودہ_سم -= آر آر [شروع] شروع کریں += 1 اگر موجودہ_سم == ٹارگٹ_سم: ٹارگٹ_سم واپس کریں اگر موجودہ_سم <ٹارگٹ_سم اور کرنٹ_سم> زیادہ سے زیادہ_سم: میکس_سم = کرنٹ_سم اختتام += 1 میکس_سم!= 9result = سب سے بڑا_سوبری_سم (نمبر ، ہدف) پرنٹ (نتیجہ) # آؤٹ پٹ: 9 اس پروگرام میں ، سب سے بڑا_سوبری_سم فنکشن ان پٹ کے طور پر ایک فہرست اے آر آر اور ایک ہدف کا ہدف ہدف لیتا ہے اور غیر خالی سبری کا سب سے بڑا مجموعہ تلاش کرتا ہے جو ہدف کے مجموعی کے برابر ہوتا ہے۔. پروگرام میکس_سم کو ایک بہت ہی چھوٹی قیمت (`فلوٹ سے شروع کرتا ہے)"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط و قیمت ، اور زاویہ بریکٹ کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن ہے جو چیک کرتا ہے کہ اگر دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، اور زاویہ بریکٹ کے ساتھ ایک درست اظہار ہے: پائیٹون کوپی کوڈ ڈیف آئی ایس_والیڈ_ ایکسپریشن (اظہار): اسٹیک = [] افتتاحی = {'(' ، '،' ، '؛} قیمتیں = {'\"\" ، \"\"} quot_stack = [] اظہار کے لئے چار کے لئے: اگر کھلنے میں چار: اسٹیک.اپی اینڈ (چار) الیف چار بند میں بند نہیں: اگر اسٹیک نہیں ہے یا (اسٹیک [-1] + چار)جوڑے میں نہیں: جھوٹے اسٹیک کو واپس کریں۔لین (اسٹیک) == 0 اور لین (کوئٹ_ اسٹیک) == 0# مثال usageexpression1 = \"{(a+b)*[c- (d+e)]}\" اظہار 2 = \"([)]\" اظہار 3 = \"'ہیلو ، ورلڈ!"
    },
    {
        "Question": "\"تصادم کی قرارداد کے لئے علیحدہ زنجیروں کا استعمال کرتے ہوئے ہیش نقشہ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور کلیدی قیمت کے جوڑے داخل کرنے ، بازیافت کرنے اور ان کو دور کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو تصادم کے حل کے لئے علیحدہ زنجیروں کا استعمال کرتے ہوئے ہیش کے نقشے کی نمائندگی کرتی ہے ، جس میں کلیدی قدر کے جوڑے داخل کرنے ، بازیافت کرنے اور اسے ہٹانے کے طریقوں کے ساتھ: پائیتھون کوپی کوڈکلاس ہیش میپ: ڈیف __init __ (خود): سیلف۔سائز = 10 سیلف۔ بکیٹس = [[[[[] رینج (سیلف. سائز) میں _ کے لئے] ڈیف _ ہش (خود ، کلید): واپسی ہیش (کلید) ٪ خود۔بالٹیاں [انڈیکس] I کے لئے ، (موجودہ_کی ، _) گنتی (بالٹی) میں: اگر موجود_کی == کلید: بالٹی [i] = (کلیدی ، قدر) واپس بالٹی.ایپینڈ ((کلیدی ، قدر)) ڈیف بازیافت (خود ، ،کلیدی): انڈیکس = سیلف ۔_ہش (کلیدی) بالٹی = سیلف بوکیٹس [انڈیکس] موجودہ_کی کے لئے ، بالٹی میں قدر:"
    },
    {
        "Question": "کسی دیئے گئے تار میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!کسی دیئے گئے تار میں سب سے طویل پیلنڈرومک اسٹرنگ کی لمبائی تلاش کرنے کے لئے ایک پروگرام یہ ہے: پائیتھون کوپی کوڈڈیف طویل ترین_پالندروومک_سبسٹرنگ (s): n = len (s) اگر n <2: ریٹرن این اسٹارٹ = 0 میکس_لن = 1 # ہیلپر فنکشن کو وسعت کے ارد گرد بڑھانے کے لئےسینٹر ڈیف ایکسپینشن_آراؤنڈ_ سینٹر (بائیں ، دائیں): جبکہ بائیں> = 0 اور دائیں <n اور s [بائیں] == s [دائیں]: بائیں - = 1 دائیں += 1 دائیں واپسی - بائیں - 1 کے لئے 1 کے لئے (n): len1 = angish_around_center (i ، i) # عجیب لمبائی کے لئے چیک کریں palindromes len2 = apprison_around_center (i + 1) # یہاں تک کہ لمبائی کے لئے بھی چیک کریں palindromes curr_len = زیادہ سے زیادہ (len1 ، len2) اگر curr_len> میکس_لین: میکس_لین = کرر اسٹارٹ =i - (curr_len - 1) // 2 میکس_لن# ریٹرن#"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا بائنری سرچ کا استعمال کرتے ہوئے ایک دیئے گئے نمبر ایک بہترین مربع ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا بائنری سرچ کا استعمال کرتے ہوئے ایک دیئے گئے نمبر ایک کامل مربع ہے یا نہیں: پائیتھون کوپی کوڈیڈف IS_PERFECT_SQUARE (NUM): اگر نمبر <0: غلط لوٹ اگر نمبر == 0 یا نمبر == 1: دائیں بائیں ، دائیں واپس لوٹنا= 1 ، نمبر // 2 جبکہ بائیں <= دائیں: درمیانی = بائیں + (دائیں - بائیں) // 2 مربع = وسط * وسط * اگر مربع == نمبر: حقیقی الیف مربع <نمبر: بائیں = وسط + 1 اور:دائیں = وسط - واپسی غلط # مثال usagenumber = 25result = is_perfect_square (نمبر) پرنٹ (f \"{نمبر} ایک کامل مربع ہے: {نتیجہ}\") # آؤٹ پٹ: 25 ایک کامل مربع ہے: اس پروگرام کو سچ ہے ، is_perfect_square فنکشنان پٹ کے طور پر ایک انٹیجر نمبر لیتا ہے اور بولین کی قیمت کو لوٹاتا ہے جس سے یہ ظاہر ہوتا ہے کہ نمبر ایک کامل مربع ہے۔ یہ فنکشن پہلے ہینڈل کرتا ہے"
    },
    {
        "Question": "\"بائنری درخت میں زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں ، جہاں کسی بھی نوڈ پر راستہ شروع اور ختم ہوسکتا ہے۔\"",
        "Answer": "یقینا!بائنری درخت میں زیادہ سے زیادہ رقم کا راستہ تلاش کرنے کے لئے ایک پروگرام کا نفاذ یہاں ہے ، جہاں کسی بھی نوڈ پر راستہ شروع اور ختم ہوسکتا ہے: پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، قدر)self.right = nonedef max_path_sum (جڑ): میکس_سم = فلوٹ ('-inf') Def max_path_sum_helper (نوڈ): نوڈل میکس_سم: اگر نوڈ نہیں ہے تو: بائیں اور دائیں سب ٹریوں میں زیادہ سے زیادہ رقم کے راستے کا حساب لگائیں۔.رقم کا راستہ"
    },
    {
        "Question": "ڈائریکٹرا کے الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے ہدایت شدہ وزن والے گراف کی نمائندگی کرنے والے ایک ازگر کلاس بنائیں اور طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو ہدایت شدہ وزن والے گراف کی نمائندگی کرتا ہے اور مختصر ترین راستہ تلاش کرنے کے لئے ڈجکسٹرا کے الگورتھم کو نافذ کرتا ہے: پائیتھون کوپی کوڈیمپورٹ ہیپکلاس گراف: ڈیف __init __ (خود): سیلف.ورٹیس = {} ڈیف ایڈ_ورٹیکس (سیلف ، ورٹیکس): خود۔عمودی [vertex] = {} Def add_edge (خود ، شروع ، اختتام ،"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، قیمتیں ، زاویہ بریکٹ اور سلیش کے ساتھ ایک درست اظہار ہے یا نہیں۔\"",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے یا نہیں: پائیتھون کوپی کوڈ ڈیف آئی ایس_والیڈ_ ایکسپریشن (اظہار): اسٹیک = [] اوپننگ_چارس = {'(' ('، '[' ، '{' ، '<' ، '' \"\" ، '' \"، '/'} closing_chars = {')'] ']' ، '}' ، '>' ، '' ،\" ، \"''\"، '/'} مماثل_چارس = {'()' ، '[]' ، '{}' ، '<>' ، ''\" \"\" \"\" ، '' \"، '//'} اظہار کے لئے: اگر: اگراوپننگ_چارس میں چار: اسٹیک.ایپینڈ (چار) الیف چار میں بند_چارس: اگر اسٹیک نہیں ہے تو: غلط افتتاحی_چار واپس کریں = اسٹیک ۔پپ () اگر اوپننگ_چار + چار"
    },
    {
        "Question": "کسی بائنری صف میں 0s اور 1s کی برابر تعداد کے ساتھ سبری کی زیادہ سے زیادہ لمبائی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں دیئے گئے بائنری سرنی میں 0s اور 1s کی مساوی تعداد کے ساتھ سبری کی زیادہ سے زیادہ لمبائی تلاش کرنے کے لئے ایک پروگرام ہے: پائیتھون کوپی کوڈڈیف Find_max_length_subarray (ARR).= میں میکس_لنتھ# مثال کے طور پر استعمال شدہ_ریری = [0 ، 1 ، 0 ، 0 ، 1 ، 1 ، 1 ، 0 ، 1 ، 0 ، 0] میکس_ لمبائی = find_max_length_subarray (بائنری_ریری) پرنٹ (\"برابر کی زیادہ سے زیادہ لمبائی 0s اور 1s کی برابر تعداد کے ساتھ:\"، میکس_ لمبائی) اس پروگرام میں ، ہم بائنری صف کے ذریعے تکرار کرتے ہیں اور اب تک کا سامنا کرنے والے 0s اور 1s کی تعداد کے درمیان فرق کو ٹریک رکھنے کے لئے گنتی متغیر کو برقرار رکھتے ہیں۔ہم گنتی کی اقدار اور ان کے متعلقہ اشاریوں کو ذخیرہ کرنے کے لئے ایک ہیش میپ کا استعمال کرتے ہیں۔ جب بھی ہم 0 کا سامنا کرتے ہیں تو ہم گنتی کو 1 سے کم کرتے ہیں ، اور جب بھی ہمیں 1 کا سامنا کرنا پڑتا ہے ، ہم گنتی میں اضافہ کرتے ہیں۔"
    },
    {
        "Question": "مثبت عدد کی فہرست میں دیئے گئے ہدف کے ساتھ کسی بھی خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!مثبت عدد کی فہرست میں دیئے گئے ہدف کے ساتھ کسی غیر خالی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیتھون کوپی کوڈڈیف Find_max_sum_subarray (ARR ، ٹارگٹ_سم)(arr)): موجودہ_سم += آر [i] جبکہ موجودہ_سم> ٹارگٹ_سم: کرنٹ_سم -= آر آر [شروع] شروع کریں += 1 اگر موجودہ_سم == ٹارگٹ_سم: زیادہ سے زیادہ_سم = زیادہ سے زیادہ (میکس_سم ، کرنٹ_سم) میکس_سم# مثال کے طور پر یسجینم_ لسٹ = [1، 2 ، 3 ، 4"
    },
    {
        "Question": "ایک فنکشن کو نافذ کریں تاکہ کم سے کم حرفوں کی کم سے کم تعداد کو تلاش کیا جاسکے تاکہ اس کو ایک پیلنڈرووم بنایا جاسکے۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا نفاذ ہے جس میں کم سے کم حرفوں کی کم سے کم تعداد کو ایک تار میں شامل کرنے کے لئے شامل کیا جاسکتا ہے تاکہ اسے پیلنڈرووم بنایا جاسکے: پائیتھون کوپی کوڈڈیف من_چارس_ٹو_پال انڈرووم (سٹرنگ): اگر سٹرنگ == سٹرنگ [::-1]: واپس 0 این = لین (واپس 0 این = لین (سٹرنگ) dp = [[0] *"
    },
    {
        "Question": "بائنری ٹری کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور بائنری نمبر داخل کرنے اور تلاش کرنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!بائنری نمبروں کو داخل کرنے اور تلاش کرنے کے طریقوں کے ساتھ بائنری ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس بائنری ٹرینائڈ: ڈیف __init __ (خود): سیلف۔ چائلڈرین = [کوئی نہیں ، کوئی بھی نہیں] خود۔: Def __init __ (خود): self.root = بائنری ٹریئنوڈ () ڈیف داخل کریں (خود ، بائنری_نبر): بائنری_نمبر میں بٹ کے لئے نوڈ = سیلف۔۔Bit_index]: غلط نوڈ = نوڈ. بچوں کو واپس کریں [Bit_index] واپس نوڈ۔ is_end_of_number# مثال usagetrie = binainertrie () trie.insert (\"1010\") trie.insert (\"1101\") trie.insert (\"0111\") پرنٹ (\"011\") پرنٹ (\"011\") پرنٹ (\"011\") پرنٹ (\"011\") پرنٹtrie.search (\"1010\")) # سچ پرنٹ (trie.search (\"1101\")) # ٹروپنٹ (tr"
    },
    {
        "Question": "تار کی فہرست میں سب سے طویل عام پریفکس تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!تار کی فہرست میں سب سے طویل مشترکہ سابقہ تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیٹون کوپی کوڈ ڈیف طویل ترین_کومون_پرفکس (ڈور): اگر تار نہیں تو: ڈور میں تار کے لئے \"\" \"پریفکس = ڈور [0]: تار [1:]پریفکس)]! = پریفکس: پریفکس = پریفکس [:-1] اگر پریفکس نہیں: واپسی \"\" پریفکس# مثال کے استعمال کے الفاظ = [\"ایپل\" ، \"ایپلی کیشن\" ، \"اہلیت\" ، \"ضمیمہ\"] کامن_پری فکس = طویل ترین_کومون_پریفکس (الفاظ (الفاظ (الفاظ) پرنٹ (کامن_پریفکس) # آؤٹ پٹ: \"ایپ\" اس پروگرام میں ، ہم ایک طویل عرصے تک_کومون_پرفکس کی وضاحت کرتے ہیں جو ان پٹ کے طور پر تاروں کی فہرست لیتا ہے اور ان میں سب سے طویل عام سابقہ واپس کرتا ہے۔ اگر ان پٹ کی فہرست خالی ہے تو فنکشن کا پہلا چیک ہوتا ہے۔اگر یہ ہے تو ، یہ ایک خالی تار واپس کرتا ہے کیونکہ کوئی عام سابقہ نہیں ہے۔ ہم فہرست میں پہلی سٹرنگ کے ساتھ سابقہ متغیر کو شروع کریں۔اس کے بعد ، ہم فہرست میں باقی ڈوروں پر تکرار کرتے ہیں۔ہر تار کے ل we ، ہم بار بار پریفکس سے حروف کو ہٹا دیتے ہیں جب تک کہ سٹرنگ کا پریفکس کے ساتھ شروع نہیں ہوتا ہے۔اس سے یہ یقینی بنتا ہے کہ اس طرح کے تمام تاروں میں پریفکس سب سے طویل عام سابقہ بنی ہوئی ہے"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا بائنری نمائندگی میں دیئے گئے نمبر ایک پالندرووم ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا اس کی بائنری نمائندگی میں دیئے گئے نمبر ایک پیلینڈرووم ہے: پائیتھون کوپی کوڈ ڈیف IS_BINARY_PALINDROME (نمبر): بائنری = بن (نمبر) [2:] # بائنری نمائندگی میں نمبر تبدیل کریں اور '0B' پریفکس کو ہٹا دیں۔الٹ_بائنری = بائنری [::-1] # بائنری سٹرنگ ریٹرن بائنری == الٹ_بائنری # مثال کے استعمال کے استعمال (is_binary_palindrome (9)) # آؤٹ پٹ: سچ (بائنری میں 9) پرنٹ (is_binary_palindrome (10)) # آؤٹ پٹ: غلط۔'سلائسنگ ([2:]) کا استعمال کرتے ہوئے سابقہ۔ پھر ، ہم -1 کے ایک قدم کے ساتھ سلائسنگ کا استعمال کرتے ہوئے بائنری تار کو الٹ دیتے ہیں (`[:: -1"
    },
    {
        "Question": "دیئے گئے بائنری صف میں 0s اور 1s کی برابر تعداد کے ساتھ طویل ترین بڑھتی ہوئی سبری کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "دیئے گئے بائنری صف میں 0s اور 1s کی مساوی تعداد کے ساتھ طویل ترین بڑھتی ہوئی سبری کو تلاش کرنے کے ل you ، آپ اسی طرح کا نقطہ نظر استعمال کرسکتے ہیں جیسے ہدف کی رقم کے ساتھ سب سے طویل سبری کو تلاش کریں۔یہاں ایک پروگرام ہے جو اس مسئلے کو حل کرتا ہے: پائیتھون کوپی کوڈ ڈیف طویل ترین_Increasing_subarray_with_equal_zeros_ones (arr): گنتی = 0 میکس_لین = 0 سوم_مپ = {0: -1} i in رینج (لین (arr)): اگر arr [i] == 0: گنتی ہے۔- = 1 اور: گنتی += 1 اگر SUM_MAP میں گنتی کریں: میکس_لن = میکس (میکس_لن ، I - SUM_MAP [COUNT]) اور: SUM_MAP [گنتی] = میں میکس_لن# مثال کے استعمال کے استعمال کے استعمال سے متعلق_ریری_ری = [0 ، 1 ، 0 ، 1 ، 1 ،1 ، 0 ، 0] پرنٹ (سب سے طویل_increasing_subarray_with_equal_zeros_ones (بائنری_آرے)) # آؤٹ پٹ: 6 بائنری_رای = [1 ،"
    },
    {
        "Question": "سرکلر قطار کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور کسی مخصوص تعداد میں پوزیشنوں کے ذریعہ قطار کو گھومنے کے لئے ایک طریقہ نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو سرکلر قطار کی نمائندگی کرتی ہے جس میں قطار کو ایک مخصوص تعداد میں گھومنے کے طریقہ کار کے ساتھ ایک طریقہ کار کے ساتھ: پائیتھون کوپی کوڈکلاس سرکلر کیوئ: ڈیف __init __ (خود ، صلاحیت): خود کی گنتی = صلاحیت خود = [کوئی نہیں] * خود کی صلاحیتself.front = self.reare = -1 def is_empty (self): واپسی sell"
    },
    {
        "Question": "دیئے گئے سرکلر صف میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم سبری کو تلاش کرنے کے ل we ، ہم کڈانے کا الگورتھم استعمال کرسکتے ہیں۔خیال دو معاملات کو سنبھالنے کے لئے ہے: ایک جہاں زیادہ سے زیادہ رقم سبری سرکلر رینج کے اندر ہے ، اور دوسرا جہاں یہ سرکلر رینج کے گرد لپیٹتا ہے۔ یہاں فنکشن کا نفاذ ہے: پائیٹون کوپی کوڈڈف میکس_سوم_سوبری_سرکلر (آر آر): ڈیف کڈین (آر آر):میکس_سم = فلوٹ ('-inf') کریری_سم = 0 نمبر کے لئے نمبرکڈانے (اے آر آر) # کیس 2: سرکلر رینج کے ارد گرد زیادہ سے زیادہ سم سبری ریپنگ کل_سم = سم (اے آر آر) کے لئے I (لین (اے آر آر)): آر آر [i] = -arr [i] # ہر عنصر کی علامت کو الٹ دیںمیکس_سم_روپ = ٹوٹل_سم + کڈانے (اے آر آر) # دو معاملات میں سے زیادہ سے زیادہ واپسی میکس (میکس_سم_ وِتھن ، میکس_سم_روپ) آئیے ایک مثال کے ساتھ فنکشن کی جانچ کرتے ہیں: پائیتھون کوپی کوڈیرر = [8 ، -1 ، 3 ، 4] پرنٹ (میکس_سم_سوبری_سکلر (اے آر آر)) # آؤٹ پٹ: 15 میں دی گئی مثال ، زیادہ سے زیادہ"
    },
    {
        "Question": "\"ایک پروگرام لکھیں تاکہ اوپر سے بائیں کونے سے گرڈ کے نیچے دائیں کونے تک منفرد راستوں کی تعداد تلاش کی جاسکے ، صرف دائیں یا نیچے کی طرف بڑھتی ہے ، جس میں گرڈ میں '1' کی نمائندگی کی جانے والی رکاوٹیں ہیں۔\"",
        "Answer": "اوپر کے بائیں کونے سے لے کر گرڈ کے نیچے دائیں کونے تک انفرادی راستوں کی تعداد تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ہر سیل کے لئے راستوں کی تعداد کو ذخیرہ کرنے کے لئے 2D گرڈ بنائیں گے۔ یہاں پروگرام کا نفاذ ہے: پائیتھون کوپی کوڈیڈف منفرد_پاتھس_بسٹیکلز (گرڈ) (گرڈ): قطاریں = لین (گرڈ) کولس = لین (گرڈ [0]) # 2 ڈی بنائیںہر سیل کے لئے راستوں کی تعداد کو ذخیرہ کرنے کے لئے گرڈ = [[0] * رینج (قطار) میں _ کے لئے COLs] # اوپر والے کونے والے DP [0] [0] = 1 کے لئے راستوں کی تعداد کو شروع کریں [0] = 1 اگر گرڈ [0] [0] == 0 اور 0 # رینج (1 ، COLS) میں کرنل کے لئے پہلی قطار بھریں: اگر گرڈ [0] [کرنل] == 0: ڈی پی [0] [کرن] = ڈی پی [0] [0] [کرنل - 1] # رینج میں قطار کے لئے پہلا کالم بھریں (1 ، قطاریں): اگر گرڈ [قطار] [0] == 0: ڈی پی"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے تار کو لغت کے الفاظ کے خلائی الگ الگ ترتیب میں تقسیم کیا جاسکتا ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا دیئے گئے تار کو لغت کے الفاظ کے خلائی الگ الگ ترتیب میں تقسیم کیا جاسکتا ہے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔ہم ایک ٹیبل تیار کریں گے جس میں یہ اسٹور کیا جائے کہ آیا کسی سٹرنگ کو لغت کے الفاظ میں تقسیم کیا جاسکتا ہے۔ یہاں فنکشن کا نفاذ ہے: پائیتھون کوپی کوڈیڈف ورڈ_ بریک (ایس ، ورڈ_ ڈکٹ): این = لین (ایس) # اسٹور کرنے کے لئے ایک ٹیبل بنائیں کہ آیا کوئی سبسٹرنگ کر سکتا ہے یا نہیںقطع شدہ DP = [غلط] * (n + 1) dp [0] = رینج میں I کے لئے سچ (1 ، n + 1): J میں حد (i) کے لئے: اگر dp [j] اور s [j: i: i] ورڈ_ڈکٹ میں: ڈی پی [i] = سچ بریک ریٹرن ڈی پی [این] آئیے ایک مثال کے ساتھ فنکشن کی جانچ کریں: پائیتھون کوپی کوڈ وورڈ_ڈکٹ = {\"ایپل\" ، \"قلم\" ، \"انناس\"} ایس = \"ایپلپین پیپل\" پرنٹ (ورڈ_ بریک (ایس)، ورڈ_ ڈکٹ)) # آؤٹ پٹ: trues = \"انناسپلپیناپل\" پرنٹ (ورڈ_ بریک (s ، ورڈ_ ڈکٹ)) # آؤٹ پٹ: trues = \"کیٹسینڈوگ\""
    },
    {
        "Question": "کسی دیئے گئے لغت میں سب سے طویل لفظ تلاش کرنے کے لئے ایک پروگرام لکھیں جو کسی دیئے گئے تار سے حروف کو حذف کرکے تعمیر کیا جاسکتا ہے۔",
        "Answer": "کسی دیئے گئے لغت میں سب سے طویل لفظ تلاش کرنے کے لئے جو کسی دیئے گئے تار سے حروف کو حذف کرکے تعمیر کیا جاسکتا ہے ، ہم لغت میں ہر لفظ پر تکرار کرسکتے ہیں اور چیک کرسکتے ہیں کہ آیا یہ دیئے گئے تار سے حروف کو حذف کرکے تشکیل دے سکتا ہے۔ہم اب تک پائے جانے والے سب سے طویل لفظ پر نظر رکھیں گے۔ یہاں پروگرام کا نفاذ ہے: پائیتھون کوپی کوڈ ڈیف طویل ترین_ ورڈ (لغت ، ایس): سب سے طویل = \"\" لغت میں لفظ کے لئے: اگر is_subsecance (لفظ ، s) اور لین (لفظ)> لین (سب سے طویل): سب سے طویل = لفظ کی واپسی سب سے طویل عرصے تک IS_SUBSEANCE (لفظ ، s): i ، j = 0 ، 0 جبکہ میں <لین (ورڈ) اور جے <لین (s): اگر لفظ [i] == s [j]: i += 1 j += 1 واپسی i == لین (ورڈ) آئیے ایک مثال کے ساتھ پروگرام کی جانچ کریں: پائیتھون کوپی کوڈ ڈکشنری = [\"بلی\" ، \"بیٹ\" ، \"چوہا\" ، \"ایپل\" ، \"کیلے\" ،\"کار\"] s = \"کٹار\" پرنٹ (طویل ترین_ ورڈ (لغت ، ایس)) # آؤٹ پٹ: \"بلی"
    },
    {
        "Question": "سوڈوکو سولور کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور دیئے گئے سوڈوکو پہیلی کو حل کرنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس ہے جو سوڈوکو سولور کی نمائندگی کرتی ہے جس میں بیک ٹریکنگ الگورتھم کا استعمال کرتے ہوئے دیئے گئے سوڈوکو پہیلی کو حل کرنے کے طریقہ کار کے ساتھ: پائیتھون کوپی کوڈکلاس سوڈوکسولور: ڈی ای ایف حل (خود ، بورڈ): # ہیلپر فنکشن یہ چیک کرنے کے لئے کہ کسی قدر کی قیمت دی جاسکتی ہے یا نہیں۔is_valid (بورڈ ، قطار ، کرنل ، NUM): # رینج (9) کے لئے قطار چیک کریں (9): اگر بورڈ [قطار] [i] == NUM: رینج (9) کے لئے غلط # چیک کالم واپس کریں (9)i] [col] == num: غلط # 3x3 subgrid start_row = (قطار // 3) * 3 اسٹارٹ_کول = (کرنل // 3) * 3 کے لئے رینج (3) کے لئے (3): رینج (3) میں جے کے لئے (3): اگر بورڈ [start_row + i] [start_col + j] == num: غلط واپسی سچ واپس # HELPER فنکشن بورڈ میں خالی سیل تلاش کرنے کے لئے Def find_empty_cell (بورڈ): رینج میں I (9) کے لئے: رینج میں جے کے لئے(9): اگر بورڈ [i] [J] == 0: واپس I ، J واپس کوئی # کوئی بھی # recursive فنکشن کو سوڈوکو پہیلی کو حل کرنے کے لئے"
    },
    {
        "Question": "کسی مخصوص عدد کی فہرست سے K الگ الگ عدد کے تمام ممکنہ امتزاج پیدا کرنے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست سے K الگ الگ عدد کے تمام ممکنہ امتزاج پیدا کرنے کے لئے یہاں ایک فنکشن کا نفاذ ہے: پائیٹون کوپی کوڈ ڈیف جنریٹ_کومبنیشنز (نمبرز ، کے"
    },
    {
        "Question": "بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے ل you ، آپ ہسٹوگرام کے مسئلے میں سب سے بڑے مستطیل کی بنیاد پر نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ایک پروگرام ہے جو اس نقطہ نظر کو نافذ کرتا ہے: پائیتھون کوپی کوڈیڈف سب سے بڑے_راٹینگل_اریہ (میٹرکس): اگر میٹرکس نہیں ہے تو: 0 اونچائیوں کو واپس کریں = [0] * لین (میٹرکس [0]) میکس_یریہ = 0 میٹرکس میں قطار کے لئے: I ، ویل میں (قطار میں (قطار)): # موجودہ قطار کی بنیاد پر اونچائیوں کی سرنی کو اپ ڈیٹ کریں اگر ویل == 1: اونچائی [i] += 1 اور: اونچائی [i] = 0 # موجودہ صف میں سب سے بڑا مستطیل کا علاقہ تلاش کریں میکس_یریا = میکس (میکس_یریا ، سب سے زیادہ_ریکٹیننگ_ن_ہسٹگرام.ضمیمہ (i) i += 1 اور: ٹاپ = اسٹیک.پپ () ایریا = اونچائی [اوپر] * (اگر میں اسٹیک نہیں کرتا تو I"
    },
    {
        "Question": "\"2D گرڈ میں الگ الگ جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں جزیروں کی تعریف '1 کے مربوط علاقوں سے ہوتی ہے۔\"",
        "Answer": "2D گرڈ میں الگ الگ جزیروں کی تعداد تلاش کرنے کے لئے ، جہاں جزیروں کی وضاحت '1 کے منسلک علاقوں سے کی جاتی ہے ، آپ الگ الگ جزیروں پر نظر رکھنے کے لئے ایک سیٹ کے ساتھ ساتھ گہرائی میں پہلی تلاش (DFS) نقطہ نظر استعمال کرسکتے ہیں۔یہاں ایک پروگرام ہے جو اس کو نافذ کرتا ہے: پائیتھون کوپی کوڈیڈف نمبر_ڈیسٹنٹ_س لینڈز (گرڈ): اگر گرڈ نہیں ہے یا گرڈ نہیں ہے [0]: 0 قطاریں ، کولس = لین (گرڈ) ، لین (گرڈ [0]) الگ الگ_س لینڈز = سیٹ () ڈیف ڈی ایف ایس (ڈیف ڈی ایف ایس (ڈیف ڈی ایف ایس ()قطار ، کرنل ، جزیرے ، سمت): اگر (0 <= قطار <قطاریں اور 0 <= col <cols اور گرڈ [قطار] [کرن] == 1): گرڈ [قطار] [کرنل] = 0 جزیرہ۔ اپینڈ (سمت) ڈی ایف ایس (قطار + 1 ، کرنل ، جزیرہ ، 'ڈی') ڈی ایف ایس (قطار - 1 ، کرنل ، جزیرہ ، 'یو') ڈی ایف ایس (قطار ، کرنل + 1 ، جزیرہ ، 'آر') ڈی ایف ایس (قطار ، کرنل -1 ، جزیرہ ، 'l') جزیرہ۔ اپینڈ ('بی') # رینج میں قطار کے لئے بیک ٹریک (قطار): رینج میں کرنل (COLs) کے لئے: اگر گرڈ [قطار] [کرنل] == 1:"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کریں کہ آیا ملر-ریبین پرائمری ٹیسٹ کا استعمال کرتے ہوئے ایک دیئے گئے نمبر ایک اہم نمبر ہے یا نہیں۔",
        "Answer": "یقینا!یہاں یہ معلوم کرنے کے لئے کہ کوئی دیئے گئے نمبر ایک اہم نمبر ہے تو یہ چیک کرنے کے لئے ازگر میں ملر-ریبین پرائمری ٹیسٹ کا نفاذ ہے: پائیٹون کوپی کوڈیمپورٹ رینڈم ڈیف آئی ایس_پرائم (این ، کے = 5): اگر n <= 1: جھوٹے کو واپس کریں اگر n == 2 یا n n == 2 یا n== 3: اگر n ٪ 2 == 0: لوٹیں تو غلط # لکھیں n - 1 as 2^r * d r = 0 d = n - 1 جبکہ d ٪ 2 == 0: r += 1 d // =2 # رینج (کے) میں _ کے لئے ملر ریبین پرائمری ٹیسٹ کے اوقات پرفارم کریں: a = بے ترتیب۔ رینڈنٹ (2 ، n - 2) x = pow (a ، d ، n) اگر x == 1 یا x == n- 1: رینج میں _ کے لئے جاری رکھیں (r - 1): x = pow (x ، 2 ، n) اگر x == n - 1: توڑ کوئی اور:"
    },
    {
        "Question": "بیل مین فورڈ الگورتھم کا استعمال کرتے ہوئے مختصر ترین راستہ تلاش کرنے کے لئے وزن والے ہدایت والے ایسائکلک گراف کی نمائندگی کرنے والے ایک ازگر کلاس لکھیں اور طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو وزن والے ہدایت والے ایسائکلک گراف کی نمائندگی کرتی ہے اور بیل مین فورڈ الگورتھم کو نافذ کرتی ہے تاکہ ایک ماخذ ورٹیکس سے دوسرے تمام عمودی حصے تک مختصر ترین راستہ تلاش کیا جاسکے: پائیٹون کوپی کوڈکلاس ویٹڈ ڈاگ: ڈیف __init __ (خود ، نمبر_ورٹیسس): خود۔ Num_vertices = numselficess.کناروں = [] ڈیف ایڈ_ج (خود ، ماخذ ، منزل ، وزن): سیلف ڈاٹ ای ڈی ایس ای ڈی۔ اپینڈ ((ماخذ ، منزل ، وزن)) ڈیف بیل مین_فورڈ (خود ، ماخذ): # مرحلہ 1: سوائے انفینٹی کے طور پر تمام عمودی فاصلے کو شروع کریں سوائے اس کے کہ سوائےماخذ عمودی فاصلہ = [فلوٹ ('inf')] * سیلف۔نوم_ورٹیسس فاصلہ [ماخذ] = 0 # مرحلہ 2: رینج میں بار بار آرام کے کناروں (v - 1) کی حد (self.num_vertices - 1): U کے لئے U کے لئے، V ، W خود میں۔خود میں منفی وزن کے چکروں کی جانچ پڑتال کریں۔سائیکل \"ریٹرن فاصلہ# مثال کے استعمال: گراف = ویٹڈ ڈیگ (6) گراف.اڈی_ ایج"
    },
    {
        "Question": "ہندسوں کے دیئے گئے تار سے تمام ممکنہ درست IP پتے تیار کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!ہندسوں کے دیئے گئے تار سے تمام ممکنہ درست IP پتے تیار کرنے کے لئے ازگر میں ایک پروگرام ہے: پیتھون کوپی کوڈڈف بحالی_پ_اڈریسس (ایس): ڈیف بیک ٹریک (ایس ، اسٹارٹ ، راہ ، نتیجہ): # بیس کیس: اگر ہمارے پاس 4 حصے ہیں اور اگر ہمارے پاس 4 حصے ہیں اور اگر ہمارے پاس 4 حصے ہیں اورایس میں ہندسے اگر لین (راستہ) == 4 اور اسٹارٹ == لین (زبانیں): نتیجہ۔ اپینڈ (\".\". \"شامل کریں (راہ)) واپسی # اگر ہمارے پاس 4 حصے ہیں لیکن پھر بھی ایس میں ہندسے باقی ہیں ، اگر واپس جائیں تو واپس جائیں۔لین (راستہ) == 4 یا اسٹارٹ == لین (زبانیں): رینج میں لمبائی کے لئے تمام ممکنہ طبقہ کی لمبائی (1 ، 2 ، 3) کی کوشش کریں (1 ، 4): # اگر لمبائی میں '0' سے شروع ہونے والے طبقات کو نظرانداز کریں> 1 اگر لمبائی> 1 اور s [start] == '0': جاری رکھیں # موجودہ طبقے کو ایس طبقہ = s سے نکالیں [شروع کریں: شروع کریں+لمبائی] # چیک کریں کہ آیا طبقہ ایک درست IP طبقہ ہے (0 <= طبقہ)<= 255) اگر INT (طبقہ) <= 255: # اگلی اسٹارٹ انڈیکس اور تازہ ترین راستہ بیک ٹریک (s ، اسٹارٹ + لمبائی ، راستہ + [طبقہ] ، نتیجہ) کے ساتھ بار بار بیک ٹریک کریں۔"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں الٹ کی تعداد کو گننے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں الٹی کی تعداد کو گننے کے لئے ایک فنکشن کا نفاذ یہاں ہے: پائیٹون کوپی کوڈ ڈیف کاؤنٹی_ انورینسز (نمبر): # دو ترتیب شدہ فہرستوں کو ضم کرنے کے لئے # ہیلپر فنکشن ڈیف انضمام (بائیں ، دائیں): ضم شدہ = [] انو_ کاؤنٹ= 0 i ، j = 0 ، 0 جبکہ میں <لین (بائیں) اور جے <لین (دائیں): اگر بائیں [i] <= دائیں [j]: ضم شدہ۔ اپینڈ (بائیں [i]) i += 1 اور: انضمام۔ اپینڈ (دائیں [j]) انو_کاؤنٹ += لین (بائیں) - i j += 1 # نامکمل فہرست میں سے باقی عناصر ضم شدہ۔) واپسی ضم شدہ ، انو_کونٹ # بیس کیس: اگر فہرست میں صفر یا ایک عنصر ہے تو ، کوئی الٹا نہیں ہے اگر لین (نمبر) <= 1: لوٹنے والے نمبر ، 0 # فہرست کو دو حصوں میں وسط = لین (نمبر) میں تقسیم کریں // 2 بائیں.الٹا"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں زیادہ سے زیادہ سبری مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!عددیوں کی ایک دی گئی فہرست میں زیادہ سے زیادہ سبری پروڈکٹ تلاش کرنے کے لئے ایک فنکشن کا نفاذ یہاں ہے: پائیٹون کوپی کوڈڈیف میکس_سوبری_ پروڈکٹ (نمبر): اگر نمبر نہیں تو: واپس 0 میکس_ پروڈکٹ = نمبر [0] کرر_میکس = نمبر [0] کرن_من = نمبر [0]رینج (1 ، لین (نمبر)) میں I کے لئے: اگر نمبر [i] <0: curr_max ، curr_min = curr_min ، curr_max curr_max = زیادہ سے زیادہ (nums [i] ، curr_max * nums [i] [i]) curr_min = min (nums [nums [i] ، curr_min * nums [i]) میکس_ پروڈکٹ = زیادہ سے زیادہ (میکس_ پروڈکٹ ، کرر_میکس) واپسی میکس_ پروڈکٹ# مثال کے استعمال: نمبر = [2 ، 3 ، -2 ، 4] میکس_ پروڈکٹ = میکس_سوبری_ پروڈکٹ (نمبر) پرنٹ (\"زیادہ سے زیادہ سب رے پروڈکٹ:\"، MAX_PRODUCT) آؤٹ پٹ: YAMLCOPY CODEMAXIM SUBARRAY پروڈکٹ: 6 میں ، اس پروگرام میں ، MAX_SUBARRAY_PRODUCT فنکشن ان پٹ کے طور پر انٹیگر نمبروں کی ایک فہرست لیتا ہے اور زیادہ سے زیادہ سبری پروڈکٹ کو لوٹاتا ہے۔ یہ فنکشن موجودہ زیادہ سے زیادہ اور کم سے کم پروڈکٹ کو ٹریک رکھنے کے لئے ایک متحرک پروگرامنگ نقطہ نظر کا استعمال کرتا ہے۔ہر انڈیکسموجودہ عنصر اور پچھلے زیادہ سے زیادہ اور کم سے کم کی بنیاد پر موجودہ زیادہ سے زیادہ اور کم سے کم کو اپ ڈیٹ کرتے ہوئے ، فہرست کے ذریعے تکرار کرتا ہے۔اگر موجودہ عنصر منفی ہے تو ، موجودہ زیادہ سے زیادہ اور کم سے کم تبدیل ہوجاتے ہیں کیونکہ منفی تعداد سے ضرب لگانے کا نتیجہ ایک کا نتیجہ بن سکتا ہے"
    },
    {
        "Question": "ریڈکس ٹری (ٹری) کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور تاروں کو داخل کرنے اور تلاش کرنے کے لئے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جس میں ریڈکس ٹری (ٹری) کی نمائندگی ہوتی ہے جس میں تاروں کو داخل کرنے اور تلاش کرنے کے طریقوں کے ساتھ: پائیتھون کوپی کوڈکلاس ریڈکسٹری: کلاس نوڈ: ڈیف __init __ (خود ، چار): سیلف ۔چار = چار سیلف۔ بچوں = {} خود.is_word_end = غلط Def __init __ (خود): self.root = self.node (\"\") Def داخل کریں (خود ، لفظ): موجودہ_نوڈ = سیلف.روٹ کے لئے لفظ میں: اگر کرنٹ_نوڈ میں چار چار: کرنٹ_نوڈ = کرنٹ_نوڈ۔بچے [چار] اور: new_node = self.node (CHAR) موجودہ_نوڈ.کرن [چار] = new_node کرنٹ_نوڈ = new_node کرنٹ_نوڈ.س_ورڈ_ینڈ = سچے ڈیف سرچ (خود ، لفظ): کرنٹ_نوڈ = سیلف۔موجودہ_نوڈ.کرینین میں: موجودہ_نوڈ = کرنٹ_نوڈ.کرنین [چار] ورنہ: غلط واپسی موجودہ_نوڈ.س_ورڈ_ینڈیکسامپل استعمال: پائیتھون کوپی کوڈ# ایک ریڈکس ٹریٹری = ریڈکسٹری ()# داخل کریں الفاظ داخل کریں۔\") ٹری.نسرٹ (\" سنتری \") # الفاظ کے پرنٹ (درختوں کی تلاش (\" ایپل \")) # ٹروپنٹ (ٹری.سرچ (\" کیلے \")) # ٹروپنٹ (درخت.سارچ (\" اورنج \")) # سچ"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا بائنری ٹری ایک درست بائنری سرچ درخت ہے۔",
        "Answer": "یقینا!ذیل میں یہ چیک کرنے کے لئے ازگر میں کسی فنکشن کا نفاذ ہے کہ آیا بائنری ٹری ایک درست بائنری سرچ ٹری ہے: پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، کوئی بھی نہیں): سیلف.وال =ویل سیلف ایف ٹی = بائیں سیلف۔ رائٹ = رائٹ ڈیف is_valid_bst (جڑ): ڈیف ہیلپر (نوڈ ، لوئر = فلوٹ ('-انف') ، اوپری = فلوٹ ('انف')): اگر نہیں نوڈ: سچ ویل = نوڈ واپس.val اگر وال <= لوئر یا ویل> = اوپری: اگر مددگار نہیں تو غلط واپس کریں (نوڈ۔ رائٹ ، ویل ، اوپری): اگر مددگار نہیں ہے تو جھوٹا لوٹائیں (نوڈ۔ لیفٹ ، لوئر ، ویل): غلط واپسی سچے ریٹرن ہیلپر (جڑ) یہ عمل درآمد بائنری درخت کو عبور کرنے کے لئے ایک بار بار چلنے والا مددگار فنکشن کا استعمال کرتا ہے اور جانچ پڑتال کرتا ہے کہ آیا ہر نوڈ کی قیمت قابل قبول حد میں ہے یا نہیں۔اس حد کی وضاحت نچلی اور اوپری حدود سے ہوتی ہے ، جو ابتدائی طور پر بالترتیب منفی انفینٹی اور مثبت انفینٹی کے طور پر شروع ہوتی ہے۔ ہر نوڈ کے ل we ، ہم اس کی قدر کا موازنہ نچلے اور اوپری حد سے کرتے ہیں۔اگر قیمت نچلے حد سے کم یا اس کے برابر ہے یا اوپری حد سے زیادہ یا اس کے برابر ہے تو ، یہ بائنری سرچ ٹری پراپرٹی کی خلاف ورزی کرتا ہے ، اور ہم غلط لوٹتے ہیں۔"
    },
    {
        "Question": "کسی بھی نوڈ سے کسی دوسرے نوڈ تک درخت میں سب سے طویل راستہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی بھی نوڈ سے کسی دوسرے نوڈ تک درخت میں سب سے طویل راستہ تلاش کرنے کے ل we ، ہم گہرائی میں پہلی تلاش (DFS) الگورتھم استعمال کرسکتے ہیں۔یہاں ازگر میں ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بچے = کوئی نہیں): سیلف۔ وال = ویل سیلف۔ بچے = بچے اگر بچے اور ڈیف طویل ترین_پاتھ (جڑ): اگر جڑ نہیں تو: اگر جڑ نہیں ہے تو: اگر جڑ نہیں ہے: اگر جڑ نہیں ہے تو:واپس 0 DEF DFS (نوڈ ، PATH_LENGT): node.Children: نوڈ میں بچے کے لئے زیادہ سے زیادہ لمبائی = زیادہ سے زیادہ (زیادہ سے زیادہ (زیادہ سے زیادہ ، زیادہ سے زیادہ ، زیادہ سے زیادہ ، PATH_LENGTH)اس عمل کو نفاذ کریں ، ہم وضاحت کرتے ہیں"
    },
    {
        "Question": "قطار اور کالموں کے ذریعہ ترتیب دیئے گئے میٹرکس میں کے ٹی ایچ کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "ایک میٹرکس میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو قطار اور کالموں کے ذریعہ ترتیب دینے کے ل we ، ہم ایک کم سے کم ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔یہاں ازگر میں ایک مثال عمل ہے: پائیتھون کوپی کوڈیمپورٹ ہیپ کیو ڈیف Kth_smallest (میٹرکس ، کے): اگر میٹرکس یا K <1: واپس کوئی نہیں M ، n = لین (میٹرکس) ، لین (میٹرکس [0]) Min_HEAP = [] I IN کے لئے Iرینج (منٹ (K ، M)): ہیپ کیو ہپش (MIN_HEAP ، (میٹرکس [I] [0] ، I ، 0)) جبکہ K> 0: عنصر ، قطار ، کرنل = ہیپ کیو ہپپپ (MIN_HEAP) اگر کرنل <این - 1: ہیپ کیو۔ ہیپش (من_ہپ ، (میٹرکس [قطار] [کرنل + 1] ، قطار ، کرنل + 1)))"
    },
    {
        "Question": "دو ڈوروں کے مابین لیونشٹین فاصلے کا حساب لگانے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!لیونشٹین فاصلہ ایک تار کو دوسرے میں تبدیل کرنے کے لئے کم سے کم آپریشنز (اندراجات ، حذف ، یا متبادل) کی ایک پیمائش ہے۔ازگر میں دو ڈوروں کے درمیان لیونشین فاصلے کا حساب لگانے کے لئے ایک فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف لیونشٹین_ڈسٹنس (ورڈ 1 ، ورڈ 2): ایم ، این = لین (ورڈ 1) ، لین (ورڈ 2) ڈی پی = [[0] * (این + (این + (این + (این +)1) رینج میں _ (M + 1)] کے لئے I (M + 1) کے لئے: DP [i] [0] = i J کے لئے رینج (n + 1): dp [0] [j] = jرینج (1 ، m + 1) میں I"
    },
    {
        "Question": "بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور داخل کرنے اور چیک کریں کہ آیا عنصر موجود ہے یا نہیں۔",
        "Answer": "یقینا!ذیل میں ازگر میں ایک بلوم فلٹر کلاس کا ایک مثال عمل ہے ، جس میں عناصر داخل کرنے کے طریقے بھی شامل ہیں اور یہ چیک کریں کہ آیا عنصر موجود ہے یا نہیں: پائیتھون کوپی کوڈیمپورٹ ایم ایم ایچ 3 فریم بِٹرای امپورٹ بٹلری کلاس بلوم فلٹر: ڈیف __init __ (خود ، سائز ، نمبر ہش_فونیکٹس): سیلف۔ خود۔num_hash_functions = num_hash_functionself.bit_array = bitarray (size) self.bit_array.setall (0) Def داخل (خود ، عنصر): حد میں بیج کے لئے (self.num_hash_function): انڈیکس = ایم ایم ایچ 3. ہش (عنصر ، بیج) ٪ خود۔size self.bit_array [index] = 1 DEF پر مشتمل ہے (خود ، عنصر)"
    },
    {
        "Question": "وقفوں کی دی گئی فہرست میں زیادہ سے زیادہ اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "وقفوں کی دی گئی فہرست میں اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد تلاش کرنے کے ل we ، ہم سویپ لائن الگورتھم کے تصور کو استعمال کرسکتے ہیں۔ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈیڈف Find_max_overlaping_Intervals (وقفے): اگر وقفے نہیں تو: 0 واقعات کو واپس کریں = [] شروع کے لئے ، وقفوں میں ختم: واقعات.ایپینڈ ((اسٹارٹ ، 1)) واقعات ((اختتام ، -1)))) واقعات.سورٹ () میکس_ اوورلپس = 0 کریری_ اوورلپس = 0 _ کے لئے ، واقعات میں واقعہ: curr_overlaps += ایونٹ میکس_ اوورلپس = زیادہ سے زیادہ (زیادہ سے زیادہ_ اوورلپس ، کریری_ اوورلپس) واپسی میکس_ اوورلپسن اس عمل کو تلاش کریں ، `تلاش کریں` تلاش کریں"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر تینوں کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد تینوں کی طاقت ہے ، ہم اختیارات کی لوگرتھمک پراپرٹی استعمال کرسکتے ہیں۔یہاں ازگر میں ایک مثال عمل ہے: پائیتھون کوپی کوڈیمپورٹ ریاضی ڈیف IS_POWER_OF_THERE (N): اگر N <= 0: واپس جھوٹی پاور = ریاضی ۔لاگ (N ، 3) ریٹرن ریاضی (پاور ، راؤنڈ (پاور)) ، اس عمل میں ،IS_POWER_OF_THERE فنکشن ان پٹ کے طور پر ایک نمبر N لیتا ہے اور اگر N تینوں کی طاقت ہے ، اور دوسری صورت میں غلط ہے تو ، ہم اس بیس کیس کو سنبھالتے ہیں جہاں N 0 سے کم یا اس کے برابر ہے۔تین ہمیشہ مثبت ہوتے ہیں۔"
    },
    {
        "Question": "کسی دیئے گئے تار میں زیادہ تر K الگ الگ کرداروں کے ساتھ سب سے طویل پیلنڈرومک سٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "کسی دیئے گئے تار میں زیادہ تر K الگ الگ حروف کے ساتھ سب سے طویل پیلنڈرومک اسٹرنگ تلاش کرنے کے ل we ، ہم سلائیڈنگ ونڈو کے نقطہ نظر کو استعمال کرسکتے ہیں۔ازگر میں ایک مثال کے طور پر عمل درآمد: پائیتھون کوپی کوڈڈف طویل ترین_پالندروومک_سبسٹرینگ_ وِٹ_ڈسٹنٹ (ایس ، کے): اگر نہیں ہے یا K <1: ریٹرن \"\" شروع = 0 میکس_لنتھ = 0 میکس_سبسٹرینگ = \"\" چار_کاؤنٹ = {} رینج میں اختتام کے لئے (لن (ایس))): دائیں_چار = ایس [اختتام] چار_کاؤنٹ [رائٹ_چار] = چار_کاؤنٹ.بیٹ (دائیں_چار ، 0) + 1"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا تاثرات کی اجازت دی جاسکتی ہے ، ہم اسٹیک پر مبنی نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ازگر میں فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_براکیٹس = \"({[\" کلوزنگ_برکیٹس = \"\")}] \"اظہار میں چار کے لئے: اگر اوپننگ_برکیٹس میں چار: اسٹیک۔) الیف چار کلوزنگ_ برکیٹس میں: اگر اسٹیک نہیں ہے تو: غلط آخری_وپیننگ = اسٹیک.پپ () واپس کریں اگر اوپننگ_براکیٹس۔ انڈیکس۔ انڈیکس (آخری_ اوپننگ)! = کلوزنگ_برکیٹس۔ انڈیکس (چار): غلط ریٹرن لین (اسٹیک) == 0 اس پر عمل درآمد ، IS_Valid_expressionفنکشن ایک تار `اظہار لیتا ہے"
    },
    {
        "Question": "ایک سٹرنگ کو دو غیر خالی پیلنڈرومک سبسٹرنگز میں تقسیم کرنے کے طریقوں کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "تار کو دو غیر خالی پیلنڈرومک سبسٹرنگز میں تقسیم کرنے کے طریقوں کی تعداد تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں۔ازگر میں ایک مثال کے طور پر عمل درآمد ہے: پائیتھون کوپی کوڈڈف COUNT_PALINDROMIC_DIVIONS (S): N = LEN (S) DP = [[0] * N _ کے لئے _ کے لئے (N)] # I میں I کے لئے بیس مقدمات کی ابتداء کریں (N): DP [i] [i] = 1 # لمبائی کے لئے ڈی پی ٹیبل کی تعمیر (2 ، n + 1): میں رینج میں ہوں (n - لمبائی + 1): j = i + لمبائی - 1 اگر s [i] ==s [j]: # چیک کریں کہ اگر لمبائی == 2 یا DP [i [i"
    },
    {
        "Question": "وقفوں کی دی گئی فہرست میں زیادہ سے زیادہ تعداد میں غیر اوورلیپنگ وقفوں کی تلاش کے لئے ایک پروگرام بنائیں۔",
        "Answer": "وقفوں کی دی گئی فہرست میں غیر اوورلیپنگ وقفوں کی زیادہ سے زیادہ تعداد تلاش کرنے کے ل we ، ہم ان کے آخری نکات سے وقفوں کو چھانٹنے پر مبنی لالچی الگورتھم استعمال کرسکتے ہیں۔ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈ ڈیف Find_max_non_overlapple_intervals (وقفے): اگر وقفے نہیں تو: اگر نہیں تو وقفے: اختتام پوائنٹس کے وقفوں کے ذریعہ 0 # ترتیب دیں۔1] وقفوں میں وقفے کے لئے [1:]: اسٹارٹ = وقفہ [0] اگر"
    },
    {
        "Question": "لغت کے ترتیب میں عددیوں کی دی گئی فہرست کی اگلی اجازت پیدا کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "لغت کے ترتیب میں عددیوں کی دی گئی فہرست کی اگلی ترتیب پیدا کرنے کے ل we ، ہم مندرجہ ذیل الگورتھم کا استعمال کرسکتے ہیں: فہرست کے دائیں طرف سے شروع کریں اور ملحقہ عناصر کی پہلی جوڑی تلاش کریں جہاں بائیں عنصر دائیں عنصر سے چھوٹا ہے۔آئیے بائیں عنصر کی اشاریہ کو کال کریں۔ اگر اس طرح کی کوئی جوڑی موجود نہیں ہے تو ، اس کا مطلب ہے کہ دیئے گئے اجازت نامہ لغت کی ترتیب میں آخری اجازت ہے۔اس معاملے میں ، ہم پہلے پرمٹیشن کی نمائندگی کرتے ہوئے ، اوپر کی طرف سے فہرست کو واپس کرتے ہیں۔ اگر کوئی جوڑی مل جاتی ہے تو ، ہمیں بائیں عنصر کے دائیں طرف سب سے چھوٹا عنصر تلاش کرنے کی ضرورت ہے جو بائیں عنصر سے زیادہ ہے۔آئیے اس عنصر کے اشاریہ کو کال کریں۔"
    },
    {
        "Question": "ایک سرخ رنگ کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "اندراج اور تلاش کے طریقوں کے ساتھ مکمل سرخ سیاہ درخت کو نافذ کرنا ایک پیچیدہ کام ہے اور ایک ہی ردعمل کے دائرہ سے باہر ہے۔تاہم ، میں آپ کو تصور کا ایک جائزہ اور ازگر میں سرخ سیاہ درخت کا ایک آسان عمل درآمد فراہم کرسکتا ہوں۔ ریڈ-بلیک ٹری ایک خود توازن بائنری سرچ درخت ہے جو مخصوص رنگ اور گردش کے قواعد کا استعمال کرتے ہوئے توازن کو برقرار رکھتا ہے۔یہاں اندراج اور تلاش کے طریقوں کے ساتھ ایک آسان سرخ سیاہ درخت کلاس کا ایک مثال عمل ہے: پائیٹون کوپی کوڈکلاس ریڈ بلک ٹری: کلاس نوڈ: ڈیف __init __ (خود ، کلید): سیلف.کی.کی کی کلیدی = کلیدی خود نہیں۔حق = کوئی نہیں سیلف۔ کلر = \"سرخ\" # تمام نئے نوڈس ابتدائی طور پر رنگین ریڈ ڈیف __init __ (خود) ہیں:"
    },
    {
        "Question": "تین دیئے گئے تاروں کی طویل ترین مشترکہ حصول تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "تین دیئے گئے تاروں کی سب سے طویل عام مشترکہ (LCs) تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں۔ازگر میں اس پروگرام کے ایک مثال کے نفاذ: پائیتھون کوپی کوڈیڈف طویل ترین_کومون_سوبسینس (ایس ٹی آر 1 ، ایس ٹی آر 2 ، ایس ٹی آر 3): ایم ، این ، پی = لین (ایس ٹی آر 1) ، لین (ایس ٹی آر 2) ، لین (ایس ٹی آر 3) ڈی پی = [[[0] * (([0] * (p + 1) _ میں حد (n + 1)] _ کے لئے _ (M + 1)] کے لئے I (1 ، m + 1) کے لئے: J کے لئے رینج میں (1 ، n + 1): K کے لئےرینج میں (1 ، P + 1): اگر"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر چار کی طاقت ہے۔",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا کسی دیئے گئے نمبر کو چار کی طاقت ہے ، ہم مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: چیک کریں کہ آیا نمبر صفر سے زیادہ ہے یا نہیں۔ چیک کریں کہ اگر نمبر دو کی طاقت ہے تو اس بات کی تصدیق کرکے کہ اس کی بائنری نمائندگی میں صرف ایک بٹ سیٹ ہے۔ہم نمبر اور اس کے پیشرو (نمبر اور (نمبر - 1)) کے ساتھ بٹ وائز اور آپریشن (&) استعمال کرسکتے ہیں۔اگر نتیجہ صفر ہے تو ، نمبر دو کی طاقت ہے۔ چیک کریں اگر نمبر مائنس ایک (نمبر - 1) ہے"
    },
    {
        "Question": "\"ہر سکے کے فرق کی محدود فراہمی کے ساتھ ، تبدیلی کی ایک مقررہ رقم کے ل needed کم سے کم تعداد میں سکے تلاش کرنے کے لئے ایک پروگرام لکھیں۔\"",
        "Answer": "ایک مقررہ مقدار میں تبدیلی کے ل needed درکار سککوں کی کم سے کم تعداد تلاش کرنے کے ل we ، ہم ایک متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں جسے \"سکے تبدیلی\" مسئلہ کہا جاتا ہے۔یہاں ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف من_ کوائنز (سکے ، رقم): # ہر رقم کے لئے درکار سککوں کی کم سے کم تعداد کو ذخیرہ کرنے کے لئے ایک ٹیبل کی ابتدا کریں۔DP [0] = 0 سکے میں سکے کے لئے: I میں رینج (سکے ، رقم + 1) کے لئے: ڈی پی [i] = منٹ (ڈی پی [i] ، ڈی پی [i - سکے] + 1)"
    },
    {
        "Question": "ایک لاحقہ سرنی کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور ذیلی جگہوں کی تلاش کے ل methods طریقوں کو نافذ کریں۔",
        "Answer": "سٹرنگ تلاش کے طریقوں کے ساتھ ایک مکمل لاحقہ سرنی کلاس کو نافذ کرنا ایک پیچیدہ کام ہے اور ایک ہی ردعمل کے دائرہ سے باہر ہے۔تاہم ، میں آپ کو تصور کا ایک جائزہ اور ازگر میں لاحقہ سرنی کلاس کا ایک آسان عمل درآمد فراہم کرسکتا ہوں۔ ایک لاحقہ سرنی ایک ڈیٹا ڈھانچہ ہے جو ترتیب دیئے گئے ترتیب میں دیئے گئے تار کے تمام لاحقہ کو محفوظ کرتا ہے۔یہ لاحقہ پر بائنری سرچ آپریشنز انجام دے کر موثر اسٹرنگ کی تلاش کی اجازت دیتا ہے۔"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات کی اجازت دی جاسکتی ہے ، ہم اسٹیک پر مبنی نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ازگر میں فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_چارز = {'(' ، '،' ، '{' ، '،' '،' '،' '،' '،'/ '''} کلوزنگ_چارس = {') ':' ('،'] ':' ['،'} ':' {'،'> ':' <'،' '' '' '' '' '، \"\": \":\"'\"،'/':'/'} گھوںسلا_چارس = {'\" \"\" \"، '' ، '/'} اظہار کے لئے چار کے لئے: اگر اوپننگ_چارس میں چار: اسٹیک.ایپینڈ (چار) الیف چار میں بندیاں: اگر لین (اگر لین (اگراسٹیک) == 0 یا اسٹیک [-1]! = کلوزنگ_چارس [چار]:"
    },
    {
        "Question": "کسی دیئے گئے تار میں لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے لمبے حصے",
        "Answer": "دیئے گئے تار میں سب سے طویل پیلنڈرومک متضاد کی لمبائی تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھونکپی کوڈیڈف طویل ترین_پالندروومک_سوبسینس (ایس): این = لین (ایس) ڈی پی = [[0] * n رینج میں (این) کے لئے] # تمام انفرادی کردار لمبائی 1 کے لئے ہیں۔رینج (این) میں: ڈی پی [i] [i] = 1 # رینج میں سی ایل کے لئے اخترن ٹیبل کو بھریں (2 ، n + 1): میں رینج میں (n - cl + 1) کے لئے: j = i + cl -1 اگر s [i] == s [j] اور cl == 2: dp [i] [j] = 2 الیف s [i] == s [j]: dp [i] [j] = dp [i+ 1] [J - 1] + 2 اور: DP [i] [j] = زیادہ سے زیادہ"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں غیر اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عددیوں کی دی گئی فہرست میں نان اوورلیپنگ سبریوں کی زیادہ سے زیادہ رقم تلاش کرنے کے ل we ، ہم متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈ ڈیف میکس_سوم_نون_ اوورلیپنگ_سبریز (نمبرز ، کے): این = لین (نمبر) اگر این <K: واپس 0 # حساب کتاب کا حساب کتابی پہلے سے پہلے کی رقم = [0] * (n + 1) I in in in in in کے لئےرینج (1 ، این + 1): پریفکس_سوم [i] = پریفکس_سوم [i - 1] + نمبر [i - 1] # غیر اوورلیپنگ سبارری کی زیادہ سے زیادہ رقم کا حساب لگائیں dp = [0] * (n + 1) i کے لئےرینج میں (1 ، n + 1): dp [i] = dp [i - 1] اگر i> = k: dp [i] = زیادہ سے زیادہ (dp [i] ، dp"
    },
    {
        "Question": "مستقل وقت اور جگہ کی پیچیدگی میں عدد کے دھارے کے وسط کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "مستقل وقت اور جگہ کی پیچیدگی میں عددیوں کے دھارے کے وسط کو تلاش کرنے کے ل we ، ہم دو ڈھیر استعمال کرسکتے ہیں: نمبروں کے چھوٹے نصف حصے کو ذخیرہ کرنے کے لئے ایک زیادہ سے زیادہ ہیپ اور بڑے نصف حصے کو ذخیرہ کرنے کے لئے ایک منٹ ہیپ۔ان ڈھیروں کو برقرار رکھنے سے ، ہم مؤثر طریقے سے میڈین کو تلاش کرسکتے ہیں۔ یہاں تک کہ ازگر میں اس فنکشن کا ایک مثال عمل: پائیٹون کوپی کوڈیمپورٹ ہیپک کلاس میڈین فائنڈر: ڈیف __init __ (خود):"
    },
    {
        "Question": "ایک ازگر کلاس لکھیں جو ایک ناگوار سیٹ ڈیٹا ڈھانچے کی نمائندگی کرتے ہیں اور یونین کو انجام دینے اور آپریشن تلاش کرنے کے طریقوں کو نافذ کرتے ہیں۔",
        "Answer": "یقینا!یہاں ازگر میں ایک ناپسندیدہ سیٹ ڈیٹا ڈھانچے کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ڈسکشن سیٹ: ڈیف __init __ (خود ، سائز): سیلف پیئرنٹ = فہرست (حد (سائز)) سیلف۔ آرک = [0] * سائز ڈیف تلاش (خود، x): اگر self.palent [x]! = x: # راہ کمپریشن سیلف۔ پیرنٹ [x] = self.find (self.parent [x]) خود واپس.Y): جڑ_ x = self.find (x) روٹ_ی = سیلف۔ فائنڈ (y) اگر جڑ_ x == روٹ_ی: لوٹ اگر سیلف۔ رینک [روٹ_ ایکس] <سیلف_راینک [روٹ_ی]: سیلف۔پیرینٹ [روٹ_ ایکس] = روٹ_ی ایلفself.rank [روٹ_ ایکس]> خود"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا دیئے گئے نمبر بٹ وائز آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا ایک مثال عمل ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دی گئی تعداد ازگر میں بٹ وائس آپریشنز کا استعمال کرتے ہوئے دو کی طاقت ہے: پائیتھون کوپی کوڈیڈف IS_POWER_OF_TWO (n): اگر n <= 0: غلط واپسی (n & (n - 1)) == 0 # مثال کے استعمال: نمبر = 16 ریزولٹ = is_power_of_two (num) پرنٹ (نتیجہ) # آؤٹ پٹ: truenum = 10result = is_power_of_two (num) پرنٹ (نتیجہ) پرنٹ (نتیجہ) # آؤٹ پٹ: اس پر عمل درآمد کو غلط ، is_power_of_two فنکشن ان پٹ کے طور پر ایک عددی n لیتا ہے اوریہ چیک کرنے کے لئے بٹ وائس آپریشنز کا استعمال کریں کہ آیا یہ دو کی طاقت ہے۔ حالت (N & (n - 1))) == 0 چیک اگر n اور `n -"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ سب سے طویل عرصہ تک بڑھتے ہوئے سبری کو تلاش کریں جس میں زیادہ تر K الگ الگ انٹیجرس انٹیجرز کی ایک فہرست میں شامل ہوں۔",
        "Answer": "انٹیجرز کی ایک دی گئی فہرست میں زیادہ تر K الگ الگ عدد کے ساتھ سب سے طویل عرصے تک بڑھتے ہوئے سبری کو تلاش کرنے کے ل we ، ہم سلائیڈنگ ونڈو نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈڈیف سب سے طویل_increasing_subarray (nums ، K): اگر K <= 0: واپسی [] شروع = 0 میکس_ لمبائی = 0 الگ الگ_کاؤنٹ = 0 الگ الگ_انٹیجرز = {} رینج کے اختتام کے لئے (لین (نمبر)): الگ الگ_ٹینجرز [نمبر [اختتام]] = الگ الگ_ٹینجرز.ایٹ (نمبر [اختتام] ، 0) + 1 جبکہ الگ الگ_اونٹ> K: الگ الگ_ٹینجرز [نمبر [اسٹارٹ]] -= 1 اگر الگ الگ_ٹینجرز [نمبر [آغاز]] == 0:"
    },
    {
        "Question": "\"دیئے گئے تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں ، جہاں ہر خط کو ایک نمبر (A = 1 ، B = 2 ، وغیرہ) میں نقش کیا جاتا ہے۔\"",
        "Answer": "کسی دیئے گئے تار کو ڈی کوڈ کرنے کے طریقوں کی تعداد تلاش کرنے کے ل where ، جہاں ہر خط کو ایک نمبر (A = 1 ، B = 2 ، وغیرہ) میں نقش کیا جاتا ہے ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔یہاں ازگر میں فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف نمبر_ڈیکوڈنگز (s): n = len (s) اگر n == 0 یا s [0] == '0': واپس 0 dp = [0] * (n + (n +)1) ڈی پی [0] = 1 ڈی پی [1] = 1 میں I کے لئے (2 ، n + 1): اگر s [i - 1]! = '0': dp [i] + = dp [i - 1 - 1] دو_ڈیجٹ"
    },
    {
        "Question": "اس رکاوٹ کے ساتھ مل کر زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام لکھیں کہ اس کے بعد میں کوئی دو عناصر ملحقہ نہیں ہیں۔",
        "Answer": "اس رکاوٹ کے ساتھ مل کر زیادہ سے زیادہ رقم تلاش کرنے کے لئے کہ اس کے بعد میں کوئی دو عناصر ملحقہ نہیں ہیں ، ہم متحرک پروگرامنگ استعمال کرسکتے ہیں۔یہاں ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف میکس_سوم_سوبسینس (اے آر آر): این = لین (آر آر) اگر این == 0: واپس 0 اگر ن == 1: واپسی ار (0] ڈی پی = [0] * این ڈی پی[0] = آر آر [0] ڈی پی [1] = زیادہ سے زیادہ (آر [0] ، آر [1]) میں رینج (2 ، این) کے لئے: ڈی پی [i] = زیادہ سے زیادہ (ڈی پی [I-1] ، ڈی پی[میں-"
    },
    {
        "Question": "\"2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں جزیروں کی تعریف '1 کے منسلک علاقوں سے ہوتی ہے ، لیکن اخترن رابطوں پر غور نہیں کیا جاتا ہے۔\"",
        "Answer": "2D گرڈ میں جزیروں کی تعداد تلاش کرنے کے لئے ، جہاں جزیروں کی وضاحت '1 کے (افقی یا عمودی طور پر) کے منسلک علاقوں سے کی جاتی ہے ، لیکن اخترن رابطوں پر غور نہیں کیا جاتا ہے ، ہم گہرائی سے پہلے تلاش (DFS) الگورتھم استعمال کرسکتے ہیں۔ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف نمبر_س لینڈز (گرڈ): اگر گرڈ نہیں ہے یا گرڈ نہیں ہے [0]: واپس 0 نمبر_روز = لین (گرڈ) نمبر_کولز = لین (گرڈ [0]) گنتی = 0 ڈیف ڈی ایف ایس (قطار ، کرنل"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کی اجازت ملتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور آپریٹرز کی اجازت ملتی ہے ، ہم اسٹیک ڈیٹا ڈھانچہ استعمال کرسکتے ہیں۔یہاں ازگر میں فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف is_valid_expression (s): اسٹیک = [] افتتاحی_براکیٹس = {'(' ، '،' ، '{'} بند_برکیٹس = {')'] '،'] ، '}'} مماثل_برکیٹس = {'(': ')' ، '[': ']' ، '{': '}': '}'} چار میں چار کے لئے: اگر اوپننگ_برکیٹس میں چار: اسٹیک.اپینڈ (چار) الیف چار میں بند_بریکٹ: اگراسٹیک یا مماثل_براکیٹس نہیں [اسٹیک.پپ ()]! = چار: غلط واپسی لین (اسٹیک) == 0# مثال کے استعمال: اظہار: اظہار"
    },
    {
        "Question": "طبقہ کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور اقدار کو اپ ڈیٹ کرنے کے طریقوں کو نافذ کریں اور حدود کی رقم کے لئے استفسار کریں۔",
        "Answer": "یقینا!یہاں ایک ازگر کی کلاس ہے جو ایک طبقہ کے درخت کی نمائندگی کرتی ہے جس میں اقدار کو اپ ڈیٹ کرنے کے طریقوں اور رینج کے لئے استفسار کیا جاتا ہے۔self.n) self.construct_tree (arr ، 0 ، self.n - 1 ، 0) Def Construct_tree (خود ، arr ، شروع ، اختتام ، انڈیکس): اگر اسٹارٹ == اختتام: سیلف ٹری [انڈیکس] = آر (شروع کریں] واپس وسط = (اسٹارٹ + اینڈ) // 2 سیلف ۔کانسٹرکٹ_ٹری (آر آر ، اسٹارٹ ، مڈ ، 2 * انڈیکس + 1) سیلف۔ کنسٹرکٹ_ٹری (آر آر ، مڈ + 1 ، اختتام ، 2 * انڈیکس + 2) سیلف۔ ٹری [اشاریہ]"
    },
    {
        "Question": "عدد کی دی گئی فہرست کو ترتیب دینے کے لئے درکار کم سے کم تعداد میں تبدیلیاں تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "عددیوں کی دی گئی فہرست کو ترتیب دینے کے لئے درکار تبدیلیاں کی کم سے کم تعداد تلاش کرنے کے ل we ، ہم گراف سائیکل کے تصور کو استعمال کرسکتے ہیں۔ہر سائیکل عناصر کے ایک سیٹ کی نمائندگی کرتا ہے جس کو ترتیب دیئے گئے ترتیب تک پہنچنے کے لئے تبدیل کرنے کی ضرورت ہے۔یہاں ازگر میں پروگرام کا ایک مثال عمل ہے: پائیتھونکوپی کوڈیڈف من_سوپس (اے آر آر):"
    },
    {
        "Question": "دو دیئے گئے ڈوروں کی سب سے طویل عام مشترکہ تلاش کے ل a ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں دو دیئے گئے تاروں کی سب سے لمبی عام مشترکہ حصول تلاش کرنے کے لئے ایک فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈڈیف طویل ترین_کومون_سوبسینس (ایس ٹی آر 1 ، ایس ٹی آر 2): ایم = لین (ایس ٹی آر 1) این = لین (ایس ٹی آر 2) # لمبائی کو ذخیرہ کرنے کے لئے ایک جدول بنائیںسب سے طویل عام مشترکہ DP = [[0] * (n + 1) _ کے لئے _ کے لئے (M + 1)] # رینج (1 ، M + 1) کے لئے ٹیبل کے نیچے کو بھریں (1 ، M + 1)1 ، n + 1): اگر str1 [i - 1] == str2 [j - 1]: dp [i] [j] = dp [i - 1] [j - 1] + 1 اور: dp [i][j] = زیادہ سے زیادہ (dp [i - 1] [j"
    },
    {
        "Question": "\"عددیوں کی دی گئی فہرست میں ریاضی کے ٹکڑوں کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں ، جہاں ایک ریاضی کا ٹکڑا ایک متنازعہ سبری ہے جس میں کم از کم تین عناصر ایک ہی فرق رکھتے ہیں۔\"",
        "Answer": "یقینا!یہاں ایک پروگرام کا ایک مثال عمل ہے"
    },
    {
        "Question": "نوڈس کو داخل کرنے اور تلاش کرنے کے لئے بی ٹری کی نمائندگی کرنے والے ایک ازگر کی کلاس بنائیں اور طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!نوڈس کو داخل کرنے اور تلاش کرنے کے طریقوں کے ساتھ ازگر میں بی ٹری کلاس کا ایک مثال عمل ہے: پائیٹون کوپی کوڈکلاس بٹرینوڈ: ڈیف __init __ (خود ، پتی = غلط)= لیف ڈیف داخل کریں_نون_فل (خود ، کلید): i = len (self.keys) - 1 اگر self.leaf: self.keys.append (کوئی نہیں) جبکہ i> = 0 اور کلیدی <سیلف.کیئز [i]: خود۔چابیاں [i + 1] = self.keys [i] i -= 1 self.keys [i + 1] = کلید اور: جبکہ i> = 0 اور key <self.keys [i]: i -= 1 اگر لین(سیلف۔ چائلڈ [i +"
    },
    {
        "Question": "کسی فنکشن کو اس بات کی جانچ پڑتال کریں کہ آیا کوئی دی گئی تعداد کسی دوسرے نمبر کی طاقت ہے یا نہیں۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا ایک مثال عمل ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا کوئی دیئے گئے نمبر ازگر میں کسی بھی دوسرے نمبر کی طاقت ہے: پائیتھون کوپی کوڈیڈف is_power_of (نمبر ، بیس): اگر num <= 0 یا بیس <= 1: جھوٹی طاقت = 1 جبکہ پاور واپس لوٹائیں۔<نمبر: پاور *= بیس ریٹرن پاور == NUM # مثال کے استعمال: نمبر = 16 بیس = 2result = is_power_of (نمبر ، بیس) پرنٹ (نتیجہ) # آؤٹ پٹ: truenum = 27base = 3Result = is_power_of (num ، بیس) پرنٹ (نتیجہ (نتیجہ)) # آؤٹ پٹ: truenum = 10base = 2result = is_power_of (num ، بیس) پرنٹ (نتیجہ) # آؤٹ پٹ: فالین"
    },
    {
        "Question": "\"ایک پروگرام لکھیں تاکہ کسی سبری کی زیادہ سے زیادہ رقم کو اس رکاوٹ کے ساتھ تلاش کیا جاسکے کہ سبری میں کوئی دو عناصر ملحقہ نہیں ہیں ، اور سبری اس فہرست کے اختتام پر لپیٹ سکتا ہے۔\"",
        "Answer": "یقینا!ازگر میں ایک مثال کا پروگرام یہ ہے جس میں اس رکاوٹ کے ساتھ ایک سبری کا زیادہ سے زیادہ مجموعہ پایا جاتا ہے کہ سبری میں کوئی دو عناصر ملحق نہیں ہیں ، اور سب رے اس فہرست کے اختتام کے گرد لپیٹ سکتا ہے: پائیتھون کوپی کوڈڈیف میکس_سم_نو_ ایڈجینٹ (اے آر آر): این = لین (این = لین (arr) if n == 0: واپس 0 اگر n == 1: واپسی arr [0] # زیادہ سے زیادہ رقم کا حساب لگائیں جس میں زیادہ سے زیادہ_سم = زیادہ سے زیادہ (arr [0] ، arr [1]) prev_max_sum = arr [0] i in in کے لئےرینج (2 ، این): curr_max_sum = زیادہ سے زیادہ (prev_max_sum + arr [i] ، میکس_سم"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں متحرک پروگرامنگ کا استعمال کرتے ہوئے کسی دیئے گئے نمبر تک فبونیکی تسلسل کا حساب لگانے کے لئے کسی فنکشن کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف فائبونیکی (این): اگر n <= 0: واپسی [] fib = [0 ، 1] # فبونیکی کو شروع کریںبیس معاملات کے ساتھ ترتیب جبکہ ایف آئی بی [-1] <n: # دیئے گئے نمبر fib.append (fib [-1] + fib [-2]) ریٹرن فب [:-1] # کو ہٹا دیںآخری عنصر اگر یہ دیئے گئے نمبر# مثال کے استعمال سے تجاوز کرتا ہے: n = 100fib_sercoence = fibonacci (n) پرنٹ (fib_secence) اس عمل میں ، fibonacci فنکشن ان پٹ کے طور پر ایک مثبت عددی n لیتا ہے اور دیئے گئے نمبر پر فبونیکی ترتیب کو واپس کرتا ہے۔پہلے دو نمبر ، 0 اور 1 کے ساتھ فبونیکی تسلسل کا آغاز کریں ، پھر ، ہم تسلسل میں آخری دو نمبر شامل کرکے اگلے فبونیکی نمبروں کو مستقل طور پر تیار کرتے ہیں جب تک کہ ترتیب میں آخری نمبر دیئے گئے نمبر N سے زیادہ نہ ہو۔آخر میں ، ہم آخری عنصر کو تسلسل سے ہٹا دیتے ہیں اگر یہ N. آپ سے زیادہ ہو تو آپ اپنے مثبت انٹیجر این کو فراہم کرکے اور فبونیکی فنکشن کو کال کرنے کے لئے فبونیکی سلسلے کا حساب کتاب کرنے کے لئے جانچ سکتے ہیں۔نتیجے میں فبونیکی ترتیب FIB_SECANCE متغیر میں محفوظ کی جائے گی اور اسے پرنٹ یا مزید پروسیسنگ کے لئے استعمال کیا جاسکتا ہے۔"
    },
    {
        "Question": "سب سے بڑا پرائم پیلنڈرووم کسی دیئے گئے نمبر سے کم تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ازگر میں ایک مثال کا پروگرام یہ ہے جس میں ایک دیئے گئے نمبر سے کم سب سے بڑا پرائم پیلنڈرووم مل جاتا ہے: پائیتھون کوپی کوڈیڈف آئی ایس_ پرائم (این): اگر ن <2: رینج میں I کے لئے جھوٹی لوٹ (2 ، انٹ (این ** 0.5) + 1):اگر n ٪ i == 0: واپس غلط ریٹرن ٹریوڈیف is_palindrome (n): واپسی str (n) == str (n) [:: - 1] Def سب سے بڑا_پائیم_پالندرووم (حد): حد میں نمبر (حد - 1 ، 0، -1): اگر is_palindrome (num) اور is_prime (num): واپسی نمبر واپسی کوئی نہیں# مثال کے استعمال: حد = 1000 ریزولٹ = سب سے بڑی_پائرم_پالنڈرووم (حد) پرنٹ (\"سب سے بڑا پرائم پیلنڈرووم\" ، حد سے کم: \"، نتیجہ سے کم ہے:\" ، نتیجہجیز"
    },
    {
        "Question": "ایک ازگر کی کلاس بنائیں جو خود توازن بائنری سرچ درخت (جیسے AVL درخت یا سرخ رنگ کے درخت) کی نمائندگی کرتی ہے اور نوڈس کو داخل کرنے اور تلاش کرنے کے طریقے نافذ کریں۔",
        "Answer": "کسی AVL درخت یا سرخ رنگ کے درخت کی طرح خود متوازن بائنری سرچ درخت کو نافذ کرنا ایک پیچیدہ کام ہے جس کے لئے بنیادی الگورتھم کی تفصیلی تفہیم کی ضرورت ہوتی ہے۔یہ یہاں ایک ہی ردعمل کے دائرہ کار سے باہر ہے۔تاہم ، میں آپ کو اس میں شامل اقدامات کا ایک اعلی سطحی جائزہ فراہم کرسکتا ہوں اور آپ کو بیرونی وسائل کی طرف راغب کرتا ہوں جہاں آپ کو تفصیلی عمل درآمد مل سکتا ہے۔ بائنری سرچ ٹری کے لئے ایک کلاس اور درختوں کے نوڈس کے لئے ایک علیحدہ کلاس کی وضاحت کریں۔ہر نوڈ کو اپنی کلید ، قیمت ، بائیں بچے ، دائیں بچے ، اور توازن کے ل required درکار اضافی خصوصیات کو ذخیرہ کرنا چاہئے۔ درخت کو توازن پیدا کرنے کے لئے گردش کی کارروائیوں کو متاثر کریں۔"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی بلٹ ان فنکشن استعمال کیے بغیر دیئے گئے نمبر ایک بہترین مربع ہے یا نہیں۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا ایک مثال عمل ہے جس کی جانچ پڑتال کے لئے کہ آیا کوئی دیئے گئے نمبر کسی بلٹ ان فنکشن کا استعمال کیے بغیر ایک بہترین مربع ہے: پائیٹون کوپی کوڈ ڈیف"
    },
    {
        "Question": "دو دیئے گئے ڈوروں کی سب سے طویل عام سبسٹرنگ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ازگر میں ایک مثال کا پروگرام یہ ہے جس میں دو دیئے گئے تاروں کی سب سے طویل عام سبسٹرنگ ملتی ہے: پائیتھون کوپی کوڈڈیف طویل ترین_کومون_سبسٹرنگ (ایس ٹی آر 1 ، ایس ٹی آر 2): ایم = لین (ایس ٹی آر 1) این = لین (ایس ٹی آر 2) # مشترکہ سبسٹرنگز ٹیبل کی لمبائی کو ذخیرہ کرنے کے لئے ایک جدول بنائیں۔= [[0] * (n + 1) _ کے لئے حد (M + 1)] # متغیرات کو سب سے طویل عام سبسٹرنگ اور اس کی لمبائی میکس_ لمبائی = 0 end_index = 0 # میں متحرک پروگرامنگ کا استعمال کرتے ہوئے ٹیبل کو بھرنے کے ل.رینج (1 ، ایم + 1): کے لئے"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!ازگر میں ایک مثال کا پروگرام یہ ہے جس میں عددیوں کی ایک دی گئی فہرست میں دو نمبروں کی زیادہ سے زیادہ XOR قیمت ملتی ہے: پائیٹون کوپی کوڈکلاس ٹرائنوڈ: DEF __INIT __ (خود)"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا دیئے گئے تار متوازن قوسین ، بریکٹ اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کو پیش نظارہ کیا جاسکتا ہے۔\"",
        "Answer": "یقینا!یہاں ایک فنکشن کا ایک مثال عمل ہے جس کی جانچ پڑتال کے لئے کہ آیا کوئی دیئے گئے تار متوازن قوسین ، بریکٹ ، اور گھوبگھرالی منحنی خطوط وحدانی کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کی پیشگی پیش کی جاسکتی ہے: پائیٹون کوپی کوڈ ڈیف آئی ایس_والیڈ_ ایکسپریشن (اظہار): اسٹیک = [] اوپن_بریکٹ = \"([{\"قریب_برکیٹس =\")]} \"پیش نظارہ = {'+': 1 ، '-': 1 ، '*': 2 ، '/': 2} اظہار کے لئے چار کے لئے: اگر اوپن_ برکیٹس میں چار: اسٹیک۔اپینڈ (چار) الیف چار کو قریب_برکیٹس میں: اگر اسٹیک یا اسٹیک نہیں ہے۔"
    },
    {
        "Question": "موثر سابقہ تلاش اور الفاظ کی گنتی کی حمایت کے ساتھ ایک ٹری (سابقہ درخت) کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں۔",
        "Answer": "یقینا!موثر پریفکس تلاش اور الفاظ کی گنتی کی حمایت کے ساتھ ایک ٹری (سابقہ درخت) کی نمائندگی کرنے والے ایک ازگر کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ٹرائنوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈین = {{} خود.(خود): self.root = trienode () Def داخل کریں (خود ، لفظ): نوڈ ="
    },
    {
        "Question": "\"ایک مقررہ تعداد کے ساتھ سیڑھیاں چڑھنے کے لئے الگ الگ طریقوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں آپ ایک وقت میں 1 یا 2 قدم اٹھاسکتے ہیں۔\"",
        "Answer": "یقینا!یہاں ایک مخصوص تعداد کے ساتھ سیڑھیاں چڑھنے کے لئے الگ الگ طریقوں کی تعداد تلاش کرنے کے لئے ایک مثال پروگرام ہے ، جہاں آپ ایک وقت میں 1 یا 2 قدم اٹھاسکتے ہیں: پائیٹون کوپی کوڈ ڈیف کاؤنٹ ڈسٹ ویز (این): اگر n == 0 یا n == 1: واپس 1 اور: # میمورائزیشن ٹیبل میمو کو شروع کریں میمو = [0] * (n + 1) # بیس کیسز میمو کو سیٹ کریں [0] = 1 میمو [1] = 1 # i کے لئے متحرک پروگرامنگ کا استعمال کرتے ہوئے الگ الگ طریقوں کی گنتی کریں۔رینج میں (2 ، n + 1): میمو [i] = میمو [i - 1] + میمو [i - 2] میمو کی واپسی [n]# مثال کے استعمال: اقدامات = 5distinct_ways = کاؤنٹ ڈسٹ ویز (اقدامات) پرنٹ (\"کی تعداد (\" \"اس پروگرام میں ، چڑھنے کے الگ الگ طریقے \"، اقدامات ،\" اقدامات: \"، الگ الگ_ایس) ، کاؤنٹ ڈسٹ ویز فنکشن ان پٹ کے طور پر اقدامات کی تعداد لیتا ہے اور سیڑھیاں پر چڑھنے کے الگ الگ طریقوں کی تعداد کو واپس کرتا ہے۔"
    },
    {
        "Question": "یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا دیئے گئے نمبر لوگاریتھمک ٹائم پیچیدگی کا استعمال کرتے ہوئے کسی اور نمبر کی طاقت ہے یا نہیں۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ ہے جو چیک کرتا ہے کہ اگر کسی دیئے گئے نمبر کو لاگ ان کے وقت کی پیچیدگی کا استعمال کرتے ہوئے کسی اور نمبر کی طاقت ہے: پائیٹون کوپی کوڈیمپورٹ ریاضی ڈیف آئس پاوروفانوتھورنمبر (نمبر): اگر نمبر <= 0 یا بیس <= 1: غلط طاقت = ریاضی واپس کریں۔لاگ (نمبر ، بیس) ریاضی کی واپسی۔num = 27base = 3 پرنٹ (نمبر ، \"\" ، بیس ، \"کی طاقت ہے ،\" ، ispowerofanothernumber (num ، base)) num"
    },
    {
        "Question": "اونچائیوں کی ایک دی گئی فہرست میں ہسٹگرامس کے ذریعہ تشکیل شدہ مستطیل کا زیادہ سے زیادہ رقبہ تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!اونچائیوں کی ایک دی گئی فہرست میں ہسٹگرامس کے ذریعہ تشکیل پانے والے مستطیل کا زیادہ سے زیادہ رقبہ تلاش کرنے کے لئے یہاں ایک مثال پروگرام ہے: پائیتھون کوپی کوڈ ڈیف فائنڈ میکس ریکٹنگلیا (ہائٹس): اگر اونچائی نہیں تو: واپس 0 میکسیریا = 0 اسٹیک = [] i = 0 جبکہ میں <لین (واپس (واپس کریں۔اونچائی): اگر اسٹیک یا اونچائی نہیں ہے [i]> = اونچائی [اسٹیک [-1]]: اسٹیک.ایپینڈ (i) i += 1 اور: ٹاپ = اسٹیک.پپ () چوڑائی = i اگر اسٹیک نہیں ہے تو میں -اسٹیک [-1] - 1 ایریا = اونچائی [اوپر] * چوڑائی میکسیریا = زیادہ سے زیادہ (میکسیریا ، ایریا) جبکہ اسٹیک: ٹاپ = اسٹیک.پپ () چوڑائی = i اگر اسٹیک نہیں ہے تو لین (اونچائی) - اسٹیک [-1]- 1"
    },
    {
        "Question": "ایک گراف کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور ڈیجکسٹرا کے الگورتھم کا استعمال کرتے ہوئے دو عمودیوں کے مابین مختصر ترین راستہ تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!دو عمودیوں کے مابین مختصر ترین راستہ تلاش کرنے کے لئے گراف کی نمائندگی کرنے اور ڈیجکسٹرا کے الگورتھم کو نافذ کرنے والے ایک ازگر کلاس کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیمپورٹ ہیپکلاس گراف: ڈیف __init __ (خود): سیلف۔.ٹائٹس [ورٹیکس] = {} ڈیف ایڈ_ج (خود ، شروع ، اختتام ، وزن): سیلف.ورٹیکس [اسٹارٹ] [اختتام] = وزن خود۔): فاصلوں = {ورٹیکس: سیلف ورٹیکس میں ورٹیکس کے لئے فلوٹ ('انف')} فاصلوں [شروعات] = 0 ترجیحی_کیو = [(0 ، اسٹارٹ)] ملاحظہ = سیٹ () جبکہ ترجیحی_کیو:"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے انٹیجرز کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!متحرک پروگرامنگ کا استعمال کرتے ہوئے عددیوں کی ایک دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے یہاں ایک فنکشن کا نفاذ ہے: پائیتھون کوپی کوڈ ڈیف Find_longest_increasing_subsence (Nums): اگر NUS نہیں: واپسی [] n = لین (نمبر) ڈی پی = [1] * این #تمام عناصر کے ساتھ ڈی پی سرنی کا آغاز 1 کے لئے 1 کے طور پر (1 ، این): رینج میں جے کے لئے (i): اگر نمبر [i]> نمبر [j]: dp [i] = زیادہ سے زیادہ (DP [i] ،DP [J] + 1) میکس_ لمبائی = زیادہ سے زیادہ (DP) # بڑھتی ہوئی بعد کی زیادہ سے زیادہ لمبائی میکس_ انڈیکس = DP.index (میکس_ لمبائی) کی زیادہ سے زیادہ لمبائی تلاش کریں # طویل عرصے تک آخری عنصر کی اشاریہ تلاش کریں # طویل ترین بڑھتی ہوئی بعد کی سب سے لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی لمبی تنظیم نو تشکیل دیں =[نمبر [میکس_ انڈیکس]]"
    },
    {
        "Question": "منفرد بی ایس ٹی (بائنری سرچ درختوں) کی تعداد تلاش کرنے کے لئے ایک پروگرام لکھیں جو نوڈس کی دی گئی تعداد کے ساتھ تشکیل دی جاسکتی ہے۔",
        "Answer": "یقینا!منفرد بی ایس ٹی (بائنری سرچ درختوں) کی تعداد تلاش کرنے کے لئے یہاں ایک پروگرام ہے جو نوڈس کی ایک بڑی تعداد کے ساتھ تشکیل دیا جاسکتا ہے: پائیتھون کوپی کوڈڈیف COUNT_UNIQUE_BSTS (n): اگر n <= 1: واپس 1 # 1 # ایک فہرست بنائیں ایک فہرست بنائیں جس کی تعداد کو ذخیرہ کرنے کے لئے ایک فہرست بنائیں۔نوڈس کی ہر تعداد کے لئے منفرد BSTs منفرد_بسٹس = [0] * (n + 1) منفرد_بسٹس [0] = 1 منفرد_بسٹس [1] = 1 # رینج میں نمبر_نوڈس کے لئے 2 سے N سے N سے N کے لئے نوڈس کی ہر تعداد کے لئے منفرد BSTs کی تعداد کا حساب لگائیں."
    },
    {
        "Question": "اسٹیک پر مبنی نقطہ نظر کا استعمال کرتے ہوئے بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!اسٹیک پر مبنی نقطہ نظر کا استعمال کرتے ہوئے بائنری میٹرکس میں 1s کا سب سے بڑا آئتاکار علاقہ تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیٹون کوپی کوڈڈیف سب سے بڑا_ریکٹیننگ_اریہ (میٹرکس): اگر میٹرکس نہیں ہے یا میٹرکس نہیں ہے [0].== 0: ہسٹگرام [j] = 0 اور: ہسٹگرام [j] += 1 علاقہ = سب سے بڑا_راٹینگلنگ_ایریا_ن_ہسٹوگرام (ہسٹوگرام) میکس_اریا = میکس_یریا (میکس_یریا ، علاقہ) میکس_آرڈیف سب سے زیادہ_ریکٹینج_ریا_ہسٹگرام (اونچائی): اسٹیک = [] زیادہ سے زیادہ)"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھریلو تاثرات اور آپریٹرز کی پیش کش کی جاسکتی ہے۔\"",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس کی وجہ سے گھوںسلا اظہار اور آپریٹرز کی پیش کش ہے: پائیٹون کوپی کوڈیڈف آئی ایس_والیڈ_یکسپریشن (اظہار): اسٹیک= [] افتتاحی_چارز = '([{<\"' کلوزنگ_چارز = ')]]}>\"]' آپریٹرز = '+-*/' اس سے بچ گئے = اظہار میں چار کے لئے غلط: اگر فرار ہوگیا: فرار ہوا = غلط جاری رکھیں اگر چار == '\\\\ ': فرار = سچ جاری کریں اگر اوپننگ_چارس میں چار: اسٹیک.اپی اینڈ (چار) الیف چار میں بند_چارس میں: اگر اسٹیک یا کلوزنگ_چارس نہیں۔ انڈیکس (چار)!آپریٹرز میں چار: اگر اسٹیک نہیں ہے"
    },
    {
        "Question": "موثر اضافے اور ممبرشپ چیک کے لئے تعاون کے ساتھ بلوم فلٹر کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں۔",
        "Answer": "یقینا!یہاں موثر اضافے اور ممبرشپ کی حمایت کے ساتھ ازگر میں ایک بلوم فلٹر کا نفاذ ہے چیک: پیتھون کوپی کوڈیمپورٹ ایم ایم ایچ 3 فریم بٹلری امپورٹ بٹلری کلاس بلوم فلٹر: ڈیف __init __ (خود ، سائز ، num_hash_function): خود۔Bitarray (size) self.bit_array.setall (0) Def (خود ، آئٹم): حد میں بیج کے لئے (sell"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے دیئے گئے اسٹرنگ میں الگ الگ حصوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "یقینا!متحرک پروگرامنگ کا استعمال کرتے ہوئے کسی دیئے گئے تار میں الگ الگ حصوں کی تعداد تلاش کرنے کے لئے ایک پروگرام کا نفاذ ہے: پائیٹون کوپی کوڈڈیف COUNT_DISTINCT_SUBCENSES (s): n = len (s) # الگ الگ متضاد DP = [0] کی تعداد کو ذخیرہ کرنے کے لئے ایک ٹیبل بنائیں۔* (n + 1) # صرف ایک خالی مشترکہ ڈی پی ہے [0] = 1 # رینج (1 ، n + 1) کے لئے تار کے کرداروں کے ذریعے تکرار (1 ، n + 1): # موجودہ کردار ڈی پی کی گنتی کو شروع کریں [i] = 1 # رینج (i - 1 ، -1 ، -1) کے لئے موجودہ کردار کے پچھلے واقعے کی اشاریہ تلاش کریں: اگر s [j] == s [i - 1]:"
    },
    {
        "Question": "کسی فنکشن کو یہ چیک کرنے کے لئے نافذ کریں کہ آیا کوئی دی گئی تعداد ایرٹوسٹینز الگورتھم کی چھلنی کا استعمال کرتے ہوئے ایک اہم نمبر ہے۔",
        "Answer": "یقینا!یہاں کسی فنکشن کا نفاذ یہ ہے کہ آیا کسی دیئے گئے نمبر کو ایرٹوسٹینز الگورتھم کی چھلنی کا استعمال کرتے ہوئے ایک اہم نمبر ہے: پائیتھون کوپی کوڈیڈف آئی ایس_پائم (این): اگر این <= 1: غلط # پرائم نمبرز کو ٹریک کرنے کے لئے ایک بولین صف بنائیں IS_PRIME = [سچ] * (n + 1) is_prime [0] = is_prime [1] = غلط # eratosthenes الگورتھم p = 2 کی چھلنی کا اطلاق کریں جبکہ p * p <= n: اگر is_prime [p]: کیونکہ میں حد میں ہوں (p *پی ، این + 1 ، پی): is_prime [i] = غلط p + = 1 واپسی is_prime [n]# مثال کے استعمال: نمبر = 17if"
    },
    {
        "Question": "\"عددیوں کی دی گئی فہرست کے اختتام تک کم سے کم چھلانگ کی تلاش کے ل a ایک پروگرام لکھیں ، جہاں ہر عدد زیادہ سے زیادہ تعداد میں مراحل کی نمائندگی کرتا ہے جو اس پوزیشن سے چھلانگ لگائے جاسکتے ہیں۔\"",
        "Answer": "یقینا!عددیوں کی دی گئی فہرست کے اختتام تک پہنچنے کے لئے کم سے کم چھلانگوں کی تلاش کے ل a ایک پروگرام کا نفاذ ہے: پائیٹون کوپی کوڈیڈف من_جمپ (نمبر): این = لین (نمبر) # کم سے کم چھلانگ چھلانگ کو اسٹور کرنے کے لئے ایک ٹیبل بنائیں=.j]> = i: # اگر پوزیشن J پوزیشن I تک پہنچ سکتی ہے ، # اپ ڈیٹ"
    },
    {
        "Question": "ایک لاحقہ درخت کی نمائندگی کرنے والے ایک ازگر کلاس بنائیں جو موثر اسٹرنگ تلاش اور طویل ترین عام سابقہ کے لئے معاونت کے ساتھ۔",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جس میں ایک لاحقہ درخت کی نمائندگی کی گئی ہے جس کی مدد سے موثر سبسٹرنگ سرچ اور طویل ترین مشترکہ سابقہ کی حمایت کی جاسکتی ہے: پیتھون کوپی کوڈکلاس لاحقہ لاحقہ: کلاس نوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈین = {self} self.suffix_link = کوئی نہیں Def __init __، سٹرنگ): self.string = string + '$' self.root = self.node () self.build_suffix_tree () def build_suffix_tree (خود): n = len (self.string) active_nodایکٹیو_ لمبائی = 0 بقیہ_سفکس_کاؤنٹ = 0 آخری_کریٹڈ_نوڈ = کوئی نہیں رینج (این) کے لئے: باقی_سفکس_کاؤنٹ += 1 لسٹ_کریٹ_نوڈ = کوئی بھی نہیں جبکہ باقی_سفکس_کاؤنٹ> 0: اگر ایکٹو_ لمبائی == 0: ایکٹو_جینڈ [inctive_leng: لیف_نوڈ = خود"
    },
    {
        "Question": "\"یہ چیک کرنے کے لئے کسی فنکشن کو نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط وحدانی ، قیمتیں ، زاویہ بریکٹ ، اور سلیش کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور کسٹم آپریٹرز کی اجازت دی جاسکتی ہے ، آپ اسٹیک پر مبنی نقطہ نظر استعمال کرسکتے ہیں۔فنکشن کا ایک نفاذ یہاں ہے: پائیٹون کوپی کوڈڈف is_valid_expression (اظہار): اسٹیک = [] اوپننگ_براکیٹس = ['(' ، '[' ، '{' ، '<'] کلوزنگ_بریکٹ = [')' ، ']' ، '' ، ']'،'> '] quots = [' '' '، \"\" \"] آپریٹرز = ['+'،'-'،'*'،'/'] سے فرار = اظہار میں چار کے لئے غلط: اگر چار ==' \\\\ ': فرار ہوا = سچ جاری رکھیں اگر فرار ہوجائیں: فرار ہونے والا = غلط جاری رکھیں اگر اوپننگ_براکیٹس میں چار: اسٹیک.اپینڈ (چار)"
    },
    {
        "Question": "کڈانے کے الگورتھم کا استعمال کرتے ہوئے دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم سبری تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک پروگرام ہے جس میں کڈانے کے الگورتھم کا استعمال کرتے ہوئے دیئے گئے سرکلر سرنی میں زیادہ سے زیادہ رقم کا سبریئر مل جاتا ہے: پائیتھون کوپی کوڈڈیف کڈنے_الگوریتھم (اے آر آر): میکس_سم = فلوٹ ('-انف') موجودہ_سم = 0 کے لئے ارٹ: کرنٹ_سم += نمبر اگر موجودہ_سم> میکس_سم ہے۔: میکس_سم = کرنٹ_سم اگر موجودہ_سم <0: موجودہ_سم = 0 میکس_سم ڈیف میکس_سوم_سرکلر_سوبری (اے آر آر) کی واپسی: میکس_سوم_سوبری = کڈین_الگوریتم (آر اے آر) کے لئے کل_سم (آر اے آر) (من) من_سم_سوبری = کڈین_الگورٹم سرنی:میکس_سم_سوبری ریٹرن میکس (میکس_سم_سوبری ، ٹوٹل_سم + من_سم_سوبری) واپس کریں"
    },
    {
        "Question": "\"ہندسوں کے دیئے گئے تار کو حروف تہجی میں ڈیکوڈ کرنے کے لئے الگ الگ طریقوں کی تعداد تلاش کرنے کے لئے ایک پروگرام بنائیں ، جہاں A = 1 ، B = 2 ، وغیرہ۔\"",
        "Answer": "یقینا!ہندسوں کے دیئے گئے تار کو حرف تہجی میں ڈیکوڈ کرنے کے لئے الگ الگ طریقوں کی تعداد تلاش کرنے کے لئے یہاں ایک پروگرام ہے: پائیٹون کوپی کوڈیڈف نمبر_ڈیکوڈنگز (زبانیں): n = لین (s) اگر n == 0: واپس 0 dp = [0] * (n + (n +)1) ڈی پی [0] = 1 ڈی پی [1] = 1 اگر ایس [0]! = '0' اور 0 کے لئے رینج میں (2 ، n + 1): اگر s [i-1]! = '0'."
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے تین دیئے گئے تاروں کی سب سے طویل مشترکہ حصول تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!متحرک پروگرامنگ کا استعمال کرتے ہوئے تین دیئے گئے تاروں کی سب سے طویل عام طور پر تلاش کرنے کے لئے ایک فنکشن کا نفاذ ہے: پائیٹون کوپی کوڈڈیف طویل ترین_کومون_سوبسینس (ایس ٹی آر 1 ، ایس ٹی آر 2 ، ایس ٹی آر 3): ایم ، این ، او = لین (ایس ٹی آر 1) ، لین (ایس ٹی آر 2) ، لین (ایس ٹی آر 3 (ایس ٹی آر 3)) dp = [[[0 کے لئے _ کے لئے حد (o+1)] _ کے لئے حد (n+1)] _ کے لئے _ (m+1)] in in range (1 ، m+1) کے لئے: کیونکہرینج میں J (1 ، n+1): رینج میں K کے لئے (1 ، O+1): اگر str1 [i-1] == str2 [j-1] == str3 [k-1]: dp [i [i] [j] [k] = dp [i-1] [j-1] [k-1] + 1 اور: ڈی پی [i] [j] [k] = زیادہ سے زیادہ (dp [i-1] [j][کے] ، ڈی پی [i] [J-1] [K] ، ڈی پی [i] [j] [K-1]) واپسی ڈی پی [ایم] [این] [او]# مثال کے طور پر یو ایس اے جی ایس ٹی آر 1 ="
    },
    {
        "Question": "\"اسکیپ لسٹ کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور عناصر کو موثر طریقے سے داخل کرنے ، تلاش کرنے اور ان کو دور کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں اثاثہ میں ایک اسکیپلسٹ کلاس کا نفاذ ہے جس میں عناصر کو موثر طریقے سے داخل کرنے ، تلاش کرنے اور ان کو دور کرنے کے طریقوں کے ساتھ: پائیتھون کوپی کوڈیمپورٹ رینڈم کلاس نوڈ: ڈیف __init __ (خود ، ویل = کوئی بھی نہیں): سیلف.وال = ویل سیلف۔ نیکسٹ = [] کلاس اسکیپلسٹ:Def __init __ (خود): self.head = node () self.max_level = 1 def بے ترتیب_لیول (خود): سطح = 1 جبکہ بے ترتیب۔ رینڈم () <0.5 اور سطح <sell.max_level + 1: سطح + = 1 واپسی کی سطحڈیف داخل کریں (خود ، ویل): سطح = سیلف۔ رینڈوم_لیول () اگر سطح> سیلف۔ میکس_ لیول: سیلف۔میکس_ لیول = لیول سیلف۔ ہیڈ.نیکسٹ۔(ویل) کر = سیلف۔ ہیڈ"
    },
    {
        "Question": "\"ہر سکے کے فرق کی لامحدود فراہمی کے ساتھ ، ایک مقررہ مقدار میں تبدیلی کے ل needed کم سے کم تعداد میں سککوں کی تلاش کے ل a ایک پروگرام بنائیں ، جبکہ سکے کی کل تعداد کو کم سے کم کریں۔\"",
        "Answer": "یقینا!لالچی الگورتھم کا استعمال کرتے ہوئے ایک مخصوص مقدار میں تبدیلی کے ل needed درکار سککوں کی کم از کم تعداد تلاش کرنے کے لئے ایک پروگرام ہے: پائیتھون کوپی کوڈیڈف منکوائنز (سکے ، رقم): سکے.سورٹ (ریورس = سچ) # سککوں کو نزول آرڈر نمبرز = 0 میں ترتیب دیں۔سکے میں سکے کے ل :: نمبرکوائنز += رقم // سکے # اس فرقے کے سکے کی تعداد کو کل رقم میں شامل کریں ٪ = سکے # جب تک استعمال شدہ سکے کی قیمت کے ذریعہ رقم کو کم کریں! = 0: واپسی -1 -1 #عین مطابق تبدیلی کی واپسی نمبرکونز # مثال کے طور پر یہ ممکن نہیں ہے کہ usageCoins = [1 ، 5 ، 10 ، 25]"
    },
    {
        "Question": "سلائڈنگ ونڈو نقطہ نظر کا استعمال کرتے ہوئے عددی کی ایک دی گئی فہرست میں زیادہ تر K الگ الگ عدد کے ساتھ طویل ترین بڑھتی ہوئی سبری کو تلاش کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں فنکشن Find_longest_increasing_subarray کا ایک نفاذ ہے جو عددیوں کی ایک دی گئی فہرست میں زیادہ تر K الگ الگ انٹیگرس کے ساتھ سب سے طویل عرصے تک بڑھتے ہوئے سب رے کو تلاش کرنے کے لئے سلائڈنگ ونڈو نقطہ نظر کا استعمال کرتا ہے: پائیٹون کوپی کوڈڈیف Find_longest_incresing_subarray (Nums ، k): اگر k == 0: K == 0: K == 0: K == 0: K == 0: K == 0: واپس []اسٹارٹ = 0 سب سے طویل_subarray = [] disctive_count = 0 الگ الگ_ٹینجرز = {} رینج (لین (nums)) کے اختتام کے لئے: num = nums [اختتام] اگر Num distinct_integers میں نہیں ہے: disfint_count += 1 الگ الگ_ٹیجرز [num] = 0 الگ الگ_انٹیجرز [num] [num]] += 1 جبکہ الگ الگ_کاؤنٹ> K: بائیں_نم = نمبر [شروع] الگ الگ_ٹینجرز [بائیں_نوم] -= 1 اگر الگ الگ_ٹینٹجرز [بائیں_نم] == 0: ڈیل الگ الگ_ٹینجرز [بائیں_نم] الگ الگ_کونٹ -= 1 اسٹارٹ += 1"
    },
    {
        "Question": "لوگرتھمک ٹائم پیچیدگی میں مساوی سائز کی دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "لوگرتھمک ٹائم پیچیدگی میں مساوی سائز کی دو ترتیب شدہ صفوں کے درمیانی حصے کو تلاش کرنے کے ل you ، آپ ترمیم شدہ بائنری تلاش کے نقطہ نظر کو استعمال کرسکتے ہیں۔اس پروگرام کا ایک نفاذ یہاں ہے: پائیتھون کوپی کوڈیڈف Find_median_sorted_arrays (nums1 ، nums2): m = len (nums1) n = len (nums2) اگر m! = n: value error (\"ان پٹ سرنیوں کو برابر سائز ہونا ضروری ہے۔\") # ضم کریں # ضم کریں # ضم کریں۔دو ترتیب شدہ صفیں ضم ہوگئیں = [] i = j = 0 جبکہ میں <m اور j <n: if nums1 [i] <nums2 [j]: ضم شدہ۔ append (nums1 [i]) i += 1 اور: ضم شدہ۔ append."
    },
    {
        "Question": "کواڈٹری کی نمائندگی کرنے والی ایک ازگر کلاس بنائیں اور پوائنٹس کو موثر طریقے سے داخل کرنے اور تلاش کرنے کے طریقوں کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ازگر میں ایک کواڈٹری کلاس کا نفاذ ہے جو پوائنٹس کی موثر اضافے اور تلاش کی حمایت کرتا ہے: پیتھون کوپی کوڈکلاس پوائنٹ: Def __init __ (خود ، x ، y): self.x = x سیلف۔، y ، چوڑائی ، اونچائی): self.x = x self.y = y self.width = چوڑائی"
    },
    {
        "Question": "\"کسی فنکشن کو اس بات کی جانچ پڑتال کے لئے نافذ کریں کہ آیا کسی دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، سلیش ، اور کسٹم آپریٹرز کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا اظہار اور آپریٹر کی پیش کش کی اجازت دی جاسکتی ہے۔\"",
        "Answer": "یہ چیک کرنے کے لئے کہ آیا ایک دیئے گئے تار متوازن قوسین ، بریکٹ ، گھوبگھرالی منحنی خطوط ، قیمتیں ، زاویہ بریکٹ ، سلیشس ، اور کسٹم آپریٹرز کے ساتھ ایک درست اظہار ہے ، جس سے گھوںسلا تاثرات اور آپریٹر کی پیش کش کی اجازت ہے ، آپ اسٹیک پر مبنی نقطہ نظر کو استعمال کرسکتے ہیں۔یہاں ازگر میں ایک مثال عمل ہے: پائیٹون کوپی کوڈیڈف is_valid_expression (اظہار): اسٹیک = [] اوپن_چارس = \"([{<\\\" \\ '/\"قریب_چارس =\")]}> \\ \"\\'/\" آپریٹرز = {\"+\".قریب میں چاروں میں چار: اگر نہیں"
    },
    {
        "Question": "عدد کی دی گئی فہرست میں سبری کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "عددیوں کی دی گئی فہرست میں سبری کی زیادہ سے زیادہ مصنوعات تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ نقطہ نظر کو استعمال کرسکتے ہیں۔ازگر میں ایک مثال کا پروگرام یہ ہے: پائیتھون کوپی کوڈڈف میکس_ پروڈکٹ_سوبری (نمبر): اگر نمبر نہیں ہے تو: واپس 0 میکس_ پروڈکٹ = نمبرز [0] من_ پروڈکٹ = نمبر [0] گلوبل_میکس = میکس_ پروڈکٹ رینج میں (1 ، لین (نمبر)): اگر نمبر (1 ، لین (نمبر))۔"
    },
    {
        "Question": "بائنری تلاش کا استعمال کرتے ہوئے انٹیجرز کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے ایک پروگرام بنائیں۔",
        "Answer": "بائنری تلاش کا استعمال کرتے ہوئے عددیوں کی دی گئی فہرست میں سب سے طویل عرصے تک بڑھتی ہوئی تعداد کو تلاش کرنے کے ل you ، آپ متحرک پروگرامنگ کے نقطہ نظر پر عمل کرسکتے ہیں۔ازگر میں ایک مثال کا پروگرام یہ ہے: پائیتھون کوپی کوڈ ڈیف طویل ترین_ان کریزنگ_سوبسینس (نمبر): اگر نمبر نہیں تو: واپس 0 این = لین (نمبر) ڈی پی = [1] * این # لمبائی این کی ایک فہرست کو تمام عناصر کے ساتھ شروع کریں جس میں 1 رینج میں 1 کے لئے 1 (1 ، این): رینج میں جے کے لئے (i): اگر نمبر [i]> نمبر [j]: dp [i] = زیادہ سے زیادہ (dp [i] ، dp [j] + 1) اس میں زیادہ سے زیادہ (dp) واپسی زیادہ سے زیادہ (dp)پروگرام ، ہم دیئے گئے فہرست نمبر میں ہر انڈیکس I پر ختم ہونے والے سب سے طویل عرصے تک بڑھتے ہوئے حصول کو ٹریک رکھنے کے لئے ایک متحرک پروگرامنگ ٹیبل ڈی پی تشکیل دیتے ہیں۔ہم ڈی پی کے تمام عناصر کو بطور شروع کرتے ہیں"
    },
    {
        "Question": "متحرک پروگرامنگ کا استعمال کرتے ہوئے دو ڈوروں کے مابین لیونشٹین فاصلے کا حساب لگانے کے لئے ایک فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں متحرک پروگرامنگ کا استعمال کرتے ہوئے دو ڈوروں کے مابین لیونشٹین فاصلے کا حساب لگانے کے لئے ایک فنکشن کا نفاذ ہے: پائیتھون کوپی کوڈ ڈیف لیونشٹین_ڈسٹینس (ایس ٹی آر 1 ، ایس ٹی آر 2): ایم = لین (ایس ٹی آر 1) این = لین (ایس ٹی آر 2) # فاصلوں کو ذخیرہ کرنے کے لئے 2 ڈی میٹرکس بنائیں۔dp = [[0] * (n + 1) _ کے لئے _ میں حد (m + 1)] # رینج میں I کے لئے پہلی صف اور کالم شروع کریں (m + 1): dp [i] [0] = i for jرینج میں (n + 1): dp [0] [j] = j # بقیہ میٹرکس کے لئے فاصلوں کا حساب لگائیں I میں I کے لئے (1 ، m + 1): J میں حد کے لئے (1 ، n + 1"
    },
    {
        "Question": "\"وقفہ کے درخت کی نمائندگی کرنے والی ایک ازگر کلاس لکھیں اور وقفوں کو موثر انداز میں داخل کرنے ، تلاش کرنے اور دور کرنے کے طریقوں کو نافذ کریں۔\"",
        "Answer": "یقینا!یہاں ایک ازگر کلاس کا نفاذ ہے جو وقفے کے درخت کی نمائندگی کرتا ہے جس میں وقفوں کو موثر طریقے سے داخل کرنے ، تلاش کرنے اور ہٹانے کے طریقوں کے ساتھ: پائیتھون کوپی کوڈکلاس انٹرویلٹرینوڈ: ڈیف __init __ (خود ، شروع ، اختتام)= end self.left = کوئی بھی نہیں۔ رائٹ = نان کلاسٹ انٹروولٹری: Def __init __ (خود): self.root = کوئی بھی نہیں ڈیف داخل کریں (خود ، آغاز ، اختتام): سیل.روٹ = سیلف۔) ڈیف _ Insert_helper (خود ، نوڈ ، اسٹارٹ ، اختتام): اگر نوڈ کوئی نہیں ہے: ریٹرنلٹرینوڈ (شروع ، اختتام) اگر شروع کریں <node.start: node.left = سیلف۔"
    },
    {
        "Question": "اس رکاوٹ کے ساتھ کسی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام بنائیں کہ سبری میں کوئی تین عناصر لگاتار نہیں ہیں۔",
        "Answer": "یقینا!اس رکاوٹ کے ساتھ کسی سبری کی زیادہ سے زیادہ رقم تلاش کرنے کے لئے ایک پروگرام یہ ہے کہ سبری میں کوئی تین عناصر لگاتار نہیں ہیں: پائیتھون کوپی کوڈڈیف میکس_سم_ ویتھ_کانسٹرینٹ (اے آر آر): این = لین (اے آر آر) اگر ن <= 2: واپسی کا مجموعہ (آر آر) ڈی پی =[0] * n dp [0] = arr [0] dp [1] = arr [0] + arr [1] in in range (2 ، n): dp [i] = زیادہ سے زیادہ (arr [i] +ڈی پی [i - 2] ، arr [i] + dp [i - 3] ، dp [i - 1]) زیادہ سے زیادہ واپسی (dp [-1] ، dp [-2])# مثال کے استعمال: arr = [3 ،7 ، 4 ، 2 ، 8 ، 5] میکس_سم = زیادہ سے زیادہ_سم_تھ_کسٹرینٹ (آر آر) پرنٹ"
    }
]