[
    {
        "Question": "ڈیٹا ڈھانچہ کیا ہے؟",
        "Answer": "ڈیٹا کا ڈھانچہ کمپیوٹر کی میموری میں ڈیٹا کو منظم اور اسٹور کرنے کا ایک طریقہ ہے تاکہ اس تک رسائی اور موثر انداز میں ہیرا پھیری کی جاسکے۔یہ ایک منطقی نمائندگی فراہم کرتا ہے کہ اعداد و شمار کو کس طرح منظم کیا جاتا ہے ، جس سے موثر اسٹوریج ، بازیافت ، اور معلومات کی ہیرا پھیری کی اجازت ہوتی ہے۔ ڈیٹا ڈھانچے کو دو اہم زمروں میں درجہ بندی کیا جاسکتا ہے: قدیم اعداد و شمار کے ڈھانچے اور جامع ڈیٹا ڈھانچے۔ بنیادی اعداد و شمار کے ڈھانچے: یہ بنیادی ہیںپروگرامنگ زبانوں کے ذریعہ فراہم کردہ بلاکس بلڈنگ۔مثالوں میں شامل ہیں: انٹیجر: پوری تعداد (جیسے ، 1 ، 2 ، 3) اسٹور کرتا ہے۔ فلوٹ: اسٹورز اعشاریہ اعشاریہ (جیسے ، 3.14 ، 2.718)۔ چیریکٹر: ایک ہی حرف (جیسے ، 'اے' ، 'بی' ، 'سی' کو اسٹور کرتا ہے۔) .بولین"
    },
    {
        "Question": "ایک صف اور منسلک فہرست میں کیا فرق ہے؟",
        "Answer": "صفوں اور لنکڈ فہرستیں دونوں اعداد و شمار کے ڈھانچے ہیں جو عناصر کے مجموعوں کو اسٹور اور منظم کرنے کے لئے استعمال ہوتے ہیں۔تاہم ، وہ اپنے بنیادی ڈھانچے ، میموری کے انتظام اور کارکردگی کی خصوصیات کے لحاظ سے مختلف ہیں۔صفوں اور منسلک فہرستوں کے مابین کلیدی اختلافات یہ ہیں: ڈھانچہ: سرنی: ایک سرنی میموری کا ایک متنازعہ بلاک ہے جو ایک ہی قسم کے عناصر کو اسٹور کرتا ہے۔عنصروں تک انڈیکس کا استعمال کرتے ہوئے رسائی حاصل کی جاتی ہے ، تخلیق کے وقت طے شدہ سائز کا تعین کیا جاتا ہے۔صفوں کی ایک مقررہ لمبائی ہوتی ہے اور ان کے اشاریہ کی بنیاد پر عناصر تک براہ راست رسائی فراہم کرتی ہے۔ لنکڈ فہرست: ایک لنکڈ فہرست نوڈس پر مشتمل ہوتی ہے جہاں ہر نوڈ میں ترتیب میں اگلے نوڈ کے لئے ایک قدر اور حوالہ (یا پوائنٹر) ہوتا ہے۔نوڈس ضروری طور پر میموری کے متضاد مقامات پر محفوظ نہیں ہوتے ہیں ، جس سے متحرک میموری کی مختص کرنے کی اجازت ہوتی ہے۔منسلک فہرستیں لمبائی میں مختلف ہوسکتی ہیں اور عناصر تک ترتیب تک رسائی فراہم کرسکتی ہیں۔ میموری مینجمنٹ: سرنی: صفوں کو تمام عناصر کو ذخیرہ کرنے کے لئے میموری کا پہلے سے مختص بلاک کی ضرورت ہوتی ہے۔سرنی کا سائز طے ہے اور اسے آسانی سے تبدیل نہیں کیا جاسکتا"
    },
    {
        "Question": "ایک اسٹیک قطار سے کیسے مختلف ہے؟",
        "Answer": "ایک اسٹیک اور قطار دونوں لکیری ڈیٹا ڈھانچے ہیں جو عناصر کو ذخیرہ کرنے اور ان میں ہیرا پھیری کے لئے استعمال ہوتے ہیں۔تاہم ، وہ اس ترتیب کے لحاظ سے مختلف ہیں جس میں عناصر تک رسائی اور ہٹا دیا جاتا ہے۔یہاں اسٹیک اور ایک قطار کے درمیان کلیدی اختلافات ہیں: اسٹیک: آخری ان پہلی آؤٹ (LIFO): ایک اسٹیک میں ، آخری عنصر جو شامل کیا جاتا ہے (دھکا دیا جاتا ہے) پہلے ہی ہٹایا جاتا ہے (پاپڈ)۔اس کے بارے میں پلیٹوں کے اسٹیک کی طرح سوچئے ، جہاں آپ صرف اوپر سے پلیٹوں کو شامل یا ہٹا سکتے ہیں۔اس کو ہٹائے بغیر سب سے اوپر کا عنصر۔ مثال کے طور پر: کتابوں کے ڈھیر پر غور کریں۔آخری کتاب سب سے اوپر رکھی گئی ہے"
    },
    {
        "Question": "ہیش ٹیبل کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ایک ہیش ٹیبل ، جسے ہیش میپ کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو موثر اندراج ، حذف کرنے اور بازیافت کے کام فراہم کرتا ہے۔اس میں ہیشنگ نامی ایک تکنیک استعمال کی گئی ہے تاکہ وہ اپنی چابیاں پر مبنی عناصر کو ذخیرہ کریں اور بازیافت کریں۔ایک ہیش ٹیبل میں بالٹیوں یا سلاٹوں کی ایک صف شامل ہوتی ہے ، جہاں ہر سلاٹ ایک یا زیادہ کلیدی قدر کے جوڑے کو ذخیرہ کرسکتا ہے۔ ہیش ٹیبل کس طرح کام کرتا ہے: ہیش فنکشن: ایک ہیش فنکشن ان پٹ کے طور پر ایک کلید لیتا ہے اور ہیش کوڈ کی گنتی کرتا ہے ،ایک عدد قیمت ہے۔ہیش کوڈ کا استعمال انڈیکس یا بالٹی کا تعین کرنے کے لئے کیا جاتا ہے جہاں متعلقہ کلیدی قدر کی جوڑی ہوگی"
    },
    {
        "Question": "درختوں کا ڈیٹا ڈھانچہ کیا ہے اور اس کی مختلف اقسام کیا ہیں؟",
        "Answer": "ایک درخت ایک نان لائنر ڈیٹا ڈھانچہ ہے جو منسلک ، ایسائکلک انداز میں درجہ بندی سے عناصر کو منظم کرتا ہے۔اس میں نوڈس اور کناروں پر مشتمل ہے ، جہاں نوڈس عناصر کی نمائندگی کرتے ہیں ، اور کنارے عناصر کے مابین تعلقات کی نمائندگی کرتے ہیں۔کسی درخت میں سب سے اوپر والے نوڈ کو روٹ نوڈ کہا جاتا ہے ، اور ہر نوڈ میں صفر یا اس سے زیادہ بچوں کے نوڈس ہوسکتے ہیں۔نوڈس جن میں ایک ہی والدین کے نوڈ ہوتے ہیں انہیں بہن بھائی کہتے ہیں ، اور بغیر کسی بچے کے نوڈس کے نوڈ کو پتی کا نوڈ کہا جاتا ہے۔ یہاں مختلف قسم کے درخت ہیں: بائنری ٹری: ایک بائنری ٹری ایک درخت ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچوں کے نوڈس ہوتے ہیں۔، بائیں بچے اور دائیں بچے کے طور پر جانا جاتا ہے۔جس ترتیب میں بچوں کے نوڈس کا اہتمام کیا جاتا ہے وہ بائنری درخت کی خصوصیات کو متاثر کرسکتا ہے ، جیسے بائنری سرچ ٹری ، اےول ٹری ، یا ڈھیر۔ بائنری سرچ ٹری (بی ایس ٹی): بائنری سرچ ٹری بائنری درخت کی ایک قسم ہے جس میںنوڈ کے بائیں بچے میں نوڈ سے کم اقدار ہوتی ہیں ، اور دائیں بچے میں نوڈ سے زیادہ اقدار ہوتی ہیں۔یہ موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو قابل بناتا ہے ، اس کے ساتھ"
    },
    {
        "Question": "آپ ترتیب شدہ صف میں بائنری سرچ الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "ایک ترتیب شدہ صف پر بائنری سرچ الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: بالترتیب بائیں اور دائیں پوائنٹرز کو صف کے آغاز اور اختتام پر سیٹ کریں۔ جب بائیں پوائنٹر دائیں پوائنٹر سے کم یا اس کے برابر ہے ، دہرائیں۔مندرجہ ذیل اقدامات: a.درمیانی انڈیکس کا حساب بائیں اور دائیں پوائنٹرز کی اوسط کے طور پر کریں: وسط = (بائیں + دائیں) / 2.b.مڈل انڈیکس کی قیمت کو ہدف کی قیمت کے ساتھ موازنہ کریں: اگر درمیانی قیمت ہدف کے برابر ہے تو ، مڈل انڈیکس کو نتیجہ کے طور پر واپس کریں۔ اگر درمیانی قیمت ہدف سے زیادہ ہے تو ، دائیں پوائنٹر کو وسط میں اپ ڈیٹ کریں - 1.ifدرمیانی قیمت ہدف سے کم ہے ، بائیں پوائنٹر کو مڈ + پر اپ ڈیٹ کریں۔"
    },
    {
        "Question": "ٹری ڈیٹا ڈھانچہ کیا ہے اور یہ کیسے مفید ہے؟",
        "Answer": "ایک ٹرائی ، جسے ایک سابقہ درخت بھی کہا جاتا ہے ، درختوں کی طرح کا ڈیٹا ڈھانچہ ہے جو تار کے طور پر ذخیرہ شدہ چابیاں کی موثر بازیافت کے لئے استعمال ہوتا ہے۔یہ خاص طور پر متعلقہ مسائل کو حل کرنے کے لئے مفید ہے"
    },
    {
        "Question": "جب آپ ہیپ ڈیٹا ڈھانچہ استعمال کریں گے؟",
        "Answer": "ایک ہیپ ڈیٹا ڈھانچہ عام طور پر ایسے منظرناموں میں استعمال ہوتا ہے جس میں ترجیحی قطاروں کے موثر انتظام کی ضرورت ہوتی ہے یا زیادہ سے زیادہ یا کم سے کم عنصر جلد تلاش کرنا ہوتا ہے۔یہاں کچھ ایسے حالات ہیں جہاں ہیپ ڈیٹا کا ڈھانچہ خاص طور پر مفید ہے: ترجیحی قطار: ترجیحی قطار کو موثر انداز میں نافذ کرنے کے لئے ڈھیر کا استعمال کیا جاسکتا ہے۔ترجیحی قطار میں ، عناصر کی ترجیحات سے وابستہ ہیں ، اور سب سے زیادہ (یا سب سے کم) ترجیحی عنصر ہمیشہ قطار کے سامنے رہتا ہے۔ڈھیر پر مبنی ترجیحی قطار موثر وقت (O (1)) یا لوگرتھمک وقت (O (لاگ (لاگ (لاگ (لاگ (O (لاگ (O (1)) میں موجودہ اعلی (یا سب سے کم) ترجیحی عنصر کی موثر اضافے ، سب سے زیادہ (یا سب سے کم) ترجیحی عنصر کو ختم کرنے ، اور موجودہ اعلی (یا سب سے کم) ترجیحی عنصر کی بازیافت کی اجازت دیتی ہے۔n)). چھانٹ رہا ہے: ہیپسورٹ ایک جگہ میں ایک موثر جگہ چھنٹائی کرنے والا الگورتھم ہے جو ڈھیر کا استعمال کرتا ہے۔یہ ان پٹ سرنی سے زیادہ سے زیادہ ہیپ (چڑھائی کے آرڈر کے لئے) یا ایک کم ہیپ (نزول آرڈر کے لئے) بنا کر اور ڈھیر سے زیادہ سے زیادہ (یا کم سے کم) عنصر کو بار بار نکال کر کام کرتا ہے۔ہیپسورٹ میں O (n لاگ این) کی وقت کی پیچیدگی ہوتی ہے اور یہ خاص طور پر مفید ہے"
    },
    {
        "Question": "متحرک پروگرامنگ کے تصور کی وضاحت کریں۔",
        "Answer": "متحرک پروگرامنگ ایک مسئلے کو حل کرنے کی ایک تکنیک ہے جو پیچیدہ مسائل کو حل کرنے کے لئے استعمال کی جاتی ہے تاکہ ان کو توڑ ڈالیں اور صرف ایک بار ہر ذیلی مسائل کو حل کیا جاسکے۔یہ اوورلیپنگ اسٹرکچرز کے ساتھ مسائل کو موثر حل کرنے ، بے کار کمپیوٹوں کو ختم کرنے اور کارکردگی کو بہتر بنانے کی اجازت دیتا ہے۔ متحرک پروگرامنگ کے پیچھے کلیدی خیال یہ ہے کہ چھوٹے چھوٹے پروبلوں کو حل کرکے اور بڑے مسئلے کے حل کے ل these ان ذیلی پروبلوں کے حل کا استعمال کریں۔ذیلی مسائل کے حل عام طور پر کسی ٹیبل یا میموئزیشن سرنی میں محفوظ کیے جاتے ہیں ، جس سے آسانی سے تلاش اور دوبارہ استعمال کی جاسکتی ہے۔ ڈائنیمک پروگرامنگ میں درج ذیل اقدامات شامل ہیں: مسئلہ کی نشاندہی کریں: مسئلے کو سمجھیں اور اس بات کا تعین کریں کہ آیا یہ متحرک پروگرامنگ کے لئے موزوں خصوصیات کی نمائش کرتا ہے۔ان مسائل جن میں زیادہ سے زیادہ ساخت اور اوورلیپنگ سب پروبلوبل شامل ہیں وہ متحرک پروگرامنگ کے لئے اچھے امیدوار ہیں۔ تکرار کے رشتے کو تشکیل دیں: مسئلے کو چھوٹے چھوٹے مضامین میں توڑ دیں اور اس کے لحاظ سے بڑے مسئلے کے حل کا اظہار کریں"
    },
    {
        "Question": "چوڑائی کی پہلی اور گہرائی کی پہلی تلاش کے مابین اختلافات کی وضاحت کریں۔",
        "Answer": "چوڑائی کی پہلی تلاش (بی ایف ایس) اور گہرائی سے پہلے تلاش (ڈی ایف ایس) دو مشہور گراف ٹریورسل الگورتھم ہیں جو نوڈس کو تلاش کرنے یا تلاش کرنے کے لئے استعمال ہوتے ہیں"
    },
    {
        "Question": "یادداشت کیا ہے اور متحرک پروگرامنگ میں اس کا استعمال کس طرح ہوتا ہے؟",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ مہنگے فنکشن کالوں کی گنتی کو بہتر بنانے کے لئے ان کے نتائج کو بہتر بنایا جاسکے اور جب وہی ان پٹ دوبارہ ہوتا ہے تو ان کو دوبارہ استعمال کرتے ہوئے ان کا دوبارہ استعمال کرتے ہیں۔اس میں اعداد و شمار کے ڈھانچے میں فنکشن کالز کے نتائج کو ذخیرہ کرنا شامل ہے ، عام طور پر کسی سرنی یا ہیش ٹیبل میں ، تاکہ اسی آدانوں کے ساتھ بعد میں آنے والی کالیں اس کو دوبارہ تشکیل دینے کے بجائے براہ راست پیشگی نتیجہ بازیافت کرسکیں۔ متحرک پروگرامنگ کے تناظر میں ، میمورائزیشن عام طور پر ہوتی ہے۔recursive الگورتھم کے ساتھ استعمال کیا جاتا ہے جو اوورلیپنگ کی نمائش کرتے ہیں"
    },
    {
        "Question": "کیا آپ وضاحت کرسکتے ہیں کہ سرخ رنگ کا درخت کیسے کام کرتا ہے؟",
        "Answer": "یقینا!ایک سرخ رنگ کا درخت ایک خود متوازن بائنری سرچ درخت ہے جو خصوصیات کے ایک سیٹ کو نافذ کرکے توازن کو برقرار رکھتا ہے۔اس کا نام درخت میں ہر نوڈ کو تفویض کردہ رنگ کے نام پر رکھا گیا ہے: سرخ یا سیاہ۔سرخ رنگ کے درخت کی خصوصیات مندرجہ ذیل ہیں: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ کا نوڈ ہمیشہ سیاہ ہوتا ہے۔ ہر پتی (کال) نوڈ سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔ ہر راستہ۔نوڈ سے اس کی اولاد پتی نوڈس میں سیاہ نوڈس کی مساوی تعداد ہوتی ہے۔اس پراپرٹی کو بلیک اونچائی پراپرٹی یا بلیک بیلنس کہا جاتا ہے۔ ان خصوصیات پر عمل پیرا ہونے کے بعد ، ایک سرخ رنگ کا درخت اس بات کو یقینی بناتا ہے کہ جڑ سے کسی بھی پتے تک کا لمبا ترین راستہ مختصر ترین راستے کی لمبائی سے دوگنا نہیں ہوتا ہے ، جس کے نتیجے میں متوازن ہوتا ہے۔درخت۔ سرخ رنگ کے درخت پر کی جانے والی کاروائیاں ، جیسے اندراج اور حذف کرنا ، کو برقرار رکھنا شامل ہے"
    },
    {
        "Question": "ترجیحی قطار کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "ترجیحی قطار ایک تجریدی ڈیٹا کی قسم ہے جو عناصر کا مجموعہ محفوظ کرتی ہے ، ہر ایک ترجیح سے وابستہ ہے۔ترجیح مجموعہ کے اندر کسی عنصر کی نسبت کی اہمیت یا عجلت کی نشاندہی کرتی ہے۔اعلی ترجیح کے حامل عناصر کو زیادہ اہم سمجھا جاتا ہے اور کم ترجیح والے عناصر سے پہلے بازیافت یا اس پر کارروائی کی جاتی ہے۔ ترجیحی قطار کے ذریعہ تعاون یافتہ اہم کاروائیاں یہ ہیں: اندراج: عنصر کی ترجیح کی بنیاد پر آرڈر کو برقرار رکھتے ہوئے ترجیحی قطار میں عنصر شامل کرتا ہے۔نیا عنصر مناسب پوزیشن میں رکھا گیا ہے تاکہ یہ یقینی بنایا جاسکے کہ اعلی ترجیح کے حامل عناصر قطار کے سامنے کے قریب ہیں۔ لالچ: یہ عنصر کو ترجیحی قطار سے اعلی ترجیح کے ساتھ ہٹاتا ہے اور واپس کرتا ہے۔سب سے زیادہ کے ساتھ عنصر"
    },
    {
        "Question": "آپ بلبلا ترتیب والے الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "بلبلا ترتیب والا الگورتھم ایک سادہ چھانٹنے والا الگورتھم ہے جو بار بار فہرست میں قدم رکھتا ہے ، ملحقہ عناصر کا موازنہ کرتا ہے ، اور اگر وہ غلط ترتیب میں ہیں تو ان کو تبدیل کرتا ہے۔اس عمل کو اس وقت تک دہرایا جاتا ہے جب تک کہ فہرست ترتیب نہ دی جائے"
    },
    {
        "Question": "اکیلا اور دوگنا منسلک فہرست میں کیا فرق ہے؟",
        "Answer": "ایک واحد منسلک فہرست اور دوگنا منسلک فہرست کے درمیان بنیادی فرق ہر نوڈ کے پاس موجود حوالوں کی تعداد میں ہے۔ان دونوں کا موازنہ یہاں ہے: اکیلے لنکڈ لسٹ: واحد منسلک فہرست میں ہر نوڈ میں دو فیلڈز شامل ہوتے ہیں: فہرست میں اگلے نوڈ کا ڈیٹا اور ایک حوالہ (یا پوائنٹر)۔ نوڈس غیر مستقیم انداز میں جڑے ہوئے ہیں ، جہاں ہر نوڈ پوائنٹساگلے نوڈ پر۔ آخری نوڈ"
    },
    {
        "Question": "ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی کیا ہے؟",
        "Answer": "ہیش ٹیبل میں کسی عنصر کی تلاش میں وقت کی پیچیدگی کا انحصار مخصوص نفاذ اور تصادم کی موجودگی پر ہوتا ہے۔اوسط صورت میں ، ایک اچھی طرح سے تقسیم شدہ ہیش فنکشن اور کم بوجھ عنصر کے ساتھ ، ہیش ٹیبل میں تلاش کرنے کی وقت کی پیچیدگی O (1) ، یا مستقل وقت ہے۔ یہاں تلاش کرنا ایک خرابی ہے کہ عام طور پر ہیش ٹیبل میں کس طرح کام کرتا ہے:جس عنصر کی تلاش کی جائے اس کی کلید ہیش فنکشن کا استعمال کرتے ہوئے ہیش کی جاتی ہے۔ہیش فنکشن ہیش ٹیبل کے بنیادی سرنی ڈھانچے میں انڈیکس کی کلید کا نقشہ بناتا ہے۔ اگر کوئی تصادم نہیں ہوتا ہے (یعنی متعدد چابیاں"
    },
    {
        "Question": "سرکلر بفر کیا ہے اور اس کے کیا فوائد ہیں؟",
        "Answer": "ایک سرکلر بفر ، جسے سرکلر قطار یا رنگ بفر بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ایک مقررہ سائز کے بفر کو سرکلر کے طور پر استعمال کرتا ہے۔"
    },
    {
        "Question": "متوازن سرچ درخت میں سست لوڈنگ کے تصور کی وضاحت کریں۔",
        "Answer": "متوازن تلاش کے درختوں کے تناظر میں ، سست لوڈنگ سے مراد ایک ایسی تکنیک ہے جہاں نوڈ کے اعداد و شمار یا قدر کی اصل گنتی یا بازیافت اس وقت تک موخر کردی جاتی ہے جب تک کہ اس کی واضح طور پر درخواست نہ کی جائے۔تعمیر یا اضافے کے دوران درخت میں تمام نوڈس کے لئے اقدار کو پیش کرنے اور ذخیرہ کرنے کے بجائے ، اقدار صرف اس وقت بھری ہوئی یا حساب کی جاتی ہیں جب ضروری ہو۔ لیزی لوڈنگ خاص طور پر منظرناموں میں مفید ثابت ہوسکتی ہے جہاں نوڈ کی قیمت کی گنتی یا بازیافت مہنگا یا وسائل ہے۔گہریجب تک اس کی ضرورت نہ ہو اس وقت تک لوڈنگ کو موخر کرنے سے ، غیر ضروری کمپیوٹیشن یا بازیافتوں سے بچا جاسکتا ہے ، ممکنہ طور پر وقت اور وسائل کی بچت ہوتی ہے۔ جب سست لوڈنگ کو متوازن سرچ درخت پر لگایا جاتا ہے ، جیسے AVL درخت یا سرخ سیاہ درخت ، میں نوڈسدرخت عام طور پر اصل قدر کو براہ راست ذخیرہ کرنے کے بجائے کلید اور قدر کے حوالے سے ذخیرہ کرتا ہے۔نوڈ سے وابستہ قدر صرف اس وقت حاصل کی جاتی ہے یا اس کی گنتی کی جاتی ہے۔ یہاں متوازن سرچ درخت میں سست لوڈنگ کے تصور کو واضح کرنے کے لئے ایک مثال کا منظر ہے: فرض کیج. ہمارے پاس متوازن سرچ ٹری ہے جو طلباء کے بارے میں معلومات کو محفوظ کرتا ہے ، جہاں ہر نوڈ طالب علم کی نمائندگی کرتا ہے۔اور طالب علم کی شناخت (کلید) اور طالب علم کے گریڈ (ویلیو) کو اسٹور کرتا ہے۔ درخت کی تعمیر کرتے وقت تمام طلباء کے درجات کو لوڈ کرنے اور اسٹور کرنے کے بارے میں ، ہم سست لوڈنگ کا استعمال کرتے ہیں۔ہر ایک"
    },
    {
        "Question": "بائنری تلاش کے درخت سے اے وی ایل کا درخت کیسے مختلف ہے؟",
        "Answer": "ایک AVL درخت ایک قسم کا خود توازن بائنری سرچ ٹری (BST) ہے جو موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو یقینی بنانے کے لئے ایک مخصوص توازن کی حالت کو برقرار رکھتا ہے۔اے وی ایل کے درخت اور عمومی بائنری تلاش کے درخت کے درمیان کلیدی فرق بیلنس عنصر اور اس سے وابستہ توازن کے عمل میں ہے۔یہاں اہم اختلافات ہیں: بیلنس فیکٹر: اے وی ایل کے درخت میں ہر نوڈ ایک بیلنس عنصر کو ذخیرہ کرتا ہے ، جو اس نوڈ کے بائیں اور دائیں سب ٹریوں کے درمیان اونچائی کا فرق ہے۔بیلنس عنصر -1 ، 0 ، یا 1 ہوسکتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ آیا سب ٹری بالترتیب بائیں بھاری ، متوازن یا دائیں بھاری ہے۔عام بائنری سرچ ٹری میں ، توازن کے عنصر کا کوئی تصور نہیں ہے۔ متوازن آپریشنز: جب بھی کسی AVL درخت میں اندراج یا حذف کرنے کا عمل انجام دیا جاتا ہے جو توازن کی حالت میں خلل ڈالتا ہے (توازن عنصر -2 یا +2 بن جاتا ہے) ، مخصوص توازن کی کاروائیاں ہوتی ہیں۔توازن کو بحال کرنے کے لئے متحرک.ان کارروائیوں میں گردش (سنگل یا ڈبل"
    },
    {
        "Question": "بلوم فلٹر کیا ہے اور اس کا استعمال کیسے ہوتا ہے؟",
        "Answer": "ایک بلوم فلٹر ایک امکانی اعداد و شمار کا ڈھانچہ ہے جو کسی سیٹ میں کسی عنصر کی رکنیت کو جانچنے کے لئے استعمال ہوتا ہے۔یہ مؤثر طریقے سے یہ طے کرتا ہے کہ آیا کسی عنصر کو سیٹ میں موجود ہونے کا امکان ہے یا یقینی طور پر موجود نہیں ہے ، لیکن یہ کبھی کبھار غلط مثبت نتائج پیدا کرسکتا ہے (اس بات کا اشارہ کرتا ہے کہ عنصر موجود ہوتا ہے جب یہ نہیں ہوتا ہے) ، حالانکہ یہ کبھی بھی غلط منفی پیدا نہیں کرتا ہے (اس بات کی نشاندہی کرتے ہیں کہ ایکعنصر موجود نہیں ہوتا ہے جب یہ ہوتا ہے) .یہ ہے کہ بلوم فلٹر کس طرح کام کرتا ہے: ابتدا: ایک بلوم فلٹر ایک مقررہ سائز بٹ سرنی (عام طور پر ایم بٹس کے) اور K آزاد ہیش فنکشن کا ایک سیٹ کے ساتھ تیار کیا جاتا ہے۔بلوم فلٹر کا عنصر ، یہ K ہیش کے ہر افعال کا استعمال کرتے ہوئے ہیش کیا جاتا ہے ، جس کے نتیجے میں K مختلف ہیش اقدار ہوتی ہیں۔بٹ سرنی میں متعلقہ بٹس ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر 1 پر سیٹ کیے گئے ہیں۔ میمبرشپ ٹیسٹ: یہ چیک کرنے کے لئے کہ عنصر سیٹ میں ہے یا نہیں ، عنصر کو اسی کے ہیش افعال کا استعمال کرتے ہوئے ہیش کیا جاتا ہے۔ہیش اقدار کے ذریعہ اشارہ کردہ پوزیشنوں پر بٹ سرے میں بٹس کی جانچ کی جاتی ہے۔اگر تمام متعلقہ بٹس 1 پر سیٹ کیے گئے ہیں تو ، عنصر پر غور کیا جاتا ہے \""
    },
    {
        "Question": "امورائزڈ تجزیہ کے تصور کی وضاحت کریں۔",
        "Answer": "امورائزڈ تجزیہ ایک ایسی تکنیک ہے جو اعداد و شمار کے ڈھانچے پر آپریشنز کی ترتیب کی اوسط وقت کی پیچیدگی کا تعین کرنے کے لئے استعمال کی جاتی ہے ، چاہے انفرادی کارروائیوں میں مختلف وقت کی پیچیدگیاں ہوسکتی ہیں۔یہ کاموں کی ایک سیریز کے دوران اعداد و شمار کے ڈھانچے یا الگورتھم کی کارکردگی کی خصوصیات کے بارے میں زیادہ درست اور جامع تفہیم فراہم کرتا ہے۔ کچھ معاملات میں ، اعداد و شمار کے ڈھانچے میں کسی ایک آپریشن کی بدترین وقت کی پیچیدگی ناکارہ ہوسکتی ہے ، لیکن جب کسی ترتیب پر غور کریں۔کارروائیوں میں ، اوسط وقت کی پیچیدگی نمایاں طور پر بہتر ہوسکتی ہے۔امورائزڈ تجزیہ ہمیں مہنگے کارروائیوں کے اخراجات کو بڑی تعداد میں سستے کاموں پر تقسیم کرکے کارروائیوں کی مجموعی لاگت کا تجزیہ کرنے میں مدد کرتا ہے۔ امورٹائزڈ تجزیہ میں تین اہم طریقے شامل ہیں: مجموعی تجزیہ: یہ طریقہ کاروں کی ترتیب کی کل لاگت کا تجزیہ کرتا ہے اور اس کو تقسیم کرتا ہے۔کارروائیوں کی تعداد سے۔یہ فی آپریشن اوسط لاگت پر اوپری پابند فراہم کرتا ہے۔ حساب کتاب کا طریقہ: اس طریقہ کار میں ، کچھ آپریشنز"
    },
    {
        "Question": "جامد اور متحرک صف میں کیا فرق ہے؟",
        "Answer": "جامد کے درمیان فرق"
    },
    {
        "Question": "آپ انضمام کی ترتیب الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "انضمام ترتیب والے الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: تقسیم کریں: غیر ترتیب شدہ صف کو دو حصوں میں تقسیم کریں۔یہ درمیانی اشاریہ تلاش کرکے اور دو الگ الگ سبریوں کی تشکیل کے ذریعہ کیا جاسکتا ہے ، ایک شروع سے وسط تک عناصر پر مشتمل ہے ، اور دوسرا درمیانی+1 سے آخر تک عناصر پر مشتمل ہے۔پچھلے مرحلے میں تخلیق کردہ دو سبریوں کو۔یہ قدم سبریوں کو تقسیم کرنا جاری رکھے گا جب تک کہ ہر سبری میں صرف ایک عنصر نہ ہو ، جسے پہلے ہی ترتیب دیا جاتا ہے۔یہ دو سبریوں کے عناصر کا موازنہ کرکے اور اصل صف میں رکھے جانے والے چھوٹے عنصر کو منتخب کرکے کیا جاتا ہے۔اس عمل کو اس وقت تک دہرائیں جب تک کہ دونوں سبریوں کے تمام عناصر کو اصل صف میں ضم کردیا نہ جائے۔ یہاں"
    },
    {
        "Question": "اسکیپ لسٹ ڈیٹا کا ڈھانچہ کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "اسکیپ لسٹ ایک ڈیٹا ڈھانچہ ہے جو عناصر کی ترتیب شدہ فہرست میں عناصر کی تلاش کا ایک موثر طریقہ فراہم کرتا ہے۔یہ ایک منسلک فہرست کی طرح ہے لیکن اس میں متعدد متوازی لنکڈ فہرستیں شامل ہیں ، جن کو \"سطح\" کہا جاتا ہے ، جو تیزی سے تلاش کے کاموں کی اجازت دیتا ہے۔اسکیپ لسٹوں کو فراہم کرنے کے لئے ڈیزائن کیا گیا ہے"
    },
    {
        "Question": "ایک لاحقہ درخت کیا ہے اور یہ کیسے مفید ہے؟",
        "Answer": "ایک لاحقہ درخت ایک ڈیٹا ڈھانچہ ہے جو کسی دیئے گئے تار کے تمام لاحقہ کو موثر انداز میں نمائندگی کرتا ہے۔یہ بنیادی طور پر پیٹرن مماثل اور سٹرنگ سرچ آپریشنز کے لئے استعمال ہوتا ہے۔ایک لاحقہ درخت خاص طور پر ان ایپلی کیشنز میں مفید ہے جس میں بڑے متن یا ڈی این اے کی ترتیب کا تجزیہ کرنا شامل ہے۔ یہاں ایک لاحقہ درخت کس طرح کام کرتا ہے: تعمیر: لاحقہ درخت کی تعمیر کے لئے ، دیئے گئے تار کو کردار کے لحاظ سے پروسس کیا جاتا ہے۔تار کا ہر لاحقہ درخت میں ایک علیحدہ راستے کے طور پر شامل کیا جاتا ہے۔لاحقہ جو مشترکہ سابقہ میں شریک ہیں اسی راہ میں شریک ہیں جب تک کہ وہ ڈائیورج۔ نوڈس اور کناروں: درخت"
    },
    {
        "Question": "بائنری سرچ ٹری میں عنصر داخل کرنے کی وقت کی پیچیدگی کیا ہے؟",
        "Answer": "بائنری سرچ ٹری (بی ایس ٹی) میں کسی عنصر کو داخل کرنے کی وقت کی پیچیدگی درخت کی ساخت پر منحصر ہے۔بہترین صورتحال میں ، جہاں درخت متوازن ہے ، وقت کی پیچیدگی O (لاگ این) ہے ، جہاں N درخت میں نوڈس کی تعداد ہے۔تاہم ، بدترین صورتحال میں ، جہاں درخت انتہائی متوازن ہے (لکیری لنکڈ فہرست سے مشابہت) ، وقت کی پیچیدگی O (n) ہوسکتی ہے ، جہاں درخت میں نوڈس کی تعداد ہے۔ اس تغیر کی وجہ یہ ہےکہ متوازن بی ایس ٹی میں ، درخت کی اونچائی نوڈس کی تعداد کے سلسلے میں لاگ ان کی رہتی ہے ، جس سے داخلے کے موثر کاموں کو یقینی بنایا جاتا ہے۔متوازن بی ایس ٹی میں ہر سطح باقی تلاش کی جگہ کو تقریبا half نصف تک تقسیم کرتا ہے ، جس کی وجہ سے عناصر کی متوازن تقسیم ہوتی ہے۔ دوسری طرف ، ایک متوازن بی ایس ٹی ایک لکیری ڈھانچے میں ہراس ڈال سکتا ہے ، جس میں ایک سب ٹری دوسرے سے نمایاں طور پر بڑا ہے۔اس معاملے میں ، کسی عنصر کو داخل کرنے میں درخت کی پوری اونچائی سے گزرنا شامل ہوسکتا ہے ، جس کے نتیجے میں ایک خطی وقت کی پیچیدگی ہوتی ہے۔ موثر اضافے کو یقینی بنانے کے لئے ، خود توازن بائنری تلاش کا استعمال کرنا عام ہے۔"
    },
    {
        "Question": "کیا آپ وضاحت کرسکتے ہیں کہ ایک فبونیکی ہیپ کیسے کام کرتا ہے؟",
        "Answer": "ایک فبونیکی ہیپ ایک ڈیٹا ڈھانچہ ہے جو ترجیحی قطار کو موثر انداز میں نافذ کرنے کے لئے استعمال ہوتا ہے۔یہ بائنری ہیپس یا بائنومیئل ہیپس جیسے ترجیحی قطار کے نفاذ کے مقابلے میں بعض کارروائیوں کے لئے بہتر امورائزڈ ٹائم پیچیدگی فراہم کرتا ہے۔فیبونیکی ہیپ کی کلیدی خصوصیات میں اس کی انضمام کے ڈھیر پراپرٹی اور مستقل وقت کی کارروائیوں جیسے اندراج اور کمی کی صلاحیت شامل ہے۔ یہاں فیبونیکی ہیپ کس طرح کام کرتا ہے اس کا ایک جائزہ: ساخت: ایک فبونیکی ہیپ کا ایک مجموعہ ہے۔درختوں کا حکم دیا۔ڈھیر میں ہر درخت کم سے کم پراپرٹی کی پیروی کرتا ہے ، جہاں ہر نوڈ کی کلید اس کے والدین کی کلید سے زیادہ یا اس کے برابر ہوتی ہے۔درختوں کی کوئی شکل ہوسکتی ہے ، اور ڈھیر کی نمائندگی خود ہی جڑ کے نوڈس کی دوگنا سے منسلک فہرست کے ذریعہ کی جاتی ہے۔اس کے بعد اس درخت کو جڑ کی فہرست میں شامل کیا جاتا ہے۔اندراج کے عمل میں O (1) کی مستقل وقت کی پیچیدگی ہوتی ہے کیونکہ کسی ضم یا تنظیم نو کی ضرورت نہیں ہوتی ہے۔کم سے کم نوڈ ہے"
    },
    {
        "Question": "خود توازن بائنری تلاش کا درخت کیا ہے اور آپ اسے کب استعمال کریں گے؟",
        "Answer": "ایک خود توازن بائنری سرچ ٹری (بی ایس ٹی) ایک بائنری سرچ ٹری ہے جو موثر تلاش ، اندراج ، اور حذف کرنے کی کارروائیوں کو یقینی بنانے کے ل intrats داخلوں اور حذف ہونے کے دوران خود بخود متوازن ڈھانچے کو برقرار رکھتی ہے۔توازن کا طریقہ کار درختوں کے نوڈس کو غیر متوازن ڈھانچے میں انحطاط کو روکنے کے لئے دوبارہ تقسیم کرتا ہے ، جو غیر موثر کارروائیوں کا باعث بن سکتا ہے۔ عام طور پر استعمال ہونے والے خود توازن والے بی ایس ٹی میں شامل ہیں: اے وی ایل کا درخت: ایک اے وی ایل کا درخت اونچائی سے متوازن بائنری تلاش کا درخت ہے ، جہاں اونچائی ہے ، جہاں اونچائی ہے۔کسی بھی نوڈ کے بائیں اور دائیں سبٹیز زیادہ سے زیادہ 1 سے مختلف ہیں۔ AVL درخت اونچائی کے توازن کو برقرار رکھنے کے ل rents اضافے اور حذفوں کے دوران گردشیں انجام دے کر اس توازن کو حاصل کرتے ہیں۔یہ تلاش کے ل O O (لاگ این) کی بدترین وقت کی پیچیدگی کو یقینی بناتا ہے ،"
    },
    {
        "Question": "آپ کوئکسورٹ الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "کوئکسورٹ ایک مشہور چھانٹ رہا الگورتھم ہے جو تقسیم اور فتح کرنے والے نقطہ نظر کی پیروی کرتا ہے۔یہ محور عنصر کو منتخب کرنے ، محور کے ارد گرد صف کو تقسیم کرنے ، اور محور کے دونوں طرف سبریوں کو بار بار ترتیب دینے سے کام کرتا ہے۔یہاں کوئیکسٹورٹ الگورتھم کو نافذ کرنے کے طریقوں کی ایک قدم بہ قدم وضاحت ہے: تقسیم: صف سے محور عنصر کا انتخاب کریں۔محور کا انتخاب الگورتھم کی کارکردگی کو متاثر کرسکتا ہے ، اور محور کے انتخاب کے لئے مختلف حکمت عملی موجود ہے (جیسے ،"
    },
    {
        "Question": "گراف ڈیٹا ڈھانچہ کیا ہے اور اس کی مختلف اقسام کیا ہیں؟",
        "Answer": "ایک گراف ایک ڈیٹا ڈھانچہ ہوتا ہے جو باہم مربوط نوڈس کے ذخیرے کی نمائندگی کرنے کے لئے استعمال ہوتا ہے ، جہاں نوڈس کو عمودی کہا جاتا ہے ، اور ان کے مابین رابطوں کو کناروں کہتے ہیں۔"
    },
    {
        "Question": "ایک منٹ کے ڈھیر اور میکس ہیپ کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "ایک منٹ کے ڈھیر اور زیادہ سے زیادہ ڈھیر کے درمیان بنیادی فرق عناصر اور ان پراپرٹیز کی ترتیب میں ہے جو وہ برقرار رکھتے ہیں: من ڈھیر: ایک منٹ کے ڈھیر میں ، کسی بھی نوڈ کے لئے ، اس نوڈ کی قیمت اقدار سے کم یا اس کے برابر ہے۔اس کے بچے۔دوسرے لفظوں میں ، کم سے کم قیمت ہمیشہ ڈھیر کی جڑ میں رہتی ہے۔یہ پراپرٹی اس بات کو یقینی بناتی ہے کہ کم سے کم عنصر کو ڈھیر سے موثر انداز میں بازیافت کیا جاسکتا ہے۔ میکس ہیپ: کسی بھی نوڈ کے لئے ، زیادہ سے زیادہ ڈھیر میں ، قیمت"
    },
    {
        "Question": "آپ گراف پر ڈی ایف ایس (گہرائی کی پہلی تلاش) الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "کسی گراف پر گہرائی کی پہلی تلاش (DFS) الگورتھم کو نافذ کرنے کے ل you ، آپ اسٹیک کا استعمال کرتے ہوئے یا کسی تکرار نقطہ نظر کا استعمال کرتے ہوئے کسی تکراری نقطہ نظر کا استعمال کرسکتے ہیں۔یہاں اسٹیک کا استعمال کرتے ہوئے تکراری نقطہ نظر کی ایک قدم بہ قدم وضاحت ہے: نوڈس کو دیکھنے کے لئے ذخیرہ کرنے کے لئے ایک اسٹیک بنائیں۔اس کو شروع کرنے والے نوڈ کے ساتھ شروع کریں۔ ملاحظہ کرنے والے نوڈس کا ٹریک رکھنے کے لئے ایک سیٹ یا صف تیار کریں۔ جب اسٹیک خالی نہیں ہے: اسٹیک سے ایک نوڈ پاپ کریں۔ چیک کریں اگر نوڈ پہلے ہی ملاحظہ کیا گیا ہے۔اگر ایسا ہے تو ، اگلے تکرار کو جاری رکھیں۔ نوڈ کو ملاحظہ کریں اور اس پر کارروائی کریں۔ موجودہ نوڈ کے ملحقہ تمام نوڈس کو گیٹ کریں جن کا دورہ نہیں کیا گیا ہے اور انہیں اسٹیک پر دھکیلیں۔ازگر میں تکراری نقطہ نظر کا استعمال کرتے ہوئے ڈی ایف ایس الگورتھم کا ایک مثال عمل: پائیتھون کوپی کوڈیڈف ڈی ایف ایس (گراف ، اسٹارٹ_نوڈ): اسٹیک = [اسٹارٹ_نوڈ] ملاحظہ کریں = سیٹ ()"
    },
    {
        "Question": "یادداشت کیا ہے اور متحرک پروگرامنگ میں اس کا استعمال کس طرح ہوتا ہے؟",
        "Answer": "میمورائزیشن ایک ایسی تکنیک ہے جو متحرک پروگرامنگ میں استعمال ہوتی ہے تاکہ کسی فنکشن کے عمل کو بہتر بنانے کے لئے اس کے نتائج کو بہتر بنائے۔اس میں مہنگے فنکشن کالز کے نتائج کو ذخیرہ کرنا اور جب وہی آدانوں کو دوبارہ ہوتا ہے تو انہیں کیشے سے بازیافت کرنا شامل ہوتا ہے۔یادداشت پہلے کے حساب شدہ نتائج کو دوبارہ استعمال کرکے بے کار کمپیوٹوں کو ختم کرتی ہے ، اس طرح الگورتھم کی مجموعی وقت کی پیچیدگی کو کم کرتی ہے۔یہ افعال کسی مسئلے کو بار بار چھوٹے چھوٹے مضامین میں توڑ کر حل کرتے ہیں۔تاہم ، یادداشت کے بغیر ، ایک ہی ذیلی مسائل کو متعدد بار حل کیا جاسکتا ہے ، جس کی وجہ سے غیر ضروری کمپیوٹوں کا سبب بنتا ہے۔ متحرک پروگرامنگ میں یادداشت کا استعمال کیا جاتا ہے: تکرار کرنے والے فنکشن کی شناخت کریں: ایک تکرار فنکشن کی تلاش کریں جو اوورلیپنگ سب پروبلوبلز کی پراپرٹی کو ظاہر کرتا ہے ، جہاں ایک ہی ذیلی پروبلیس کو ظاہر کرتا ہے۔متعدد بار حل کیے جاتے ہیں۔ ایک کیشے کو تیار کریں: اعداد و شمار کے ڈھانچے کو شروع کریں ، جیسے سرنی یا ہیش ٹیبل ، پہلے کمپیوٹڈ نتائج کو ذخیرہ کرنے کے لئے کیشے کے طور پر کام کریں۔کیشے کو ان پٹ (یا آدانوں کا مجموعہ) ان کے متعلقہ آؤٹ پٹ پر نقشہ بنانے کے قابل ہونا چاہئے۔ فنکشن کو تبدیل کریں: پہلے چیک کرنے کے لئے تکرار کرنے والی تقریب میں ترمیم کریں کہ آیا دیئے گئے ان پٹ کا نتیجہ پہلے ہی کیشے میں موجود ہے یا نہیں۔اگر ایسا ہوتا ہے تو ، کیشڈ نتیجہ لوٹائیں"
    },
    {
        "Question": "ڈیجکسٹرا کا الگورتھم کیا ہے اور اس کا استعمال کیسے ہوتا ہے؟",
        "Answer": "ڈجکسٹرا کا الگورتھم ایک مقبول الگورتھم ہے جو غیر منفی کنارے کے وزن والے گراف میں نوڈس کے درمیان مختصر ترین راستہ تلاش کرنے کے لئے استعمال ہوتا ہے۔یہ ہدایت اور غیر ہدایت شدہ دونوں گرافوں پر کام کرتا ہے اور گراف کے دوسرے تمام نوڈس تک ایک ہی ماخذ نوڈ سے کم ترین راستہ تیار کرتا ہے۔ الگورتھم ہر نوڈ کے لئے \"غیر منحصر\" نوڈس اور \"فاصلے\" کی قیمت کا ایک سیٹ برقرار رکھتا ہے ، ابتدائی طور پر انفینٹی پر سیٹ کیا جاتا ہے۔سوائے سورس نوڈ کے جو 0 پر سیٹ کیا گیا ہے۔یہ عمل اس وقت تک جاری ہے جب تک کہ تمام نوڈس کا دورہ نہ کیا جائے یا منزل کا نوڈ پہنچا نہ جائے۔ یہاں ڈجکسٹرا کے الگورتھم کی ایک قدم بہ قدم وضاحت: گراف کو شروع کریں اور ماخذ نوڈ کا فاصلہ 0 اور دیگر تمام نوڈس کو انفینٹی پر سیٹ کریں۔ایک ترجیحی قطار (جو اکثر ایک من ڈھیر کے طور پر نافذ کی جاتی ہے) نوڈس کو ان کے فاصلوں کی بنیاد پر ذخیرہ کرنے کے لئے۔ماخذ نوڈ داخل کریں"
    },
    {
        "Question": "کیا آپ AVL درخت اور سرخ رنگ کے درخت کے درمیان فرق کی وضاحت کرسکتے ہیں؟",
        "Answer": "اے وی ایل کے درخت اور سرخ رنگ کے دونوں درخت خود کو متوازن کرنے والے بائنری تلاش کے درخت ہیں جو درخت کی اونچائی کو متوازن رکھتے ہوئے موثر کارروائیوں کو یقینی بناتے ہیں۔تاہم ، ان کے مابین کچھ اختلافات موجود ہیں: توازن کے معیار: AVL درخت: ایک AVL درخت میں ، ہر نوڈ کا توازن عنصر ، بائیں subtree مائنس کی اونچائی کے طور پر بیان کیا جاتا ہے ، دائیں سبٹری کی اونچائی ، یا تو -1 ، 0 ہونا چاہئے۔، یا 1. اگر کسی بھی نوڈ کا توازن عنصر اس حد سے باہر ہوجاتا ہے تو ، درخت کو گردش کی کارروائیوں کو انجام دے کر توازن دیا جاتا ہے۔ ریڈ-بلیک ٹری: سرخ رنگ کے درخت میں ، ہر نوڈ کو رنگ تفویض کیا جاتا ہے-یا تو سرخ یا سیاہ۔درخت کو درج ذیل خصوصیات کو پورا کرنا چاہئے: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ نوڈ سیاہ ہے۔ ہر پتی نوڈ (نیل یا کال) سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔"
    },
    {
        "Question": "ریڈکس درخت کیسے کام کرتا ہے؟",
        "Answer": "ایک ریڈکس درخت ، جسے ٹری یا پریفکس ٹری بھی کہا جاتا ہے ، ایک خاص درخت کے اعداد و شمار کا ڈھانچہ ہے جو موثر اسٹوریج اور تاروں کی بازیافت کے لئے استعمال ہوتا ہے۔یہ خاص طور پر لغت کے نفاذ ، آٹومپلیٹ سسٹم ، اور آئی پی روٹنگ ٹیبلز جیسے ایپلی کیشنز کے لئے مفید ہے۔ ریڈکس ٹری اپنے کرداروں کے ذریعہ تاروں کا اہتمام کرتا ہے ، جس میں ہر نوڈ ایک سابقہ یا مکمل تار کی نمائندگی کرتا ہے۔یہاں ایک جائزہ ہے کہ ایک ریڈکس ٹری کس طرح کام کرتا ہے: نوڈ ڈھانچہ: ریڈکس ٹری میں ہر نوڈ میں کئی اجزاء ہوتے ہیں: کلیدی/کردار: نوڈ سے وابستہ کردار۔مثال کے طور پر ، لغت کے نفاذ میں ، ہر کردار کسی لفظ میں ایک خط کی نمائندگی کرتا ہے۔ بچوں: بچوں کے نوڈس کے اشارے یا حوالہ۔ہر بچہ ایک ممکنہ کردار سے مطابقت رکھتا ہے جو لفظ مارکر کے موجودہ نوڈ کی پیروی کرسکتا ہے: ایک جھنڈا جس سے یہ ظاہر ہوتا ہے کہ آیا نوڈ ایک مکمل لفظ کے اختتام کی نمائندگی کرتا ہے۔ ریڈکس ٹری کی تعمیر: ریڈکس کا درخت ابتدائی طور پر خالی ہے ، جس میں صرف ایک جڑ نوڈ ہے۔چونکہ درخت میں ڈور ڈالے جاتے ہیں ، حروف کو بائیں سے دائیں تک عبور کیا جاتا ہے۔ داخلہ آپریشن: ریڈکس ٹری میں ایک تار داخل کرنا: جڑ نوڈ پر شروع کریں۔ چیک کریں اگر موجودہ کردار موجودہ نوڈ کے بچے کی طرح موجود ہے۔کرتا ہے ، منتقل"
    },
    {
        "Question": "بی ٹری کیا ہے اور یہ بائنری سرچ کے درخت سے کیسے مختلف ہے؟",
        "Answer": "بی ٹری ایک خود توازن رکھنے والا درخت ڈیٹا ڈھانچہ ہے جو ڈسک پر یا ثانوی اسٹوریج میں بڑی مقدار میں ڈیٹا کو موثر انداز میں اسٹور کرنے اور بازیافت کرنے کے لئے ڈیزائن کیا گیا ہے۔یہ سست رسائی کے اوقات کے ساتھ نظاموں کے ل optim بہتر ہے ، جیسے ہارڈ ڈرائیوز ، جہاں کم سے کم ڈسک ریڈز کارکردگی کے لئے بہت ضروری ہے۔ایک بی ٹری بائنری سرچ ٹری (بی ایس ٹی) سے کئی طریقوں سے مختلف ہے: نوڈ ڈھانچہ: بائنری سرچ ٹری میں ، ہر نوڈ میں عام طور پر ایک ہی کلید اور دو بچوں کے پوائنٹر ہوتے ہیں ، جو بائیں اور دائیں سبٹریز کی نمائندگی کرتے ہیں۔اس کے برعکس ، بی ٹری نوڈ میں متعدد چابیاں اور بچوں کے پوائنٹرز شامل ہوسکتے ہیں۔نوڈ میں چابیاں کی تعداد ایک خاص حد کے اندر ہے ، جس کا تعین بی ٹری کے حکم سے ہوتا ہے۔بی ٹری کا ترتیب نوڈ میں اجازت دی گئی کم سے کم اور زیادہ سے زیادہ چابیاں کا تعین کرتا ہے۔آرڈر کا ایک بی ٹری ایم نوڈ میں زیادہ تر M-1 کیز اور ایم چائلڈ پوائنٹرز پر ہوسکتا ہے ، سوائے جڑ کے علاوہ"
    },
    {
        "Question": "درخت پر مبنی ڈیٹا ڈھانچے کا استعمال کرتے ہوئے ہف مین کوڈنگ کے تصور کی وضاحت کریں۔",
        "Answer": "ہف مین کوڈنگ ایک لچکدار ڈیٹا کمپریشن الگورتھم ہے جو درخت پر مبنی ڈیٹا ڈھانچہ استعمال کرتا ہے ، جسے ہف مین ٹری کے نام سے جانا جاتا ہے ، ان کی موجودگی کی تعدد کی بنیاد پر حروف کو متغیر لمبائی کے کوڈ تفویض کرنے کے لئے۔یہ عام طور پر فائل کمپریشن اور ڈیٹا ٹرانسمیشن جیسے ایپلی کیشنز میں استعمال ہوتا ہے۔ یہاں ایک قدم بہ قدم وضاحت ہے کہ ہف مین کوڈنگ درختوں پر مبنی ڈیٹا ڈھانچے کا استعمال کرتے ہوئے کس طرح کام کرتی ہے: تعدد تجزیہ: ہف مین کوڈنگ میں پہلا قدم فریکوئینسی تجزیہ کرنا ہے۔ان پٹ ڈیٹا ، جیسے ٹیکسٹ دستاویز یا حروف کی ترتیب۔ہر کردار کی فریکوئنسی گنتی کی جاتی ہے ، اور ایک فریکوینسی ٹیبل تیار کیا جاتا ہے۔ ہف مین درخت کی تعمیر: فریکوینسی ٹیبل سے ہر کردار کو ابتدائی طور پر ایک پتی نوڈ کے طور پر سمجھا جاتا ہے۔ سب سے کم تعدد والے دو نوڈس کو ایک نئے والدین نوڈ میں ملایا جاتا ہے ، جس میں مشترکہ طور پر ایک نئے والدین کے نوڈ میں مل جاتا ہے۔تعدد دو بچوں کے نوڈس کی تعدد کا مجموعہ ہونے کی وجہ سے۔ یہ عمل اس وقت تک دہرایا جاتا ہے جب تک کہ تمام نوڈس کو ایک سنگل میں جوڑ نہیں دیا جاتا ہے"
    },
    {
        "Question": "ملحقہ میٹرکس کیا ہے اور یہ گراف کی نمائندگی کرنے کے لئے کس طرح استعمال ہوتا ہے؟",
        "Answer": "ایک ملحقہ میٹرکس دو جہتی میٹرکس کا استعمال کرتے ہوئے گراف کی نمائندگی کرنے کا ایک عام طریقہ ہے۔یہ گراف میں عمودی کے مابین تعلقات کی ایک کمپیکٹ اور موثر نمائندگی فراہم کرتا ہے۔ ایک ملحقہ میٹرکس میں ، میٹرکس کی قطاریں اور کالم گراف کے عمودی کی نمائندگی کرتے ہیں۔میٹرکس کا ہر سیل دو عمودی کے درمیان ایک کنارے کی نمائندگی کرتا ہے۔ہر سیل میں ذخیرہ شدہ قیمت اسی طرح کے عمودی کے مابین کنارے کی موجودگی یا عدم موجودگی کی نشاندہی کرتی ہے۔ اس کے لئے دو عام نقطہ نظر ہیں"
    },
    {
        "Question": "آپ گراف پر بی ایف ایس (چوڑائی کی پہلی تلاش) الگورتھم کو کس طرح نافذ کریں گے؟",
        "Answer": "کسی گراف پر چوڑائی کی پہلی تلاش (بی ایف ایس) الگورتھم کو نافذ کرنے کے ل you ، آپ ان اقدامات پر عمل کرسکتے ہیں: ایک ابتدائی ورٹیکس کا انتخاب کریں: ایک ایسا ابتدائی حد کا انتخاب کریں جس سے آپ بی ایف ایس ٹریورزال کو شروع کرنا چاہتے ہیں۔ ڈیٹا ڈھانچے کو بہتر بنائیں: عمودی حصے کو ذخیرہ کرنے کے لئے ایک قطار بنائیںملاحظہ کرنے کے لئے اور ایک سیٹ یا سرنی کا دورہ کرنے والے عمودی کو ٹریک کرنے کے لئے۔ ابتدائی ورٹیکس کو تلاش کریں: ابتدائی ورٹیکس کو قطار میں شامل کریں اور اسے ملاحظہ کی طرح نشان زد کریں۔قطار کا سامنے۔ عمودی پروسیس کریں (جیسے ، اسے پرنٹ کریں یا اس پر کچھ آپریشن انجام دیں)۔"
    },
    {
        "Question": "ایک لاحقہ سرنی کیا ہے اور یہ کیسے مفید ہے؟",
        "Answer": "ایک لاحقہ سرنی ایک ڈیٹا ڈھانچہ ہے جو دیئے گئے تار کے تمام لاحقہ کی ترتیب شدہ صف کو محفوظ کرتا ہے۔یہ اصل سٹرنگ ، جیسے پیٹرن مماثل ، سٹرنگ سرچ ، اور سب سے طویل عام پریفکس کمپیوٹیشن پر اسٹرنگ سے متعلقہ کاروائیاں انجام دینے کا ایک موثر طریقہ فراہم کرتا ہے۔ لاحقہ سرنی کی تعمیر کے ل the ، اصل تار پہلے لاحقہ کی ایک صف میں تبدیل ہوجاتا ہے۔ہر لاحقہ اصل تار کے ایک مخصوص انڈیکس سے شروع ہونے والا اور اختتام تک پھیلتا ہے۔اس کے بعد لاحقہ لاحقہ سرنی بنانے کے لئے لغت کے مطابق ترتیب دیا جاتا ہے۔ لاحقہ سرنی میں کئی ایپلی کیشنز اور فوائد ہیں: سٹرنگ سرچ: ایک لاحقہ سرنی کے ساتھ ، آپ مؤثر طریقے سے کسی نمونہ یا اصل تار کے اندر اسٹرنگ تلاش کرسکتے ہیں۔ترتیب شدہ لاحقہ سرنی پر بائنری سرچ یا دیگر موثر تلاش الگورتھم کا استعمال کرکے ، آپ"
    },
    {
        "Question": "ہیش ٹیبل میں ہیش تصادم کے تصور کی وضاحت کریں۔",
        "Answer": "ایک ہیش ٹیبل میں ، ہیش تصادم اس وقت ہوتا ہے جب بنیادی صف میں ایک ہی انڈیکس یا بالٹی کا دو مختلف چابیاں نقشہ بنائیں۔چونکہ ہیش کے افعال مختلف چابیاں کے لئے ایک ہی ہیش ویلیو پیدا کرسکتے ہیں ، لہذا زیادہ تر عملی منظرناموں میں تصادم ناگزیر ہوتے ہیں ، خاص طور پر جب چابیاں کی تعداد بالٹیوں کی تعداد سے کہیں زیادہ بڑی ہوتی ہے۔ ہیش کے تصادم کو سنبھالنے کے لئے دو عام حکمت عملی: علیحدہ زنجیروں کے ساتھ: ساتھعلیحدہ زنجیر ، ہیش ٹیبل میں ہر بالٹی میں ایک لنکڈ لسٹ یا کچھ اور ڈیٹا ڈھانچہ شامل ہے جس میں ایک ہی انڈیکس میں ہیش ہیش کو ایک سے زیادہ کلیدی قیمت کے جوڑے ذخیرہ کرنے کے ل. ہیں۔جب تصادم ہوتا ہے تو ، اس انڈیکس میں موجودہ زنجیر میں نئی کلیدی قدر کی جوڑی کو شامل کیا جاتا ہے۔اس طرح ، متعدد اقدار ایک دوسرے کو اوور رائٹ کیے بغیر ایک ہی انڈیکس میں محفوظ کی جاسکتی ہیں۔کسی تلاش یا بازیافت کے دوران ، مطلوبہ کلید قدر کو تلاش کرنے کے لئے مناسب زنجیر کا سفر کیا جاتا ہے"
    },
    {
        "Question": "خود کو منظم کرنے کی فہرست ڈیٹا ڈھانچے کا کام کیسے کام کرتا ہے؟",
        "Answer": "خود تنظیم سازی کی فہرست ایک ڈیٹا ڈھانچہ ہے جو خود بخود رسائی کی تعدد کی بنیاد پر اپنے عناصر کی تنظیم نو کرتا ہے۔خود تنظیم سازی کی فہرست کا ہدف مہنگا کاموں کی تعداد کو کم کرکے ، جیسے عناصر کی تلاش یا بازیافت کرنے کے ذریعہ کثرت سے رسائی والے عناصر تک رسائی کی کارکردگی کو بہتر بنانا ہے۔ عناصر کو خود تنظیم سازی کی فہرست میں منظم کرنے کے لئے مختلف حکمت عملی ہیں۔یہاں دو مشترکہ نقطہ نظر ہیں: منتقل سے سامنے (ایم ٹی ایف): موو ٹو فرنٹ حکمت عملی میں ، جب بھی کسی عنصر تک رسائی حاصل کی جاتی ہے (تلاش یا بازیافت) ، اسے فہرست کے سامنے میں منتقل کردیا جاتا ہے۔اس کا مطلب یہ ہے کہ حال ہی میں تک رسائی حاصل کرنے والا عنصر ہمیشہ فہرست کے سر پر رہے گا۔ایسا کرنے سے ، اکثر رسائی حاصل کرنے والے عناصر آہستہ آہستہ محاذ کی طرف بڑھتے ہیں ، جس سے تلاش کی مجموعی کارکردگی کو بہتر بنایا جاتا ہے۔تاہم ، اس حکمت عملی سے یہ فرض کیا گیا ہے کہ مستقبل میں رسائی کا نمونہ حالیہ ماضی تک رسائی کے نمونہ سے مشابہت کرے گا۔ ٹرانسپوز: ٹرانسپوز حکمت عملی اس خیال پر مبنی ہے جس نے حال ہی میں رسائی حاصل کی ہے۔"
    },
    {
        "Question": "ڈھیر ڈیٹا ڈھانچے میں کم سے کم عنصر کی تلاش میں وقت کی پیچیدگی کیا ہے؟",
        "Answer": "ڈھیر ڈیٹا ڈھانچے میں کم سے کم عنصر کی تلاش میں وقت کی پیچیدگی مستقل وقت ہے ، O (1)۔ایک کم سے کم ہیپ میں ، کم سے کم عنصر ہمیشہ روٹ نوڈ پر محفوظ کیا جاتا ہے ، جو اسے آسانی سے قابل رسائی اور بازیافت کرتا ہے۔ڈھیر کے سائز سے قطع نظر ، آپ مستقل وقت میں کم سے کم عنصر کو بازیافت کرنے کے لئے براہ راست روٹ نوڈ تک رسائی حاصل کرسکتے ہیں۔ یہ کم سے کم عنصر کی مستقل وقت کی بازیافت ہیپ ڈیٹا ڈھانچے کی ایک اہم خصوصیت ہے اور اس کی ایک وجہ ہے۔ترجیحی قطار میں موثر آپریشن اور الگورتھم کو چھانٹ رہا ہے۔دیگر کارروائیوں کی وقت کی پیچیدگی ، جیسے اندراج اور حذف کرنا ، ڈھیر کے مخصوص نفاذ پر منحصر ہے ، عام طور پر O (لاگ N) سے لے کر O (n) تک بدترین صورت میں ، جہاں N ڈھیر میں عناصر کی تعداد ہے۔.یہ قابل غور ہے کہ کم سے کم عنصر کو ہٹانے کے بعد ہیپ پراپرٹی کو برقرار رکھنا (عام طور پر ہیپائیفائ یا دوبارہ ہیپائیفائ کے عمل کے ذریعے) اضافی وقت کی ضرورت پڑسکتی ہے ، لیکن کم سے کم عنصر کی اصل بازیافت خود مستقل وقت کا عمل ہے۔"
    },
    {
        "Question": "ایک سپلی ٹری کیا ہے اور اسے کس طرح استعمال کیا جاتا ہے؟",
        "Answer": "ایک سپلی ٹری ایک خود کو ایڈجسٹ کرنے والا بائنری سرچ درخت ہے جو عناصر کے رسائی کے انداز کی بنیاد پر خود کو تنظیم نو کرتا ہے۔اس کا مقصد کثرت سے رسائی والے عناصر کی جڑ کے قریب لاکر ، مستقبل تک رسائی کے اوقات کو کم کرکے ، ایک سپلینگ کے درخت میں ، جب بھی کسی عنصر تک رسائی حاصل کی جاتی ہے (تلاش ، داخل کی جاتی ہے یا حذف) کو بہتر بنانا ہے ، اس کی جڑ میں لایا جاتا ہے۔گردشوں اور تنظیم نو کی کارروائیوں کی ایک سیریز کے ذریعے درخت۔اس عمل کو \"چھڑکنے\" کہا جاتا ہے۔چھڑکنے والا آپریشن درختوں کے ڈھانچے کو جڑوں میں رکھنے کے لئے ایڈجسٹ کرتا ہے ، جس سے بعد میں ہونے والی کارروائیوں میں رسائی آسان اور تیز تر ہوجاتی ہے۔ اسپلائنگ آپریشن عام طور پر تین اہم اقدامات پر مشتمل ہوتا ہے: زگ زگ یا زیگ زگ گردش: اگر رسائی حاصل شدہ عنصرایک پوتے یا پوتے کا بچہ ہے ، اس کو جڑ تک لانے کے لئے گردشوں کا ایک سلسلہ انجام دیا جاتا ہے۔اس میں یا تو زیگ زگ گردش شامل ہوسکتی ہے یا"
    },
    {
        "Question": "اسکیپ گراف ڈیٹا ڈھانچہ کیا ہے اور یہ کیسے کام کرتا ہے؟",
        "Answer": "اسکیپ گراف ایک احتمالی اعداد و شمار کا ڈھانچہ ہے جو متوازن سرچ درخت کی طرح موثر تلاش اور اشاریہ سازی کی صلاحیتوں کو فراہم کرتا ہے لیکن ایک آسان ساخت کے ساتھ۔یہ موثر تلاش اور اندراج کے کاموں کو حاصل کرنے کے ل Sk اسکیپ لسٹوں اور بائنری سرچ درختوں کے فوائد کو جوڑتا ہے۔ ایک اسکیپ گراف پرتوں کے ایک درجہ بندی پر مشتمل ہوتا ہے ، جس میں ہر نوڈس کی ایک منسلک فہرست ہوتی ہے۔اسکیپ گراف کی نچلی پرت ڈیٹا ڈھانچے میں موجود تمام عناصر کی ترتیب شدہ منسلک فہرست ہے۔اونچی پرتیں نچلی پرت کے کچھ عناصر پر انتخابی طور پر \"اسکیپنگ\" کے ذریعہ تخلیق کی جاتی ہیں ، جس میں شارٹ کٹ تشکیل دیتے ہیں جو تیز تر تلاشی کی اجازت دیتے ہیں۔ یہاں اسکیپ گراف کس طرح کام کرتا ہے: تعمیراتی: ابتدائی طور پر ، تمام عناصر کو اسکیپ گراف کی نیچے کی پرت میں داخل کیا جاتا ہے ،ترتیب شدہ لنکڈ فہرست تشکیل دینا۔ہر نوڈ میں ایک کلیدی قدر کی جوڑی ہوتی ہے اور اس میں ایک یا زیادہ فارورڈ پوائنٹر ہوسکتے ہیں جو اگلی اعلی پرت میں نوڈس کی طرف اشارہ کرتے ہیں۔ اسکپ کنکشن: اعلی پرتوں کو بنانے کے لئے ، ایک احتمال کا طریقہ استعمال کیا جاتا ہے۔نچلی پرت میں ہر نوڈ کے ل a ، ایک سکے ٹاس طے کرتا ہے کہ آیا اس میں اگلی اعلی پرت کا فارورڈ پوائنٹر ہوگا۔فارورڈ پوائنٹر رکھنے کا امکان کم ہوتا ہے کیونکہ پرت اونچی ہوتی ہے۔اس عمل سے ایک اسکیپ کنکشن پیدا ہوتا ہے جو نچلی پرت میں متعدد عناصر کو نظرانداز کرتا ہے ، جس سے تیز تر تلاشی کی اجازت ملتی ہے۔"
    },
    {
        "Question": "اسٹیک اور قطار کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "ایک اسٹیک اور قطار دونوں لکیری ڈیٹا ڈھانچے ہیں جو عناصر کو اسٹور اور منظم کرنے کے لئے استعمال ہوتے ہیں۔اسٹیک اور ایک قطار کے درمیان بنیادی فرق اس میں ہے کہ کس طرح عناصر کو شامل کیا جاتا ہے اور ہر ڈھانچے سے ہٹایا جاتا ہے ، جس کے نتیجے میں مختلف رسائی کے نمونوں اور طرز عمل کا نتیجہ ہوتا ہے۔ اسٹیک: ایک اسٹیک آخری ان فرسٹ آؤٹ (LIFO) اصول کی پیروی کرتا ہے ، اس کا مطلب ہے کہآخری عنصر داخل کیا گیا پہلا ایک ہے جس کو ہٹا دیا جاتا ہے۔ عنصر کو اسی سرے سے شامل اور ہٹا دیا جاتا ہے ، جسے اکثر اسٹیک کا \"اوپر\" کہا جاتا ہے۔ اسٹیک پر انجام دی جانے والی کارروائیوں کو عام طور پر \"پش\" کہا جاتا ہے (عنصر شامل کرتے ہوئے عنصر شامل کرتے ہیں۔اسٹیک کے اوپری حصے میں) اور \"پاپ\" (اسٹیک سے اوپر والے عنصر کو ہٹانا)۔ ایک اسٹیک کو عمودی ڈھانچے کے طور پر دیکھا جاسکتا ہے ، جہاں نئے عناصر ایک دوسرے کے اوپر کھڑے ہیں۔پہلے سے باہر (FIFO) اصول ، اس کا مطلب یہ ہے کہ پہلا عنصر داخل کیا گیا پہلا عنصر ہے جس کو ہٹا دیا جاتا ہے۔ عنصروں کو ایک سرے میں شامل کیا جاتا ہے ، جسے اکثر قطار کا \"عقبی\" یا \"پیچھے\" کہا جاتا ہے ، اور دوسرے سے ہٹا دیا جاتا ہےاختتام ، جسے اکثر قطار کا \"فرنٹ\" کہا جاتا ہے۔ قطار میں انجام دی جانے والی کارروائیوں کو عام طور پر \"انکیو\" کہا جاتا ہے (اس میں عنصر شامل کرتے ہیں"
    },
    {
        "Question": "فینوک درخت کیا ہے اور اس کا استعمال کیسے ہوتا ہے؟",
        "Answer": "ایک فینوک درخت ، جسے بائنری انڈیکسڈ ٹری (BIT) بھی کہا جاتا ہے ، ایک ایسا ڈیٹا ڈھانچہ ہے جو مؤثر طریقے سے سابقہ رقم کے سوالات کو انجام دینے اور کسی صف میں انفرادی عناصر کو اپ ڈیٹ کرنے کے لئے استعمال ہوتا ہے۔یہ متحرک صف میں عناصر کی مجموعی رقم کی گنتی اور اس میں ترمیم کرنے کا ایک موثر طریقہ فراہم کرتا ہے۔ فینوک کے درخت میں ایک سرنی پر مبنی نمائندگی ہے جو بائنری درخت کے ڈھانچے کو استعمال کرتی ہے۔یہ کیسے کام کرتا ہے: سرنی نمائندگی: فینوک ٹری کو سائز N+1 کی ایک صف کے طور پر پیش کیا جاتا ہے ، جہاں N اصل صف کا سائز ہے۔انڈیکس 0 میں اضافی عنصر 0. بائنری درختوں کے ڈھانچے کے طور پر شروع کیا گیا ہے: فینوک درخت میں ہر عنصر اصل صف میں عناصر کی ایک حد سے مساوی ہے۔خاص طور پر ، فینوک درخت میں انڈیکس I کے عنصر کے لئے ، اصل صف میں عناصر کی اسی رینج [i - lsone (i) + 1 ، i] ہے ، جہاں LSONE (i) کم سے کم اہمیت کی قدر ہے۔i.prefix SUM حساب کتاب کی بائنری نمائندگی: اصل صف میں دیئے گئے انڈیکس I تک عناصر کے سابقہ رقم کی گنتی کرنے کے لئے ، آپ فینوک کے درخت کو انڈیکس I سے اس کے والدین کے نوڈس تک منتقل کرتے ہیں جب تک"
    },
    {
        "Question": "گنتی کی ترتیب الگورتھم کیسے کام کرتی ہے؟",
        "Answer": "گنتی کی طرح ایک موثر الگورتھم ہے جو ایک معروف حد کے ساتھ عددیوں کے ذخیرے کو ترتیب دینے کے لئے استعمال ہوتا ہے۔یہ ان پٹ سرنی میں ہر عنصر کے لئے طے کرکے کام کرتا ہے ، عناصر کی تعداد جو اس سے چھوٹے ہیں۔ان گنتیوں کی بنیاد پر ، یہ ہر عنصر کو اپنی صحیح ترتیب شدہ پوزیشن میں رکھتا ہے۔ یہاں گنتی کی طرح کام کرتا ہے: گنتی کا مرحلہ: ان پٹ سرنی کو عبور کریں اور ہر انوکھے عنصر کے واقعات کو گنیں۔ان گنتیوں کو ذخیرہ کرنے کے لئے \"گنتی سرنی\" یا \"فریکوئینسی سرنی\" کے نام سے ایک معاون سرنی بنائیں۔"
    },
    {
        "Question": "ایک لنکڈ فہرست کو جگہ پر الٹ کرنے کے لئے کسی فنکشن کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ایک فنکشن کا ایک مثال ہے جس میں ایک واحد منسلک فہرست کو تبدیل کرنے کے لئے ایک فنکشن کا نفاذ ہے: پائیتھون کوپی کوڈکلاس لسٹنوڈ: ڈیف __init __ (خود ، قدر): سیلف.وال = ویلیو سیلف۔ نیکسٹ = نون ایڈف ریورس_ لنکڈ_ لسٹ (ہیڈ): # چیک کریں کہ آیا لنکڈ لسٹ ہے یا نہیںخالی یا صرف ایک نوڈ پر مشتمل ہے اگر سر نہیں ہے یا ہیڈ نہیں ہے۔ نیکسٹ: ریٹرن ہیڈ # موجودہ ، پچھلے ، اور اگلے نوڈس کو ٹریک رکھنے کے لئے تین پوائنٹرز کو شروع کریں = ہیڈ پچھلا = کوئی بھی # لنکڈ فہرست کے ذریعے نہیں ، لنکس کو تبدیل کرتے ہوئے ، جبکہ لنکس کو تبدیل کرتے ہوئے لنک کو تبدیل کرتے ہیں۔موجودہ: next_node = موجودہ۔ نیکسٹ # اگلے نوڈ کے حوالہ کو محفوظ کریں۔ nedext = پچھلا # الٹ لنک # پوائنٹرز کو اگلے نوڈس میں منتقل کریں پچھلے = موجودہ موجودہ = اگلے_نوڈ # ٹریورسل کے بعد ، پچھلا پوائنٹر اشارہ کرے گاالٹ لنکڈ لسٹ ریٹرن کا نیا سربراہ پچھلا ہے۔"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ معلوم کیا جاسکے کہ بائنری کا درخت بائنری تلاش کا درخت ہے۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا بائنری ٹری بائنری سرچ ٹری (بی ایس ٹی) ہے ، آپ مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک مددگار فنکشن کی وضاحت کریں ، آئیے اس کو IS_BST_UTIL کہتے ہیں ، جو بائنری ٹری نوڈ لیتا ہے ، اس کے ساتھ کم از کم اور زیادہ سے زیادہ قیمت بھی ہے کہ نوڈ کی قیمت ہے۔اندر آنا چاہئے۔یہ فنکشن بار بار جانچ پڑتال کرتا ہے کہ اگر درخت میں ہر نوڈ بی ایس ٹی پراپرٹی کو مطمئن کرتا ہے۔ IS_BST_UTIL فنکشن میں: بیس کیس: اگر نوڈ کوئی نہیں ہے تو ، سچ واپس لوٹیں (ایک خالی درخت ایک درست BST سمجھا جاتا ہے) ۔کیک کریں اگر نوڈ کی قیمت اس کے اندر ہے تو چیک کریںکم سے کم اور زیادہ سے زیادہ اقدار کے ذریعہ بیان کردہ حد۔اگر یہ حد سے باہر ہے تو ، غلط کو واپس کریں۔ موجودہ نوڈ کی قیمت کے طور پر تازہ ترین زیادہ سے زیادہ قیمت کے ساتھ بائیں بچے کے لئے IS_BST_UTIL پر کال کریں (بائیں سبٹری میں موجود تمام اقدار موجودہ نوڈ سے چھوٹی ہونی چاہئیں)۔موجودہ نوڈ کی قدر کے طور پر تازہ ترین کم سے کم قیمت (دائیں سب ٹری میں موجود تمام اقدار موجودہ نوڈ سے زیادہ ہونی چاہئیں)۔ اگر دونوں بار بار آنے والی کالیں درست لوٹ آئیں تو ، درست لوٹ آئیں ، اس بات کی نشاندہی کرتے ہیں کہ موجودہ نوڈ پر جڑے ہوئے سب ٹری ایک درست bst.finally ہے۔، ایک ریپر فنکشن بنائیں ، آئیے اسے کہتے ہیں `"
    },
    {
        "Question": "دو قطاروں کا استعمال کرتے ہوئے ایک اسٹیک کو نافذ کریں۔",
        "Answer": "دو قطاریں استعمال کرتے ہوئے اسٹیک کو نافذ کرنے کے ل you ، آپ مندرجہ ذیل نقطہ نظر کو استعمال کرسکتے ہیں: ایک اسٹیک کلاس بنائیں جو اندرونی طور پر دو قطاریں برقرار رکھے۔ پش آپریشن کے لئے: نئے عنصر کو قطار میں داخل کریں۔ پاپ آپریشن کے لئے: تمام عناصر کو قطار سے منتقل کریں"
    },
    {
        "Question": "\"انٹیجرز کی ایک صف کو دیکھتے ہوئے ، زیادہ سے زیادہ سبری کی رقم تلاش کرنے کے لئے ایک پروگرام لکھیں۔\"",
        "Answer": "انٹیجرز کی ایک صف میں زیادہ سے زیادہ سبری کا مجموعہ تلاش کرنے کے ل you ، آپ کڈانے کے الگورتھم کا استعمال کرسکتے ہیں ، جس میں O (n) کی وقت کی پیچیدگی ہوتی ہے۔ازگر میں یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف Find_max_subarray_sum (نمبر): اگر نمبر نہیں ہے تو: 0 میکس_سم = نمبرز [0] موجودہ_سم = نمبر [0] رینج (1 ، لین (نمبر)): کرنٹ_سم = میکس (نمبر (نمبر (نمبر)۔یہ دو متغیرات کی ابتدا کرتا ہے: میکس_سم اب تک کا زیادہ سے زیادہ رقم کا پتہ لگانے کے لئے ، اور موجودہ سبری کے جوڑے کو ٹریک کرنے کے لئے موجودہ_سم۔ دوسرے عنصر سے شروع ہونے والی صفوں کے ذریعے الگورتھم تکرار کرتا ہے۔ہر عنصر کے ل it ، یہ موازنہ کرتا ہے کہ آیا موجودہ عنصر سے نیا سبری شروع کرنا یا موجودہ عنصر کو شامل کرکے موجودہ سبری کو بڑھانا زیادہ فائدہ مند ہے۔یہ اس کے مطابق موجودہ_سم کو اپ ڈیٹ کرتا ہے اور زیادہ سے زیادہ رقم کا سامنا کرنا پڑتا ہے"
    },
    {
        "Question": "عدد کی ایک صف پر کوئکسورٹ انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ازگر میں کوئکسورٹ الگورتھم کا ایک مثال عمل ہے: پائیتھون کوپی کوڈیڈف کوئکسورٹ (اے آر آر): اگر لین (اے آر آر) <= 1: ریٹرن ارا پائیوٹ = آر آر [لین (اے آر آر) // 2] # درمیانی عنصر کو محور چھوٹے کے طور پر منتخب کریں۔= [x کے لئے x in arr اگر x <pivot] # محور برابر سے چھوٹے عناصر = [x کے لئے x x کے لئے x == محور] # پائیوٹ زیادہ کے برابر # عناصر = [x کے لئے x کے لئے اگر x> Pivot] # محور ریٹرن کوئکسورٹ (ایس ایم) سے زیادہ عناصر"
    },
    {
        "Question": "منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کریں۔",
        "Answer": "منٹ کے ڈھیر کا استعمال کرتے ہوئے ترجیحی قطار کو نافذ کرنے کے ل you ، آپ کر سکتے ہیں"
    },
    {
        "Question": "اس بات کا تعین کرنے کے لئے ایک پروگرام لکھیں کہ آیا دو بائنری درخت ایک جیسے ہیں یا نہیں۔",
        "Answer": "اس بات کا تعین کرنے کے لئے کہ آیا دو بائنری درخت ایک جیسے ہیں ، آپ ان کے نوڈس کا متناسب موازنہ کرسکتے ہیں۔ازگر میں ایک مثال کے نفاذ: پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، ویل = 0 ، بائیں = کوئی نہیں ، کوئی بھی نہیں): سیلف.وال = ویل سیلف۔: # بیس کیس: اگر دونوں درخت خالی ہیں تو ، وہ ایک جیسے ہیں اگر ٹری 1 کوئی نہیں ہے اور ٹری 2 کوئی نہیں ہے: سچ واپس # اگر درختوں میں سے ایک ہی خالی ہے تو ، وہ ایک جیسے نہیں ہیں اگر ٹری 1 کوئی نہیں ہے یا ٹری 2 کوئی نہیں ہے: غلط واپس کریں غلط# چیک کریں کہ آیا موجودہ نوڈس کی اقدار برابر ہیں اگر درخت 1۔ول! = ٹری 2۔ول: غلط واپس لوٹائیں # بائیں اور دائیں ذیلی ذیلیوں کو بار بار چیک کریں"
    },
    {
        "Question": "شروع سے ہیش ٹیبل کو نافذ کریں۔",
        "Answer": "شروع سے ایک مکمل ہیش ٹیبل پر عمل درآمد کرنا ایک پیچیدہ کام ہوسکتا ہے۔تاہم ، میں آپ کو ایک بنیادی تفہیم فراہم کرنے کے لئے آپ کو ازگر میں ہیش ٹیبل کا آسان نفاذ فراہم کرسکتا ہوں۔یہاں ایک مثال عمل ہے: پائیتھون کوپی کوڈکلاس ہیش ٹیبل: ڈیف __init __ (خود ، سائز): سیلف۔ سائز = سائز سیلف۔ ٹیبل = [] _ میں _ کے لئے (سائز)] ڈیف _hash_function (خود ، کلید): ریٹرن ہیش (کلید)٪ self.size"
    },
    {
        "Question": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "غیر ترتیب شدہ صف میں کے ٹی ایچ کے سب سے بڑے عنصر کو تلاش کرنے کے ل you ، آپ \"کوئیک سلیکٹ\" الگورتھم نامی کوئکسورٹ الگورتھم کی مختلف حالتوں کا استعمال کرسکتے ہیں۔خیال یہ ہے کہ محور عنصر کا استعمال کرتے ہوئے صف کو تقسیم کیا جائے اور پیوٹ کی نسبتہ پوزیشن کی بنیاد پر تقسیم کے مطلوبہ پہلو پر بار بار توجہ مرکوز کی جائے۔ ہر کی مثال ازگر میں ایک مثال کے طور پر عمل درآمد: پائیتھون کوپی کوڈ ڈیف فائنڈ_ کےتھ_لارجسٹ (نمبر ، کے): # صف کو دوبارہ ترتیب دیںکوئیک سلیکٹ الگورتھم # کا استعمال کرتے ہوئے # جب تک کہ کے ٹی ایچ کا سب سے بڑا عنصر اپنی ترتیب شدہ پوزیشن میں نہ ہو تو کوئیک_ سلیکٹ (نمبرز ، 0 ، لین (نمبر) - 1 ، کے) ڈیف کوئیک_ سلیکٹ (نمبرز ، کم ، اونچائی ، کے): # تقسیم کریں سرنی اور اس کو حاصل کریںپیوٹ انڈیکس PIVOT_INDEX = پارٹیشن (نمبر ، کم ، اونچا) # محور انڈیکس کی پوزیشن چیک کریں اگر Pivot_index == لین (نمبر) - K: # محور KTH کا سب سے بڑا عنصر ریٹرن نمبر ہے [Pivot_index] Elif Pivot_index> len (nums (nums) - K:"
    },
    {
        "Question": "سرکلر بفر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہاں ازگر میں سرکلر بفر ڈیٹا ڈھانچے کا نفاذ ہے: پائیتھون کوپی کوڈکلاس سرکلر بفر: ڈیف __ __init __ (خود ، صلاحیت): خود کی صلاحیت = صلاحیت خود ۔بفر = [کوئی نہیں] * صلاحیت سیلف ہیڈ = 0 سیلف۔ ٹیل = 0 خود۔سائز = 0 Def is_empty (self): sellسرکلر بفر بھرا ہوا ہے \") سیلف۔ بفر [خود۔ ٹیل] = آئٹم سیلف۔استثناء کو بڑھاؤ (\"سرکلر بفر خالی ہے\") آئٹم = سیلف بفر [سیلف ہیڈ]"
    },
    {
        "Question": "گراف پر چوڑائی کی پہلی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ازگر میں چوڑائی کی پہلی تلاش (بی ایف ایس) الگورتھم کا ایک مثال ہے: پائیتھون کوپی کوڈفرم کلیکشن درآمد ڈیکیڈف بی ایف ایس (گراف ، اسٹارٹ): ملاحظہ کریں = سیٹ () قطار = ڈیک ([اسٹارٹ]) ملاحظہ کریں۔نوڈ = قطار.پوپلفٹ () پرنٹ (نوڈ ، اینڈ = \"\") # گراف میں پڑوسی کے لئے نوڈ (یا کوئی مطلوبہ آپریشن کریں) پر کارروائی کریں [نوڈ]: اگر پڑوسی میں نہیں ملاحظہ کریں: قطار۔ اپینڈ (پڑوسی) ملاحظہ کریں۔(پڑوسی)# مثال گراف جس کی نمائندگی ملحقہ فہرست گراف = {'A': ['B' ، 'C'] ، 'B': ['a' ، 'd' ، 'e'] ، 'C': ['a' ، 'f'] ، 'd': ['b'] ، 'e': ['b' ، 'f'] ، 'f': ['c' ، 'e']} start_node = 'a'print (\"BFS Traversal:\") BFS (گراف ، اسٹارٹ_نوڈ) اس مثال میں ، ہمارے پاس ایک گراف ہے جس کی نمائندگی ملحقہ فہرست کے طور پر کی جاتی ہے۔گراف ڈکشنری عمودی کو چابیاں اور ان سے ملحقہ ملحقہ عمودی کو اقدار کے طور پر اسٹور کرتی ہے۔بی ایف ایس فنکشن مخصوص اسٹارٹ نوڈ سے شروع ہونے والے گراف پر چوڑائی کی پہلی تلاش انجام دیتا ہے۔ الگورتھم نوڈس کو دیکھنے کے لئے ٹریک رکھنے کے لئے ایک قطار (ڈیک کا استعمال کرتے ہوئے) استعمال کرتا ہے۔اس کا آغاز قطار میں اسٹارٹ نوڈ کو شامل کرکے اور اسے ملاحظہ کے ساتھ نشان زد کرکے شروع ہوتا ہے۔جبکہ وہاں موجود ہیں"
    },
    {
        "Question": "ترتیب شدہ لنکڈ فہرست میں بائنری سرچ الگورتھم کو نافذ کریں۔",
        "Answer": "ایک ترتیب شدہ لنکڈ فہرست میں بائنری سرچ الگورتھم کو نافذ کرنے کے ل we ، ہمیں فہرست کی ترتیب شدہ نوعیت سے فائدہ اٹھانے اور بائنری تلاش کا ایک ترمیم شدہ ورژن انجام دینے کی ضرورت ہے۔ازگر میں ایک مثال کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس لسٹنوڈ: ڈیف __init __ (خود ، ویل = 0 ، اگلا = کوئی نہیں): سیلف.وال = ویل سیلف۔ نیکسٹ = نیکسٹ ڈیف بائنری_سرچ (سر ، ہدف): بائیں ، دائیں = سر ، جبکہ کوئی نہیںبائیں! = دائیں: درمیانی = get_middle (بائیں ، دائیں) اگر درمیانی.اول == ہدف: مڈ ایلیف مڈ.ول <ہدف: بائیں = وسط۔ نیکسٹ لوٹ کریں: دائیں = وسط ریٹرن نونیڈف گیٹ_مڈل (بائیں ، دائیں): سست= بائیں بازو = بائیں بازو کے وقت بائیں"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ آیا دیئے گئے تار ایک پیلنڈرووم ہے۔",
        "Answer": "یقینا!ازگر میں ایک پروگرام یہ ہے کہ اس بات کا تعین کرنے کے لئے کہ آیا دیئے گئے سٹرنگ ایک پالندرووم ہے: پائیتھون کوپی کوڈیڈف is_palindrome (s): s = s.lower () # کیس کو غیر حساس موازنہ کے لئے چھوٹے حصے میں تبدیل کریں = 0 دائیں = لین (s) - 1جبکہ بائیں <دائیں: اگر نہیں [بائیں] .isalnum (): # بائیں بائیں طرف سے غیر الفانومرک حروف کو نظرانداز کریں += 1 الیف نہیں ہے [دائیں] .isalnum (): # دائیں دائیں طرف سے غیر الفینومیرک حروف کو نظرانداز کریں-=1 الیف ایس [بائیں]! = s [دائیں]: # حرفوں کا موازنہ غلط لوٹتے ہیں اور: بائیں += 1 دائیں -= 1 سچائی # مثال usagestring1 = \"ایک آدمی ، ایک منصوبہ ، ایک نہر: پاناما\" پرنٹ (is_palindrome (is_palindrome (سٹرنگ 1)) # آؤٹ پٹ: truestring2 = \"Racecar\" پرنٹ (is_palindrome (سٹرنگ 2)) # آؤٹ پٹ: truestring3 = \"ہیلو\" پرنٹ (is_palindrome (سٹرنگ 3))"
    },
    {
        "Question": "بائنری ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں بائنری ہیپ کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس بائنری ہیپ: ڈیف __init __ (خود): سیلف۔ ہیپ = [] ڈیف سائز (خود): ریٹرن لین (سیلف۔ ہیپ) ڈیف آئی ایس ای ایم پی (سیلف): ریٹرن لین (واپس (خود)self.heap) == 0 Def داخل کریں (خود ، آئٹم): سیلف.اپ.اپی اینڈ (آئٹم) سیلف۔اگر سیلف۔(خود ، انڈیکس): والدین = (انڈیکس - 1) // 2"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ دیئے گئے بائنری درخت متوازن ہیں یا نہیں۔",
        "Answer": "یقینا!ازگر میں ایک پروگرام یہ ہے کہ اگر دیئے گئے بائنری ٹری متوازن ہے تو اس بات کا تعین کرنے کے لئے کہ پائیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __init __ (خود ، قدر): سیلف ویلیو = ویلیو خود۔کوئی نہیں: سچ # # بائیں اور دائیں subtres کے درمیان اونچائی کے فرق کو چیک کریںسبٹریز متوازن واپسی ہیں۔"
    },
    {
        "Question": "ٹری ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں ٹری ڈیٹا ڈھانچے کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس ٹرائینوڈ: ڈیف __init __ (خود): سیلف۔ چائلڈین = {} sellخود ، لفظ): موجودہ = خود۔، لفظ): کرنٹ = سیلف۔ لفظ میں چار کے لئے: اگر کرنٹ میں نہیں ہے۔ اگر موجودہ میں نہیں۔ بچوں کو واپس کریں = موجودہ = موجودہ۔ چائلڈین [چار] واپس کریں۔پریفکس میں چار: اگر کرنٹ میں نہیں۔ بچوں کو واپس کریں۔\") trie.insert (\" CAR \") trie.Insert (\" CAT \") # ٹری پرنٹ (trie.search (\" ایپل \")) میں الفاظ تلاش کریں # آؤٹ پٹ: ٹروپنٹ (trie.search (\" کیلے \")) #آؤٹ پٹ: ٹروپنٹ (ٹری۔ سرچ (\"کار\")) # آؤٹ پٹ: ٹروپنٹ (ٹری.سرچ (\"بلی\")) # آؤٹ پٹ"
    },
    {
        "Question": "کسی گراف پر گہرائی کی پہلی تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!ملحقہ فہرست کا استعمال کرتے ہوئے نمائندگی کرنے والے گراف پر گہرائی سے پہلے تلاش (ڈی ایف ایس) انجام دینے کے لئے ازگر میں ایک پروگرام ہے: پائیتھون کوپی کوڈکلاس گراف: ڈیف __INIT __ (خود ، عمودی): سیلف.ورٹیس = ورٹیسس سیلف۔رینج میں (عمودی)] ڈیف ایڈ_ج (خود ، ایس آر سی ، ڈسٹ): سیلف ڈاٹ ایڈج_ لسٹ [ایس آر سی]] * سیلف .ورٹیسس سیلف۔ملاحظہ [پڑوسی]: سیلف۔."
    },
    {
        "Question": "خود توازن بائنری تلاش کے درخت کو نافذ کریں۔",
        "Answer": "خود توازن رکھنے والے بائنری سرچ درخت کو نافذ کرنا ، جیسے اے وی ایل درخت یا سرخ رنگ کا درخت ، ایک پیچیدہ کام ہوسکتا ہے۔اس کے لئے درختوں کی گردشوں پر محتاط غور کرنے اور اضافے اور حذف ہونے کے دوران درخت کے توازن کے معیار کو برقرار رکھنے کی ضرورت ہے۔ذیل میں ازگر میں اے وی ایل کے درخت کا ایک آسان عمل درآمد ہے: پیتھون کوپی کوڈکلاس Avlnode: Def __Init __ (خود ، کلید): self.key = key self.left = کوئی بھی نہیں۔ کوئی خود نہیں۔): self.root = کوئی بھی Def get_height (سیلف ، نوڈ): اگر نوڈ کوئی نہیں ہے: واپس 0 واپسی نوڈ۔، self.get_height (node.right)) Def get_blance (خود ، نوڈ): اگر نوڈ کوئی نہیں ہے: واپس 0 لوٹ واپس کریں۔"
    },
    {
        "Question": "عدد کی ایک صف پر انضمام کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہ ایک ازگر پروگرام ہے جو عددیوں کی ایک صف پر انضمام کی ترتیب الگورتھم کو انجام دیتا ہے: پائیتھون کوپی کوڈیڈف انضمام_سورٹ (اے آر آر): اگر لین (آر آر) <= 1: آر اے آر آر # آر # سرے کو دو حصوں میں تقسیم کریں = لین (آر اے آر) // 2بائیں_ہالف = آر [: وسط] دائیں_ہلف = آر آر [وسط:] # بار بار دو حصوں کو بائیں_ہالف = انضمام_سورٹ (بائیں_ہالف) کو ترتیب دیں۔، دائیں): ضم شدہ = [] i = j = 0 جبکہ میں <لین (بائیں) اور جے <لین (دائیں): اگر بائیں [i] <= دائیں [j]: ضم شدہ۔ اپینڈ (بائیں [i]) i+= 1 اور: ضم شدہ۔ اپینڈ (دائیں [j]) j += 1 # بائیں یا دائیں صف سے باقی عناصر شامل کریں جبکہ میں <لین (بائیں): ضم شدہ۔ اپینڈ (بائیں [i]) i += 1"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک فنکشن لکھیں کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں یا نہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر کا فنکشن یہ ہے کہ آیا یہ چیک کرنے کے لئے کہ آیا دو ڈور ایک دوسرے کے اناگرام ہیں: پائیتھون کوپی کوڈیڈف ARE_ANAGRAMS (STR1 ، STR2): # وائٹ اسپیس کو ہٹا دیں اور تار کو لوئر کیس STR1 = str1.repleas (\"\" \") میں تبدیل کریں۔str2.replace (\"\" ، \"\") .lower () # چیک کریں کہ آیا تار کی لمبائی برابر ہے اگر لین (str1)! = لین (str2): غلط # دونوں تار کے لئے فریکوئینسی لغت بنائیں freq_dict1 = {} freq_dict2= {} # str1 میں str1 میں ہر کردار کی تعدد کو str1 میں شمار کریں: freq_dict1 [چار] = freq_dict1.get (چار ، 0) + 1 # str2 میں ہر کردار کی تعدد گنیں"
    },
    {
        "Question": "شروع سے ایک واحد منسلک فہرست کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں ایک واحد منسلک فہرست کا نفاذ یہاں ہے: پیتھون کوپی کوڈکلاس نوڈ: Def __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ نیکسٹ = نان کلاس لنکڈ لسٹ: ڈیف __init __ (خود)): ریٹرن سیلف۔ ہیڈ کوئی بھی نہیں ہے۔.is_empty (): self.head = new_node else: موجودہ = سیلف ہیڈ جبکہ موجودہ۔ نیکسٹ: کرنٹ = کرنٹ۔ نیکسٹ موجودہ۔ نیکسٹ = نیا_نوڈ ڈیف داخل کریں_ٹ_پوزیشن (خود ، ڈیٹا ، پوزیشن): اگر پوزیشن <= 0: خود۔insert_at_beginning (ڈیٹا) ELIF پوزیشن> = سیلف. گیٹ_ لمبائی ():"
    },
    {
        "Question": "عدد کی ایک صف پر بائنری تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!انٹیجرز کی ترتیب شدہ صف پر بائنری تلاش کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈ ڈیف بائنری_سارچ (اے آر آر ، ہدف): کم = 0 ہائی = لین (اے آر آر) - 1 جبکہ کم <= اعلی: درمیانی = (کم + اعلی) // 2 اگر err [وسط] == ہدف: مڈ ایلف آر آر [وسط] <ہدف: کم = وسط + 1 اور: اعلی = وسط - 1 ریٹرن -1# مثال usagearr = [2 ، 4 ، 6 ، 8 ، 10، 12 ، 14 ، 16 ، 18 ، 20] ہدف"
    },
    {
        "Question": "منسلک فہرست کا استعمال کرتے ہوئے اسٹیک کو نافذ کریں۔",
        "Answer": "یقینا!لنکڈ لسٹ کا استعمال کرتے ہوئے اسٹیک کا ایک ازگر کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیل۔ نیکسٹ = نانکلاس اسٹیک: ڈیف __init __ (خود): سیلف۔ ٹوپ = کوئی بھی نہیں ہے۔خود): ریٹرن سیلف نہیں۔\"اسٹیک خالی ہے۔ پاپ کرنے سے قاصر ہے۔\") کوئی بھی ڈیٹا = سیلف ٹوپ.ڈیٹا سیلف۔ ٹاپ = سیلف۔ ٹوپ۔ نیکسٹ ڈیٹا ڈیف جھانکنے والا (خود): اگر سیلف۔ آئی ایس_پٹی (): پرنٹ (\"اسٹیک خالی ہے. جھانکنے سے قاصر۔ \") کوئی بھی واپس نہیں لوٹ کر۔ڈیٹا ، اختتام = \" ->\") موجودہ = موجودہ۔ نیکسٹ پرنٹ (\"کوئی نہیں\")# مثال یوس ایگسٹیک = اسٹیک () اسٹیک۔ پش (10) اسٹیک.پش (20) اسٹیک"
    },
    {
        "Question": "ایک پروگرام لکھیں تاکہ اس بات کا تعین کیا جاسکے کہ دیئے گئے بائنری ٹری متوازن بائنری تلاش کا درخت ہے یا نہیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جس کا تعین کرنے کے لئے کہ آیا بائنری ٹری ایک متوازن بائنری سرچ ٹری ہے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __ __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ سیلف = کوئی بھی نہیں۔اگر جڑ کوئی نہیں ہے: سچ واپس کریں # چیک کریں کہ آیا بائیں subtree بائیں_ہائٹ = get_height (روٹ. لیفٹ) ہے اگر بائیں_ہائٹ == -1: غلط واپس کریں # دیکھیں # چیک کریں کہ آیا دائیں سب ٹری متوازن ہے۔== -1: غلط واپس لوٹیں # چیک کریں کہ اگر موجودہ نوڈ متوازن ہے تو اگر ABS (بائیں_ہائٹ - دائیں_ہائٹ)> 1: غلط واپسی ٹرایڈف گیٹ_ہائٹ (نوڈ) واپس کریں: اگر نوڈ کوئی نہیں ہے تو: واپس 0 بائیں_ہائٹ = get_height (نوڈ۔= get_height (node.right) # اگر کوئی سب ٹری غیر متوازن ہے تو ، واپس -1 -1 اگر بائیں_ہائٹ == -1 یا دائیں_ہائٹ == -1: واپسی -1 # اگر موجودہ نوڈ متوازن ہے تو ، واپس -1 -1 اگر ABS (بائیں_ہائٹ -دائیں_ صحت سے متعلق ہے۔)> 1:"
    },
    {
        "Question": "دو اسٹیکس کا استعمال کرتے ہوئے قطار کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!یہاں دو اسٹیکس کا استعمال کرتے ہوئے قطار کا ایک ازگر کا نفاذ ہے: پائیتھون کوپی کوڈکلاس قطار: ڈیف __init __ (خود): سیلف۔ ان_ اسٹیک = [] سیلف۔ آؤٹ_ اسٹیک = [] ڈیف آئی ایس ای پی آئی ایس پی (سیلف): ریٹرن لین (سیلف۔ ان_ اسٹیک) == 0 اورلین (self.out_stack) == 0 def enqueue (خود ، ڈیٹا): سیلف.این_سٹیک.ایپینڈ (ڈیٹا) ڈیف ڈی کیوئو (خود): اگر سیلف.س_پٹی (): پرنٹ (\"قطار خالی ہے۔ ڈی کیوئو سے قاصر ہے۔\") اگر لین (self.out_stack) == 0: # in_stack سے out_stack پر عناصر کی منتقلی کریں جبکہ لین (self.in_stack)> 0: سیلف۔ آؤٹ_سٹیک.ایپینڈ (self.in_stack.pop ()) سیلف۔ آؤٹ_ اسٹیک واپس کریں۔پاپ () ڈیف پیک (خود): اگر سیلف۔ آئی ایس_پٹی (): پرنٹ (\"قطار خالی ہے۔ جھانکنے سے قاصر ہے۔لین (self.in_stack)> 0: self.out_stack.append (self.in_stack.pop ()) واپس لوٹیں۔. \") واپسی پرنٹ (\" فرنٹ -> \"، اینڈ =\" \") پرنٹ (*سیلف آؤٹ_ اسٹیک [:: -1] ، ستمبر =\" -> \"، اینڈ =\" \") پرنٹ (\" < -پیچھے \")# مثال کے استعمال کے استعمال = قطار () قطار۔"
    },
    {
        "Question": "الفاظ کی ترتیب کو تار میں الٹا کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!الفاظ کی ترتیب کو تار میں تبدیل کرنے کے لئے یہاں ایک ازگر پروگرام ہے: پائیتھون کوپی کوڈیڈف ریورس_ ورڈز (سٹرنگ): # انفرادی الفاظ میں سٹرنگ کو انفرادی الفاظ میں تقسیم کریں۔# ایک نئے سٹرنگ الٹ الٹ_سٹرنگ = '' کی تشکیل کے لئے الٹ الفاظ میں شامل ہوں۔ join (الٹ_ ورڈز) واپسی الٹ_سٹرنگ# مثال کے طور پر استعمال کریں۔فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اس میں الفاظ کی ترتیب کو تبدیل کرتا ہے۔سب سے پہلے ، اسٹرنگ کو تقسیم کے طریقہ کار کا استعمال کرتے ہوئے انفرادی الفاظ میں تقسیم کیا جاتا ہے ، جو الفاظ کی فہرست بناتا ہے۔اس کے بعد ، الفاظ کی فہرست [::-1] سلائسنگ تکنیک کا استعمال کرتے ہوئے الٹ ہے۔آخر میں ، الٹ الفاظ میں شامل ہونے کے طریقہ کار کا استعمال کرتے ہوئے ، ایک جگہ کے ساتھ ، ایک نیا الٹ سٹرنگ تشکیل دینے کے لئے ، ایک ساتھ مل کر شامل ہوجاتے ہیں۔، اس کے ساتھ ریورس_ورڈز فنکشن کو کال کرتا ہے ، اور الٹ سٹرنگ کو پرنٹ کرتا ہے۔آؤٹ پٹ `\" حیرت انگیز ہے۔ اوپن آئی ورلڈ ہے! ہیلو \""
    },
    {
        "Question": "کم سے کم میکس ہیپ ڈیٹا ڈھانچہ کو نافذ کریں۔",
        "Answer": "ایک من میکس ہیپ ایک خصوصی ڈیٹا ڈھانچہ ہے جو کم سے کم اور زیادہ سے زیادہ عناصر دونوں کی موثر اندراج ، حذف کرنے اور بازیافت کی حمایت کرتا ہے۔یہاں ایک کم سے کم میکس ہیپ کا ازگر کا نفاذ ہے: پائیتھون کوپی کوڈکلاس منماکسیپ: ڈیف __init __ (خود): سیلف۔ ایچ ای اے پی = [] ڈیف آئی ایس ای پی ٹی (خود): ریٹرن لین (سیلف۔ ہیپ) == 0 ڈیف گیٹ_مین (خود): اگرself.is_empty (): پرنٹ (\"ہیپ خالی ہے۔\".2]) ڈیف داخل کریں (خود)"
    },
    {
        "Question": "دو ڈوروں کے مابین سب سے طویل عام حصول تلاش کرنے کے لئے ایک فنکشن لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر فنکشن ہے جو متحرک پروگرامنگ کا استعمال کرتے ہوئے دو تاروں کے مابین سب سے طویل عام طور پر پائے جاتے ہیں: پائیتھون کوپی کوڈڈیف طویل ترین_کومون_سوبسینس (ایس ٹی آر 1 ، ایس ٹی آر 2): ایم = لین (ایس ٹی آر 1) این = لین (ایس ٹی آر 2) # لمبے لمبے عام حصے کی لمبائی کو ذخیرہ کرنے کے لئے ایک جدول بنائیں۔dp = [[0] * (n + 1) _ کے لئے _ میں حد (m + 1)] # رینج (1 ، m + 1) کے لئے متحرک پروگرامنگ کا استعمال کرتے ہوئے ٹیبل کو بھریں (1 ، m + 1)1): اگر str1 [i - 1] == str2 [j - 1]: dp [i] [j] = dp [i - 1] [j - 1] +"
    },
    {
        "Question": "ڈیجکسٹرا کے مختصر ترین راستے الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!وزن والے گراف میں مختصر ترین راستہ تلاش کرنے کے لئے ڈیجکسٹرا کے الگورتھم کا یہاں ایک ازگر کا نفاذ ہے: پائیتھون کوپی کوڈیمپورٹ ہیپ کیو ففوم کلیکشنز درآمد ڈیفالٹ ڈکٹ ڈیف ڈجکسٹرا (گراف ، اسٹارٹ): # عمودی حصے کو ذخیرہ کرنے کے لئے ترجیحی قطار بنائیں = [(0 ، اسٹارٹ)] # تخلیقاسٹارٹ ورٹیکس سے لے کر ہر ورٹیکس فاصلوں تک فاصلوں کو ذخیرہ کرنے کے لئے ایک لغت = ڈیفالٹ ڈکٹ (لیمبڈا: فلوٹ ('انف')) فاصلوں [اسٹارٹ] = 0 # پچھلے عمودی کو مختصر ترین راستے میں اسٹور کرنے کے لئے ایک لغت بنائیں = {}پی کیو: # ترجیحی قطار ڈسٹرکٹ سے کم سے کم فاصلے کے ساتھ ورٹیکس کو پاپ کریں ، موجودہ = ہیپ کیو ہپپپ (پی کیو) # اگر پاپڈ ورٹیکس پہلے ہی ملاحظہ کیا گیا ہے تو ، اس کو چھوڑیں اگر ڈسٹ> فاصلوں [موجودہ]: جاری رکھیں # پڑوسیوں کو تلاش کریںپڑوسی کے لئے موجودہ عمودی ، گراف میں وزن [موجودہ]: # اسٹارٹ ورٹیکس سے پڑوسی سے نیا فاصلہ نیا_ڈیسٹ = ڈسٹ + وزن # # اگر نیا فاصلہ پہلے ریکارڈ شدہ فاصلے سے چھوٹا ہے تو ، اس کو اپ ڈیٹ کریں اگر new_dist <فاصلوں [پڑوسی]: فاصلے [پڑوسی] = نیا_ ڈسٹ پچھلا [پڑوسی] = موجودہ"
    },
    {
        "Question": "دو ترتیب شدہ صفوں کے وسط تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!یہاں ایک ازگر پروگرام ہے جس میں دو ترتیب شدہ صفوں کا درمیانی درجے کا پتہ چلتا ہے: پائیتھون کوپی کوڈڈیف Find_median_sorted_arrays (Nums1 ، Nums2): # دونوں صفوں کو ایک ہی ترتیب شدہ سرنی میں مل کر = ترتیب شدہ (Nums1 + nums2) # مشترکہ صف کی لمبائی کی لمبائی تلاش کریں۔لین (مشترکہ) # چیک کریں کہ آیا مشترکہ سرنی کی لمبائی عجیب یا اس سے بھی لمبائی ہے اگر لمبائی ٪ 2 == 1: # اگر لمبائی عجیب ہے تو ، درمیانی عنصر میڈین = مشترکہ [لمبائی // 2] واپس لوٹائیں اور: # اگر لمبائی کی لمبائییہاں تک کہ ، درمیانی دو عناصر کی اوسط کا حساب لگائیں = لمبائی // 2 میڈین = (مشترکہ [درمیانی - 1"
    },
    {
        "Question": "خود توازن رکھنے والے AVL درخت کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں خود توازن رکھنے والے اے وی ایل کے درخت کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس Avlnode: Def __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ خود۔"
    },
    {
        "Question": "بائنری درخت پر آرڈر میں درختوں کی سیر کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!بائنری ٹری پر آرڈر میں درختوں کی ٹریورسل کو انجام دینے کے لئے یہاں ایک پروگرام ہے: پیتھون کوپی کوڈکلاس ٹرینوڈ: ڈیف __ __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔: in_order_traversal (روٹ.لفٹ) پرنٹ (روٹ.ڈیٹا ، اختتام = \"\") in_order_traversal (روٹ. رائٹ)# مثال کے استعمال# بائنری ٹریروٹ = ٹرینوڈ (1) روٹ. لیفٹ = ٹرینوڈ (2) روٹ۔ روٹ = ٹرینیوڈ بنائیں۔.بائنری درختہر نوڈ میں ڈیٹا ویلیو ہوتا ہے ، نیز اس کے بائیں اور دائیں پوائنٹرز اس کے بائیں اور دائیں بچے کے نوڈس ہوتے ہیں۔ in_order_traversal فنکشن IN کو انجام دیتا ہے"
    },
    {
        "Question": "بلوم فلٹر ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں بلوم فلٹر ڈیٹا ڈھانچے کا نفاذ یہاں ہے: پائیتھون کوپی کوڈیمپورٹ ایم ایم ایچ 3 فریم بٹلری امپورٹ بٹلرائکلاس بلوم فلٹر: ڈیف __init __ (خود ، سائز ، Num_hashes): خود۔bit_array.setall (0) Def شامل کریں (خود ، آئٹم): بیج میں بیج کے لئے (سیلف۔ نیم_ھاش): انڈیکس = ایم ایم ایچ 3. ہش (آئٹم ، بیج) ٪ سیلف۔ خود۔، آئٹم): بیج میں بیج کے لئے (self.num_hashes): انڈیکس = mmh3.hash (آئٹم ، سیڈ) ٪ خود۔ خود.، کے لئے ، کے لئے ، کے لئے ،."
    },
    {
        "Question": "دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!کسی دیئے گئے تار کے تمام اجازت نامے تیار کرنے کے لئے ایک پروگرام یہ ہے: پائیٹون کوپی کوڈیڈف پرمٹیشن (سٹرنگ): # بیس کیس: اگر تار خالی ہے تو ، اگر لین (سٹرنگ) == 0: واپسی [] # بیس کیس: اگر کوئی خالی اجازت واپس کریں تواسٹرنگ میں صرف ایک ہی کردار ہوتا ہے ، اگر لین (سٹرنگ) == 1: تمام اجازت نامے کے نتائج کو اسٹور کرنے کے لئے لیٹ [سٹرنگ] # فہرست کو دوبارہ ترتیب کے طور پر واپس کرنے کے طور پر واپس کریں۔لین (سٹرنگ)): # موجودہ کردار موجودہ_چار = سٹرنگ [i] # بقیہ حروف کے باقی حصوں کی ترتیب کو تیار کریں۔پرمٹیشن_ف_ریمیننگ میں پرم کے لئے باقی حروف کی ہر ترتیب کا کردار: نتیجہ۔پرمٹیشن فنکشن ان پٹ کے طور پر ایک تار لیتا ہے اور اس سٹرنگ کے تمام ترتیب کو بار بار تیار کرتا ہے۔ بیس کیسز کو پہلے سنبھالا جاتا ہے۔"
    },
    {
        "Question": "سرخ سیاہ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "مکمل سرخ سیاہ درخت کے اعداد و شمار کے ڈھانچے کو نافذ کرنا ایک پیچیدہ کام ہے ، لیکن یہاں سرخ رنگ کے درخت کی کلیدی کارروائیوں اور خصوصیات کا ایک جائزہ ہے: ایک سرخ رنگ کا درخت ایک قسم کا خود توازن بائنری سرچ درخت ہے جو مندرجہ ذیل کو برقرار رکھتا ہے۔پراپرٹیز: ہر نوڈ یا تو سرخ یا سیاہ ہوتا ہے۔ جڑ سیاہ ہے۔ ہر پتی (نیل یا نول نوڈ) سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔ نوڈ سے اس کی اولاد کے پتوں تک ہر آسان راستہ پر مشتمل ہوتا ہے۔سیاہ نوڈس کی ایک ہی تعداد (اسے سیاہ اونچائی کے نام سے جانا جاتا ہے)۔ سرخ رنگ کے درختوں کی کارروائیوں میں اندراج ، حذف کرنا ، اور تلاش کرنا شامل ہے ، اور وہ بائنری سرچ درخت میں اسی طرح کی کارروائیوں سے ملتے جلتے ہیں۔تاہم ، کلیدی فرق ان کارروائیوں کے دوران سرخ سیاہ خصوصیات کو برقرار رکھنے کے قواعد میں ہے۔ سرخ رنگ کے درخت کو نافذ کرنے کے ل you ، آپ عام طور پر ایک نوڈ کلاس کی وضاحت کریں گے جو درخت میں نوڈ کی نمائندگی کرتا ہے۔ہر نوڈ میں اس کی کلید ، قدر ، رنگ (سرخ یا سیاہ) کے لئے خصوصیات ہوں گی ، اور اس کے بائیں بچے کی طرف اشارہ کریں"
    },
    {
        "Question": "بائنری درخت پر پری آرڈر ٹری ٹریور کو انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!بائنری ٹری پر پری آرڈر ٹری ٹریورسل کو انجام دینے کے لئے یہاں ایک پروگرام ہے: بائنری ٹری کلاس نوڈ میں نوڈ کی نمائندگی کرنے کے لئے پائیٹون کوپی کوڈ# نوڈ کلاس: Def __init __ (خود ، قدر): سیلف۔ ویلیو = ویلیو سیلف۔ خود نہیں۔دائیں = کوئی بھی # فنکشن پری آرڈر ٹریورسالڈف پری_آرڈر_ٹراورسل (نوڈ) انجام دینے کے لئے: اگر نوڈ کوئی نہیں ہے: # موجودہ نوڈ پرنٹ کی قیمت (نوڈ.والیو ، اختتام = \"\") # بار بار بائیں سب ٹری پری_آرڈر_ٹراورسل (بار بار گزرتے ہیں۔node.left)# بار بار دائیں subtree pre_order_traversal (node.right)# مثال کے استعمال# بائنری ٹریروٹ = نوڈ (1) روٹ. لیفٹ = نوڈ (2) جڑ.ایچ = نوڈ (3) روٹ.لفٹ.لفٹ= نوڈ (4) روٹ. لیفٹ۔ رائٹ = نوڈ (5)# پری آرڈر ٹریورسل پرنٹ (\"پری آرڈر ٹریورسل:\" ، اینڈ = \"\") پری_آرڈر_ٹراورسل (جڑ) اس پروگرام میں ، ہم ایک کی وضاحت کرتے ہیں۔"
    },
    {
        "Question": "ایک ناگوار سیٹ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ریٹ کمپریشن اور یونین کے ساتھ یونین-فنڈ الگورتھم کا استعمال کرتے ہوئے ڈس ڈیسپٹ سیٹ ڈیٹا ڈھانچے کا نفاذ یہاں ہے: پائیٹون کوپی کوڈ# نوڈ کلاس ہر عنصر کو ڈس ڈیسنٹ سیٹ کلاس نوڈ میں نمائندگی کرنے کے لئے: Def __init __ (خود ، ڈیٹا): خود۔ڈیٹا = ڈیٹا سیل۔ پیرنٹ = سیلف۔ رینک = 0# ڈس ڈیسپٹ سیٹ ڈیٹا سٹرکچرکلاس ڈسکشن سیٹ کی نمائندگی کرنے والی کلاس کلاس: Def __init __ (خود): self.nodes = {} Def Make_set (خود ، ڈیٹا): نوڈ = نوڈ (ڈیٹا (ڈیٹا (ڈیٹا)) self.nodes [ڈیٹا] = نوڈ DEF Find_set (خود ، ڈیٹا):"
    },
    {
        "Question": "متن کے تار میں پیٹرن کی موجودگی کی تعداد کو گننے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!نوتھ مورس پراٹ (کے ایم پی) الگورتھم کا استعمال کرتے ہوئے ٹیکسٹ سٹرنگ میں پیٹرن کے واقعات کی تعداد کو گننے کے لئے یہاں ایک پروگرام ہے: پائیٹون کوپی کوڈیڈف کیلکولیٹ_ ایل پی ایس (پیٹرن): لمبائی = 0 ایل پی ایس = [0] * لین (پیٹرن) i =1 جبکہ میں <لین (پیٹرن): اگر پیٹرن [i] == پیٹرن [لمبائی]: لمبائی += 1 ایل پی ایس [i] = لمبائی i += 1"
    },
    {
        "Question": "ریڈکس ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں ریڈکس ترتیب والے الگورتھم کا نفاذ یہاں ہے: پائیتھون کوپی کوڈیڈف ریڈکس_سورٹ (اے آر آر): # ہندسوں کی تعداد کا تعین کرنے کے لئے زیادہ سے زیادہ نمبر تلاش کریں میکس_نوم = میکس (اے آر آر) نمبر_ڈیجٹس = لین (ایس ٹی آر (میکس_نم)) # ہر ایک کے لئے گنتی ترتیب دیں۔ہندسہ (num_digits) میں ہندسے کے لئے کم از کم اہم سے زیادہ اہم تک: گنتی = [0] * 10 # ہر ہندسے کی آؤٹ پٹ کے لئے گنتی کی سرنی کو شروع کریں = [0] * لین (اے آر آر) # ارج میں ہر ہندسے کے واقعات کو اے آر آر میں نمبر کے لئے شمار کریں: ہندسے_اویلیو = (نمبر // (10 ** ہندسہ)) ٪ 10 گنتی [ہندسوں_اویلیو] += 1 # رینج (1 ، 10) میں مجموعی گنتی کا حساب لگائیں: گنتی"
    },
    {
        "Question": "بائنری سرچ ٹری میں کے ٹی ایچ ٹی کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!بائنری سرچ ٹری (بی ایس ٹی) میں کے ٹی ایچ کے سب سے چھوٹے عنصر کو تلاش کرنے کے لئے ایک پروگرام یہ ہے کہ انڈر آرڈر ٹراورسل کا استعمال کرتے ہوئے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، قدر): سیلف۔ ویلیو = ویلیو سیلف۔نونیڈف Kth_smallest (جڑ ، کے): اسٹیک = [] موجودہ = جڑ کی گنتی = 0 جبکہ سچ ہے جبکہ سچ: اگر موجودہ کوئی نہیں ہے: اسٹیک۔ اپینڈ (موجودہ) موجودہ = موجودہ۔ لیفٹ الیف اسٹیک: نوڈ = اسٹیک۔= 1 اگر گنتی == K: واپسی نوڈ۔ ویلیو کرنٹ = نوڈ۔ رائٹ کوئی اور نہیں: کوئی بھی نہیں# مثال کے طور پر# مثال کے طور پر یوسجیروٹ = نوڈ (5) روٹ۔ لیفٹ = نوڈ (3) روٹ۔ رائٹ = نوڈ (7) روٹ۔ لیفٹ۔بائیں = نوڈ (2) روٹ. لیفٹ۔ رائٹ = نوڈ (4) جڑ۔ رائٹ.لیفٹ = نوڈ (6) روٹ۔ رائٹ۔اس پروگرام میں {K} TH سب سے چھوٹا عنصر یہ ہے: \"، kth_smallest_element) ، ہم بائنری سرچ ٹری (بی ایس ٹی) میں ہر نوڈ کی نمائندگی کرنے کے لئے ایک نوڈ کلاس کی وضاحت کرتے ہیں۔Kth_smallest فنکشن BST کی جڑ اور K کی قدر کو ان پٹ اور ریٹرن کے طور پر لیتا ہے"
    },
    {
        "Question": "ایک طبقہ کے درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں طبقہ کے درخت کے اعداد و شمار کے ڈھانچے کا نفاذ یہاں ہے: پائیتھون کوپی کوڈکلاس سیگمنٹٹری: ڈیف __ __init __ (خود ، arr): self.arr = arr self.tree = [0] * (4 * لین (arr)) # طبقہ کے درخت کو شروع کریں0 اقدار کے ساتھ خود۔arr [start] else: mid = (start + end) // 2 بائیں_ بچے = 2 * نوڈ رائٹ_چلڈ = 2 * نوڈ + 1 سیلف۔ بلڈ (بائیں_ بچے ، اسٹارٹ ، وسط)"
    },
    {
        "Question": "یہ چیک کرنے کے لئے ایک پروگرام لکھیں کہ آیا دیا گیا گراف ایک درخت ہے یا نہیں۔",
        "Answer": "یہ چیک کرنے کے لئے کہ دیا ہوا گراف ایک درخت ہے یا نہیں ، آپ گراف پر گہرائی سے پہلے تلاش (DFS) ٹریورسل انجام دے سکتے ہیں اور درج ذیل شرائط کی جانچ کرسکتے ہیں: تمام عمودیوں کو بالکل ایک بار ملاحظہ کیا جانا چاہئے۔اگر کسی بھی حد سے زیادہ بار ملاحظہ کیا جاتا ہے تو ، اس کا مطلب یہ ہے کہ گراف میں ایک چکر موجود ہے ، اور یہ درخت نہیں ہوسکتا ہے۔ گراف کو مکمل طور پر جڑنا چاہئے ، اس کا مطلب ہے کہ کسی بھی حد سے شروع ہونے والے ، آپ کو دوسرے تمام عمات تک پہنچنے کے قابل ہونا چاہئے۔اگر منقطع اجزاء موجود ہیں تو ، یہ درخت نہیں ہوسکتا ہے۔ ڈی ایف ایس ٹریورسل کے دوران پیچھے کے کنارے نہیں ہونا چاہئے۔پچھلا کنارے ایک کنارے ہے جو ڈی ایف ایس ٹراورسل میں اپنے ایک آباؤ اجداد سے ایک چوٹی کو جوڑتا ہے۔اگر آپ کو پچھلے کنارے کا سامنا کرنا پڑتا ہے تو ، اس کا مطلب ہے کہ یہاں ایک چکر ہے ، اور یہ درخت نہیں ہوسکتا ہے۔ ازگر میں ایک مثال کا پروگرام ہے جو چیک کرتا ہے کہ اگر دیئے گئے گراف کا درخت ہے تو: کاپی کوڈ"
    },
    {
        "Question": "فبونیکی ہیپ ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "شروع سے فبونیکی ڈھیر پر عمل درآمد کرنا ایک پیچیدہ کام ہے۔اس میں متعدد ڈیٹا ڈھانچے کا انتظام کرنا اور مختلف ہیپ خصوصیات کو برقرار رکھنا شامل ہے۔تاہم ، میں آپ کو فبونیکی ہیپ ڈیٹا ڈھانچے اور اس کے کاموں کا ایک اعلی سطحی جائزہ فراہم کرسکتا ہوں۔ ایک فبونیکی ہیپ ایک قسم کا ہیپ ڈیٹا ڈھانچہ ہے جو موثر کارروائیوں کی حمایت کرتا ہے جیسے اندراج ، حذف کرنے ، اور کم سے کم عنصر کو مستحکم مستقل میں نکالتا ہے۔وقتیہ درختوں کے امتزاج اور فبونیکی ہیپ سے منفرد خصوصیات کا ایک مجموعہ استعمال کرکے اس کارکردگی کو حاصل کرتا ہے۔ ایک فبونیکی ہیپ کی کلیدی خصوصیات میں شامل ہیں: من ہیپ پراپرٹی: ہیپ میں ہر نوڈ من ہیپ پراپرٹی کو پورا کرتا ہے ، جس میں کہا گیا ہے کہ اس کی کلید کو پورا کیا جاتا ہےہر نوڈ میں سے اس کے والدین کی کلید سے زیادہ یا اس کے برابر ہوتا ہے۔ان درختوں کو \"من-ہیپ آرڈرڈ درخت\" یا محض \"فبونیکی درخت\" کہا جاتا ہے۔ \"ڈگری پراپرٹی: ڈھیر میں ہر نوڈ میں ایک ڈگری ہوتی ہے ، جو اس میں بچوں کی تعداد کی نمائندگی کرتی ہے۔"
    },
    {
        "Question": "بائنری ٹری پر پوسٹ آرڈر کے درختوں کو ٹریورسل انجام دینے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!بائنری ٹری پر پوسٹ آرڈر ٹریورسل انجام دینے کے لئے ازگر میں ایک مثال کا پروگرام ہے: پیتھون کوپی کوڈکلاس نوڈ: ڈیف __init __ (خود ، ڈیٹا): سیلف ڈاٹ ڈیٹا = ڈیٹا سیلف۔ لیفٹ = کوئی بھی نہیں۔روٹ کوئی نہیں ہے: ریٹرن # ٹراورس بائیں سب ٹری پوسٹ_آرڈر (روٹ. لیفٹ) # ٹراورس دائیں سب ٹری پوسٹ_آرڈر (روٹ. رائٹ) # نوڈ پرنٹ ملاحظہ کریں (جڑ ڈاٹ ڈیٹا ، اینڈ = \"\") # مثال کے استعمال # بائنری ٹریروٹ = نوڈ بنائیں نوڈ)"
    },
    {
        "Question": "ہدایت شدہ ایسائکلک گراف کے لئے ایک ٹوپولوجیکل ترتیب والے الگورتھم کو نافذ کریں۔",
        "Answer": "یقینا!ازگر میں گہرائی سے پہلے تلاش (ڈی ایف ایس) کا استعمال کرتے ہوئے ہدایت شدہ ایسائکلک گراف کے لئے ٹوپولوجیکل ترتیب الگورتھم کا نفاذ یہاں ہے: پائیتھون کوپی کوڈفوم کلیکشن درآمد ڈیفالٹ ڈکٹکلاس گراف: ڈیف __INIT __ (خود ، عمودی)) ڈیف ایڈ_ج (سیلف ، یو ، وی): سیلف ڈاٹ ایڈج_ لسٹ [یو]self.adj_list [v]: اگر دورہ نہیں کیا گیا ہے [پڑوسی]: سیلف۔ ٹوپولوجیکل_سورٹ_ٹیل (پڑوسی ، ملاحظہ کریں ، اسٹیک) # موجودہ حد کو اسٹیک اسٹیک پر دھکیلیں۔self.vertices stack = [] # رینج (self.vertices) میں V کے لئے ہر غیر منحصر ورٹیکس کے لئے DFs انجام دیں: اگر نہیں ملاحظہ کیا گیا ہے [v]: سیلف ٹوپولوجیکل_سورٹ_ٹیل (v ، ملاحظہ کریں ، اسٹیک) # ٹوپولوجیکل ترتیب میں عمودی پرنٹ کریں"
    },
    {
        "Question": "عدد کی ایک صف میں سب سے طویل عرصہ تک بڑھتی ہوئی کامیابی کو تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "یقینا!متحرک پروگرامنگ کا استعمال کرتے ہوئے عدد کی ایک صف میں سب سے طویل عرصہ تک بڑھتی ہوئی تعداد کو تلاش کرنے کے لئے ازگر میں ایک پروگرام ہے: پائیتھون کوپی کوڈ ڈیف طویل ترین_ان کریزنگ_سوبسینس (نمبر): این = لین (نمبر) اگر n == 0: واپسی [] # لمبائی کو ذخیرہ کرنے کے لئے ایک صف شروع کریں۔طویل عرصے سے بڑھتے ہوئے متنازعہ dp = [1] * n # پچھلے عناصر کے اشاریوں کو ماضی میں پیش کرنے کے لئے ایک صف کو شروع کریں = [-1] * n # میں طویل عرصے تک بڑھتی ہوئی بڑھتی ہوئی لمبائی کی لمبائی میکس_ لمبائی = 1 end_index = 0 کی حد میں تلاش کریں۔، کے لئے ، ، ، ، ، ، ، ، ، ، کے لئے ، صدیں ، ، ، ، کے لئے."
    },
    {
        "Question": "لاحقہ سرنی ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "لاحقہ سرنی ڈیٹا ڈھانچے کو نافذ کرنا ایک پیچیدہ کام ہے ، لیکن میں آپ کو اس میں شامل اقدامات کا ایک اعلی سطحی جائزہ فراہم کرسکتا ہوں۔ ایک لاحقہ سرنی دیئے گئے تار کے تمام لاحقہ کا ایک ترتیب شدہ صف ہے۔ایک لاحقہ سرنی کی تعمیر کے لئے ایک عمومی نقطہ نظر یہ ہے: ان پٹ سٹرنگ کے تمام لاحقہ پیدا کریں۔ لاحقوں کو لغت کے لحاظ سے ترتیب دیں۔# ان پٹ سٹرنگ لاحقہ کے تمام لاحقہ پیدا کریں = [s [i:] کے لئے رینج (لین ((())))] # بلٹ ان `ترتیب دیئے گئے فنکشن لاحقہ_ارے = ترتیب شدہ (رینج (لفیکسس (لفیکسس) کا استعمال کرتے ہوئے لازمی طور پر لفیکس کو ترتیب دیں۔)) ، کلیدی = لیمبڈا ایکس: لاحقہ [x])"
    },
    {
        "Question": "بائنری درخت کا قطر تلاش کرنے کے لئے ایک پروگرام لکھیں۔",
        "Answer": "بائنری کا قطر تلاش کرنے کے لئے"
    },
    {
        "Question": "بی+ درخت کے ڈیٹا ڈھانچے کو نافذ کریں۔",
        "Answer": "بی+ ٹری ڈیٹا ڈھانچے کو نافذ کرنا ایک پیچیدہ کام ہے جس میں نوڈ ڈھانچہ ، اندراج ، حذف کرنے ، اور تلاش کے کاموں سمیت مختلف عوامل پر محتاط غور کرنے کی ضرورت ہوتی ہے۔بی+ درخت کے مکمل نفاذ میں متعدد اجزاء اور طریقے شامل ہیں۔یہاں ایک اعلی سطحی جائزہ ہے کہ کس طرح بی+ ٹری کام کرتا ہے اور اس میں شامل کچھ اہم اجزاء شامل ہیں: بی+ درخت کا ڈھانچہ: بی+ درخت نوڈس پر مشتمل ہے ، جس میں جڑ نوڈ ، اندرونی نوڈس ، اور پتی نوڈس شامل ہیں۔ ہر نوڈ میں ایک مقررہ صلاحیت ہے اورایک مخصوص تعداد کی چابیاں اور اس سے متعلقہ اقدار یا پوائنٹرز۔ نوڈ ڈھانچہ: داخلی نوڈس میں کلیدی قیمت کے جوڑے اور بچوں کے نوڈس کے پوائنٹر ہوتے ہیں۔توازن برقرار رکھنے کے لئے کم سے کم اور زیادہ سے زیادہ چابیاں"
    },
    {
        "Question": "ڈیٹا ڈھانچہ کیا ہے؟",
        "Answer": "ڈیٹا کا ڈھانچہ کمپیوٹر کی میموری میں ڈیٹا کو منظم اور اسٹور کرنے کا ایک طریقہ ہے تاکہ اس تک موثر انداز میں رسائی ، ترمیم اور اس پر کارروائی کی جاسکے۔یہ ایک منطقی نمائندگی فراہم کرتا ہے کہ کس طرح ڈیٹا کا اہتمام کیا جاتا ہے اور اس پر آپریشن کس طرح انجام دیئے جاسکتے ہیں۔اعداد و شمار کے ڈھانچے کمپیوٹر سائنس میں بنیادی تعمیراتی بلاکس ہیں اور مختلف کمپیوٹیشنل مسائل کو حل کرنے کے لئے ضروری ہیں۔ ڈیٹا ڈھانچے ڈیٹا عناصر کے مابین تعلقات کی وضاحت کرتے ہیں ، جس سے موثر اسٹوریج ، بازیافت اور ڈیٹا کی ہیرا پھیری کی اجازت ہوتی ہے۔وہ مخصوص الگورتھم یا ایپلی کیشنز کی ضروریات کی بنیاد پر ڈیٹا کو منظم کرنے اور ان کا نظم کرنے کے مختلف طریقے فراہم کرتے ہیں۔ہر اعداد و شمار کے ڈھانچے کی اپنی خصوصیات ہوتی ہیں ، جیسے کہ یہ اعداد و شمار کو اسٹور اور بازیافت کرتا ہے ، اس کا وقت اور جگہ کی پیچیدگی ، اور مخصوص کارروائیوں کے ل its اس کی مناسبیت۔ مکمل طور پر استعمال شدہ ڈیٹا ڈھانچے میں صفیں ، لنکڈ فہرستیں ، اسٹیک ، قطاریں ، درخت ، گراف ، ہیش شامل ہیں۔میزیں ، ڈھیر ، اور بہت کچھ۔ہر اعداد و شمار کے ڈھانچے کے اپنے فوائد اور تجارتی آفس ، اور انتخاب کا انتخاب ہوتا ہے"
    },
    {
        "Question": "اسٹیک کیا ہے؟اس کی ایک مثال دیں کہ اسے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک اسٹیک ایک لکیری ڈیٹا ڈھانچہ ہے جو آخری ان فرسٹ آؤٹ (LIFO) اصول کی پیروی کرتا ہے ، جس کا مطلب ہے کہ اسٹیک میں ڈالا جانے والا آخری عنصر پہلا ایک ہے جس کو ہٹایا جاتا ہے۔اس کو پلیٹوں کے ڈھیر کے طور پر سوچیں ، جہاں آپ نے آخری پلیٹ اوپر رکھی ہے وہ پہلا ہے جس کو آپ اتار سکتے ہیں۔ ایک اسٹیک"
    },
    {
        "Question": "قطار کیا ہے؟اس کی ایک مثال دیں کہ اسے کس طرح استعمال کیا جاسکتا ہے۔",
        "Answer": "ایک قطار ایک لکیری ڈیٹا ڈھانچہ ہے جو پہلے ان فرسٹ آؤٹ (FIFO) اصول کی پیروی کرتا ہے۔یہ ایک حقیقی زندگی کی قطار یا لائن کی طرح کام کرتا ہے ، جہاں قطار میں شامل ہونے والا پہلا شخص پیش کیا جاتا ہے یا اس پر کارروائی کی جاتی ہے۔ ایک قطار میں دو اہم کاروائیاں ہوتی ہیں: انکیو: اس کے پیچھے (اختتام) میں عنصر شامل کرتا ہےقطار۔ ڈیکیو: قطار کے سامنے (آغاز) سے عنصر کو ہٹاتا ہے اور لوٹاتا ہے۔ ان بنیادی کارروائیوں کے علاوہ ، ایک قطار عام طور پر دیگر آپریشنز فراہم کرتی ہے جیسے جھانکنا (اس کو ہٹائے بغیر سامنے والے عنصر کو بازیافت کرنے کے لئے) اور آئسٹی فیٹیاگر قطار"
    },
    {
        "Question": "بائنری درخت کیا ہے؟",
        "Answer": "بائنری کا درخت ایک قسم کا درجہ بندی کے اعداد و شمار کا ڈھانچہ ہے جس میں ہر نوڈ میں زیادہ سے زیادہ دو بچوں ہوتے ہیں ، جنھیں بائیں بچے اور دائیں بچے کے طور پر جانا جاتا ہے۔بائنری درخت کو \"بائنری\" کہا جاتا ہے کیونکہ ہر نوڈ میں زیادہ سے زیادہ دو بچے ہوسکتے ہیں۔ بائنری درخت میں: ہر نوڈ میں صفر ، ایک ، یا دو بچے ہوسکتے ہیں۔ جس ترتیب میں بچوں کو نوڈ میں شامل کیا جاتا ہے وہ اہم ہے۔بائیں بچے کو عام طور پر دائیں بچے سے پہلے شامل کیا جاتا ہے۔ نوڈ کے بچے الگ الگ ہوتے ہیں ، یعنی وہاں کوئی ڈپلیکیٹ بچے نہیں ہوتے ہیں۔"
    },
    {
        "Question": "بائنری تلاش کا درخت کیا ہے؟",
        "Answer": "بائنری سرچ ٹری (بی ایس ٹی) ایک قسم کا بائنری درخت ہے جس میں ایک اضافی پراپرٹی ہوتی ہے جو اسے تلاش ، اندراج اور حذف کرنے کے کاموں کے ل efficient موثر بناتی ہے۔بائنری تلاش کے درخت میں ، ہر نوڈ کے لئے ، اس کے بائیں سب ٹری میں موجود تمام نوڈس کی قدر اس کی قیمت سے کم ہے ، اور اس کے دائیں سب ٹری میں موجود تمام نوڈس کی قیمت اس کی قدر سے زیادہ ہے۔ بائنری سرچ ٹری کی کلیدی خصوصیات ہیں: پراپرٹی کو آرڈر کرنا: بائنری سرچ ٹری میں کسی بھی نوڈ کے ل its ، اس کے بائیں سب ٹری میں موجود تمام نوڈس نوڈ سے کم اقدار رکھتے ہیں ، اور اس کے دائیں سب ٹری میں موجود تمام نوڈس نوڈ سے زیادہ اقدار رکھتے ہیں۔ڈپلیکیٹ اقدار کی اجازت دیں۔ہر نوڈ کی ایک انوکھی کلیدی قدر ہوتی ہے۔ بائنری سرچ ٹری کی آرڈرنگ پراپرٹی موثر تلاش کے کاموں کی اجازت دیتی ہے۔جب کسی خاص قدر کی تلاش کرتے ہو تو ، بائنری سرچ ٹری کو ہر ایک میں قدروں کے ساتھ ہدف کی قیمت کا موازنہ کرکے عبور کیا جاسکتا ہے"
    },
    {
        "Question": "ہیش ٹیبل کیا ہے؟",
        "Answer": "ایک ہیش ٹیبل ، جسے ہیش نقشہ بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو موثر اندراج ، حذف کرنے اور عناصر کی بازیافت فراہم کرتا ہے۔یہ ہیشنگ کے تصور پر مبنی ہے ، جو مستقل طور پر اوسطا کیس کی کارروائیوں کی اجازت دیتا ہے ، جس سے بڑی مقدار میں ڈیٹا کو سنبھالنے کے لئے انتہائی موثر ہوتا ہے۔ ایک ہیش ٹیبل میں ، ڈیٹا عناصر کو ہیش ٹیبل سرنی نامی ایک صف کی طرح ڈھانچے میں محفوظ کیا جاتا ہے۔سرنی کو ہیش فنکشن کا استعمال کرتے ہوئے ترتیب دیا گیا ہے ، جو ان پٹ ڈیٹا کو ہیش کوڈ کے نام سے جانا جاتا ہے۔ہیش کوڈ کو سرنی سے عناصر کو ذخیرہ کرنے اور بازیافت کرنے کے لئے انڈیکس کے طور پر استعمال کیا جاتا ہے۔ ہیش ٹیبل کی کلیدی خصوصیات یہ ہیں: ہیش فنکشن: a"
    },
    {
        "Question": "ایک گراف کیا ہے؟",
        "Answer": "ایک گراف ایک غیر لکیری ڈیٹا ڈھانچہ ہے جس میں نوڈس کا ایک سیٹ (جسے ورٹیسیس بھی کہا جاتا ہے) اور نوڈس کو جوڑنے والے کناروں کا ایک سیٹ ہوتا ہے۔ایک گراف کا استعمال مختلف اشیاء یا اداروں کے مابین تعلقات یا رابطوں کی نمائندگی کرنے کے لئے کیا جاتا ہے۔ ایک گراف میں: نوڈس: نوڈس گراف میں موجود اداروں یا اشیاء کی نمائندگی کرتے ہیں۔ہر نوڈ میں ایک انوکھا شناخت کنندہ یا قدر سے وابستہ ہوسکتا ہے"
    },
    {
        "Question": "چوڑائی کی پہلی تلاش اور گہرائی کی پہلی تلاش میں کیا فرق ہے؟",
        "Answer": "چوڑائی کی پہلی تلاش (بی ایف ایس) اور گہرائی سے پہلے تلاش (ڈی ایف ایس) دو بنیادی گراف ٹراورسل الگورتھم ہیں جو مختلف طریقوں سے گراف کے ذریعے تلاش کرتے ہیں یا تلاش کرتے ہیں۔بی ایف ایس اور ڈی ایف ایس کے مابین بنیادی فرق اس ترتیب میں ہے جس میں ٹریورسل کے دوران نوڈس کا دورہ کیا جاتا ہے۔ بریڈریڈ فرسٹ تلاش (بی ایف ایس): بی ایف ایس ایک دیئے گئے سورس نوڈ سے شروع ہوتا ہے اور ایک ہی سطح پر تمام نوڈس کی کھوج کرتا ہے (یعنی ، تمام ہمسایہ ممالکموجودہ نوڈ) اگلے درجے پر جانے سے پہلے۔ اس میں نوڈس کا دورہ کرنے کے لئے ایک قطار ڈیٹا ڈھانچہ استعمال کیا جاتا ہے۔ماخذ نوڈ کو قطار میں شامل کیا جاتا ہے ، اور پھر سورس نوڈ کے پڑوسیوں کو قطار میں شامل کیا جاتا ہے۔یہ عمل اس وقت تک جاری رہتا ہے جب تک کہ تمام نوڈس کا دورہ نہ کیا جائے۔ بی ایف ایس اس بات کی ضمانت دیتا ہے کہ یہ سب کا دورہ کرتا ہے"
    },
    {
        "Question": "ڈھیر کیا ہے؟",
        "Answer": "کمپیوٹر سائنس میں ، ایک ڈھیر درخت پر مبنی ایک خصوصی ڈیٹا ڈھانچہ ہے جو ہیپ پراپرٹی کو مطمئن کرتا ہے۔ایک ڈھیر کو اکثر بائنری ڈھیر کے طور پر نافذ کیا جاتا ہے ، جو ایک مکمل بائنری درخت ہے جہاں ہر نوڈ یا تو کم سے کم پراپرٹی یا زیادہ سے زیادہ ہیپ پراپرٹی کو مطمئن کرتا ہے۔اس نوڈ کی قیمت اس کے بچے نوڈس کی اقدار سے کم یا اس کے برابر ہے۔دوسرے لفظوں میں ، کم سے کم قیمت ہمیشہ ہیپ کی جڑ میں رہتی ہے۔ میکس ہیپ"
    },
    {
        "Question": "زیادہ سے زیادہ ڈھیر اور ایک منٹ کے ڈھیر کے درمیان فرق کی وضاحت کریں۔",
        "Answer": "زیادہ سے زیادہ ڈھیر اور ایک منٹ کے ڈھیر کے درمیان فرق ڈھیر کے اندر عناصر کی ترتیب میں ہے اور جس پراپرٹی کو وہ مطمئن کرتے ہیں: زیادہ سے زیادہ ڈھیر: زیادہ سے زیادہ ڈھیر میں ، ہر والدین کے نوڈ کی قیمت زیادہ ہوتی ہے"
    },
    {
        "Question": "ترجیحی قطار کیا ہے؟",
        "Answer": "ترجیحی قطار ایک تجریدی ڈیٹا کی قسم ہے جو عناصر کو ان سے وابستہ ترجیحات کے ساتھ محفوظ کرتی ہے۔یہ بھی ایسا ہی ہے"
    },
    {
        "Question": "سرخ سیاہ درخت کیا ہے؟",
        "Answer": "ایک سرخ سیاہ درخت ایک خود متوازن بائنری سرچ درخت ہے جو قواعد و ضوابط کے ایک سیٹ کے ذریعے توازن برقرار رکھتا ہے۔اس کا نام درخت کے ہر نوڈ کو تفویض کردہ رنگ کے نام پر رکھا گیا ہے ، جو سرخ یا سیاہ ہوسکتا ہے۔سرخ سیاہ درخت اس بات کی ضمانت دیتا ہے کہ درخت کی اونچائی لاگرتھمک رہتی ہے ، جس سے موثر تلاش ، اندراج ، اور حذف کرنے کی کارروائیوں کو یقینی بناتا ہے۔ سرخ رنگ کے درخت کی کلیدی خصوصیات مندرجہ ذیل ہیں: ہر نوڈ یا تو سرخ یا سیاہ ہے۔ جڑ کا نوڈ ہے۔ہمیشہ سیاہ۔ ہر پتی (نول نوڈ) سیاہ ہے۔ اگر نوڈ سرخ ہے تو ، اس کے دونوں بچے سیاہ ہیں۔ نوڈ سے اس کی اولاد کے پتے تک ہر راستے میں مساوی تعداد ہوتی ہے"
    },
    {
        "Question": "طبقہ کا درخت کیا ہے؟",
        "Answer": "ایک طبقہ کا درخت ، جسے وقفہ کے درخت کے نام سے بھی جانا جاتا ہے ، ایک ورسٹائل ڈیٹا ڈھانچہ ہے جو کسی سرنی کے وقفوں یا طبقات کو موثر استفسار اور اپ ڈیٹ کرنے کی اجازت دیتا ہے۔یہ خاص طور پر مختلف رینج پر مبنی سوالات کو حل کرنے کے ل useful مفید ہے ، جیسے صف میں عناصر کی ایک مخصوص حد کے اندر کم سے کم ، زیادہ سے زیادہ ، رقم یا دیگر مجموعی قیمت تلاش کرنا۔ طبقہ کا درخت سرنی کو نوڈس کی ایک درجہ بندی کی ساخت میں توڑ دیتا ہے ،جہاں ہر نوڈ سرنی کے ایک طبقہ یا وقفہ کی نمائندگی کرتا ہے۔درخت کی جڑ پوری صف کی نمائندگی کرتی ہے ، اور ہر داخلی نوڈ ایک طبقہ کی نمائندگی کرتا ہے جو اس کے بچوں کے طبقات کا اتحاد ہے۔پتی کے نوڈس سرنی کے انفرادی عناصر کی نمائندگی کرتے ہیں۔ طبقہ کے درخت کے پیچھے کلیدی خیال یہ ہے کہ اندرونی نوڈس پر ہر طبقہ کے لئے انٹرمیڈیٹ کے نتائج ، جیسے رقم یا کم سے کم قیمت کو ذخیرہ کرنا ہے۔اس سے پوری صفوں کو عبور کرنے کی ضرورت کے بغیر طبقات پر موثر سوالات اور تازہ کاریوں کی اجازت ملتی ہے۔"
    },
    {
        "Question": "فینوک درخت کیا ہے؟",
        "Answer": "ایک فینوک درخت ، جسے بائنری انڈیکسڈ ٹری (BIT) بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو مجموعی طور پر مجموعی رقم کے سوالات اور عناصر کی ایک صف کے بارے میں اپ ڈیٹ کی حمایت کرتا ہے۔یہ پریفکس سم سرنی کا ایک متبادل فراہم کرتا ہے ، جس میں تازہ ترین معلومات اور سوالات دونوں کے لئے O (n) وقت کی ضرورت ہوتی ہے۔ فینوک ٹری مجموعی رقم کو ذخیرہ کرنے کے لئے ایک ہوشیار بائنری نمائندگی کا استعمال کرتا ہے۔درخت کا ہر اشاریہ صف میں کسی عنصر سے مساوی ہے ، اور ہر انڈیکس میں ذخیرہ شدہ قیمت عناصر کی ایک مخصوص رینج کی مجموعی رقم کی نمائندگی کرتی ہے۔ فینوک درخت کی ساخت بائنری نمائندگی کے تصور اور لوئبٹ کے خیال پر مبنی ہے۔، کے لئے ، ، ، ، ، ، ، ، ، ، کے لئے ، صدیں ، ، ، ، کے لئے."
    },
    {
        "Question": "AVL درخت کیا ہے؟",
        "Answer": "ایک اے وی ایل کا درخت خود سے متوازن بائنری سرچ درخت ہے جس کا نام اس کے موجدوں ، ایڈیلسن ویلسکی اور لینڈس کے نام پر رکھا گیا ہے۔یہ نوڈس کی تعداد میں لوگرتھمک کے قریب اپنی اونچائی کو برقرار رکھنے کے لئے ڈیزائن کیا گیا ہے ، موثر تلاش ، اندراج اور حذف کرنے کے کاموں کو یقینی بناتا ہے۔ ایک AVL درخت میں ، ہر نوڈ میں ایک توازن عنصر ہوتا ہے جو اس کے بائیں اور دائیں سبٹریز کی بلندیوں کے درمیان فرق کی نمائندگی کرتا ہے۔بیلنس عنصر یا تو -1 ، 0 ، یا 1 ہوسکتا ہے ، جس سے یہ ظاہر ہوتا ہے کہ آیا سب ٹری بالترتیب بائیں بھاری ، متوازن ، یا دائیں بھاری ہے۔ اے وی ایل کے درخت کی کلیدی ملکیت یہ ہے کہ ہر نوڈ کا توازن عنصر ہونا ضروری ہے۔حد [-1 ، 1]۔اگر کسی بھی موقع پر بیلنس عنصر اس پراپرٹی کی خلاف ورزی کرتا ہے تو ، درختوں کے توازن کو بحال کرنے کے لئے گردشیں انجام دی جاتی ہیں۔ اے وی ایل کے درختوں میں استعمال ہونے والی چار قسم کی گردشیں: بائیں گردش: یہ آپریشن توازن کو بحال کرنے کے لئے استعمال ہوتا ہے جب نوڈ دائیں بھاری ہوجاتا ہے۔اس میں نوڈ کے دائیں بچے کو اوپر منتقل کرنا شامل ہے ، جس سے یہ نئی جڑ بن جاتی ہے ، جبکہ اصل جڑ نئی جڑ کا بائیں بچہ بن جاتی ہے۔ ٹھیک گردش: جب نوڈ بائیں بھاری ہوجاتا ہے تو یہ آپریشن توازن کو بحال کرنے کے لئے استعمال ہوتا ہے۔اس میں نوڈ کے بائیں بچے کو اوپر منتقل کرنا شامل ہے ، جبکہ اسے نئی جڑ بنانا ہے ، جبکہ"
    },
    {
        "Question": "لاحقہ درخت کیا ہے؟",
        "Answer": "ایک لاحقہ درخت ایک ڈیٹا ڈھانچہ ہے جو کسی دیئے گئے تار کے تمام لاحقہ کو موثر انداز میں نمائندگی کرتا ہے۔یہ عام طور پر پیٹرن مماثل اور سٹرنگ ہیرا پھیری الگورتھم کے لئے استعمال ہوتا ہے۔لمبائی کے لئے ایک لاحقہ درخت کی تعمیر کے لئے O (n) وقت اور جگہ کی پیچیدگی کی ضرورت ہوتی ہے۔ لاحقہ درخت درخت کے ڈھانچے میں تکراری سے لاحقہ شامل کرکے بنایا گیا ہے۔درخت میں ہر کنارے اصل تار کے ایک حص rising ے کی نمائندگی کرتا ہے ، اور جڑ سے پتی کے نوڈ تک کا راستہ ایک مکمل لاحقہ کی نمائندگی کرتا ہے۔کناروں کی پیروی کرتے ہوئے ، ہم کسی سٹرنگ کے واقعات کا سراغ لگاسکتے ہیں یا دو ڈوروں کے مابین سب سے طویل عام سسٹرنگ تلاش کرسکتے ہیں۔ لاحقہ درخت کا کلیدی فائدہ یہ ہے کہ یہ موثر اسٹرنگ تلاش اور پیٹرن مماثل کی اجازت دیتا ہے۔ایک نمونہ پیش کرتے ہوئے ، ہم لاحقہ کو عبور کرکے اصل تار میں اس کے واقعات کی تلاش کرسکتے ہیں"
    },
    {
        "Question": "ایک لاحقہ سرنی کیا ہے؟",
        "Answer": "ایک لاحقہ سرنی دیئے گئے تار کے تمام لاحقہ کا ایک ترتیب شدہ صف ہے۔یہ ایک لاحقہ درخت کا متبادل ڈیٹا ڈھانچہ ہے جو اسی طرح کی فعالیت فراہم کرتا ہے لیکن زیادہ کمپیکٹ نمائندگی کے ساتھ۔لاحقہ صفوں کو عام طور پر سٹرنگ پروسیسنگ اور پیٹرن مماثل الگورتھم میں استعمال کیا جاتا ہے۔ ایک لاحقہ سرنی کی تعمیر میں پوائنٹرز یا انڈیکس کی ایک صف تیار کرنا شامل ہے جو دیئے گئے تار کے تمام لاحقہ کی ابتدائی پوزیشنوں کی نمائندگی کرتا ہے۔اس کے بعد یہ لاحقہ ان کے متعلقہ ذیلی ذخیروں کی بنیاد پر لغت کے مطابق ترتیب دیا جاتا ہے۔نتیجے میں لاحقہ سرنی موثر تلاش اور پیٹرن مماثل کاموں کی اجازت دیتا ہے۔ لاحقہ سرنی کا کلیدی فائدہ اس کی سادگی اور کم میموری اوور ہیڈ ہے جو لاحقہ درخت کے مقابلے میں ہے۔"
    },
    {
        "Question": "ایک ناگوار سیٹ ڈیٹا ڈھانچہ کیا ہے؟",
        "Answer": "ایک متنازعہ سیٹ ڈیٹا ڈھانچہ ، جسے یونین فٹ ڈیٹا ڈھانچہ بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو ناگوار (غیر اوورلیپنگ) سیٹوں کے ذخیرے کی نمائندگی کرتا ہے۔یہ مندرجہ ذیل آپریشنز کو موثر انداز میں انجام دینے کے لئے کاروائیاں فراہم کرتا ہے: میکیٹ (x): ایک واحد عنصر x.find (x) کے ساتھ ایک نیا سیٹ تیار کرتا ہے: x سے تعلق رکھنے والے سیٹ کے نمائندے (جسے جڑ بھی کہا جاتا ہے) واپس کرتا ہے۔نمائندہ ایک ہے"
    },
    {
        "Question": "اسکیپ لسٹ کیا ہے؟",
        "Answer": "اسکیپ لسٹ ایک ڈیٹا ڈھانچہ ہے جو کسی لنکڈ فہرست یا متوازن سرچ درخت کی طرح ترتیب دیئے گئے ترتیب میں عناصر کو ذخیرہ کرنے اور تلاش کرنے کا ایک موثر طریقہ فراہم کرتا ہے۔اس کی ایجاد 1989 میں ولیم پگ نے متوازن تلاش کے درختوں کے متبادل کے طور پر کی تھی جو اسی طرح کی کارکردگی کی خصوصیات پیش کرتی ہے لیکن آسان عمل کے ساتھ۔ ایک اسکیپ لسٹ میں منسلک فہرستوں کی متعدد پرتوں پر مشتمل ہے ، جہاں ہر پرت اس کے نیچے کی پرت کا سب سیٹ ہے۔نیچے کی پرت اصل ترتیب شدہ منسلک فہرست ہے جس میں تمام عناصر شامل ہیں۔اونچی پرتوں میں نچلی پرت سے عناصر کا ایک حصہ ہوتا ہے ، جس میں عناصر کا احتمال سے منتخب کیا جاتا ہے۔اوپری پرت میں صرف دو عناصر ہوتے ہیں ، جو اسکیپ لسٹ میں سب سے چھوٹے اور سب سے بڑے عناصر ہیں۔ اسکیپ لسٹ کے پیچھے کلیدی خیال یہ ہے کہ اعلی پرتیں ایکسپریس لین کے طور پر کام کرتی ہیں ، جس سے تیزی سے تلاشی اور ٹریورسل کی اجازت ہوتی ہے۔ایک پرت میں ہر عنصر میں ایک فارورڈ پوائنٹر ہوتا ہے جو اگلی پرت میں اس عنصر کی اگلی موجودگی کی طرف اشارہ کرتا ہے۔اگر کوئی عنصر کسی اعلی پرت میں موجود نہیں ہے تو ، فارورڈ پوائنٹر نیچے کی پرت میں اگلی موجودگی پر اس کے اوپر جاتا ہے۔ اسکیپ لسٹ میں کسی عنصر کی تلاش کے ل you ، آپ اوپر کی پرت سے شروع کرتے ہیں اور عناصر کو دائیں طرف جاتے ہوئے گزرتے ہیں جب تک دائیں طرف حرکت کرتے ہوآپ کو مطلوبہ عنصر مل جاتا ہے یا کسی بڑے عنصر تک پہنچ جاتا ہے۔اگر آپ کسی پرت کے اختتام پر پہنچ جاتے ہیں تو ، آپ نیچے کی پرت کی طرف بڑھتے ہیں اور تلاش جاری رکھتے ہیں۔یہ عمل اس وقت تک جاری رہتا ہے جب تک کہ عنصر نہیں مل جاتا ہے یا"
    },
    {
        "Question": "خود توازن بائنری تلاش کا درخت کیا ہے؟",
        "Answer": "خود توازن بائنری سرچ ٹری ایک بائنری سرچ ٹری (بی ایس ٹی) ہے جو خود بخود متوازن ڈھانچے کو برقرار رکھتا ہے کیونکہ عناصر داخل یا حذف کردیئے جاتے ہیں۔ایک متوازن بی ایس ٹی یقینی بناتا ہے کہ درخت کی اونچائی"
    },
    {
        "Question": "دوگنا منسلک فہرست کیا ہے؟",
        "Answer": "ایک دوگنا منسلک فہرست ایک لکیری ڈیٹا ڈھانچہ ہے جہاں ہر نوڈ میں دو پوائنٹر ہوتے ہیں: ایک پچھلے نوڈ کی طرف اشارہ کرتا ہے اور دوسرا تسلسل میں اگلے نوڈ کی طرف اشارہ کرتا ہے۔ڈیٹا عنصر کے علاوہ ، دوگنا منسلک فہرست میں ہر نوڈ اپنے پچھلے اور اگلے نوڈس کے حوالے برقرار رکھتا ہے ، جس سے دونوں سمتوں میں ٹراورسل کی اجازت ملتی ہے۔ دوگنا منسلک فہرست کا ڈھانچہ مندرجہ ذیل ہے: vbnetcopy کوڈینوڈ: - ڈیٹا: اصل ڈیٹا: اصل ڈیٹایا نوڈ میں ذخیرہ شدہ قیمت۔- پچھلا: فہرست میں پچھلے نوڈ کا پوائنٹر/حوالہ۔- اگلا: فہرست میں اگلے نوڈ کا پوائنٹر/حوالہ۔"
    },
    {
        "Question": "تھوڑا سا صف کیا ہے؟",
        "Answer": "تھوڑا سا سرنی ، جسے تھوڑا سا ویکٹر یا بٹسیٹ بھی کہا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو بٹس کی ایک صف کی نمائندگی کرتا ہے ، جہاں ہر ایک میں دو اقدار میں سے ایک ہوسکتا ہے: 0 یا 1. یہ کسی سیٹ کی ایک کمپیکٹ اور میموری کی موثر نمائندگی ہے۔بولین اقدار کے۔ یہاں بٹ سریوں کے بارے میں کچھ اہم نکات ہیں: ڈھانچہ: تھوڑا سا سرنی عام طور پر بٹس کے ایک مقررہ سائز کی صف کے طور پر نافذ کیا جاتا ہے ، جہاں ہر سا بولین قدر کی نمائندگی کرتا ہے۔بٹ سرنی کا سائز مطلوبہ اقدار کے مطلوبہ سیٹ کی نمائندگی کرنے کے لئے درکار بٹس کی تعداد کے ذریعہ طے کیا جاتا ہے۔"
    },
    {
        "Question": "بائنری انڈیکسڈ درخت کیا ہے؟",
        "Answer": "ایک بائنری اشاریہ دار درخت ، جسے فینوک ٹری کے نام سے بھی جانا جاتا ہے ، ایک ڈیٹا ڈھانچہ ہے جو عناصر کو اپ ڈیٹ کرنے اور کسی صف کے سابقہ رقم کا حساب لگانے کی موثر انداز میں مدد کرتا ہے۔اس سے متحرک یا تغیر پذیر صف پر موثر کارروائیوں کی اجازت ملتی ہے جہاں عناصر کو لاگ ان کے وقت کی پیچیدگی میں اپ ڈیٹ یا ان سے استفسار کیا جاسکتا ہے۔ یہاں بائنری انڈیکسڈ درختوں کے بارے میں کچھ اہم نکات ہیں: ڈھانچہ: بائنری انڈیکسڈ درخت کو عام طور پر سرنی پر مبنی ڈیٹا ڈھانچے کے طور پر پیش کیا جاتا ہے۔اس میں بائنری درخت کی طرح کا ڈھانچہ استعمال ہوتا ہے ، جہاں درخت کا ہر نوڈ سرنی میں عناصر کی ایک حد کی نمائندگی کرتا ہے۔درخت میں ہر نوڈ کا انڈیکس اصل صف میں عناصر کے ایک سابقہ مجموعہ سے مساوی ہے۔ آپریشن: تازہ کاری: بائنری انڈیکسڈ درخت صف میں انفرادی عناصر کی موثر اپ ڈیٹ کی حمایت کرتے ہیں۔درخت کو عبور کرنے اور اسی طرح کے نوڈس کو اپ ڈیٹ کرنے سے ، درختوں کی ساخت کو سرنی میں ہونے والی تبدیلیوں کی عکاسی کرنے کے لئے ایڈجسٹ کیا جاتا ہے۔اس آپریشن کے ذریعہ انجام دیا جاسکتا ہے"
    },
    {
        "Question": "ایک ویرل ٹیبل کیا ہے؟",
        "Answer": "ایک ویرل ٹیبل ایک اعداد و شمار کا ڈھانچہ ہے جو مستحکم صف یا ترتیب پر موثر انداز میں رینج کے سوالات کی گنتی اور جوابات دیتا ہے۔یہ بنیادی طور پر اس وقت استعمال ہوتا ہے جب سرنی کو کثرت سے اپ ڈیٹ نہیں کیا جاتا ہے ، لیکن متعدد سوالات ہیں جن کے لئے رینج پر مبنی سوالات کا موثر انداز میں جواب دینے کی ضرورت ہوتی ہے۔ یہاں ویرل ٹیبلز کے بارے میں کچھ اہم نکات ہیں: ڈھانچہ:"
    }
]