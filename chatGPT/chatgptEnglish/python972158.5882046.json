[
    {
        "Input": "python",
        "Output": "Hello! How can I assist you with Python?"
    },
    {
        "Input": "Write a Python program to find the sum of all numbers in a list.",
        "Output": "Certainly! Here's an example Python program that calculates the sum of all numbers in a list:\npython\nCopy code\ndef sum_of_list(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\n# Example usage\nmy_list = [1, 2, 3, 4, 5]\nresult = sum_of_list(my_list)\nprint(\"Sum of the list:\", result)\nIn this program, the sum_of_list function takes a list of numbers as an argument. It initializes a variable `total"
    },
    {
        "Input": "Implement a function to check if a given string is a palindrome.",
        "Output": "Sure! Here's a Python function that checks if a given string is a palindrome:\npython\nCopy code\ndef is_palindrome(string):\n   "
    },
    {
        "Input": "Write a program to generate all prime numbers up to a given number.",
        "Output": "Certainly! Here's a Python program that generates all prime numbers up to a given number:\npython\nCopy code\ndef generate_primes(n):\n    primes = []\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n\n# Example usage\nlimit = 30\nprime_numbers = generate_primes(limit)\nprint(\"Prime numbers up"
    },
    {
        "Input": "Create a function that takes a string as input and returns the frequency of each character in the string.",
        "Output": "Certainly! Here's a Python function that calculates the frequency of each character in a given string:\npython\nCopy code\ndef character_frequency(string):\n    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n\n# Example usage\nmy_string = \"Hello, World!\"\nresult = character_frequency(my_string)\nprint(\"Character frequency:\", result)\nIn this program, the character_frequency function takes a string as an argument. It initializes an empty dictionary called frequency to store the frequency of each character.\nThe function then iterates over each character in the string using a `for"
    },
    {
        "Input": "Implement a binary search algorithm to find the position of an element in a sorted list.",
        "Output": "Certainly! Here's a Python implementation of the binary search algorithm to find the position of an element in a sorted list:\npython\nCopy code\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\n# Example usage\nmy_list = [1, 3, 5, 7,"
    },
    {
        "Input": "Write a Python class representing a linked list and implement a method to reverse it.",
        "Output": "Certainly! Here's a Python class representing a linked list and an implementation of a method to reverse it:\npython\nCopy code\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList"
    },
    {
        "Input": "Create a function that finds the longest common prefix string amongst a list of strings.",
        "Output": "Certainly! Here's a Python function that finds the longest common prefix string among a list of strings:\npython\nCopy code\ndef longest_common_prefix(strings):\n    if not strings:\n        return \"\"\n\n    shortest_string = min(strings, key=len)\n    prefix = \"\"\n    \n    for i in range(len(shortest_string)):\n        current_char = shortest_string[i]\n        for string in strings:\n            if string[i] != current_char:\n                return prefix\n        prefix += current_char\n    \n    return prefix\n\n# Example usage\nmy_strings = [\"apple\", \"app\", \"application\", \"aptitude\"]\nresult = longest_common_prefix(my_strings)\nprint(\"Longest common prefix:\", result)\nIn this program, the longest_common_prefix function"
    },
    {
        "Input": "Implement a decorator that measures the execution time of a function.",
        "Output": "Certainly! Here's a Python decorator that measures the execution time of a function:\npython\nCopy code\nimport time\n\ndef measure_time(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        execution_time = end_time - start_time\n        print(f\"Execution time of {func.__name__}: {execution_time:.6f} seconds"
    },
    {
        "Input": "Write a program to sort a list of dictionaries based on a specific key.",
        "Output": "Certainly! Here's a Python program that sorts a list of dictionaries based on a specific key:\npython\nCopy code\ndef sort_list_of_dicts(list_of_dicts, key):\n    sorted_list = sorted(list_of_dicts, key=lambda x: x[key])\n    return sorted_list\n\n# Example usage\nmy_list = [\n    {\"name\": \"Alice\", \"age\": 25},\n    {\"name\": \"Bob\", \"age\": 30},\n    {\"name\": \"Charlie\", \"age\": 20}\n]\nsorted_list = sort"
    },
    {
        "Input": "Implement a recursive function to calculate the factorial of a given number.",
        "Output": "Certainly! Here's a Python recursive function to calculate the factorial of a given number:\npython\nCopy code\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# Example usage\nnumber = 5\nresult = factorial(number)\nprint(\"Factorial of\", number, \"is\", result)\nIn this program, the factorial function takes a number n as an argument. It uses a recursive approach to calculate the factorial.\nThe base case of the recursion is when n equals 0. In this case, the function returns 1, as the factorial of 0 is defined to be 1.\nFor any positive value of n, the function recursively calls itself with n - 1 and multiplies the result by n. This is because the factorial"
    },
    {
        "Input": "Write a Python program to check if a string contains only digits.",
        "Output": "Certainly! Here's a Python program to check if a string contains only digits:\npython\nCopy code\ndef contains_only_digits(string):\n    return string.isdigit()\n\n# Example usage\nmy_string = \"12345\"\nresult = contains_only_digits(my_string)\n\nif result:\n    print(\"The string contains only digits.\")\nelse:\n    print(\"The string does not contain only digits.\")\nIn this program, the contains_only_digits function takes a string string as an argument. It uses the isdigit() method of strings to check if all characters in the string are digits.\nThe isdigit() method returns True if all characters in the string are digits,"
    },
    {
        "Input": "Implement a function to find the second largest element in a list.",
        "Output": "Certainly! Here's a Python function that finds the second largest element in a list:\npython\nCopy code\ndef find_second_largest(lst):\n    if len(lst) < 2:\n        return None\n\n    largest = float('-inf')\n    second_largest = float('-inf')\n\n    for num in lst:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n\n    return second_largest\n\n# Example usage\nmy_list = [5, 9, 2, 7, 3,"
    },
    {
        "Input": "Create a program to reverse a given sentence without reversing the individual words.",
        "Output": "Certainly! Here's a Python program to reverse a given sentence without reversing the individual words:\npython\nCopy code\ndef reverse_sentence(sentence):\n    words = sentence.split()\n    reversed_words = reversed(words)\n    reversed_sentence = \" \".join(reversed_words)\n    return reversed_sentence\n\n# Example usage\nmy_sentence = \"Hello, world! How are you?\"\nresult = reverse_sentence(my_sentence)\nprint(\"Reversed sentence:\", result)\nIn this program, the reverse_sentence function takes a sentence as input. It first splits the sentence into individual words using the split() method, which separates the words based on whitespace.\nThen, the reversed() function is used to reverse the order of the words. The reversed_words object is an iterator that yields the words in reverse order."
    },
    {
        "Input": "\"Write a Python class representing a stack and implement its push, pop, and peek methods.\"",
        "Output": "Certainly! Here's a Python class representing a stack and implementing its push, pop, and peek methods:\npython\nCopy code\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self.items.pop()\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self.items[-1]\nIn this program, the"
    },
    {
        "Input": "Implement a function to remove duplicates from a list while preserving the order.",
        "Output": "Certainly! Here's a Python function that removes duplicates from a list while preserving the order:\npython\nCopy code\ndef remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result\n\n# Example usage\nmy_list = [10, 20, 30, 20, 40, 10, 50]\nresult = remove_duplicates(my_list)\nprint(\"List with duplicates removed:\", result)\nIn this program, the remove_duplicates function takes a list lst as an argument. It initializes an empty set called seen to keep track of the unique items encountered so far. It also initializes an empty list called `"
    },
    {
        "Input": "Create a program to calculate the Fibonacci sequence up to a given number.",
        "Output": "Certainly! Here's a Python program to calculate the Fibonacci sequence up to a given number:\npython\nCopy code\ndef fibonacci_sequence(n):\n    sequence = [0, 1]\n\n    while sequence[-1] + sequence[-2] <= n:\n        next_number = sequence[-1] + sequence[-2]\n        sequence.append(next_number)\n\n    return sequence\n\n# Example usage\nnumber = 1000\nfib_sequence = fibonacci_sequence(number)\nprint(\"Fibonacci sequence up to\", number, \":\")\nprint(fib_sequence)\nIn this program, the `fibonacci_sequence"
    },
    {
        "Input": "Write a Python class representing a binary tree and implement a method to calculate its height.",
        "Output": "Certainly! Here's a Python class representing a binary tree and implementing a method to calculate its height:\npython\nCopy code\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, current_node):\n        if value < current_node.value:\n            if current_node.left is None:\n                current_node.left = Node(value)\n            else:\n                self._insert_recursive(value, current_node.left)\n        else:\n            if current_node.right is None:\n               "
    },
    {
        "Input": "Implement a function to find the median of a list of numbers.",
        "Output": "Certainly! Here's a Python function to find the median of a list of numbers:\npython\nCopy code\ndef find_median(numbers):\n    sorted_numbers = sorted(numbers)\n    length = len(sorted_numbers)\n\n    if length % 2 == 0:\n        mid1 = length // 2\n        mid2 = mid1 - 1\n        median = (sorted_numbers[mid1] + sorted_numbers[mid2]) / 2\n    else:\n        mid = length // 2\n        median = sorted_numbers[mid]\n\n    return median\n\n# Example usage\nmy_list = [5, 9, 2, 7, 3, 8, 6]\nresult = find_median(my_list)\nprint(\"Median:\", result)\nIn this program, the `find_median"
    },
    {
        "Input": "Write a program to count the occurrences of each word in a given text file.",
        "Output": "Certainly! Here's a Python program to count the occurrences of each word in a given text file:\npython\nCopy code\ndef count_word_occurrences(file_path):\n    word_counts = {}\n\n    with open(file_path, 'r') as file:\n        for line in file:\n            words = line.split()\n            for word in words:\n                if word in word_counts:\n                    word_counts[word] += 1\n                else:\n                    word_counts[word] = 1\n\n    return word_counts\n\n# Example usage\nfile_path = 'text_file.txt'\nword_occurrences = count_word_occurrences(file_path)\n\n# Print word occurrences\nfor word, count in word_occurrences.items():\n    print(f"
    },
    {
        "Input": "Create a function that checks if two strings are anagrams of each other.",
        "Output": "Certainly! Here's a Python function that checks if two strings are anagrams of each other:\npython\nCopy code\ndef are_anagrams(string1, string2):\n    # Convert both strings to lowercase and remove whitespace\n    string1 = string1.lower().replace(\" \", \"\")\n    string2 = string2.lower().replace(\" \", \"\")\n\n    # Check if the lengths of the strings are equal\n    if len(string1) != len(string2):\n        return False\n\n    # Create dictionaries to store character counts\n    char_counts1 = {}\n    char_counts2 = {}\n\n    # Count characters in string1\n    for char in string1:\n        if char in char_counts1:\n            char_counts1[char] += 1\n        else:\n            char_counts1[char] = 1\n\n    # Count characters"
    },
    {
        "Input": "Implement a recursive function to calculate the sum of digits in a positive integer.",
        "Output": "Certainly! Here's a recursive Python function to calculate the sum of digits in a positive integer:\npython\nCopy code\ndef sum_of_digits(n):\n    if n < 10:\n        return n\n    else:\n        last_digit = n % 10\n        remaining_digits = n // 10\n        return last_digit + sum_of_digits(remaining_digits)\n\n# Example usage\nnumber = 12345\nresult = sum_of_digits(number)\nprint(\"Sum of digits:\", result)\nIn this program, the sum_of_digits function takes a positive integer `"
    },
    {
        "Input": "Write a program to find the largest continuous sum in a given list of integers.",
        "Output": "Certainly! Here's a Python program to find the largest continuous sum in a given list of integers:\npython\nCopy code\ndef find_largest_continuous_sum(nums):\n    if not nums:\n        return 0\n\n    current_sum = nums[0]\n    max_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n# Example usage\nmy_list = [2, -1, 3, -4, 2, 0, -5, 6]\nresult = find_largest_continuous_sum(my_list)\nprint(\"Largest continuous sum:\", result)\nIn this program,"
    },
    {
        "Input": "Create a Python class representing a queue and implement its enqueue and dequeue methods.",
        "Output": "Certainly! Here's a Python class representing a queue and implementing the enqueue() and dequeue() methods:\npython\nCopy code\nclass Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item):\n        self.queue.append(item)\n\n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue.pop(0)\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n    def size(self):\n        return len(self.queue)\n\n# Example usage\nmy_queue = Queue()\nmy_queue.enqueue(\"A\")\nmy_queue.enqueue(\"B\")\nmy_queue.enqueue(\"C\")\n\nprint(\"Queue size:\", my_queue.size())\n\nitem = my_queue.dequeue()\nprint"
    },
    {
        "Input": "Write a program to convert a decimal number to its binary representation.",
        "Output": "Certainly! Here's a Python program to convert a decimal number to its binary representation:\npython\nCopy code\ndef decimal_to_binary(decimal):\n    binary = \"\"\n    if decimal == 0:\n        return \"0\"\n\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal //= 2\n\n    return binary\n\n# Example usage\nnumber = 25\nresult = decimal_to_binary(number)\nprint(f\"Binary representation of {number}: {result}\")\nIn this program, the decimal_to_binary function takes a decimal number decimal as an argument. It initializes an empty string binary to store the binary representation.\nIf the decimal number is 0, it immediately returns the string \"0\" as the binary representation.\nThe function uses a while loop to convert the decimal number to binary."
    },
    {
        "Input": "Create a function that rotates a list to the right by a given number of steps.",
        "Output": "Certainly! Here's a Python function that rotates a list to the right by a given number of steps:\npython\nCopy code\ndef rotate_list_right(lst, steps):\n    if not lst:\n        return lst\n\n    length = len(lst)\n    steps %= length  # Adjust the number of steps to be within the length of the list\n    rotated_lst = lst[-steps:] + lst[:-steps]\n\n    return rotated_lst\n\n# Example usage\nmy_list = [1, 2, 3, 4, 5]\nnum_steps = 2\nresult = rotate_list_right(my_list,"
    },
    {
        "Input": "Implement a recursive function to calculate the factorial of a given number.",
        "Output": "Certainly! Here's a recursive Python function to calculate the factorial of a given number:\npython\nCopy code\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# Example usage\nnumber = 5\nresult = factorial(number)\nprint(f\"The factorial of {number} is: {result}\")\nIn this program, the"
    },
    {
        "Input": "Write a Python class representing a graph and implement a method to perform a depth-first search.",
        "Output": "Certainly! Here's a Python class representing a graph and implementing a method to perform a depth-first search (DFS):\npython\nCopy code\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_vertex(self, vertex):\n        if vertex not in self.adjacency_list:\n            self.adjacency_list[vertex] = []\n\n    def add_edge(self, vertex1, vertex2):\n        if vertex1 in self.adjacency_list and vertex2 in self.adjacency_list:\n            self.adjacency_list[vertex1].append(vertex2)\n            self.adjacency_list[vertex2].append(vertex1)\n\n    def dfs(self, start_vertex):\n        visited = set()\n\n        def dfs_helper(vertex):\n            visited.add(vertex)\n            print(vertex, end=\" \")\n\n           "
    },
    {
        "Input": "Create a program to find the common elements between two lists.",
        "Output": "Certainly! Here's a Python program to find the common elements between two lists:\npython\nCopy code\ndef find_common_elements(list1, list2):\n    common_elements = []\n\n    for item in list1:\n        if item in list2 and item not in common_elements:\n            common_elements.append(item)\n\n    return common_elements\n\n# Example usage\nlist_a = [1, 2, 3, 4, 5]\nlist_b = [4, 5, 6, 7, 8]\ncommon_elements = find_common_elements(list_a, list_b)\nprint(\"Common elements:\", common_elements)\nIn this program, the find_common_elements function takes two lists, list1 and list2, as arguments. It initializes an empty list common_elements to store the common elements.\nThe function iterates over"
    },
    {
        "Input": "Implement a function that checks if a string is a valid email address.",
        "Output": "Certainly! Here's a Python function that checks if a string is a valid email address using regular expressions:\npython\nCopy code\nimport re\n\ndef is_valid_email(email):\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    match = re.match(pattern, email)\n    return match is not None\n\n# Example usage\nemail_address = \"example@example.com\"\nresult = is_valid_email(email_address)\nprint(f\"{email_address} is a valid email address? {result}\")\nIn this program, the is_valid_email function takes an email address email as an argument. It uses the re.match function from the re module to match"
    },
    {
        "Input": "Write a program to find the missing number in a given list of integers.",
        "Output": "Certainly! Here's a Python program to find the missing number in a given list of integers:\npython\nCopy code\ndef find_missing_number(nums):\n    n = len(nums) + 1\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    missing_number = expected_sum - actual_sum\n    return missing_number\n\n# Example usage\nnumbers = [1, 2, 4, 6, 3, 7, 8]\nmissing_number = find_missing_number(numbers)\nprint(\"Missing number:\", missing_number)\n``"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid palindrome, ignoring non-alphanumeric characters.\"",
        "Output": "Certainly! Here's a Python function that checks if a given string is a valid palindrome, ignoring non-alphanumeric characters:\npython\nCopy code\nimport re\n\ndef is_valid_palindrome(string):\n    alphanumeric_string = re.sub(r'[^a-zA-Z0-9]', '', string.lower())\n    reversed_string = alphanumeric_string[::-1]\n    return alphanumeric_string == reversed_string\n\n# Example usage\ntext = \"A man, a plan, a canal: Panama\"\nresult = is_valid_palindrome(text)\nprint(f\"{text} is a valid palindrome? {result}\")\nIn this program, the is_valid_palindrome function takes a string string as an argument. It uses the re.sub function from the re module to remove all non-alphanumeric characters from the string. The regular expression pattern [^a-zA-Z0-9] matches any character that is not an"
    },
    {
        "Input": "Create a Python class representing a queue and implement its size and is_empty methods.",
        "Output": "Certainly! Here's a Python class representing a queue and implementing its size and is_empty methods:\npython\nCopy code\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len"
    },
    {
        "Input": "Write a program to check if two strings are rotations of each other.",
        "Output": "Certainly! Here's a Python program to check if two strings are rotations of each other:\npython\nCopy code\ndef are_rotations(str1, str2):\n    if len(str1) != len(str2):\n        return False\n\n    concatenated = str1 + str1\n    return str2 in concatenated\n\n# Example usage\nstring1 = \"abcd\"\nstring2 = \"cdab\"\nresult = are_rotations(string1, string2)\nprint(f\"{string1} and {string2} are rotations? {result}\")\nIn this program, the are_rotations function takes two strings, str1 and str2, as arguments.\nFirst, it checks if the lengths of the two strings are different. If they are different, it means they cannot be rotations of each other, and the function returns False.\nNext, it concatenates str1 with itself to create a new string called"
    },
    {
        "Input": "Implement a function to calculate the power of a number using recursion.",
        "Output": "Certainly! Here's a Python function that calculates the power of a number using recursion:\npython\nCopy code\ndef power(base, exponent):\n    if exponent == 0:\n        return 1\n    elif exponent < 0:\n        return 1 / power(base, -exponent)\n    else:\n        return base * power(base, exponent - 1)\n\n# Example usage\nbase = 2\nexponent = 3\nresult = power(base, exponent)\nprint(f\"{base} raised to the power of {exponent} is {result}\")\nIn this program, the power function takes two arguments: base and exponent. It calculates the power of base raised to the exponent using recursion.\nThe function has three"
    },
    {
        "Input": "Create a program to remove all duplicates from a string.",
        "Output": "Certainly! Here's a Python program to remove all duplicates from a string:\npython\nCopy code\ndef remove_duplicates(string):\n    unique_chars = []\n    result = \"\"\n\n    for char in string:\n        if char not in unique_chars:\n            unique_chars.append(char)\n            result += char\n\n    return result\n\n# Example usage\ntext = \"Hello, World!\"\nresult = remove_duplicates(text)\nprint(\"String after removing duplicates:\", result)\nIn this program, the remove_duplicates function takes a string string as an argument. It initializes an empty list called unique_chars to store the unique characters encountered in the string. It also initializes an empty string called result to build the final string after removing duplicates.\nThe function then iterates over each character in the string. If the character is not already present in unique_chars, it appends it to the list and adds it to the result string."
    },
    {
        "Input": "Write a Python class representing a binary search tree and implement a method to insert a node.",
        "Output": "Certainly! Here's a Python class representing a binary search tree (BST) and implementing a method to insert a node:\npython\nCopy code\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):"
    },
    {
        "Input": "Implement a function to find the longest substring without repeating characters in a given string.",
        "Output": "Certainly! Here's a Python function that finds the longest substring without repeating characters in a given string:\npython\nCopy code\ndef longest_substring_without_repeating_chars(string):\n    if not string:\n        return \"\"\n\n    max_substring = \"\"\n    current_substring = \"\"\n    visited_chars = set()\n\n    for char in string:\n        if char not in visited_chars:\n            visited_chars.add(char)\n            current_substring += char\n            if len(current_substring) > len(max_substring):\n                max_substring = current_substring"
    },
    {
        "Input": "Create a program to reverse the order of words in a given sentence.",
        "Output": "Certainly! Here's a Python program to reverse the order of words in a given sentence:\npython\nCopy code\ndef reverse_sentence(sentence):\n    words = sentence.split()\n    reversed_words = words[::-1]\n    reversed_sentence = \" \".join(reversed_words)\n    return reversed_sentence\n\n# Example usage\nsentence = \"Hello, how are you today?\"\nreversed_sentence = reverse_sentence(sentence)\nprint(\"Reversed sentence:\", reversed_sentence)\nIn this program, the reverse_sentence function takes a sentence as a string sentence and returns the sentence with the order of words reversed.\nThe function first splits the sentence into a list of words using the split method. It then reverses the order of the words using the slicing notation [::-1],"
    },
    {
        "Input": "Write a function that returns the nth Fibonacci number using dynamic programming.",
        "Output": "Certainly! Here's a Python function that uses dynamic programming to calculate the nth Fibonacci number:\npython\nCopy code\ndef fibonacci(n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Initialize the Fibonacci sequence with the first two numbers\n    fib = [0, 1]\n\n    # Calculate the Fibonacci numbers up to the nth number\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    # Return the nth Fibonacci number\n    return fib[n]\n\n# Example usage\nn = 6\nresult = fibonacci(n)"
    },
    {
        "Input": "Implement a program to perform matrix multiplication.",
        "Output": "Certainly! Here's a Python program to perform matrix multiplication:\npython\nCopy code\ndef matrix_multiplication(matrix1, matrix2):\n    rows1 = len(matrix1)\n    cols1 = len(matrix1[0])\n    rows2 = len(matrix2)\n    cols2 = len(matrix2[0])\n\n    # Check if matrices can be multiplied\n    if cols1 != rows2:\n        raise ValueError(\"Number of columns in matrix1 must be equal to the number of rows in matrix2.\")\n\n    # Create the result matrix with appropriate dimensions\n    result = [[0 for _ in range(cols2)] for _ in range(rows1)]\n\n    # Perform matrix multiplication"
    },
    {
        "Input": "Write a program to find the least common multiple (LCM) of two numbers.",
        "Output": "Certainly! Here's a Python program to find the least common multiple (LCM) of two numbers:\npython\nCopy code\ndef find_lcm(num1, num2):\n    # Find the maximum of the two numbers\n    max_num = max(num1, num2)\n\n    # Iterate from the maximum number and check for a common multiple\n    lcm = max_num\n    while True:\n        if lcm % num1 == 0 and lcm % num2 == 0:\n            break\n        lcm += max_num\n\n    return lcm\n\n# Example usage\nnumber1 = 12\nnumber2 = 18\nlcm = find_lcm(number1, number2)\nprint(\"LCM of\", number1, \"and\", number2, \"is:\", lcm)\nIn this program, the `"
    },
    {
        "Input": "Implement a function to check if a given string is a valid IPv4 address.",
        "Output": "Certainly! Here's a Python function to check if a given string is a valid IPv4 address:\npython\nCopy code\ndef is_valid_ipv4(address):\n    # Split the address into its components\n   "
    },
    {
        "Input": "Create a program to find the largest prime factor of a given number.",
        "Output": "Certainly! Here's a Python program to find the largest prime factor of a given number:\npython\nCopy code\ndef largest_prime_factor(number):\n    # Initialize the largest prime factor as 1\n    largest_factor"
    },
    {
        "Input": "Write a Python class representing a circular linked list and implement a method to insert a node at the beginning.",
        "Output": "Certainly! Here's a Python class representing a circular linked list and implementing a method to insert a node at the beginning:\npython\nCopy code\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_beginning(self, data):\n        new_node = Node(data)\n\n        # Check if the list is empty\n        if self.head is None:\n            self.head = new_node\n            new_node.next = self.head\n        else:\n            current = self.head\n            while current.next != self.head:\n                current = current.next\n\n            current.next = new_node\n            new_node.next = self.head\n           "
    },
    {
        "Input": "Implement a function to find the intersection of two lists.",
        "Output": "Certainly! Here's a Python function to find the intersection of two lists:\npython\nCopy code\ndef find_intersection(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    intersection = set1.intersection(set2)\n    return list(intersection)\n\n# Example usage\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\nresult = find_intersection(list1, list2)\nprint(\"Intersection of the two"
    },
    {
        "Input": "Create a program to generate a random password of a given length.",
        "Output": "Sure! Here's a Python program to generate a random password of a given length:\npython\nCopy code\nimport random\nimport string\n\ndef generate_random_password(length):\n    # Define the characters to choose from\n    characters = string.ascii_letters + string.digits + string.punctuation\n\n    # Generate the password\n    password = ''.join(random.choice(characters) for _ in range(length))\n\n    return password\n\n# Example usage\nlength = 10\npassword = generate_random_password(length)\nprint(\"Random password:\", password)\nIn this program, the generate_random_password function takes a length parameter and returns a randomly generated password of that length.\nThe function first defines the characters to choose from using the string module. It includes lowercase"
    },
    {
        "Input": "Write a function to check if a given number is a perfect square.",
        "Output": "Certainly! Here's a Python function to check if a given number is a perfect square:\npython\nCopy code\ndef"
    },
    {
        "Input": "Implement a program to sort a list of integers using the bubble sort algorithm.",
        "Output": "Certainly! Here's a Python program to sort a list of integers using the bubble sort algorithm:\npython\nCopy code\ndef bubble_sort(numbers):\n    n = len(numbers)\n\n    for i in range(n - 1):\n        # Flag to check if any swap is made in the current pass\n        swapped = False\n\n        for j in range(n - 1 - i):\n            # Compare adjacent elements and swap if necessary\n            if numbers[j] > numbers[j + 1]:\n                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]\n                swapped = True\n\n        # If no swap is made in the current pass, the list is already sorted\n        if not swapped:\n            break\n\n   "
    },
    {
        "Input": "Create a Python class representing a directed graph and implement a method to perform a breadth-first search.",
        "Output": "Certainly! Here's a Python class representing a directed graph and implementing a breadth-first search (BFS) method:\npython\nCopy code\nfrom collections import defaultdict\n\nclass DirectedGraph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def add_edge(self, source, destination):\n        self.graph[source].append(destination)\n\n    def breadth_first_search(self, start_node):\n        visited = set()\n        queue = []\n\n        visited.add(start_node)\n        queue.append(start_node)\n\n        while queue:\n            node = queue.pop(0)\n            print(node, end=\" \")\n\n            for neighbor in self.graph[node]:\n                if neighbor not in visited:\n                    visited"
    },
    {
        "Input": "Write a program to count the number of vowels in a given string.",
        "Output": "Certainly! Here's a Python program to count the number of vowels in a given string:\npython\nCopy code\ndef count_vowels(string):\n    vowels = 'aeiouAEIOU'\n    vowel_count = 0\n\n    for char in string:\n        if char in vowels:\n            vowel_count += 1\n\n    return vowel_count\n\n# Example usage\nstring = \"Hello, World!\"\nvowel_count = count_vowels(string)\nprint(\"Number of vowels:\", vowel_count)\nIn this program, the count_vowels function takes a string as an argument and returns the count of vowels in the string.\nThe function initializes a variable vowels with a string containing all lowercase and uppercase vowels. It also initializes a variable vowel_count to 0, which will store the count of vowels.\nThe function then iterates"
    },
    {
        "Input": "Implement a function to reverse a given integer.",
        "Output": "Certainly! Here's a Python function to reverse a given integer:\npython\nCopy code\ndef reverse_integer(num):\n    # Convert the number to a string for easier manipulation\n    num_str = str(num)\n\n    # Check if the number is negative\n    is_negative = False\n    if num_str[0] == '-':\n        is_negative = True\n        num_str = num_str[1:]\n\n    # Reverse the string\n    reversed_str = num_str[::-1]\n\n    # Convert the reversed string back to an integer\n    reversed_num = int(reversed_str)\n\n    # Restore the negative sign if necessary\n    if is_negative:\n        reversed_num *= -1\n\n    return reversed_num\n\n# Example usage\nnum = 12345\nreversed_num = reverse_integer(num)\nprint"
    },
    {
        "Input": "Create a program to check if a given number is an Armstrong number.",
        "Output": "Certainly! Here's a Python program to check if a given number is an Armstrong number:\npython\nCopy code\ndef is_armstrong_number(num):\n    # Convert the number to a string for easier manipulation\n    num_str = str(num)\n    \n    # Calculate the number of digits in the number\n    num_digits = len(num_str)\n    \n    # Calculate the sum of the cubes of each digit\n    sum_of_cubes = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if the sum of cubes is equal to the original number\n    if sum_of_cubes == num:\n        return True\n    else:\n       "
    },
    {
        "Input": "Write a Python class representing a priority queue and implement its enqueue and dequeue methods.",
        "Output": "Certainly! Here's a Python class representing a priority queue and implementing its enqueue and dequeue methods:\npython\nCopy code\nclass PriorityQueue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item, priority):\n        self.queue.append((item, priority))\n        self.queue.sort(key=lambda x: x[1])\n\n    def dequeue(self):\n        if self.is_empty():\n            return None\n        return self.queue.pop(0)[0]\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n# Example usage\nqueue = PriorityQueue()\nqueue.enqueue('Task 1', 2)\nqueue.enqueue('Task 2', 1)\nqueue.enqueue('Task 3', 3)\n\nprint(\"Dequeue:\", queue.dequeue())\nprint(\"Dequeue:\", queue.dequeue())\nprint(\"Dequeue:\", queue.dequeue())\nprint(\"Is empty:\", queue.is_empty())\n``"
    },
    {
        "Input": "Implement a function to find the intersection of two sorted arrays.",
        "Output": "Certainly! Here's a Python function to find the intersection of two sorted arrays:\npython\nCopy code\ndef find_intersection(arr1, arr2):\n    intersection = []\n    i = j = 0\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr1[i] > arr2[j]:\n            j += 1\n        else:\n            intersection.append(arr1[i])\n            i += 1\n            j += 1\n\n    return intersection\n\n# Example usage\narray1 = [1, 3, 4, 5, 7, 9]\narray2 = [2, 3, 5, 6, 8, 9]\nintersection = find_intersection(array1, array2)\nprint(\"Intersection:\", intersection)\nIn this program, the find_intersection function takes two sorted arrays, `arr1"
    },
    {
        "Input": "Create a program to convert a binary number to its decimal representation.",
        "Output": "Certainly! Here's a Python program to convert a binary number to its decimal representation:\npython\nCopy code\ndef binary_to_decimal(binary):\n    decimal = 0\n    power = 0\n\n    # Iterate over the binary digits in reverse order\n    for digit in reversed(binary):\n        # Convert the digit to an integer\n        digit = int(digit)\n        \n        # Add the contribution of the digit to the decimal value\n        decimal += digit * (2 **"
    },
    {
        "Input": "\"Write a function to check if a given string is a valid palindrome, considering case sensitivity.\"",
        "Output": "Certainly! Here's a Python function to check if a given string is a valid palindrome, considering case sensitivity:\npython\nCopy code\ndef is_palindrome(string):\n    # Remove any whitespace from the string\n    string = string.replace(\" \", \"\")\n    \n    # Check if the string is equal to its reverse\n    return string == string[::-1]\n\n# Example usage\ninput_string = \"Racecar\"\nif is_palindrome(input_string):\n    print(input_string, \"is a valid palindrome\")\nelse:\n    print(input_string, \"is not a valid palindrome\")\nIn this program, the is_palindrome function takes a string as an argument and returns a boolean indicating whether the string is a valid palindrome, considering case sensitivity"
    },
    {
        "Input": "Implement a program to calculate the sum of the digits in a factorial of a given number.",
        "Output": "Sure! Here's a Python program to calculate the sum of the digits in the factorial of a given number:\npython\nCopy code\ndef factorial_sum(n):\n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n\n    digit_sum = 0\n    while factorial > 0:\n        digit_sum += factorial % 10\n        factorial //= 10\n\n    return digit_sum\n\n# Example usage\nnumber = 5\nsum_of_digits = factorial_sum(number)\nprint(\"Factorial sum of\", number, \":\", sum_of_digits)"
    },
    {
        "Input": "Create a Python class representing a circular queue and implement its enqueue and dequeue methods.",
        "Output": "Certainly! Here's a Python class representing a circular queue with enqueue and dequeue methods:\npython\nCopy code\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = 0\n        self.rear = -1\n        self.size = 0\n\n    def is_empty(self):\n        return self.size == 0\n\n    def is_full(self):\n        return self.size == self.capacity\n\n    def enqueue(self, item):\n        if self.is_full():\n            print(\"Queue is full. Unable to enqueue item:\", item)\n            return\n\n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size += 1\n        print(\"Enqueued item:\", item)"
    },
    {
        "Input": "Write a program to find the maximum difference between two elements in a given list.",
        "Output": "Certainly! Here's a Python program to find the maximum difference between two elements in a given list:\npython\nCopy code\ndef max_difference(nums):\n    if len(nums) < 2:\n        return None\n\n    min_num = nums[0]\n    max_diff = nums[1] - nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] - min_num > max_diff:\n            max_diff = nums[i] - min_num\n\n        if nums[i] < min_num:\n            min_num = nums[i]\n\n    return max_diff\n\n\n# Example usage\nnumbers = [7, 2, 3, 10, 4, 1, 8, 6]\nresult = max_difference(numbers)\nprint(\"Maximum difference:\", result)\nIn this program, the max_difference function takes a list of numbers, `nums"
    },
    {
        "Input": "Implement a function to find the first non-repeated character in a string.",
        "Output": "Certainly! Here's a Python function to find the first non-repeated character in a string:\npython\nCopy code\ndef find_first_non_repeated_char(string):\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeated character\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if there is no non-repeated character\n    return None\n\n\n# Example usage\ninput_str = \"abacabad\"\nresult = find_first_non_repeated_char(input_str)\nif result:\n    print(\"First non-repeated character:\", result)\nelse:\n    print(\"No non-repeated characters found.\")\nIn this program, the find_first_non_repeated_char function takes a string,"
    },
    {
        "Input": "Create a program to find the common elements among multiple lists.",
        "Output": "Certainly! Here's a Python program to find the common elements among multiple lists:\npython\nCopy code\ndef find_common_elements(*lists):\n    # Initialize a set with the elements from the first list\n    common_elements = set(lists[0])\n\n    # Iterate over the remaining lists\n    for lst in lists[1:]:\n        # Update the set by taking the intersection with each list\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)\n\n\n# Example usage\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7]\nlist3 = [5, 6, 7, 8, 9]\nlist4 = [5, 10]\n\nresult = find_common_elements(list1, list2, list3, list4)\nprint(\"Common elements:\", result)\nIn this program, the `find"
    },
    {
        "Input": "Implement a program to check if a given string is an anagram of a palindrome.",
        "Output": "Sure! Here's a Python program to check if a given string is an anagram of a palindrome:\npython\nCopy code\ndef is_anagram_of_palindrome(string):\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    odd_count = 0\n    # Check the count of each character\n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n\n        # If there are more than one characters with odd counts,\n        # the string cannot be rearranged into a palindrome\n        if odd_count > 1:\n            return False\n\n    return True\n\n\n# Example usage\ninput_str = \"ivicc\"\nresult = is_anagram_of_palindrome(input_str)\nif result:\n    print(\"The string is an anagram of a palindrome.\")\nelse:\n   "
    },
    {
        "Input": "Create a Python class representing a doubly linked list and implement a method to delete a node by value.",
        "Output": "Certainly! Here's a Python class representing a doubly linked list and implementing a method to delete a node by value:\npython\nCopy code\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n            new_node.prev = current\n\n    def delete_by_value(self, value):\n        current = self.head\n\n        # Traverse the list to find the node to delete\n       "
    },
    {
        "Input": "Write a program to sort a list of strings in lexicographic (dictionary) order.",
        "Output": "Certainly! Here's a Python program to sort a list of strings in lexicographic (dictionary) order:\npython\nCopy code\ndef sort_strings_lexicographically(string_list):\n    sorted_list = sorted(string_list)\n    return sorted_list\n\n\n# Example usage\nstrings = ['apple', 'banana', 'cat', 'dog', 'elephant']\nsorted_strings = sort_strings_lexicographically(strings)\n\nprint(\"Sorted strings:\")\nfor string in sorted_strings:\n    print(string)\nIn this program, the sort_strings_lexicographically function takes a list of strings, string_list, as an argument and sorts it in lexicographic order using the sorted function.\nThe sorted function returns a new list containing the strings sorted in ascending order according to the lexicographic (dictionary) order.\nThe sorted list is then returned by the function.\nThe example usage demonstrates how to call the function with a sample list of strings, `"
    },
    {
        "Input": "Implement a function to convert a decimal number to a binary fraction.",
        "Output": "Sure! Here's a Python function to convert a decimal number to a binary fraction:\npython\nCopy code\ndef decimal_to_binary_fraction(decimal_number, precision=8):\n    binary_fraction = \"\"\n\n    # Convert the integral part of the decimal number to binary\n    integral_part = int(decimal_number)\n    binary_fraction += bin(integral_part)[2:] + \".\"\n\n    # Convert the fractional part of the decimal number to binary\n    fractional_part = decimal_number - integral_part\n    while precision > 0:\n        fractional_part *= 2\n        bit = int(fractional_part)\n        binary_fraction += str(bit)\n        fractional_part -= bit\n        precision -= 1\n\n    return binary_fraction\n\n\n# Example usage\nnumber = 6.75\nbinary_fraction = decimal_to_binary_fraction(number)\nprint(f\"The binary fraction of {number} is: {binary_fraction}\")\nIn this program, the decimal_to_binary_fraction function takes a decimal number"
    },
    {
        "Input": "Create a program to find the sum of the prime numbers up to a given number.",
        "Output": "Certainly! Here's a Python program to find the sum of the prime numbers up to a given number:\npython\nCopy code\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef sum_of_primes(limit):\n    prime_sum = 0\n    for num in range(2, limit + 1):\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\n\n# Example usage\nnumber = 100\nprime_sum = sum_of_primes(number)\nprint(f\"The sum of prime numbers up to {number} is: {prime_sum}\")\nIn this program, the is_prime function is used to check if a number n is prime. It iterates from 2 to the square root of n and checks if n is divisible by any number in that range. If n is divisible by any number, it returns False, indicating that n is not prime. Otherwise, it returns True, indicating that n is prime"
    },
    {
        "Input": "Write a Python class representing a hash table and implement methods to insert and retrieve key-value pairs.",
        "Output": "Certainly! Here's a Python class representing a hash table with methods to insert and retrieve key-value pairs:\npython\nCopy code\nclass HashTable:\n    def __init__(self, size):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def insert(self, key, value):\n        index = self._hash(key)\n        bucket = self.table[index]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n\n    def retrieve(self, key):\n        index = self._hash(key)\n        bucket = self.table[index]\n        for k, v in bucket:\n            if k == key:\n                return v\n        raise KeyError(f\"Key '{key}' not found in the hash table.\")\n\n    def __str__(self):\n        elements = []\n       "
    },
    {
        "Input": "Implement a function to reverse a given string without using any built-in methods.",
        "Output": "Sure! Here's a function to reverse a given string without using any built-in methods in Python:\npython\nCopy code\ndef reverse_string(string):\n    reversed_string = \"\"\n    for i in range(len(string) - 1, -1, -1):\n        reversed_string += string[i]\n    return reversed_string\nIn this function, we initialize an empty string reversed_string to store the reversed string. We iterate over the characters of the input string in reverse order using a for loop. Starting from the last index of the string (len(string) - 1), we decrement the index by"
    },
    {
        "Input": "Write a program to find the common elements between two sorted lists.",
        "Output": "Certainly! Here's a program to find the common elements between two sorted lists:\npython\nCopy code\ndef find_common_elements(list1, list2):\n    common_elements = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] == list2[j]:\n            common_elements.append(list1[i])\n            i += 1\n            j += 1\n        elif list1[i] < list2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return common_elements\n\n\n# Example usage\nlist1 = [1, 2, 3, 4, 6, 8]\nlist2 = [2, 4, 5, 6, 7, 8]\ncommon_elements = find_common_elements(list1, list2)\nprint(common_elements)\nIn this program, the find_common_elements function takes two sorted"
    },
    {
        "Input": "Create a Python class representing a binary min-heap and implement methods to insert and extract the minimum element.",
        "Output": "Certainly! Here's a Python class representing a binary min-heap with methods to insert and extract the minimum element:\npython\nCopy code\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._up_heapify(len(self.heap) - 1)\n\n    def extract_min(self):\n        if len(self.heap) == 0:\n            raise IndexError(\"Heap is empty.\")\n        \n        self._swap(0, len(self.heap) - 1)\n        min_value = self.heap.pop()\n        self._down_heapify(0)\n        return min_value\n\n    def _up_heapify(self, index):\n        parent_index = (index - 1) // 2\n\n        if parent_index >= 0 and self.heap[parent_index] > self.heap[index]:\n            self._swap(parent_index, index)\n            self._up_heapify(parent_index)\n\n    def _down_heapify(self, index):\n        left_child_index = (2 * index) + 1\n        right_child_index = (2 * index) + 2\n        smallest"
    },
    {
        "Input": "Implement a function to find the first non-repeating character in a string.",
        "Output": "Certainly! Here's an implementation of a function to find the first non-repeating character in a string:\npython\nCopy code\ndef find_first_non_repeating_character(string):\n    char_count = {}\n    \n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n\n# Example usage\nstring = \"hello world\"\nresult = find_first_non_repeating_character(string)\nprint(result)  # Output: \"h\"\nIn this implementation, the find_first_non_repeating_character function takes a string as input and returns the first non-repeating character.\nFirst, we create a dictionary char_count to store the"
    },
    {
        "Input": "Write a program to check if a given string is a valid URL.",
        "Output": "To check if a given string is a valid URL, you can use the urllib.parse module in Python. Here's an example program:\npython\nCopy code\nfrom urllib.parse import urlparse\n\ndef is_valid_url(url):\n    try:\n        result = urlparse(url)\n        return all([result.scheme, result.netloc])\n    except ValueError:\n        return False\n\n# Example usage\nurl1 = \"https://www.example.com\"\nurl2 = \"http://example\"\nurl3 = \"invalid_url\"\n\nprint(is_valid_url(url1))  # Output: True\nprint(is_valid_url(url2))  # Output: False\nprint(is_valid_url(url3))  # Output: False\nIn this program, the is_valid_url function takes a string as input and uses the urlparse function from urllib.parse to parse the URL and retrieve its components.\nWe"
    },
    {
        "Input": "Create a program to find the intersection of multiple sets.",
        "Output": "Certainly! Here's an example program to find the intersection of multiple sets:\npython\nCopy code\ndef find_intersection(*sets):\n    if len(sets) < 2:\n        return set()\n    \n    intersection"
    },
    {
        "Input": "Implement a function to check if a given number is a palindrome.",
        "Output": "Certainly! Here's an implementation of a function to check if a given number is a palindrome:\npython\nCopy code\ndef is_palindrome(number):\n    if number < 0:\n        return False\n\n    reverse = 0\n    temp = number\n\n    while temp > 0:\n        digit = temp % 10\n        reverse = reverse * 10 + digit\n        temp = temp // 10\n\n    return reverse == number\n\n# Example usage\nnum1 = 12321\nnum2 = 12345\n\nprint(is_palindrome(num1))  # Output: True\nprint(is_palindrome(num2))  # Output: False\nIn this implementation, the is_palindrome function takes a number as input and checks if it is a palindrome.\nFirst, we check if the number is negative. If so, we consider it as not a palindrome and return False.\nWe then initialize a variable reverse to 0 and create a temporary variable temp to store the number.\nUsing a while loop, we extract the last digit of the number (digit) by taking the modulus with 10, and update the reverse variable by multiplying it by 10"
    },
    {
        "Input": "Write a Python class representing a circular queue and implement a method to check if it is full.",
        "Output": "Sure! Here's a Python class representing a circular queue with a method to check if it is full:\npython\nCopy code\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.size = 0\n        self.front = 0\n        self.rear = -1\n\n    def is_full(self):\n        return self.size == self.capacity\n\n    # Other methods of the circular queue...\n\n# Example usage\nqueue = CircularQueue(5)\nqueue.enqueue(10)\nqueue.enqueue(20)\nqueue.enqueue(30)\nqueue.enqueue(40)\nqueue.enqueue(50)\n\nprint(queue.is_full())  # Output: True\nIn this implementation, the CircularQueue class represents a circular queue. It has an attribute capacity to store the maximum capacity of the queue, an attribute `"
    },
    {
        "Input": "Create a program to find the largest prime palindrome less than a given number.",
        "Output": "Sure! Here's a program to find the largest prime palindrome less than a given number:\npython\nCopy code\ndef is_prime(number):\n    if number < 2:\n        return False\n\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n\n    return True\n\ndef is_palindrome(number):\n    return str(number) == str(number)[::-1]\n\ndef largest_prime_palindrome(limit):\n    for num in range(limit - 1, 1, -1):\n        if is_prime(num) and is_palindrome(num):\n            return num\n\n    return None\n\n# Example usage\nlimit = 1000\nlargest_prime_palindrome_num = largest_prime_palindrome(limit)\nprint(largest_prime_palindrome_num)  # Output: 929\nIn this program, we have three helper functions:\nis_prime: This function checks if a number is prime or not. It iterates from 2 to the square root of"
    },
    {
        "Input": "Implement a function to remove all occurrences of a specified element from a list.",
        "Output": "Certainly! Here's a function that removes all occurrences of a specified element from a list:\npython\nCopy code\ndef remove_element(lst, element):\n    return [x for x in lst if x != element]\nIn this function, lst is the input list and element is the element to be removed. The function uses a list comprehension to iterate over each element in lst and only includes the elements that are not equal to element in the resulting list. This effectively removes all occurrences of element from the list.\nHere's an example usage of the function:\npython\nCopy code\nmy_list = [1, 2, 3, 4, 3, 5, 3]\nresult = remove_element(my_list, 3)\nprint(result)  # Output: [1, 2, 4, 5]\nIn this example, we have a list my_list with several occurrences of the element 3. We call the remove_element"
    },
    {
        "Input": "Write a program to calculate the sum of the digits of a given number until it becomes a single-digit number.",
        "Output": "Sure! Here's a program to calculate the sum of the digits of a given number until it becomes a single-digit number:\npython\nCopy code\ndef sum_of_digits(number):\n    while number >= 10:\n        number = sum(int(digit) for digit in str(number))\n    return number\n\n# Example usage\nnumber = 12345\nresult = sum_of_digits(number)\nprint(result)  # Output: 6\nIn this program, the sum_of_digits function takes a number as input and iteratively calculates the sum of its digits until the resulting sum becomes a single-digit number.\nThe function uses a while loop to keep calculating the sum until the number becomes less than 10. Inside the loop, the number is converted to a string using str(number), and each digit is extracted using a generator expression int(digit) for digit in str(number). The sum function is then used to calculate the sum of the digits. This process continues until the resulting sum becomes a single-digit number.\nOnce the sum becomes a single-digit number, the loop exits and the function returns"
    },
    {
        "Input": "Create a Python class representing a trie (prefix tree) and implement methods to insert and search for words.",
        "Output": "Certainly! Here's a Python class representing a Trie (prefix tree) and implementing methods to insert and search for words:\npython\nCopy code\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\nIn this implementation, we have two classes:\nTrieNode: This class represents a node in the trie. It has a dictionary children to store the child nodes, and a boolean is_end_of_word flag to indicate if a word ends at that node.\nTrie: This class represents the trie data structure. It has a root node as an instance variable. The insert method inserts a word into the trie by iterating"
    },
    {
        "Input": "Implement a function to check if a given string is an anagram of another string.",
        "Output": "Sure! Here's a function to check if a given string is an anagram of another string:\npython\nCopy code\ndef is_anagram(str1, str2):\n    # Convert both strings to lowercase and remove whitespace\n    str1 = str1.lower().replace(\" \", \"\")\n    str2 = str2.lower().replace(\" \", \"\")\n\n    # Check if the lengths of the strings are equal\n    if len(str1) != len(str2):\n        return False\n\n    # Create dictionaries to count character frequencies in both strings\n    char_count_1 = {}\n    char_count_2 = {}\n\n    # Count the frequency of each character in str1\n    for char in str1:\n        char_count_1[char] = char_count_1.get(char, 0) + 1\n\n    # Count the frequency of each character in str2\n    for char in str2:\n        char_count_2[char] = char_count_2.get(char, 0) + 1\n\n    # Check if the character frequencies in both strings are equal\n    return char_count_1 == char_count_2\nIn this implementation, the is_anagram function takes two strings str1 and str2 as input and checks if"
    },
    {
        "Input": "Write a program to find the minimum number of coins needed to make a given amount of change.",
        "Output": "Sure! Here's a program to find the minimum number of coins needed to make a given amount of change:\npython\nCopy code\ndef minimum_coins(coins, amount):\n    # Create a list to store the minimum number of coins needed for each amount\n    dp = [float('inf')] * (amount + 1)\n\n    # Base case: 0 coins needed to make 0 amount\n    dp[0] = 0\n\n    # Iterate over all amounts from 1 to the target amount\n    for i in range(1, amount + 1):\n        # Iterate over all available coins\n        for coin in coins:\n            # If the current coin value is less than or equal to the current amount,\n            # update the minimum number of coins needed for the current amount\n            if coin <= i:\n                dp[i] = min(dp[i], 1 + dp[i - coin])\n\n    # Return the minimum number of coins needed to make the target amount\n    return dp[amount]\n``"
    },
    {
        "Input": "Create a program to find the second smallest element in a list.",
        "Output": "Certainly! Here's a program to find the second smallest element in a list:\npython\nCopy code\ndef find_second_smallest(nums):\n    if len(nums) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest\nThe find_second_smallest function takes a list of numbers nums as input and returns the second smallest element. Here's how it works:\nWe initialize two variables smallest and second_smallest with the maximum possible value float('inf').\nWe iterate over each number num in the input list nums.\nIf the current number"
    },
    {
        "Input": "Implement a function to perform matrix addition.",
        "Output": "Certainly! Here's a program to perform matrix addition:\npython\nCopy code\ndef matrix_addition(matrix1"
    },
    {
        "Input": "Write a Python class representing a hash set and implement methods to insert and remove elements.",
        "Output": "Certainly! Here's an implementation of a Python class representing a hash set with methods to insert and remove elements:\npython\nCopy code\nclass HashSet:\n    def __init__(self):\n        self.bucket_count = 16\n        self.buckets = [[] for _ in range(self.bucket_count)]\n\n    def _hash_function(self, value):\n        return hash(value) % self.bucket_count\n\n    def insert(self, value):\n        hash_value = self._hash_function(value)\n        bucket = self.buckets[hash_value]\n\n        if value not in bucket:\n            bucket.append(value)\n\n    def remove(self, value):\n        hash_value = self._hash_function(value)\n        bucket = self.buckets[hash_value]\n\n        if value in bucket:\n            bucket.remove(value)\n\n    def __contains__(self, value):\n        hash_value = self._hash_function(value)\n        bucket = self.buckets[hash_value]\n\n        return value in bucket\nIn this implementation:\nThe"
    },
    {
        "Input": "Create a program to find the length of the longest increasing subarray in a given list of integers.",
        "Output": "Certainly! Here's a program to find the length of the longest increasing subarray in a given list of integers:\npython\nCopy code\ndef find_longest_increasing_subarray_length(nums):\n    if not nums:\n        return 0\n\n    longest_length = 1\n    current_length = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_length += 1\n            longest_length = max(longest_length, current_length)\n        else:\n            current_length = 1\n\n    return longest_length\nHere's an example usage of the function:\npython\nCopy code\nnums = [1, 2, 3, 2, 4, 5, 1, 2, 3, 4, 5, 6, 7]\nresult = find_longest_increasing_subarray_length(nums)\nprint(result)  # Output: 6\nIn this example, the program defines the `find_long"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid palindrome, considering only alphanumeric characters.\"",
        "Output": "Certainly! Here's an implementation of a function that checks if a given string is a valid palindrome, considering only alphanumeric characters:\npython\nCopy code\ndef is_valid_palindrome(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n\n    # Check if the string is a palindrome\n    return s == s[::-1]\nHere's an example usage of the function:\npython\nCopy code\nstring1 = \"A man, a plan, a canal: Panama\"\nresult1 = is_valid_palindrome(string1)\nprint(result1)  # Output: True\n\nstring2 = \"race a car\"\nresult2 = is_valid_palindrome(string2)\nprint(result2)  # Output: False\nIn this example, the program defines the is_valid_palindrome function that takes a string s as input. It removes all non-alphanumeric characters from the string using a list comprehension and converts"
    },
    {
        "Input": "Write a program to generate all possible permutations of a given string.",
        "Output": "Certainly! Here's a program to generate all possible permutations of a given string:\npython\nCopy code\ndef generate_permutations(s):\n    # Base case: If the string has only one character, return it as a single-element list\n    if len(s) == 1:\n        return [s]\n\n    # Recursive case: Generate permutations for each character in the string\n    permutations = []\n    for i in range(len(s)):\n        # Remove the current character from the string\n        remaining_chars = s[:i] + s[i+1:]\n\n        # Generate permutations for the remaining characters\n        remaining_permutations = generate_permutations(remaining_chars)\n\n        # Add the current character to the beginning of each permutation\n        for perm in remaining_permutations:\n            permutations.append(s[i] + perm)\n\n    return permutations\nHere's an example usage of the function:\npython\nCopy code\nstring = \"abc\"\npermutations = generate_permutations"
    },
    {
        "Input": "Create a Python class representing a circular linked list and implement a method to delete a node at a given position.",
        "Output": "Certainly! Here's a Python class representing a circular linked list with a method to delete a node at a given position:\npython\nCopy code\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        new_node = Node(data)\n\n        if self.head is None:\n            self.head = new_node\n            self.head.next = self.head\n        else:\n            current = self.head\n            while current.next != self.head:\n                current = current.next\n            current.next = new_node\n            new_node.next = self.head\n\n    def delete_at_position(self, position):\n        if self.head is None:\n            return\n\n        current = self.head\n        prev = None\n        count = 1\n\n        # Find the node to be deleted\n        while count < position:\n            prev = current\n            current = current.next\n           "
    },
    {
        "Input": "Implement a function to find the majority element (appears more than n/2 times) in a list.",
        "Output": "Certainly! Here's an implementation of a function to find the majority element in a list:\npython\nCopy code\ndef find_majority_element(nums):\n    count = 0\n    majority = None\n\n    for num in nums:\n        if count == 0:\n            majority = num\n            count = 1\n        elif num == majority:\n            count += 1\n        else:\n            count -= 1\n\n    # Verify if the majority element appears more than n/2 times\n    count = 0\n    for num in nums:\n        if num == majority:\n            count += 1\n\n    if count > len(nums) // 2:\n        return majority\n    else:\n        return None\n\n\n# Example usage:\nnums = [1, 2, 3, 2, 2, 2, 5]\nresult = find_majority_element(nums)\n\nif result is not None:\n    print(f\"The majority element in the list is {result}\")\nelse:\n    print(\"There is no majority element in the list\")\nIn this implementation,"
    },
    {
        "Input": "Write a program to calculate the sum of all even Fibonacci numbers up to a given limit.",
        "Output": "Certainly! Here's a program that calculates the sum of all even Fibonacci numbers up to a given limit:\npython\nCopy code\ndef sum_even_fibonacci(limit):\n    # Initialize variables\n    prev, curr = 0, 1\n    sum_even = 0\n\n    # Calculate Fibonacci numbers and sum the even ones\n    while curr <= limit:\n        if curr % 2 == 0:\n            sum_even += curr\n\n        # Calculate the next Fibonacci number\n        prev, curr = curr, prev + curr\n\n    return sum_even\n\n\n# Example usage:\nlimit = 4000000\nresult = sum_even_fibonacci(limit)\nprint(f\"The sum of even Fibonacci numbers up to {limit} is: {result}\")\nIn this program, we use a while loop to calculate Fibonacci numbers and sum the even ones. We start with the initial values prev = 0 and curr = 1. In each iteration, we check if curr is even using the modulo operator (curr % 2 == 0). If it is, we add it to the `sum"
    },
    {
        "Input": "Create a program to sort a list of strings using the insertion sort algorithm.",
        "Output": "Certainly! Here's a program that sorts a list of strings using the insertion sort algorithm:\npython\nCopy code\ndef insertion_sort(strings):\n    # Traverse through the list\n    for i in range(1, len(strings)):\n        key = strings[i]\n        j = i - 1\n\n        # Compare the current element with the elements before it\n        while j >= 0 and strings[j] > key:\n            strings[j + 1] = strings[j]\n            j -= 1\n\n        # Place the current element at its correct position\n        strings[j + 1] = key\n\n    return strings\n\n\n# Example usage:\nstrings = [\"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\"]\nsorted_strings = insertion_sort(strings)\n\nprint(\"Sorted list of strings:\")\nfor string in sorted_strings:\n    print(string)\nIn this program, the insertion_sort function implements the insertion sort algorithm. It iterates through the list starting from the second element (i = 1) and compares each element with the elements before it (j). If an element is smaller, it shifts the elements to the right until it finds the correct position for the current element. Finally, it places the current element"
    },
    {
        "Input": "Implement a function to find the maximum subarray sum in a given list of integers.",
        "Output": "Certainly! Here's a function that finds the maximum subarray sum in a given list of integers using Kadane's algorithm:\npython\nCopy code\ndef max_subarray_sum(nums):\n    if not nums:\n        return 0\n\n    max_sum = nums[0]  # Initialize the maximum sum\n    current_sum = nums[0]  # Initialize the current sum\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\n# Example usage:\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nresult = max_subarray_sum(nums)\nprint(\"Maximum subarray sum:\", result)\nIn this program, the max_subarray_sum function implements Kadane's algorithm. It starts by initializing the maximum sum (max_sum) and"
    },
    {
        "Input": "Write a Python class representing a directed weighted graph and implement methods to add edges and perform Dijkstra's algorithm.",
        "Output": "Certainly! Here's an example of a Python class representing a directed weighted graph and implementing methods to add edges and perform Dijkstra's algorithm:\npython\nCopy code\nfrom heapq import heappop, heappush\n\n\nclass DirectedWeightedGraph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, source, destination, weight):\n        if source not in self.graph:\n            self.graph[source] = []\n        self.graph[source].append((destination, weight))\n\n    def dijkstra(self, source):\n        distances = {node: float('inf') for node in self.graph}\n        distances[source] = 0\n\n        priority_queue = [(0, source)]\n\n        while priority_queue:\n            current_distance, current_node = heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.graph[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heappush(priority_queue, (distance, neighbor))\n\n       "
    },
    {
        "Input": "Create a program to remove all duplicate characters from a string and maintain the original order.",
        "Output": "Certainly! Here's a program that removes all duplicate characters from a string while maintaining the original order:\npython\nCopy code\ndef remove_duplicates(string):\n    seen = set()\n    result = []\n\n    for char in string:\n        if char not in seen:\n            seen.add(char)\n            result.append(char)\n\n    return ''.join(result)\n\n\n# Example usage:\ninput_string = \"Hello, World!\"\noutput_string = remove_duplicates(input_string)\nprint(output_string)\nIn this program, the remove_duplicates function takes a string as input and removes duplicate characters while preserving the order. It uses a set, seen, to keep track of characters that have already been encountered. It also uses a list, result, to store the non-duplicate characters in the original order.\nThe function iterates over each character in the input string. If a character has not been seen before (i.e., not in the seen set), it adds the character to the set and appends it to the result list. Finally, the result list is joined back into a string using the join method and returned.\nIn the example usage, the remove_duplicates function is called with the input string \"Hello, World!\". The resulting string is printed, which will be \"Helo, Wrd!\" since all duplicate characters"
    },
    {
        "Input": "\"Implement a function to find the number of ways to climb a staircase with a given number of steps, considering that you can take either 1 or 2 steps at a time.\"",
        "Output": "Sure! You can use a recursive approach to solve this problem. Here's the implementation of a function that calculates the number of ways to climb a staircase with a given number of steps:\npython\nCopy code\ndef count"
    },
    {
        "Input": "Write a program to count the number of occurrences of each character in a given string.",
        "Output": "Certainly! Here's a program that counts the number of occurrences of each character in a given string:\npython\nCopy code\ndef count_characters(string):\n    char_count = {}\n    \n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    return char_count\n\n\n# Example usage:\ninput_string = \"Hello, World!\"\ncharacter_count = count_characters(input_string)\nfor char, count in character_count.items():\n    print(f\"{char}: {count}\")\nIn this program, the count_characters function takes a string as input and returns a dictionary char_count where the keys are the characters in the string and the values are the counts of each character.\nThe function iterates over each character in"
    },
    {
        "Input": "Create a Python class representing a circular doubly linked list and implement a method to insert a node at the end.",
        "Output": "Certainly! Here's an example of a Python class representing a circular doubly linked list and an implementation of the insert_at_end method:\npython\nCopy code\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\nclass CircularDoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_end(self, data):\n        new_node = Node(data)\n\n        if self.head is None:\n            self.head = new_node\n            new_node.next = new_node\n            new_node.prev = new_node\n        else:\n            last_node = self.head.prev\n            last_node.next = new_node\n            new_node.prev ="
    },
    {
        "Input": "Implement a function to check if a given string is a valid parentheses expression.",
        "Output": "Certainly! Here's an implementation of a function to check if a given string is a valid parentheses expression using a stack:\npython\nCopy code\ndef is_valid_parentheses(expression):\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n    \n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if len(stack) == 0:\n                return False\n            else:\n                last_opening_bracket = stack.pop()\n                if opening_brackets.index(last_opening_bracket) != closing_brackets.index(char):\n                    return False\n    \n    return len(stack) == 0\nIn this implementation, we use a stack data structure to keep track of the opening parentheses encountered. We iterate over each character in the expression and perform the following steps:\nIf the character is an opening bracket (i.e., '(', '[', or '{'), we push it onto the stack.\nIf the character is a closing bracket (i.e., ')', ']', or '}'), we check if the stack is empty. If it is, we know that there is no corresponding opening bracket for the current closing bracket,"
    },
    {
        "Input": "Write a program to find the smallest missing positive integer in a given list of integers.",
        "Output": "To find the smallest missing positive integer in a given list of integers, you can use the following Python program:\npython\nCopy code\ndef find_smallest_missing_positive(nums):\n    n = len(nums)\n    \n    # Move all positive integers to the left side of the list\n    j = 0\n    for i in range(n):\n        if nums[i] <= 0:\n            nums[i], nums[j] = nums[j], nums[i]\n            j += 1\n    \n    # Consider only the positive integers in the modified list\n    nums = nums[j:]\n    n = len(nums)\n    \n    # Mark the presence of a positive integer by negating the corresponding index\n    for i in range(n):\n        num = abs(nums[i])\n       "
    },
    {
        "Input": "Create a program to reverse the order of words in a given string while preserving whitespace.",
        "Output": "To reverse the order of words in a given string while preserving whitespace, you can use the following Python program:\npython\nCopy code\ndef reverse_words(string):\n    words = string.split(\" \")\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n    return reversed_string\nHere's an example usage of the reverse_words function:\npython\nCopy code\nstring = \"Hello   World!   How   are   you?\"\nreversed_string = reverse_words(string)\nprint(reversed_string)  # Output: \"you?   are   How   World!   Hello\"\nIn this example, the reverse_words function takes a string as input. It splits the string into words using whitespace as the delimiter, reverses the order of the words, and then joins the"
    },
    {
        "Input": "Implement a function to find the maximum product of two integers in a given list.",
        "Output": "Sure! Here's a function that finds the maximum product of two integers in a given list:\npython\nCopy code\ndef max_product(nums):\n    if len(nums) < 2:\n        raise ValueError(\"The list should contain at least two integers.\")\n\n    max_product = float(\"-inf\")\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n   "
    },
    {
        "Input": "Write a Python class representing a stack and implement a method to find the minimum element in constant time.",
        "Output": "Certainly! Here's a Python class representing a stack with a method to find the minimum element in constant time:\npython\nCopy code\nclass StackWithMin:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n        if not self.min_stack or value <= self.min_stack[-1]:\n            self.min_stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError(\"Stack is empty.\")\n        value = self.stack.pop()\n        if value == self.min_stack[-1]:\n            self.min_stack.pop()\n        return value\n\n    def peek(self):\n        if not self.stack:\n            raise IndexError(\"Stack is empty.\")\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def get_min(self):\n        if not self.min_stack:\n            raise IndexError(\"Stack is empty.\")\n        return self.min_stack[-1]\nIn this implementation, we use two stacks: stack to store the elements and min_stack to keep track of the current minimum element. Whenever we push an element onto the stack, we also check if it is less than or equal to the top element of min_stack. If it is, we push it onto min_stack. When we pop an element from stack, we check"
    },
    {
        "Input": "Create a program to find the largest sum of a contiguous subarray in a given list of integers.",
        "Output": "Certainly! Here's a program to find the largest sum of a contiguous subarray in a given list of integers:\npython\nCopy code\ndef max_subarray_sum(arr):\n    if not arr:\n        return 0\n\n    current_sum = max_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\nIn this program, we use the Kadane's algorithm to find the largest sum of a contiguous subarray. We iterate through the array and keep track of two variables: current_sum and max_sum. current_sum stores the maximum sum of a subarray ending at the current index, and max_sum stores the overall maximum sum encountered so far.\nFor each element in the array, we"
    },
    {
        "Input": "Implement a function to check if a given number is a happy number.",
        "Output": "Certainly! Here's an implementation of a function to check if a given number is a happy number:\npython\nCopy code\ndef is_happy_number(n):\n    visited = set()\n    while n != 1:\n        if n in visited:\n            return False\n        visited.add(n)\n        n = calculate_next_number(n)\n    return True\n\ndef calculate_next_number(n):\n    next_number = 0\n    while n > 0:\n        digit = n % 10\n        next_number += digit * digit\n        n //= 10\n    return next_number\nIn this implementation, the is_happy_number function checks if a given number is a happy number. It uses a set visited to keep track of the numbers encountered during the calculation. The function repeatedly calculates the next number using the calculate_next_number function until it either reaches 1 (indicating a happy number) or encounters a number that has already been visited (indicating a cycle and not a happy number).\nThe calculate_next_number"
    },
    {
        "Input": "Write a program to find the number of ways to make change for a given amount using a set of coins.",
        "Output": "Sure! Here's a program to find the number of ways to make change for a given amount using a set of coins:\npython\nCopy code\ndef count_change(coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n\n    for coin in coins:\n        for i in range(coin, amount +"
    },
    {
        "Input": "Create a Python class representing a binary AVL tree and implement methods to insert and search for nodes.",
        "Output": "Certainly! Here's an implementation of a binary AVL tree in Python with methods to insert and search for nodes:\npython\nCopy code\nclass AVLNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, data):\n        self.root = self._insert(self.root, data)\n\n    def _insert(self, node, data):\n        if node is None:\n            return AVLNode(data)\n        \n        if data < node.data:\n            node.left = self._insert(node.left, data)\n        else:\n            node.right = self._insert(node.right, data)\n\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n        balance = self._get_balance(node)\n\n        if balance > 1:\n            if data < node.left.data:\n                return self._rotate_right(node)\n            else:\n                node.left = self._rotate_left(node.left)\n                return self._rotate_right(node)\n\n       "
    },
    {
        "Input": "Implement a function to check if a given string is a valid parentheses expression with different types of parentheses.",
        "Output": "Sure! Here's an implementation of a function to check if a given string is a valid parentheses expression, considering different types of parentheses:\npython\nCopy code\ndef is_valid_parentheses(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1]"
    },
    {
        "Input": "Write a program to find the smallest missing positive integer that does not appear in a given list of integers.",
        "Output": "Certainly! Here's an example implementation of a program to find the smallest missing positive integer in a given list of integers:\npython\nCopy code\ndef find_smallest_missing_positive(nums):\n    n = len(nums)\n\n    # Step 1: Move all positive integers to the left side of the list\n    i = 0\n    while i < n:\n        if 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        else:\n            i += 1\n\n    # Step 2: Find the first index where the value is not equal to the index + 1\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    # If all positive integers from 1 to n are present, the smallest missing positive is n + 1\n    return n + "
    },
    {
        "Input": "Create a program to find the longest substring with at most K distinct characters in a given string.",
        "Output": "Certainly! Here's an example implementation of a program to find the longest substring with at most K distinct characters in a given string:\npython\nCopy code\ndef longest_substring_with_k_distinct_chars(s, k):\n    n = len(s)\n    if k == 0 or n == 0:\n        return \"\"\n\n    char_count = {}\n    max_len = 0\n    max_start = 0\n    start = 0\n\n    for end in range(n):\n        # Add current character to the dictionary and increment its count\n        char_count[s[end]] = char_count.get(s[end], 0) + 1\n\n        #"
    },
    {
        "Input": "\"Implement a function to find the maximum difference between two elements in a given list, with the second element appearing after the first.\"",
        "Output": "Certainly! Here's an implementation of a function that finds the maximum difference between two elements in a given list, with the second element appearing after the first:\npython\nCopy code\ndef find_max_difference(arr):\n    if len(arr) < 2:\n        return None\n\n    min_element = arr[0]\n    max_difference = arr[1] - arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] - min_element > max_difference:\n            max_difference = arr[i] - min_element\n\n        if arr[i] < min_element:\n            min_element = arr[i]\n\n    return max_difference\nIn this implementation, we initialize the min_element as the first element of the list and the max_difference as the difference between the second element and the first element. We then iterate through the list starting from the second element.\nAt each iteration, we"
    },
    {
        "Input": "\"Write a Python class representing a hash map and implement methods to insert, retrieve, and remove key-value pairs.\"",
        "Output": "Certainly! Here's an implementation of a Python class representing a hash map (also known as a dictionary or associative array) with methods to insert, retrieve, and remove key-value pairs:\npython\nCopy code\nclass HashMap:\n    def __init__(self):\n        self.size = 10  # initial size of the hash map\n        self.map = [[] for _ in range(self.size)]  # list of lists for handling collisions\n\n    def _get_hash(self, key):\n        # calculate the hash value for a given key\n        return hash(key) % self.size\n\n    def insert(self, key, value):\n        # insert a key-value pair into the hash map\n        key_hash = self._get_hash(key)\n        key_value = [key, value]\n\n        # check if the key already exists, update the value if so\n        for pair in self.map[key_hash]:\n            if pair[0] == key:\n                pair[1] = value"
    },
    {
        "Input": "Create a program to check if a given string is a valid Sudoku solution.",
        "Output": "Certainly! Here's a program to check if a given string represents a valid Sudoku solution:\npython\nCopy code\ndef is_valid_sudoku(board):\n    # Check rows\n    for row in board:\n        if not is_valid_row(row):\n            return False\n\n    # Check columns\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if not is_valid_row(column):\n            return False\n\n    # Check subgrids\n    for row in range(0, 9, 3):\n        for col in range(0, 9, 3):\n            subgrid = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n            if not is_valid_row(subgrid):\n                return False\n\n    return True\n\n\ndef is_valid_row(row):\n    # Check if a given row (or column or subgrid) is valid\n    seen = set()\n    for num in row:\n        if num != \".\":\n            if num in seen:\n                return False\n            seen.add(num)\n    return True\n\n\n# Example usage:\nvalid_solution = [\n    [\"5\", \"3\", \".\","
    },
    {
        "Input": "Implement a function to calculate the square root of a given number without using built-in functions.",
        "Output": "To calculate the square root of a given number without using built-in functions, we can use an iterative approach such as the Newton's method. Here's an implementation of a square root function:\npython\nCopy code\ndef square_root(number, precision=0.0001):\n    if number < 0:\n        raise ValueError(\"Cannot calculate square root of a negative number\")\n\n    guess = number / 2  # Start with an initial guess\n\n    while abs(guess * guess - number) > precision:\n        guess = (guess + number / guess) / 2  # Update the guess using Newton's method"
    },
    {
        "Input": "Write a program to find the number of distinct elements in a given list.",
        "Output": "To find the number of distinct elements in a given list, you can use a set data structure. Here's a simple program that demonstrates this:\npython\nCopy code\ndef count_distinct_elements(lst):\n    distinct_elements = set(lst)  # Create a set from the list to remove duplicates\n    return len(distinct_elements)  # Return the count of distinct elements\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]\nprint(count_distinct_elements(numbers))  # Output: 8\nIn this program, the count_distinct_elements function takes a list as input. It creates a set from the list, which automatically removes duplicate elements. The number of elements in the set is then returned as the count of distinct elements.\nYou can use this function with any list of elements to find the number of distinct elements."
    },
    {
        "Input": "Create a Python class representing a directed weighted graph and implement methods to perform a topological sort.",
        "Output": "Certainly! Here's an example of a Python class representing a directed weighted graph with methods to perform a topological sort:\npython\nCopy code\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v, weight):\n        self.graph[u].append((v, weight))\n\n    def topological_sort_util(self, v, visited, stack):\n        visited[v] = True\n\n        for neighbor, _ in self.graph[v]:\n            if not visited[neighbor]:\n                self.topological_sort_util(neighbor, visited, stack)\n\n        stack.insert(0, v)\n\n    def topological_sort(self):\n        visited = defaultdict(bool)\n        stack = []\n\n        for vertex in self.graph:\n            if not visited[vertex]:\n                self.topological_sort_util(vertex, visited, stack)\n\n        return stack\n\n# Example usage:\ng"
    },
    {
        "Input": "Implement a function to check if a given string is a valid expression with balanced parentheses.",
        "Output": "Certainly! Here's an example implementation of a function to check if a given string is a valid expression with balanced parentheses:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_brackets = {'(', '[', '{'}\n    closing_brackets = {')', ']', '}'}\n    bracket_pairs = {'(': ')', '[': ']', '{': '}'}\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            top = stack.pop()\n            if bracket_pairs[top] != char:\n                return False\n\n    return len(stack) == 0\n\n# Example usage:\nexpression1 = \"((a + b) * (c - d))\"\nexpression2 = \"((a + b) * (c - d)}\"\nexpression3 = \"(a + b) * (c - d))\"\nexpression4 = \"{[a + b] * (c - d)}\"\n\nprint(is_valid_expression(expression1))  # Output: True\nprint(is_valid_expression(expression2))  # Output: False\nprint(is_valid_expression(expression3))  # Output: False\nprint(is_valid_expression"
    },
    {
        "Input": "Write a program to find the maximum sum of non-adjacent elements in a given list of integers.",
        "Output": "Certainly! Here's an example program to find the maximum sum of non-adjacent elements in a given list of integers:\npython\nCopy code\ndef max_sum_non_adjacent(nums):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    # Initialize two variables to keep track of the maximum sum\n    # considering the previous element and the maximum sum without\n    # considering the previous element\n    prev_max_sum = nums[0]\n    curr_max_sum = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        # Calculate the maximum sum by considering the current element\n        # and the maximum sum without considering the previous element\n        temp = max(curr_max_sum, prev_max_sum + nums[i])\n\n        # Update the previous and current maximum sum variables\n        prev_max_sum = curr_max_sum\n        curr_max_sum = temp\n\n    # Return the maximum of the last two sums"
    },
    {
        "Input": "Implement a function to find the longest palindromic substring in a given string.",
        "Output": "Certainly! Here's an example implementation of a function to find the longest palindromic substring in a given string:\npython\nCopy code\ndef longest_palindrome(s):\n    if not s:\n        return \"\"\n\n    n = len(s)\n    start, end = 0, 0\n\n    for i in range(n):\n        len1 = expand_from_center(s, i, i)  # For odd-length palindromes\n        len2 = expand_from_center(s, i, i + 1)  # For even-length palindromes\n        max_len = max(len1, len2)\n\n        if max_len > end - start + 1:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n\n    return s[start:end + 1]\n\n\ndef expand_from_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n       "
    },
    {
        "Input": "Write a program to find the minimum number of characters to be removed from a string to make it a palindrome.",
        "Output": "To find the minimum number of characters to be removed from a string to make it a palindrome, you can use dynamic programming to solve this problem efficiently. Here's an example implementation:\npython\nCopy code\ndef min_chars_removed(s):\n    if not s:\n        return 0\n\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -"
    },
    {
        "Input": "Create a Python class representing a binary max-heap and implement methods to insert and extract the maximum element.",
        "Output": "Certainly! Here's an implementation of a Python class representing a binary max-heap with methods to insert and extract the maximum element:\npython\nCopy code\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._sift_up(len(self.heap) - 1)\n\n    def extract_max(self):\n        if len(self.heap) == 0:\n            raise IndexError(\"Heap is"
    },
    {
        "Input": "Implement a function to find the first repeating element in a list.",
        "Output": "Sure! Here's an implementation of a function that finds the first repeating element in a given list:\npython\nCopy code\ndef find_first_repeating_element(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\nThe find_first_repeating_element function takes a list nums as input and uses a set seen to keep track of the elements that have been encountered so far. It iterates through each element in the list and checks if the element is already present in the set. If it is, then it is the first repeating element and is returned. If not, it is added to the set. If no repeating element is found, the function returns None.\nHere's an example usage of the find_first_repeating_element function:\npython\nCopy code\nnums = [2, 3, 4, 5, 2, 6, 7, 4]\nresult = find_first_repeating_element(nums)\nprint"
    },
    {
        "Input": "Write a program to find the length of the longest common subsequence between two strings.",
        "Output": "Certainly! Here's an implementation of a program that finds the length of the longest common subsequence between two strings using dynamic programming:\npython\nCopy code\ndef longest_common_subsequence_length(str1, str2):\n    m = len(str1)\n    n = len(str2)\n\n    # Create a table to store the lengths of longest common subsequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Compute the lengths of longest common subsequences\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Return the length of the longest common subsequence\n    return dp[m][n]\nThe `longest_common"
    },
    {
        "Input": "Create a program to remove all duplicate elements from a list and maintain the original order.",
        "Output": "Certainly! Here's an implementation of a program that removes all duplicate elements from a list while maintaining the original order:\npython\nCopy code\ndef remove_duplicates(lst):\n    seen = set()\n    result = []\n\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n           "
    },
    {
        "Input": "Implement a function to check if a given string is a valid parenthesis expression with different types of parentheses.",
        "Output": "To check if a given string is a valid parenthesis expression with different types of parentheses, you can use a stack data structure. Here's an implementation of the function:\npython\nCopy code\ndef is_valid_parenthesis(expression):\n    stack = []\n    opening = set(['(', '[', '{'])\n    closing = set([')', ']', '}'])\n    pairs = {')': '(', ']': '[', '}': '{'}\n\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if len(stack) == 0 or stack[-1] != pairs[char]:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\nThe is_valid_parenthesis function takes a string expression as input and initializes an empty stack, opening set containing opening parentheses, closing set containing closing parentheses, and a dictionary pairs that maps closing parentheses to their respective opening parentheses.\nThe function then iter"
    },
    {
        "Input": "Write a Python class representing a circular queue and implement a method to get the front element without removing it.",
        "Output": "Certainly! Here's a Python class representing a circular queue with a method to get the front element without removing it:\npython\nCopy code\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n\n    def is_empty(self):\n        return self.front == -1\n\n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n\n    def enqueue(self, item):\n        if self.is_full():\n            print(\"Queue is full. Unable to enqueue item.\")\n            return\n        elif self.is_empty():\n            self.front = 0\n            self.rear = 0\n        else:\n            self.rear = (self.rear + 1) % self.capacity\n\n        self.queue[self.rear] = item\n\n    def dequeue(self):\n        if self.is_empty():\n            print(\"Queue is empty. Unable to dequeue item.\")\n            return\n\n        item = self.queue[self.front]\n        if self.front == self.rear:"
    },
    {
        "Input": "Create a program to find the maximum sum of a non-empty subarray in a given list of integers.",
        "Output": "Certainly! Here's a program to find the maximum sum of a non-empty subarray in a given list of integers:\npython\nCopy code\ndef max_subarray_sum(arr):\n    if not arr:\n        return 0\n\n    current_sum = max_sum = arr[0]\n\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\nThe max_subarray_sum function takes a list of integers"
    },
    {
        "Input": "Implement a function to check if a given number is a perfect number.",
        "Output": "Sure! A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding itself). Here's a function to check if a given number is a perfect number:\npython\nCopy code\ndef is_perfect_number(num):\n    if num <= 0:\n        return False\n\n    divisor_sum = sum([divisor for divisor in range(1, num) if num % divisor == 0])\n\n    return divisor_sum == num\nThe is_perfect_number function takes an integer num as input and returns True if"
    },
    {
        "Input": "Write a program to find the kth largest element in a given list.",
        "Output": "Sure! Here's a program to find the kth largest element in a given list:\npython\nCopy code\ndef find_kth_largest(nums, k):\n    if k < 1 or k > len(nums):\n        return None\n\n    # Sort the list in descending order\n    nums.sort(reverse=True)\n\n    return nums[k - 1]\nThe find_kth_largest function takes a list of numbers nums and an integer k as input and returns the kth largest element from the list. If k is invalid (less than 1 or greater than the length of the list), the function returns None.\nThe algorithm works as follows:\nFirst, we check if k is a valid index within the range of the list. If"
    },
    {
        "Input": "Create a Python class representing a trie (prefix tree) and implement methods to insert and search for words.",
        "Output": "Certainly! Here's an implementation of a Trie (Prefix Tree) class in Python with methods to insert words and search for words:\npython\nCopy code\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\nThe TrieNode class represents a node in the Trie. It contains a dictionary children to store the children nodes and a boolean is_end_of_word to indicate if the node represents the end of a word.\nThe Trie class is the main class that represents the Trie data structure. It has an instance variable root that points"
    },
    {
        "Input": "Implement a function to check if a given string is a valid expression with balanced parentheses and brackets.",
        "Output": "Certainly! Here's an implementation of a function in Python to check if a given string is a valid expression with balanced parentheses and brackets:\npython\nCopy code\ndef is_valid_expression(s):\n    stack = []\n    opening_brackets = ['(', '[']\n    closing_brackets = [')', ']']\n    matching_brackets = {'(': ')', '[': ']'}\n    \n    for char in s:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or matching_brackets[stack.pop()] != char:\n                return False\n    \n    return len(stack) == 0\nThe is_valid_expression function takes a string s as input and checks if it is a valid expression with balanced parentheses and brackets. It uses a stack data structure to keep track of the opening brackets encountered so far. For every character in the string, it performs the following actions:\nIf the character is an opening bracket ('(' or '['), it is added to the stack.\nIf the character is a closing bracket (')' or ']'), it checks if the stack is empty or if the corresponding opening bracket for"
    },
    {
        "Input": "Write a program to find the maximum product of three integers in a given list.",
        "Output": "Certainly! Here's an implementation of a program in Python to find the maximum product of three integers in a given list:\npython\nCopy code\ndef maximum_product_of_three(nums):\n    nums.sort()\n    n = len(nums)\n    # Two negative numbers and one positive number could yield the maximum product\n    option1 = nums[0] * nums[1] * nums[n - 1]\n    # Three positive numbers yield the maximum product\n    option2 = nums[n - 3] * nums[n - 2] * nums[n - 1]\n    \n    return max(option1, option2)\nThe maximum_product_of_three function takes a list of integers nums as input and finds the maximum product of three integers from the list. It starts by sorting the list in ascending order. Then, it considers two possible options:\noption1: Multiplying the first two numbers (smallest) with the last number (largest). This accounts for the case when the maximum product involves two negative numbers and one positive number.\noption2: Multiplying the last three numbers (largest). This accounts for the case when the maximum product involves three positive"
    },
    {
        "Input": "Create a program to generate all possible permutations of a given list of distinct integers.",
        "Output": "Sure! Here's an implementation of a program in Python to generate all possible permutations of a given list of distinct integers using recursion:\npython\nCopy code\ndef permutations(nums):\n    result = []\n    generate_permutations(nums, [], result)\n    return result\n\ndef generate_permutations(nums, current_permutation, result):\n    if not nums:\n        result.append(current_permutation)\n    else:\n        for i in range(len(nums)):\n            new_permutation = current_permutation + [nums[i]]\n            remaining_nums = nums[:i] + nums[i+1:]\n            generate_permutations(remaining_nums, new_permutation, result)\nThe permutations function takes a list of distinct integers nums as input and returns a list of all possible permutations of the integers. It initializes an empty list result to store the permutations. Then, it calls the generate_permutations function with the initial permutation current_permutation as an empty list.\nThe generate_permutations function is a helper function that uses recursion to generate all possible permutations. It takes three parameters: nums, the remaining numbers to be permuted; current_permutation, the current permutation being generated; and"
    },
    {
        "Input": "Implement a function to calculate the GCD (Greatest Common Divisor) of two numbers.",
        "Output": "Certainly! Here's an implementation of a function to calculate the Greatest Common Divisor (GCD) of two numbers using the Euclidean algorithm in Python:\npython\nCopy code\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\nThe gcd function takes two numbers a and b as input and calculates their GCD using the Euclidean algorithm. The algorithm repeatedly divides a by b and assigns the remainder to a, and assigns the original value of b to b. This process continues until b becomes zero, at which point a will be the GCD of the original a and b.\nHere's an example usage of the gcd function:\npython\nCopy code\nnum1 = 36\nnum2 = 48\nprint(gcd(num1, num2))  # Output: 12\nIn this example, we call the gcd function with the numbers"
    },
    {
        "Input": "\"Write a Python class representing a hash set and implement methods to insert, remove, and check if an element exists.\"",
        "Output": "Certainly! Here's an implementation of a Python class representing a hash set with methods to insert, remove, and check if an element exists:\npython\nCopy code\nclass HashSet:\n    def __init__(self):\n        self.capacity = 16\n        self.size = 0\n        self.buckets = [[] for _ in range(self.capacity)]\n\n    def insert(self, value):\n        bucket_index = self._hash(value)\n        bucket = self.buckets[bucket_index]\n        for i, item in enumerate(bucket):\n            if item == value:\n                return\n        bucket.append(value)\n        self.size += 1\n        if self.size >= self.capacity * 0.75:\n            self._resize()\n\n    def remove(self, value):\n        bucket_index = self._hash(value)\n        bucket = self.buckets[bucket_index]\n        for i, item in enumerate(bucket):\n            if item == value:\n                del bucket[i]\n                self.size -= 1\n                return\n\n    def contains(self, value):\n        bucket_index = self._hash(value)\n        bucket = self.buckets[bucket_index]\n        return value in bucket\n\n    def _hash(self, value):"
    },
    {
        "Input": "\"Create a program to find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right or down.\"",
        "Output": "Certainly! Here's a program that calculates the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right or down:\npython\nCopy code\ndef count_paths(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D array to store the number of paths\n    paths = [[0] * cols for _ in range(rows)]\n\n    # There is only one path to reach any cell in the first row or column\n    for i in range(rows):\n        paths[i][0] = 1\n    for j in range(cols):\n        paths[0][j] = 1\n\n    # Calculate the number of paths for each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            paths[i][j] = paths[i-1][j] + paths[i][j-1]\n\n    # Return the number of paths to reach the bottom-right corner\n   "
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces.\"",
        "Output": "Certainly! Here's an implementation of a function that checks if a given string is a valid expression with balanced parentheses, brackets, and curly braces:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    mapping = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    }\n\n    for char in expression:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n        elif char in [')', ']', '}']:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n\n    return len(stack) =="
    },
    {
        "Input": "Write a program to find the median of a list of numbers in linear time.",
        "Output": "To find the median of a list of numbers in linear time, we can use the quickselect algorithm. The quickselect algorithm is a variation of the quicksort algorithm that allows us to find the kth smallest element in a list in linear time on average.\nHere's an implementation of a function that finds the median of a list of numbers in linear time:\npython\nCopy code\nimport random\n\ndef find_median(nums):\n    if not nums:\n        return None\n\n    def partition(nums, low, high):\n        pivot_index = random.randint(low, high)\n        pivot = nums[pivot_index]\n        nums[pivot_index], nums[high] = nums[high], nums[pivot_index]\n        i = low\n        for j in range(low, high):\n            if nums[j] < pivot:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n        nums[i], nums[high] = nums[high], nums[i]\n        return i\n\n    def quickselect(nums, low, high, k):\n        if low == high:\n            return nums[low]\n        pivot_index = partition"
    },
    {
        "Input": "Create a Python class representing a binary search tree and implement methods to delete a node and find the kth smallest element.",
        "Output": "Certainly! Here's an implementation of a Python class representing a binary search tree (BST) with methods to delete a node and find the kth smallest element:\npython\nCopy code\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        if not self.root:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n\n    def _insert_recursive(self, node, val):\n        if val < node.val:\n            if not node.left:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        else:\n            if not node.right:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n\n    def delete(self, val):\n        self.root = self._delete_recursive(self.root, val)\n\n   "
    },
    {
        "Input": "Implement a function to find the longest increasing subsequence in a given list of integers.",
        "Output": "Certainly! Here's an implementation of a function to find the longest increasing subsequence in a given list of integers:\npython\nCopy code\ndef find_longest_increasing_subsequence(nums):\n    n = len(nums)\n    if n == 0:\n        return []\n\n    # Initialize an array to store the lengths of the longest increasing subsequences\n    dp = [1] * n\n\n    # Initialize an array to store the indices of the previous elements in the subsequences\n    prev = [-1] * n\n\n    # Iterate over the input list\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    # Find the index of the maximum length subsequence\n    max_len_idx = 0\n    for i in range(1, n):\n        if dp[i] > dp[max_len_idx]:\n            max_len_idx = i\n\n    # Build the longest increasing subsequence\n    lis = []\n    curr_idx = max_len_idx\n    while curr_idx != -1:\n        lis.append(nums[curr_idx])\n        curr_idx = prev[curr_idx]\n\n    # Reverse the subsequence to get the correct order\n    lis.reverse()\n\n    return lis"
    },
    {
        "Input": "Write a program to calculate the factorial of a given non-negative integer using recursion.",
        "Output": "Certainly! Here's a program that calculates the factorial of a given non-negative integer using recursion:\npython\nCopy code\ndef factorial(n):\n    # Base case: factorial of 0 or 1 is 1\n    if n == 0 or n == 1:\n        return 1\n\n    # Recursive case: factorial of n is n multiplied by factorial of (n-1)\n    return n * factorial(n-1)\nHere's an example of how to use the function:\npython\nCopy code\nn = 5\nresult = factorial(n)\nprint(f\"The factorial of {n} is {result}\")  # Output: The factorial of 5 is 120\nIn this example, the function factorial takes a non-negative integer n"
    },
    {
        "Input": "\"Create a program to find the number of islands in a 2D grid, where '1' represents land and '0' represents water.\"",
        "Output": "Certainly! Here's a program that finds the number of islands in a 2D grid using depth-first search (DFS):\npython\nCopy code\ndef numIslands(grid):\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n\n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != '1':\n            return\n\n        grid[row][col] = '0'\n\n        dfs(row+1, col)\n        dfs(row-1, col)\n        dfs(row, col+1)\n        dfs(row, col-1)\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n\n    return count\nHere's an example of how to use the function:\npython\nCopy code\ngrid = [\n    ['1', '1', '0', '0', '0'],\n    ['1', '1', '0', '0', '0'],\n    ['0', '0', '1', '0', '0'],"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, and quotes.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, and quotes, we can use a stack data structure. Here's an implementation in Python:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_brackets = \"([{\"\n    closing_brackets = \")]}\"\n    quote_chars = \"'\\\"\"\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or opening_brackets.index(stack.pop()) != closing_brackets.index(char):\n                return False\n        elif char in quote_chars:\n            if not stack or stack[-1] != char:\n                stack.append(char)\n            else:\n                stack.pop()\n    \n    return len(stack) == 0\nHere's an example of how to use the function:\npython\nCopy code\nexpression = \"(3 + 5) * [2 - 4]\"\nresult = is_valid_expression(expression)\nprint(f\"The expression is valid: {result}\")  # Output: The expression is valid: True\n\ninvalid_expression = \"{(2 + 3) * \\\"Hello\\\"}\"\nresult"
    },
    {
        "Input": "Write a Python class representing a stack and implement methods to find the minimum element in constant time and retrieve the maximum element in logarithmic time.",
        "Output": "Sure! Here's a Python class representing a stack with methods to find the minimum element in constant time and retrieve the maximum element in logarithmic time:\npython\nCopy code\nclass Stack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n        self.max_stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n        if not self.min_stack or value <= self.min_stack[-1]:\n            self.min_stack.append(value)\n\n        if not self.max_stack or value >= self.max_stack[-1]:\n            self.max_stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            return None\n\n        value = self.stack.pop()\n\n        if value == self.min_stack[-1]:\n            self.min_stack.pop()\n\n        if value == self.max_stack[-1]:\n            self.max_stack.pop()\n\n        return value\n\n    def top(self):\n        if not self.stack:\n            return None\n\n        return self.stack[-1]\n\n    def get_min(self):\n        if not self.min_stack:\n            return None\n\n        return self.min_stack[-1]\n\n    def get_max(self):\n        if not self.max_stack:\n            return None\n\n        return self.max_stack[-1]\nHere's an example of how to use the Stack class:\npython\nCopy code\nstack = Stack()\nstack.push("
    },
    {
        "Input": "Create a program to find the median of two sorted arrays of different sizes.",
        "Output": "To find the median of two sorted arrays of different sizes, you can merge the two arrays into a single sorted array and then calculate the median based on the length of the merged array. Here's a Python program that implements this approach:\npython\nCopy code\ndef find_median(nums1, nums2):\n    merged = merge_sorted_arrays(nums1, nums2)\n    length = len(merged)\n    \n    if length % 2 == 0:\n        mid = length // 2\n        return (merged[mid-1] + merged[mid]) / 2\n    else:\n        mid = length // 2\n        return merged[mid]\n    \ndef merge_sorted_arrays(nums1, nums2):\n    merged = []\n    i = j = 0\n    \n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    \n    while i < len(nums1):\n        merged.append(nums1[i])\n        i += 1\n    \n    while j < len(nums2):\n        merged.append(nums2[j])\n        j += 1\n    \n    return merged\n\n#"
    },
    {
        "Input": "Implement a function to check if a given number is a narcissistic number.",
        "Output": "A narcissistic number, also known as an Armstrong number, is a number that is equal to the sum of its own digits raised to the power of the number of digits. For example, 153 is a narcissistic number because 1^3 + 5^3 + 3^3 = 153.\nHere's a Python function that checks if a given number is a narcissistic number:\npython\nCopy code\ndef is_narcissistic_number(num):\n    num_str = str(num)\n    num_digits = len(num_str)\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    return"
    },
    {
        "Input": "\"Write a program to find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right, down, or diagonally.\"",
        "Output": "To find the number of paths from the top-left corner to the bottom-right corner of a grid, moving only right, down, or diagonally, we can use a dynamic programming approach. Here's a Python program that implements this:\npython\nCopy code\ndef count_paths(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D table to store the number of paths to reach each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # There is always one way to reach the top-left corner\n    dp[0][0] = 1\n\n    # Fill the table bottom-up\n    for i in range(rows):\n        for j in range(cols):\n            # For each cell, add the number of paths from the adjacent cells\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n            if i > 0 and j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n\n    # The"
    },
    {
        "Input": "Create a Python class representing a circular doubly linked list and implement a method to delete a node at a given position.",
        "Output": "Certainly! Here's an implementation of a Python class representing a circular doubly linked list with a method to delete a node at a given position:\npython\nCopy code\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\nclass CircularDoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n\n        if not self.head:\n            self.head = new_node\n            self.head"
    },
    {
        "Input": "Implement a function to sort a list of integers using the quicksort algorithm.",
        "Output": "Certainly! Here's an implementation of the quicksort algorithm in Python:\npython\nCopy code\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        smaller = [x for x in arr[1:] if x <= pivot]\n        greater = [x for x in arr[1:] if x > pivot]\n        return quicksort(smaller) + [pivot] + quicksort(greater)\n\n\n# Example usage\nnumbers = [7, 2, 1, 6, 8, 5, 3, 4]\nsorted_numbers = quicksort(numbers)\nprint(sorted_numbers)  # Output: [1, 2, 3, 4, 5, 6, 7, 8]\nIn this implementation, the quicksort function takes a list arr as input and recursively sorts it using the quicksort algorithm.\nThe base case is when the length of the list is less than or equal to 1. In this case, the list is already sorted, so it is returned as is.\nFor lists with more than one element, a pivot is chosen (in this"
    },
    {
        "Input": "\"Write a program to find the maximum difference between two elements in a given list, with the second element appearing after the first, and the first element being smaller.\"",
        "Output": "Certainly! Here's a Python program that finds the maximum difference between two elements in a given list, where the second element appears after the first and the first element is smaller:\npython\nCopy code\ndef max_difference(arr):\n    if len(arr) < 2:\n        return None\n\n    min_value = arr[0]\n    max_diff = arr[1] - arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] - min_value > max_diff:\n            max_diff = arr[i] - min_value\n        if arr[i] < min_value:\n            min_value = arr[i]\n\n    return max_diff\n\n\n# Example usage\nnumbers = [7, 2, 5, 3, 9, 1, 6]\nresult = max_difference(numbers)\nprint(result)  # Output: 7\nIn this program, the max_difference function takes a list arr as input and iterates through the elements to find the maximum difference.\nThe program initializes two variables: min_value to store the minimum value seen so far, and max_diff to store the maximum difference found.\nThe program then iterates over the list starting from the second element. It checks if the difference between the current element and min_value is greater than the current maximum difference (max_diff). If so, it updates max_diff with the new maximum difference.\nAdditionally"
    },
    {
        "Input": "Create a program to find the largest sum of a non-empty subarray with a given target sum in a list of integers.",
        "Output": "Certainly! Here's a Python program that finds the largest sum of a non-empty subarray with a given target sum in a list of integers:\npython\nCopy code\ndef largest_subarray_sum(arr, target_sum):\n    if not arr:\n        return None\n\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n\n    while end < len(arr):\n        current_sum += arr[end]\n\n        while current_sum > target_sum and start <= end:\n            current_sum -= arr[start]\n            start += 1\n\n        if current_sum == target_sum:\n            return target_sum\n\n        if current_sum < target_sum and current_sum > max_sum:\n            max_sum = current_sum\n\n        end += 1\n\n    return max_sum if max_sum != float('-inf') else None\n\n\n# Example usage\nnumbers = [1, 2, 3, 4, 5]\ntarget = 9\nresult = largest_subarray_sum(numbers, target)\nprint(result)  # Output: 9\nIn this program, the largest_subarray_sum function takes a list arr and a target sum target_sum as input and finds the largest sum of a non-empty subarray that equals the target sum.\nThe program initializes max_sum to a very small value (`float"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, and angle brackets.\"",
        "Output": "Certainly! Here's a Python function that checks if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, and angle brackets:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening = {'(', '[', '{', '<'}\n    closing = {')', ']', '}', '>'}\n    pairs = {'()', '[]', '{}', '<>'}\n    quotes = {'\"', \"'\"}\n    quote_stack = []\n\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack or (stack[-1] + char) not in pairs:\n                return False\n            stack.pop()\n        elif char in quotes:\n            if not quote_stack:\n                quote_stack.append(char)\n            elif quote_stack[-1] == char:\n                quote_stack.pop()\n            else:\n                quote_stack.append(char)\n\n    return len(stack) == 0 and len(quote_stack) == 0\n\n\n# Example usage\nexpression1 = \"{(a+b)*[c-(d+e)]}\"\nexpression2 = \"([)]\"\nexpression3 = \"'Hello, World!'\"\nexpression4 = \"<abc>xyz</abc>\"\nexpression5 = \"<abc>xyz</def>\"\n\nprint(is_valid_expression(expression1))  # Output: True\nprint"
    },
    {
        "Input": "\"Write a Python class representing a hash map using separate chaining for collision resolution and implement methods to insert, retrieve, and remove key-value pairs.\"",
        "Output": "Certainly! Here's a Python class representing a hash map using separate chaining for collision resolution, with methods to insert, retrieve, and remove key-value pairs:\npython\nCopy code\nclass HashMap:\n    def __init__(self):\n        self.size = 10\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def insert(self, key, value):\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        for i, (existing_key, _) in enumerate(bucket):\n            if existing_key == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n\n    def retrieve(self, key):\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        for existing_key, value in bucket:"
    },
    {
        "Input": "Create a program to find the length of the longest palindromic substring in a given string.",
        "Output": "Certainly! Here's a program to find the length of the longest palindromic substring in a given string:\npython\nCopy code\ndef longest_palindromic_substring(s):\n    n = len(s)\n    if n < 2:\n        return n\n\n    start = 0\n    max_len = 1\n\n    # Helper function to expand around the center\n    def expand_around_center(left, right):\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    for i in range(n):\n        len1 = expand_around_center(i, i)  # Check for odd length palindromes\n        len2 = expand_around_center(i, i + 1)  # Check for even length palindromes\n        curr_len = max(len1, len2)\n        if curr_len > max_len:\n            max_len = curr_len\n            start = i - (curr_len - 1) // 2\n\n    return max_len\n\n\n#"
    },
    {
        "Input": "Implement a function to check if a given number is a perfect square using binary search.",
        "Output": "Certainly! Here's an implementation of a function to check if a given number is a perfect square using binary search:\npython\nCopy code\ndef is_perfect_square(num):\n    if num < 0:\n        return False\n    if num == 0 or num == 1:\n        return True\n\n    left, right = 1, num // 2\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n\n        if square == num:\n            return True\n        elif square < num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\n# Example usage\nnumber = 25\nresult = is_perfect_square(number)\nprint(f\"{number} is a perfect square: {result}\")  # Output: 25 is a perfect square: True\nIn this program, the is_perfect_square function takes an integer num as input and returns a boolean value indicating whether num is a perfect square.\nThe function first handles the"
    },
    {
        "Input": "\"Write a program to find the maximum sum path in a binary tree, where the path can start and end at any node.\"",
        "Output": "Certainly! Here's an implementation of a program to find the maximum sum path in a binary tree, where the path can start and end at any node:\npython\nCopy code\nclass TreeNode:\n    def __init__(self, value):\n        self.val = value\n        self.left = None\n        self.right = None\n\ndef max_path_sum(root):\n    max_sum = float('-inf')\n\n    def max_path_sum_helper(node):\n        nonlocal max_sum\n\n        if not node:\n            return 0\n\n        # Calculate the maximum sum path in the left and right subtrees\n        left_sum = max(0, max_path_sum_helper(node.left))\n        right_sum = max(0, max_path_sum_helper(node.right))\n\n        # Update the maximum sum if the current path is greater\n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n\n        # Return the maximum sum path that"
    },
    {
        "Input": "Create a Python class representing a directed weighted graph and implement methods to find the shortest path using Dijkstra's algorithm.",
        "Output": "Certainly! Here's an implementation of a Python class representing a directed weighted graph and implementing the Dijkstra's algorithm to find the shortest path:\npython\nCopy code\nimport heapq\n\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n\n    def add_vertex(self, vertex):\n        self.vertices[vertex] = {}\n\n    def add_edge(self, start, end,"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes.\"",
        "Output": "Certainly! Here's an implementation of a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_chars = {'(', '[', '{', '<', '\"', \"'\", '/'}\n    closing_chars = {')', ']', '}', '>', '\"', \"'\", '/'}\n    matching_chars = {'()', '[]', '{}', '<>', '\"\"', \"''\", '//'}\n    \n    for char in expression:\n        if char in opening_chars:\n            stack.append(char)\n        elif char in closing_chars:\n            if not stack:\n                return False\n            opening_char = stack.pop()\n            if opening_char + char"
    },
    {
        "Input": "Write a program to find the maximum length of a subarray with equal number of 0s and 1s in a given binary array.",
        "Output": "Certainly! Here's a program to find the maximum length of a subarray with an equal number of 0s and 1s in a given binary array:\npython\nCopy code\ndef find_max_length_subarray(arr):\n    max_length = 0\n    count = 0\n    hashmap = {0: -1}\n\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            count -= 1\n        else:\n            count += 1\n        \n        if count in hashmap:\n            max_length = max(max_length, i - hashmap[count])\n        else:\n            hashmap[count] = i\n    \n    return max_length\n\n\n# Example usage\nbinary_array = [0, 1, 0, 0, 1, 1, 0, 1, 0, 0]\nmax_length = find_max_length_subarray(binary_array)\nprint(\"Maximum length of subarray with equal number of 0s and 1s:\", max_length)\nIn this program, we iterate through the binary array and maintain a count variable to keep track of the difference between the number of 0s and 1s encountered so far. We use a hashmap to store the count values and their corresponding indices.\nWhenever we encounter a 0, we decrement the count by 1, and whenever we encounter a 1, we increment the count by"
    },
    {
        "Input": "Create a program to find the maximum sum of a non-empty subarray with a given target sum in a list of positive integers.",
        "Output": "Certainly! Here's a program to find the maximum sum of a non-empty subarray with a given target sum in a list of positive integers:\npython\nCopy code\ndef find_max_sum_subarray(arr, target_sum):\n    max_sum = 0\n    current_sum = 0\n    start = 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n\n        while current_sum > target_sum:\n            current_sum -= arr[start]\n            start += 1\n\n        if current_sum == target_sum:\n            max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\n# Example usage\nnum_list = [1, 2, 3, 4"
    },
    {
        "Input": "Implement a function to find the minimum number of characters to be added to a string to make it a palindrome.",
        "Output": "Sure! Here's an implementation of a function to find the minimum number of characters to be added to a string to make it a palindrome:\npython\nCopy code\ndef min_chars_to_make_palindrome(string):\n    if string == string[::-1]:\n        return 0\n\n    n = len(string)\n    dp = [[0] *"
    },
    {
        "Input": "Write a Python class representing a binary trie and implement methods to insert and search for binary numbers.",
        "Output": "Certainly! Here's an implementation of a Python class representing a binary trie (prefix tree) with methods to insert and search for binary numbers:\npython\nCopy code\nclass BinaryTrieNode:\n    def __init__(self):\n        self.children = [None, None]\n        self.is_end_of_number = False\n\n\nclass BinaryTrie:\n    def __init__(self):\n        self.root = BinaryTrieNode()\n\n    def insert(self, binary_number):\n        node = self.root\n        for bit in binary_number:\n            bit_index = int(bit)\n            if not node.children[bit_index]:\n                node.children[bit_index] = BinaryTrieNode()\n            node = node.children[bit_index]\n        node.is_end_of_number = True\n\n    def search(self, binary_number):\n        node = self.root\n        for bit in binary_number:\n            bit_index = int(bit)\n            if not node.children[bit_index]:\n                return False\n            node = node.children[bit_index]\n        return node.is_end_of_number\n\n\n# Example usage\ntrie = BinaryTrie()\ntrie.insert(\"1010\")\ntrie.insert(\"1101\")\ntrie.insert(\"0111\")\n\nprint(trie.search(\"1010\"))  # True\nprint(trie.search(\"1101\"))  # True\nprint(tr"
    },
    {
        "Input": "Create a program to find the longest common prefix among a list of strings.",
        "Output": "Certainly! Here's a program to find the longest common prefix among a list of strings:\npython\nCopy code\ndef longest_common_prefix(strings):\n    if not strings:\n        return \"\"\n\n    prefix = strings[0]\n    for string in strings[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n\n# Example usage\nwords = [\"apple\", \"application\", \"aptitude\", \"append\"]\ncommon_prefix = longest_common_prefix(words)\nprint(common_prefix)  # Output: \"app\"\nIn this program, we define a function longest_common_prefix that takes a list of strings as input and returns the longest common prefix among them.\nThe function first checks if the input list is empty. If it is, it returns an empty string as there is no common prefix.\nWe initialize the prefix variable with the first string in the list. Then, we iterate over the remaining strings in the list. For each string, we repeatedly remove characters from the prefix until the string no longer starts with the prefix. This ensures that the prefix remains the longest common prefix among all the strings seen so"
    },
    {
        "Input": "Implement a function to check if a given number is a palindrome in binary representation.",
        "Output": "Sure! Here's an implementation of a function to check if a given number is a palindrome in its binary representation:\npython\nCopy code\ndef is_binary_palindrome(number):\n    binary = bin(number)[2:]  # Convert number to binary representation and remove the '0b' prefix\n    reversed_binary = binary[::-1]  # Reverse the binary string\n\n    return binary == reversed_binary\n\n\n# Example usage\nprint(is_binary_palindrome(9))  # Output: True (9 in binary: 1001)\nprint(is_binary_palindrome(10))  # Output: False (10 in binary: 1010)\nprint(is_binary_palindrome(101))  # Output: True (101 in binary: 1100101)\nIn this function, we first convert the given number to its binary representation using the bin() function and remove the '0b' prefix using slicing ([2:]).\nThen, we reverse the binary string using slicing with a step of -1 (`[::-1"
    },
    {
        "Input": "Write a program to find the longest increasing subarray with equal number of 0s and 1s in a given binary array.",
        "Output": "To find the longest increasing subarray with an equal number of 0s and 1s in a given binary array, you can use a similar approach as finding the longest subarray with a target sum. Here's a program that solves this problem:\npython\nCopy code\ndef longest_increasing_subarray_with_equal_zeros_ones(arr):\n    count = 0\n    max_len = 0\n    sum_map = {0: -1}\n\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            count -= 1\n        else:\n            count += 1\n\n        if count in sum_map:\n            max_len = max(max_len, i - sum_map[count])\n        else:\n            sum_map[count] = i\n\n    return max_len\n\n\n# Example usage\nbinary_array = [0, 1, 0, 1, 1, 0, 0]\nprint(longest_increasing_subarray_with_equal_zeros_ones(binary_array))  # Output: 6\n\nbinary_array = [1,"
    },
    {
        "Input": "Create a Python class representing a circular queue and implement a method to rotate the queue by a given number of positions.",
        "Output": "Sure! Here's a Python class representing a circular queue with a method to rotate the queue by a given number of positions:\npython\nCopy code\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * self.capacity\n        self.front = self.rear = -1\n\n    def is_empty(self):\n        return self.front == -"
    },
    {
        "Input": "Implement a function to find the maximum sum subarray in a given circular array.",
        "Output": "To find the maximum sum subarray in a given circular array, we can use Kadane's algorithm. The idea is to handle two cases: one where the maximum sum subarray is within the circular range, and another where it wraps around the circular range.\nHere's the implementation of the function:\npython\nCopy code\ndef max_sum_subarray_circular(arr):\n    def kadane(arr):\n        max_sum = float('-inf')\n        curr_sum = 0\n\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    # Case 1: Maximum sum subarray within the circular range\n    max_sum_within = kadane(arr)\n\n    # Case 2: Maximum sum subarray wrapping around the circular range\n    total_sum = sum(arr)\n    for i in range(len(arr)):\n        arr[i] = -arr[i]  # Invert the sign of each element\n    max_sum_wrap = total_sum + kadane(arr)\n\n    # Return the maximum of the two cases\n    return max(max_sum_within, max_sum_wrap)\nLet's test the function with an example:\npython\nCopy code\narr = [8, -1, 3, 4]\nprint(max_sum_subarray_circular(arr))  # Output: 15\nIn the given example, the maximum"
    },
    {
        "Input": "\"Write a program to find the number of unique paths from the top-left corner to the bottom-right corner of a grid, moving only right or down, with obstacles represented as '1' in the grid.\"",
        "Output": "To find the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles, we can use dynamic programming. We'll create a 2D grid to store the number of paths for each cell.\nHere's the implementation of the program:\npython\nCopy code\ndef unique_paths_with_obstacles(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D grid to store the number of paths for each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Initialize the number of paths for the top-left corner\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n\n    # Fill the first row\n    for col in range(1, cols):\n        if grid[0][col] == 0:\n            dp[0][col] = dp[0][col - 1]\n\n    # Fill the first column\n    for row in range(1, rows):\n        if grid[row][0] == 0:\n            dp"
    },
    {
        "Input": "Implement a function to check if a given string can be segmented into a space-separated sequence of dictionary words.",
        "Output": "To check if a given string can be segmented into a space-separated sequence of dictionary words, we can use dynamic programming. We'll build a table that stores whether a substring can be segmented into dictionary words.\nHere's the implementation of the function:\npython\nCopy code\ndef word_break(s, word_dict):\n    n = len(s)\n\n    # Create a table to store whether a substring can be segmented\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\nLet's test the function with an example:\npython\nCopy code\nword_dict = {\"apple\", \"pen\", \"pineapple\"}\ns = \"applepenpineapple\"\nprint(word_break(s, word_dict))  # Output: True\n\ns = \"pineapplepenapple\"\nprint(word_break(s, word_dict))  # Output: True\n\ns = \"catsandog\""
    },
    {
        "Input": "Write a program to find the longest word in a given dictionary that can be constructed by deleting characters from a given string.",
        "Output": "To find the longest word in a given dictionary that can be constructed by deleting characters from a given string, we can iterate over each word in the dictionary and check if it can be formed by deleting characters from the given string. We'll keep track of the longest word found so far.\nHere's the implementation of the program:\npython\nCopy code\ndef longest_word(dictionary, s):\n    longest = \"\"\n    for word in dictionary:\n        if is_subsequence(word, s) and len(word) > len(longest):\n            longest = word\n    return longest\n\ndef is_subsequence(word, s):\n    i, j = 0, 0\n    while i < len(word) and j < len(s):\n        if word[i] == s[j]:\n            i += 1\n        j += 1\n    return i == len(word)\nLet's test the program with an example:\npython\nCopy code\ndictionary = [\"cat\", \"bat\", \"rat\", \"apple\", \"banana\", \"car\"]\ns = \"cattar\"\n\nprint(longest_word(dictionary, s))  # Output: \"cat"
    },
    {
        "Input": "Create a Python class representing a Sudoku solver and implement methods to solve a given Sudoku puzzle.",
        "Output": "Certainly! Here's a Python class representing a Sudoku solver with a method to solve a given Sudoku puzzle using a backtracking algorithm:\npython\nCopy code\nclass SudokuSolver:\n    def solve(self, board):\n        # Helper function to check if a value can be placed at a given position\n        def is_valid(board, row, col, num):\n            # Check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n\n            # Check column\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n\n            # Check 3x3 subgrid\n            start_row = (row // 3) * 3\n            start_col = (col // 3) * 3\n            for i in range(3):\n                for j in range(3):\n                    if board[start_row + i][start_col + j] == num:\n                        return False\n\n            return True\n\n        # Helper function to find an empty cell in the board\n        def find_empty_cell(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n\n        # Recursive function to solve the Sudoku puzzle\n       "
    },
    {
        "Input": "Implement a function to generate all possible combinations of k distinct integers from a given list of integers.",
        "Output": "Certainly! Here's an implementation of a function to generate all possible combinations of k distinct integers from a given list of integers:\npython\nCopy code\ndef generate_combinations(nums, k"
    },
    {
        "Input": "Write a program to find the largest rectangular area of 1s in a binary matrix.",
        "Output": "To find the largest rectangular area of 1s in a binary matrix, you can use the approach based on the largest rectangle in histogram problem. Here's a program that implements this approach:\npython\nCopy code\ndef largest_rectangle_area(matrix):\n    if not matrix:\n        return 0\n\n    heights = [0] * len(matrix[0])\n    max_area = 0\n\n    for row in matrix:\n        for i, val in enumerate(row):\n            # Update the heights array based on the current row\n            if val == 1:\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        # Find the largest rectangle area in the current row\n        max_area = max(max_area, largest_rectangle_in_histogram(heights))\n\n    return max_area\n\n\ndef largest_rectangle_in_histogram(heights):\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i if not stack else i"
    },
    {
        "Input": "\"Create a program to find the number of distinct islands in a 2D grid, where islands are defined by connected regions of '1's.\"",
        "Output": "To find the number of distinct islands in a 2D grid, where islands are defined by connected regions of '1's, you can use a depth-first search (DFS) approach along with a set to keep track of the distinct islands. Here's a program that implements this:\npython\nCopy code\ndef num_distinct_islands(grid):\n    if not grid or not grid[0]:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    distinct_islands = set()\n\n    def dfs(row, col, island, direction):\n        if (\n            0 <= row < rows\n            and 0 <= col < cols\n            and grid[row][col] == 1\n        ):\n            grid[row][col] = 0\n            island.append(direction)\n            dfs(row + 1, col, island, 'D')\n            dfs(row - 1, col, island, 'U')\n            dfs(row, col + 1, island, 'R')\n            dfs(row, col - 1, island, 'L')\n            island.append('B')  # Backtrack\n\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1:\n               "
    },
    {
        "Input": "Implement a function to check if a given number is a prime number using the Miller-Rabin primality test.",
        "Output": "Sure! Here's an implementation of the Miller-Rabin primality test in Python to check if a given number is a prime number:\npython\nCopy code\nimport random\n\ndef is_prime(n, k=5):\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Write n - 1 as 2^r * d\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n\n    # Perform Miller-Rabin primality test k times\n    for _ in range(k):\n        a = random.randint(2, n - 2)\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n           "
    },
    {
        "Input": "Write a Python class representing a weighted directed acyclic graph and implement methods to find the shortest path using the Bellman-Ford algorithm.",
        "Output": "Certainly! Here's a Python class representing a weighted directed acyclic graph and implementing the Bellman-Ford algorithm to find the shortest path from a source vertex to all other vertices:\npython\nCopy code\nclass WeightedDAG:\n    def __init__(self, num_vertices):\n        self.num_vertices = num_vertices\n        self.edges = []\n\n    def add_edge(self, source, destination, weight):\n        self.edges.append((source, destination, weight))\n\n    def bellman_ford(self, source):\n        # Step 1: Initialize distance to all vertices as infinity except the source vertex\n        distance = [float('inf')] * self.num_vertices\n        distance[source] = 0\n\n        # Step 2: Relax edges repeatedly (V - 1) times\n        for _ in range(self.num_vertices - 1):\n            for u, v, w in self.edges:\n                if distance[u] != float('inf') and distance[u] + w < distance[v]:\n                    distance[v] = distance[u] + w\n\n        # Step 3: Check for negative-weight cycles\n        for u, v, w in self.edges:\n            if distance[u] != float('inf') and distance[u] + w < distance[v]:\n                return \"Graph contains negative-weight cycles\"\n\n        return distance\n\n# Example usage:\ngraph = WeightedDAG(6)\ngraph.add_edge"
    },
    {
        "Input": "Create a program to generate all possible valid IP addresses from a given string of digits.",
        "Output": "Sure! Here's a program in Python to generate all possible valid IP addresses from a given string of digits:\npython\nCopy code\ndef restore_ip_addresses(s):\n    def backtrack(s, start, path, result):\n        # Base case: if we have 4 segments and used all digits in s\n        if len(path) == 4 and start == len(s):\n            result.append(\".\".join(path))\n            return\n\n        # If we have 4 segments but still have digits left in s, return\n        if len(path) == 4 or start == len(s):\n            return\n\n        # Try all possible segment lengths (1, 2, 3)\n        for length in range(1, 4):\n            # Ignore segments starting with '0' if length > 1\n            if length > 1 and s[start] == '0':\n                continue\n\n            # Extract the current segment from s\n            segment = s[start:start+length]\n            # Check if the segment is a valid IP segment (0 <= segment <= 255)\n            if int(segment) <= 255:\n                # Recursively backtrack with the next start index and updated path\n                backtrack(s, start+length, path + [segment], result)"
    },
    {
        "Input": "Implement a function to count the number of inversions in a given list of integers.",
        "Output": "Certainly! Here's an implementation of a function to count the number of inversions in a given list of integers:\npython\nCopy code\ndef count_inversions(nums):\n    # Helper function to merge two sorted lists and count inversions\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n\n        # Append the remaining elements from the unfinished list\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    # Base case: if the list has zero or one element, no inversions\n    if len(nums) <= 1:\n        return nums, 0\n\n    # Divide the list into two halves\n    mid = len(nums) // 2\n    left, inv_left = count_inversions(nums[:mid])\n    right, inv_right = count_inversions(nums[mid:])\n\n    # Merge the sorted halves and count inversions\n    merged, inv_merge = merge(left, right)\n\n    # Return the merged list and the sum of inversions"
    },
    {
        "Input": "Write a program to find the maximum subarray product in a given list of integers.",
        "Output": "Certainly! Here's an implementation of a function to find the maximum subarray product in a given list of integers:\npython\nCopy code\ndef max_subarray_product(nums):\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    curr_max = nums[0]\n    curr_min = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            curr_max, curr_min = curr_min, curr_max\n\n        curr_max = max(nums[i], curr_max * nums[i])\n        curr_min = min(nums[i], curr_min * nums[i])\n\n        max_product = max(max_product, curr_max)\n\n    return max_product\n\n\n# Example usage:\nnums = [2, 3, -2, 4]\nmax_product = max_subarray_product(nums)\nprint(\"Maximum subarray product:\", max_product)\nOutput:\nyaml\nCopy code\nMaximum subarray product: 6\nIn this program, the max_subarray_product function takes a list of integers nums as input and returns the maximum subarray product.\nThe function uses a dynamic programming approach to keep track of the current maximum and minimum product at each index. It iterates through the list, updating the current maximum and minimum based on the current element and the previous maximum and minimum. If the current element is negative, the current maximum and minimum are swapped since multiplying by a negative number can result in a"
    },
    {
        "Input": "Create a Python class representing a radix tree (trie) and implement methods to insert and search for strings.",
        "Output": "Certainly! Here's an implementation of a Python class representing a radix tree (trie) with methods to insert and search for strings:\npython\nCopy code\nclass RadixTree:\n    class Node:\n        def __init__(self, char):\n            self.char = char\n            self.children = {}\n            self.is_word_end = False\n\n    def __init__(self):\n        self.root = self.Node(\"\")\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char in current_node.children:\n                current_node = current_node.children[char]\n            else:\n                new_node = self.Node(char)\n                current_node.children[char] = new_node\n                current_node = new_node\n        current_node.is_word_end = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char in current_node.children:\n                current_node = current_node.children[char]\n            else:\n                return False\n        return current_node.is_word_end\nExample usage:\npython\nCopy code\n# Create a radix tree\ntree = RadixTree()\n\n# Insert words\ntree.insert(\"apple\")\ntree.insert(\"banana\")\ntree.insert(\"orange\")\n\n# Search for words\nprint(tree.search(\"apple\"))  # True\nprint(tree.search(\"banana\"))  # True\nprint(tree.search(\"orange\"))  # True"
    },
    {
        "Input": "Implement a function to check if a given binary tree is a valid binary search tree.",
        "Output": "Certainly! Below is an example implementation of a function in Python to check if a given binary tree is a valid binary search tree:\npython\nCopy code\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def helper(node, lower=float('-inf'), upper=float('inf')):\n        if not node:\n            return True\n        \n        val = node.val\n        if val <= lower or val >= upper:\n            return False\n        \n        if not helper(node.right, val, upper):\n            return False\n        \n        if not helper(node.left, lower, val):\n            return False\n        \n        return True\n\n    return helper(root)\nThis implementation uses a recursive helper function to traverse the binary tree and check if each node's value is within the acceptable range. The range is defined by the lower and upper bounds, which initially start as negative infinity and positive infinity, respectively.\nFor each node, we compare its value with the lower and upper bounds. If the value is less than or equal to the lower bound or greater than or equal to the upper bound, it violates the binary search tree property, and we return False.\nWe"
    },
    {
        "Input": "Write a program to find the longest path in a tree from a given node to any other node.",
        "Output": "To find the longest path in a tree from a given node to any other node, we can use a depth-first search (DFS) algorithm. Here's an example implementation in Python:\npython\nCopy code\nclass TreeNode:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children else []\n\ndef longest_path(root):\n    if not root:\n        return 0\n    \n    def dfs(node, path_length):\n        nonlocal max_length\n        \n        if not node.children:\n            max_length = max(max_length, path_length)\n        \n        for child in node.children:\n            dfs(child, path_length + 1)\n\n    max_length = 0\n    dfs(root, 0)\n    return max_length\nIn this implementation, we define"
    },
    {
        "Input": "Create a program to find the kth smallest element in a matrix sorted by rows and columns.",
        "Output": "To find the kth smallest element in a matrix sorted by rows and columns, we can use a min-heap data structure. Here's an example implementation in Python:\npython\nCopy code\nimport heapq\n\ndef kth_smallest(matrix, k):\n    if not matrix or k < 1:\n        return None\n    \n    m, n = len(matrix), len(matrix[0])\n    min_heap = []\n    \n    for i in range(min(k, m)):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n    \n    while k > 0:\n        element, row, col = heapq.heappop(min_heap)\n        \n        if col < n - 1:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n        \n       "
    },
    {
        "Input": "Implement a function to calculate the Levenshtein distance between two strings.",
        "Output": "Certainly! The Levenshtein distance is a measure of the minimum number of operations (insertions, deletions, or substitutions) required to transform one string into another. Here's an example implementation of a function to calculate the Levenshtein distance between two strings in Python:\npython\nCopy code\ndef levenshtein_distance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    \n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n"
    },
    {
        "Input": "Write a Python class representing a bloom filter and implement methods to insert and check if an element exists.",
        "Output": "Certainly! Below is an example implementation of a Bloom Filter class in Python, including methods to insert elements and check if an element exists:\npython\nCopy code\nimport mmh3\nfrom bitarray import bitarray\n\nclass BloomFilter:\n    def __init__(self, size, num_hash_functions):\n        self.size = size\n        self.num_hash_functions = num_hash_functions\n        self.bit_array = bitarray(size)\n        self.bit_array.setall(0)\n\n    def insert(self, element):\n        for seed in range(self.num_hash_functions):\n            index = mmh3.hash(element, seed) % self.size\n            self.bit_array[index] = 1\n\n    def contains(self, element):\n        for seed in range(self.num_hash_functions):\n            index = mm"
    },
    {
        "Input": "Create a program to find the maximum number of overlapping intervals in a given list of intervals.",
        "Output": "To find the maximum number of overlapping intervals in a given list of intervals, we can use the concept of sweep line algorithm. Here's an example implementation in Python:\npython\nCopy code\ndef find_max_overlapping_intervals(intervals):\n    if not intervals:\n        return 0\n    \n    events = []\n    for start, end in intervals:\n        events.append((start, 1))\n        events.append((end, -1))\n    \n    events.sort()\n    \n    max_overlaps = 0\n    curr_overlaps = 0\n    for _, event in events:\n        curr_overlaps += event\n        max_overlaps = max(max_overlaps, curr_overlaps)\n    \n    return max_overlaps\nIn this implementation, the `find"
    },
    {
        "Input": "Implement a function to check if a given number is a power of three.",
        "Output": "To check if a given number is a power of three, we can use the logarithmic property of powers. Here's an example implementation in Python:\npython\nCopy code\nimport math\n\ndef is_power_of_three(n):\n    if n <= 0:\n        return False\n    \n    power = math.log(n, 3)\n    return math.isclose(power, round(power))\nIn this implementation, the is_power_of_three function takes a number n as input and returns True if n is a power of three, and False otherwise.\nFirst, we handle the base case where n is less than or equal to 0. In this case, we return False since powers of three are always positive.\nWe then calculate the logarithm of n to the base 3 using"
    },
    {
        "Input": "Write a program to find the longest palindromic substring with at most K distinct characters in a given string.",
        "Output": "To find the longest palindromic substring with at most K distinct characters in a given string, we can use a sliding window approach. Here's an example implementation in Python:\npython\nCopy code\ndef longest_palindromic_substring_with_k_distinct(s, k):\n    if not s or k < 1:\n        return \"\"\n    \n    start = 0\n    max_length = 0\n    max_substring = \"\"\n    char_count = {}\n    \n    for end in range(len(s)):\n        right_char = s[end]\n        char_count[right_char] = char_count.get(right_char, 0) + 1\n        "
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions, we can use a stack-based approach. Here's an example implementation of the function in Python:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_brackets = \"({[\"\n    closing_brackets = \")}]\"\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            last_opening = stack.pop()\n            if opening_brackets.index(last_opening) != closing_brackets.index(char):\n                return False\n\n    return len(stack) == 0\nIn this implementation, the is_valid_expression function takes a string `expression"
    },
    {
        "Input": "Write a program to find the number of ways to divide a string into two non-empty palindromic substrings.",
        "Output": "To find the number of ways to divide a string into two non-empty palindromic substrings, we can use a dynamic programming approach. Here's an example implementation in Python:\npython\nCopy code\ndef count_palindromic_divisions(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize base cases\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build the dp table\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                # Check if the inner substring is already a palindrome\n                if length == 2 or dp[i"
    },
    {
        "Input": "Create a program to find the maximum number of non-overlapping intervals in a given list of intervals.",
        "Output": "To find the maximum number of non-overlapping intervals in a given list of intervals, we can use a greedy algorithm based on sorting the intervals by their end points. Here's an example implementation in Python:\npython\nCopy code\ndef find_max_non_overlapping_intervals(intervals):\n    if not intervals:\n        return 0\n\n    # Sort intervals by end points\n    intervals.sort(key=lambda x: x[1])\n\n    count = 1\n    end = intervals[0][1]\n\n    for interval in intervals[1:]:\n        start = interval[0]\n        if"
    },
    {
        "Input": "Implement a function to generate the next permutation of a given list of integers in lexicographic order.",
        "Output": "To generate the next permutation of a given list of integers in lexicographic order, we can use the following algorithm:\nStart from the rightmost element of the list and find the first pair of adjacent elements where the left element is smaller than the right element. Let's call the index of the left element i.\nIf no such pair exists, it means the given permutation is the last permutation in lexicographic order. In this case, we return the list in ascending order, representing the first permutation.\nIf a pair is found, we need to find the smallest element to the right of the left element that is greater than the left element. Let's call the index of this element j.\nSwap the elements at indices i and j."
    },
    {
        "Input": "Write a Python class representing a red-black tree and implement methods to insert and search for nodes.",
        "Output": "Implementing a complete Red-Black Tree with insertion and search methods is a complex task and beyond the scope of a single response. However, I can provide you with an overview of the concept and a simplified implementation of a Red-Black Tree in Python.\nRed-Black Tree is a self-balancing binary search tree that maintains balance using specific coloring and rotation rules. Here's an example implementation of a simplified Red-Black Tree class with insertion and search methods:\npython\nCopy code\nclass RedBlackTree:\n    class Node:\n        def __init__(self, key):\n            self.key = key\n            self.parent = None\n            self.left = None\n            self.right = None\n            self.color = \"RED\"  # All new nodes are initially colored red\n\n    def __init__(self):\n       "
    },
    {
        "Input": "Create a program to find the longest common subsequence of three given strings.",
        "Output": "To find the longest common subsequence (LCS) of three given strings, we can use a dynamic programming approach. Here's an example implementation of the program in Python:\npython\nCopy code\ndef longest_common_subsequence(str1, str2, str3):\n    m, n, p = len(str1), len(str2), len(str3)\n    dp = [[[0] * (p + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if"
    },
    {
        "Input": "Implement a function to check if a given number is a power of four.",
        "Output": "To check if a given number is a power of four, we can use the following approach:\nCheck if the number is greater than zero.\nCheck if the number is a power of two by verifying that it has only one bit set in its binary representation. We can use the bitwise AND operation (&) with the number and its predecessor (num & (num - 1)). If the result is zero, the number is a power of two.\nCheck if the number minus one (num - 1) is"
    },
    {
        "Input": "\"Write a program to find the minimum number of coins needed to make a given amount of change, with a limited supply of each coin denomination.\"",
        "Output": "To find the minimum number of coins needed to make a given amount of change, we can use a dynamic programming approach known as the \"Coin Change\" problem. Here's an example implementation of the program in Python:\npython\nCopy code\ndef min_coins(coins, amount):\n    # Initialize a table to store the minimum number of coins needed for each amount\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n   "
    },
    {
        "Input": "Create a Python class representing a suffix array and implement methods to search for substrings.",
        "Output": "Implementing a complete Suffix Array class with substring search methods is a complex task and beyond the scope of a single response. However, I can provide you with an overview of the concept and a simplified implementation of a Suffix Array class in Python.\nA Suffix Array is a data structure that stores all the suffixes of a given string in sorted order. It allows efficient substring searching by performing binary search operations on the suffixes.\nHere's an example implementation of a simplified Suffix Array class with substring search methods:\npython\nCopy code\nclass SuffixArray:\n    def __init__(self, string):\n        self.string = string\n        self.s"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions, we can use a stack-based approach. Here's an example implementation of the function in Python:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_chars = {'(', '[', '{', '<', '\"', \"'\", '/'}\n    closing_chars = {')': '(', ']': '[', '}': '{', '>': '<', '\"': '\"', \"'\": \"'\", '/': '/'}\n    nested_chars = {'\"', \"'\", '/'}\n\n    for char in expression:\n        if char in opening_chars:\n            stack.append(char)\n        elif char in closing_chars:\n            if len(stack) == 0 or stack[-1] != closing_chars[char]:\n               "
    },
    {
        "Input": "Write a program to find the length of the longest palindromic subsequence in a given string.",
        "Output": "To find the length of the longest palindromic subsequence in a given string, we can use a dynamic programming approach. Here's an example implementation of the program in Python:\npython\nCopy code\ndef longest_palindromic_subsequence(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    # All individual characters are palindromes of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the table diagonally\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max"
    },
    {
        "Input": "Create a program to find the maximum sum of non-overlapping subarrays in a given list of integers.",
        "Output": "To find the maximum sum of non-overlapping subarrays in a given list of integers, we can use a dynamic programming approach. Here's an example implementation of the program in Python:\npython\nCopy code\ndef max_sum_non_overlapping_subarrays(nums, k):\n    n = len(nums)\n    if n < k:\n        return 0\n\n    # Calculate prefix sums\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    # Calculate the maximum sum of non-overlapping subarrays\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        if i >= k:\n            dp[i] = max(dp[i], dp"
    },
    {
        "Input": "Implement a function to find the median of a stream of integers in constant time and space complexity.",
        "Output": "To find the median of a stream of integers in constant time and space complexity, we can use two heaps: a max-heap to store the smaller half of the numbers and a min-heap to store the larger half. By maintaining these heaps, we can efficiently find the median.\nHere's an example implementation of the function in Python:\npython\nCopy code\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n       "
    },
    {
        "Input": "Write a Python class representing a disjoint-set data structure and implement methods to perform union and find operations.",
        "Output": "Certainly! Here's an example implementation of a disjoint-set data structure in Python:\npython\nCopy code\nclass DisjointSet:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            # Path compression\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n\n        if root_x == root_y:\n            return\n\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self"
    },
    {
        "Input": "Implement a function to check if a given number is a power of two using bitwise operations.",
        "Output": "Certainly! Here's an example implementation of a function to check if a given number is a power of two using bitwise operations in Python:\npython\nCopy code\ndef is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\n# Example usage:\nnum = 16\nresult = is_power_of_two(num)\nprint(result)  # Output: True\n\nnum = 10\nresult = is_power_of_two(num)\nprint(result)  # Output: False\nIn this implementation, the is_power_of_two function takes an integer n as input and uses bitwise operations to check if it is a power of two.\nThe condition (n & (n - 1)) == 0 checks if n and `n -"
    },
    {
        "Input": "Write a program to find the longest increasing subarray with at most K distinct integers in a given list of integers.",
        "Output": "To find the longest increasing subarray with at most K distinct integers in a given list of integers, we can use a sliding window approach. Here's an example implementation of the program in Python:\npython\nCopy code\ndef longest_increasing_subarray(nums, k):\n    if k <= 0:\n        return []\n\n    start = 0\n    max_length = 0\n    distinct_count = 0\n    distinct_integers = {}\n\n    for end in range(len(nums)):\n        distinct_integers[nums[end]] = distinct_integers.get(nums[end], 0) + 1\n\n        while distinct_count > k:\n            distinct_integers[nums[start]] -= 1\n            if distinct_integers[nums[start]] == 0:\n               "
    },
    {
        "Input": "\"Implement a function to find the number of ways to decode a given string, where each letter is mapped to a number (A=1, B=2, etc.).\"",
        "Output": "To find the number of ways to decode a given string, where each letter is mapped to a number (A=1, B=2, etc.), we can use dynamic programming. Here's an example implementation of the function in Python:\npython\nCopy code\ndef num_decodings(s):\n    n = len(s)\n    if n == 0 or s[0] == '0':\n        return 0\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        two_digit"
    },
    {
        "Input": "Write a program to find the maximum sum of a subsequence with the constraint that no two elements in the subsequence are adjacent.",
        "Output": "To find the maximum sum of a subsequence with the constraint that no two elements in the subsequence are adjacent, we can use dynamic programming. Here's an example implementation of the program in Python:\npython\nCopy code\ndef max_sum_subsequence(arr):\n    n = len(arr)\n\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return arr[0]\n\n    dp = [0] * n\n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-"
    },
    {
        "Input": "\"Create a program to find the number of islands in a 2D grid, where islands are defined by connected regions of '1's, but diagonal connections are not considered.\"",
        "Output": "To find the number of islands in a 2D grid, where islands are defined by connected regions of '1's (horizontally or vertically), but diagonal connections are not considered, we can use Depth-First Search (DFS) algorithm. Here's an example implementation of the program in Python:\npython\nCopy code\ndef num_islands(grid):\n    if not grid or not grid[0]:\n        return 0\n\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n    count = 0\n\n    def dfs(row, col"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators, we can use a stack data structure. Here's an example implementation of the function in Python:\npython\nCopy code\ndef is_valid_expression(s):\n    stack = []\n    opening_brackets = {'(', '[', '{'}\n    closing_brackets = {')', ']', '}'}\n    matching_brackets = {'(': ')', '[': ']', '{': '}'}\n\n    for char in s:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or matching_brackets[stack.pop()] != char:\n                return False\n\n    return len(stack) == 0\n\n# Example usage:\nexpression"
    },
    {
        "Input": "Write a Python class representing a segment tree and implement methods to update values and query for range sums.",
        "Output": "Certainly! Here's a Python class representing a segment tree with methods to update values and query for range sums:\npython\nCopy code\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.construct_tree(arr, 0, self.n - 1, 0)\n\n    def construct_tree(self, arr, start, end, index):\n        if start == end:\n            self.tree[index] = arr[start]\n            return\n\n        mid = (start + end) // 2\n        self.construct_tree(arr, start, mid, 2 * index + 1)\n        self.construct_tree(arr, mid + 1, end, 2 * index + 2)\n        self.tree[index]"
    },
    {
        "Input": "Create a program to find the minimum number of swaps required to sort a given list of integers.",
        "Output": "To find the minimum number of swaps required to sort a given list of integers, we can use the concept of graph cycles. Each cycle represents a set of elements that need to be swapped to reach the sorted order. Here's an example implementation of the program in Python:\npython\nCopy code\ndef min_swaps(arr):\n   "
    },
    {
        "Input": "Implement a function to find the longest common subsequence of two given strings.",
        "Output": "Certainly! Here's an example implementation of a function to find the longest common subsequence of two given strings in Python:\npython\nCopy code\ndef longest_common_subsequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n\n    # Create a table to store the lengths of the longest common subsequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill the table bottom-up\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j"
    },
    {
        "Input": "\"Write a program to find the number of arithmetic slices in a given list of integers, where an arithmetic slice is a contiguous subarray with at least three elements having the same difference.\"",
        "Output": "Certainly! Here's an example implementation of a program"
    },
    {
        "Input": "Create a Python class representing a B-tree and implement methods to insert and search for nodes.",
        "Output": "Sure! Here's an example implementation of a B-tree class in Python with methods to insert and search for nodes:\npython\nCopy code\nclass BTreeNode:\n    def __init__(self, leaf=False):\n        self.keys = []\n        self.child = []\n        self.leaf = leaf\n\n    def insert_non_full(self, key):\n        i = len(self.keys) - 1\n        if self.leaf:\n            self.keys.append(None)\n            while i >= 0 and key < self.keys[i]:\n                self.keys[i + 1] = self.keys[i]\n                i -= 1\n            self.keys[i + 1] = key\n        else:\n            while i >= 0 and key < self.keys[i]:\n                i -= 1\n            if len(self.child[i +"
    },
    {
        "Input": "Implement a function to check if a given number is a power of any other number.",
        "Output": "Certainly! Here's an example implementation of a function to check if a given number is a power of any other number in Python:\npython\nCopy code\ndef is_power_of(num, base):\n    if num <= 0 or base <= 1:\n        return False\n\n    power = 1\n    while power < num:\n        power *= base\n\n    return power == num\n\n# Example usage:\nnum = 16\nbase = 2\nresult = is_power_of(num, base)\nprint(result)  # Output: True\n\nnum = 27\nbase = 3\nresult = is_power_of(num, base)\nprint(result)  # Output: True\n\nnum = 10\nbase = 2\nresult = is_power_of(num, base)\nprint(result)  # Output: False\nIn"
    },
    {
        "Input": "\"Write a program to find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent, and the subarray can wrap around the end of the list.\"",
        "Output": "Sure! Here's an example program in Python that finds the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent, and the subarray can wrap around the end of the list:\npython\nCopy code\ndef max_sum_no_adjacent(arr):\n    n = len(arr)\n\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return arr[0]\n\n    # Calculate maximum sum without wrapping\n    max_sum = max(arr[0], arr[1])\n    prev_max_sum = arr[0]\n\n    for i in range(2, n):\n        curr_max_sum = max(prev_max_sum + arr[i], max_sum"
    },
    {
        "Input": "Implement a function to calculate the Fibonacci sequence up to a given number using dynamic programming.",
        "Output": "Certainly! Here's an example implementation of a function to calculate the Fibonacci sequence up to a given number using dynamic programming in Python:\npython\nCopy code\ndef fibonacci(n):\n    if n <= 0:\n        return []\n\n    fib = [0, 1]  # Initialize the Fibonacci sequence with the base cases\n\n    while fib[-1] < n:  # Generate the Fibonacci sequence up to the given number\n        fib.append(fib[-1] + fib[-2])\n\n    return fib[:-1]  # Remove the last element if it exceeds the given number\n\n# Example usage:\nn = 100\nfib_sequence = fibonacci(n)\nprint(fib_sequence)\nIn this implementation, the fibonacci function takes a positive integer n as input and returns the Fibonacci sequence up to the given number.\nWe initialize the Fibonacci sequence with the first two numbers, 0 and 1. Then, we continuously generate the next Fibonacci numbers by adding the last two numbers in the sequence until the last number in the sequence exceeds the given number n. Finally, we remove the last element from the sequence if it exceeds n.\nYou can test this function by providing your own positive integer n and calling the fibonacci function to calculate the Fibonacci sequence up to the given number. The resulting Fibonacci sequence will be stored in the fib_sequence variable and can be printed or used for further processing."
    },
    {
        "Input": "Write a program to find the largest prime palindrome less than a given number.",
        "Output": "Sure! Here's an example program in Python that finds the largest prime palindrome less than a given number:\npython\nCopy code\ndef is_prime(n):\n    if n < 2:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\n\ndef largest_prime_palindrome(limit):\n    for num in range(limit - 1, 0, -1):\n        if is_palindrome(num) and is_prime(num):\n            return num\n\n    return None\n\n\n# Example usage:\nlimit = 1000\nresult = largest_prime_palindrome(limit)\nprint(\"Largest prime palindrome less than\", limit, \"is:\", result)"
    },
    {
        "Input": "Create a Python class representing a self-balancing binary search tree (such as an AVL tree or a red-black tree) and implement methods to insert and search for nodes.",
        "Output": "Implementing a self-balancing binary search tree like an AVL tree or a red-black tree is a complex task that requires a detailed understanding of the underlying algorithms. It is beyond the scope of a single response here. However, I can provide you with a high-level overview of the steps involved and direct you to external resources where you can find detailed implementations.\nDefine a class for the binary search tree and a separate class for the tree nodes. Each node should store its key, value, left child, right child, and additional properties required for balancing.\nImplement the rotation operations for balancing the tree"
    },
    {
        "Input": "Implement a function to check if a given number is a perfect square without using any built-in functions.",
        "Output": "Sure! Here's an example implementation of a function to check if a given number is a perfect square without using any built-in functions:\npython\nCopy code\ndef"
    },
    {
        "Input": "Write a program to find the longest common substring of two given strings.",
        "Output": "Sure! Here's an example program in Python that finds the longest common substring of two given strings:\npython\nCopy code\ndef longest_common_substring(str1, str2):\n    m = len(str1)\n    n = len(str2)\n\n    # Create a table to store the lengths of common substrings\n    table = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Variables to keep track of the longest common substring and its length\n    max_length = 0\n    end_index = 0\n\n    # Fill the table using dynamic programming\n    for i in range(1, m + 1):\n        for"
    },
    {
        "Input": "Create a program to find the maximum XOR value of two numbers in a given list of integers.",
        "Output": "Sure! Here's an example program in Python that finds the maximum XOR value of two numbers in a given list of integers:\npython\nCopy code\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators with precedence.\"",
        "Output": "Certainly! Here's an example implementation of a function to check if a given string is a valid expression with balanced parentheses, brackets, and curly braces, allowing for nested expressions and operators with precedence:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    open_brackets = \"([{\"\n    close_brackets = \")]}\"\n    precedence = {\n        '+': 1,\n        '-': 1,\n        '*': 2,\n        '/': 2\n    }\n\n    for char in expression:\n        if char in open_brackets:\n            stack.append(char)\n        elif char in close_brackets:\n            if not stack or stack.pop() != open_brackets[close_brackets.index(char)]:\n                return False\n        elif char in precedence:\n           "
    },
    {
        "Input": "Write a Python class representing a trie (prefix tree) with support for efficient prefix search and word count.",
        "Output": "Certainly! Here's an example implementation of a Python class representing a Trie (prefix tree) with support for efficient prefix search and word count:\npython\nCopy code\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word_count = 0\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node ="
    },
    {
        "Input": "\"Create a program to find the number of distinct ways to climb a staircase with a given number of steps, where you can take either 1 or 2 steps at a time.\"",
        "Output": "Certainly! Here's an example program to find the number of distinct ways to climb a staircase with a given number of steps, where you can take either 1 or 2 steps at a time:\npython\nCopy code\ndef countDistinctWays(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        # Initialize the memoization table\n        memo = [0] * (n + 1)\n        # Set the base cases\n        memo[0] = 1\n        memo[1] = 1\n        # Compute the distinct ways using dynamic programming\n        for i in range(2, n + 1):\n            memo[i] = memo[i - 1] + memo[i - 2]\n        return memo[n]\n\n# Example usage:\nsteps = 5\ndistinct_ways = countDistinctWays(steps)\nprint(\"Number of distinct ways to climb\", steps, \"steps:\", distinct_ways)\nIn this program, the countDistinctWays function takes the number of steps n as input and returns the number of distinct ways to climb the staircase.\nWe"
    },
    {
        "Input": "Implement a function to check if a given number is a power of another number using logarithmic time complexity.",
        "Output": "Certainly! Here's an implementation of a function that checks if a given number is a power of another number using logarithmic time complexity:\npython\nCopy code\nimport math\n\ndef isPowerOfAnotherNumber(num, base):\n    if num <= 0 or base <= 1:\n        return False\n\n    power = math.log(num, base)\n    return math.isclose(power, round(power))\n\n# Example usage:\nnum = 16\nbase = 2\nprint(num, \"is a power of\", base, \":\", isPowerOfAnotherNumber(num, base))\n\nnum = 27\nbase = 3\nprint(num, \"is a power of\", base, \":\", isPowerOfAnotherNumber(num, base))\n\nnum"
    },
    {
        "Input": "Write a program to find the maximum area of a rectangle formed by histograms in a given list of heights.",
        "Output": "Certainly! Here's an example program to find the maximum area of a rectangle formed by histograms in a given list of heights:\npython\nCopy code\ndef findMaxRectangleArea(heights):\n    if not heights:\n        return 0\n\n    maxArea = 0\n    stack = []\n    i = 0\n\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            area = heights[top] * width\n            maxArea = max(maxArea, area)\n\n    while stack:\n        top = stack.pop()\n        width = i if not stack else len(heights) - stack[-1] - 1\n       "
    },
    {
        "Input": "Create a Python class representing a graph and implement methods to find the shortest path between two vertices using Dijkstra's algorithm.",
        "Output": "Certainly! Here's an example implementation of a Python class representing a graph and implementing Dijkstra's algorithm to find the shortest path between two vertices:\npython\nCopy code\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n\n    def add_vertex(self, vertex):\n        self.vertices[vertex] = {}\n\n    def add_edge(self, start, end, weight):\n        self.vertices[start][end] = weight\n        self.vertices[end][start] = weight\n\n    def dijkstra(self, start, end):\n        distances = {vertex: float('inf') for vertex in self.vertices}\n        distances[start] = 0\n\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n           "
    },
    {
        "Input": "Implement a function to find the longest increasing subsequence in a given list of integers using dynamic programming.",
        "Output": "Certainly! Here's an implementation of a function to find the longest increasing subsequence in a given list of integers using dynamic programming:\npython\nCopy code\ndef find_longest_increasing_subsequence(nums):\n    if not nums:\n        return []\n\n    n = len(nums)\n    dp = [1] * n  # Initialize the dp array with all elements as 1\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)  # Find the maximum length of the increasing subsequence\n    max_index = dp.index(max_length)  # Find the index of the last element in the longest subsequence\n\n    # Reconstruct the longest increasing subsequence\n    longest_subsequence = [nums[max_index]]\n   "
    },
    {
        "Input": "Write a program to find the number of unique BSTs (binary search trees) that can be formed with a given number of nodes.",
        "Output": "Sure! Here's a program to find the number of unique BSTs (binary search trees) that can be formed with a given number of nodes:\npython\nCopy code\ndef count_unique_bsts(n):\n    if n <= 1:\n        return 1\n\n    # Create a list to store the number of unique BSTs for each number of nodes\n    unique_bsts = [0] * (n + 1)\n    unique_bsts[0] = 1\n    unique_bsts[1] = 1\n\n    # Calculate the number of unique BSTs for each number of nodes from 2 to n\n    for num_nodes in range(2, n + 1):\n        for root in range(1, num_nodes + 1):\n            # Calculate the number of unique BSTs by considering each node as the root\n           "
    },
    {
        "Input": "Create a program to find the largest rectangular area of 1s in a binary matrix using stack-based approach.",
        "Output": "Certainly! Here's a program to find the largest rectangular area of 1s in a binary matrix using a stack-based approach:\npython\nCopy code\ndef largest_rectangle_area(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Calculate the histogram for each row of the matrix\n    histogram = [0] * cols\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                histogram[j] = 0\n            else:\n                histogram[j] += 1\n\n        area = largest_rectangle_area_in_histogram(histogram)\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef largest_rectangle_area_in_histogram(heights):\n    stack = []\n    max_area = 0\n   "
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and operators with precedence.\"",
        "Output": "Certainly! Here's an implementation of a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and operators with precedence:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_chars = '([{<\"'\n    closing_chars = ')]}>\"]'\n    operators = '+-*/'\n    escaped = False\n\n    for char in expression:\n        if escaped:\n            escaped = False\n            continue\n\n        if char == '\\\\':\n            escaped = True\n            continue\n\n        if char in opening_chars:\n            stack.append(char)\n        elif char in closing_chars:\n            if not stack or closing_chars.index(char) != opening_chars.index(stack.pop()):\n                return False\n        elif char in operators:\n            if not stack"
    },
    {
        "Input": "Write a Python class representing a Bloom filter with support for efficient insertion and membership check.",
        "Output": "Certainly! Here's an implementation of a Bloom filter in Python with support for efficient insertion and membership check:\npython\nCopy code\nimport mmh3\nfrom bitarray import bitarray\n\n\nclass BloomFilter:\n    def __init__(self, size, num_hash_functions):\n        self.size = size\n        self.num_hash_functions = num_hash_functions\n        self.bit_array = bitarray(size)\n        self.bit_array.setall(0)\n\n    def add(self, item):\n        for seed in range(self.num_hash_functions):\n            index = mmh3.hash(item, seed) % self.size\n           "
    },
    {
        "Input": "Create a program to find the number of distinct subsequences in a given string using dynamic programming.",
        "Output": "Certainly! Here's an implementation of a program to find the number of distinct subsequences in a given string using dynamic programming:\npython\nCopy code\ndef count_distinct_subsequences(s):\n    n = len(s)\n\n    # Create a table to store the number of distinct subsequences\n    dp = [0] * (n + 1)\n\n    # There is only one empty subsequence\n    dp[0] = 1\n\n    # Iterate through the characters of the string\n    for i in range(1, n + 1):\n        # Initialize the count for the current character\n        dp[i] = 1\n\n        # Find the index of the previous occurrence of the current character\n        for j in range(i - 1, -1, -1):\n            if s[j] == s[i - 1]:\n               "
    },
    {
        "Input": "Implement a function to check if a given number is a prime number using the Sieve of Eratosthenes algorithm.",
        "Output": "Certainly! Here's an implementation of a function to check if a given number is a prime number using the Sieve of Eratosthenes algorithm:\npython\nCopy code\ndef is_prime(n):\n    if n <= 1:\n        return False\n\n    # Create a boolean array to track prime numbers\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n\n    # Apply the Sieve of Eratosthenes algorithm\n    p = 2\n    while p * p <= n:\n        if is_prime[p]:\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n\n    return is_prime[n]\n\n\n# Example usage:\nnum = 17\nif"
    },
    {
        "Input": "\"Write a program to find the minimum number of jumps required to reach the end of a given list of integers, where each integer represents the maximum number of steps that can be jumped from that position.\"",
        "Output": "Certainly! Here's an implementation of a program to find the minimum number of jumps required to reach the end of a given list of integers:\npython\nCopy code\ndef min_jumps(nums):\n    n = len(nums)\n\n    # Create a table to store the minimum number of jumps\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    # Calculate the minimum number of jumps for each position\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                # If position j can reach position i,\n                # update"
    },
    {
        "Input": "Create a Python class representing a suffix tree with support for efficient substring search and longest common prefix.",
        "Output": "Certainly! Here's an implementation of a Python class representing a suffix tree with support for efficient substring search and longest common prefix:\npython\nCopy code\nclass SuffixTree:\n    class Node:\n        def __init__(self):\n            self.children = {}\n            self.suffix_link = None\n\n    def __init__(self, string):\n        self.string = string + '$'\n        self.root = self.Node()\n        self.build_suffix_tree()\n\n    def build_suffix_tree(self):\n        n = len(self.string)\n        active_node = self.root\n        active_edge = ''\n        active_length = 0\n        remaining_suffix_count = 0\n        last_created_node = None\n\n        for i in range(n):\n            remaining_suffix_count += 1\n            last_created_node = None\n\n            while remaining_suffix_count > 0:\n                if active_length == 0:\n                    active_edge = self.string[i]\n\n                if active_edge not in active_node.children:\n                    leaf_node = self"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, and slashes, allowing for nested expressions and custom operators, you can use a stack-based approach. Here's an implementation of the function:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    opening_brackets = ['(', '[', '{', '<']\n    closing_brackets = [')', ']', '}', '>']\n    quotes = ['\"', \"'\"]\n    operators = ['+', '-', '*', '/']\n    escaped = False\n\n    for char in expression:\n        if char == '\\\\':\n            escaped = True\n            continue\n\n        if escaped:\n            escaped = False\n            continue\n\n        if char in opening_brackets:\n            stack.append(char)\n       "
    },
    {
        "Input": "Write a program to find the maximum sum subarray in a given circular array using Kadane's algorithm.",
        "Output": "Sure! Here's a program that finds the maximum sum subarray in a given circular array using Kadane's algorithm:\npython\nCopy code\ndef kadane_algorithm(arr):\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\ndef max_sum_circular_subarray(arr):\n    max_sum_subarray = kadane_algorithm(arr)\n    total_sum = sum(arr)\n    min_sum_subarray = kadane_algorithm([-num for num in arr])\n\n    if total_sum == min_sum_subarray:\n        return max_sum_subarray\n\n    return max(max_sum_subarray, total_sum + min_sum_subarray)\n\n#"
    },
    {
        "Input": "\"Create a program to find the number of distinct ways to decode a given string of digits into alphabets, where A=1, B=2, etc.\"",
        "Output": "Certainly! Here's a program to find the number of distinct ways to decode a given string of digits into alphabets:\npython\nCopy code\ndef num_decodings(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n    \n    for i in range(2, n + 1):\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n            \n        two_digit = int(s[i-2:i])\n        if 10 <= two_digit <= "
    },
    {
        "Input": "Implement a function to find the longest common subsequence of three given strings using dynamic programming.",
        "Output": "Certainly! Here's an implementation of a function to find the longest common subsequence of three given strings using dynamic programming:\npython\nCopy code\ndef longest_common_subsequence(str1, str2, str3):\n    m, n, o = len(str1), len(str2), len(str3)\n    dp = [[[0 for _ in range(o+1)] for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            for k in range(1, o+1):\n                if str1[i-1] == str2[j-1] == str3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n\n    return dp[m][n][o]\n\n# Example usage\nstr1 ="
    },
    {
        "Input": "\"Write a Python class representing a skip list and implement methods to insert, search, and remove elements efficiently.\"",
        "Output": "Certainly! Here's an implementation of a SkipList class in Python with methods to insert, search, and remove elements efficiently:\npython\nCopy code\nimport random\n\nclass Node:\n    def __init__(self, val=None):\n        self.val = val\n        self.next = []\n        \nclass SkipList:\n    def __init__(self):\n        self.head = Node()\n        self.max_level = 1\n        \n    def random_level(self):\n        level = 1\n        while random.random() < 0.5 and level < self.max_level + 1:\n            level += 1\n        return level\n    \n    def insert(self, val):\n        level = self.random_level()\n        if level > self.max_level:\n            self.max_level = level\n            self.head.next.extend([None] * (level - self.max_level))\n        \n        new_node = Node(val)\n        cur = self.head\n        \n       "
    },
    {
        "Input": "\"Create a program to find the minimum number of coins needed to make a given amount of change, with an infinite supply of each coin denomination, while minimizing the total number of coins.\"",
        "Output": "Certainly! Here's a program to find the minimum number of coins needed to make a given amount of change using a greedy algorithm:\npython\nCopy code\ndef minCoins(coins, amount):\n    coins.sort(reverse=True)  # Sort the coins in descending order\n    \n    numCoins = 0\n    for coin in coins:\n        numCoins += amount // coin  # Add the number of coins of this denomination to the total\n        amount %= coin  # Reduce the amount by the value of coins used so far\n        \n    if amount != 0:\n        return -1  # It is not possible to make exact change\n        \n    return numCoins\n\n# Example usage\ncoins = [1, 5, 10, 25]  # Available coin denominations\namount = 47  # Desired amount of change\nresult = minCoins(coins, amount)\nprint"
    },
    {
        "Input": "Implement a function to find the longest increasing subarray with at most K distinct integers in a given list of integers using a sliding window approach.",
        "Output": "Certainly! Here's an implementation of the function find_longest_increasing_subarray that uses a sliding window approach to find the longest increasing subarray with at most K distinct integers in a given list of integers:\npython\nCopy code\ndef find_longest_increasing_subarray(nums, k):\n    if k == 0:\n        return []\n\n    start = 0\n    longest_subarray = []\n    distinct_count = 0\n    distinct_integers = {}\n\n    for end in range(len(nums)):\n        num = nums[end]\n\n        if num not in distinct_integers:\n            distinct_count += 1\n            distinct_integers[num] = 0\n\n        distinct_integers[num] += 1\n\n        while distinct_count > k:\n            left_num = nums[start]\n\n            distinct_integers[left_num] -= 1\n            if distinct_integers[left_num] == 0:\n                del distinct_integers[left_num]\n                distinct_count -= 1\n\n            start += 1\n\n       "
    },
    {
        "Input": "Write a program to find the median of two sorted arrays of equal size in logarithmic time complexity.",
        "Output": "To find the median of two sorted arrays of equal size in logarithmic time complexity, you can use a modified binary search approach. Here's an implementation of the program:\npython\nCopy code\ndef find_median_sorted_arrays(nums1, nums2):\n    m = len(nums1)\n    n = len(nums2)\n    \n    if m != n:\n        raise ValueError(\"Input arrays must have equal size.\")\n    \n    # Merge the two sorted arrays\n    merged = []\n    i = j = 0\n    \n    while i < m and j < n:\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    \n    while i < m:\n        merged.append(nums1[i])\n        i += 1\n    \n    while j < n:\n       "
    },
    {
        "Input": "Create a Python class representing a quadtree and implement methods to insert and search for points efficiently.",
        "Output": "Certainly! Here's an implementation of a Quadtree class in Python that supports efficient insertion and searching of points:\npython\nCopy code\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass QuadtreeNode:\n    def __init__(self, x, y, width, height):\n        self.x = x\n        self.y = y\n        self.width = width"
    },
    {
        "Input": "\"Implement a function to check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, slashes, and custom operators, allowing for nested expressions and operator precedence.\"",
        "Output": "To check if a given string is a valid expression with balanced parentheses, brackets, curly braces, quotes, angle brackets, slashes, and custom operators, allowing for nested expressions and operator precedence, you can use a stack-based approach. Here's an example implementation in Python:\npython\nCopy code\ndef is_valid_expression(expression):\n    stack = []\n    open_chars = \"([{<\\\"\\'/\"\n    close_chars = \")]}>\\\"\\'/\"\n    operators = {\"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2, \"^\": 3}  # Example operators and their precedence\n\n    for char in expression:\n        if char in open_chars:\n            stack.append(char)\n        elif char in close_chars:\n            if not"
    },
    {
        "Input": "Write a program to find the maximum product of a subarray in a given list of integers.",
        "Output": "To find the maximum product of a subarray in a given list of integers, you can use a dynamic programming approach. Here's an example program in Python:\npython\nCopy code\ndef max_product_subarray(nums):\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    global_max = max_product\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            # Swap max_product and min_product since negative number flips the sign\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i],"
    },
    {
        "Input": "Create a program to find the longest increasing subsequence in a given list of integers using binary search.",
        "Output": "To find the longest increasing subsequence in a given list of integers using binary search, you can follow a dynamic programming approach. Here's an example program in Python:\npython\nCopy code\ndef longest_increasing_subsequence(nums):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n  # Initialize a list of length n with all elements as 1\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\nIn this program, we create a dynamic programming table dp to keep track of the longest increasing subsequence ending at each index i in the given list nums. We initialize all elements of dp as"
    },
    {
        "Input": "Implement a function to calculate the Levenshtein distance between two strings using dynamic programming.",
        "Output": "Certainly! Here's an implementation of a function to calculate the Levenshtein distance between two strings using dynamic programming in Python:\npython\nCopy code\ndef levenshtein_distance(str1, str2):\n    m = len(str1)\n    n = len(str2)\n\n    # Create a 2D matrix to store the distances\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize the first row and column\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Calculate the distances for the rest of the matrix\n    for i in range(1, m + 1):\n        for j in range(1, n + 1"
    },
    {
        "Input": "\"Write a Python class representing an interval tree and implement methods to insert, search, and remove intervals efficiently.\"",
        "Output": "Certainly! Here's an implementation of a Python class representing an interval tree with methods for inserting, searching, and removing intervals efficiently:\npython\nCopy code\nclass IntervalTreeNode:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.max_end = end\n        self.left = None\n        self.right = None\n\n\nclass IntervalTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, start, end):\n        self.root = self._insert_helper(self.root, start, end)\n\n    def _insert_helper(self, node, start, end):\n        if node is None:\n            return IntervalTreeNode(start, end)\n\n        if start < node.start:\n            node.left = self._insert_helper(node.left, start, end"
    },
    {
        "Input": "Create a program to find the maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive.",
        "Output": "Certainly! Here's a program to find the maximum sum of a subarray with the constraint that no three elements in the subarray are consecutive:\npython\nCopy code\ndef max_sum_with_constraint(arr):\n    n = len(arr)\n\n    if n <= 2:\n        return sum(arr)\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = arr[0] + arr[1]\n\n    for i in range(2, n):\n        dp[i] = max(arr[i] + dp[i - 2], arr[i] + dp[i - 3], dp[i - 1])\n\n    return max(dp[-1], dp[-2])\n\n\n# Example usage:\narr = [3, 7, 4, 2, 8, 5]\nmax_sum = max_sum_with_constraint(arr)\nprint"
    }
]